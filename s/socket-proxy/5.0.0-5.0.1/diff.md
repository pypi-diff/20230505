# Comparing `tmp/socket_proxy-5.0.0-py3-none-any.whl.zip` & `tmp/socket_proxy-5.0.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,21 @@
-Zip file size: 30977 bytes, number of entries: 19
--rw-r--r--  2.0 unx      240 b- defN 23-Apr-20 16:54 socket_proxy/__init__.py
--rw-r--r--  2.0 unx    14803 b- defN 23-Apr-20 16:54 socket_proxy/__main__.py
--rw-r--r--  2.0 unx     3314 b- defN 23-Apr-20 16:54 socket_proxy/api.py
--rw-r--r--  2.0 unx     3096 b- defN 23-Apr-20 16:54 socket_proxy/base.py
--rw-r--r--  2.0 unx     2392 b- defN 23-Apr-20 16:54 socket_proxy/connection.py
--rw-r--r--  2.0 unx     2083 b- defN 23-Apr-20 16:54 socket_proxy/event.py
--rw-r--r--  2.0 unx    12017 b- defN 23-Apr-20 16:54 socket_proxy/package.py
--rw-r--r--  2.0 unx    11836 b- defN 23-Apr-20 16:54 socket_proxy/proxy.py
--rw-r--r--  2.0 unx     6616 b- defN 23-Apr-20 16:54 socket_proxy/tunnel.py
--rw-r--r--  2.0 unx     7307 b- defN 23-Apr-20 16:54 socket_proxy/tunnel_client.py
--rw-r--r--  2.0 unx     4543 b- defN 23-Apr-20 16:54 socket_proxy/tunnel_gui.py
--rw-r--r--  2.0 unx     7937 b- defN 23-Apr-20 16:54 socket_proxy/tunnel_server.py
--rw-r--r--  2.0 unx    11183 b- defN 23-Apr-20 16:54 socket_proxy/utils.py
--rw-r--r--  2.0 unx     1085 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     3933 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/WHEEL
--rw-r--r--  2.0 unx       60 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       13 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1560 b- defN 23-Apr-20 16:55 socket_proxy-5.0.0.dist-info/RECORD
-19 files, 94110 bytes uncompressed, 28443 bytes compressed:  69.8%
+Zip file size: 31079 bytes, number of entries: 19
+-rw-r--r--  2.0 unx      240 b- defN 23-May-05 17:41 socket_proxy/__init__.py
+-rw-r--r--  2.0 unx    14801 b- defN 23-May-05 17:41 socket_proxy/__main__.py
+-rw-r--r--  2.0 unx     3309 b- defN 23-May-05 17:41 socket_proxy/api.py
+-rw-r--r--  2.0 unx     3103 b- defN 23-May-05 17:41 socket_proxy/base.py
+-rw-r--r--  2.0 unx     2392 b- defN 23-May-05 17:41 socket_proxy/connection.py
+-rw-r--r--  2.0 unx     2083 b- defN 23-May-05 17:41 socket_proxy/event.py
+-rw-r--r--  2.0 unx    12017 b- defN 23-May-05 17:41 socket_proxy/package.py
+-rw-r--r--  2.0 unx    11808 b- defN 23-May-05 17:41 socket_proxy/proxy.py
+-rw-r--r--  2.0 unx     6619 b- defN 23-May-05 17:41 socket_proxy/tunnel.py
+-rw-r--r--  2.0 unx     7302 b- defN 23-May-05 17:41 socket_proxy/tunnel_client.py
+-rw-r--r--  2.0 unx     4789 b- defN 23-May-05 17:41 socket_proxy/tunnel_gui.py
+-rw-r--r--  2.0 unx     7920 b- defN 23-May-05 17:41 socket_proxy/tunnel_server.py
+-rw-r--r--  2.0 unx    11178 b- defN 23-May-05 17:41 socket_proxy/utils.py
+-rw-r--r--  2.0 unx     1085 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3933 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       60 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       13 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1560 b- defN 23-May-05 17:42 socket_proxy-5.0.1.dist-info/RECORD
+19 files, 94304 bytes uncompressed, 28545 bytes compressed:  69.7%
```

## zipnote {}

```diff
@@ -33,26 +33,26 @@
 
 Filename: socket_proxy/tunnel_server.py
 Comment: 
 
 Filename: socket_proxy/utils.py
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/LICENSE
+Filename: socket_proxy-5.0.1.dist-info/LICENSE
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/METADATA
+Filename: socket_proxy-5.0.1.dist-info/METADATA
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/WHEEL
+Filename: socket_proxy-5.0.1.dist-info/WHEEL
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/entry_points.txt
+Filename: socket_proxy-5.0.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/top_level.txt
+Filename: socket_proxy-5.0.1.dist-info/top_level.txt
 Comment: 
 
-Filename: socket_proxy-5.0.0.dist-info/RECORD
+Filename: socket_proxy-5.0.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## socket_proxy/__init__.py

```diff
@@ -2,8 +2,8 @@
 from .connection import Connection
 from .package import *
 from .proxy import ProxyServer
 from .tunnel import Tunnel
 from .tunnel_client import TunnelClient
 from .tunnel_server import TunnelServer
 
-VERSION = "5.0.0"
+VERSION = "5.0.1"
```

## socket_proxy/__main__.py

```diff
@@ -406,15 +406,15 @@
         return parsed
     return parser.parse_with_config(args, dict(cp.items(parsed.mode)))
 
 
 def run_client(no_curses: bool) -> None:
     for arg in ["ca", "connect", "dst"]:
         if not getattr(base.config, arg, False):
-            _logger.critical("Missing --%s argument", arg)
+            _logger.critical(f"Missing --{arg} argument")
             sys.exit(1)
 
     cls = TunnelClient if no_curses else GUIClient
 
     cli = cls(
         *base.config.connect,
         *base.config.dst,
@@ -426,15 +426,15 @@
     )
     cli.start()
 
 
 def run_server() -> None:
     for arg in ["cert", "key"]:
         if not getattr(base.config, arg, False):
-            _logger.critical("Missing --%s argument", arg)
+            _logger.critical(f"Missing --{arg} argument")
             sys.exit(1)
 
     server = ProxyServer(
         *base.config.listen,
         ca=base.config.ca,
         cert=base.config.cert,
         key=base.config.key,
```

## socket_proxy/api.py

```diff
@@ -79,15 +79,15 @@
         extras = [
             "tls" if self.api_type == APIType.Server and self.api_ssl else "",
             "token" if self.api_token else "",
         ]
         extras = sorted(filter(None, extras))
         extras = f"[{','.join(extras)}]" if extras else ""
 
-        _logger.info("Starting API on %s:%s %s", self.api_host, self.api_port, extras)
+        _logger.info(f"Starting API on {self.api_host}:{self.api_port} {extras}")
         self.api = web.Application()
         self.api.add_routes(
             [
                 web.get(r"/{name:.*}", self._api_index),
                 web.delete(r"/{name:.*}", self._api_delete),
             ]
         )
```

## socket_proxy/base.py

```diff
@@ -72,15 +72,15 @@
 
 class ProtocolType(enum.IntEnum):
     """Helper class for supported protocols"""
 
     TCP = 0x01
     HTTP = 0x02
 
-    def __str__(self):
+    def __str__(self) -> str:
         return {
             ProtocolType.TCP: "TCP",
             ProtocolType.HTTP: "HTTP",
         }[self.value]
 
     @staticmethod
     def from_str(protocol: str) -> TypeVar("ProtocolType"):
```

## socket_proxy/proxy.py

```diff
@@ -122,19 +122,16 @@
     def generate_token(self, hotp: bool = False) -> str:
         """Generate a new authentication token"""
         if not self.authentication:
             return None
 
         token = str(uuid.uuid4())
         self.tokens[token] = None if hotp else datetime.now()
-        _logger.info(
-            "Generated authentication token %s [%s]",
-            token,
-            "hotp" if hotp else "totp",
-        )
+        ttype = "hotp" if hotp else "totp"
+        _logger.info(f"Generated authentication token {token} [{ttype}]")
         self.event.send_nowait(msg="token_generate", token=token, hotp=bool(hotp))
         self._persist_state()
         return token
 
     async def _api_handle(self, path: Tuple[str], request: api.Request) -> Any:
         """Handle api functions"""
         if ("token", "hotp") == path[:2]:
```

## socket_proxy/tunnel.py

```diff
@@ -50,15 +50,15 @@
     def token(self) -> str:
         return self.tunnel.token
 
     @property
     def uuid(self) -> str:
         return self.tunnel.uuid
 
-    def get_config_dict(self):
+    def get_config_dict(self) -> dict:
         """Return the configuration as a dictionary used in the API or client"""
         return {
             "bantime": self.bantime or None,
             "chunk_size": self.chunk_size,
             "idle_timeout": self.idle_timeout or None,
             "max_clients": self.max_clients or None,
             "max_connects": self.max_connects or None,
@@ -100,18 +100,18 @@
             "traffic": {
                 "bytes_in": bytes_in,
                 "bytes_out": bytes_out,
             },
         }
 
     def info(self, msg: str, *args) -> None:
-        _logger.info("Tunnel %s " + msg, self.uuid, *args)
+        _logger.info(f"Tunnel {self.uuid} {msg}", *args)
 
     def error(self, msg: str, *args) -> None:
-        _logger.error("Tunnel %s " + msg, self.uuid, *args)
+        _logger.error(f"Tunnel {self.uuid} {msg}", *args)
 
     def add(self, client: Connection) -> None:
         if client.token in self.clients:
             return
 
         if 0 < self.max_clients <= len(self.clients):
             raise base.ReachedClientLimit()
@@ -143,15 +143,15 @@
     async def _disconnect_client(self, token: bytes) -> None:
         """Disconnect a client"""
         client = self.pop(token)
         if client:
             # Store the traffic information from the disconnecting clients
             self.bytes_in += client.bytes_in
             self.bytes_out += client.bytes_out
-            _logger.info("Client %s disconnected", token.hex())
+            _logger.info(f"Client {token.hex()} disconnected")
             await client.close()
 
     async def idle(self) -> None:
         """This methods will get called regularly to apply timeouts"""
         if self.idle_timeout and self.tunnel:
             if time.time() - self.tunnel.last_time > self.idle_timeout:
                 self.info("timeout")
```

## socket_proxy/tunnel_client.py

```diff
@@ -59,28 +59,28 @@
             await self.stop()
             return
 
         # Send a ping regularly
         self.last_ping = time.time()
         await self.tunnel.tun_write(package.PingPackage(self.last_ping))
 
-    def _check_alive(self):
+    def _check_alive(self) -> bool:
         """Check if the connection is alive using the last ping"""
 
         if self.last_ping is None or self.last_pong is None:
             return True
 
         if abs(self.last_pong - self.last_ping) <= base.INTERVAL_TIME:
             return True
 
         return False
 
     async def _client_loop(self, client: Connection) -> None:
         """This is the main client loop"""
-        _logger.info("Client %s connected", client.token.hex())
+        _logger.info(f"Client {client.token.hex()} connected")
         while True:
             data = await client.read(self.chunk_size)
             if not data:
                 await self._disconnect_client(client.token)
                 break
 
             try:
@@ -164,15 +164,15 @@
         # Manage data coming through the tunnel
         if isinstance(pkg, package.ClientDataPackage):
             await self._send_data(pkg)
             return True
 
         # Something unexpected happened
         if pkg is not None:
-            self.error("invalid package: %s", pkg)
+            self.error(f"invalid package: {pkg}")
             return await super()._handle()
 
         return await super()._handle()
 
     async def disconnect(self, *uuids: Tuple[str]) -> bool:
         """Disconnect a specific client"""
         if len(uuids) < 1:
@@ -186,16 +186,16 @@
         return False
 
     async def loop(self) -> None:
         """Main client loop of the client side of the tunnel"""
         self.tunnel = await Connection.connect(self.host, self.port, ssl=self.sc)
         ssl_obj = self.tunnel.writer.get_extra_info("ssl_object")
         extra = f" [{ssl_obj.version()}]" if ssl_obj else ""
-        _logger.info("Tunnel %s:%s connected%s", self.host, self.port, extra)
-        _logger.info("Forwarding to %s:%s", self.dst_host, self.dst_port)
+        _logger.info(f"Tunnel {self.host}:{self.port} connected{extra}")
+        _logger.info(f"Forwarding to {self.dst_host}:{self.dst_port}")
 
         if self.api_port:
             asyncio.create_task(self.start_api())
 
         try:
             # Start the tunnel and send the initial package
             self.running = True
@@ -210,13 +210,13 @@
 
             pkg = package.ConnectPackage(self.protocol)
             await self.tunnel.tun_write(pkg)
             await self._serve()
         finally:
             self.running = False
             await self.stop()
-            _logger.info("Tunnel %s:%s closed", self.host, self.port)
+            _logger.info(f"Tunnel {self.host}:{self.port} closed")
 
     def start(self) -> None:
         """Start the client and the event loop"""
         _logger.info("Starting client...")
         asyncio.run(self.loop())
```

## socket_proxy/tunnel_gui.py

```diff
@@ -1,14 +1,14 @@
 import curses
 import logging
 import queue
 from logging.handlers import QueueHandler
 from typing import List
 
-from .base import LOG_FORMAT, InternetType
+from .base import LOG_FORMAT, InternetType, IPvXAddress
 from .tunnel_client import TunnelClient
 from .utils import format_transfer
 
 _logger = logging.getLogger(__name__)
 
 
 class GUIClient(TunnelClient):
@@ -29,14 +29,19 @@
         self.log_handler.setFormatter(logging.Formatter(LOG_FORMAT, style="{"))
         logging.getLogger().handlers = [self.log_handler]
 
     def get_dimension(self) -> None:
         """Get the dimensions of the current window"""
         self.height, self.width = self.scr.getmaxyx()
 
+    # pylint: disable=W0613,R0201
+    def fmt_port(self, ip_type: InternetType, ip: IPvXAddress, port: int) -> str:
+        """Format an address"""
+        return f"{ip}:{port}" if ip else str(port)
+
     def _draw(self) -> None:
         """Draw all GUI elements"""
         self.scr.clear()
         self._draw_config()
         self._draw_info()
         self._draw_log()
 
@@ -111,27 +116,28 @@
         self.logs = self.logs[-h - 2 :]
 
         self._draw_lines(win, self.logs)
 
         win.refresh()
         return win
 
-    def _draw_lines(self, win, lines: List[str]) -> None:  # pylint: disable=R0201
+    # disable: pylint=R0201
+    def _draw_lines(self, win: curses.window, lines: List[str]) -> None:
         """Draw multiple lines in a window with some border"""
         h, w = [k - 2 for k in win.getmaxyx()]
         for y, line in enumerate(lines[:h]):
             win.addstr(y + 1, 2, line[:w])
 
     async def _handle(self) -> bool:
         """Handle the drawing after each package"""
         self.get_dimension()
         self._draw()
         return await super()._handle()
 
-    def _gui(self, scr) -> None:
+    def _gui(self, scr: curses.window) -> None:
         """Configure the main screen"""
         self.scr = scr
         curses.noecho()
         curses.curs_set(0)
 
         super().start()
```

## socket_proxy/tunnel_server.py

```diff
@@ -54,15 +54,15 @@
         await super().idle()
 
         # Clear the connections
         dt = datetime.now() - timedelta(seconds=self.bantime)
         for ip, ban in list(self.connections.items()):
             if ban.first < dt:
                 self.connections.pop(ip)
-                _logger.info("Connection number of %s resetted", ip)
+                _logger.info(f"Connection number of {ip} resetted")
 
     async def _client_accept(
         self,
         reader: StreamReader,
         writer: StreamWriter,
         read_ahead: bytes = None,
     ) -> None:
@@ -72,25 +72,25 @@
 
         # Block connections using the networks
         if self.block(ip):
             reader.feed_eof()
             writer.close()
             await writer.wait_closed()
 
-            _logger.info("Connection from %s blocked", ip)
+            _logger.info(f"Connection from {ip} blocked")
             await self.event.send(msg="client_blocked", tunnel=self.uuid, ip=str(ip))
             return
 
         self.connections[ip].hits += 1
 
         # Create the client object and generate an unique token
         client = Connection(reader, writer, self.protocol, utils.generate_token())
         self.add(client)
 
-        _logger.info("Client %s connected on %s:%s", client.uuid, host, port)
+        _logger.info(f"Client {client.uuid} connected on {host}:{port}")
         await self.event.send(
             msg="client_connect",
             tunnel=self.uuid,
             client=client.uuid,
         )
 
         # Inform the tunnel about the new client
@@ -145,15 +145,15 @@
 
     async def _client_loop(self) -> None:
         """Main client loop initializing the client and managing the transmission"""
         self.addr = [sock.getsockname()[:2] for sock in self.server.sockets]
 
         # Initialize the tunnel by sending the appropiate data
         out = " ".join(sorted(f"{host}:{port}" for host, port in self.addr))
-        self.info("Listen on %s", out)
+        self.info(f"Listen on {out}")
 
         addr = [(base.InternetType.from_ip(ip), ip, port) for ip, port in self.addr]
         pkg = package.InitPackage(self.token, addr, self.domain)
         await self.tunnel.tun_write(pkg)
 
         # Start listening
         async with self.server:
@@ -164,18 +164,18 @@
         # Start the server
         if isinstance(pkg, package.ConnectPackage):
             self.protocol = pkg.protocol
             if self.protocol not in self.protocols:
                 self.error(f"Disabled protocol {self.protocol.name}")
                 return False
 
-            self.info("Using protocol: %s", self.protocol.name)
+            self.info(f"Using protocol: {self.protocol.name}")
 
             if self.protocol != base.ProtocolType.TCP:
-                self.info("Reachable with domain: %s", self.domain)
+                self.info(f"Reachable with domain: {self.domain}")
                 pkg = package.InitPackage(self.token, [], self.domain)
                 await self.tunnel.tun_write(pkg)
             elif not await self._open_server():
                 return await super()._handle()
 
             return True
 
@@ -195,24 +195,24 @@
             await self._disconnect_client(pkg.token)
             return True
 
         # Handle data coming through the tunnel
         if isinstance(pkg, package.ClientDataPackage):
             # Check for valid tokens
             if pkg.token not in self:
-                self.error("Invalid client token: %s", pkg.token)
+                self.error(f"Invalid client token: {pkg.token}")
                 return False
 
             conn = self[pkg.token]
             await conn.write(pkg.data)
             return True
 
         # Invalid package means to close the connection
         if pkg is not None:
-            self.error("Invalid package: %s", pkg)
+            self.error(f"Invalid package: {pkg}")
             return await super()._handle()
 
         return await super()._handle()
 
     async def stop(self) -> None:
         """Stop everything"""
         await super().stop()
@@ -223,13 +223,13 @@
 
         self.info("closed")
 
     async def loop(self) -> None:
         """Main loop of the proxy tunnel"""
         ssl_obj = self.tunnel.writer.get_extra_info("ssl_object")
         extra = f" [{ssl_obj.version()}]" if ssl_obj else ""
-        self.info("Connected %s:%s%s", self.host, self.port, extra)
+        self.info(f"Connected {self.host}:{self.port}{extra}")
 
         try:
             await self._serve()
         finally:
             await self.stop()
```

## socket_proxy/utils.py

```diff
@@ -152,22 +152,22 @@
         ctx.load_verify_locations(cafile=crl)
 
     # Set possible ciphers to use
     if ciphers:
         ctx.set_ciphers(ciphers)
 
     # Output debugging
-    _logger.info("CA usage: %s", bool(ca))
-    _logger.info("Certificate: %s", bool(cert))
-    _logger.info("Hostname verification: %s", bool(check_hostname))
+    _logger.info(f"CA usage: {bool(ca)}")
+    _logger.info(f"Certificate: {bool(cert)}")
+    _logger.info(f"Hostname verification: {bool(check_hostname)}")
     # pylint: disable=no-member
-    _logger.info("Minimal TLS Version: %s", ctx.minimum_version.name)
+    _logger.info(f"Minimal TLS Version: {ctx.minimum_version.name}")
 
     ciphers = sorted(c["name"] for c in ctx.get_ciphers())
-    _logger.info("Ciphers: %s", ", ".join(ciphers))
+    _logger.info(f"Ciphers: {', '.join(ciphers)}")
 
     return ctx
 
 
 def get_unused_port(min_port: int, max_port: int, udp: bool = False) -> int:
     """Returns a random unused port within the given range or None if all are used"""
     sock = socket.socket(type=socket.SOCK_DGRAM) if udp else socket.socket()
```

## Comparing `socket_proxy-5.0.0.dist-info/LICENSE` & `socket_proxy-5.0.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `socket_proxy-5.0.0.dist-info/METADATA` & `socket_proxy-5.0.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: socket-proxy
-Version: 5.0.0
+Version: 5.0.1
 Summary: Proxy TCP ports of local systems
 Home-page: https://github.com/fkantelberg/socket-proxy
 Author: Florian Kantelberg
 Author-email: florian.kantelberg@mailbox.org
 License: MIT
 Keywords: proxy socket network
 Classifier: License :: OSI Approved :: MIT License
```

## Comparing `socket_proxy-5.0.0.dist-info/RECORD` & `socket_proxy-5.0.1.dist-info/RECORD`

 * *Files 19% similar despite different names*

```diff
@@ -1,19 +1,19 @@
-socket_proxy/__init__.py,sha256=Ux1sa2Qolib40f7QdZ1KYbarMIxfinnh0zLhMj7dMY4,240
-socket_proxy/__main__.py,sha256=b4hz5GBrIKObPt3Fw_l3c3f4P-iZJfAPncCy-_CxYxU,14803
-socket_proxy/api.py,sha256=HstlCAewf-eNak-CpMV1wt5obmVljWHKQeeULwfavCU,3314
-socket_proxy/base.py,sha256=Ec-FnKHQAlHoG60qiUL3shOQJdYs3qZ64RMw3eOD-aE,3096
+socket_proxy/__init__.py,sha256=QtnKXK-Ec0bgwgQ4zda2yHdLb_NJE0q81VgeJLCUNbo,240
+socket_proxy/__main__.py,sha256=N3iv7IWasNtBPpRHGNi5xzojQYS9xMQb-tF3vxrGTR4,14801
+socket_proxy/api.py,sha256=YtJ9mhELDkaJS68t-66aoWiWvMiV-54MI8Fla1g9EQ4,3309
+socket_proxy/base.py,sha256=M8Dz_pEdujRXQFmM1c4QiMwJ3EIAR72puHcsm-Xvju0,3103
 socket_proxy/connection.py,sha256=XIg8HzNJ6kskjrDk0e15X-QLZrfyorefMfmQODT5U9c,2392
 socket_proxy/event.py,sha256=06Rb7g04x9ejISkFq6soPU6GGx0FvBa2ldLi--TPUNA,2083
 socket_proxy/package.py,sha256=e-rs0Y9h_Z7XudsxCmI_usA57smCxhrA1M1h41jAY3A,12017
-socket_proxy/proxy.py,sha256=w_Kt2BqH1OxXmvBVykjdJXDumlnYFLzqm4Xi_j023ig,11836
-socket_proxy/tunnel.py,sha256=6A_EgKzLeET62CiIT90UOocS2UNZC5hy43cWNVLNLKk,6616
-socket_proxy/tunnel_client.py,sha256=ucPDvhUHxkh_-75reyG0kMZIic5AAh8u7hU_ukkhdgc,7307
-socket_proxy/tunnel_gui.py,sha256=U6XBxpi3VOFDS6oy46Tz1F9nXTDgSBpkhbeWfRf8yXI,4543
-socket_proxy/tunnel_server.py,sha256=4zei7MUsguRBgiZqeT6Kr-navz6fCkzcCdBF7mdBkao,7937
-socket_proxy/utils.py,sha256=Vz9CPdkTXgrPxMqzOZp2asfrPiCqK1IXY4peqwtzSFo,11183
-socket_proxy-5.0.0.dist-info/LICENSE,sha256=2uv3FXpGSeGfn8IfQfoIC6H2ERGw0jizs1HaWgYDMP4,1085
-socket_proxy-5.0.0.dist-info/METADATA,sha256=_iuIJEYG-5B29qqoHZ1zkaWGnZf9LQNZak-u-OnlH8M,3933
-socket_proxy-5.0.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-socket_proxy-5.0.0.dist-info/entry_points.txt,sha256=sXzDQVeWk-cGEVpzGuIw9FKUa8RSt2rwoAW3C4toTQ4,60
-socket_proxy-5.0.0.dist-info/top_level.txt,sha256=W6iccuTFPJ_pC8hSANVYhKj446G5xcTiZO2bT4vPKWg,13
-socket_proxy-5.0.0.dist-info/RECORD,,
+socket_proxy/proxy.py,sha256=fGKxxGyUIPGFWvrV1Jp25atkB8ANmmAxhup7UZZ6cAA,11808
+socket_proxy/tunnel.py,sha256=_iBjGcUvOR-q5wC98DEzWVU6BO4ix5_CSk8XIi5K5wc,6619
+socket_proxy/tunnel_client.py,sha256=t-AjZtGA3CL1KZsVCFq_7bB6raFq6WQTigCNZxrwHKo,7302
+socket_proxy/tunnel_gui.py,sha256=TTlnkzLarCRrL9CPOgeqmqQ5dx4qScWUGfeuDz1eU08,4789
+socket_proxy/tunnel_server.py,sha256=sid1Fe3U4BZnwJgyrLloCOk3etuT1bxwVJ6r_NJ6z3E,7920
+socket_proxy/utils.py,sha256=-KRaMTpGbOs-QmH-2PWSdaHK6SIAGq4uqqHtSu7Y69w,11178
+socket_proxy-5.0.1.dist-info/LICENSE,sha256=2uv3FXpGSeGfn8IfQfoIC6H2ERGw0jizs1HaWgYDMP4,1085
+socket_proxy-5.0.1.dist-info/METADATA,sha256=QYvdT9ZE4u7H6qF4_ZAfEmF8chhEU0BXXHBfGE3YgWc,3933
+socket_proxy-5.0.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+socket_proxy-5.0.1.dist-info/entry_points.txt,sha256=sXzDQVeWk-cGEVpzGuIw9FKUa8RSt2rwoAW3C4toTQ4,60
+socket_proxy-5.0.1.dist-info/top_level.txt,sha256=W6iccuTFPJ_pC8hSANVYhKj446G5xcTiZO2bT4vPKWg,13
+socket_proxy-5.0.1.dist-info/RECORD,,
```

