# Comparing `tmp/lofar-h5plot-2.6.2.tar.gz` & `tmp/lofar-h5plot-2.7.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/frits/software/lofar-h5plot/dist/.tmp-l3kq72pu/lofar-h5plot-2.6.2.tar", last modified: Tue Apr 11 14:55:23 2023, max compression
+gzip compressed data, was "lofar-h5plot-2.7.0.tar", last modified: Fri May  5 12:02:10 2023, max compression
```

## Comparing `lofar-h5plot-2.6.2.tar` & `lofar-h5plot-2.7.0.tar`

### file list

```diff
@@ -1,15 +1,15 @@
-drwxr-xr-x   0 frits     (1000) frits     (1000)        0 2023-04-11 14:55:23.901579 lofar-h5plot-2.6.2/
--rw-rw-r--   0 frits     (1000) frits     (1000)    35149 2019-03-06 15:44:49.000000 lofar-h5plot-2.6.2/LICENSE
--rw-r--r--   0 frits     (1000) frits     (1000)     1857 2023-04-11 14:55:23.901579 lofar-h5plot-2.6.2/PKG-INFO
--rw-rw-r--   0 frits     (1000) frits     (1000)     1329 2022-11-09 14:32:41.000000 lofar-h5plot-2.6.2/README.md
--rwxrwxr-x   0 frits     (1000) frits     (1000)    55648 2023-04-11 14:52:49.000000 lofar-h5plot-2.6.2/h5plot
-drwxr-xr-x   0 frits     (1000) frits     (1000)        0 2023-04-11 14:55:23.899579 lofar-h5plot-2.6.2/lofar-h5plot/
--rw-rw-r--   0 frits     (1000) frits     (1000)        0 2020-01-07 14:53:28.000000 lofar-h5plot-2.6.2/lofar-h5plot/__init__.py
-drwxr-xr-x   0 frits     (1000) frits     (1000)        0 2023-04-11 14:55:23.901579 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/
--rw-r--r--   0 frits     (1000) frits     (1000)     1857 2023-04-11 14:55:23.000000 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/PKG-INFO
--rw-r--r--   0 frits     (1000) frits     (1000)      237 2023-04-11 14:55:23.000000 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/SOURCES.txt
--rw-r--r--   0 frits     (1000) frits     (1000)        1 2023-04-11 14:55:23.000000 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/dependency_links.txt
--rw-r--r--   0 frits     (1000) frits     (1000)       23 2023-04-11 14:55:23.000000 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/requires.txt
--rw-r--r--   0 frits     (1000) frits     (1000)       13 2023-04-11 14:55:23.000000 lofar-h5plot-2.6.2/lofar_h5plot.egg-info/top_level.txt
--rw-r--r--   0 frits     (1000) frits     (1000)       38 2023-04-11 14:55:23.901579 lofar-h5plot-2.6.2/setup.cfg
--rw-rw-r--   0 frits     (1000) frits     (1000)      838 2023-04-11 14:52:39.000000 lofar-h5plot-2.6.2/setup.py
+drwxrwxr-x   0 sweijen   (1001) sweijen   (1001)        0 2023-05-05 12:02:10.144983 lofar-h5plot-2.7.0/
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)    35149 2023-04-22 13:38:11.000000 lofar-h5plot-2.7.0/LICENSE
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)     1857 2023-05-05 12:02:10.144983 lofar-h5plot-2.7.0/PKG-INFO
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)     1329 2023-04-22 13:38:11.000000 lofar-h5plot-2.7.0/README.md
+-rwxrwxr-x   0 sweijen   (1001) sweijen   (1001)    69836 2023-05-05 12:00:46.000000 lofar-h5plot-2.7.0/h5plot
+drwxrwxr-x   0 sweijen   (1001) sweijen   (1001)        0 2023-05-05 12:02:10.144983 lofar-h5plot-2.7.0/lofar-h5plot/
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)        0 2023-04-22 13:38:11.000000 lofar-h5plot-2.7.0/lofar-h5plot/__init__.py
+drwxrwxr-x   0 sweijen   (1001) sweijen   (1001)        0 2023-05-05 12:02:10.144983 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)     1857 2023-05-05 12:02:09.000000 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/PKG-INFO
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)      237 2023-05-05 12:02:10.000000 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/SOURCES.txt
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)        1 2023-05-05 12:02:09.000000 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/dependency_links.txt
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)       23 2023-05-05 12:02:09.000000 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/requires.txt
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)       13 2023-05-05 12:02:09.000000 lofar-h5plot-2.7.0/lofar_h5plot.egg-info/top_level.txt
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)       38 2023-05-05 12:02:10.144983 lofar-h5plot-2.7.0/setup.cfg
+-rw-rw-r--   0 sweijen   (1001) sweijen   (1001)      838 2023-05-05 12:00:26.000000 lofar-h5plot-2.7.0/setup.py
```

### Comparing `lofar-h5plot-2.6.2/LICENSE` & `lofar-h5plot-2.7.0/LICENSE`

 * *Files identical despite different names*

### Comparing `lofar-h5plot-2.6.2/PKG-INFO` & `lofar-h5plot-2.7.0/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lofar-h5plot
-Version: 2.6.2
+Version: 2.7.0
 Summary: The spiritual successor to ParmDBplot for quickly reviewing gain solutions generated by NDPPP.
 Home-page: https://github.com/tikk3r/lofar-h5plot
 Author: Frits Sweijen
 Author-email: frits.sweijen@gmail.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: lofar-h5plot Version: 2.6.2 Summary: The spiritual
+Metadata-Version: 2.1 Name: lofar-h5plot Version: 2.7.0 Summary: The spiritual
 successor to ParmDBplot for quickly reviewing gain solutions generated by
 NDPPP. Home-page: https://github.com/tikk3r/lofar-h5plot Author: Frits Sweijen
 Author-email: frits.sweijen@gmail.com Classifier: Programming Language ::
 Python :: 3 Classifier: License :: OSI Approved :: GNU General Public License
 v3 (GPLv3) Classifier: Operating System :: OS Independent Requires-Python:
 >=3.6 Description-Content-Type: text/markdown License-File: LICENSE
                           ****** LOFAR H5plot ******
```

### Comparing `lofar-h5plot-2.6.2/README.md` & `lofar-h5plot-2.7.0/README.md`

 * *Files identical despite different names*

### Comparing `lofar-h5plot-2.6.2/h5plot` & `lofar-h5plot-2.7.0/h5plot`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 #!/usr/bin/env python3
 """ The spiritual successor to ParmDBplot for quickly reviewing gain solutions generated by NDPPP.
 """
-__version__ = 'v2.6.1'
+__version__ = 'v2.7.0'
 import logging
 import signal
 import sys
 import time
 
-from PyQt5.QtWidgets import QApplication, QComboBox, QDialog, QFormLayout, QGridLayout, QHBoxLayout, QLabel, \
-    QListWidget, QPushButton, QVBoxLayout, QWidget
-from PyQt5 import QtCore
+from PyQt5.QtWidgets import QApplication, QCheckBox, QComboBox, QDialog, QFormLayout, QGridLayout, QHBoxLayout, QLabel, \
+    QLineEdit, QListWidget, QPushButton, QScrollBar, QVBoxLayout, QWidget
+from PyQt5 import QtCore, QtWidgets
 
 from losoto.lib_operations import reorderAxes
 from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
 from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
 from matplotlib.figure import Figure
 
 import losoto.h5parm as lh5
@@ -226,14 +226,15 @@
     # Values have shape (timestamps, frequencies, antennas, polarizations, directions).
     axes = st.getAxesNames()
     st_type = st.getType()
     x_axis = vals[1]['time']
     y_axis = vals[1]['freq']
     values = np.asarray(vals[0])
     plabels = []
+
     try:
         pols = list(vals[1]['pol'])
     except:
         logging.debug('No polarization axis present.')
     if (st_type == 'phase') or (st_type == 'rotation'):
         isphase = True
     else:
@@ -265,32 +266,31 @@
                 plotvals_weight = weights[:, :, antenna]
         if wrapphase:
             plotvals = wrap_phase(plotvals)
     else:
         if 'pol' in axes:
             if 'dir' in axes:
                 plotvals = values[:, :, antenna, pol, direction]
-                plotvals_weight = values[:, :, antenna, pol, direction]
+                plotvals_weight = weights[:, :, antenna, pol, direction]
             else:
                 plotvals = values[:, :, antenna, pol]
                 plotvals_weight = weights[:, :, antenna, pol]
         elif 'dir' in axes:
             plotvals = values[:, :, antenna, direction]
             plotvals_weight = weights[:, :, antenna, direction]
         else:
             plotvals = values[:, :, antenna] - values[:, :, refantenna]
             plotvals_weight = weights[:, :, antenna]
-
     return x_axis, y_axis, plotvals, plotvals_weight, isphase
 
 
 class GraphWindow(QDialog):
     """ A window displaying the plotted quantity. Allows the user to cycle through time or frequency.
     """
-    def __init__(self, values, weights, frametitle, antindex, refantindex, axis, st, timeslot=0, freqslot=0, direction=0, times=None, freqs=None, parent=None):
+    def __init__(self, values, weights, frametitle, antindex, refantindex, axis, st, timeslot=0, freqslot=0, direction=0, times=None, freqs=None, parent=None, mode='values', do_timediff=False, do_freqdiff=False, do_poldiff=False):
         """ Initialize a new GraphWindow instance.
 
         Args:
             frametitle (str): title the frame will hvae.
             antindex (int): the index of the selected antenna.
             axis (str): the type of axis being plotted (time or freq).
             timeslot (int): index along the time axis to start with.
@@ -314,14 +314,18 @@
         self.direction = direction
         self.values = values
         self.weights = weights
         self.antindex = antindex
         self.refantindex = refantindex
         self.st = st
         self.parent = parent
+        self.mode = mode
+        self.do_timediff = do_timediff
+        self.do_freqdiff = do_freqdiff
+        self.do_poldiff = do_poldiff
         try:
             self.frequencies = freqs
         except AttributeError:
             # frequencies is None, plotting against time.
             pass
 
         try:
@@ -381,22 +385,35 @@
         antiter_layout.addWidget(self.btn_antiter_next)
 
         self.buttons = QGridLayout()
         self.buttons.addWidget(self.button_prev, 0, 0)
         self.buttons.addWidget(self.select_label, 0, 1)
         self.buttons.addWidget(self.button_next, 0, 2)
 
+        self.scrolls = QGridLayout()
+        self.scrollbar = QScrollBar()
+        self.scrollbar.setOrientation(QtCore.Qt.Horizontal)
+        if 'time' in axis.lower() and self.frequencies is not None:
+            self.scrollbar.setRange(0, len(self.frequencies)-1)
+        elif 'freq' in axis.lower()  and self.times is not None:
+            self.scrollbar.setRange(0, len(self.times)-1)
+        else:
+            self.scrollbar.setDisabled(True)
+        self.scrollbar.valueChanged.connect(self._scrollbar_event)
+        self.scrolls.addWidget(self.scrollbar, 0, 0)
+
         self.fig = Figure()
         self.canvas = FigureCanvas(self.fig)
         self.toolbar = NavigationToolbar(self.canvas, self)
 
         self.layout = QVBoxLayout()
         self.layout.addWidget(self.toolbar)
         self.layout.addWidget(self.canvas, stretch=500)
         self.layout.addItem(self.buttons)
+        self.layout.addItem(self.scrolls)
         self.layout.addWidget(antiter_widget)
         self.setLayout(self.layout)
 
     def format_time(self, seconds):
         """ Formats the time to be displayed in the plotting windows.
 
         A string is formatted, displaying the time in seconds or (fractional) minutes or hours.
@@ -438,34 +455,35 @@
         self.setWindowTitle(self.frametitle)
 
     def _forward_button_event(self):
         """ An event triggered by pressing the "Forward" button of a GraphWindow.
 
         When pressed, the abscissa is advanced one position, showing the next time or frequency slot.
         """
-        import time
         if 'time' in self.xlabel.lower():
             self.freqslot += 1
             self.select_label.setText('Frequency: {:.3f} MHz'.format(self.frequencies[self.freqslot] / 1e6))
             diridx = self.parent.directions.index(self.direction)
             x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, freqslot=self.freqslot, direction=diridx)
             if (self.freqslot > 0) and (not self.button_prev.isEnabled()):
                 self.button_prev.setEnabled(True)
             if self.freqslot == (len(self.frequencies) - 1):
                 self.button_next.setEnabled(False)
+            self.scrollbar.setValue(self.freqslot)
                 
         elif 'freq' in self.xlabel.lower():
             self.timeslot += 1
             self.select_label.setText('Time: ' + self.format_time(self.times[self.timeslot]))
             diridx = self.parent.directions.index(self.direction)
             x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, timeslot=self.timeslot, direction=diridx)
             if self.timeslot < (len(self.times) - 1) and (not self.button_prev.isEnabled()):
                 self.button_prev.setEnabled(True)
             if self.timeslot == (len(self.times) - 1):
                 self.button_next.setEnabled(False)
+            self.scrollbar.setValue(self.timeslot)
         self.plot(x, y, yw, self.frametitle, ax_labels=[self.xlabel, self.ylabel], plot_labels=l, isphase=p)
 
     def _backward_button_event(self):
         """ An event triggered by pressing the "Back" button of a GraphWindow.
 
         When pressed, the abscissa is set back one position, showing the previous time or frequency slot.
         """
@@ -475,88 +493,203 @@
                 self.select_label.setText('Frequency: {:.3f} MHz'.format(self.frequencies[self.freqslot] / 1e6))
                 diridx = self.parent.directions.index(self.direction)
                 x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, freqslot=self.freqslot, direction=diridx)
                 if self.freqslot == 0:
                     self.button_prev.setEnabled(False)
                 if (self.freqslot < (len(self.frequencies) - 1)) and (not self.button_next.isEnabled()):
                     self.button_next.setEnabled(True)
+                self.scrollbar.setValue(self.freqslot)
         elif 'freq' in self.xlabel.lower():
             if self.timeslot > 0:
                 self.timeslot -= 1
                 self.select_label.setText('Time: ' + self.format_time(self.times[self.timeslot]))
                 diridx = self.parent.directions.index(self.direction)
                 x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, timeslot=self.timeslot, direction=diridx)
                 if self.timeslot == 0:
                     self.button_prev.setEnabled(False)
                 if (self.timeslot < (len(self.parent.times) - 1)) and (not self.button_next.isEnabled()):
                     self.button_next.setEnabled(True)
+                self.scrollbar.setValue(self.timeslot)
+        self.plot(x, y, yw, self.frametitle, ax_labels=[self.xlabel, self.ylabel], plot_labels=l, isphase=p)
+
+    def _scrollbar_event(self):
+        if 'time' in self.xlabel.lower() and len(self.frequencies) > 1:
+            self.freqslot = self.scrollbar.value()
+            self.select_label.setText('Frequency: {:.3f} MHz'.format(self.frequencies[self.freqslot] / 1e6))
+            diridx = self.parent.directions.index(self.direction)
+            x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, freqslot=self.freqslot, direction=diridx)
+            if (self.freqslot > 0) and (not self.button_prev.isEnabled()):
+                self.button_prev.setEnabled(True)
+            if self.freqslot == (len(self.frequencies) - 1):
+                self.button_next.setEnabled(False)
+                
+        elif 'freq' in self.xlabel.lower():
+            self.timeslot = self.scrollbar.value()
+            self.select_label.setText('Time: ' + self.format_time(self.times[self.timeslot]))
+            diridx = self.parent.directions.index(self.direction)
+            x, y, yw, l, p = load_axes(self.values, self.st, self.axis, self.antindex, self.refantindex, timeslot=self.timeslot, direction=diridx)
+            if self.timeslot < (len(self.times) - 1) and (not self.button_prev.isEnabled()):
+                self.button_prev.setEnabled(True)
+            if self.timeslot == (len(self.times) - 1):
+                self.button_next.setEnabled(False)
         self.plot(x, y, yw, self.frametitle, ax_labels=[self.xlabel, self.ylabel], plot_labels=l, isphase=p)
 
     def plot(self, xaxis, yaxis, yaxis_weight, frametitle='', limits=[None, None], ax_labels=['', ''], plot_labels=[], multidim=False, isphase=False):
         self.xlabel = ax_labels[0]
         self.ylabel = ax_labels[1]
         self.xlabelp = plot_labels[0]
         self.ylabelp = plot_labels[1]
         self.fig.clf()
         self.ax = self.fig.add_subplot(111)
         self.ax.clear()
         if 'time' in ax_labels[0]:
             # Start counting from t=0
             xaxis = xaxis - xaxis[0]
         self.ax.set_title(frametitle + ' - {:s}'.format(self.direction))
+        if 'time' in ax_labels[0] and self.do_timediff:
+            self.ax.set_title(frametitle + ' - {:s} time diff'.format(self.direction))
+        if 'freq' in ax_labels[0] and self.do_freqdiff:
+            self.ax.set_title(frametitle + ' - {:s} frequency diff'.format(self.direction))
         if self.ax.get_legend_handles_labels()[1]:
             self.ax.legend()
         if type(xaxis) is list:
             xaxis = np.asarray(xaxis)
         if type(yaxis) is list:
             yaxis = np.asarray(yaxis)
         if type(yaxis_weight) is list:
             yaxis_weight = np.asarray(yaxis_weight)
             # Set weights to 0 for NaN solutions.
             yaxis_weight[np.isnan(yaxis)] = 0
         if len(yaxis.shape) > 1 and len(plot_labels) != 0:
-            for i in range(yaxis.shape[0]):
-                v = yaxis[i, :]
-                self.ax.plot(xaxis, v, '--', alpha=0.25, color='C' + str(i))
-                self.ax.plot(xaxis, v, 'h', label=plot_labels[i], color='C' + str(i))
+            if self.do_poldiff:
+                # Need to plot polarisation difference.
+                v = yaxis[0, :] - yaxis[-1, :]
                 # Handle flagged data. Weights are polarization independent.
-                vw = yaxis_weight[i, :]
+                vw = yaxis_weight[0, :]
                 v_m = np.ma.masked_where(vw == 0, v)
+                if 'time' in ax_labels[0] and self.do_timediff:
+                    v_m = np.ma.diff(v_m, axis=0)
+                    xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                if 'freq' in ax_labels[0] and self.do_freqdiff:
+                    v_m = np.diff(v_m, axis=0)
+                    xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C0')
+                self.ax.plot(xaxis, v_m, 'h', label='XX - YY', color='C0')
                 if np.ma.is_masked(v_m):
                     for x in xaxis[vw==0]:
                         self.ax.axvline(x, color='r')
                     self.ax.plot(xaxis[np.ma.getmaskarray(v_m)], np.ma.getdata(v_m)[np.ma.getmaskarray(v_m)], 'h', color='r')
+            else:
+                for i in range(yaxis.shape[0]):
+                    if self.mode == 'values':
+                        v = yaxis[i, :]
+                        # Handle flagged data. Weights are polarization independent.
+                        vw = yaxis_weight[i, :]
+                        v_m = np.ma.masked_where(vw == 0, v)
+                        if 'time' in ax_labels[0] and self.do_timediff:
+                            v_m = np.ma.diff(v_m, axis=0)
+                            if i == 0:
+                                xaxis = xaxis[:-1]
+                            vw = vw[:-1]
+                        if 'freq' in ax_labels[0] and self.do_freqdiff:
+                            v_m = np.diff(v_m, axis=0)
+                            if i == 0:
+                                xaxis = xaxis[:-1]
+                            vw = vw[:-1]
+                        self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C' + str(i))
+                        self.ax.plot(xaxis, v_m, 'h', label=plot_labels[i], color='C' + str(i))
+                        if np.ma.is_masked(v_m):
+                            for x in xaxis[vw==0]:
+                                self.ax.axvline(x, color='r')
+                            self.ax.plot(xaxis[np.ma.getmaskarray(v_m)], np.ma.getdata(v_m)[np.ma.getmaskarray(v_m)], 'h', color='r')
+                    elif self.mode == 'weights':
+                        vw = yaxis_weight[i, :]
+                        self.ax.plot(xaxis, vw, '--', alpha=0.25, color='C' + str(i))
+                        self.ax.plot(xaxis, vw, 'h', label=plot_labels[i], color='C' + str(i))
             self.ax.legend()
         elif len(yaxis.shape) > 1 and len(plot_labels) == 0:
-            for i in range(yaxis.shape[0]):
-                v = yaxis[i, :]
-                vw = yaxis_weight[i, :]
-                v_m = np.ma.masked_where(yaxis_weight == 0, v)
-                self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C' + str(i))
-                self.ax.plot(xaxis, v_m, 'h', color='C' + str(i))
+            if self.do_poldiff:
+                # Need to plot polarisation difference.
+                v = yaxis[0, :] - yaxis[-1, :]
+                # Handle flagged data. Weights are polarization independent.
+                vw = yaxis_weight[0, :]
+                v_m = np.ma.masked_where(vw == 0, v)
+                if 'time' in ax_labels[0] and self.do_timediff:
+                    v_m = np.ma.diff(v_m, axis=0)
+                    if i == 0:
+                        xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                if 'freq' in ax_labels[0] and self.do_freqdiff:
+                    v_m = np.diff(v_m, axis=0)
+                    if i == 0:
+                        xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C0')
+                self.ax.plot(xaxis, v_m, 'h', label='XX - YY', color='C0')
+                if np.ma.is_masked(v_m):
+                    for x in xaxis[vw==0]:
+                        self.ax.axvline(x, color='r')
+                    self.ax.plot(xaxis[np.ma.getmaskarray(v_m)], np.ma.getdata(v_m)[np.ma.getmaskarray(v_m)], 'h', color='r')
+            else:
+                for i in range(yaxis.shape[0]):
+                    if self.mode == 'values':
+                        v = yaxis[i, :]
+                        vw = yaxis_weight[i, :]
+                        v_m = np.ma.masked_where(yaxis_weight == 0, v)
+                        if 'time' in ax_labels[0] and self.do_timediff:
+                            v_m = np.diff(v_m, axis=0)
+                            if i == 0:
+                                xaxis = xaxis[:-1]
+                            vw = vw[:-1]
+                        if 'freq' in ax_labels[0] and self.do_freqdiff:
+                            v_m = np.diff(v_m, axis=0)
+                            if i == 0:
+                                xaxis = xaxis[:-1]
+                            vw = vw[:-1]
+                        self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C' + str(i))
+                        self.ax.plot(xaxis, v_m, 'h', color='C' + str(i))
+                    elif self.mode == 'weights':
+                        vw = yaxis_weight[i, :]
+                        self.ax.plot(xaxis, vw, '--', alpha=0.25, color='C' + str(i))
+                        self.ax.plot(xaxis, vw, 'h', label=plot_labels[i], color='C' + str(i))
         else:
-            v = yaxis
-            self.ax.plot(xaxis, v, '--', alpha=0.25, color='C0')
-            self.ax.plot(xaxis, v, 'h', color='C0')
-            vw = yaxis_weight
-            v_m = np.ma.masked_where(yaxis_weight == 0, v)
-            if np.ma.is_masked(v_m):
-                for x in xaxis[vw==0]:
-                    self.ax.axvline(x, color='r')
-                self.ax.plot(xaxis[np.ma.getmaskarray(v_m)], np.ma.getdata(v_m)[np.ma.getmaskarray(v_m)], 'h', color='r')
+            if self.mode == 'values':
+                v = yaxis
+                vw = yaxis_weight
+                v_m = np.ma.masked_where(yaxis_weight == 0, v)
+                if 'time' in ax_labels[0] and self.do_timediff:
+                    v_m = np.diff(v_m, axis=0)
+                    xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                if 'freq' in ax_labels[0] and self.do_freqdiff:
+                    v_m = np.diff(v_m, axis=0)
+                    xaxis = xaxis[:-1]
+                    vw = vw[:-1]
+                self.ax.plot(xaxis, v_m, '--', alpha=0.25, color='C0')
+                self.ax.plot(xaxis, v_m, 'h', color='C0')
+                if np.ma.is_masked(v_m):
+                    for x in xaxis[vw==0]:
+                        self.ax.axvline(x, color='r')
+                    self.ax.plot(xaxis[np.ma.getmaskarray(v_m)], np.ma.getdata(v_m)[np.ma.getmaskarray(v_m)], 'h', color='r')
+            elif self.mode == 'weights':
+                    vw = yaxis_weight
+                    self.ax.plot(xaxis, vw, '--', alpha=0.25, color='C0')
+                    self.ax.plot(xaxis, vw, 'h', label=plot_labels, color='C0')
         if isphase:
             self.ax.set_ylim(-np.pi, np.pi)
         self.ax.set(xlabel=ax_labels[0], ylabel=ax_labels[1], xlim=limits[0], ylim=limits[1])
         self.canvas.draw()
 
 
 class GraphWindow2D(QDialog):
     """ A window displaying the plotted 2D quantity. Allows the user to cycle through antenna.
     """
-    def __init__(self, values, weights, frametitle, antindex, refantindex, axis, st, polslot=0, direction=0, times=None, freqs=None, pols=None, parent=None):
+    def __init__(self, values, weights, frametitle, antindex, refantindex, axis, st, polslot=0, direction=0, times=None, freqs=None, pols=None, parent=None, mode='values', do_timediff=False, do_freqdiff=False, do_poldiff=False):
         """ Initialize a new GraphWindow instance.
 
         Args:
             values (ndarray): array of values to plot.
             weights (ndarray): array of weights corresponding to the values.
             frametitle (str): title the frame will have.
             antindex (int): the index of the selected antenna.
@@ -579,14 +712,18 @@
         self.direction = direction
         self.values = values
         self.weights = weights
         self.antindex = antindex
         self.refantindex = refantindex
         self.st = st
         self.parent = parent
+        self.mode = mode
+        self.do_timediff = do_timediff
+        self.do_freqdiff = do_freqdiff
+        self.do_poldiff = do_poldiff
         try:
             self.polarizations = pols
         except AttributeError:
             pass
 
         try:
             self.frequencies = freqs
@@ -652,14 +789,20 @@
         self.layout = QVBoxLayout()
         self.layout.addWidget(self.toolbar)
         self.layout.addWidget(self.canvas, stretch=500)
         self.layout.addItem(self.buttons)
         self.layout.addWidget(antiter_widget)
         self.setLayout(self.layout)
 
+        if self.do_poldiff:
+            self.button_prev.setEnabled(False)
+            self.button_next.setEnabled(False)
+            self.select_label.setText('Corr.: {:s} - {:s}'.format(self.polarizations[0], self.polarizations[-1]))
+            return
+
     def format_time(self, seconds):
         """ Formats the time to be displayed in the plotting windows.
 
         A string is formatted, displaying the time in seconds or (fractional) minutes or hours.
 
         Args:
             seconds (int): the time in seconds.
@@ -677,28 +820,50 @@
 
     def _antiter_next_button_event(self):
         if (self.antindex + 1) < len(self.parent.stations):
             self.antindex += 1
         else:
             self.antindex = 0
         diridx = self.parent.directions.index(self.direction)
-        x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
+        if len(self.polarizations) > 1 and self.do_poldiff:
+            # Need to plot polarisation difference.
+            x, y, z1, zw1, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, 0, direction=diridx)
+            x2, y2, z2, zw2, p2 = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, -1, direction=diridx)
+            z = z1 - z2
+            # Combine flags of both polarisations.
+            zw = zw1 * zw2
+        else:
+            x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
         self.frametitle = self.parent.stations[self.antindex]
-        self.plot(x, y, z, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p, frametitle=self.frametitle)
+        if self.mode == 'values':
+            self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        elif self.mode == 'weights':
+            self.plot(x, y, zw, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'))
         self.setWindowTitle(self.frametitle)
 
     def _antiter_prev_button_event(self):
         if (self.antindex - 1) > 0:
             self.antindex -= 1
         else:
             self.antindex = len(self.parent.stations) - 1
         diridx = self.parent.directions.index(self.direction)
-        x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
+        if len(self.polarizations) > 1 and self.do_poldiff:
+            # Need to plot polarisation difference.
+            x, y, z1, zw1, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, 0, direction=diridx)
+            x2, y2, z2, zw2, p2 = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, -1, direction=diridx)
+            z = z1 - z2
+            # Combine flags of both polarisations.
+            zw = zw1 * zw2
+        else:
+            x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
         self.frametitle = self.parent.stations[self.antindex]
-        self.plot(x, y, z, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p, frametitle=self.frametitle)
+        if self.mode == 'values':
+            self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        elif self.mode == 'weights':
+            self.plot(x, y, zw, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'))
         self.setWindowTitle(self.frametitle)
 
     def _forward_button_event(self):
         """ An event triggered by pressing the "Forward" button of a GraphWindow.
 
         When pressed, the abscissa is advanced one position, showing the next time or frequency slot.
         """
@@ -707,15 +872,18 @@
         if (self.polslot > 0) and (not self.button_prev.isEnabled()):
             self.button_prev.setEnabled(True)
         if self.polslot == (len(self.polarizations) - 1):
             self.button_next.setEnabled(False)
         self.select_label.setText('Corr.: {:s}'.format(self.polarizations[self.polslot]))
         diridx = self.parent.directions.index(self.direction)
         x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
-        self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        if self.mode == 'values':
+            self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        elif self.mode == 'weights':
+            self.plot(x, y, zw, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'))
 
     def _backward_button_event(self):
         """ An event triggered by pressing the "Back" button of a GraphWindow.
 
         When pressed, the abscissa is set back one position, showing the previous time or frequency slot.
         """
         if (self.polslot > 0):
@@ -723,27 +891,40 @@
         if self.polslot == 0:
             self.button_prev.setEnabled(False)
         if (self.polslot < (len(self.polarizations) - 1)) and (not self.button_next.isEnabled()):
             self.button_next.setEnabled(True)
         self.select_label.setText('Corr.: {:s}'.format(self.polarizations[self.polslot]))
         diridx = self.parent.directions.index(self.direction)
         x, y, z, zw, p = load_axes_2d(self.values, self.weights, self.st, self.antindex, self.refantindex, self.polslot, direction=diridx)
-        self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        if self.mode == 'values':
+            self.plot(x, y, z, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p)
+        elif self.mode == 'weights':
+            self.plot(x, y, zw, self.frametitle, ax_labels=('Time [s]', 'Freq. [MHz]'))
 
     def plot(self, xaxis, yaxis, zaxis, frametitle='', limits=[None, None], ax_labels=['', ''], multidim=False, isphase=False):
         self.xlabel = ax_labels[0]
         self.ylabel = ax_labels[1]
         self.fig.clf()
         self.ax = self.fig.add_subplot(111)
         self.ax.clear()
         # Start counting from t=0
         xaxis = xaxis - xaxis[0]
         yaxis = yaxis * 1e-6
         if self.polarizations is not None:
-            self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s} - {:s}'.format(self.polarizations[self.polslot], self.direction))
+            if self.do_poldiff:
+                pol = '{:s} - {:s}'.format(self.polarizations[0], self.polarizations[-1])
+            else:
+                pol = self.polarizations[self.polslot]
+            self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s} - {:s}'.format(pol, self.direction))
+            if self.do_timediff and not self.do_freqdiff:
+                self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s} - {:s} time diff'.format(pol, self.direction))
+            if not self.do_timediff and self.do_freqdiff:
+                self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s} - {:s} frequency diff'.format(pol, self.direction))
+            if self.do_timediff and self.do_freqdiff:
+                self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s} - {:s} time and frequency diff'.format(pol, self.direction))
         else:
             self.ax.set_title(frametitle + ':' + self.st.name + ' - {:s}'.format(self.direction))
         tdiff = np.diff(xaxis)
         fdiff = np.diff(yaxis)
         solint_time = tdiff[0]
         solint_freq = fdiff[0]
         vals = zaxis.copy()
@@ -766,28 +947,55 @@
             gapsize = plot_x[gapidx+1] - plot_x[gapidx]
             x_spacing = solint_time
             while (gapsize >= 2*x_spacing) and (len(plot_x) <= xaxis[-1] / solint_time): # if gap greater 2 times y-spacing, pad NaNs
                 vals = np.insert(vals, gapidx + 1, np.nan * np.ones((int(gapsize / x_spacing), vals.shape[1])), axis=0)  # fill gap with NaNs
                 plot_x = np.insert(plot_x, gapidx + 1, np.arange(plot_x[gapidx], plot_x[gapidx + 1], solint_time))  # fill gap with NaNs
                 gapidx = np.nanargmax(np.abs(np.diff(plot_x)) >= 2*solint_time)  # index BEFORE the gap
                 gapsize = np.abs(plot_x[gapidx+1] - plot_x[gapidx])
+        if self.parent.check_tdiff.isChecked():
+            vals = np.diff(vals, axis=0)
+        if self.parent.check_fdiff.isChecked():
+            vals = np.diff(vals, axis=1)
         if isphase:
             current_cmap = matplotlib.cm.get_cmap('jet')
             current_cmap.set_bad(color='w')
             im = self.ax.imshow(vals.T, interpolation='none', extent=[plot_x[0], plot_x[-1], plot_y[0], plot_y[-1]], aspect='auto', cmap=current_cmap, origin='lower')
             im.set_clim(-np.pi, np.pi)
         else:
             current_cmap = matplotlib.cm.get_cmap('viridis')
             current_cmap.set_bad(color='w')
-            im = self.ax.imshow(zaxis.T, interpolation='none', extent=[plot_x[0], plot_x[-1], plot_y[0], plot_y[-1]], aspect='auto', cmap=current_cmap, origin='lower')
+            im = self.ax.imshow(vals.T, interpolation='none', extent=[plot_x[0], plot_x[-1], plot_y[0], plot_y[-1]], aspect='auto', cmap=current_cmap, origin='lower')
         cb = self.fig.colorbar(im)
         self.ax.set(xlabel=ax_labels[0], ylabel=ax_labels[1], xlim=limits[0], ylim=limits[1])
         self.canvas.draw()
 
 
+class ListWidget(QListWidget):
+    """ Version of QListWidget that resizes itself.
+    
+    https://stackoverflow.com/questions/63497841/qlistwidget-does-not-resize-itself
+    """
+    def __init__(self, *args, **kwargs):
+        super().__init__(*args, **kwargs)
+        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
+        self.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
+
+
+    def minimumSizeHint(self) -> QtCore.QSize:
+        return QtCore.QSize(-1, -1)
+
+
+    def viewportSizeHint(self) -> QtCore.QSize:
+        if self.model().rowCount() == 0:
+            return QtCore.QSize(self.width(), 0)
+        height = sum(self.sizeHintForRow(i) for i in range(self.count()) if not self.item(i).isHidden())
+        width = super().viewportSizeHint().width()
+        return QtCore.QSize(width, height)
+
+
 class H5PlotGUI(QDialog):
     """The main GUI for H5Plot.
 
     From here the SolSets, SolTabs and antennas to plot are selected.
     """
     def __init__(self, h5file, logging_instance, parent=None):
         """ Initialize a new instances of the H5PlotGUI.
@@ -872,18 +1080,32 @@
         # self.phasewrap_box.setEnabled(False)
         # self.phasewrap_box.stateChanged.connect(self._phasewrap_event)
         self.dir_label = QLabel('Dir.')
         self.dir_picker = QComboBox()
         self.dir_picker.addItems(self.directions)
         self.dir_picker.activated.connect(self._dir_picker_event)
 
+        self.checkbox_layout = QGridLayout()
+        self.check_weights = QCheckBox('Plot weights')
+        self.check_tdiff = QCheckBox('Time diff.')
+        self.check_fdiff = QCheckBox('Freq. diff.')
+        self.check_pdiff = QCheckBox('Pol. diff. (XX-YY)')
+
+        self.check_weights.toggled.connect(self._weight_picker_event)
+        self.checkbox_layout.addWidget(self.check_weights, 0, 0)
+        self.checkbox_layout.addWidget(self.check_tdiff, 0, 1)
+        self.checkbox_layout.addWidget(self.check_fdiff, 1, 1)
+        self.checkbox_layout.addWidget(self.check_pdiff, 1, 0)
+
+        self.plotmode = 'values'
+
         self.plot_button = QPushButton('Plot')
         self.plot_button.clicked.connect(self._plot_button_event)
 
-        self.station_picker = QListWidget()
+        self.station_picker = ListWidget()
         self.station_picker.addItems(self.stations)
         self.station_picker.setCurrentRow(0)
 
         plot_layout = QGridLayout()
         plot_layout.addWidget(self.soltab_label_y, 0, 0)
         plot_layout.addWidget(self.soltab_picker, 0, 1)
         plot_layout.addWidget(self.soltab_label_x, 0, 2)
@@ -892,18 +1114,18 @@
         plot_layout.addWidget(self.refant_picker, 1, 1)
         plot_layout.addWidget(self.dir_label, 1, 2,)
         plot_layout.addWidget(self.dir_picker, 1, 3)
 
         layout = QFormLayout(self)
         layout.addRow(self.solset_label, self.solset_picker)
         layout.addRow(plot_layout)
+        layout.addRow(self.checkbox_layout)
         layout.addRow(self.plot_button)
         layout.addRow(self.station_picker)
 
-
     def _axis_picker_event(self):
         """Callback function for when the x-axis is changed.
 
         Sets the `axis` attribute to the selected axis
         """
         self.logger.debug('Axis changed to: ' + self.axis_picker.currentText())
         self.axis = self.axis_picker.currentText()
@@ -979,51 +1201,72 @@
     def _plot_button_event(self):
         """Callback function for when the plot button is pressed.
 
         Calls the `plot` function subsecquently.
         """
         self.logger.debug('Plotting button pressed.')
         if self.axis == 'freq' or self.axis == 'time':
-            self.plot(labels=(self.axis, self.soltab.name))
+            self.plot(labels=(self.axis, self.soltab.name), mode=self.plotmode)
         elif self.axis == 'waterfall':
-            self.plot_waterfall(labels=('time', 'freq'))
+            self.plot_waterfall(labels=('time', 'freq'), mode=self.plotmode)
 
-    def plot_waterfall(self, labels=('x-axis', 'y-axis')):
+    def _weight_picker_event(self):
+        if self.check_weights.isChecked():
+            self.plotmode = 'weights'
+        else:
+            self.plotmode = 'values'
+        self.logger.info('Plotting {:s}'.format(self.plotmode))
+
+    def plot_waterfall(self, labels=('x-axis', 'y-axis'), mode='values'):
         """ Show a two-dimensional waterfall plot of time vs. frequency.
         """
         if ('phase_offset') in self.soltab.name:
             self.logger.info('Phase-offset is scalar and cannot be plotted in 2D.')
         if (('rotationmeasure' in self.soltab.name) or ('RMextract' in self.soltab.name) or ('clock' in self.soltab.name) or ('faraday' in self.soltab.name) or ('tec' in self.soltab.name)):
             self.logger.info('Rotation Measure, clock, faraday or TEC cannot be plotted in 2D!')
             return
         self.logger.info('Plotting ' + self.soltab.name + \
                          ' for ' + self.solset.name)
         antenna = self.station_picker.currentRow()
         # Data loaded here is xaxis, yaxis, zaxis, isphase
         print('Loading data')
-        msg = load_axes_2d(self.stcache.values, self.stcache.weights, self.soltab, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), pol=0, direction=self.direction)
         try:
-            x, y, z, zw, p = msg
+            #x, y, z, zw, p = msg
+            if hasattr(self, "polarizations"):
+                if len(self.polarizations) > 1 and self.check_pdiff.isChecked():
+                    # Need to plot polarisation difference.
+                    x, y, z1, zw1, p = load_axes_2d(self.stcache.values, self.stcache.weights, self.soltab, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), pol=0, direction=self.direction)
+                    x2, y2, z2, zw2, p2 = load_axes_2d(self.stcache.values, self.stcache.weights, self.soltab, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), pol=-1, direction=self.direction)
+                    z = z1 - z2
+                    # Combine flags of both polarisations.
+                    zw = zw1 * zw2
+                else:
+                    x, y, z, zw, p = load_axes_2d(self.stcache.values, self.stcache.weights, self.soltab, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), pol=0, direction=self.direction)
+            else:
+                x, y, z, zw, p = load_axes_2d(self.stcache.values, self.stcache.weights, self.soltab, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), pol=0, direction=self.direction)
         except ValueError:
             logging.error('Error loading 2D data!')
             return
         if (len(x) == 1) or (len(y) == 1):
             self.logger.info('Either time or frequency has only 1 entry, not plotting!')
             return
+        # print('PLOTTING 2D WEIGHTS')
         try:
-            plot_window = GraphWindow2D(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, pols=self.polarizations, parent=self, direction=self.directions[self.direction])
+            plot_window = GraphWindow2D(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, pols=self.polarizations, parent=self, direction=self.directions[self.direction], mode=mode, do_timediff=self.check_tdiff.isChecked(), do_freqdiff=self.check_fdiff.isChecked(), do_poldiff=self.check_pdiff.isChecked())
         except AttributeError:
             # No polarizations most likely.
-            plot_window = GraphWindow2D(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, pols=['N/A'], parent=self, direction=self.directions[self.direction])
+            plot_window = GraphWindow2D(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, pols=['N/A'], parent=self, direction=self.directions[self.direction], mode=mode, do_timediff=self.check_tdiff.isChecked(), do_freqdiff=self.check_fdiff.isChecked(), do_poldiff=self.check_pdiff.isChecked())
         self.figures.append(plot_window)
-        z[zw == 0] = np.nan
-        plot_window.plot(x, y, z, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p, frametitle=self.stations[antenna])
+        if mode == 'values':
+            plot_window.plot(x, y, z, ax_labels=('Time [s]', 'Freq. [MHz]'), isphase=p, frametitle=self.stations[antenna])
+        elif mode == 'weights':
+            plot_window.plot(x, y, zw, ax_labels=('Time [s]', 'Freq. [MHz]'), frametitle=self.stations[antenna])
         plot_window.show()
 
-    def plot(self, labels=('x-axis', 'y-axis'), limits=([None, None], [None, None])):
+    def plot(self, labels=('x-axis', 'y-axis'), limits=([None, None], [None, None]), mode='values'):
         if ('phase_offset') in self.soltab.name:
             self.logger.info('Phase-offset is scalar and cannot be plotted in 2D.')
         self.logger.info('Plotting ' + self.soltab.name + ' vs ' + self.axis + \
                          ' for ' + self.solset.name)
         antenna = self.station_picker.currentRow()
         if (('rotationmeasure' in self.soltab.name) or ('RMextract' in self.soltab.name) or ('clock' in self.soltab.name) or ('faraday' in self.soltab.name) or ('tec' in self.soltab.name)) and (self.axis == 'freq'):
             self.logger.info('Rotation Measure or clock does not support frequency axis! Switch to time instead.')
@@ -1031,18 +1274,18 @@
         msg = load_axes(self.stcache.values, self.soltab, self.axis, antenna=antenna, refantenna=int(np.argwhere(self.stations == self.refant)), direction=self.direction, weights=self.stcache.weights)
         try:
             x_axis, Y_AXIS, Y_AXIS_WEIGHT, plabels, isphase = msg
         except ValueError:
             # Requested combination not supported.
             return
         if 'freq' in self.soltab.getAxesNames():
-            plot_window = GraphWindow(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, parent=self, direction=self.directions[self.direction])
+            plot_window = GraphWindow(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, freqs=self.frequencies, parent=self, direction=self.directions[self.direction], mode=mode, do_timediff=self.check_tdiff.isChecked(), do_freqdiff=self.check_fdiff.isChecked(), do_poldiff=self.check_pdiff.isChecked())
         else:
             # Probably TEC or another solution type with no frequency axis.
-            plot_window = GraphWindow(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, parent=self, direction=self.directions[self.direction])
+            plot_window = GraphWindow(self.stcache.values, self.stcache.weights, self.stations[antenna], antenna, int(np.argwhere(self.stations == self.refant)), self.axis, self.soltab, times=self.times, parent=self, direction=self.directions[self.direction], mode=mode, do_timediff=self.check_tdiff.isChecked(), do_freqdiff=self.check_fdiff.isChecked(), do_poldiff=self.check_pdiff.isChecked())
         self.figures.append(plot_window)
         plot_window.plot(x_axis, Y_AXIS, Y_AXIS_WEIGHT, self.stations[antenna], limits=[None, None], ax_labels=[self.axis, labels[1]], plot_labels=plabels, isphase=isphase)
         plot_window.show()
 
         # TEC does not have a frequency axis, so disable the button as well.
         if 'tec' in self.soltab.name:
             self.logger.debug('TEC solutions detected, disabling buttons.')
```

### Comparing `lofar-h5plot-2.6.2/lofar_h5plot.egg-info/PKG-INFO` & `lofar-h5plot-2.7.0/lofar_h5plot.egg-info/PKG-INFO`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: lofar-h5plot
-Version: 2.6.2
+Version: 2.7.0
 Summary: The spiritual successor to ParmDBplot for quickly reviewing gain solutions generated by NDPPP.
 Home-page: https://github.com/tikk3r/lofar-h5plot
 Author: Frits Sweijen
 Author-email: frits.sweijen@gmail.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: GNU General Public License v3 (GPLv3)
 Classifier: Operating System :: OS Independent
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 2.1 Name: lofar-h5plot Version: 2.6.2 Summary: The spiritual
+Metadata-Version: 2.1 Name: lofar-h5plot Version: 2.7.0 Summary: The spiritual
 successor to ParmDBplot for quickly reviewing gain solutions generated by
 NDPPP. Home-page: https://github.com/tikk3r/lofar-h5plot Author: Frits Sweijen
 Author-email: frits.sweijen@gmail.com Classifier: Programming Language ::
 Python :: 3 Classifier: License :: OSI Approved :: GNU General Public License
 v3 (GPLv3) Classifier: Operating System :: OS Independent Requires-Python:
 >=3.6 Description-Content-Type: text/markdown License-File: LICENSE
                           ****** LOFAR H5plot ******
```

### Comparing `lofar-h5plot-2.6.2/setup.py` & `lofar-h5plot-2.7.0/setup.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import setuptools
 
 with open('README.md', 'r') as f:
     long_desc = f.read()
 
 setuptools.setup(
     name='lofar-h5plot',
-    version='2.6.2',
+    version='2.7.0',
     scripts=['h5plot'],
     author='Frits Sweijen',
     author_email='frits.sweijen@gmail.com',
     description='The spiritual successor to ParmDBplot for quickly reviewing gain solutions generated by NDPPP.',
     long_description=long_desc,
     long_description_content_type='text/markdown',
     url='https://github.com/tikk3r/lofar-h5plot',
```

