# Comparing `tmp/vrt_lss_universal-6.4.1962-py3-none-any.whl.zip` & `tmp/vrt_lss_universal-6.5.1990-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,145 +1,119 @@
-Zip file size: 377390 bytes, number of entries: 143
--rw-r--r--  2.0 unx      689 b- defN 23-Apr-05 10:43 vrt_lss_universal/__init__.py
--rw-r--r--  2.0 unx    38744 b- defN 23-Apr-05 10:43 vrt_lss_universal/api_client.py
--rw-r--r--  2.0 unx    16610 b- defN 23-Apr-05 10:43 vrt_lss_universal/configuration.py
--rw-r--r--  2.0 unx     4995 b- defN 23-Apr-05 10:43 vrt_lss_universal/exceptions.py
--rw-r--r--  2.0 unx    82286 b- defN 23-Apr-05 10:43 vrt_lss_universal/model_utils.py
--rw-r--r--  2.0 unx    14020 b- defN 23-Apr-05 10:43 vrt_lss_universal/rest.py
--rw-r--r--  2.0 unx      223 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/__init__.py
--rw-r--r--  2.0 unx    16635 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/actualize_api.py
--rw-r--r--  2.0 unx    11572 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/convert_api.py
--rw-r--r--  2.0 unx    36669 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/plan_api.py
--rw-r--r--  2.0 unx    41974 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/replan_api.py
--rw-r--r--  2.0 unx    15183 b- defN 23-Apr-05 10:43 vrt_lss_universal/api/system_api.py
--rw-r--r--  2.0 unx      713 b- defN 23-Apr-05 10:43 vrt_lss_universal/apis/__init__.py
--rw-r--r--  2.0 unx      351 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/__init__.py
--rw-r--r--  2.0 unx    12214 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/actualize_settings.py
--rw-r--r--  2.0 unx    14652 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/actualize_task.py
--rw-r--r--  2.0 unx    12057 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/assigned_performer.py
--rw-r--r--  2.0 unx    12053 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/assigned_transport.py
--rw-r--r--  2.0 unx    11419 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/attribute.py
--rw-r--r--  2.0 unx    11635 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/attributes.py
--rw-r--r--  2.0 unx    12139 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/box.py
--rw-r--r--  2.0 unx    12374 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/box_compatibilities.py
--rw-r--r--  2.0 unx    11547 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/box_features.py
--rw-r--r--  2.0 unx    11171 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/box_limits.py
--rw-r--r--  2.0 unx    11519 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/box_restrictions.py
--rw-r--r--  2.0 unx    11441 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_async_result.py
--rw-r--r--  2.0 unx    13501 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_info.py
--rw-r--r--  2.0 unx    11710 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_progress.py
--rw-r--r--  2.0 unx    14958 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_settings.py
--rw-r--r--  2.0 unx    11955 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_state.py
--rw-r--r--  2.0 unx    14750 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/calculation_status.py
--rw-r--r--  2.0 unx    13604 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/capacity.py
--rw-r--r--  2.0 unx    11629 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/capacity_factor.py
--rw-r--r--  2.0 unx    11807 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo.py
--rw-r--r--  2.0 unx    13676 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_compatibilities.py
--rw-r--r--  2.0 unx    11649 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_features.py
--rw-r--r--  2.0 unx    11515 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_placement.py
--rw-r--r--  2.0 unx    11701 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_restrictions.py
--rw-r--r--  2.0 unx    12663 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_rotation.py
--rw-r--r--  2.0 unx    12344 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/cargo_rotation_type.py
--rw-r--r--  2.0 unx    11170 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/check_result.py
--rw-r--r--  2.0 unx    11749 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/compatibility_penalty.py
--rw-r--r--  2.0 unx    14288 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/demand.py
--rw-r--r--  2.0 unx    12813 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/demand_fact.py
--rw-r--r--  2.0 unx    12020 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_error.py
--rw-r--r--  2.0 unx    11910 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_error_list.py
--rw-r--r--  2.0 unx    15312 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_error_type.py
--rw-r--r--  2.0 unx    11806 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_path.py
--rw-r--r--  2.0 unx    14135 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_type.py
--rw-r--r--  2.0 unx    12048 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_warning.py
--rw-r--r--  2.0 unx    11890 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_warning_list.py
--rw-r--r--  2.0 unx    27798 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/entity_warning_type.py
--rw-r--r--  2.0 unx    13151 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/facts.py
--rw-r--r--  2.0 unx    13471 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/geo_settings.py
--rw-r--r--  2.0 unx    11581 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/geopoint.py
--rw-r--r--  2.0 unx    11657 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/hardlink.py
--rw-r--r--  2.0 unx    11672 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/hardlink_element.py
--rw-r--r--  2.0 unx    12252 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/hardlink_element_type.py
--rw-r--r--  2.0 unx    12731 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response400.py
--rw-r--r--  2.0 unx    11729 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response401.py
--rw-r--r--  2.0 unx    11729 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response402.py
--rw-r--r--  2.0 unx    11729 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response403.py
--rw-r--r--  2.0 unx    11868 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response404.py
--rw-r--r--  2.0 unx    11536 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response404_detail.py
--rw-r--r--  2.0 unx    11729 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response429.py
--rw-r--r--  2.0 unx    11729 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/inline_response500.py
--rw-r--r--  2.0 unx    13492 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/location.py
--rw-r--r--  2.0 unx    11305 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/location_compatibilities.py
--rw-r--r--  2.0 unx    13639 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/measurements.py
--rw-r--r--  2.0 unx    11603 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/model_break.py
--rw-r--r--  2.0 unx    11496 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/object_metrics.py
--rw-r--r--  2.0 unx    11686 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/operation_id.py
--rw-r--r--  2.0 unx    12886 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/order.py
--rw-r--r--  2.0 unx    12382 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/order_compatibilities.py
--rw-r--r--  2.0 unx    12117 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/order_fact.py
--rw-r--r--  2.0 unx    11378 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/order_features.py
--rw-r--r--  2.0 unx    11594 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/order_restrictions.py
--rw-r--r--  2.0 unx    13044 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer.py
--rw-r--r--  2.0 unx    12124 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_blacklist.py
--rw-r--r--  2.0 unx    11682 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_compatibilities.py
--rw-r--r--  2.0 unx    12286 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_fact.py
--rw-r--r--  2.0 unx    11669 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_features.py
--rw-r--r--  2.0 unx    11348 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_limits.py
--rw-r--r--  2.0 unx    11769 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_restrictions.py
--rw-r--r--  2.0 unx    15197 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_shift.py
--rw-r--r--  2.0 unx    12909 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_tariff.py
--rw-r--r--  2.0 unx    12246 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/performer_tariff_constraint.py
--rw-r--r--  2.0 unx    12090 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/plan_configuration.py
--rw-r--r--  2.0 unx    13529 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/plan_result.py
--rw-r--r--  2.0 unx    11877 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/plan_settings.py
--rw-r--r--  2.0 unx    11943 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/plan_statistics.py
--rw-r--r--  2.0 unx    14071 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/plan_task.py
--rw-r--r--  2.0 unx    12982 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/possible_event.py
--rw-r--r--  2.0 unx    11981 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/quality_statistics.py
--rw-r--r--  2.0 unx    12221 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/replan_settings.py
--rw-r--r--  2.0 unx    11878 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/replan_strategy.py
--rw-r--r--  2.0 unx    14717 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/replan_task.py
--rw-r--r--  2.0 unx    13353 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/routing_matrix.py
--rw-r--r--  2.0 unx    12094 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/routing_matrix_line.py
--rw-r--r--  2.0 unx    11667 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/routing_transport_matrix.py
--rw-r--r--  2.0 unx    12308 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/routing_transport_matrix_list.py
--rw-r--r--  2.0 unx    11404 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/schema_error.py
--rw-r--r--  2.0 unx    11862 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/schema_error_list.py
--rw-r--r--  2.0 unx    12534 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/service_name.py
--rw-r--r--  2.0 unx    15425 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/statistics.py
--rw-r--r--  2.0 unx    14059 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/stop_statistics.py
--rw-r--r--  2.0 unx    11773 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/time_duration.py
--rw-r--r--  2.0 unx    11638 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/time_window.py
--rw-r--r--  2.0 unx    11446 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/time_window_violations.py
--rw-r--r--  2.0 unx    13395 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/tracedata.py
--rw-r--r--  2.0 unx    11602 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/track_point.py
--rw-r--r--  2.0 unx    13569 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport.py
--rw-r--r--  2.0 unx    11682 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_compatibilities.py
--rw-r--r--  2.0 unx    12286 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_fact.py
--rw-r--r--  2.0 unx    11677 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_factor.py
--rw-r--r--  2.0 unx    11757 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_features.py
--rw-r--r--  2.0 unx    11800 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_limits.py
--rw-r--r--  2.0 unx    11526 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_load.py
--rw-r--r--  2.0 unx    11781 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_restrictions.py
--rw-r--r--  2.0 unx    13793 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_shift.py
--rw-r--r--  2.0 unx    13202 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_tariff.py
--rw-r--r--  2.0 unx    11922 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_tariff_constraint.py
--rw-r--r--  2.0 unx    14044 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/transport_type.py
--rw-r--r--  2.0 unx    13332 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip.py
--rw-r--r--  2.0 unx    15214 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_assumptions.py
--rw-r--r--  2.0 unx    11535 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_penalties.py
--rw-r--r--  2.0 unx    12022 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_start_time_strategy.py
--rw-r--r--  2.0 unx    16556 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_state.py
--rw-r--r--  2.0 unx    13144 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_state_flag.py
--rw-r--r--  2.0 unx    13186 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_statistics.py
--rw-r--r--  2.0 unx    11907 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trip_waitlist.py
--rw-r--r--  2.0 unx    12263 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/trips_settings.py
--rw-r--r--  2.0 unx    15297 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/universal_data.py
--rw-r--r--  2.0 unx    14143 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/unplanned_items.py
--rw-r--r--  2.0 unx    11610 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/validate_result.py
--rw-r--r--  2.0 unx    12597 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/version_result.py
--rw-r--r--  2.0 unx    11892 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/waypoint.py
--rw-r--r--  2.0 unx    11153 b- defN 23-Apr-05 10:43 vrt_lss_universal/model/work_and_rest_rules.py
--rw-r--r--  2.0 unx     8734 b- defN 23-Apr-05 10:43 vrt_lss_universal/models/__init__.py
--rw-r--r--  2.0 unx      369 b- defN 23-Apr-05 10:43 vrt_lss_universal-6.4.1962.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-05 10:43 vrt_lss_universal-6.4.1962.dist-info/WHEEL
--rw-r--r--  2.0 unx       18 b- defN 23-Apr-05 10:43 vrt_lss_universal-6.4.1962.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    14131 b- defN 23-Apr-05 10:43 vrt_lss_universal-6.4.1962.dist-info/RECORD
-143 files, 1865785 bytes uncompressed, 354680 bytes compressed:  81.0%
+Zip file size: 163611 bytes, number of entries: 117
+-rw-r--r--  2.0 unx     7795 b- defN 23-May-05 16:04 vrt_lss_universal/__init__.py
+-rw-r--r--  2.0 unx    29547 b- defN 23-May-05 16:04 vrt_lss_universal/api_client.py
+-rw-r--r--  2.0 unx    14673 b- defN 23-May-05 16:04 vrt_lss_universal/configuration.py
+-rw-r--r--  2.0 unx     5040 b- defN 23-May-05 16:04 vrt_lss_universal/exceptions.py
+-rw-r--r--  2.0 unx    12563 b- defN 23-May-05 16:04 vrt_lss_universal/rest.py
+-rw-r--r--  2.0 unx      327 b- defN 23-May-05 16:04 vrt_lss_universal/api/__init__.py
+-rw-r--r--  2.0 unx    21357 b- defN 23-May-05 16:04 vrt_lss_universal/api/actualize_api.py
+-rw-r--r--  2.0 unx    14753 b- defN 23-May-05 16:04 vrt_lss_universal/api/convert_api.py
+-rw-r--r--  2.0 unx    46319 b- defN 23-May-05 16:04 vrt_lss_universal/api/plan_api.py
+-rw-r--r--  2.0 unx    53433 b- defN 23-May-05 16:04 vrt_lss_universal/api/replan_api.py
+-rw-r--r--  2.0 unx    18580 b- defN 23-May-05 16:04 vrt_lss_universal/api/system_api.py
+-rw-r--r--  2.0 unx     6998 b- defN 23-May-05 16:04 vrt_lss_universal/models/__init__.py
+-rw-r--r--  2.0 unx     3293 b- defN 23-May-05 16:04 vrt_lss_universal/models/actualize_settings.py
+-rw-r--r--  2.0 unx     7650 b- defN 23-May-05 16:04 vrt_lss_universal/models/actualize_task.py
+-rw-r--r--  2.0 unx     2780 b- defN 23-May-05 16:04 vrt_lss_universal/models/assigned_performer.py
+-rw-r--r--  2.0 unx     2778 b- defN 23-May-05 16:04 vrt_lss_universal/models/assigned_transport.py
+-rw-r--r--  2.0 unx     1932 b- defN 23-May-05 16:04 vrt_lss_universal/models/attribute.py
+-rw-r--r--  2.0 unx     3754 b- defN 23-May-05 16:04 vrt_lss_universal/models/box.py
+-rw-r--r--  2.0 unx     2690 b- defN 23-May-05 16:04 vrt_lss_universal/models/box_compatibilities.py
+-rw-r--r--  2.0 unx     2483 b- defN 23-May-05 16:04 vrt_lss_universal/models/box_limits.py
+-rw-r--r--  2.0 unx     2261 b- defN 23-May-05 16:04 vrt_lss_universal/models/calculation_async_result.py
+-rw-r--r--  2.0 unx     6528 b- defN 23-May-05 16:04 vrt_lss_universal/models/calculation_info.py
+-rw-r--r--  2.0 unx     5336 b- defN 23-May-05 16:04 vrt_lss_universal/models/calculation_settings.py
+-rw-r--r--  2.0 unx     2725 b- defN 23-May-05 16:04 vrt_lss_universal/models/calculation_state.py
+-rw-r--r--  2.0 unx     1235 b- defN 23-May-05 16:04 vrt_lss_universal/models/calculation_status.py
+-rw-r--r--  2.0 unx     3065 b- defN 23-May-05 16:04 vrt_lss_universal/models/capacity.py
+-rw-r--r--  2.0 unx     2498 b- defN 23-May-05 16:04 vrt_lss_universal/models/capacity_factor.py
+-rw-r--r--  2.0 unx     3118 b- defN 23-May-05 16:04 vrt_lss_universal/models/cargo.py
+-rw-r--r--  2.0 unx     4051 b- defN 23-May-05 16:04 vrt_lss_universal/models/cargo_compatibilities.py
+-rw-r--r--  2.0 unx     2021 b- defN 23-May-05 16:04 vrt_lss_universal/models/cargo_placement.py
+-rw-r--r--  2.0 unx      670 b- defN 23-May-05 16:04 vrt_lss_universal/models/cargo_rotation_type.py
+-rw-r--r--  2.0 unx     1805 b- defN 23-May-05 16:04 vrt_lss_universal/models/check_result.py
+-rw-r--r--  2.0 unx     2277 b- defN 23-May-05 16:04 vrt_lss_universal/models/compatibility_penalty.py
+-rw-r--r--  2.0 unx     4577 b- defN 23-May-05 16:04 vrt_lss_universal/models/custom400_with_errors_and_warnings.py
+-rw-r--r--  2.0 unx     4744 b- defN 23-May-05 16:04 vrt_lss_universal/models/demand.py
+-rw-r--r--  2.0 unx     2841 b- defN 23-May-05 16:04 vrt_lss_universal/models/demand_fact.py
+-rw-r--r--  2.0 unx     2872 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_error.py
+-rw-r--r--  2.0 unx     1433 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_error_type.py
+-rw-r--r--  2.0 unx     2853 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_path.py
+-rw-r--r--  2.0 unx     1183 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_type.py
+-rw-r--r--  2.0 unx     2898 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_warning.py
+-rw-r--r--  2.0 unx     4971 b- defN 23-May-05 16:04 vrt_lss_universal/models/entity_warning_type.py
+-rw-r--r--  2.0 unx     4510 b- defN 23-May-05 16:04 vrt_lss_universal/models/facts.py
+-rw-r--r--  2.0 unx     2400 b- defN 23-May-05 16:04 vrt_lss_universal/models/general401.py
+-rw-r--r--  2.0 unx     2400 b- defN 23-May-05 16:04 vrt_lss_universal/models/general402.py
+-rw-r--r--  2.0 unx     2400 b- defN 23-May-05 16:04 vrt_lss_universal/models/general403.py
+-rw-r--r--  2.0 unx     2654 b- defN 23-May-05 16:04 vrt_lss_universal/models/general404.py
+-rw-r--r--  2.0 unx     2058 b- defN 23-May-05 16:04 vrt_lss_universal/models/general404_detail.py
+-rw-r--r--  2.0 unx     2400 b- defN 23-May-05 16:04 vrt_lss_universal/models/general429.py
+-rw-r--r--  2.0 unx     2400 b- defN 23-May-05 16:04 vrt_lss_universal/models/general500.py
+-rw-r--r--  2.0 unx     3294 b- defN 23-May-05 16:04 vrt_lss_universal/models/geo_settings.py
+-rw-r--r--  2.0 unx     1954 b- defN 23-May-05 16:04 vrt_lss_universal/models/geopoint.py
+-rw-r--r--  2.0 unx     2838 b- defN 23-May-05 16:04 vrt_lss_universal/models/hardlink.py
+-rw-r--r--  2.0 unx     2052 b- defN 23-May-05 16:04 vrt_lss_universal/models/hardlink_element.py
+-rw-r--r--  2.0 unx      581 b- defN 23-May-05 16:04 vrt_lss_universal/models/hardlink_element_type.py
+-rw-r--r--  2.0 unx     6333 b- defN 23-May-05 16:04 vrt_lss_universal/models/location.py
+-rw-r--r--  2.0 unx     2214 b- defN 23-May-05 16:04 vrt_lss_universal/models/location_compatibilities.py
+-rw-r--r--  2.0 unx     8581 b- defN 23-May-05 16:04 vrt_lss_universal/models/measurements.py
+-rw-r--r--  2.0 unx     3449 b- defN 23-May-05 16:04 vrt_lss_universal/models/model_break.py
+-rw-r--r--  2.0 unx     2070 b- defN 23-May-05 16:04 vrt_lss_universal/models/object_metrics.py
+-rw-r--r--  2.0 unx     4593 b- defN 23-May-05 16:04 vrt_lss_universal/models/order.py
+-rw-r--r--  2.0 unx     3245 b- defN 23-May-05 16:04 vrt_lss_universal/models/order_compatibilities.py
+-rw-r--r--  2.0 unx     2491 b- defN 23-May-05 16:04 vrt_lss_universal/models/order_fact.py
+-rw-r--r--  2.0 unx     4785 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer.py
+-rw-r--r--  2.0 unx     2570 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_compatibilities.py
+-rw-r--r--  2.0 unx     2593 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_fact.py
+-rw-r--r--  2.0 unx     1993 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_limits.py
+-rw-r--r--  2.0 unx     6960 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_shift.py
+-rw-r--r--  2.0 unx     3356 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_tariff.py
+-rw-r--r--  2.0 unx     3010 b- defN 23-May-05 16:04 vrt_lss_universal/models/performer_tariff_constraint.py
+-rw-r--r--  2.0 unx     5202 b- defN 23-May-05 16:04 vrt_lss_universal/models/plan_result.py
+-rw-r--r--  2.0 unx     3105 b- defN 23-May-05 16:04 vrt_lss_universal/models/plan_settings.py
+-rw-r--r--  2.0 unx     2920 b- defN 23-May-05 16:04 vrt_lss_universal/models/plan_statistics.py
+-rw-r--r--  2.0 unx     6596 b- defN 23-May-05 16:04 vrt_lss_universal/models/plan_task.py
+-rw-r--r--  2.0 unx     4587 b- defN 23-May-05 16:04 vrt_lss_universal/models/possible_event.py
+-rw-r--r--  2.0 unx     2788 b- defN 23-May-05 16:04 vrt_lss_universal/models/quality_statistics.py
+-rw-r--r--  2.0 unx     3595 b- defN 23-May-05 16:04 vrt_lss_universal/models/replan_settings.py
+-rw-r--r--  2.0 unx     2365 b- defN 23-May-05 16:04 vrt_lss_universal/models/replan_strategy.py
+-rw-r--r--  2.0 unx     7576 b- defN 23-May-05 16:04 vrt_lss_universal/models/replan_task.py
+-rw-r--r--  2.0 unx     3337 b- defN 23-May-05 16:04 vrt_lss_universal/models/routing_matrix.py
+-rw-r--r--  2.0 unx     2305 b- defN 23-May-05 16:04 vrt_lss_universal/models/routing_transport_matrix.py
+-rw-r--r--  2.0 unx     2179 b- defN 23-May-05 16:04 vrt_lss_universal/models/schema_error.py
+-rw-r--r--  2.0 unx      679 b- defN 23-May-05 16:04 vrt_lss_universal/models/service_name.py
+-rw-r--r--  2.0 unx     5263 b- defN 23-May-05 16:04 vrt_lss_universal/models/statistics.py
+-rw-r--r--  2.0 unx     5123 b- defN 23-May-05 16:04 vrt_lss_universal/models/stop_statistics.py
+-rw-r--r--  2.0 unx     2085 b- defN 23-May-05 16:04 vrt_lss_universal/models/time_window.py
+-rw-r--r--  2.0 unx     2399 b- defN 23-May-05 16:04 vrt_lss_universal/models/time_window_violations.py
+-rw-r--r--  2.0 unx     3286 b- defN 23-May-05 16:04 vrt_lss_universal/models/tracedata.py
+-rw-r--r--  2.0 unx     2274 b- defN 23-May-05 16:04 vrt_lss_universal/models/track_point.py
+-rw-r--r--  2.0 unx     5430 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport.py
+-rw-r--r--  2.0 unx     2589 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_compatibilities.py
+-rw-r--r--  2.0 unx     2593 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_fact.py
+-rw-r--r--  2.0 unx     2064 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_factor.py
+-rw-r--r--  2.0 unx     2903 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_limits.py
+-rw-r--r--  2.0 unx     2441 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_load.py
+-rw-r--r--  2.0 unx     5490 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_shift.py
+-rw-r--r--  2.0 unx     3845 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_tariff.py
+-rw-r--r--  2.0 unx     2383 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_tariff_constraint.py
+-rw-r--r--  2.0 unx     1140 b- defN 23-May-05 16:04 vrt_lss_universal/models/transport_type.py
+-rw-r--r--  2.0 unx     4511 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip.py
+-rw-r--r--  2.0 unx     5097 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_assumptions.py
+-rw-r--r--  2.0 unx     2540 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_penalties.py
+-rw-r--r--  2.0 unx      576 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_start_time_strategy.py
+-rw-r--r--  2.0 unx     6226 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_state.py
+-rw-r--r--  2.0 unx      868 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_state_flag.py
+-rw-r--r--  2.0 unx     4174 b- defN 23-May-05 16:04 vrt_lss_universal/models/trip_statistics.py
+-rw-r--r--  2.0 unx     3241 b- defN 23-May-05 16:04 vrt_lss_universal/models/trips_settings.py
+-rw-r--r--  2.0 unx     9370 b- defN 23-May-05 16:04 vrt_lss_universal/models/universal_data.py
+-rw-r--r--  2.0 unx     3858 b- defN 23-May-05 16:04 vrt_lss_universal/models/unplanned_items.py
+-rw-r--r--  2.0 unx     2721 b- defN 23-May-05 16:04 vrt_lss_universal/models/validate_result.py
+-rw-r--r--  2.0 unx     2508 b- defN 23-May-05 16:04 vrt_lss_universal/models/version_result.py
+-rw-r--r--  2.0 unx     3238 b- defN 23-May-05 16:04 vrt_lss_universal/models/waypoint.py
+-rw-r--r--  2.0 unx     2346 b- defN 23-May-05 16:04 vrt_lss_universal/models/work_and_rest_rules.py
+-rw-r--r--  2.0 unx    18642 b- defN 23-May-05 16:04 vrt_lss_universal-6.5.1990.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-05 16:04 vrt_lss_universal-6.5.1990.dist-info/WHEEL
+-rw-r--r--  2.0 unx       18 b- defN 23-May-05 16:04 vrt_lss_universal-6.5.1990.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx    11471 b- defN 23-May-05 16:04 vrt_lss_universal-6.5.1990.dist-info/RECORD
+117 files, 594930 bytes uncompressed, 144983 bytes compressed:  75.6%
```

## zipnote {}

```diff
@@ -6,17 +6,14 @@
 
 Filename: vrt_lss_universal/configuration.py
 Comment: 
 
 Filename: vrt_lss_universal/exceptions.py
 Comment: 
 
-Filename: vrt_lss_universal/model_utils.py
-Comment: 
-
 Filename: vrt_lss_universal/rest.py
 Comment: 
 
 Filename: vrt_lss_universal/api/__init__.py
 Comment: 
 
 Filename: vrt_lss_universal/api/actualize_api.py
@@ -30,401 +27,326 @@
 
 Filename: vrt_lss_universal/api/replan_api.py
 Comment: 
 
 Filename: vrt_lss_universal/api/system_api.py
 Comment: 
 
-Filename: vrt_lss_universal/apis/__init__.py
-Comment: 
-
-Filename: vrt_lss_universal/model/__init__.py
-Comment: 
-
-Filename: vrt_lss_universal/model/actualize_settings.py
-Comment: 
-
-Filename: vrt_lss_universal/model/actualize_task.py
-Comment: 
-
-Filename: vrt_lss_universal/model/assigned_performer.py
-Comment: 
-
-Filename: vrt_lss_universal/model/assigned_transport.py
-Comment: 
-
-Filename: vrt_lss_universal/model/attribute.py
-Comment: 
-
-Filename: vrt_lss_universal/model/attributes.py
-Comment: 
-
-Filename: vrt_lss_universal/model/box.py
-Comment: 
-
-Filename: vrt_lss_universal/model/box_compatibilities.py
-Comment: 
-
-Filename: vrt_lss_universal/model/box_features.py
-Comment: 
-
-Filename: vrt_lss_universal/model/box_limits.py
-Comment: 
-
-Filename: vrt_lss_universal/model/box_restrictions.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_async_result.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_info.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_progress.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_settings.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_state.py
-Comment: 
-
-Filename: vrt_lss_universal/model/calculation_status.py
-Comment: 
-
-Filename: vrt_lss_universal/model/capacity.py
-Comment: 
-
-Filename: vrt_lss_universal/model/capacity_factor.py
-Comment: 
-
-Filename: vrt_lss_universal/model/cargo.py
-Comment: 
-
-Filename: vrt_lss_universal/model/cargo_compatibilities.py
-Comment: 
-
-Filename: vrt_lss_universal/model/cargo_features.py
-Comment: 
-
-Filename: vrt_lss_universal/model/cargo_placement.py
-Comment: 
-
-Filename: vrt_lss_universal/model/cargo_restrictions.py
+Filename: vrt_lss_universal/models/__init__.py
 Comment: 
 
-Filename: vrt_lss_universal/model/cargo_rotation.py
+Filename: vrt_lss_universal/models/actualize_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/cargo_rotation_type.py
+Filename: vrt_lss_universal/models/actualize_task.py
 Comment: 
 
-Filename: vrt_lss_universal/model/check_result.py
+Filename: vrt_lss_universal/models/assigned_performer.py
 Comment: 
 
-Filename: vrt_lss_universal/model/compatibility_penalty.py
+Filename: vrt_lss_universal/models/assigned_transport.py
 Comment: 
 
-Filename: vrt_lss_universal/model/demand.py
+Filename: vrt_lss_universal/models/attribute.py
 Comment: 
 
-Filename: vrt_lss_universal/model/demand_fact.py
+Filename: vrt_lss_universal/models/box.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_error.py
+Filename: vrt_lss_universal/models/box_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_error_list.py
+Filename: vrt_lss_universal/models/box_limits.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_error_type.py
+Filename: vrt_lss_universal/models/calculation_async_result.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_path.py
+Filename: vrt_lss_universal/models/calculation_info.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_type.py
+Filename: vrt_lss_universal/models/calculation_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_warning.py
+Filename: vrt_lss_universal/models/calculation_state.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_warning_list.py
+Filename: vrt_lss_universal/models/calculation_status.py
 Comment: 
 
-Filename: vrt_lss_universal/model/entity_warning_type.py
+Filename: vrt_lss_universal/models/capacity.py
 Comment: 
 
-Filename: vrt_lss_universal/model/facts.py
+Filename: vrt_lss_universal/models/capacity_factor.py
 Comment: 
 
-Filename: vrt_lss_universal/model/geo_settings.py
+Filename: vrt_lss_universal/models/cargo.py
 Comment: 
 
-Filename: vrt_lss_universal/model/geopoint.py
+Filename: vrt_lss_universal/models/cargo_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/hardlink.py
+Filename: vrt_lss_universal/models/cargo_placement.py
 Comment: 
 
-Filename: vrt_lss_universal/model/hardlink_element.py
+Filename: vrt_lss_universal/models/cargo_rotation_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/hardlink_element_type.py
+Filename: vrt_lss_universal/models/check_result.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response400.py
+Filename: vrt_lss_universal/models/compatibility_penalty.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response401.py
+Filename: vrt_lss_universal/models/custom400_with_errors_and_warnings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response402.py
+Filename: vrt_lss_universal/models/demand.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response403.py
+Filename: vrt_lss_universal/models/demand_fact.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response404.py
+Filename: vrt_lss_universal/models/entity_error.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response404_detail.py
+Filename: vrt_lss_universal/models/entity_error_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response429.py
+Filename: vrt_lss_universal/models/entity_path.py
 Comment: 
 
-Filename: vrt_lss_universal/model/inline_response500.py
+Filename: vrt_lss_universal/models/entity_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/location.py
+Filename: vrt_lss_universal/models/entity_warning.py
 Comment: 
 
-Filename: vrt_lss_universal/model/location_compatibilities.py
+Filename: vrt_lss_universal/models/entity_warning_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/measurements.py
+Filename: vrt_lss_universal/models/facts.py
 Comment: 
 
-Filename: vrt_lss_universal/model/model_break.py
+Filename: vrt_lss_universal/models/general401.py
 Comment: 
 
-Filename: vrt_lss_universal/model/object_metrics.py
+Filename: vrt_lss_universal/models/general402.py
 Comment: 
 
-Filename: vrt_lss_universal/model/operation_id.py
+Filename: vrt_lss_universal/models/general403.py
 Comment: 
 
-Filename: vrt_lss_universal/model/order.py
+Filename: vrt_lss_universal/models/general404.py
 Comment: 
 
-Filename: vrt_lss_universal/model/order_compatibilities.py
+Filename: vrt_lss_universal/models/general404_detail.py
 Comment: 
 
-Filename: vrt_lss_universal/model/order_fact.py
+Filename: vrt_lss_universal/models/general429.py
 Comment: 
 
-Filename: vrt_lss_universal/model/order_features.py
+Filename: vrt_lss_universal/models/general500.py
 Comment: 
 
-Filename: vrt_lss_universal/model/order_restrictions.py
+Filename: vrt_lss_universal/models/geo_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer.py
+Filename: vrt_lss_universal/models/geopoint.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_blacklist.py
+Filename: vrt_lss_universal/models/hardlink.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_compatibilities.py
+Filename: vrt_lss_universal/models/hardlink_element.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_fact.py
+Filename: vrt_lss_universal/models/hardlink_element_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_features.py
+Filename: vrt_lss_universal/models/location.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_limits.py
+Filename: vrt_lss_universal/models/location_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_restrictions.py
+Filename: vrt_lss_universal/models/measurements.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_shift.py
+Filename: vrt_lss_universal/models/model_break.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_tariff.py
+Filename: vrt_lss_universal/models/object_metrics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/performer_tariff_constraint.py
+Filename: vrt_lss_universal/models/order.py
 Comment: 
 
-Filename: vrt_lss_universal/model/plan_configuration.py
+Filename: vrt_lss_universal/models/order_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/plan_result.py
+Filename: vrt_lss_universal/models/order_fact.py
 Comment: 
 
-Filename: vrt_lss_universal/model/plan_settings.py
+Filename: vrt_lss_universal/models/performer.py
 Comment: 
 
-Filename: vrt_lss_universal/model/plan_statistics.py
+Filename: vrt_lss_universal/models/performer_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/plan_task.py
+Filename: vrt_lss_universal/models/performer_fact.py
 Comment: 
 
-Filename: vrt_lss_universal/model/possible_event.py
+Filename: vrt_lss_universal/models/performer_limits.py
 Comment: 
 
-Filename: vrt_lss_universal/model/quality_statistics.py
+Filename: vrt_lss_universal/models/performer_shift.py
 Comment: 
 
-Filename: vrt_lss_universal/model/replan_settings.py
+Filename: vrt_lss_universal/models/performer_tariff.py
 Comment: 
 
-Filename: vrt_lss_universal/model/replan_strategy.py
+Filename: vrt_lss_universal/models/performer_tariff_constraint.py
 Comment: 
 
-Filename: vrt_lss_universal/model/replan_task.py
+Filename: vrt_lss_universal/models/plan_result.py
 Comment: 
 
-Filename: vrt_lss_universal/model/routing_matrix.py
+Filename: vrt_lss_universal/models/plan_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/routing_matrix_line.py
+Filename: vrt_lss_universal/models/plan_statistics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/routing_transport_matrix.py
+Filename: vrt_lss_universal/models/plan_task.py
 Comment: 
 
-Filename: vrt_lss_universal/model/routing_transport_matrix_list.py
+Filename: vrt_lss_universal/models/possible_event.py
 Comment: 
 
-Filename: vrt_lss_universal/model/schema_error.py
+Filename: vrt_lss_universal/models/quality_statistics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/schema_error_list.py
+Filename: vrt_lss_universal/models/replan_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/service_name.py
+Filename: vrt_lss_universal/models/replan_strategy.py
 Comment: 
 
-Filename: vrt_lss_universal/model/statistics.py
+Filename: vrt_lss_universal/models/replan_task.py
 Comment: 
 
-Filename: vrt_lss_universal/model/stop_statistics.py
+Filename: vrt_lss_universal/models/routing_matrix.py
 Comment: 
 
-Filename: vrt_lss_universal/model/time_duration.py
+Filename: vrt_lss_universal/models/routing_transport_matrix.py
 Comment: 
 
-Filename: vrt_lss_universal/model/time_window.py
+Filename: vrt_lss_universal/models/schema_error.py
 Comment: 
 
-Filename: vrt_lss_universal/model/time_window_violations.py
+Filename: vrt_lss_universal/models/service_name.py
 Comment: 
 
-Filename: vrt_lss_universal/model/tracedata.py
+Filename: vrt_lss_universal/models/statistics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/track_point.py
+Filename: vrt_lss_universal/models/stop_statistics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport.py
+Filename: vrt_lss_universal/models/time_window.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_compatibilities.py
+Filename: vrt_lss_universal/models/time_window_violations.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_fact.py
+Filename: vrt_lss_universal/models/tracedata.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_factor.py
+Filename: vrt_lss_universal/models/track_point.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_features.py
+Filename: vrt_lss_universal/models/transport.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_limits.py
+Filename: vrt_lss_universal/models/transport_compatibilities.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_load.py
+Filename: vrt_lss_universal/models/transport_fact.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_restrictions.py
+Filename: vrt_lss_universal/models/transport_factor.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_shift.py
+Filename: vrt_lss_universal/models/transport_limits.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_tariff.py
+Filename: vrt_lss_universal/models/transport_load.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_tariff_constraint.py
+Filename: vrt_lss_universal/models/transport_shift.py
 Comment: 
 
-Filename: vrt_lss_universal/model/transport_type.py
+Filename: vrt_lss_universal/models/transport_tariff.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip.py
+Filename: vrt_lss_universal/models/transport_tariff_constraint.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_assumptions.py
+Filename: vrt_lss_universal/models/transport_type.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_penalties.py
+Filename: vrt_lss_universal/models/trip.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_start_time_strategy.py
+Filename: vrt_lss_universal/models/trip_assumptions.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_state.py
+Filename: vrt_lss_universal/models/trip_penalties.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_state_flag.py
+Filename: vrt_lss_universal/models/trip_start_time_strategy.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_statistics.py
+Filename: vrt_lss_universal/models/trip_state.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trip_waitlist.py
+Filename: vrt_lss_universal/models/trip_state_flag.py
 Comment: 
 
-Filename: vrt_lss_universal/model/trips_settings.py
+Filename: vrt_lss_universal/models/trip_statistics.py
 Comment: 
 
-Filename: vrt_lss_universal/model/universal_data.py
+Filename: vrt_lss_universal/models/trips_settings.py
 Comment: 
 
-Filename: vrt_lss_universal/model/unplanned_items.py
+Filename: vrt_lss_universal/models/universal_data.py
 Comment: 
 
-Filename: vrt_lss_universal/model/validate_result.py
+Filename: vrt_lss_universal/models/unplanned_items.py
 Comment: 
 
-Filename: vrt_lss_universal/model/version_result.py
+Filename: vrt_lss_universal/models/validate_result.py
 Comment: 
 
-Filename: vrt_lss_universal/model/waypoint.py
+Filename: vrt_lss_universal/models/version_result.py
 Comment: 
 
-Filename: vrt_lss_universal/model/work_and_rest_rules.py
+Filename: vrt_lss_universal/models/waypoint.py
 Comment: 
 
-Filename: vrt_lss_universal/models/__init__.py
+Filename: vrt_lss_universal/models/work_and_rest_rules.py
 Comment: 
 
-Filename: vrt_lss_universal-6.4.1962.dist-info/METADATA
+Filename: vrt_lss_universal-6.5.1990.dist-info/METADATA
 Comment: 
 
-Filename: vrt_lss_universal-6.4.1962.dist-info/WHEEL
+Filename: vrt_lss_universal-6.5.1990.dist-info/WHEEL
 Comment: 
 
-Filename: vrt_lss_universal-6.4.1962.dist-info/top_level.txt
+Filename: vrt_lss_universal-6.5.1990.dist-info/top_level.txt
 Comment: 
 
-Filename: vrt_lss_universal-6.4.1962.dist-info/RECORD
+Filename: vrt_lss_universal-6.5.1990.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## vrt_lss_universal/__init__.py

```diff
@@ -1,26 +1,137 @@
+# coding: utf-8
+
 # flake8: noqa
 
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
-__version__ = "6.4.1962"
+__version__ = "6.5.1990"
+
+# import apis into sdk package
+from vrt_lss_universal.api.actualize_api import ActualizeApi
+from vrt_lss_universal.api.convert_api import ConvertApi
+from vrt_lss_universal.api.plan_api import PlanApi
+from vrt_lss_universal.api.replan_api import ReplanApi
+from vrt_lss_universal.api.system_api import SystemApi
 
 # import ApiClient
 from vrt_lss_universal.api_client import ApiClient
-
-# import Configuration
 from vrt_lss_universal.configuration import Configuration
-
-# import exceptions
 from vrt_lss_universal.exceptions import OpenApiException
-from vrt_lss_universal.exceptions import ApiAttributeError
 from vrt_lss_universal.exceptions import ApiTypeError
 from vrt_lss_universal.exceptions import ApiValueError
 from vrt_lss_universal.exceptions import ApiKeyError
+from vrt_lss_universal.exceptions import ApiAttributeError
 from vrt_lss_universal.exceptions import ApiException
+# import models into sdk package
+from vrt_lss_universal.models.actualize_settings import ActualizeSettings
+from vrt_lss_universal.models.actualize_task import ActualizeTask
+from vrt_lss_universal.models.assigned_performer import AssignedPerformer
+from vrt_lss_universal.models.assigned_transport import AssignedTransport
+from vrt_lss_universal.models.attribute import Attribute
+from vrt_lss_universal.models.box import Box
+from vrt_lss_universal.models.box_compatibilities import BoxCompatibilities
+from vrt_lss_universal.models.box_limits import BoxLimits
+from vrt_lss_universal.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_universal.models.calculation_info import CalculationInfo
+from vrt_lss_universal.models.calculation_settings import CalculationSettings
+from vrt_lss_universal.models.calculation_state import CalculationState
+from vrt_lss_universal.models.calculation_status import CalculationStatus
+from vrt_lss_universal.models.capacity import Capacity
+from vrt_lss_universal.models.capacity_factor import CapacityFactor
+from vrt_lss_universal.models.cargo import Cargo
+from vrt_lss_universal.models.cargo_compatibilities import CargoCompatibilities
+from vrt_lss_universal.models.cargo_placement import CargoPlacement
+from vrt_lss_universal.models.cargo_rotation_type import CargoRotationType
+from vrt_lss_universal.models.check_result import CheckResult
+from vrt_lss_universal.models.compatibility_penalty import CompatibilityPenalty
+from vrt_lss_universal.models.custom400_with_errors_and_warnings import Custom400WithErrorsAndWarnings
+from vrt_lss_universal.models.demand import Demand
+from vrt_lss_universal.models.demand_fact import DemandFact
+from vrt_lss_universal.models.entity_error import EntityError
+from vrt_lss_universal.models.entity_error_type import EntityErrorType
+from vrt_lss_universal.models.entity_path import EntityPath
+from vrt_lss_universal.models.entity_type import EntityType
+from vrt_lss_universal.models.entity_warning import EntityWarning
+from vrt_lss_universal.models.entity_warning_type import EntityWarningType
+from vrt_lss_universal.models.facts import Facts
+from vrt_lss_universal.models.general401 import General401
+from vrt_lss_universal.models.general402 import General402
+from vrt_lss_universal.models.general403 import General403
+from vrt_lss_universal.models.general404 import General404
+from vrt_lss_universal.models.general404_detail import General404Detail
+from vrt_lss_universal.models.general429 import General429
+from vrt_lss_universal.models.general500 import General500
+from vrt_lss_universal.models.geo_settings import GeoSettings
+from vrt_lss_universal.models.geopoint import Geopoint
+from vrt_lss_universal.models.hardlink import Hardlink
+from vrt_lss_universal.models.hardlink_element import HardlinkElement
+from vrt_lss_universal.models.hardlink_element_type import HardlinkElementType
+from vrt_lss_universal.models.location import Location
+from vrt_lss_universal.models.location_compatibilities import LocationCompatibilities
+from vrt_lss_universal.models.measurements import Measurements
+from vrt_lss_universal.models.model_break import ModelBreak
+from vrt_lss_universal.models.object_metrics import ObjectMetrics
+from vrt_lss_universal.models.order import Order
+from vrt_lss_universal.models.order_compatibilities import OrderCompatibilities
+from vrt_lss_universal.models.order_fact import OrderFact
+from vrt_lss_universal.models.performer import Performer
+from vrt_lss_universal.models.performer_compatibilities import PerformerCompatibilities
+from vrt_lss_universal.models.performer_fact import PerformerFact
+from vrt_lss_universal.models.performer_limits import PerformerLimits
+from vrt_lss_universal.models.performer_shift import PerformerShift
+from vrt_lss_universal.models.performer_tariff import PerformerTariff
+from vrt_lss_universal.models.performer_tariff_constraint import PerformerTariffConstraint
+from vrt_lss_universal.models.plan_result import PlanResult
+from vrt_lss_universal.models.plan_settings import PlanSettings
+from vrt_lss_universal.models.plan_statistics import PlanStatistics
+from vrt_lss_universal.models.plan_task import PlanTask
+from vrt_lss_universal.models.possible_event import PossibleEvent
+from vrt_lss_universal.models.quality_statistics import QualityStatistics
+from vrt_lss_universal.models.replan_settings import ReplanSettings
+from vrt_lss_universal.models.replan_strategy import ReplanStrategy
+from vrt_lss_universal.models.replan_task import ReplanTask
+from vrt_lss_universal.models.routing_matrix import RoutingMatrix
+from vrt_lss_universal.models.routing_transport_matrix import RoutingTransportMatrix
+from vrt_lss_universal.models.schema_error import SchemaError
+from vrt_lss_universal.models.service_name import ServiceName
+from vrt_lss_universal.models.statistics import Statistics
+from vrt_lss_universal.models.stop_statistics import StopStatistics
+from vrt_lss_universal.models.time_window import TimeWindow
+from vrt_lss_universal.models.time_window_violations import TimeWindowViolations
+from vrt_lss_universal.models.tracedata import Tracedata
+from vrt_lss_universal.models.track_point import TrackPoint
+from vrt_lss_universal.models.transport import Transport
+from vrt_lss_universal.models.transport_compatibilities import TransportCompatibilities
+from vrt_lss_universal.models.transport_fact import TransportFact
+from vrt_lss_universal.models.transport_factor import TransportFactor
+from vrt_lss_universal.models.transport_limits import TransportLimits
+from vrt_lss_universal.models.transport_load import TransportLoad
+from vrt_lss_universal.models.transport_shift import TransportShift
+from vrt_lss_universal.models.transport_tariff import TransportTariff
+from vrt_lss_universal.models.transport_tariff_constraint import TransportTariffConstraint
+from vrt_lss_universal.models.transport_type import TransportType
+from vrt_lss_universal.models.trip import Trip
+from vrt_lss_universal.models.trip_assumptions import TripAssumptions
+from vrt_lss_universal.models.trip_penalties import TripPenalties
+from vrt_lss_universal.models.trip_start_time_strategy import TripStartTimeStrategy
+from vrt_lss_universal.models.trip_state import TripState
+from vrt_lss_universal.models.trip_state_flag import TripStateFlag
+from vrt_lss_universal.models.trip_statistics import TripStatistics
+from vrt_lss_universal.models.trips_settings import TripsSettings
+from vrt_lss_universal.models.universal_data import UniversalData
+from vrt_lss_universal.models.unplanned_items import UnplannedItems
+from vrt_lss_universal.models.validate_result import ValidateResult
+from vrt_lss_universal.models.version_result import VersionResult
+from vrt_lss_universal.models.waypoint import Waypoint
+from vrt_lss_universal.models.work_and_rest_rules import WorkAndRestRules
```

## vrt_lss_universal/api_client.py

```diff
@@ -1,84 +1,87 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
-import json
 import atexit
+import datetime
+from dateutil.parser import parse
+import json
 import mimetypes
 from multiprocessing.pool import ThreadPool
-import io
 import os
 import re
-import typing
-from urllib.parse import quote
-from urllib3.fields import RequestField
+import tempfile
 
+from urllib.parse import quote
 
-from vrt_lss_universal import rest
 from vrt_lss_universal.configuration import Configuration
-from vrt_lss_universal.exceptions import ApiTypeError, ApiValueError, ApiException
-from vrt_lss_universal.model_utils import (
-    ModelNormal,
-    ModelSimple,
-    ModelComposed,
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    deserialize_file,
-    file_type,
-    model_to_dict,
-    none_type,
-    validate_and_convert_types
-)
+import vrt_lss_universal.models
+from vrt_lss_universal import rest
+from vrt_lss_universal.exceptions import ApiValueError, ApiException
 
 
 class ApiClient(object):
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
-    NOTE: This class is auto generated by OpenAPI Generator.
-    Do not edit the class manually.
-
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     :param pool_threads: The number of threads to use for async requests
         to the API. More threads means more concurrent API requests.
     """
 
+    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
+    NATIVE_TYPES_MAPPING = {
+        'int': int,
+        'long': int, # TODO remove as only py3 is supported?
+        'float': float,
+        'str': str,
+        'bool': bool,
+        'date': datetime.date,
+        'datetime': datetime.datetime,
+        'object': object,
+    }
     _pool = None
 
     def __init__(self, configuration=None, header_name=None, header_value=None,
                  cookie=None, pool_threads=1):
+        # use default configuration if none is provided
         if configuration is None:
-            configuration = Configuration.get_default_copy()
+            configuration = Configuration.get_default()
         self.configuration = configuration
         self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/6.4.1962/python'
+        self.user_agent = 'OpenAPI-Generator/6.5.1990/python'
+        self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
         self.close()
 
@@ -108,35 +111,48 @@
     @user_agent.setter
     def user_agent(self, value):
         self.default_headers['User-Agent'] = value
 
     def set_default_header(self, header_name, header_value):
         self.default_headers[header_name] = header_value
 
+
+    _default = None
+
+    @classmethod
+    def get_default(cls):
+        """Return new instance of ApiClient.
+
+        This method returns newly created, based on default constructor,
+        object of ApiClient class or returns a copy of default
+        ApiClient.
+
+        :return: The ApiClient object.
+        """
+        if cls._default is None:
+            cls._default = ApiClient()
+        return cls._default
+
+    @classmethod
+    def set_default(cls, default):
+        """Set default instance of ApiClient.
+
+        It stores default ApiClient.
+
+        :param default: object of ApiClient.
+        """
+        cls._default = default
+
     def __call_api(
-        self,
-        resource_path: str,
-        method: str,
-        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        body: typing.Optional[typing.Any] = None,
-        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,
-        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,
-        auth_settings: typing.Optional[typing.List[str]] = None,
-        _return_http_data_only: typing.Optional[bool] = None,
-        collection_formats: typing.Optional[typing.Dict[str, str]] = None,
-        _preload_content: bool = True,
-        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,
-        _host: typing.Optional[str] = None,
-        _check_type: typing.Optional[bool] = None,
-        _content_type: typing.Optional[str] = None,
-        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None
-    ):
+            self, resource_path, method, path_params=None,
+            query_params=None, header_params=None, body=None, post_params=None,
+            files=None, response_types_map=None, auth_settings=None,
+            _return_http_data_only=None, collection_formats=None,
+            _preload_content=True, _request_timeout=None, _host=None,
+            _request_auth=None):
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
@@ -154,338 +170,311 @@
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
                     '{%s}' % k,
                     quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
-        # query parameters
-        if query_params:
-            query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
-
         # post parameters
         if post_params or files:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
             post_params = self.parameters_to_tuples(post_params,
                                                     collection_formats)
             post_params.extend(self.files_parameters(files))
-            if header_params['Content-Type'].startswith("multipart"):
-                post_params = self.parameters_to_multipart(post_params,
-                                                          (dict) )
+
+        # auth setting
+        self.update_params_for_auth(
+            header_params, query_params, auth_settings,
+            resource_path, method, body,
+            request_auth=_request_auth)
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
-        # auth setting
-        self.update_params_for_auth(header_params, query_params,
-                                    auth_settings, resource_path, method, body,
-                                    request_auths=_request_auths)
-
         # request url
         if _host is None:
             url = self.configuration.host + resource_path
         else:
             # use server/host defined in path or operation instead
             url = _host + resource_path
 
+        # query parameters
+        if query_params:
+            query_params = self.sanitize_for_serialization(query_params)
+            url_query = self.parameters_to_url_query(query_params,
+                                                     collection_formats)
+            url += "?" + url_query
+
         try:
             # perform request and return response
             response_data = self.request(
-                method, url, query_params=query_params, headers=header_params,
+                method, url,
+                query_params=query_params,
+                headers=header_params,
                 post_params=post_params, body=body,
                 _preload_content=_preload_content,
                 _request_timeout=_request_timeout)
         except ApiException as e:
-            e.body = e.body.decode('utf-8')
+            if e.body:
+                e.body = e.body.decode('utf-8')
             raise e
 
         self.last_response = response_data
 
         return_data = response_data
 
         if not _preload_content:
-            return (return_data)
             return return_data
 
+        response_type = response_types_map.get(str(response_data.status), None)
+
+        if response_type == "bytearray":
+            response_data.data = response_data.data
+        else:
+            match = None
+            content_type = response_data.getheader('content-type')
+            if content_type is not None:
+                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+            encoding = match.group(1) if match else "utf-8"
+            response_data.data = response_data.data.decode(encoding)
+
         # deserialize response data
-        if response_type:
-            if response_type != (file_type,):
-                encoding = "utf-8"
-                content_type = response_data.getheader('content-type')
-                if content_type is not None:
-                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s\;]?", content_type)
-                    if match:
-                        encoding = match.group(1)
-                response_data.data = response_data.data.decode(encoding)
-
-            return_data = self.deserialize(
-                response_data,
-                response_type,
-                _check_type
-            )
+        if response_type == "bytearray":
+            return_data = response_data.data
+        elif response_type:
+            return_data = self.deserialize(response_data, response_type)
         else:
             return_data = None
 
         if _return_http_data_only:
             return (return_data)
         else:
             return (return_data, response_data.status,
                     response_data.getheaders())
 
-    def parameters_to_multipart(self, params, collection_types):
-        """Get parameters as list of tuples, formatting as json if value is collection_types
-
-        :param params: Parameters as list of two-tuples
-        :param dict collection_types: Parameter collection types
-        :return: Parameters as list of tuple or urllib3.fields.RequestField
-        """
-        new_params = []
-        if collection_types is None:
-            collection_types = (dict)
-        for k, v in params.items() if isinstance(params, dict) else params:  
-            if isinstance(v, collection_types): # v is instance of collection_type, formatting as application/json
-                 v = json.dumps(v, ensure_ascii=False).encode("utf-8")
-                 field = RequestField(k, v)
-                 field.make_multipart(content_type="application/json; charset=utf-8")
-                 new_params.append(field)
-            else:
-                 new_params.append((k, v))
-        return new_params
+    def sanitize_for_serialization(self, obj):
+        """Builds a JSON POST object.
 
-    @classmethod
-    def sanitize_for_serialization(cls, obj):
-        """Prepares data for transmission before it is sent with the rest client
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
             convert to string in iso8601 format.
         If obj is list, sanitize each element in the list.
         If obj is dict, return the dict.
         If obj is OpenAPI model, return the properties dict.
-        If obj is io.IOBase, return the bytes
+
         :param obj: The data to serialize.
         :return: The serialized form of data.
         """
-        if isinstance(obj, (ModelNormal, ModelComposed)):
-            return {
-                key: cls.sanitize_for_serialization(val) for key, val in model_to_dict(obj, serialize=True).items()
-            }
-        elif isinstance(obj, io.IOBase):
-            return cls.get_file_data_and_close_file(obj)
-        elif isinstance(obj, (str, int, float, none_type, bool)):
+        if obj is None:
+            return None
+        elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
-        elif isinstance(obj, (datetime, date)):
+        elif isinstance(obj, list):
+            return [self.sanitize_for_serialization(sub_obj)
+                    for sub_obj in obj]
+        elif isinstance(obj, tuple):
+            return tuple(self.sanitize_for_serialization(sub_obj)
+                         for sub_obj in obj)
+        elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
-        elif isinstance(obj, ModelSimple):
-            return cls.sanitize_for_serialization(obj.value)
-        elif isinstance(obj, (list, tuple)):
-            return [cls.sanitize_for_serialization(item) for item in obj]
+
         if isinstance(obj, dict):
-            return {key: cls.sanitize_for_serialization(val) for key, val in obj.items()}
-        raise ApiValueError('Unable to prepare type {} for serialization'.format(obj.__class__.__name__))
+            obj_dict = obj
+        else:
+            # Convert model obj to dict except
+            # attributes `openapi_types`, `attribute_map`
+            # and attributes which value is not None.
+            # Convert attribute name to json key in
+            # model definition for request.
+            obj_dict = obj.to_dict()
+
+        return {key: self.sanitize_for_serialization(val)
+                for key, val in obj_dict.items()}
 
-    def deserialize(self, response, response_type, _check_type):
+    def deserialize(self, response, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
-        :param response_type: For the response, a tuple containing:
-            valid classes
-            a list containing valid classes (for list schemas)
-            a dict containing a tuple of valid classes as the value
-            Example values:
-            (str,)
-            (Pet,)
-            (float, none_type)
-            ([int, none_type],)
-            ({str: (bool, str, int, float, date, datetime, str, none_type)},)
-        :param _check_type: boolean, whether to check the types of the data
-            received from the server
-        :type _check_type: bool
+        :param response_type: class literal for
+            deserialized object, or string of class name.
 
         :return: deserialized object.
         """
         # handle file downloading
         # save response body into a tmp file and return the instance
-        if response_type == (file_type,):
-            content_disposition = response.getheader("Content-Disposition")
-            return deserialize_file(response.data, self.configuration,
-                                    content_disposition=content_disposition)
+        if response_type == "file":
+            return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            received_data = json.loads(response.data)
+            data = json.loads(response.data)
         except ValueError:
-            received_data = response.data
+            data = response.data
+
+        return self.__deserialize(data, response_type)
+
+    def __deserialize(self, data, klass):
+        """Deserializes dict, list, str into an object.
+
+        :param data: dict, list or str.
+        :param klass: class literal, or string of class name.
+
+        :return: object.
+        """
+        if data is None:
+            return None
+
+        if type(klass) == str:
+            if klass.startswith('List['):
+                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls)
+                        for sub_data in data]
+
+            if klass.startswith('Dict['):
+                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
+                return {k: self.__deserialize(v, sub_kls)
+                        for k, v in data.items()}
+
+            # convert str to class
+            if klass in self.NATIVE_TYPES_MAPPING:
+                klass = self.NATIVE_TYPES_MAPPING[klass]
+            else:
+                klass = getattr(vrt_lss_universal.models, klass)
 
-        # store our data under the key of 'received_data' so users have some
-        # context if they are deserializing a string and the data type is wrong
-        deserialized_data = validate_and_convert_types(
-            received_data,
-            response_type,
-            ['received_data'],
-            True,
-            _check_type,
-            configuration=self.configuration
-        )
-        return deserialized_data
-
-    def call_api(
-        self,
-        resource_path: str,
-        method: str,
-        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        body: typing.Optional[typing.Any] = None,
-        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,
-        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,
-        auth_settings: typing.Optional[typing.List[str]] = None,
-        async_req: typing.Optional[bool] = None,
-        _return_http_data_only: typing.Optional[bool] = None,
-        collection_formats: typing.Optional[typing.Dict[str, str]] = None,
-        _preload_content: bool = True,
-        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,
-        _host: typing.Optional[str] = None,
-        _check_type: typing.Optional[bool] = None,
-        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None
-    ):
+        if klass in self.PRIMITIVE_TYPES:
+            return self.__deserialize_primitive(data, klass)
+        elif klass == object:
+            return self.__deserialize_object(data)
+        elif klass == datetime.date:
+            return self.__deserialize_date(data)
+        elif klass == datetime.datetime:
+            return self.__deserialize_datetime(data)
+        else:
+            return self.__deserialize_model(data, klass)
+
+    def call_api(self, resource_path, method,
+                 path_params=None, query_params=None, header_params=None,
+                 body=None, post_params=None, files=None,
+                 response_types_map=None, auth_settings=None,
+                 async_req=None, _return_http_data_only=None,
+                 collection_formats=None,_preload_content=True,
+                  _request_timeout=None, _host=None, _request_auth=None):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async_req request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
         :param query_params: Query parameters in the url.
         :param header_params: Header parameters to be
             placed in the request header.
         :param body: Request body.
         :param post_params dict: Request post form parameters,
             for `application/x-www-form-urlencoded`, `multipart/form-data`.
         :param auth_settings list: Auth Settings names for the request.
-        :param response_type: For the response, a tuple containing:
-            valid classes
-            a list containing valid classes (for list schemas)
-            a dict containing a tuple of valid classes as the value
-            Example values:
-            (str,)
-            (Pet,)
-            (float, none_type)
-            ([int, none_type],)
-            ({str: (bool, str, int, float, date, datetime, str, none_type)},)
-        :param files: key -> field name, value -> a list of open file
-            objects for `multipart/form-data`.
-        :type files: dict
+        :param response: Response data type.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
         :param async_req bool: execute request asynchronously
-        :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
-        :type _return_http_data_only: bool, optional
         :param collection_formats: dict of collection formats for path, query,
             header, and post parameters.
-        :type collection_formats: dict, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
-        :param _check_type: boolean describing if the data back from the server
-            should have its type checked.
-        :type _check_type: bool, optional
-        :param _request_auths: set to override the auth_settings for an a single
+        :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
-        :type _request_auths: list, optional
+        :type _request_token: dict, optional
         :return:
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
         if not async_req:
             return self.__call_api(resource_path, method,
                                    path_params, query_params, header_params,
                                    body, post_params, files,
-                                   response_type, auth_settings,
+                                   response_types_map, auth_settings,
                                    _return_http_data_only, collection_formats,
                                    _preload_content, _request_timeout, _host,
-                                   _check_type, _request_auths=_request_auths)
+                                   _request_auth)
 
         return self.pool.apply_async(self.__call_api, (resource_path,
                                                        method, path_params,
                                                        query_params,
                                                        header_params, body,
                                                        post_params, files,
-                                                       response_type,
+                                                       response_types_map,
                                                        auth_settings,
                                                        _return_http_data_only,
                                                        collection_formats,
                                                        _preload_content,
                                                        _request_timeout,
-                                                       _host, _check_type, None, _request_auths))
+                                                       _host, _request_auth))
 
     def request(self, method, url, query_params=None, headers=None,
                 post_params=None, body=None, _preload_content=True,
                 _request_timeout=None):
         """Makes the HTTP request using RESTClient."""
         if method == "GET":
-            return self.rest_client.GET(url,
+            return self.rest_client.get_request(url,
                                         query_params=query_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         headers=headers)
         elif method == "HEAD":
-            return self.rest_client.HEAD(url,
+            return self.rest_client.head_request(url,
                                          query_params=query_params,
                                          _preload_content=_preload_content,
                                          _request_timeout=_request_timeout,
                                          headers=headers)
         elif method == "OPTIONS":
-            return self.rest_client.OPTIONS(url,
+            return self.rest_client.options_request(url,
                                             query_params=query_params,
                                             headers=headers,
-                                            post_params=post_params,
                                             _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout,
-                                            body=body)
+                                            _request_timeout=_request_timeout)
         elif method == "POST":
-            return self.rest_client.POST(url,
+            return self.rest_client.post_request(url,
                                          query_params=query_params,
                                          headers=headers,
                                          post_params=post_params,
                                          _preload_content=_preload_content,
                                          _request_timeout=_request_timeout,
                                          body=body)
         elif method == "PUT":
-            return self.rest_client.PUT(url,
+            return self.rest_client.put_request(url,
                                         query_params=query_params,
                                         headers=headers,
                                         post_params=post_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         body=body)
         elif method == "PATCH":
-            return self.rest_client.PATCH(url,
+            return self.rest_client.patch_request(url,
                                           query_params=query_params,
                                           headers=headers,
                                           post_params=post_params,
                                           _preload_content=_preload_content,
                                           _request_timeout=_request_timeout,
                                           body=body)
         elif method == "DELETE":
-            return self.rest_client.DELETE(url,
+            return self.rest_client.delete_request(url,
                                            query_params=query_params,
                                            headers=headers,
                                            _preload_content=_preload_content,
                                            _request_timeout=_request_timeout,
                                            body=body)
         else:
             raise ApiValueError(
@@ -499,15 +488,15 @@
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  
+        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
@@ -519,367 +508,247 @@
                         delimiter = ','
                     new_params.append(
                         (k, delimiter.join(str(value) for value in v)))
             else:
                 new_params.append((k, v))
         return new_params
 
-    @staticmethod
-    def get_file_data_and_close_file(file_instance: io.IOBase) -> bytes:
-        file_data = file_instance.read()
-        file_instance.close()
-        return file_data
+    def parameters_to_url_query(self, params, collection_formats):
+        """Get parameters as list of tuples, formatting collections.
+
+        :param params: Parameters as dict or list of two-tuples
+        :param dict collection_formats: Parameter collection formats
+        :return: URL query string (e.g. a=Hello%20World&b=123)
+        """
+        new_params = []
+        if collection_formats is None:
+            collection_formats = {}
+        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+            if isinstance(v, (int, float)):
+                v = str(v)
+            if isinstance(v, bool):
+                v = str(v).lower()
+            if isinstance(v, dict):
+                v = json.dumps(v)
+
+            if k in collection_formats:
+                collection_format = collection_formats[k]
+                if collection_format == 'multi':
+                    new_params.extend((k, value) for value in v)
+                else:
+                    if collection_format == 'ssv':
+                        delimiter = ' '
+                    elif collection_format == 'tsv':
+                        delimiter = '\t'
+                    elif collection_format == 'pipes':
+                        delimiter = '|'
+                    else:  # csv is the default
+                        delimiter = ','
+                    new_params.append(
+                        (k, delimiter.join(quote(str(value)) for value in v)))
+            else:
+                new_params.append((k, quote(str(v))))
+
+        return "&".join(["=".join(item) for item in new_params])
 
-    def files_parameters(self, files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None):
+    def files_parameters(self, files=None):
         """Builds form parameters.
 
-        :param files: None or a dict with key=param_name and
-            value is a list of open file objects
-        :return: List of tuples of form parameters with file data
+        :param files: File parameters.
+        :return: Form parameters with files.
         """
-        if files is None:
-            return []
-
         params = []
-        for param_name, file_instances in files.items():
-            if file_instances is None:
-                # if the file field is nullable, skip None values
-                continue
-            for file_instance in file_instances:
-                if file_instance is None:
-                    # if the file field is nullable, skip None values
+
+        if files:
+            for k, v in files.items():
+                if not v:
                     continue
-                if file_instance.closed is True:
-                    raise ApiValueError(
-                        "Cannot read a closed file. The passed in file_type "
-                        "for %s must be open." % param_name
-                    )
-                filename = os.path.basename(file_instance.name)
-                filedata = self.get_file_data_and_close_file(file_instance)
-                mimetype = (mimetypes.guess_type(filename)[0] or
-                            'application/octet-stream')
-                params.append(
-                    tuple([param_name, tuple([filename, filedata, mimetype])]))
+                file_names = v if type(v) is list else [v]
+                for n in file_names:
+                    with open(n, 'rb') as f:
+                        filename = os.path.basename(f.name)
+                        filedata = f.read()
+                        mimetype = (mimetypes.guess_type(filename)[0] or
+                                    'application/octet-stream')
+                        params.append(
+                            tuple([k, tuple([filename, filedata, mimetype])]))
 
         return params
 
     def select_header_accept(self, accepts):
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
             return
 
-        accepts = [x.lower() for x in accepts]
+        for accept in accepts:
+            if re.search('json', accept, re.IGNORECASE):
+                return accept
 
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
+        return accepts[0]
 
-    def select_header_content_type(self, content_types, method=None, body=None):
+    def select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
-        :param method: http method (e.g. POST, PATCH).
-        :param body: http body to send.
         :return: Content-Type (e.g. application/json).
         """
         if not content_types:
             return None
 
-        content_types = [x.lower() for x in content_types]
+        for content_type in content_types:
+            if re.search('json', content_type, re.IGNORECASE):
+                return content_type
 
-        if (method == 'PATCH' and
-                'application/json-patch+json' in content_types and
-                isinstance(body, list)):
-            return 'application/json-patch+json'
-
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
-        else:
-            return content_types[0]
+        return content_types[0]
 
     def update_params_for_auth(self, headers, queries, auth_settings,
-                               resource_path, method, body, request_auths=None):
+                               resource_path, method, body,
+                               request_auth=None):
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
-        :param resource_path: A string representation of the HTTP request resource path.
-        :param method: A string representation of the HTTP request method.
-        :param body: A object representing the body of the HTTP request.
-            The object type is the return value of _encoder.default().
-        :param request_auths: if set, the provided settings will
-            override the token in the configuration.
+        :resource_path: A string representation of the HTTP request resource path.
+        :method: A string representation of the HTTP request method.
+        :body: A object representing the body of the HTTP request.
+        The object type is the return value of sanitize_for_serialization().
+        :param request_auth: if set, the provided settings will
+                             override the token in the configuration.
         """
         if not auth_settings:
             return
 
-        if request_auths:
-            for auth_setting in request_auths:
-                self._apply_auth_params(headers, queries, resource_path, method, body, auth_setting)
+        if request_auth:
+            self._apply_auth_params(headers, queries,
+                                    resource_path, method, body,
+                                    request_auth)
             return
 
         for auth in auth_settings:
             auth_setting = self.configuration.auth_settings().get(auth)
             if auth_setting:
-                self._apply_auth_params(headers, queries, resource_path, method, body, auth_setting)
+                self._apply_auth_params(headers, queries,
+                                        resource_path, method, body,
+                                        auth_setting)
+
+    def _apply_auth_params(self, headers, queries,
+                           resource_path, method, body,
+                           auth_setting):
+        """Updates the request parameters based on a single auth_setting
 
-    def _apply_auth_params(self, headers, queries, resource_path, method, body, auth_setting):
+        :param headers: Header parameters dict to be updated.
+        :param queries: Query parameters tuple list to be updated.
+        :resource_path: A string representation of the HTTP request resource path.
+        :method: A string representation of the HTTP request method.
+        :body: A object representing the body of the HTTP request.
+        The object type is the return value of sanitize_for_serialization().
+        :param auth_setting: auth settings for the endpoint
+        """
         if auth_setting['in'] == 'cookie':
             headers['Cookie'] = auth_setting['value']
         elif auth_setting['in'] == 'header':
             if auth_setting['type'] != 'http-signature':
                 headers[auth_setting['key']] = auth_setting['value']
         elif auth_setting['in'] == 'query':
             queries.append((auth_setting['key'], auth_setting['value']))
         else:
             raise ApiValueError(
                 'Authentication token must be in `query` or `header`'
             )
 
+    def __deserialize_file(self, response):
+        """Deserializes body to file
 
-class Endpoint(object):
-    def __init__(self, settings=None, params_map=None, root_map=None,
-                 headers_map=None, api_client=None, callable=None):
-        """Creates an endpoint
-
-        Args:
-            settings (dict): see below key value pairs
-                'response_type' (tuple/None): response type
-                'auth' (list): a list of auth type keys
-                'endpoint_path' (str): the endpoint path
-                'operation_id' (str): endpoint string identifier
-                'http_method' (str): POST/PUT/PATCH/GET etc
-                'servers' (list): list of str servers that this endpoint is at
-            params_map (dict): see below key value pairs
-                'all' (list): list of str endpoint parameter names
-                'required' (list): list of required parameter names
-                'nullable' (list): list of nullable parameter names
-                'enum' (list): list of parameters with enum values
-                'validation' (list): list of parameters with validations
-            root_map
-                'validations' (dict): the dict mapping endpoint parameter tuple
-                    paths to their validation dictionaries
-                'allowed_values' (dict): the dict mapping endpoint parameter
-                    tuple paths to their allowed_values (enum) dictionaries
-                'openapi_types' (dict): param_name to openapi type
-                'attribute_map' (dict): param_name to camelCase name
-                'location_map' (dict): param_name to  'body', 'file', 'form',
-                    'header', 'path', 'query'
-                collection_format_map (dict): param_name to `csv` etc.
-            headers_map (dict): see below key value pairs
-                'accept' (list): list of Accept header strings
-                'content_type' (list): list of Content-Type header strings
-            api_client (ApiClient) api client instance
-            callable (function): the function which is invoked when the
-                Endpoint is called
-        """
-        self.settings = settings
-        self.params_map = params_map
-        self.params_map['all'].extend([
-            'async_req',
-            '_host_index',
-            '_preload_content',
-            '_request_timeout',
-            '_return_http_data_only',
-            '_check_input_type',
-            '_check_return_type',
-            '_content_type',
-            '_spec_property_naming',
-            '_request_auths'
-        ])
-        self.params_map['nullable'].extend(['_request_timeout'])
-        self.validations = root_map['validations']
-        self.allowed_values = root_map['allowed_values']
-        self.openapi_types = root_map['openapi_types']
-        extra_types = {
-            'async_req': (bool,),
-            '_host_index': (none_type, int),
-            '_preload_content': (bool,),
-            '_request_timeout': (none_type, float, (float,), [float], int, (int,), [int]),
-            '_return_http_data_only': (bool,),
-            '_check_input_type': (bool,),
-            '_check_return_type': (bool,),
-            '_spec_property_naming': (bool,),
-            '_content_type': (none_type, str),
-            '_request_auths': (none_type, list)
-        }
-        self.openapi_types.update(extra_types)
-        self.attribute_map = root_map['attribute_map']
-        self.location_map = root_map['location_map']
-        self.collection_format_map = root_map['collection_format_map']
-        self.headers_map = headers_map
-        self.api_client = api_client
-        self.callable = callable
-
-    def __validate_inputs(self, kwargs):
-        for param in self.params_map['enum']:
-            if param in kwargs:
-                check_allowed_values(
-                    self.allowed_values,
-                    (param,),
-                    kwargs[param]
-                )
+        Saves response body into a file in a temporary folder,
+        using the filename from the `Content-Disposition` header if provided.
 
-        for param in self.params_map['validation']:
-            if param in kwargs:
-                check_validations(
-                    self.validations,
-                    (param,),
-                    kwargs[param],
-                    configuration=self.api_client.configuration
-                )
+        :param response:  RESTResponse.
+        :return: file path.
+        """
+        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
+        os.close(fd)
+        os.remove(path)
 
-        if kwargs['_check_input_type'] is False:
-            return
+        content_disposition = response.getheader("Content-Disposition")
+        if content_disposition:
+            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                                 content_disposition).group(1)
+            path = os.path.join(os.path.dirname(path), filename)
 
-        for key, value in kwargs.items():
-            fixed_val = validate_and_convert_types(
-                value,
-                self.openapi_types[key],
-                [key],
-                kwargs['_spec_property_naming'],
-                kwargs['_check_input_type'],
-                configuration=self.api_client.configuration
-            )
-            kwargs[key] = fixed_val
+        with open(path, "wb") as f:
+            f.write(response.data)
 
-    def __gather_params(self, kwargs):
-        params = {
-            'body': None,
-            'collection_format': {},
-            'file': {},
-            'form': [],
-            'header': {},
-            'path': {},
-            'query': []
-        }
-
-        for param_name, param_value in kwargs.items():
-            param_location = self.location_map.get(param_name)
-            if param_location is None:
-                continue
-            if param_location:
-                if param_location == 'body':
-                    params['body'] = param_value
-                    continue
-                base_name = self.attribute_map[param_name]
-                if (param_location == 'form' and
-                        self.openapi_types[param_name] == (file_type,)):
-                    params['file'][base_name] = [param_value]
-                elif (param_location == 'form' and
-                        self.openapi_types[param_name] == ([file_type],)):
-                    # param_value is already a list
-                    params['file'][base_name] = param_value
-                elif param_location in {'form', 'query'}:
-                    param_value_full = (base_name, param_value)
-                    params[param_location].append(param_value_full)
-                if param_location not in {'form', 'query'}:
-                    params[param_location][base_name] = param_value
-                collection_format = self.collection_format_map.get(param_name)
-                if collection_format:
-                    params['collection_format'][base_name] = collection_format
+        return path
 
-        return params
+    def __deserialize_primitive(self, data, klass):
+        """Deserializes string to primitive type.
 
-    def __call__(self, *args, **kwargs):
-        """ This method is invoked when endpoints are called
-        Example:
+        :param data: str.
+        :param klass: class literal.
+
+        :return: int, long, float, str, bool.
+        """
+        try:
+            return klass(data)
+        except UnicodeEncodeError:
+            return str(data)
+        except TypeError:
+            return data
 
-        api_instance = ActualizeApi()
-        api_instance.run_actualize_calculation  # this is an instance of the class Endpoint
-        api_instance.run_actualize_calculation()  # this invokes api_instance.run_actualize_calculation.__call__()
-        which then invokes the callable functions stored in that endpoint at
-        api_instance.run_actualize_calculation.callable or self.callable in this class
+    def __deserialize_object(self, value):
+        """Return an original value.
 
+        :return: object.
         """
-        return self.callable(self, *args, **kwargs)
+        return value
 
-    def call_with_http_info(self, **kwargs):
+    def __deserialize_date(self, string):
+        """Deserializes string to date.
 
+        :param string: str.
+        :return: date.
+        """
         try:
-            index = self.api_client.configuration.server_operation_index.get(
-                self.settings['operation_id'], self.api_client.configuration.server_index
-            ) if kwargs['_host_index'] is None else kwargs['_host_index']
-            server_variables = self.api_client.configuration.server_operation_variables.get(
-                self.settings['operation_id'], self.api_client.configuration.server_variables
-            )
-            _host = self.api_client.configuration.get_host_from_settings(
-                index, variables=server_variables, servers=self.settings['servers']
+            return parse(string).date()
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason="Failed to parse `{0}` as date object".format(string)
             )
-        except IndexError:
-            if self.settings['servers']:
-                raise ApiValueError(
-                    "Invalid host index. Must be 0 <= index < %s" %
-                    len(self.settings['servers'])
-                )
-            _host = None
 
-        for key, value in kwargs.items():
-            if key not in self.params_map['all']:
-                raise ApiTypeError(
-                    "Got an unexpected parameter '%s'"
-                    " to method `%s`" %
-                    (key, self.settings['operation_id'])
-                )
-            # only throw this nullable ApiValueError if _check_input_type
-            # is False, if _check_input_type==True we catch this case
-            # in self.__validate_inputs
-            if (key not in self.params_map['nullable'] and value is None
-                    and kwargs['_check_input_type'] is False):
-                raise ApiValueError(
-                    "Value may not be None for non-nullable parameter `%s`"
-                    " when calling `%s`" %
-                    (key, self.settings['operation_id'])
-                )
+    def __deserialize_datetime(self, string):
+        """Deserializes string to datetime.
 
-        for key in self.params_map['required']:
-            if key not in kwargs.keys():
-                raise ApiValueError(
-                    "Missing the required parameter `%s` when calling "
-                    "`%s`" % (key, self.settings['operation_id'])
-                )
+        The string should be in iso8601 datetime format.
 
-        self.__validate_inputs(kwargs)
+        :param string: str.
+        :return: datetime.
+        """
+        try:
+            return parse(string)
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason=(
+                    "Failed to parse `{0}` as datetime object"
+                    .format(string)
+                )
+            )
 
-        params = self.__gather_params(kwargs)
+    def __deserialize_model(self, data, klass):
+        """Deserializes list or dict to model.
 
-        accept_headers_list = self.headers_map['accept']
-        if accept_headers_list:
-            params['header']['Accept'] = self.api_client.select_header_accept(
-                accept_headers_list)
+        :param data: dict, list.
+        :param klass: class literal.
+        :return: model object.
+        """
 
-        if kwargs.get('_content_type'):
-            params['header']['Content-Type'] = kwargs['_content_type']
-        else:
-            content_type_headers_list = self.headers_map['content_type']
-            if content_type_headers_list:
-                if params['body'] != "":
-                    content_types_list = self.api_client.select_header_content_type(
-                        content_type_headers_list, self.settings['http_method'],
-                        params['body'])
-                    if content_types_list:
-                        params['header']['Content-Type'] = content_types_list
-
-        return self.api_client.call_api(
-            self.settings['endpoint_path'], self.settings['http_method'],
-            params['path'],
-            params['query'],
-            params['header'],
-            body=params['body'],
-            post_params=params['form'],
-            files=params['file'],
-            response_type=self.settings['response_type'],
-            auth_settings=self.settings['auth'],
-            async_req=kwargs['async_req'],
-            _check_type=kwargs['_check_return_type'],
-            _return_http_data_only=kwargs['_return_http_data_only'],
-            _preload_content=kwargs['_preload_content'],
-            _request_timeout=kwargs['_request_timeout'],
-            _host=_host,
-            _request_auths=kwargs['_request_auths'],
-            collection_formats=params['collection_format'])
+        return klass.from_dict(data)
```

## vrt_lss_universal/configuration.py

```diff
@@ -1,94 +1,72 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import copy
 import logging
 import multiprocessing
 import sys
 import urllib3
 
-from http import client as http_client
+import http.client as httplib
 from vrt_lss_universal.exceptions import ApiValueError
 
-
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
     'multipleOf', 'maximum', 'exclusiveMaximum',
     'minimum', 'exclusiveMinimum', 'maxLength',
     'minLength', 'pattern', 'maxItems', 'minItems'
 }
 
 class Configuration(object):
-    """NOTE: This class is auto generated by OpenAPI Generator
-
-    Do not edit the class manually.
+    """This class contains various settings of the API client.
 
-    :param host: Base url
+    :param host: Base url.
     :param api_key: Dict to store API key(s).
       Each entry in the dict specifies an API key.
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is the API key secret.
-    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)
+    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is an API key prefix when generating the auth data.
-    :param username: Username for HTTP basic authentication
-    :param password: Password for HTTP basic authentication
-    :param discard_unknown_keys: Boolean value indicating whether to discard
-      unknown properties. A server may send a response that includes additional
-      properties that are not known by the client in the following scenarios:
-      1. The OpenAPI document is incomplete, i.e. it does not match the server
-         implementation.
-      2. The client was generated using an older version of the OpenAPI document
-         and the server has been upgraded since then.
-      If a schema in the OpenAPI document defines the additionalProperties attribute,
-      then all undeclared properties received by the server are injected into the
-      additional properties map. In that case, there are undeclared properties, and
-      nothing to discard.
-    :param disabled_client_side_validations (string): Comma-separated list of
-      JSON schema validation keywords to disable JSON schema structural validation
-      rules. The following keywords may be specified: multipleOf, maximum,
-      exclusiveMaximum, minimum, exclusiveMinimum, maxLength, minLength, pattern,
-      maxItems, minItems.
-      By default, the validation is performed for data generated locally by the client
-      and data received from the server, independent of any validation performed by
-      the server side. If the input data does not satisfy the JSON schema validation
-      rules specified in the OpenAPI document, an exception is raised.
-      If disabled_client_side_validations is set, structural validation is
-      disabled. This can be useful to troubleshoot data validation problem, such as
-      when the OpenAPI document validation rules do not match the actual API data
-      received by the server.
+    :param username: Username for HTTP basic authentication.
+    :param password: Password for HTTP basic authentication.
+    :param access_token: Access token.
     :param server_index: Index to servers configuration.
     :param server_variables: Mapping with string values to replace variables in
       templated server configuration. The validation of enums is performed for
       variables with defined enum values before.
     :param server_operation_index: Mapping from operation ID to an index to server
       configuration.
     :param server_operation_variables: Mapping from operation ID to a mapping with
       string values to replace variables in templated server configuration.
       The validation of enums is performed for variables with defined enum values before.
     :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
-      in PEM format
+      in PEM format.
 
     :Example:
     """
 
     _default = None
 
     def __init__(self, host=None,
                  api_key=None, api_key_prefix=None,
-                 access_token=None,
                  username=None, password=None,
-                 discard_unknown_keys=False,
-                 disabled_client_side_validations="",
+                 access_token=None,
                  server_index=None, server_variables=None,
                  server_operation_index=None, server_operation_variables=None,
                  ssl_ca_cert=None,
                  ):
         """Constructor
         """
         self._base_path = "https://api.edge.veeroute.tech" if host is None else host
@@ -102,15 +80,14 @@
         self.server_operation_variables = server_operation_variables or {}
         """Default server variables
         """
         self.temp_folder_path = None
         """Temp file folder for downloading files
         """
         # Authentication Settings
-        self.access_token = access_token
         self.api_key = {}
         if api_key:
             self.api_key = api_key
         """dict to store API key(s)
         """
         self.api_key_prefix = {}
         if api_key_prefix:
@@ -122,16 +99,17 @@
         """
         self.username = username
         """Username for HTTP basic authentication
         """
         self.password = password
         """Password for HTTP basic authentication
         """
-        self.discard_unknown_keys = discard_unknown_keys
-        self.disabled_client_side_validations = disabled_client_side_validations
+        self.access_token = access_token
+        """Access token
+        """
         self.logger = {}
         """Logging Settings
         """
         self.logger["package_logger"] = logging.getLogger("vrt_lss_universal")
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         """Log format
@@ -174,31 +152,37 @@
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
         """
 
         self.proxy = None
         """Proxy URL
         """
-        self.no_proxy = None
-        """bypass proxy for host in the no_proxy list.
-        """
         self.proxy_headers = None
         """Proxy headers
         """
         self.safe_chars_for_path_param = ''
         """Safe chars for path_param
         """
         self.retries = None
         """Adding retries to override urllib3 default value 3
         """
         # Enable client side validation
         self.client_side_validation = True
 
-        # Options to pass down to the underlying urllib3 socket
         self.socket_options = None
+        """Options to pass down to the underlying urllib3 socket
+        """
+
+        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
+        """datetime format
+        """
+
+        self.date_format = "%Y-%m-%d"
+        """date format
+        """
 
     def __deepcopy__(self, memo):
         cls = self.__class__
         result = cls.__new__(cls)
         memo[id(self)] = result
         for k, v in self.__dict__.items():
             if k not in ('logger', 'logger_file_handler'):
@@ -208,46 +192,49 @@
         # use setters to configure loggers
         result.logger_file = self.logger_file
         result.debug = self.debug
         return result
 
     def __setattr__(self, name, value):
         object.__setattr__(self, name, value)
-        if name == 'disabled_client_side_validations':
-            s = set(filter(None, value.split(',')))
-            for v in s:
-                if v not in JSON_SCHEMA_VALIDATION_KEYWORDS:
-                    raise ApiValueError(
-                        "Invalid keyword: '{0}''".format(v))
-            self._disabled_client_side_validations = s
 
     @classmethod
     def set_default(cls, default):
         """Set default instance of configuration.
 
         It stores default configuration, which can be
         returned by get_default_copy method.
 
         :param default: object of Configuration
         """
-        cls._default = copy.deepcopy(default)
+        cls._default = default
 
     @classmethod
     def get_default_copy(cls):
-        """Return new instance of configuration.
+        """Deprecated. Please use `get_default` instead.
+
+        Deprecated. Please use `get_default` instead.
+
+        :return: The configuration object.
+        """
+        return cls.get_default()
+
+    @classmethod
+    def get_default(cls):
+        """Return the default configuration.
 
         This method returns newly created, based on default constructor,
         object of Configuration class or returns a copy of default
-        configuration passed by the set_default method.
+        configuration.
 
         :return: The configuration object.
         """
-        if cls._default is not None:
-            return copy.deepcopy(cls._default)
-        return Configuration()
+        if cls._default is None:
+            cls._default = Configuration()
+        return cls._default
 
     @property
     def logger_file(self):
         """The logger file.
 
         If the logger_file is None, then add stream handler and remove file
         handler. Otherwise, add file handler and remove stream handler.
@@ -293,23 +280,23 @@
         :type: bool
         """
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in self.logger.items():
                 logger.setLevel(logging.DEBUG)
-            # turn on http_client debug
-            http_client.HTTPConnection.debuglevel = 1
+            # turn on httplib debug
+            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.WARNING`
             for _, logger in self.logger.items():
                 logger.setLevel(logging.WARNING)
-            # turn off http_client debug
-            http_client.HTTPConnection.debuglevel = 0
+            # turn off httplib debug
+            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
         """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
@@ -382,16 +369,16 @@
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 6.4.1962\n"\
-               "SDK Package Version: 6.4.1962".\
+               "Version of the API: 6.5.1990\n"\
+               "SDK Package Version: 6.5.1990".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

## vrt_lss_universal/exceptions.py

```diff
@@ -1,15 +1,20 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
-"""
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
 
+    Do not edit the code manually
+
+    2023 Veeroute
+"""
 
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
@@ -107,15 +112,15 @@
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
 
     def __str__(self):
         """Custom error messages for exception"""
-        error_message = "Status Code: {0}\n"\
+        error_message = "({0})\n"\
                         "Reason: {1}\n".format(self.status, self.reason)
         if self.headers:
             error_message += "HTTP response headers: {0}\n".format(
                 self.headers)
 
         if self.body:
             error_message += "HTTP response body: {0}\n".format(self.body)
```

## vrt_lss_universal/rest.py

```diff
@@ -1,26 +1,30 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import io
 import json
 import logging
 import re
 import ssl
-from urllib.parse import urlencode
-from urllib.parse import urlparse
-from urllib.request import proxy_bypass_environment
+
+from urllib.parse import urlencode, quote_plus
 import urllib3
-import ipaddress
 
 from vrt_lss_universal.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError
 
 
 logger = logging.getLogger(__name__)
 
 
@@ -30,54 +34,54 @@
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
         self.data = resp.data
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
-        return self.urllib3_response.getheaders()
+        return self.urllib3_response.headers
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
-        return self.urllib3_response.getheader(name, default)
+        return self.urllib3_response.headers.get(name, default)
 
 
 class RESTClientObject(object):
 
     def __init__(self, configuration, pools_size=4, maxsize=None):
         # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  
-        # maxsize is the number of requests to host that are allowed in parallel  
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
+        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
+        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
 
         # cert_reqs
         if configuration.verify_ssl:
             cert_reqs = ssl.CERT_REQUIRED
         else:
             cert_reqs = ssl.CERT_NONE
 
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  
+            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
 
         if configuration.retries is not None:
             addition_pool_args['retries'] = configuration.retries
 
         if configuration.socket_options is not None:
             addition_pool_args['socket_options'] = configuration.socket_options
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
                 maxsize = 4
 
         # https pool manager
-        if configuration.proxy and not should_bypass_proxies(configuration.host, no_proxy=configuration.no_proxy or ''):
+        if configuration.proxy:
             self.pool_manager = urllib3.ProxyManager(
                 num_pools=pools_size,
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=configuration.ssl_ca_cert,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
@@ -124,43 +128,43 @@
         if post_params and body:
             raise ApiValueError(
                 "body parameter cannot be used with post_params parameter."
             )
 
         post_params = post_params or {}
         headers = headers or {}
+        # url already contains the URL query string
+        # so reset query_params to empty dict
+        query_params = {}
 
         timeout = None
         if _request_timeout:
-            if isinstance(_request_timeout, (int, float)):
+            if isinstance(_request_timeout, (int,float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, tuple) and
                   len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(
                     connect=_request_timeout[0], read=_request_timeout[1])
 
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
             if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-                # Only set a default Content-Type for POST, PUT, PATCH and OPTIONS requests
-                if (method != 'DELETE') and ('Content-Type' not in headers):
-                    headers['Content-Type'] = 'application/json'
-                if query_params:
-                    url += '?' + urlencode(query_params)
-                if ('Content-Type' not in headers) or (re.search('json', headers['Content-Type'], re.IGNORECASE)):
+
+                # no content type provided or payload is json
+                if not headers.get('Content-Type') or re.search('json', headers['Content-Type'], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  
+                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=False,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
@@ -192,15 +196,15 @@
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
                     raise ApiException(status=0, reason=msg)
             # For `GET`, `HEAD`
             else:
                 r = self.pool_manager.request(method, url,
-                                              fields=query_params,
+                                              fields={},
                                               preload_content=_preload_content,
                                               timeout=timeout,
                                               headers=headers)
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
 
@@ -223,123 +227,71 @@
             if 500 <= r.status <= 599:
                 raise ServiceException(http_resp=r)
 
             raise ApiException(http_resp=r)
 
         return r
 
-    def GET(self, url, headers=None, query_params=None, _preload_content=True,
+    def get_request(self, url, headers=None, query_params=None, _preload_content=True,
             _request_timeout=None):
         return self.request("GET", url,
                             headers=headers,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             query_params=query_params)
 
-    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
+    def head_request(self, url, headers=None, query_params=None, _preload_content=True,
              _request_timeout=None):
         return self.request("HEAD", url,
                             headers=headers,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             query_params=query_params)
 
-    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
+    def options_request(self, url, headers=None, query_params=None, post_params=None,
                 body=None, _preload_content=True, _request_timeout=None):
         return self.request("OPTIONS", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def DELETE(self, url, headers=None, query_params=None, body=None,
+    def delete_request(self, url, headers=None, query_params=None, body=None,
                _preload_content=True, _request_timeout=None):
         return self.request("DELETE", url,
                             headers=headers,
                             query_params=query_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def POST(self, url, headers=None, query_params=None, post_params=None,
+    def post_request(self, url, headers=None, query_params=None, post_params=None,
              body=None, _preload_content=True, _request_timeout=None):
         return self.request("POST", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def PUT(self, url, headers=None, query_params=None, post_params=None,
+    def put_request(self, url, headers=None, query_params=None, post_params=None,
             body=None, _preload_content=True, _request_timeout=None):
         return self.request("PUT", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def PATCH(self, url, headers=None, query_params=None, post_params=None,
+    def patch_request(self, url, headers=None, query_params=None, post_params=None,
               body=None, _preload_content=True, _request_timeout=None):
         return self.request("PATCH", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
-
-# end of class RESTClientObject
-def is_ipv4(target):
-    """ Test if IPv4 address or not
-    """
-    try:
-       chk = ipaddress.IPv4Address(target)
-       return True
-    except ipaddress.AddressValueError:
-       return False
-
-def in_ipv4net(target, net):
-    """ Test if target belongs to given IPv4 network
-    """
-    try:
-        nw = ipaddress.IPv4Network(net)
-        ip = ipaddress.IPv4Address(target)
-        if ip in nw:
-            return True
-        return False
-    except ipaddress.AddressValueError:
-        return False
-    except ipaddress.NetmaskValueError:
-        return False
-
-def should_bypass_proxies(url, no_proxy=None):
-    """ Yet another requests.should_bypass_proxies
-    Test if proxies should not be used for a particular url.
-    """
-
-    parsed = urlparse(url)
-
-    # special cases
-    if parsed.hostname in [None, '']:
-        return True
-
-    # special cases
-    if no_proxy in [None , '']:
-        return False
-    if no_proxy == '*':
-        return True
-
-    no_proxy = no_proxy.lower().replace(' ','');
-    entries = (
-        host for host in no_proxy.split(',') if host
-    )
-
-    if is_ipv4(parsed.hostname):
-        for item in entries:
-           if in_ipv4net(parsed.hostname, item):
-               return True
-    return proxy_bypass_environment(parsed.hostname, {'no': no_proxy} )
```

## vrt_lss_universal/api/__init__.py

```diff
@@ -1,3 +1,9 @@
-# do not import all apis into this module because that uses a lot of memory and stack frames
-# if you need the ability to import all apis from one package, import them with
-# from vrt_lss_universal.apis import ActualizeApi
+# flake8: noqa
+
+# import apis into api package
+from vrt_lss_universal.api.actualize_api import ActualizeApi
+from vrt_lss_universal.api.convert_api import ConvertApi
+from vrt_lss_universal.api.plan_api import PlanApi
+from vrt_lss_universal.api.replan_api import ReplanApi
+from vrt_lss_universal.api.system_api import SystemApi
+
```

## vrt_lss_universal/api/actualize_api.py

```diff
@@ -1,449 +1,524 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_universal.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_universal.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field
+
+from vrt_lss_universal.models.actualize_task import ActualizeTask
+from vrt_lss_universal.models.plan_result import PlanResult
+from vrt_lss_universal.models.validate_result import ValidateResult
+
+from vrt_lss_universal.api_client import ApiClient
+from vrt_lss_universal.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_universal.model.actualize_task import ActualizeTask
-from vrt_lss_universal.model.inline_response400 import InlineResponse400
-from vrt_lss_universal.model.inline_response401 import InlineResponse401
-from vrt_lss_universal.model.inline_response402 import InlineResponse402
-from vrt_lss_universal.model.inline_response404 import InlineResponse404
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.plan_result import PlanResult
-from vrt_lss_universal.model.validate_result import ValidateResult
 
 
 class ActualizeApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.run_actualize_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': (PlanResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/actualize/calculation',
-                'operation_id': 'run_actualize_calculation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'actualize_task',
-                ],
-                'required': [
-                    'actualize_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'actualize_task':
-                        (ActualizeTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'actualize_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_actualize_refining_endpoint = _Endpoint(
-            settings={
-                'response_type': (ActualizeTask,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/actualize/refining',
-                'operation_id': 'run_actualize_refining',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'actualize_task',
-                ],
-                'required': [
-                    'actualize_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'actualize_task':
-                        (ActualizeTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'actualize_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_actualize_validation_endpoint = _Endpoint(
-            settings={
-                'response_type': (ValidateResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/actualize/validation',
-                'operation_id': 'run_actualize_validation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'actualize_task',
-                ],
-                'required': [
-                    'actualize_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'actualize_task':
-                        (ActualizeTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'actualize_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def run_actualize_calculation(
-        self,
-        actualize_task,
-        **kwargs
-    ):
-        """Actualization (SYNC)  
+    @validate_arguments
+    def run_actualize_calculation(self, actualize_task : Annotated[ActualizeTask, Field(..., description="New request for actualization.")], **kwargs) -> PlanResult:  # noqa: E501
+        """Actualization (SYNC)  # noqa: E501
 
-        Trips actualization.  
+        Trips actualization.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_actualize_calculation(actualize_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            actualize_task (ActualizeTask): New request for actualization.
+        :param actualize_task: New request for actualization. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PlanResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_actualize_calculation_with_http_info(actualize_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_actualize_calculation_with_http_info(self, actualize_task : Annotated[ActualizeTask, Field(..., description="New request for actualization.")], **kwargs):  # noqa: E501
+        """Actualization (SYNC)  # noqa: E501
+
+        Trips actualization.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_actualize_calculation_with_http_info(actualize_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PlanResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param actualize_task: New request for actualization. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PlanResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['actualize_task'] = \
-            actualize_task
-        return self.run_actualize_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def run_actualize_refining(
-        self,
-        actualize_task,
-        **kwargs
-    ):
-        """Data refine  
 
-        Refine data before using.  
+        _params = locals()
+
+        _all_params = [
+            'actualize_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_actualize_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['actualize_task']:
+            _body_params = _params['actualize_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PlanResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/actualize/calculation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_actualize_refining(self, actualize_task : Annotated[ActualizeTask, Field(..., description="Data for refine.")], **kwargs) -> ActualizeTask:  # noqa: E501
+        """Data refine  # noqa: E501
+
+        Refine data before using.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_actualize_refining(actualize_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            actualize_task (ActualizeTask): Data for refine.
+        :param actualize_task: Data for refine. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ActualizeTask
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_actualize_refining_with_http_info(actualize_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_actualize_refining_with_http_info(self, actualize_task : Annotated[ActualizeTask, Field(..., description="Data for refine.")], **kwargs):  # noqa: E501
+        """Data refine  # noqa: E501
+
+        Refine data before using.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_actualize_refining_with_http_info(actualize_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ActualizeTask
-                If the method is called asynchronously, returns the request
-                thread.
+        :param actualize_task: Data for refine. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ActualizeTask, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['actualize_task'] = \
-            actualize_task
-        return self.run_actualize_refining_endpoint.call_with_http_info(**kwargs)
-
-    def run_actualize_validation(
-        self,
-        actualize_task,
-        **kwargs
-    ):
-        """Data validation  
 
-        Check data before using.  
+        _params = locals()
+
+        _all_params = [
+            'actualize_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_actualize_refining" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['actualize_task']:
+            _body_params = _params['actualize_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ActualizeTask",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/actualize/refining', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_actualize_validation(self, actualize_task : Annotated[ActualizeTask, Field(..., description="Data for validation.")], **kwargs) -> ValidateResult:  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_actualize_validation(actualize_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            actualize_task (ActualizeTask): Data for validation.
+        :param actualize_task: Data for validation. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ValidateResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_actualize_validation_with_http_info(actualize_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_actualize_validation_with_http_info(self, actualize_task : Annotated[ActualizeTask, Field(..., description="Data for validation.")], **kwargs):  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ValidateResult
-                If the method is called asynchronously, returns the request
-                thread.
+        >>> thread = api.run_actualize_validation_with_http_info(actualize_task, async_req=True)
+        >>> result = thread.get()
+
+        :param actualize_task: Data for validation. (required)
+        :type actualize_task: ActualizeTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ValidateResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['actualize_task'] = \
-            actualize_task
-        return self.run_actualize_validation_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'actualize_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_actualize_validation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['actualize_task']:
+            _body_params = _params['actualize_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ValidateResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/actualize/validation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_universal/api/convert_api.py

```diff
@@ -1,313 +1,360 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_universal.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_universal.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, StrictStr
+
+from vrt_lss_universal.models.universal_data import UniversalData
+
+from vrt_lss_universal.api_client import ApiClient
+from vrt_lss_universal.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_universal.model.inline_response400 import InlineResponse400
-from vrt_lss_universal.model.inline_response401 import InlineResponse401
-from vrt_lss_universal.model.inline_response402 import InlineResponse402
-from vrt_lss_universal.model.inline_response403 import InlineResponse403
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.universal_data import UniversalData
 
 
 class ConvertApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.run_convert_json_to_xlsx_endpoint = _Endpoint(
-            settings={
-                'response_type': (str,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/convert/json_to_xlsx',
-                'operation_id': 'run_convert_json_to_xlsx',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'universal_data',
-                ],
-                'required': [
-                    'universal_data',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'universal_data':
-                        (UniversalData,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'universal_data': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/octet-stream',
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_convert_xlsx_to_json_endpoint = _Endpoint(
-            settings={
-                'response_type': (UniversalData,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/convert/xlsx_to_json',
-                'operation_id': 'run_convert_xlsx_to_json',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'body',
-                ],
-                'required': [
-                    'body',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'body':
-                        (str,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'body': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def run_convert_json_to_xlsx(
-        self,
-        universal_data,
-        **kwargs
-    ):
-        """JSON >> XLSX  
+    @validate_arguments
+    def run_convert_json_to_xlsx(self, universal_data : Annotated[UniversalData, Field(..., description="Conversion request to the XLSX.")], **kwargs) -> bytearray:  # noqa: E501
+        """JSON >> XLSX  # noqa: E501
 
-        Used for conversion of input and output data to the [VRt.Universal XLSX](#section/Xlsx) format.  
+        Used for conversion of input and output data to the [VRt.Universal XLSX](#section/Xlsx) format.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_convert_json_to_xlsx(universal_data, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            universal_data (UniversalData): Conversion request to the XLSX.
+        :param universal_data: Conversion request to the XLSX. (required)
+        :type universal_data: UniversalData
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: bytearray
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_convert_json_to_xlsx_with_http_info(universal_data, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_convert_json_to_xlsx_with_http_info(self, universal_data : Annotated[UniversalData, Field(..., description="Conversion request to the XLSX.")], **kwargs):  # noqa: E501
+        """JSON >> XLSX  # noqa: E501
+
+        Used for conversion of input and output data to the [VRt.Universal XLSX](#section/Xlsx) format.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_convert_json_to_xlsx_with_http_info(universal_data, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            str
-                If the method is called asynchronously, returns the request
-                thread.
+        :param universal_data: Conversion request to the XLSX. (required)
+        :type universal_data: UniversalData
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['universal_data'] = \
-            universal_data
-        return self.run_convert_json_to_xlsx_endpoint.call_with_http_info(**kwargs)
-
-    def run_convert_xlsx_to_json(
-        self,
-        body,
-        **kwargs
-    ):
-        """XLSX >> JSON  
 
-        Used for data conversion from the [VRt.Universal XLSX](#section/Xlsx) format to the VRt.Universal JSON format.   
+        _params = locals()
+
+        _all_params = [
+            'universal_data'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_convert_json_to_xlsx" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['universal_data']:
+            _body_params = _params['universal_data']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/octet-stream', 'application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "bytearray",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '403': "General403",
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/convert/json_to_xlsx', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_convert_xlsx_to_json(self, body : Annotated[StrictStr, Field(..., description="Conversion request to the JSON format.")], **kwargs) -> UniversalData:  # noqa: E501
+        """XLSX >> JSON  # noqa: E501
+
+        Used for data conversion from the [VRt.Universal XLSX](#section/Xlsx) format to the VRt.Universal JSON format.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_convert_xlsx_to_json(body, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            body (str): Conversion request to the JSON format.
+        :param body: Conversion request to the JSON format. (required)
+        :type body: bytearray
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: UniversalData
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_convert_xlsx_to_json_with_http_info(body, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_convert_xlsx_to_json_with_http_info(self, body : Annotated[StrictStr, Field(..., description="Conversion request to the JSON format.")], **kwargs):  # noqa: E501
+        """XLSX >> JSON  # noqa: E501
+
+        Used for data conversion from the [VRt.Universal XLSX](#section/Xlsx) format to the VRt.Universal JSON format.   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_convert_xlsx_to_json_with_http_info(body, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            UniversalData
-                If the method is called asynchronously, returns the request
-                thread.
+        :param body: Conversion request to the JSON format. (required)
+        :type body: bytearray
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(UniversalData, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['body'] = \
-            body
-        return self.run_convert_xlsx_to_json_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'body'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_convert_xlsx_to_json" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['body']:
+            _body_params = _params['body']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "UniversalData",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '403': "General403",
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/convert/xlsx_to_json', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_universal/api/plan_api.py

```diff
@@ -1,987 +1,1109 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_universal.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_universal.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, StrictStr
+
+from vrt_lss_universal.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_universal.models.calculation_state import CalculationState
+from vrt_lss_universal.models.plan_result import PlanResult
+from vrt_lss_universal.models.plan_task import PlanTask
+from vrt_lss_universal.models.validate_result import ValidateResult
+
+from vrt_lss_universal.api_client import ApiClient
+from vrt_lss_universal.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_universal.model.calculation_async_result import CalculationAsyncResult
-from vrt_lss_universal.model.calculation_state import CalculationState
-from vrt_lss_universal.model.inline_response400 import InlineResponse400
-from vrt_lss_universal.model.inline_response401 import InlineResponse401
-from vrt_lss_universal.model.inline_response402 import InlineResponse402
-from vrt_lss_universal.model.inline_response404 import InlineResponse404
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.plan_result import PlanResult
-from vrt_lss_universal.model.plan_task import PlanTask
-from vrt_lss_universal.model.validate_result import ValidateResult
 
 
 class PlanApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.cancel_plan_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/calculation_async/{id}',
-                'operation_id': 'cancel_plan_calculation',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.delete_plan_result_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/result/{id}',
-                'operation_id': 'delete_plan_result',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_plan_calculation_state_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationState,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/calculation_async/{id}',
-                'operation_id': 'read_plan_calculation_state',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_plan_result_endpoint = _Endpoint(
-            settings={
-                'response_type': (PlanResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/result/{id}',
-                'operation_id': 'read_plan_result',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.run_plan_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': (PlanResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/calculation',
-                'operation_id': 'run_plan_calculation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'plan_task',
-                ],
-                'required': [
-                    'plan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'plan_task':
-                        (PlanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'plan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_plan_calculation_async_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationAsyncResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/calculation_async',
-                'operation_id': 'run_plan_calculation_async',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'plan_task',
-                ],
-                'required': [
-                    'plan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'plan_task':
-                        (PlanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'plan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_plan_validation_endpoint = _Endpoint(
-            settings={
-                'response_type': (ValidateResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/plan/validation',
-                'operation_id': 'run_plan_validation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'plan_task',
-                ],
-                'required': [
-                    'plan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'plan_task':
-                        (PlanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'plan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def cancel_plan_calculation(
-        self,
-        id,
-        **kwargs
-    ):
-        """Cancel calculation  
+    @validate_arguments
+    def cancel_plan_calculation(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Cancel calculation  # noqa: E501
 
-        Cancel calculation by the calculation identifier.  
+        Cancel calculation by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.cancel_plan_calculation(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.cancel_plan_calculation_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def cancel_plan_calculation_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Cancel calculation  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        Cancel calculation by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.cancel_plan_calculation_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.cancel_plan_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def delete_plan_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Result removal  
 
-        Removal of the planning result by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method cancel_plan_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/universal/plan/calculation_async/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def delete_plan_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Result removal  # noqa: E501
+
+        Removal of the planning result by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_plan_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_plan_result_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def delete_plan_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Result removal  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        Removal of the planning result by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_plan_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.delete_plan_result_endpoint.call_with_http_info(**kwargs)
-
-    def read_plan_calculation_state(
-        self,
-        id,
-        **kwargs
-    ):
-        """Calculation state  
 
-        Read calculation state by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_plan_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/universal/plan/result/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_plan_calculation_state(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> CalculationState:  # noqa: E501
+        """Calculation state  # noqa: E501
+
+        Read calculation state by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_plan_calculation_state(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationState
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_plan_calculation_state_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def read_plan_calculation_state_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Calculation state  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationState
-                If the method is called asynchronously, returns the request
-                thread.
+        Read calculation state by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_plan_calculation_state_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationState, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_plan_calculation_state_endpoint.call_with_http_info(**kwargs)
-
-    def read_plan_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Getting the result  
 
-        Getting the planning result based on the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_plan_calculation_state" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationState",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/plan/calculation_async/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_plan_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> PlanResult:  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the planning result based on the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_plan_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PlanResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_plan_result_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def read_plan_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the planning result based on the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_plan_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PlanResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PlanResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_plan_result_endpoint.call_with_http_info(**kwargs)
-
-    def run_plan_calculation(
-        self,
-        plan_task,
-        **kwargs
-    ):
-        """Planning (SYNC)  
 
-        Sync method for trip planning. Use only for testing and manual plannings. For production use [async method](#operation/run_plan_calculation_async).   
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_plan_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PlanResult",
+            '202': "PlanResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/plan/result/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_plan_calculation(self, plan_task : Annotated[PlanTask, Field(..., description="New planning request.")], **kwargs) -> PlanResult:  # noqa: E501
+        """Planning (SYNC)  # noqa: E501
+
+        Sync method for trip planning. Use only for testing and manual plannings. For production use [async method](#operation/run_plan_calculation_async).   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_plan_calculation(plan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            plan_task (PlanTask): New planning request.
+        :param plan_task: New planning request. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PlanResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_plan_calculation_with_http_info(plan_task, **kwargs)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PlanResult
-                If the method is called asynchronously, returns the request
-                thread.
+    @validate_arguments
+    def run_plan_calculation_with_http_info(self, plan_task : Annotated[PlanTask, Field(..., description="New planning request.")], **kwargs):  # noqa: E501
+        """Planning (SYNC)  # noqa: E501
+
+        Sync method for trip planning. Use only for testing and manual plannings. For production use [async method](#operation/run_plan_calculation_async).   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_plan_calculation_with_http_info(plan_task, async_req=True)
+        >>> result = thread.get()
+
+        :param plan_task: New planning request. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PlanResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['plan_task'] = \
-            plan_task
-        return self.run_plan_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def run_plan_calculation_async(
-        self,
-        plan_task,
-        **kwargs
-    ):
-        """Planning (ASYNC)  
 
-        Trip planning. The result can be obtained using the [result](#operation/read_plan_result) method, removing - with [delete](#operation/delete_plan_result).   
+        _params = locals()
+
+        _all_params = [
+            'plan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_plan_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['plan_task']:
+            _body_params = _params['plan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PlanResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/plan/calculation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_plan_calculation_async(self, plan_task : Annotated[PlanTask, Field(..., description="Launching the asynchronous planning.")], **kwargs) -> CalculationAsyncResult:  # noqa: E501
+        """Planning (ASYNC)  # noqa: E501
+
+        Trip planning. The result can be obtained using the [result](#operation/read_plan_result) method, removing - with [delete](#operation/delete_plan_result).   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_plan_calculation_async(plan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            plan_task (PlanTask): Launching the asynchronous planning.
+        :param plan_task: Launching the asynchronous planning. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationAsyncResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_plan_calculation_async_with_http_info(plan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_plan_calculation_async_with_http_info(self, plan_task : Annotated[PlanTask, Field(..., description="Launching the asynchronous planning.")], **kwargs):  # noqa: E501
+        """Planning (ASYNC)  # noqa: E501
+
+        Trip planning. The result can be obtained using the [result](#operation/read_plan_result) method, removing - with [delete](#operation/delete_plan_result).   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_plan_calculation_async_with_http_info(plan_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationAsyncResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param plan_task: Launching the asynchronous planning. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationAsyncResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['plan_task'] = \
-            plan_task
-        return self.run_plan_calculation_async_endpoint.call_with_http_info(**kwargs)
-
-    def run_plan_validation(
-        self,
-        plan_task,
-        **kwargs
-    ):
-        """Data validation  
 
-        Check data before using.  
+        _params = locals()
+
+        _all_params = [
+            'plan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_plan_calculation_async" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['plan_task']:
+            _body_params = _params['plan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationAsyncResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/plan/calculation_async', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_plan_validation(self, plan_task : Annotated[PlanTask, Field(..., description="Data for validation.")], **kwargs) -> ValidateResult:  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_plan_validation(plan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            plan_task (PlanTask): Data for validation.
+        :param plan_task: Data for validation. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ValidateResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_plan_validation_with_http_info(plan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_plan_validation_with_http_info(self, plan_task : Annotated[PlanTask, Field(..., description="Data for validation.")], **kwargs):  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_plan_validation_with_http_info(plan_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ValidateResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param plan_task: Data for validation. (required)
+        :type plan_task: PlanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ValidateResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['plan_task'] = \
-            plan_task
-        return self.run_plan_validation_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'plan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_plan_validation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['plan_task']:
+            _body_params = _params['plan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ValidateResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/plan/validation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_universal/api/replan_api.py

```diff
@@ -1,1122 +1,1269 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_universal.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_universal.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, StrictStr
+
+from vrt_lss_universal.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_universal.models.calculation_state import CalculationState
+from vrt_lss_universal.models.plan_result import PlanResult
+from vrt_lss_universal.models.replan_task import ReplanTask
+from vrt_lss_universal.models.validate_result import ValidateResult
+
+from vrt_lss_universal.api_client import ApiClient
+from vrt_lss_universal.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_universal.model.calculation_async_result import CalculationAsyncResult
-from vrt_lss_universal.model.calculation_state import CalculationState
-from vrt_lss_universal.model.inline_response400 import InlineResponse400
-from vrt_lss_universal.model.inline_response401 import InlineResponse401
-from vrt_lss_universal.model.inline_response402 import InlineResponse402
-from vrt_lss_universal.model.inline_response404 import InlineResponse404
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.plan_result import PlanResult
-from vrt_lss_universal.model.replan_task import ReplanTask
-from vrt_lss_universal.model.validate_result import ValidateResult
 
 
 class ReplanApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.cancel_replan_calculation_async_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/calculation_async/{id}',
-                'operation_id': 'cancel_replan_calculation_async',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.delete_replan_result_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/result/{id}',
-                'operation_id': 'delete_replan_result',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_replan_calculation_state_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationState,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/calculation_async/{id}',
-                'operation_id': 'read_replan_calculation_state',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_replan_result_endpoint = _Endpoint(
-            settings={
-                'response_type': (PlanResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/result/{id}',
-                'operation_id': 'read_replan_result',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.run_replan_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': (PlanResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/calculation',
-                'operation_id': 'run_replan_calculation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'replan_task',
-                ],
-                'required': [
-                    'replan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'replan_task':
-                        (ReplanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'replan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_replan_calculation_async_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationAsyncResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/calculation_async',
-                'operation_id': 'run_replan_calculation_async',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'replan_task',
-                ],
-                'required': [
-                    'replan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'replan_task':
-                        (ReplanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'replan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_replan_refining_endpoint = _Endpoint(
-            settings={
-                'response_type': (ReplanTask,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/refining',
-                'operation_id': 'run_replan_refining',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'replan_task',
-                ],
-                'required': [
-                    'replan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'replan_task':
-                        (ReplanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'replan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_replan_validation_endpoint = _Endpoint(
-            settings={
-                'response_type': (ValidateResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/universal/replan/validation',
-                'operation_id': 'run_replan_validation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'replan_task',
-                ],
-                'required': [
-                    'replan_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'replan_task':
-                        (ReplanTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'replan_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def cancel_replan_calculation_async(
-        self,
-        id,
-        **kwargs
-    ):
-        """Cancel calculation  
+    @validate_arguments
+    def cancel_replan_calculation_async(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Cancel calculation  # noqa: E501
 
-        Cancel calculation by the calculation identifier.  
+        Cancel calculation by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.cancel_replan_calculation_async(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.cancel_replan_calculation_async_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def cancel_replan_calculation_async_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Cancel calculation  # noqa: E501
+
+        Cancel calculation by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.cancel_replan_calculation_async_with_http_info(id, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.cancel_replan_calculation_async_endpoint.call_with_http_info(**kwargs)
-
-    def delete_replan_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Result removal  
 
-        Removal of the planning result by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method cancel_replan_calculation_async" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/universal/replan/calculation_async/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def delete_replan_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Result removal  # noqa: E501
+
+        Removal of the planning result by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_replan_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_replan_result_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def delete_replan_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Result removal  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        Removal of the planning result by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_replan_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.delete_replan_result_endpoint.call_with_http_info(**kwargs)
-
-    def read_replan_calculation_state(
-        self,
-        id,
-        **kwargs
-    ):
-        """Calculation state  
 
-        Read calculation state by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_replan_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/universal/replan/result/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_replan_calculation_state(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> CalculationState:  # noqa: E501
+        """Calculation state  # noqa: E501
+
+        Read calculation state by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_replan_calculation_state(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationState
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_replan_calculation_state_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def read_replan_calculation_state_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Calculation state  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationState
-                If the method is called asynchronously, returns the request
-                thread.
+        Read calculation state by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_replan_calculation_state_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationState, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_replan_calculation_state_endpoint.call_with_http_info(**kwargs)
-
-    def read_replan_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Getting the result  
 
-        Getting the replanning result based on the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_replan_calculation_state" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationState",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/calculation_async/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_replan_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> PlanResult:  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the replanning result based on the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_replan_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PlanResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_replan_result_with_http_info(id, **kwargs)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PlanResult
-                If the method is called asynchronously, returns the request
-                thread.
+    @validate_arguments
+    def read_replan_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the replanning result based on the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_replan_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PlanResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_replan_result_endpoint.call_with_http_info(**kwargs)
-
-    def run_replan_calculation(
-        self,
-        replan_task,
-        **kwargs
-    ):
-        """Replanning (SYNC)  
 
-        Trips replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport.   
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_replan_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PlanResult",
+            '202': "PlanResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/result/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_replan_calculation(self, replan_task : Annotated[ReplanTask, Field(..., description="New replanning request.")], **kwargs) -> PlanResult:  # noqa: E501
+        """Replanning (SYNC)  # noqa: E501
+
+        Trips replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_replan_calculation(replan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            replan_task (ReplanTask): New replanning request.
+        :param replan_task: New replanning request. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PlanResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_replan_calculation_with_http_info(replan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_replan_calculation_with_http_info(self, replan_task : Annotated[ReplanTask, Field(..., description="New replanning request.")], **kwargs):  # noqa: E501
+        """Replanning (SYNC)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PlanResult
-                If the method is called asynchronously, returns the request
-                thread.
+        Trips replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport.   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_replan_calculation_with_http_info(replan_task, async_req=True)
+        >>> result = thread.get()
+
+        :param replan_task: New replanning request. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PlanResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['replan_task'] = \
-            replan_task
-        return self.run_replan_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def run_replan_calculation_async(
-        self,
-        replan_task,
-        **kwargs
-    ):
-        """Replanning (ASYNC)  
 
-        Trip replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport. The result can be obtained using the [result](#operation/read_replan_result) method, removing - with [delete](#operation/delete_replan_result).   
+        _params = locals()
+
+        _all_params = [
+            'replan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_replan_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['replan_task']:
+            _body_params = _params['replan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PlanResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/calculation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_replan_calculation_async(self, replan_task : Annotated[ReplanTask, Field(..., description="Launching the asynchronous replanning.")], **kwargs) -> CalculationAsyncResult:  # noqa: E501
+        """Replanning (ASYNC)  # noqa: E501
+
+        Trip replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport. The result can be obtained using the [result](#operation/read_replan_result) method, removing - with [delete](#operation/delete_replan_result).   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_replan_calculation_async(replan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            replan_task (ReplanTask): Launching the asynchronous replanning.
+        :param replan_task: Launching the asynchronous replanning. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationAsyncResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_replan_calculation_async_with_http_info(replan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_replan_calculation_async_with_http_info(self, replan_task : Annotated[ReplanTask, Field(..., description="Launching the asynchronous replanning.")], **kwargs):  # noqa: E501
+        """Replanning (ASYNC)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationAsyncResult
-                If the method is called asynchronously, returns the request
-                thread.
+        Trip replanning - changing existing and creating new trips based on the facts and data about orders, performers and transport. The result can be obtained using the [result](#operation/read_replan_result) method, removing - with [delete](#operation/delete_replan_result).   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_replan_calculation_async_with_http_info(replan_task, async_req=True)
+        >>> result = thread.get()
+
+        :param replan_task: Launching the asynchronous replanning. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationAsyncResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['replan_task'] = \
-            replan_task
-        return self.run_replan_calculation_async_endpoint.call_with_http_info(**kwargs)
-
-    def run_replan_refining(
-        self,
-        replan_task,
-        **kwargs
-    ):
-        """Data refine  
 
-        Refine data before using.  
+        _params = locals()
+
+        _all_params = [
+            'replan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_replan_calculation_async" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['replan_task']:
+            _body_params = _params['replan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationAsyncResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/calculation_async', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_replan_refining(self, replan_task : Annotated[ReplanTask, Field(..., description="Data for refine.")], **kwargs) -> ReplanTask:  # noqa: E501
+        """Data refine  # noqa: E501
+
+        Refine data before using.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_replan_refining(replan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            replan_task (ReplanTask): Data for refine.
+        :param replan_task: Data for refine. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ReplanTask
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_replan_refining_with_http_info(replan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_replan_refining_with_http_info(self, replan_task : Annotated[ReplanTask, Field(..., description="Data for refine.")], **kwargs):  # noqa: E501
+        """Data refine  # noqa: E501
+
+        Refine data before using.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_replan_refining_with_http_info(replan_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ReplanTask
-                If the method is called asynchronously, returns the request
-                thread.
+        :param replan_task: Data for refine. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ReplanTask, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['replan_task'] = \
-            replan_task
-        return self.run_replan_refining_endpoint.call_with_http_info(**kwargs)
-
-    def run_replan_validation(
-        self,
-        replan_task,
-        **kwargs
-    ):
-        """Data validation  
 
-        Check data before using.  
+        _params = locals()
+
+        _all_params = [
+            'replan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_replan_refining" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['replan_task']:
+            _body_params = _params['replan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ReplanTask",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/refining', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_replan_validation(self, replan_task : Annotated[ReplanTask, Field(..., description="Data for validation.")], **kwargs) -> ValidateResult:  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_replan_validation(replan_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            replan_task (ReplanTask): Data for validation.
+        :param replan_task: Data for validation. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ValidateResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_replan_validation_with_http_info(replan_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_replan_validation_with_http_info(self, replan_task : Annotated[ReplanTask, Field(..., description="Data for validation.")], **kwargs):  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Check data before using.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_replan_validation_with_http_info(replan_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ValidateResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param replan_task: Data for validation. (required)
+        :type replan_task: ReplanTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ValidateResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['replan_task'] = \
-            replan_task
-        return self.run_replan_validation_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'replan_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_replan_validation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['replan_task']:
+            _body_params = _params['replan_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ValidateResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/replan/validation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_universal/api/system_api.py

```diff
@@ -1,419 +1,477 @@
+# coding: utf-8
+
 """
     VRt.Universal [UV]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_universal.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_universal.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, constr
+
+from vrt_lss_universal.models.check_result import CheckResult
+from vrt_lss_universal.models.version_result import VersionResult
+
+from vrt_lss_universal.api_client import ApiClient
+from vrt_lss_universal.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_universal.model.check_result import CheckResult
-from vrt_lss_universal.model.inline_response404 import InlineResponse404
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.version_result import VersionResult
 
 
 class SystemApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.check_endpoint = _Endpoint(
-            settings={
-                'response_type': (CheckResult,),
-                'auth': [],
-                'endpoint_path': '/universal/system/check',
-                'operation_id': 'check',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                ],
-                'required': [],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.file_endpoint = _Endpoint(
-            settings={
-                'response_type': (str,),
-                'auth': [],
-                'endpoint_path': '/universal/file/{filename}',
-                'operation_id': 'file',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'filename',
-                ],
-                'required': [
-                    'filename',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                    'filename',
-                ]
-            },
-            root_map={
-                'validations': {
-                    ('filename',): {
-                        'max_length': 128,
-                        'min_length': 6,
-                    },
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'filename':
-                        (str,),
-                },
-                'attribute_map': {
-                    'filename': 'filename',
-                },
-                'location_map': {
-                    'filename': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'text/html',
-                    'text/plain',
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.version_endpoint = _Endpoint(
-            settings={
-                'response_type': (VersionResult,),
-                'auth': [],
-                'endpoint_path': '/universal/system/version',
-                'operation_id': 'version',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                ],
-                'required': [],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
 
-    def check(
-        self,
-        **kwargs
-    ):
-        """Checking the availability  
+    @validate_arguments
+    def check(self, **kwargs) -> CheckResult:  # noqa: E501
+        """Checking the availability  # noqa: E501
 
-        Checking the service availability.  
+        Checking the service availability.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.check(async_req=True)
         >>> result = thread.get()
 
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CheckResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.check_with_http_info(**kwargs)  # noqa: E501
+
+    @validate_arguments
+    def check_with_http_info(self, **kwargs):  # noqa: E501
+        """Checking the availability  # noqa: E501
+
+        Checking the service availability.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CheckResult
-                If the method is called asynchronously, returns the request
-                thread.
+        >>> thread = api.check_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CheckResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        return self.check_endpoint.call_with_http_info(**kwargs)
-
-    def file(
-        self,
-        filename,
-        **kwargs
-    ):
-        """Getting the documentation  
 
-        Getting the file with this service documentation.  
+        _params = locals()
+
+        _all_params = [
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method check" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "CheckResult",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/system/check', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def file(self, filename : Annotated[constr(strict=True, max_length=128, min_length=6), Field(..., description="File name.")], **kwargs) -> str:  # noqa: E501
+        """Getting the documentation  # noqa: E501
+
+        Getting the file with this service documentation.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.file(filename, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            filename (str): File name.
+        :param filename: File name. (required)
+        :type filename: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: str
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.file_with_http_info(filename, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def file_with_http_info(self, filename : Annotated[constr(strict=True, max_length=128, min_length=6), Field(..., description="File name.")], **kwargs):  # noqa: E501
+        """Getting the documentation  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            str
-                If the method is called asynchronously, returns the request
-                thread.
+        Getting the file with this service documentation.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.file_with_http_info(filename, async_req=True)
+        >>> result = thread.get()
+
+        :param filename: File name. (required)
+        :type filename: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['filename'] = \
-            filename
-        return self.file_endpoint.call_with_http_info(**kwargs)
-
-    def version(
-        self,
-        **kwargs
-    ):
-        """Getting the service version  
 
-        Getting the service version.  
+        _params = locals()
+
+        _all_params = [
+            'filename'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method file" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['filename']:
+            _path_params['filename'] = _params['filename']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/html', 'text/plain', 'application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "str",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/file/{filename}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def version(self, **kwargs) -> VersionResult:  # noqa: E501
+        """Getting the service version  # noqa: E501
+
+        Getting the service version.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.version(async_req=True)
         >>> result = thread.get()
 
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: VersionResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.version_with_http_info(**kwargs)  # noqa: E501
+
+    @validate_arguments
+    def version_with_http_info(self, **kwargs):  # noqa: E501
+        """Getting the service version  # noqa: E501
+
+        Getting the service version.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            VersionResult
-                If the method is called asynchronously, returns the request
-                thread.
+        >>> thread = api.version_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(VersionResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        return self.version_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method version" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "VersionResult",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/universal/system/version', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_universal/models/__init__.py

```diff
@@ -1,135 +1,118 @@
+# coding: utf-8
+
 # flake8: noqa
+"""
+    VRt.Universal [UV]
+
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
+"""
+
 
-# import all models into this package
-# if you have many models here with many references from one model to another this may
-# raise a RecursionError
-# to avoid this, import only the models that you directly need like:
-# from from vrt_lss_universal.model.pet import Pet
-# or import this package, but before doing it, use:
-# import sys
-# sys.setrecursionlimit(n)
-
-from vrt_lss_universal.model.actualize_settings import ActualizeSettings
-from vrt_lss_universal.model.actualize_task import ActualizeTask
-from vrt_lss_universal.model.assigned_performer import AssignedPerformer
-from vrt_lss_universal.model.assigned_transport import AssignedTransport
-from vrt_lss_universal.model.attribute import Attribute
-from vrt_lss_universal.model.attributes import Attributes
-from vrt_lss_universal.model.box import Box
-from vrt_lss_universal.model.box_compatibilities import BoxCompatibilities
-from vrt_lss_universal.model.box_features import BoxFeatures
-from vrt_lss_universal.model.box_limits import BoxLimits
-from vrt_lss_universal.model.box_restrictions import BoxRestrictions
-from vrt_lss_universal.model.calculation_async_result import CalculationAsyncResult
-from vrt_lss_universal.model.calculation_info import CalculationInfo
-from vrt_lss_universal.model.calculation_progress import CalculationProgress
-from vrt_lss_universal.model.calculation_settings import CalculationSettings
-from vrt_lss_universal.model.calculation_state import CalculationState
-from vrt_lss_universal.model.calculation_status import CalculationStatus
-from vrt_lss_universal.model.capacity import Capacity
-from vrt_lss_universal.model.capacity_factor import CapacityFactor
-from vrt_lss_universal.model.cargo import Cargo
-from vrt_lss_universal.model.cargo_compatibilities import CargoCompatibilities
-from vrt_lss_universal.model.cargo_features import CargoFeatures
-from vrt_lss_universal.model.cargo_placement import CargoPlacement
-from vrt_lss_universal.model.cargo_restrictions import CargoRestrictions
-from vrt_lss_universal.model.cargo_rotation import CargoRotation
-from vrt_lss_universal.model.cargo_rotation_type import CargoRotationType
-from vrt_lss_universal.model.check_result import CheckResult
-from vrt_lss_universal.model.compatibility_penalty import CompatibilityPenalty
-from vrt_lss_universal.model.demand import Demand
-from vrt_lss_universal.model.demand_fact import DemandFact
-from vrt_lss_universal.model.entity_error import EntityError
-from vrt_lss_universal.model.entity_error_list import EntityErrorList
-from vrt_lss_universal.model.entity_error_type import EntityErrorType
-from vrt_lss_universal.model.entity_path import EntityPath
-from vrt_lss_universal.model.entity_type import EntityType
-from vrt_lss_universal.model.entity_warning import EntityWarning
-from vrt_lss_universal.model.entity_warning_list import EntityWarningList
-from vrt_lss_universal.model.entity_warning_type import EntityWarningType
-from vrt_lss_universal.model.facts import Facts
-from vrt_lss_universal.model.geo_settings import GeoSettings
-from vrt_lss_universal.model.geopoint import Geopoint
-from vrt_lss_universal.model.hardlink import Hardlink
-from vrt_lss_universal.model.hardlink_element import HardlinkElement
-from vrt_lss_universal.model.hardlink_element_type import HardlinkElementType
-from vrt_lss_universal.model.inline_response400 import InlineResponse400
-from vrt_lss_universal.model.inline_response401 import InlineResponse401
-from vrt_lss_universal.model.inline_response402 import InlineResponse402
-from vrt_lss_universal.model.inline_response403 import InlineResponse403
-from vrt_lss_universal.model.inline_response404 import InlineResponse404
-from vrt_lss_universal.model.inline_response404_detail import InlineResponse404Detail
-from vrt_lss_universal.model.inline_response429 import InlineResponse429
-from vrt_lss_universal.model.inline_response500 import InlineResponse500
-from vrt_lss_universal.model.location import Location
-from vrt_lss_universal.model.location_compatibilities import LocationCompatibilities
-from vrt_lss_universal.model.measurements import Measurements
-from vrt_lss_universal.model.model_break import ModelBreak
-from vrt_lss_universal.model.object_metrics import ObjectMetrics
-from vrt_lss_universal.model.operation_id import OperationId
-from vrt_lss_universal.model.order import Order
-from vrt_lss_universal.model.order_compatibilities import OrderCompatibilities
-from vrt_lss_universal.model.order_fact import OrderFact
-from vrt_lss_universal.model.order_features import OrderFeatures
-from vrt_lss_universal.model.order_restrictions import OrderRestrictions
-from vrt_lss_universal.model.performer import Performer
-from vrt_lss_universal.model.performer_blacklist import PerformerBlacklist
-from vrt_lss_universal.model.performer_compatibilities import PerformerCompatibilities
-from vrt_lss_universal.model.performer_fact import PerformerFact
-from vrt_lss_universal.model.performer_features import PerformerFeatures
-from vrt_lss_universal.model.performer_limits import PerformerLimits
-from vrt_lss_universal.model.performer_restrictions import PerformerRestrictions
-from vrt_lss_universal.model.performer_shift import PerformerShift
-from vrt_lss_universal.model.performer_tariff import PerformerTariff
-from vrt_lss_universal.model.performer_tariff_constraint import PerformerTariffConstraint
-from vrt_lss_universal.model.plan_configuration import PlanConfiguration
-from vrt_lss_universal.model.plan_result import PlanResult
-from vrt_lss_universal.model.plan_settings import PlanSettings
-from vrt_lss_universal.model.plan_statistics import PlanStatistics
-from vrt_lss_universal.model.plan_task import PlanTask
-from vrt_lss_universal.model.possible_event import PossibleEvent
-from vrt_lss_universal.model.quality_statistics import QualityStatistics
-from vrt_lss_universal.model.replan_settings import ReplanSettings
-from vrt_lss_universal.model.replan_strategy import ReplanStrategy
-from vrt_lss_universal.model.replan_task import ReplanTask
-from vrt_lss_universal.model.routing_matrix import RoutingMatrix
-from vrt_lss_universal.model.routing_matrix_line import RoutingMatrixLine
-from vrt_lss_universal.model.routing_transport_matrix import RoutingTransportMatrix
-from vrt_lss_universal.model.routing_transport_matrix_list import RoutingTransportMatrixList
-from vrt_lss_universal.model.schema_error import SchemaError
-from vrt_lss_universal.model.schema_error_list import SchemaErrorList
-from vrt_lss_universal.model.service_name import ServiceName
-from vrt_lss_universal.model.statistics import Statistics
-from vrt_lss_universal.model.stop_statistics import StopStatistics
-from vrt_lss_universal.model.time_duration import TimeDuration
-from vrt_lss_universal.model.time_window import TimeWindow
-from vrt_lss_universal.model.time_window_violations import TimeWindowViolations
-from vrt_lss_universal.model.tracedata import Tracedata
-from vrt_lss_universal.model.track_point import TrackPoint
-from vrt_lss_universal.model.transport import Transport
-from vrt_lss_universal.model.transport_compatibilities import TransportCompatibilities
-from vrt_lss_universal.model.transport_fact import TransportFact
-from vrt_lss_universal.model.transport_factor import TransportFactor
-from vrt_lss_universal.model.transport_features import TransportFeatures
-from vrt_lss_universal.model.transport_limits import TransportLimits
-from vrt_lss_universal.model.transport_load import TransportLoad
-from vrt_lss_universal.model.transport_restrictions import TransportRestrictions
-from vrt_lss_universal.model.transport_shift import TransportShift
-from vrt_lss_universal.model.transport_tariff import TransportTariff
-from vrt_lss_universal.model.transport_tariff_constraint import TransportTariffConstraint
-from vrt_lss_universal.model.transport_type import TransportType
-from vrt_lss_universal.model.trip import Trip
-from vrt_lss_universal.model.trip_assumptions import TripAssumptions
-from vrt_lss_universal.model.trip_penalties import TripPenalties
-from vrt_lss_universal.model.trip_start_time_strategy import TripStartTimeStrategy
-from vrt_lss_universal.model.trip_state import TripState
-from vrt_lss_universal.model.trip_state_flag import TripStateFlag
-from vrt_lss_universal.model.trip_statistics import TripStatistics
-from vrt_lss_universal.model.trip_waitlist import TripWaitlist
-from vrt_lss_universal.model.trips_settings import TripsSettings
-from vrt_lss_universal.model.universal_data import UniversalData
-from vrt_lss_universal.model.unplanned_items import UnplannedItems
-from vrt_lss_universal.model.validate_result import ValidateResult
-from vrt_lss_universal.model.version_result import VersionResult
-from vrt_lss_universal.model.waypoint import Waypoint
-from vrt_lss_universal.model.work_and_rest_rules import WorkAndRestRules
+# import models into model package
+from vrt_lss_universal.models.actualize_settings import ActualizeSettings
+from vrt_lss_universal.models.actualize_task import ActualizeTask
+from vrt_lss_universal.models.assigned_performer import AssignedPerformer
+from vrt_lss_universal.models.assigned_transport import AssignedTransport
+from vrt_lss_universal.models.attribute import Attribute
+from vrt_lss_universal.models.box import Box
+from vrt_lss_universal.models.box_compatibilities import BoxCompatibilities
+from vrt_lss_universal.models.box_limits import BoxLimits
+from vrt_lss_universal.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_universal.models.calculation_info import CalculationInfo
+from vrt_lss_universal.models.calculation_settings import CalculationSettings
+from vrt_lss_universal.models.calculation_state import CalculationState
+from vrt_lss_universal.models.calculation_status import CalculationStatus
+from vrt_lss_universal.models.capacity import Capacity
+from vrt_lss_universal.models.capacity_factor import CapacityFactor
+from vrt_lss_universal.models.cargo import Cargo
+from vrt_lss_universal.models.cargo_compatibilities import CargoCompatibilities
+from vrt_lss_universal.models.cargo_placement import CargoPlacement
+from vrt_lss_universal.models.cargo_rotation_type import CargoRotationType
+from vrt_lss_universal.models.check_result import CheckResult
+from vrt_lss_universal.models.compatibility_penalty import CompatibilityPenalty
+from vrt_lss_universal.models.custom400_with_errors_and_warnings import Custom400WithErrorsAndWarnings
+from vrt_lss_universal.models.demand import Demand
+from vrt_lss_universal.models.demand_fact import DemandFact
+from vrt_lss_universal.models.entity_error import EntityError
+from vrt_lss_universal.models.entity_error_type import EntityErrorType
+from vrt_lss_universal.models.entity_path import EntityPath
+from vrt_lss_universal.models.entity_type import EntityType
+from vrt_lss_universal.models.entity_warning import EntityWarning
+from vrt_lss_universal.models.entity_warning_type import EntityWarningType
+from vrt_lss_universal.models.facts import Facts
+from vrt_lss_universal.models.general401 import General401
+from vrt_lss_universal.models.general402 import General402
+from vrt_lss_universal.models.general403 import General403
+from vrt_lss_universal.models.general404 import General404
+from vrt_lss_universal.models.general404_detail import General404Detail
+from vrt_lss_universal.models.general429 import General429
+from vrt_lss_universal.models.general500 import General500
+from vrt_lss_universal.models.geo_settings import GeoSettings
+from vrt_lss_universal.models.geopoint import Geopoint
+from vrt_lss_universal.models.hardlink import Hardlink
+from vrt_lss_universal.models.hardlink_element import HardlinkElement
+from vrt_lss_universal.models.hardlink_element_type import HardlinkElementType
+from vrt_lss_universal.models.location import Location
+from vrt_lss_universal.models.location_compatibilities import LocationCompatibilities
+from vrt_lss_universal.models.measurements import Measurements
+from vrt_lss_universal.models.model_break import ModelBreak
+from vrt_lss_universal.models.object_metrics import ObjectMetrics
+from vrt_lss_universal.models.order import Order
+from vrt_lss_universal.models.order_compatibilities import OrderCompatibilities
+from vrt_lss_universal.models.order_fact import OrderFact
+from vrt_lss_universal.models.performer import Performer
+from vrt_lss_universal.models.performer_compatibilities import PerformerCompatibilities
+from vrt_lss_universal.models.performer_fact import PerformerFact
+from vrt_lss_universal.models.performer_limits import PerformerLimits
+from vrt_lss_universal.models.performer_shift import PerformerShift
+from vrt_lss_universal.models.performer_tariff import PerformerTariff
+from vrt_lss_universal.models.performer_tariff_constraint import PerformerTariffConstraint
+from vrt_lss_universal.models.plan_result import PlanResult
+from vrt_lss_universal.models.plan_settings import PlanSettings
+from vrt_lss_universal.models.plan_statistics import PlanStatistics
+from vrt_lss_universal.models.plan_task import PlanTask
+from vrt_lss_universal.models.possible_event import PossibleEvent
+from vrt_lss_universal.models.quality_statistics import QualityStatistics
+from vrt_lss_universal.models.replan_settings import ReplanSettings
+from vrt_lss_universal.models.replan_strategy import ReplanStrategy
+from vrt_lss_universal.models.replan_task import ReplanTask
+from vrt_lss_universal.models.routing_matrix import RoutingMatrix
+from vrt_lss_universal.models.routing_transport_matrix import RoutingTransportMatrix
+from vrt_lss_universal.models.schema_error import SchemaError
+from vrt_lss_universal.models.service_name import ServiceName
+from vrt_lss_universal.models.statistics import Statistics
+from vrt_lss_universal.models.stop_statistics import StopStatistics
+from vrt_lss_universal.models.time_window import TimeWindow
+from vrt_lss_universal.models.time_window_violations import TimeWindowViolations
+from vrt_lss_universal.models.tracedata import Tracedata
+from vrt_lss_universal.models.track_point import TrackPoint
+from vrt_lss_universal.models.transport import Transport
+from vrt_lss_universal.models.transport_compatibilities import TransportCompatibilities
+from vrt_lss_universal.models.transport_fact import TransportFact
+from vrt_lss_universal.models.transport_factor import TransportFactor
+from vrt_lss_universal.models.transport_limits import TransportLimits
+from vrt_lss_universal.models.transport_load import TransportLoad
+from vrt_lss_universal.models.transport_shift import TransportShift
+from vrt_lss_universal.models.transport_tariff import TransportTariff
+from vrt_lss_universal.models.transport_tariff_constraint import TransportTariffConstraint
+from vrt_lss_universal.models.transport_type import TransportType
+from vrt_lss_universal.models.trip import Trip
+from vrt_lss_universal.models.trip_assumptions import TripAssumptions
+from vrt_lss_universal.models.trip_penalties import TripPenalties
+from vrt_lss_universal.models.trip_start_time_strategy import TripStartTimeStrategy
+from vrt_lss_universal.models.trip_state import TripState
+from vrt_lss_universal.models.trip_state_flag import TripStateFlag
+from vrt_lss_universal.models.trip_statistics import TripStatistics
+from vrt_lss_universal.models.trips_settings import TripsSettings
+from vrt_lss_universal.models.universal_data import UniversalData
+from vrt_lss_universal.models.unplanned_items import UnplannedItems
+from vrt_lss_universal.models.validate_result import ValidateResult
+from vrt_lss_universal.models.version_result import VersionResult
+from vrt_lss_universal.models.waypoint import Waypoint
+from vrt_lss_universal.models.work_and_rest_rules import WorkAndRestRules
```

## Comparing `vrt_lss_universal-6.4.1962.dist-info/RECORD` & `vrt_lss_universal-6.5.1990.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,143 +1,117 @@
-vrt_lss_universal/__init__.py,sha256=MusHLfABBUjoJlWZo6XajfwYhMymDVDdWYl5baCm_2Y,689
-vrt_lss_universal/api_client.py,sha256=oLQ6wk6BPGAcVcBPK5Xs4yjWWse7CfzChjD4fMzZpy8,38744
-vrt_lss_universal/configuration.py,sha256=OaR1wy2rhJNlx0I5ESL77QLL2okrX6tNQBfopepYjf0,16610
-vrt_lss_universal/exceptions.py,sha256=SFxRwV2eLEgLZTZC8jVLKKSquyKvlNQ8-JE_38QnH3Q,4995
-vrt_lss_universal/model_utils.py,sha256=C0tdNo4M_irT5Un3VW5I8_CPCCtS6Ejr5ZNwgLI3gNg,82286
-vrt_lss_universal/rest.py,sha256=nckYUPax29Ap7KRcLAl85T_u1vUO9z1-gm1d6ilahYk,14020
-vrt_lss_universal/api/__init__.py,sha256=H6wKz951XAGwy07laGWwC2tD_g8EgvdUb11MpNJ7jqQ,223
-vrt_lss_universal/api/actualize_api.py,sha256=VjbPea_wQ8byy0BFwt48BddTtKMuypZyvw0qqRT2gCM,16635
-vrt_lss_universal/api/convert_api.py,sha256=9qZHpFLFlUnrY7tUeEAZrfj8Sjl5-8dLWmVrhgTK6gs,11572
-vrt_lss_universal/api/plan_api.py,sha256=vxo6Yx3AaWFjIIVmNyxwO-gPyGVuQkPp21KuebchNBQ,36669
-vrt_lss_universal/api/replan_api.py,sha256=fKqk6dWJzb0UCmYdqCuYxJRq5Ae96t3AaKWjkme124o,41974
-vrt_lss_universal/api/system_api.py,sha256=U8Fg0HeRkhUyJxM4PHOE7YqCXggzWDYn0Ja1FSdZI6U,15183
-vrt_lss_universal/apis/__init__.py,sha256=6Fi_cR62_6D_WAKbr7p5KgEHINFKarlNUbVxLIQUOvo,713
-vrt_lss_universal/model/__init__.py,sha256=lepVzZ7Wk3EsysT9eIuG6y0bfD5Pn3aye6ag1IehDUc,351
-vrt_lss_universal/model/actualize_settings.py,sha256=Jmyt_PFKMqcViaNmXbfwIEyNJlqpvk8B9fL7A0JZdqI,12214
-vrt_lss_universal/model/actualize_task.py,sha256=SrTA8-L8d0-yO86q1t1VTQ4s6BxEs1JZ5d58aU-MRgY,14652
-vrt_lss_universal/model/assigned_performer.py,sha256=lLV8k_imqZfK9C5NTzLy4iKYxyKSTnEb1ZFndWgu0QY,12057
-vrt_lss_universal/model/assigned_transport.py,sha256=9ibqTXM35-wc0O44DI79vnYsMLzFAI8fnYbZWhgxOqE,12053
-vrt_lss_universal/model/attribute.py,sha256=X4QcaaexdcpGWXKiQx0mL7Of_SNDXbboHpaock8_-6Q,11419
-vrt_lss_universal/model/attributes.py,sha256=HWrRgsxuVtxhY3WiHst9nAiYuoxY4GFJ6wjWvHdlHo0,11635
-vrt_lss_universal/model/box.py,sha256=WcgKZVNqAgbEsDsx_RLLfH-IVXG4N3l_LThoROTKoKM,12139
-vrt_lss_universal/model/box_compatibilities.py,sha256=RyyqClmH8qHhOsiDBn5DPX68RA-t2x1npsKrFecW3pc,12374
-vrt_lss_universal/model/box_features.py,sha256=DKZvLRpbV5HLEpgBtJV3a42Vx33dLtbdsRhkhcj74eA,11547
-vrt_lss_universal/model/box_limits.py,sha256=quQuefO4kk6tMF6yckGAOHN507zLqcW2mi-SaXc8kPg,11171
-vrt_lss_universal/model/box_restrictions.py,sha256=okTyJHN-DmnQl7m2ekZws0UdLLl6D_c1ytSfwiR5rZ4,11519
-vrt_lss_universal/model/calculation_async_result.py,sha256=xK4o_ElsYS77Toqx2bPKsj_ygKo2K_2AJvHoDR4GsKs,11441
-vrt_lss_universal/model/calculation_info.py,sha256=tQfjFLkHIN7FmOX0VeWdN_Vaq4QYXqHa_Kuhjj5jlHU,13501
-vrt_lss_universal/model/calculation_progress.py,sha256=MWHBOHXkAnULD1iqFUiY53tq4c10xXjbUQ8YNZiXvAI,11710
-vrt_lss_universal/model/calculation_settings.py,sha256=CBWCSNIY8FsEW3wFD1jtWZNXcxNC-7k4rAYwPbhDHyY,14958
-vrt_lss_universal/model/calculation_state.py,sha256=Js01QQ9SVOM5hCl1Rh7YG-TthUbHpGbuNoepmOSBL7k,11955
-vrt_lss_universal/model/calculation_status.py,sha256=55uk5X5WSQIrsHXYcfmY_fx1eIA8rjcGob7Z4AQSAM0,14750
-vrt_lss_universal/model/capacity.py,sha256=mEKNhvzqh2mykS_CoDuZvW8ec1rrqZ-KsPqGkgHeAgE,13604
-vrt_lss_universal/model/capacity_factor.py,sha256=YINd0IE2tAw2toVJ4N9ai9YusHhIobP98mJkofqXQIo,11629
-vrt_lss_universal/model/cargo.py,sha256=mtIHMOGv86mv0oSG_2T7p6ujJoen7lrwhdD-3VeDAgI,11807
-vrt_lss_universal/model/cargo_compatibilities.py,sha256=qB_3jkpk_VanQN5HT_QCZg6U4NjmVmt9sZ5EkHVntJA,13676
-vrt_lss_universal/model/cargo_features.py,sha256=e0Hg3hm0KynUI49iUqN0r-UNY1atnmV2WRlRGgB8PMg,11649
-vrt_lss_universal/model/cargo_placement.py,sha256=oa2nY6glXpGmohZC-m_CN-xzVLOUM_XdZdBCtFlBcW4,11515
-vrt_lss_universal/model/cargo_restrictions.py,sha256=eHqxqh831oAfXyLaxup-O4D4mFKgcTpgxV0euvxP4us,11701
-vrt_lss_universal/model/cargo_rotation.py,sha256=RzXAjunG6ebT22E8cA9S1iqjuKdAxpxCuZQXH1kKJl8,12663
-vrt_lss_universal/model/cargo_rotation_type.py,sha256=Gl9iClR3w05i8cZgCD3mPBuSsp6wqma4Sl6l4t6VVUg,12344
-vrt_lss_universal/model/check_result.py,sha256=Nt2CimZAeLCUNaH0udrqHLTWgrewijC_YWD20AAKpow,11170
-vrt_lss_universal/model/compatibility_penalty.py,sha256=SpkBaZ_G9Ydpe552Dm4qehS5auIS51K1jJ9MxBhf0Ys,11749
-vrt_lss_universal/model/demand.py,sha256=uzHJAH-2FTgshz6APS8lnz0X9zFo9xNfZQXxaG62P2s,14288
-vrt_lss_universal/model/demand_fact.py,sha256=CbzwCj-yuRnvFM9L5bDP2x4qhxpeXThNEBX7kJeixp4,12813
-vrt_lss_universal/model/entity_error.py,sha256=a-Fge9bKYdMRLqp8KhxXZd2ZiYIahhpjWvCSlqxPlqk,12020
-vrt_lss_universal/model/entity_error_list.py,sha256=FLg27CxBkWsZ1mJGraVYaBxTBfGHFlbL1fJAzpyU3i4,11910
-vrt_lss_universal/model/entity_error_type.py,sha256=RgNBoNUv7FD1BHbTHNvZYwicq2z38kMRmIGMz0Wbhz4,15312
-vrt_lss_universal/model/entity_path.py,sha256=ropt5GzH_S8DikPCcXwm4ODsqU1mbdM8POHMK7v5MJU,11806
-vrt_lss_universal/model/entity_type.py,sha256=wR3B2dWockDUh3rVao1ANvqsFNTUJ5zGXPDHEwnmum4,14135
-vrt_lss_universal/model/entity_warning.py,sha256=__USw52ZhAZ-O9V78ekkcz1Q9JCTLY4wH2OhvLTq7dA,12048
-vrt_lss_universal/model/entity_warning_list.py,sha256=vkNRvNQfcEDH97lHrqOFM-yd1dg1W8pHBFuKupeaUb4,11890
-vrt_lss_universal/model/entity_warning_type.py,sha256=dwzGQymcmeWotCJWvRbOWrxDFAHZ-KhaIWnDPNHcyjs,27798
-vrt_lss_universal/model/facts.py,sha256=tY6cQDDJzU1MhimpUXB78bSDFNAugfiZfE2OmUc9q2o,13151
-vrt_lss_universal/model/geo_settings.py,sha256=mTvpx2SDDCYo1KwEGXTLxQeKcTmsHdxVCAnc417Zu0E,13471
-vrt_lss_universal/model/geopoint.py,sha256=K-M6SmnFtiBtDFBRkzEFkT8tcVn5NPvkmkWlVuoRGsI,11581
-vrt_lss_universal/model/hardlink.py,sha256=AobOBMNz4GxyEJ5kcMht5-Tp9PbGt6EhhJW3_vTUFHE,11657
-vrt_lss_universal/model/hardlink_element.py,sha256=KmWq2Wu12-KB9KpDfsFGcNeu8sfqKidYYXs2idh5xig,11672
-vrt_lss_universal/model/hardlink_element_type.py,sha256=kAeh-k98yAB1PHNToQs1efBFQy0kY87yqoypu99en5g,12252
-vrt_lss_universal/model/inline_response400.py,sha256=JR96K9wU5FDCIcSNWYk2fk1HhJRYHc1tlLEo_yjad1Q,12731
-vrt_lss_universal/model/inline_response401.py,sha256=Eg71-65pMVhfl64pXqnNo-FvZBzVd7SqwZ57CWZDQc0,11729
-vrt_lss_universal/model/inline_response402.py,sha256=FpFCvNIIyeN-RJxVhekbr9eg_6-8A67vhtcsLyqpjHw,11729
-vrt_lss_universal/model/inline_response403.py,sha256=R8INloKfBNgRonP2oLFih-rxQo0P7-yLwzoSKtKo_pg,11729
-vrt_lss_universal/model/inline_response404.py,sha256=MjRFpIGb-8-JJZB9tMqmLibjkzZbatZ2_sF5zeB1Xc0,11868
-vrt_lss_universal/model/inline_response404_detail.py,sha256=KFsZgBtUZ5zNKc10QfBxc7LkwfkN97Q8WW99_oBG9VE,11536
-vrt_lss_universal/model/inline_response429.py,sha256=uQiQzFSrZjdyP6ehhSl3YmvdwXWSOn32speJPHI4PDY,11729
-vrt_lss_universal/model/inline_response500.py,sha256=8_Lr6tCK7UbvwiCYjKapFDJB0yqpi2cOD3D_q0HJMzs,11729
-vrt_lss_universal/model/location.py,sha256=TtjUttZvhXPOr67Tn3zG_olMo_nnV_OYVyRkR3jb3jA,13492
-vrt_lss_universal/model/location_compatibilities.py,sha256=WvaogWsENRw_LvaLQ0tpPabIDe4EGADdnLWuT2cMY3I,11305
-vrt_lss_universal/model/measurements.py,sha256=n4TOEcJGixTTTerfEN0GCFNznVFH_TpjN6j-oz2z2ps,13639
-vrt_lss_universal/model/model_break.py,sha256=ekbRZ4GeCgPZuzwzW40mboDZrmNpIFl9YuFHNHF4XtA,11603
-vrt_lss_universal/model/object_metrics.py,sha256=BIx7yIMn69UJhAA9NdSBkFOQkyX7A0aKMoT80IUBgH0,11496
-vrt_lss_universal/model/operation_id.py,sha256=KZd8xdxxgE2NzjMHVpP2z6E1_lgGF8pHiVGlUY3ieAk,11686
-vrt_lss_universal/model/order.py,sha256=L6NR5vdRiCoEUdRBSF0o_JULR0X9M1yAiMTEiz75l2c,12886
-vrt_lss_universal/model/order_compatibilities.py,sha256=L7gamVCFuGnotwJJ1UcphnpMLAyjkNRu43ZI3YSNEsg,12382
-vrt_lss_universal/model/order_fact.py,sha256=FeQT-YmXMHp0W0vNI28LXrKociYmna6KGiXw5laMmms,12117
-vrt_lss_universal/model/order_features.py,sha256=iwVmaXsenz8Hz1PxLcv52IuiFmZUfu7-9teLbwXD4F8,11378
-vrt_lss_universal/model/order_restrictions.py,sha256=2_NS3DFaNnWxI_UwLGBRi1jOws-_et6D306hIIbPAAk,11594
-vrt_lss_universal/model/performer.py,sha256=UPTbhfxNJPK3Wkke5oHCxlwK88jS2EqjpFWcX3ggGCE,13044
-vrt_lss_universal/model/performer_blacklist.py,sha256=DoCuUW2uMv6qSIKj5GyJjpFW83ARdFWJU-t-TOrLuB4,12124
-vrt_lss_universal/model/performer_compatibilities.py,sha256=O4VzbdHbyFh0cs5LjAWYYO5wWddXB1d2ukVf-x1O5O4,11682
-vrt_lss_universal/model/performer_fact.py,sha256=UWunkC04cmBzdGO3j4eCt9xvnsxgkNVM6jmqeu98Zps,12286
-vrt_lss_universal/model/performer_features.py,sha256=rPqB6RmlwNXZGRzB_nq6IWb5Xsq9kDJwx4xcwrsWOc0,11669
-vrt_lss_universal/model/performer_limits.py,sha256=qYmSpBkzDav7aAXRYkM2YJ0CQaGgrXbn49fNxCSwf-o,11348
-vrt_lss_universal/model/performer_restrictions.py,sha256=r0zWXZBTHs0-mibwwSgeGio2O5JAGiJctunW9wgkwK0,11769
-vrt_lss_universal/model/performer_shift.py,sha256=FYS9Pcbomzkm-m31AjvGYTqHws1FTluXLItwlGcl-uQ,15197
-vrt_lss_universal/model/performer_tariff.py,sha256=kM4OXv9ADAUMDrNbbV2lVWJikH2OAlzNQZFmtaHDJTU,12909
-vrt_lss_universal/model/performer_tariff_constraint.py,sha256=m3F5_xiTanJmsTfvDc0G3ja8KRhio7VS3ZSx9WTBjMo,12246
-vrt_lss_universal/model/plan_configuration.py,sha256=3tnqrL9vnjTr0QRI3neZC4U9dr_ByYCQqZkzVZopIiQ,12090
-vrt_lss_universal/model/plan_result.py,sha256=Eoa3r2xyTcR5VqdW0neMvSP9lLRjTRukSyPyAcNUKJw,13529
-vrt_lss_universal/model/plan_settings.py,sha256=jB0dODh0mVeoEAXQZPuMt8lNix73QyFykEsm2HF4WF8,11877
-vrt_lss_universal/model/plan_statistics.py,sha256=VBkR0zfyY8ZpPMM-IrT0fEkTBqQg-otl2XiCtABGkIE,11943
-vrt_lss_universal/model/plan_task.py,sha256=jw020S7KHfT1ocTjyi_PHYRD3iVWYj6cKA9aORYylT4,14071
-vrt_lss_universal/model/possible_event.py,sha256=b0xu3OcyXhdRGfAI3zzSo5X3Arw1wth7Ybb3xBegfRA,12982
-vrt_lss_universal/model/quality_statistics.py,sha256=IbLn7RKeJKvXuwoNbRwE_w8zegbTFMOKSDmYbxKgSm4,11981
-vrt_lss_universal/model/replan_settings.py,sha256=d6747eKQLdXCH17AssXNHjEN3G7fWFTSzx4J_AzUJVs,12221
-vrt_lss_universal/model/replan_strategy.py,sha256=X7Ueq9czRBN5hO8wvVGSEsHIyzlXlfsVl8WbthFALo0,11878
-vrt_lss_universal/model/replan_task.py,sha256=kCtq7jy2mp6jpjzYNvLMJkj44oUuZesAnKuywPiX2lg,14717
-vrt_lss_universal/model/routing_matrix.py,sha256=mOgZG6f5nVtxdgZbbKOSOFrPzP2dULbslyRGgqy4ErY,13353
-vrt_lss_universal/model/routing_matrix_line.py,sha256=FpJ-eGjbEPD4GYsvZP5-b66zBxloKLYzGXQ-Dce5zj8,12094
-vrt_lss_universal/model/routing_transport_matrix.py,sha256=mPRBttHFwDVJiUdoLzjvoZ5qVQUkhqAcXXiHCX1QQb4,11667
-vrt_lss_universal/model/routing_transport_matrix_list.py,sha256=TNbQWiCoIa9wckXU5jb917lnUxl6LPdVP8otjCu5PoQ,12308
-vrt_lss_universal/model/schema_error.py,sha256=M9mrr7B8Zg1WFwb0vy-GM60O1dpOt4fPWRo92GIJsg0,11404
-vrt_lss_universal/model/schema_error_list.py,sha256=ymROzGdKkx8XOMsJkJLPQzjsNbiSmGFiCkMr9JA9K2c,11862
-vrt_lss_universal/model/service_name.py,sha256=kpFCT9e1rdJLrQtH3v1lOtzoiP1BT5ZjgDN0F0AVYK4,12534
-vrt_lss_universal/model/statistics.py,sha256=HyismlvfFTyzSEXW8fzskd0KGdGCp-hI-QUzfa4oD5o,15425
-vrt_lss_universal/model/stop_statistics.py,sha256=ZS8JJlyQ-T71h70sUvjM-U1XV7wvHCoLNw_1EzwAdrg,14059
-vrt_lss_universal/model/time_duration.py,sha256=fKA4HLRWBLrAdv-EZ-qXfUjmMQw51jgLtVXYZ6OY6gM,11773
-vrt_lss_universal/model/time_window.py,sha256=MVr1a-y4vdZjcc2frmsh0nBUsmsbDKO23bmZj6EY1zY,11638
-vrt_lss_universal/model/time_window_violations.py,sha256=iFaYygZ6n-DxtIQWx4AwhySbpdBI0Q00YRiSxSwgSPI,11446
-vrt_lss_universal/model/tracedata.py,sha256=lrUMJ_6wzWybyqN6QISDFr3kOw8ZpO0ie0fCmtXgHAI,13395
-vrt_lss_universal/model/track_point.py,sha256=uSI-Te3nP_k0DqvPhJ0zg-kVNYrGGhpssaRL7Oskt1w,11602
-vrt_lss_universal/model/transport.py,sha256=ton-fV7OJUVO2SOvYMEHOrsA2PU-9Re5-J1TZNHEMfc,13569
-vrt_lss_universal/model/transport_compatibilities.py,sha256=AJkg3QacG_xnRmQ3G-KGjRx580UgBR1Y9eIg4PWVTUo,11682
-vrt_lss_universal/model/transport_fact.py,sha256=9cR3Lv5S_kzvEbydfCFZ-ye8sDPwcfswlqgYjJZRY8Y,12286
-vrt_lss_universal/model/transport_factor.py,sha256=RfCGTtn1yT3HT0BidvuPrL8fG1k1LKHgE-s1EFr9KeQ,11677
-vrt_lss_universal/model/transport_features.py,sha256=VfErqjeN85NjqD7qXjjjxX0sS_8UI6RX9pLupZicfV8,11757
-vrt_lss_universal/model/transport_limits.py,sha256=k0DRinioaqkZXJ22Oz30X2eZQGcINhcCjxUD5Qtf1vs,11800
-vrt_lss_universal/model/transport_load.py,sha256=k9BrWnCWd7NeuEUHg-mX6mUDh_1xMX-2i1VTQeaqf9o,11526
-vrt_lss_universal/model/transport_restrictions.py,sha256=qGCBN6TDF_VUBSyfhfCPUo8X1kkPBaqCskKvRHnK_rM,11781
-vrt_lss_universal/model/transport_shift.py,sha256=K1J-1Pz7Jr9_Zdivph5m2gtowKZVzHmK8O2yhEUkn78,13793
-vrt_lss_universal/model/transport_tariff.py,sha256=eOZ9HYGThDsVSdAyymalekaZ5M5amBCVTn6TpCimjYA,13202
-vrt_lss_universal/model/transport_tariff_constraint.py,sha256=fWFRp8mMNdDsboxGDb-GMWXPc7PEdXW5eoqtKqIww40,11922
-vrt_lss_universal/model/transport_type.py,sha256=bOjmR2yQtf002olZUrqecViUKM5rTfzXS9z1Row6da8,14044
-vrt_lss_universal/model/trip.py,sha256=_7X0LJN37d6navuv3hQa5a5KvzgajaoAgXHuEeg52Ik,13332
-vrt_lss_universal/model/trip_assumptions.py,sha256=eEjINKsR3q-KooXb0UBajVbKTELcBHgHnt2BQ2istFk,15214
-vrt_lss_universal/model/trip_penalties.py,sha256=cqnZsL4OJ7KizgETkZOMV5RqhBeeu9GuqkNxVvzUfZc,11535
-vrt_lss_universal/model/trip_start_time_strategy.py,sha256=oExsrVwNV6Ep7VkCxN2vkfHiEUYtISW6xa5Vf9gInSg,12022
-vrt_lss_universal/model/trip_state.py,sha256=_07GpsA6RZhEU2oSr6riKGueJb1RvE3MwZc86Qjulsw,16556
-vrt_lss_universal/model/trip_state_flag.py,sha256=q-3oPJ9Z4sAMR7fE6n9oc30MQUmPOoAHGaIkRVjIkyE,13144
-vrt_lss_universal/model/trip_statistics.py,sha256=RuM-wY6Uv6eadnq3GMo37L0USIZCJIcu5c2nGbZobSQ,13186
-vrt_lss_universal/model/trip_waitlist.py,sha256=rTOkywsVTy8MCyYVGHfwYQHvSLEvk1An2amxh4hbCbM,11907
-vrt_lss_universal/model/trips_settings.py,sha256=_mBNPDVlrxtV7gNRhGGrAU9Pw-EQWH2w2j3-oo0S5oE,12263
-vrt_lss_universal/model/universal_data.py,sha256=5D-MOaeDF2VuIWE4bSoGLPEDjNBdTxu4GvFJ1s-IbVY,15297
-vrt_lss_universal/model/unplanned_items.py,sha256=kbd4UJF5XK_g1v64LAUtMl_bGPCq4Dk0icX46gQ5Ysk,14143
-vrt_lss_universal/model/validate_result.py,sha256=WTRXGWBotdCCmied4hLPbK4aa3BVSOP8kGbNuxkPsrA,11610
-vrt_lss_universal/model/version_result.py,sha256=Tf9D17H5uwAChNHcXFq-mHg8BlEUYtbOgEjfPKgq9_E,12597
-vrt_lss_universal/model/waypoint.py,sha256=zS4KfOlG5-Un8H_v6o5oCiJfottohwnzgzCA0mbBwVQ,11892
-vrt_lss_universal/model/work_and_rest_rules.py,sha256=XAjh3_Sfq8GcL9stT1wUMN57CPtyOVhHVU9A7r9UZuk,11153
-vrt_lss_universal/models/__init__.py,sha256=tO31n1aJe_U2nKr3sds45v4n0T4jDYDZ8arG8f31w-A,8734
-vrt_lss_universal-6.4.1962.dist-info/METADATA,sha256=V37Mw21zRRXg1pz8KmYsEKet224zwZrwMRhmFzqVn28,369
-vrt_lss_universal-6.4.1962.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-vrt_lss_universal-6.4.1962.dist-info/top_level.txt,sha256=Q8tErg5A2_BLSCoyvso0rg0nJdxptEQAT2UMPNpwigY,18
-vrt_lss_universal-6.4.1962.dist-info/RECORD,,
+vrt_lss_universal/__init__.py,sha256=Kmv2XHx-R0jpqU8NnOS2C7XzKcJiIw4iVXT76RKC4-I,7795
+vrt_lss_universal/api_client.py,sha256=1hdsEow9FEE6cqe0Q-lHBooVKVpBhbFbWYmo7aUViHk,29547
+vrt_lss_universal/configuration.py,sha256=EOk2AlH8pozYKPAxblFyt01c1rjm6BSSx6Fx8UWg1rI,14673
+vrt_lss_universal/exceptions.py,sha256=ANJqUMOUgW8G0rSYayExxvhVWdvIzIQGkkfcAUixNkM,5040
+vrt_lss_universal/rest.py,sha256=Xrg1xMYGXPk99Cu1PZCHsZorh9I4aCr0jsrs6CHWezU,12563
+vrt_lss_universal/api/__init__.py,sha256=wahoiuhEcWSzqUuT2iojHC78J46tiInoizOglm180BA,327
+vrt_lss_universal/api/actualize_api.py,sha256=H2y4d9KMNpOpMQz5W_8F5sc8kRk-sAOdrHvpiH71fls,21357
+vrt_lss_universal/api/convert_api.py,sha256=gnRhrV8NHmvu0ZSM4PEYJHuBsrf9-AxynEdJ2jqmiKg,14753
+vrt_lss_universal/api/plan_api.py,sha256=SzV4RFzqHniiyGt_UORax2DOpnYJJ-lnDLFTiTwzzJA,46319
+vrt_lss_universal/api/replan_api.py,sha256=rJz6GXRChLayhJZGXxGBUNviO_zXuEdv8Nt0NUse3Vo,53433
+vrt_lss_universal/api/system_api.py,sha256=CvXbjrnyvL34DX57rGuXPbLdHxV4SYGd7x2q8w2yteA,18580
+vrt_lss_universal/models/__init__.py,sha256=gWasdoV2ja3t6uMBzBS-Z2-m6QxbtDWyMTVgQXzLwEs,6998
+vrt_lss_universal/models/actualize_settings.py,sha256=bHiQweN09lTnfbIwY2Uz8haYMWM0Y0QgZA5kFdBPp6k,3293
+vrt_lss_universal/models/actualize_task.py,sha256=qfDVUh48XkeuladZi8K-fPCwwdKmtt99rFLTNrFM6mM,7650
+vrt_lss_universal/models/assigned_performer.py,sha256=peBGv9ABpC7qbolSzhnbMXBflG0lKBE0ClFk7cpl2bE,2780
+vrt_lss_universal/models/assigned_transport.py,sha256=AFr3O69LNTgK8lfw-LVSKqHOuyYctyLEVhs3xhpmawE,2778
+vrt_lss_universal/models/attribute.py,sha256=ZD9aaehelz_VfoTMQqGKG_K2UQ53AA9czABy0Am83-0,1932
+vrt_lss_universal/models/box.py,sha256=B7JBYjpIH7ReY7puON_MboyRT1xO6rYcCZ9KuViBJeQ,3754
+vrt_lss_universal/models/box_compatibilities.py,sha256=eJ5FhMK_0UAI8ZTp5MfJj1cALDVwB5UKKPWZl1J-jD4,2690
+vrt_lss_universal/models/box_limits.py,sha256=SAS0ZME3u54Qh-9qXt4k8RuMECjj2UQv9yjMROkkM04,2483
+vrt_lss_universal/models/calculation_async_result.py,sha256=msEauoQ1EAhc2bjtkEZbkajCWvtcjrZWk3BNBfiiMFs,2261
+vrt_lss_universal/models/calculation_info.py,sha256=8JmwrpMq3D1TKjsIpLWEbu4bc_qaAGtAdCeiW2cbgrg,6528
+vrt_lss_universal/models/calculation_settings.py,sha256=n3BNwxu7VClydMCkKdAhN4w7rkuKgGmg5Pk7U1AxxDU,5336
+vrt_lss_universal/models/calculation_state.py,sha256=BiszWBvG1GkfFVroVVrL_g_JHz3kbluIjiru5wZ9niQ,2725
+vrt_lss_universal/models/calculation_status.py,sha256=j1XtNnTzZ9b20LdSuUF6fB9o7LLcYamAR67KYWNIHio,1235
+vrt_lss_universal/models/capacity.py,sha256=QDQBebm2MtQGgkwyEW1pkppQedrlQMmu6-7xMZ6i0HA,3065
+vrt_lss_universal/models/capacity_factor.py,sha256=rc7Oqu4vEx_WiecdX3VMtlI6A1mLUsdYm6PEZJBvEgA,2498
+vrt_lss_universal/models/cargo.py,sha256=2llL36CUUGlTNg_h3_ZqE-s8CcCd9BVIjmZxXJS0Eb0,3118
+vrt_lss_universal/models/cargo_compatibilities.py,sha256=Hckp6y8N3m-byDwCyJ6QuQ0XCvZWjcreNcElkXcI6iU,4051
+vrt_lss_universal/models/cargo_placement.py,sha256=T_UVB6Y1C1U7GAsvtOT1a98ZSx3BoArxB1J-_gH0080,2021
+vrt_lss_universal/models/cargo_rotation_type.py,sha256=G0GTjfi37uFei1pvrcZy2ejseWXHxdkS1hxdzkyscBI,670
+vrt_lss_universal/models/check_result.py,sha256=3NQwMT5AWliSrIEKitqaQ8rD--FW5jjmS9e5VVIV_Nc,1805
+vrt_lss_universal/models/compatibility_penalty.py,sha256=Rj3NyY91gqzpM4trcI24_rewOJ7ePrPi8-6O1I6O6kA,2277
+vrt_lss_universal/models/custom400_with_errors_and_warnings.py,sha256=T68lYKrigasFmtmQK-5JqM3bcFGHpWLpFxEyU1z6KQk,4577
+vrt_lss_universal/models/demand.py,sha256=4kkYc70SP-YoqCCq-TaUwPUma4eHBWLoyF9a5IPLr1c,4744
+vrt_lss_universal/models/demand_fact.py,sha256=9ntu12yEu8OsQh_TRnm3gSlOjLbJ4ZsFH2bJm4srQy8,2841
+vrt_lss_universal/models/entity_error.py,sha256=7shmacozVBhzPi1j0TGcoL0_9QvjNRJVhTrn4sLYIV8,2872
+vrt_lss_universal/models/entity_error_type.py,sha256=au41eRPW3Tv2KVZCVKejrpbWPa6L8MsMoQvOk9YuIFg,1433
+vrt_lss_universal/models/entity_path.py,sha256=a7S3oB16SXwULdJ3_-UU0q-LZgpOcwRSxuXZdzQQnE4,2853
+vrt_lss_universal/models/entity_type.py,sha256=QRur-nxs7VrRaXnwvhrtHhtYihHB9nWeCwPiAcsuvWg,1183
+vrt_lss_universal/models/entity_warning.py,sha256=cAX2524hyL0W9K0ZOtvB3tgEWbLTFuTneIHRjtlBnbo,2898
+vrt_lss_universal/models/entity_warning_type.py,sha256=XvMnF8P4G0T0S8jiKribAmDOp_AxgPjt_Yjm4jAao0A,4971
+vrt_lss_universal/models/facts.py,sha256=0NINSTIvuwaL7iYH0So3OZoKjrXIcLSeHjW0qorPCEM,4510
+vrt_lss_universal/models/general401.py,sha256=LnybayRMsgVNHh4ZdVuK5JUlf81S8Rv04vWwqdxlICg,2400
+vrt_lss_universal/models/general402.py,sha256=iRTNnE3bEvGIzgfkhAA8sIGufixtsiGEut2pxpwoaFk,2400
+vrt_lss_universal/models/general403.py,sha256=PbePk7eYuKF4BZbjxNdt4ettiyqTLF7sTVsC1GPPlUI,2400
+vrt_lss_universal/models/general404.py,sha256=xRI0N2LoTqFn5OpSLuZutTIE_TeejG244vxHKQ4POBM,2654
+vrt_lss_universal/models/general404_detail.py,sha256=U6mAb3fQNs3VQn4G-2Ds4l5uSfe_r4KnlYmE8b8wdvs,2058
+vrt_lss_universal/models/general429.py,sha256=RVCcOF85mnNViViJuWpz3MIxMvQYwYxM4Rbk_8r2vck,2400
+vrt_lss_universal/models/general500.py,sha256=W2bBTov5gPdhmBZB7wBR_Usc1JAWkUxsdM49QJBAfN8,2400
+vrt_lss_universal/models/geo_settings.py,sha256=tmTTC8gBe3MwfQWVZgS3FJosSxrjB-ZpEwk9CTtQTJk,3294
+vrt_lss_universal/models/geopoint.py,sha256=vtze8BkAjKAN1d2e_rlCEH2kQirbJWzwLfvisAxe6gk,1954
+vrt_lss_universal/models/hardlink.py,sha256=4UH66peo4n0hMg2t_HRV1o9ZvrdA2Z1kNi4tbzNyhV8,2838
+vrt_lss_universal/models/hardlink_element.py,sha256=axuXefm4CBjsOpovZJ9TOLHBFsi7ibLZnP4xcv8bNos,2052
+vrt_lss_universal/models/hardlink_element_type.py,sha256=xwXFPm1UcrzOFktQeu4ybz2WdSnHLFSzEiNKyjVJbB0,581
+vrt_lss_universal/models/location.py,sha256=j4AfoLOnhbtq7rtYddfiXbKgnvfPapWQ5PP1V5gffRM,6333
+vrt_lss_universal/models/location_compatibilities.py,sha256=Uf2Ks8oheuh9TnKUd9YHNb_zLlMQ3eovfQg_iccy6Jg,2214
+vrt_lss_universal/models/measurements.py,sha256=Xm3MmjBscNoLlj_TksVHvbS07TDtnr9PovOdVLmMOb8,8581
+vrt_lss_universal/models/model_break.py,sha256=IOnNGfSbqaMQk_wRz7JP5uvn5j12a4fe5NpNFH7_45w,3449
+vrt_lss_universal/models/object_metrics.py,sha256=TdGr8ervX6_onbE6YsBQweIRZoNg5cN7L43wq0kh1vM,2070
+vrt_lss_universal/models/order.py,sha256=swuA5IILXTl8R9ktiy23RGFgcBqMaPGLnoyIhRqk6Qk,4593
+vrt_lss_universal/models/order_compatibilities.py,sha256=3BcOg66QPK5BZadmI3LKAdsh4QyEWNzDBisl2iTc95E,3245
+vrt_lss_universal/models/order_fact.py,sha256=RsLzcrC5h7qf0ItK2SgtCm-g-BHp1IHRAFaI8ZPClxY,2491
+vrt_lss_universal/models/performer.py,sha256=emFA6HiWQid8h_5HucnKqcrmstKXTVlbtO-flq1JXiY,4785
+vrt_lss_universal/models/performer_compatibilities.py,sha256=IPibzFuyi-G9hEliltLqEB6GtfvIAT8KwJVrdR6pcCg,2570
+vrt_lss_universal/models/performer_fact.py,sha256=Sqzb_EOECNJ8LhPPscQIzAN1w0WxSlukTVlDviXY-r8,2593
+vrt_lss_universal/models/performer_limits.py,sha256=fEy1adpNoCQksTpH33I_F9B6qqxh1TBk-J-lnVuXokU,1993
+vrt_lss_universal/models/performer_shift.py,sha256=CN060Od7OOC1bCpi0ds7WSW7jvDrCeOuD2n5sEZDE4E,6960
+vrt_lss_universal/models/performer_tariff.py,sha256=RQZEwdaAbO86XZ-6Ld01QSQvffRxxjZ3qIukxcfI_Ds,3356
+vrt_lss_universal/models/performer_tariff_constraint.py,sha256=Rhz0x3MzuZufWhnLjHPLKuemUIrTt1br1Bf_apRX4no,3010
+vrt_lss_universal/models/plan_result.py,sha256=mjJ4PdY1DWnhCfBg1xUbvcKz9QgGnF4YhL5225ZUmTo,5202
+vrt_lss_universal/models/plan_settings.py,sha256=QurJOJdeAHWA5ykL-yLzA1q0tShCM4r1R-Hvmjuxomw,3105
+vrt_lss_universal/models/plan_statistics.py,sha256=shGtl8QTtb6IHx9S_7Jz99mnsJKTdubDspBBwA6EgdU,2920
+vrt_lss_universal/models/plan_task.py,sha256=NNXbTdCpXuhdL61xQ-lxmKFG5pjsyZdW0kDpFcArNZ4,6596
+vrt_lss_universal/models/possible_event.py,sha256=hYfVHAbi0ijlVh9d4ieC3mUiPwNuTF2S2h1WIjTJHRw,4587
+vrt_lss_universal/models/quality_statistics.py,sha256=qZGSap38ZD2K7P5xp8ZRJQJAiL6IDPUktq-qMMfEhWQ,2788
+vrt_lss_universal/models/replan_settings.py,sha256=U4zngytQdn6TdVA4TMHelUx5O1Y8VQXgOm0yset8Xuk,3595
+vrt_lss_universal/models/replan_strategy.py,sha256=ZiPd9OmyaEYJrP9pgwLaS1eUuVDqEcw9DEdJGqidYAA,2365
+vrt_lss_universal/models/replan_task.py,sha256=QO5UctQj2VggSU8EXK-gjTLGw3pwWHseDHurT8eameE,7576
+vrt_lss_universal/models/routing_matrix.py,sha256=Ppmqy1IBiSlIjmzCxacJi80wHJD0h0DLZ94W18Nx-j0,3337
+vrt_lss_universal/models/routing_transport_matrix.py,sha256=R9pnXlq9Y9-P_ZGlMkgyor1Np8IqPKcwqC9EHGRMbhQ,2305
+vrt_lss_universal/models/schema_error.py,sha256=LE9YgctyYXwnOhbwPeJggrhERZu3RL4Dr1rTMzNqAa4,2179
+vrt_lss_universal/models/service_name.py,sha256=B07PEjpULSOW9oI-aqGylsclbXZjMwZEqYf7RszVNKw,679
+vrt_lss_universal/models/statistics.py,sha256=OtxlShgTHWwEt0X0ViFmlrApzyrPpCdTgYJFUF4lSZk,5263
+vrt_lss_universal/models/stop_statistics.py,sha256=Sy3v9xfdM8u9pmB7VZDGHor27-UBiQ_Bbz1n2_ESUZ0,5123
+vrt_lss_universal/models/time_window.py,sha256=4SaWYaULPfl-sFTpwYZ9IgqzqCw__V_5ru4bC4QLiAE,2085
+vrt_lss_universal/models/time_window_violations.py,sha256=rA5dW9WQ_LpeFGafVVX4i41w_kgc309NMGDg0wadZPI,2399
+vrt_lss_universal/models/tracedata.py,sha256=Vs5s_Tcku7RQNPJ1GAB-Y4RvDDP-Y02vmIM8po4PD3c,3286
+vrt_lss_universal/models/track_point.py,sha256=d7yIUSZIlegJ5hu4CeK73mgDaqQoL4EXZcMl0a3u1Xk,2274
+vrt_lss_universal/models/transport.py,sha256=9RrDK0US6gISNp7Lp3e-CGYCvn_8f2cJdpAHNqIap38,5430
+vrt_lss_universal/models/transport_compatibilities.py,sha256=8srWUC31uEZTlu1fNVOk48vgqmhYkTa2KI9NX4EQ7no,2589
+vrt_lss_universal/models/transport_fact.py,sha256=f18Xx8jk5tsS6VZbY6d9W357K_JRHqKzsbDWHoXJEL4,2593
+vrt_lss_universal/models/transport_factor.py,sha256=2pi24H4a8hyjfvcZvwLtNjgS5E8rPgJLELJlpczLyg8,2064
+vrt_lss_universal/models/transport_limits.py,sha256=7FgYcmtqlXjkItjdRsll9U84aXZl3M0CbpQi_Lv7IoM,2903
+vrt_lss_universal/models/transport_load.py,sha256=qh2ovN2XXMc8sQM6HiM0bLRsQBopuUDQ3btSy70pfYo,2441
+vrt_lss_universal/models/transport_shift.py,sha256=Ex_4zch678YnC8ZqkddkglUqOuBkpYv-ENVX-bMMRrg,5490
+vrt_lss_universal/models/transport_tariff.py,sha256=_nHZs9H0NQj2N-2fwby8FsQwQ897EmDfCQWAfC9LqRM,3845
+vrt_lss_universal/models/transport_tariff_constraint.py,sha256=yxfOve9QHpnbFW3z4_wWE7DrPwb0rgGk6X9tt6TouT4,2383
+vrt_lss_universal/models/transport_type.py,sha256=y1Jy2Xxl7YjF_dGx9QsC0n_a2wS8hemn13LBG6Q63uU,1140
+vrt_lss_universal/models/trip.py,sha256=pvzuIUYHPX6SsbsmP0Xqbc2itKsBGUyzjSVTdf4_GUc,4511
+vrt_lss_universal/models/trip_assumptions.py,sha256=Yxa9OCDfx0BrAs7RXtlgn122f0-rKemPTw5bAmYNoXI,5097
+vrt_lss_universal/models/trip_penalties.py,sha256=iZsLhz0ursQSB9XM5AlUPMzbmGu4CccrvzoDhuI_XXg,2540
+vrt_lss_universal/models/trip_start_time_strategy.py,sha256=gz1sP_a_pYh3k13148ow-PfTInq9sw9d2GaxUID04x0,576
+vrt_lss_universal/models/trip_state.py,sha256=4k-2gTqVLncPnjiu-PnxLCzIRocnDXa70JMrgtDVjUk,6226
+vrt_lss_universal/models/trip_state_flag.py,sha256=Ci20bzlVsP2JuDcPLCQtYsGcm9DL2KALScF2CVcr0MM,868
+vrt_lss_universal/models/trip_statistics.py,sha256=RU3EPQJ354Ep3-p7FzAH_dLSg227LqkJAw8DoUOUeK8,4174
+vrt_lss_universal/models/trips_settings.py,sha256=s_CCpy_oBTV34sTQRiKS2wxuPUXpXIBsygEE1a4P4D0,3241
+vrt_lss_universal/models/universal_data.py,sha256=grFQ7NQQJb8RCR7mlTipjkTAClTXpHBoael6mLJN-M8,9370
+vrt_lss_universal/models/unplanned_items.py,sha256=tMcYU1mVPvvmTy6ErAVbNHUfmGxA_jNNSYK9fphbFeQ,3858
+vrt_lss_universal/models/validate_result.py,sha256=HzxuH4TIKhrdOKZs1dvT04NYRD5mIGbnULXzmSnmRto,2721
+vrt_lss_universal/models/version_result.py,sha256=o7CRxb8bF13ZbJAgEVUgW8yM2TOSrIO07HTbg6i3syQ,2508
+vrt_lss_universal/models/waypoint.py,sha256=rnN9TEZwK-cC20hAimV0OpiG2d57umYXFSovh1LcK8U,3238
+vrt_lss_universal/models/work_and_rest_rules.py,sha256=L2PWGraHIa4iEEeoGOtQz8GwEPX4urf-vEt6qeeA1Lk,2346
+vrt_lss_universal-6.5.1990.dist-info/METADATA,sha256=JfdTfIHldJk8zmdrAeOJhzXSoVhQkw0mArG6tG0ohug,18642
+vrt_lss_universal-6.5.1990.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+vrt_lss_universal-6.5.1990.dist-info/top_level.txt,sha256=Q8tErg5A2_BLSCoyvso0rg0nJdxptEQAT2UMPNpwigY,18
+vrt_lss_universal-6.5.1990.dist-info/RECORD,,
```

