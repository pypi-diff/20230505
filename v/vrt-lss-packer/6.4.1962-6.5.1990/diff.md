# Comparing `tmp/vrt_lss_packer-6.4.1962-py3-none-any.whl.zip` & `tmp/vrt_lss_packer-6.5.1990-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,68 +1,57 @@
-Zip file size: 172110 bytes, number of entries: 66
--rw-r--r--  2.0 unx      662 b- defN 23-Apr-05 10:42 vrt_lss_packer/__init__.py
--rw-r--r--  2.0 unx    38703 b- defN 23-Apr-05 10:42 vrt_lss_packer/api_client.py
--rw-r--r--  2.0 unx    16601 b- defN 23-Apr-05 10:42 vrt_lss_packer/configuration.py
--rw-r--r--  2.0 unx     4992 b- defN 23-Apr-05 10:42 vrt_lss_packer/exceptions.py
--rw-r--r--  2.0 unx    82280 b- defN 23-Apr-05 10:42 vrt_lss_packer/model_utils.py
--rw-r--r--  2.0 unx    14014 b- defN 23-Apr-05 10:42 vrt_lss_packer/rest.py
--rw-r--r--  2.0 unx      218 b- defN 23-Apr-05 10:42 vrt_lss_packer/api/__init__.py
--rw-r--r--  2.0 unx     6333 b- defN 23-Apr-05 10:42 vrt_lss_packer/api/convert_api.py
--rw-r--r--  2.0 unx    36462 b- defN 23-Apr-05 10:42 vrt_lss_packer/api/pack_api.py
--rw-r--r--  2.0 unx    15150 b- defN 23-Apr-05 10:42 vrt_lss_packer/api/system_api.py
--rw-r--r--  2.0 unx      581 b- defN 23-Apr-05 10:42 vrt_lss_packer/apis/__init__.py
--rw-r--r--  2.0 unx      348 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/__init__.py
--rw-r--r--  2.0 unx    11410 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/attribute.py
--rw-r--r--  2.0 unx    11623 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/attributes.py
--rw-r--r--  2.0 unx    12226 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/blueprint.py
--rw-r--r--  2.0 unx    11429 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_async_result.py
--rw-r--r--  2.0 unx    13486 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_info.py
--rw-r--r--  2.0 unx    11701 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_progress.py
--rw-r--r--  2.0 unx    14949 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_settings.py
--rw-r--r--  2.0 unx    11937 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_state.py
--rw-r--r--  2.0 unx    14741 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/calculation_status.py
--rw-r--r--  2.0 unx    11161 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/check_result.py
--rw-r--r--  2.0 unx    11850 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/coordinates.py
--rw-r--r--  2.0 unx    12155 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/dimensions.py
--rw-r--r--  2.0 unx    12005 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_error.py
--rw-r--r--  2.0 unx    12146 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_error_list.py
--rw-r--r--  2.0 unx    17871 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_error_type.py
--rw-r--r--  2.0 unx    11794 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_path.py
--rw-r--r--  2.0 unx    11954 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_type.py
--rw-r--r--  2.0 unx    12033 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_warning.py
--rw-r--r--  2.0 unx    12618 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_warning_list.py
--rw-r--r--  2.0 unx    15099 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/entity_warning_type.py
--rw-r--r--  2.0 unx    12710 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response400.py
--rw-r--r--  2.0 unx    11717 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response401.py
--rw-r--r--  2.0 unx    11717 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response402.py
--rw-r--r--  2.0 unx    11717 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response403.py
--rw-r--r--  2.0 unx    11856 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response404.py
--rw-r--r--  2.0 unx    11524 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response404_detail.py
--rw-r--r--  2.0 unx    11717 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response429.py
--rw-r--r--  2.0 unx    11717 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/inline_response500.py
--rw-r--r--  2.0 unx    11677 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/operation_id.py
--rw-r--r--  2.0 unx    13281 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/pack_result.py
--rw-r--r--  2.0 unx    11237 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/pack_settings.py
--rw-r--r--  2.0 unx    13450 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/pack_statistics.py
--rw-r--r--  2.0 unx    12232 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/pack_task.py
--rw-r--r--  2.0 unx    12996 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/package.py
--rw-r--r--  2.0 unx    13153 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/package_layout.py
--rw-r--r--  2.0 unx    14892 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/package_statistics.py
--rw-r--r--  2.0 unx    13489 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/package_type.py
--rw-r--r--  2.0 unx    13534 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/product.py
--rw-r--r--  2.0 unx    12572 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/product_group_layout.py
--rw-r--r--  2.0 unx    11968 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/product_layout.py
--rw-r--r--  2.0 unx    12094 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/render_task.py
--rw-r--r--  2.0 unx    11395 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/schema_error.py
--rw-r--r--  2.0 unx    11850 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/schema_error_list.py
--rw-r--r--  2.0 unx    12525 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/service_name.py
--rw-r--r--  2.0 unx    11764 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/time_duration.py
--rw-r--r--  2.0 unx    13380 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/tracedata.py
--rw-r--r--  2.0 unx    11464 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/unpacked_items.py
--rw-r--r--  2.0 unx    11595 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/validate_result.py
--rw-r--r--  2.0 unx    12588 b- defN 23-Apr-05 10:42 vrt_lss_packer/model/version_result.py
--rw-r--r--  2.0 unx     3474 b- defN 23-Apr-05 10:42 vrt_lss_packer/models/__init__.py
--rw-r--r--  2.0 unx      360 b- defN 23-Apr-05 10:42 vrt_lss_packer-6.4.1962.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Apr-05 10:42 vrt_lss_packer-6.4.1962.dist-info/WHEEL
--rw-r--r--  2.0 unx       15 b- defN 23-Apr-05 10:42 vrt_lss_packer-6.4.1962.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     6199 b- defN 23-Apr-05 10:42 vrt_lss_packer-6.4.1962.dist-info/RECORD
-66 files, 838483 bytes uncompressed, 162182 bytes compressed:  80.7%
+Zip file size: 73847 bytes, number of entries: 55
+-rw-r--r--  2.0 unx     3451 b- defN 23-May-05 16:04 vrt_lss_packer/__init__.py
+-rw-r--r--  2.0 unx    29529 b- defN 23-May-05 16:04 vrt_lss_packer/api_client.py
+-rw-r--r--  2.0 unx    14664 b- defN 23-May-05 16:04 vrt_lss_packer/configuration.py
+-rw-r--r--  2.0 unx     5037 b- defN 23-May-05 16:04 vrt_lss_packer/exceptions.py
+-rw-r--r--  2.0 unx    12557 b- defN 23-May-05 16:04 vrt_lss_packer/rest.py
+-rw-r--r--  2.0 unx      202 b- defN 23-May-05 16:04 vrt_lss_packer/api/__init__.py
+-rw-r--r--  2.0 unx     7706 b- defN 23-May-05 16:04 vrt_lss_packer/api/convert_api.py
+-rw-r--r--  2.0 unx    45958 b- defN 23-May-05 16:04 vrt_lss_packer/api/pack_api.py
+-rw-r--r--  2.0 unx    18556 b- defN 23-May-05 16:04 vrt_lss_packer/api/system_api.py
+-rw-r--r--  2.0 unx     2803 b- defN 23-May-05 16:04 vrt_lss_packer/models/__init__.py
+-rw-r--r--  2.0 unx     1929 b- defN 23-May-05 16:04 vrt_lss_packer/models/attribute.py
+-rw-r--r--  2.0 unx     2255 b- defN 23-May-05 16:04 vrt_lss_packer/models/calculation_async_result.py
+-rw-r--r--  2.0 unx     6522 b- defN 23-May-05 16:04 vrt_lss_packer/models/calculation_info.py
+-rw-r--r--  2.0 unx     5333 b- defN 23-May-05 16:04 vrt_lss_packer/models/calculation_settings.py
+-rw-r--r--  2.0 unx     2716 b- defN 23-May-05 16:04 vrt_lss_packer/models/calculation_state.py
+-rw-r--r--  2.0 unx     1232 b- defN 23-May-05 16:04 vrt_lss_packer/models/calculation_status.py
+-rw-r--r--  2.0 unx     1802 b- defN 23-May-05 16:04 vrt_lss_packer/models/check_result.py
+-rw-r--r--  2.0 unx     2167 b- defN 23-May-05 16:04 vrt_lss_packer/models/coordinates.py
+-rw-r--r--  2.0 unx     4805 b- defN 23-May-05 16:04 vrt_lss_packer/models/custom400_with_errors_and_warnings.py
+-rw-r--r--  2.0 unx     2247 b- defN 23-May-05 16:04 vrt_lss_packer/models/dimensions.py
+-rw-r--r--  2.0 unx     2863 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_error.py
+-rw-r--r--  2.0 unx     2111 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_error_type.py
+-rw-r--r--  2.0 unx     2847 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_path.py
+-rw-r--r--  2.0 unx      500 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_type.py
+-rw-r--r--  2.0 unx     2889 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_warning.py
+-rw-r--r--  2.0 unx     1335 b- defN 23-May-05 16:04 vrt_lss_packer/models/entity_warning_type.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-May-05 16:04 vrt_lss_packer/models/general401.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-May-05 16:04 vrt_lss_packer/models/general402.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-May-05 16:04 vrt_lss_packer/models/general403.py
+-rw-r--r--  2.0 unx     2648 b- defN 23-May-05 16:04 vrt_lss_packer/models/general404.py
+-rw-r--r--  2.0 unx     2052 b- defN 23-May-05 16:04 vrt_lss_packer/models/general404_detail.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-May-05 16:04 vrt_lss_packer/models/general429.py
+-rw-r--r--  2.0 unx     2394 b- defN 23-May-05 16:04 vrt_lss_packer/models/general500.py
+-rw-r--r--  2.0 unx     5134 b- defN 23-May-05 16:04 vrt_lss_packer/models/pack_result.py
+-rw-r--r--  2.0 unx     2202 b- defN 23-May-05 16:04 vrt_lss_packer/models/pack_settings.py
+-rw-r--r--  2.0 unx     3316 b- defN 23-May-05 16:04 vrt_lss_packer/models/pack_statistics.py
+-rw-r--r--  2.0 unx     3436 b- defN 23-May-05 16:04 vrt_lss_packer/models/pack_task.py
+-rw-r--r--  2.0 unx     4012 b- defN 23-May-05 16:04 vrt_lss_packer/models/package.py
+-rw-r--r--  2.0 unx     4145 b- defN 23-May-05 16:04 vrt_lss_packer/models/package_layout.py
+-rw-r--r--  2.0 unx     3457 b- defN 23-May-05 16:04 vrt_lss_packer/models/package_statistics.py
+-rw-r--r--  2.0 unx      878 b- defN 23-May-05 16:04 vrt_lss_packer/models/package_type.py
+-rw-r--r--  2.0 unx     3885 b- defN 23-May-05 16:04 vrt_lss_packer/models/product.py
+-rw-r--r--  2.0 unx     3559 b- defN 23-May-05 16:04 vrt_lss_packer/models/product_group_layout.py
+-rw-r--r--  2.0 unx     2669 b- defN 23-May-05 16:04 vrt_lss_packer/models/product_layout.py
+-rw-r--r--  2.0 unx     3645 b- defN 23-May-05 16:04 vrt_lss_packer/models/render_task.py
+-rw-r--r--  2.0 unx     2176 b- defN 23-May-05 16:04 vrt_lss_packer/models/schema_error.py
+-rw-r--r--  2.0 unx      676 b- defN 23-May-05 16:04 vrt_lss_packer/models/service_name.py
+-rw-r--r--  2.0 unx     3280 b- defN 23-May-05 16:04 vrt_lss_packer/models/tracedata.py
+-rw-r--r--  2.0 unx     2227 b- defN 23-May-05 16:04 vrt_lss_packer/models/unpacked_items.py
+-rw-r--r--  2.0 unx     2897 b- defN 23-May-05 16:04 vrt_lss_packer/models/validate_result.py
+-rw-r--r--  2.0 unx     2505 b- defN 23-May-05 16:04 vrt_lss_packer/models/version_result.py
+-rw-r--r--  2.0 unx     3448 b- defN 23-May-05 16:04 vrt_lss_packer-6.5.1990.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-May-05 16:04 vrt_lss_packer-6.5.1990.dist-info/WHEEL
+-rw-r--r--  2.0 unx       15 b- defN 23-May-05 16:04 vrt_lss_packer-6.5.1990.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     5123 b- defN 23-May-05 16:04 vrt_lss_packer-6.5.1990.dist-info/RECORD
+55 files, 263463 bytes uncompressed, 65555 bytes compressed:  75.1%
```

## zipnote {}

```diff
@@ -6,17 +6,14 @@
 
 Filename: vrt_lss_packer/configuration.py
 Comment: 
 
 Filename: vrt_lss_packer/exceptions.py
 Comment: 
 
-Filename: vrt_lss_packer/model_utils.py
-Comment: 
-
 Filename: vrt_lss_packer/rest.py
 Comment: 
 
 Filename: vrt_lss_packer/api/__init__.py
 Comment: 
 
 Filename: vrt_lss_packer/api/convert_api.py
@@ -24,176 +21,146 @@
 
 Filename: vrt_lss_packer/api/pack_api.py
 Comment: 
 
 Filename: vrt_lss_packer/api/system_api.py
 Comment: 
 
-Filename: vrt_lss_packer/apis/__init__.py
-Comment: 
-
-Filename: vrt_lss_packer/model/__init__.py
-Comment: 
-
-Filename: vrt_lss_packer/model/attribute.py
-Comment: 
-
-Filename: vrt_lss_packer/model/attributes.py
-Comment: 
-
-Filename: vrt_lss_packer/model/blueprint.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_async_result.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_info.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_progress.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_settings.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_state.py
-Comment: 
-
-Filename: vrt_lss_packer/model/calculation_status.py
+Filename: vrt_lss_packer/models/__init__.py
 Comment: 
 
-Filename: vrt_lss_packer/model/check_result.py
+Filename: vrt_lss_packer/models/attribute.py
 Comment: 
 
-Filename: vrt_lss_packer/model/coordinates.py
+Filename: vrt_lss_packer/models/calculation_async_result.py
 Comment: 
 
-Filename: vrt_lss_packer/model/dimensions.py
+Filename: vrt_lss_packer/models/calculation_info.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_error.py
+Filename: vrt_lss_packer/models/calculation_settings.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_error_list.py
+Filename: vrt_lss_packer/models/calculation_state.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_error_type.py
+Filename: vrt_lss_packer/models/calculation_status.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_path.py
+Filename: vrt_lss_packer/models/check_result.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_type.py
+Filename: vrt_lss_packer/models/coordinates.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_warning.py
+Filename: vrt_lss_packer/models/custom400_with_errors_and_warnings.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_warning_list.py
+Filename: vrt_lss_packer/models/dimensions.py
 Comment: 
 
-Filename: vrt_lss_packer/model/entity_warning_type.py
+Filename: vrt_lss_packer/models/entity_error.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response400.py
+Filename: vrt_lss_packer/models/entity_error_type.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response401.py
+Filename: vrt_lss_packer/models/entity_path.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response402.py
+Filename: vrt_lss_packer/models/entity_type.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response403.py
+Filename: vrt_lss_packer/models/entity_warning.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response404.py
+Filename: vrt_lss_packer/models/entity_warning_type.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response404_detail.py
+Filename: vrt_lss_packer/models/general401.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response429.py
+Filename: vrt_lss_packer/models/general402.py
 Comment: 
 
-Filename: vrt_lss_packer/model/inline_response500.py
+Filename: vrt_lss_packer/models/general403.py
 Comment: 
 
-Filename: vrt_lss_packer/model/operation_id.py
+Filename: vrt_lss_packer/models/general404.py
 Comment: 
 
-Filename: vrt_lss_packer/model/pack_result.py
+Filename: vrt_lss_packer/models/general404_detail.py
 Comment: 
 
-Filename: vrt_lss_packer/model/pack_settings.py
+Filename: vrt_lss_packer/models/general429.py
 Comment: 
 
-Filename: vrt_lss_packer/model/pack_statistics.py
+Filename: vrt_lss_packer/models/general500.py
 Comment: 
 
-Filename: vrt_lss_packer/model/pack_task.py
+Filename: vrt_lss_packer/models/pack_result.py
 Comment: 
 
-Filename: vrt_lss_packer/model/package.py
+Filename: vrt_lss_packer/models/pack_settings.py
 Comment: 
 
-Filename: vrt_lss_packer/model/package_layout.py
+Filename: vrt_lss_packer/models/pack_statistics.py
 Comment: 
 
-Filename: vrt_lss_packer/model/package_statistics.py
+Filename: vrt_lss_packer/models/pack_task.py
 Comment: 
 
-Filename: vrt_lss_packer/model/package_type.py
+Filename: vrt_lss_packer/models/package.py
 Comment: 
 
-Filename: vrt_lss_packer/model/product.py
+Filename: vrt_lss_packer/models/package_layout.py
 Comment: 
 
-Filename: vrt_lss_packer/model/product_group_layout.py
+Filename: vrt_lss_packer/models/package_statistics.py
 Comment: 
 
-Filename: vrt_lss_packer/model/product_layout.py
+Filename: vrt_lss_packer/models/package_type.py
 Comment: 
 
-Filename: vrt_lss_packer/model/render_task.py
+Filename: vrt_lss_packer/models/product.py
 Comment: 
 
-Filename: vrt_lss_packer/model/schema_error.py
+Filename: vrt_lss_packer/models/product_group_layout.py
 Comment: 
 
-Filename: vrt_lss_packer/model/schema_error_list.py
+Filename: vrt_lss_packer/models/product_layout.py
 Comment: 
 
-Filename: vrt_lss_packer/model/service_name.py
+Filename: vrt_lss_packer/models/render_task.py
 Comment: 
 
-Filename: vrt_lss_packer/model/time_duration.py
+Filename: vrt_lss_packer/models/schema_error.py
 Comment: 
 
-Filename: vrt_lss_packer/model/tracedata.py
+Filename: vrt_lss_packer/models/service_name.py
 Comment: 
 
-Filename: vrt_lss_packer/model/unpacked_items.py
+Filename: vrt_lss_packer/models/tracedata.py
 Comment: 
 
-Filename: vrt_lss_packer/model/validate_result.py
+Filename: vrt_lss_packer/models/unpacked_items.py
 Comment: 
 
-Filename: vrt_lss_packer/model/version_result.py
+Filename: vrt_lss_packer/models/validate_result.py
 Comment: 
 
-Filename: vrt_lss_packer/models/__init__.py
+Filename: vrt_lss_packer/models/version_result.py
 Comment: 
 
-Filename: vrt_lss_packer-6.4.1962.dist-info/METADATA
+Filename: vrt_lss_packer-6.5.1990.dist-info/METADATA
 Comment: 
 
-Filename: vrt_lss_packer-6.4.1962.dist-info/WHEEL
+Filename: vrt_lss_packer-6.5.1990.dist-info/WHEEL
 Comment: 
 
-Filename: vrt_lss_packer-6.4.1962.dist-info/top_level.txt
+Filename: vrt_lss_packer-6.5.1990.dist-info/top_level.txt
 Comment: 
 
-Filename: vrt_lss_packer-6.4.1962.dist-info/RECORD
+Filename: vrt_lss_packer-6.5.1990.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## vrt_lss_packer/__init__.py

```diff
@@ -1,26 +1,75 @@
+# coding: utf-8
+
 # flake8: noqa
 
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
-__version__ = "6.4.1962"
+__version__ = "6.5.1990"
+
+# import apis into sdk package
+from vrt_lss_packer.api.convert_api import ConvertApi
+from vrt_lss_packer.api.pack_api import PackApi
+from vrt_lss_packer.api.system_api import SystemApi
 
 # import ApiClient
 from vrt_lss_packer.api_client import ApiClient
-
-# import Configuration
 from vrt_lss_packer.configuration import Configuration
-
-# import exceptions
 from vrt_lss_packer.exceptions import OpenApiException
-from vrt_lss_packer.exceptions import ApiAttributeError
 from vrt_lss_packer.exceptions import ApiTypeError
 from vrt_lss_packer.exceptions import ApiValueError
 from vrt_lss_packer.exceptions import ApiKeyError
+from vrt_lss_packer.exceptions import ApiAttributeError
 from vrt_lss_packer.exceptions import ApiException
+# import models into sdk package
+from vrt_lss_packer.models.attribute import Attribute
+from vrt_lss_packer.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_packer.models.calculation_info import CalculationInfo
+from vrt_lss_packer.models.calculation_settings import CalculationSettings
+from vrt_lss_packer.models.calculation_state import CalculationState
+from vrt_lss_packer.models.calculation_status import CalculationStatus
+from vrt_lss_packer.models.check_result import CheckResult
+from vrt_lss_packer.models.coordinates import Coordinates
+from vrt_lss_packer.models.custom400_with_errors_and_warnings import Custom400WithErrorsAndWarnings
+from vrt_lss_packer.models.dimensions import Dimensions
+from vrt_lss_packer.models.entity_error import EntityError
+from vrt_lss_packer.models.entity_error_type import EntityErrorType
+from vrt_lss_packer.models.entity_path import EntityPath
+from vrt_lss_packer.models.entity_type import EntityType
+from vrt_lss_packer.models.entity_warning import EntityWarning
+from vrt_lss_packer.models.entity_warning_type import EntityWarningType
+from vrt_lss_packer.models.general401 import General401
+from vrt_lss_packer.models.general402 import General402
+from vrt_lss_packer.models.general403 import General403
+from vrt_lss_packer.models.general404 import General404
+from vrt_lss_packer.models.general404_detail import General404Detail
+from vrt_lss_packer.models.general429 import General429
+from vrt_lss_packer.models.general500 import General500
+from vrt_lss_packer.models.pack_result import PackResult
+from vrt_lss_packer.models.pack_settings import PackSettings
+from vrt_lss_packer.models.pack_statistics import PackStatistics
+from vrt_lss_packer.models.pack_task import PackTask
+from vrt_lss_packer.models.package import Package
+from vrt_lss_packer.models.package_layout import PackageLayout
+from vrt_lss_packer.models.package_statistics import PackageStatistics
+from vrt_lss_packer.models.package_type import PackageType
+from vrt_lss_packer.models.product import Product
+from vrt_lss_packer.models.product_group_layout import ProductGroupLayout
+from vrt_lss_packer.models.product_layout import ProductLayout
+from vrt_lss_packer.models.render_task import RenderTask
+from vrt_lss_packer.models.schema_error import SchemaError
+from vrt_lss_packer.models.service_name import ServiceName
+from vrt_lss_packer.models.tracedata import Tracedata
+from vrt_lss_packer.models.unpacked_items import UnpackedItems
+from vrt_lss_packer.models.validate_result import ValidateResult
+from vrt_lss_packer.models.version_result import VersionResult
```

## vrt_lss_packer/api_client.py

```diff
@@ -1,84 +1,87 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
-import json
 import atexit
+import datetime
+from dateutil.parser import parse
+import json
 import mimetypes
 from multiprocessing.pool import ThreadPool
-import io
 import os
 import re
-import typing
-from urllib.parse import quote
-from urllib3.fields import RequestField
+import tempfile
 
+from urllib.parse import quote
 
-from vrt_lss_packer import rest
 from vrt_lss_packer.configuration import Configuration
-from vrt_lss_packer.exceptions import ApiTypeError, ApiValueError, ApiException
-from vrt_lss_packer.model_utils import (
-    ModelNormal,
-    ModelSimple,
-    ModelComposed,
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    deserialize_file,
-    file_type,
-    model_to_dict,
-    none_type,
-    validate_and_convert_types
-)
+import vrt_lss_packer.models
+from vrt_lss_packer import rest
+from vrt_lss_packer.exceptions import ApiValueError, ApiException
 
 
 class ApiClient(object):
     """Generic API client for OpenAPI client library builds.
 
     OpenAPI generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the OpenAPI
     templates.
 
-    NOTE: This class is auto generated by OpenAPI Generator.
-    Do not edit the class manually.
-
     :param configuration: .Configuration object for this client
     :param header_name: a header to pass when making calls to the API.
     :param header_value: a header value to pass when making calls to
         the API.
     :param cookie: a cookie to include in the header when making calls
         to the API
     :param pool_threads: The number of threads to use for async requests
         to the API. More threads means more concurrent API requests.
     """
 
+    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
+    NATIVE_TYPES_MAPPING = {
+        'int': int,
+        'long': int, # TODO remove as only py3 is supported?
+        'float': float,
+        'str': str,
+        'bool': bool,
+        'date': datetime.date,
+        'datetime': datetime.datetime,
+        'object': object,
+    }
     _pool = None
 
     def __init__(self, configuration=None, header_name=None, header_value=None,
                  cookie=None, pool_threads=1):
+        # use default configuration if none is provided
         if configuration is None:
-            configuration = Configuration.get_default_copy()
+            configuration = Configuration.get_default()
         self.configuration = configuration
         self.pool_threads = pool_threads
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'OpenAPI-Generator/6.4.1962/python'
+        self.user_agent = 'OpenAPI-Generator/6.5.1990/python'
+        self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
         self.close()
 
@@ -108,35 +111,48 @@
     @user_agent.setter
     def user_agent(self, value):
         self.default_headers['User-Agent'] = value
 
     def set_default_header(self, header_name, header_value):
         self.default_headers[header_name] = header_value
 
+
+    _default = None
+
+    @classmethod
+    def get_default(cls):
+        """Return new instance of ApiClient.
+
+        This method returns newly created, based on default constructor,
+        object of ApiClient class or returns a copy of default
+        ApiClient.
+
+        :return: The ApiClient object.
+        """
+        if cls._default is None:
+            cls._default = ApiClient()
+        return cls._default
+
+    @classmethod
+    def set_default(cls, default):
+        """Set default instance of ApiClient.
+
+        It stores default ApiClient.
+
+        :param default: object of ApiClient.
+        """
+        cls._default = default
+
     def __call_api(
-        self,
-        resource_path: str,
-        method: str,
-        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        body: typing.Optional[typing.Any] = None,
-        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,
-        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,
-        auth_settings: typing.Optional[typing.List[str]] = None,
-        _return_http_data_only: typing.Optional[bool] = None,
-        collection_formats: typing.Optional[typing.Dict[str, str]] = None,
-        _preload_content: bool = True,
-        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,
-        _host: typing.Optional[str] = None,
-        _check_type: typing.Optional[bool] = None,
-        _content_type: typing.Optional[str] = None,
-        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None
-    ):
+            self, resource_path, method, path_params=None,
+            query_params=None, header_params=None, body=None, post_params=None,
+            files=None, response_types_map=None, auth_settings=None,
+            _return_http_data_only=None, collection_formats=None,
+            _preload_content=True, _request_timeout=None, _host=None,
+            _request_auth=None):
 
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
@@ -154,338 +170,311 @@
             for k, v in path_params:
                 # specified safe chars, encode everything
                 resource_path = resource_path.replace(
                     '{%s}' % k,
                     quote(str(v), safe=config.safe_chars_for_path_param)
                 )
 
-        # query parameters
-        if query_params:
-            query_params = self.sanitize_for_serialization(query_params)
-            query_params = self.parameters_to_tuples(query_params,
-                                                     collection_formats)
-
         # post parameters
         if post_params or files:
             post_params = post_params if post_params else []
             post_params = self.sanitize_for_serialization(post_params)
             post_params = self.parameters_to_tuples(post_params,
                                                     collection_formats)
             post_params.extend(self.files_parameters(files))
-            if header_params['Content-Type'].startswith("multipart"):
-                post_params = self.parameters_to_multipart(post_params,
-                                                          (dict) )
+
+        # auth setting
+        self.update_params_for_auth(
+            header_params, query_params, auth_settings,
+            resource_path, method, body,
+            request_auth=_request_auth)
 
         # body
         if body:
             body = self.sanitize_for_serialization(body)
 
-        # auth setting
-        self.update_params_for_auth(header_params, query_params,
-                                    auth_settings, resource_path, method, body,
-                                    request_auths=_request_auths)
-
         # request url
         if _host is None:
             url = self.configuration.host + resource_path
         else:
             # use server/host defined in path or operation instead
             url = _host + resource_path
 
+        # query parameters
+        if query_params:
+            query_params = self.sanitize_for_serialization(query_params)
+            url_query = self.parameters_to_url_query(query_params,
+                                                     collection_formats)
+            url += "?" + url_query
+
         try:
             # perform request and return response
             response_data = self.request(
-                method, url, query_params=query_params, headers=header_params,
+                method, url,
+                query_params=query_params,
+                headers=header_params,
                 post_params=post_params, body=body,
                 _preload_content=_preload_content,
                 _request_timeout=_request_timeout)
         except ApiException as e:
-            e.body = e.body.decode('utf-8')
+            if e.body:
+                e.body = e.body.decode('utf-8')
             raise e
 
         self.last_response = response_data
 
         return_data = response_data
 
         if not _preload_content:
-            return (return_data)
             return return_data
 
+        response_type = response_types_map.get(str(response_data.status), None)
+
+        if response_type == "bytearray":
+            response_data.data = response_data.data
+        else:
+            match = None
+            content_type = response_data.getheader('content-type')
+            if content_type is not None:
+                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+            encoding = match.group(1) if match else "utf-8"
+            response_data.data = response_data.data.decode(encoding)
+
         # deserialize response data
-        if response_type:
-            if response_type != (file_type,):
-                encoding = "utf-8"
-                content_type = response_data.getheader('content-type')
-                if content_type is not None:
-                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s\;]?", content_type)
-                    if match:
-                        encoding = match.group(1)
-                response_data.data = response_data.data.decode(encoding)
-
-            return_data = self.deserialize(
-                response_data,
-                response_type,
-                _check_type
-            )
+        if response_type == "bytearray":
+            return_data = response_data.data
+        elif response_type:
+            return_data = self.deserialize(response_data, response_type)
         else:
             return_data = None
 
         if _return_http_data_only:
             return (return_data)
         else:
             return (return_data, response_data.status,
                     response_data.getheaders())
 
-    def parameters_to_multipart(self, params, collection_types):
-        """Get parameters as list of tuples, formatting as json if value is collection_types
-
-        :param params: Parameters as list of two-tuples
-        :param dict collection_types: Parameter collection types
-        :return: Parameters as list of tuple or urllib3.fields.RequestField
-        """
-        new_params = []
-        if collection_types is None:
-            collection_types = (dict)
-        for k, v in params.items() if isinstance(params, dict) else params:  
-            if isinstance(v, collection_types): # v is instance of collection_type, formatting as application/json
-                 v = json.dumps(v, ensure_ascii=False).encode("utf-8")
-                 field = RequestField(k, v)
-                 field.make_multipart(content_type="application/json; charset=utf-8")
-                 new_params.append(field)
-            else:
-                 new_params.append((k, v))
-        return new_params
+    def sanitize_for_serialization(self, obj):
+        """Builds a JSON POST object.
 
-    @classmethod
-    def sanitize_for_serialization(cls, obj):
-        """Prepares data for transmission before it is sent with the rest client
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
             convert to string in iso8601 format.
         If obj is list, sanitize each element in the list.
         If obj is dict, return the dict.
         If obj is OpenAPI model, return the properties dict.
-        If obj is io.IOBase, return the bytes
+
         :param obj: The data to serialize.
         :return: The serialized form of data.
         """
-        if isinstance(obj, (ModelNormal, ModelComposed)):
-            return {
-                key: cls.sanitize_for_serialization(val) for key, val in model_to_dict(obj, serialize=True).items()
-            }
-        elif isinstance(obj, io.IOBase):
-            return cls.get_file_data_and_close_file(obj)
-        elif isinstance(obj, (str, int, float, none_type, bool)):
+        if obj is None:
+            return None
+        elif isinstance(obj, self.PRIMITIVE_TYPES):
             return obj
-        elif isinstance(obj, (datetime, date)):
+        elif isinstance(obj, list):
+            return [self.sanitize_for_serialization(sub_obj)
+                    for sub_obj in obj]
+        elif isinstance(obj, tuple):
+            return tuple(self.sanitize_for_serialization(sub_obj)
+                         for sub_obj in obj)
+        elif isinstance(obj, (datetime.datetime, datetime.date)):
             return obj.isoformat()
-        elif isinstance(obj, ModelSimple):
-            return cls.sanitize_for_serialization(obj.value)
-        elif isinstance(obj, (list, tuple)):
-            return [cls.sanitize_for_serialization(item) for item in obj]
+
         if isinstance(obj, dict):
-            return {key: cls.sanitize_for_serialization(val) for key, val in obj.items()}
-        raise ApiValueError('Unable to prepare type {} for serialization'.format(obj.__class__.__name__))
+            obj_dict = obj
+        else:
+            # Convert model obj to dict except
+            # attributes `openapi_types`, `attribute_map`
+            # and attributes which value is not None.
+            # Convert attribute name to json key in
+            # model definition for request.
+            obj_dict = obj.to_dict()
+
+        return {key: self.sanitize_for_serialization(val)
+                for key, val in obj_dict.items()}
 
-    def deserialize(self, response, response_type, _check_type):
+    def deserialize(self, response, response_type):
         """Deserializes response into an object.
 
         :param response: RESTResponse object to be deserialized.
-        :param response_type: For the response, a tuple containing:
-            valid classes
-            a list containing valid classes (for list schemas)
-            a dict containing a tuple of valid classes as the value
-            Example values:
-            (str,)
-            (Pet,)
-            (float, none_type)
-            ([int, none_type],)
-            ({str: (bool, str, int, float, date, datetime, str, none_type)},)
-        :param _check_type: boolean, whether to check the types of the data
-            received from the server
-        :type _check_type: bool
+        :param response_type: class literal for
+            deserialized object, or string of class name.
 
         :return: deserialized object.
         """
         # handle file downloading
         # save response body into a tmp file and return the instance
-        if response_type == (file_type,):
-            content_disposition = response.getheader("Content-Disposition")
-            return deserialize_file(response.data, self.configuration,
-                                    content_disposition=content_disposition)
+        if response_type == "file":
+            return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            received_data = json.loads(response.data)
+            data = json.loads(response.data)
         except ValueError:
-            received_data = response.data
+            data = response.data
+
+        return self.__deserialize(data, response_type)
+
+    def __deserialize(self, data, klass):
+        """Deserializes dict, list, str into an object.
+
+        :param data: dict, list or str.
+        :param klass: class literal, or string of class name.
+
+        :return: object.
+        """
+        if data is None:
+            return None
+
+        if type(klass) == str:
+            if klass.startswith('List['):
+                sub_kls = re.match(r'List\[(.*)]', klass).group(1)
+                return [self.__deserialize(sub_data, sub_kls)
+                        for sub_data in data]
+
+            if klass.startswith('Dict['):
+                sub_kls = re.match(r'Dict\[([^,]*), (.*)]', klass).group(2)
+                return {k: self.__deserialize(v, sub_kls)
+                        for k, v in data.items()}
+
+            # convert str to class
+            if klass in self.NATIVE_TYPES_MAPPING:
+                klass = self.NATIVE_TYPES_MAPPING[klass]
+            else:
+                klass = getattr(vrt_lss_packer.models, klass)
 
-        # store our data under the key of 'received_data' so users have some
-        # context if they are deserializing a string and the data type is wrong
-        deserialized_data = validate_and_convert_types(
-            received_data,
-            response_type,
-            ['received_data'],
-            True,
-            _check_type,
-            configuration=self.configuration
-        )
-        return deserialized_data
-
-    def call_api(
-        self,
-        resource_path: str,
-        method: str,
-        path_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        query_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        header_params: typing.Optional[typing.Dict[str, typing.Any]] = None,
-        body: typing.Optional[typing.Any] = None,
-        post_params: typing.Optional[typing.List[typing.Tuple[str, typing.Any]]] = None,
-        files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None,
-        response_type: typing.Optional[typing.Tuple[typing.Any]] = None,
-        auth_settings: typing.Optional[typing.List[str]] = None,
-        async_req: typing.Optional[bool] = None,
-        _return_http_data_only: typing.Optional[bool] = None,
-        collection_formats: typing.Optional[typing.Dict[str, str]] = None,
-        _preload_content: bool = True,
-        _request_timeout: typing.Optional[typing.Union[int, float, typing.Tuple]] = None,
-        _host: typing.Optional[str] = None,
-        _check_type: typing.Optional[bool] = None,
-        _request_auths: typing.Optional[typing.List[typing.Dict[str, typing.Any]]] = None
-    ):
+        if klass in self.PRIMITIVE_TYPES:
+            return self.__deserialize_primitive(data, klass)
+        elif klass == object:
+            return self.__deserialize_object(data)
+        elif klass == datetime.date:
+            return self.__deserialize_date(data)
+        elif klass == datetime.datetime:
+            return self.__deserialize_datetime(data)
+        else:
+            return self.__deserialize_model(data, klass)
+
+    def call_api(self, resource_path, method,
+                 path_params=None, query_params=None, header_params=None,
+                 body=None, post_params=None, files=None,
+                 response_types_map=None, auth_settings=None,
+                 async_req=None, _return_http_data_only=None,
+                 collection_formats=None,_preload_content=True,
+                  _request_timeout=None, _host=None, _request_auth=None):
         """Makes the HTTP request (synchronous) and returns deserialized data.
 
         To make an async_req request, set the async_req parameter.
 
         :param resource_path: Path to method endpoint.
         :param method: Method to call.
         :param path_params: Path parameters in the url.
         :param query_params: Query parameters in the url.
         :param header_params: Header parameters to be
             placed in the request header.
         :param body: Request body.
         :param post_params dict: Request post form parameters,
             for `application/x-www-form-urlencoded`, `multipart/form-data`.
         :param auth_settings list: Auth Settings names for the request.
-        :param response_type: For the response, a tuple containing:
-            valid classes
-            a list containing valid classes (for list schemas)
-            a dict containing a tuple of valid classes as the value
-            Example values:
-            (str,)
-            (Pet,)
-            (float, none_type)
-            ([int, none_type],)
-            ({str: (bool, str, int, float, date, datetime, str, none_type)},)
-        :param files: key -> field name, value -> a list of open file
-            objects for `multipart/form-data`.
-        :type files: dict
+        :param response: Response data type.
+        :param files dict: key -> filename, value -> filepath,
+            for `multipart/form-data`.
         :param async_req bool: execute request asynchronously
-        :type async_req: bool, optional
         :param _return_http_data_only: response data without head status code
                                        and headers
-        :type _return_http_data_only: bool, optional
         :param collection_formats: dict of collection formats for path, query,
             header, and post parameters.
-        :type collection_formats: dict, optional
         :param _preload_content: if False, the urllib3.HTTPResponse object will
                                  be returned without reading/decoding response
                                  data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
-        :param _check_type: boolean describing if the data back from the server
-            should have its type checked.
-        :type _check_type: bool, optional
-        :param _request_auths: set to override the auth_settings for an a single
+        :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
-        :type _request_auths: list, optional
+        :type _request_token: dict, optional
         :return:
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
         if not async_req:
             return self.__call_api(resource_path, method,
                                    path_params, query_params, header_params,
                                    body, post_params, files,
-                                   response_type, auth_settings,
+                                   response_types_map, auth_settings,
                                    _return_http_data_only, collection_formats,
                                    _preload_content, _request_timeout, _host,
-                                   _check_type, _request_auths=_request_auths)
+                                   _request_auth)
 
         return self.pool.apply_async(self.__call_api, (resource_path,
                                                        method, path_params,
                                                        query_params,
                                                        header_params, body,
                                                        post_params, files,
-                                                       response_type,
+                                                       response_types_map,
                                                        auth_settings,
                                                        _return_http_data_only,
                                                        collection_formats,
                                                        _preload_content,
                                                        _request_timeout,
-                                                       _host, _check_type, None, _request_auths))
+                                                       _host, _request_auth))
 
     def request(self, method, url, query_params=None, headers=None,
                 post_params=None, body=None, _preload_content=True,
                 _request_timeout=None):
         """Makes the HTTP request using RESTClient."""
         if method == "GET":
-            return self.rest_client.GET(url,
+            return self.rest_client.get_request(url,
                                         query_params=query_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         headers=headers)
         elif method == "HEAD":
-            return self.rest_client.HEAD(url,
+            return self.rest_client.head_request(url,
                                          query_params=query_params,
                                          _preload_content=_preload_content,
                                          _request_timeout=_request_timeout,
                                          headers=headers)
         elif method == "OPTIONS":
-            return self.rest_client.OPTIONS(url,
+            return self.rest_client.options_request(url,
                                             query_params=query_params,
                                             headers=headers,
-                                            post_params=post_params,
                                             _preload_content=_preload_content,
-                                            _request_timeout=_request_timeout,
-                                            body=body)
+                                            _request_timeout=_request_timeout)
         elif method == "POST":
-            return self.rest_client.POST(url,
+            return self.rest_client.post_request(url,
                                          query_params=query_params,
                                          headers=headers,
                                          post_params=post_params,
                                          _preload_content=_preload_content,
                                          _request_timeout=_request_timeout,
                                          body=body)
         elif method == "PUT":
-            return self.rest_client.PUT(url,
+            return self.rest_client.put_request(url,
                                         query_params=query_params,
                                         headers=headers,
                                         post_params=post_params,
                                         _preload_content=_preload_content,
                                         _request_timeout=_request_timeout,
                                         body=body)
         elif method == "PATCH":
-            return self.rest_client.PATCH(url,
+            return self.rest_client.patch_request(url,
                                           query_params=query_params,
                                           headers=headers,
                                           post_params=post_params,
                                           _preload_content=_preload_content,
                                           _request_timeout=_request_timeout,
                                           body=body)
         elif method == "DELETE":
-            return self.rest_client.DELETE(url,
+            return self.rest_client.delete_request(url,
                                            query_params=query_params,
                                            headers=headers,
                                            _preload_content=_preload_content,
                                            _request_timeout=_request_timeout,
                                            body=body)
         else:
             raise ApiValueError(
@@ -499,15 +488,15 @@
         :param params: Parameters as dict or list of two-tuples
         :param dict collection_formats: Parameter collection formats
         :return: Parameters as list of tuples, collections formatted
         """
         new_params = []
         if collection_formats is None:
             collection_formats = {}
-        for k, v in params.items() if isinstance(params, dict) else params:  
+        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
             if k in collection_formats:
                 collection_format = collection_formats[k]
                 if collection_format == 'multi':
                     new_params.extend((k, value) for value in v)
                 else:
                     if collection_format == 'ssv':
                         delimiter = ' '
@@ -519,367 +508,247 @@
                         delimiter = ','
                     new_params.append(
                         (k, delimiter.join(str(value) for value in v)))
             else:
                 new_params.append((k, v))
         return new_params
 
-    @staticmethod
-    def get_file_data_and_close_file(file_instance: io.IOBase) -> bytes:
-        file_data = file_instance.read()
-        file_instance.close()
-        return file_data
+    def parameters_to_url_query(self, params, collection_formats):
+        """Get parameters as list of tuples, formatting collections.
+
+        :param params: Parameters as dict or list of two-tuples
+        :param dict collection_formats: Parameter collection formats
+        :return: URL query string (e.g. a=Hello%20World&b=123)
+        """
+        new_params = []
+        if collection_formats is None:
+            collection_formats = {}
+        for k, v in params.items() if isinstance(params, dict) else params:  # noqa: E501
+            if isinstance(v, (int, float)):
+                v = str(v)
+            if isinstance(v, bool):
+                v = str(v).lower()
+            if isinstance(v, dict):
+                v = json.dumps(v)
+
+            if k in collection_formats:
+                collection_format = collection_formats[k]
+                if collection_format == 'multi':
+                    new_params.extend((k, value) for value in v)
+                else:
+                    if collection_format == 'ssv':
+                        delimiter = ' '
+                    elif collection_format == 'tsv':
+                        delimiter = '\t'
+                    elif collection_format == 'pipes':
+                        delimiter = '|'
+                    else:  # csv is the default
+                        delimiter = ','
+                    new_params.append(
+                        (k, delimiter.join(quote(str(value)) for value in v)))
+            else:
+                new_params.append((k, quote(str(v))))
+
+        return "&".join(["=".join(item) for item in new_params])
 
-    def files_parameters(self, files: typing.Optional[typing.Dict[str, typing.List[io.IOBase]]] = None):
+    def files_parameters(self, files=None):
         """Builds form parameters.
 
-        :param files: None or a dict with key=param_name and
-            value is a list of open file objects
-        :return: List of tuples of form parameters with file data
+        :param files: File parameters.
+        :return: Form parameters with files.
         """
-        if files is None:
-            return []
-
         params = []
-        for param_name, file_instances in files.items():
-            if file_instances is None:
-                # if the file field is nullable, skip None values
-                continue
-            for file_instance in file_instances:
-                if file_instance is None:
-                    # if the file field is nullable, skip None values
+
+        if files:
+            for k, v in files.items():
+                if not v:
                     continue
-                if file_instance.closed is True:
-                    raise ApiValueError(
-                        "Cannot read a closed file. The passed in file_type "
-                        "for %s must be open." % param_name
-                    )
-                filename = os.path.basename(file_instance.name)
-                filedata = self.get_file_data_and_close_file(file_instance)
-                mimetype = (mimetypes.guess_type(filename)[0] or
-                            'application/octet-stream')
-                params.append(
-                    tuple([param_name, tuple([filename, filedata, mimetype])]))
+                file_names = v if type(v) is list else [v]
+                for n in file_names:
+                    with open(n, 'rb') as f:
+                        filename = os.path.basename(f.name)
+                        filedata = f.read()
+                        mimetype = (mimetypes.guess_type(filename)[0] or
+                                    'application/octet-stream')
+                        params.append(
+                            tuple([k, tuple([filename, filedata, mimetype])]))
 
         return params
 
     def select_header_accept(self, accepts):
         """Returns `Accept` based on an array of accepts provided.
 
         :param accepts: List of headers.
         :return: Accept (e.g. application/json).
         """
         if not accepts:
             return
 
-        accepts = [x.lower() for x in accepts]
+        for accept in accepts:
+            if re.search('json', accept, re.IGNORECASE):
+                return accept
 
-        if 'application/json' in accepts:
-            return 'application/json'
-        else:
-            return ', '.join(accepts)
+        return accepts[0]
 
-    def select_header_content_type(self, content_types, method=None, body=None):
+    def select_header_content_type(self, content_types):
         """Returns `Content-Type` based on an array of content_types provided.
 
         :param content_types: List of content-types.
-        :param method: http method (e.g. POST, PATCH).
-        :param body: http body to send.
         :return: Content-Type (e.g. application/json).
         """
         if not content_types:
             return None
 
-        content_types = [x.lower() for x in content_types]
+        for content_type in content_types:
+            if re.search('json', content_type, re.IGNORECASE):
+                return content_type
 
-        if (method == 'PATCH' and
-                'application/json-patch+json' in content_types and
-                isinstance(body, list)):
-            return 'application/json-patch+json'
-
-        if 'application/json' in content_types or '*/*' in content_types:
-            return 'application/json'
-        else:
-            return content_types[0]
+        return content_types[0]
 
     def update_params_for_auth(self, headers, queries, auth_settings,
-                               resource_path, method, body, request_auths=None):
+                               resource_path, method, body,
+                               request_auth=None):
         """Updates header and query params based on authentication setting.
 
         :param headers: Header parameters dict to be updated.
         :param queries: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
-        :param resource_path: A string representation of the HTTP request resource path.
-        :param method: A string representation of the HTTP request method.
-        :param body: A object representing the body of the HTTP request.
-            The object type is the return value of _encoder.default().
-        :param request_auths: if set, the provided settings will
-            override the token in the configuration.
+        :resource_path: A string representation of the HTTP request resource path.
+        :method: A string representation of the HTTP request method.
+        :body: A object representing the body of the HTTP request.
+        The object type is the return value of sanitize_for_serialization().
+        :param request_auth: if set, the provided settings will
+                             override the token in the configuration.
         """
         if not auth_settings:
             return
 
-        if request_auths:
-            for auth_setting in request_auths:
-                self._apply_auth_params(headers, queries, resource_path, method, body, auth_setting)
+        if request_auth:
+            self._apply_auth_params(headers, queries,
+                                    resource_path, method, body,
+                                    request_auth)
             return
 
         for auth in auth_settings:
             auth_setting = self.configuration.auth_settings().get(auth)
             if auth_setting:
-                self._apply_auth_params(headers, queries, resource_path, method, body, auth_setting)
+                self._apply_auth_params(headers, queries,
+                                        resource_path, method, body,
+                                        auth_setting)
+
+    def _apply_auth_params(self, headers, queries,
+                           resource_path, method, body,
+                           auth_setting):
+        """Updates the request parameters based on a single auth_setting
 
-    def _apply_auth_params(self, headers, queries, resource_path, method, body, auth_setting):
+        :param headers: Header parameters dict to be updated.
+        :param queries: Query parameters tuple list to be updated.
+        :resource_path: A string representation of the HTTP request resource path.
+        :method: A string representation of the HTTP request method.
+        :body: A object representing the body of the HTTP request.
+        The object type is the return value of sanitize_for_serialization().
+        :param auth_setting: auth settings for the endpoint
+        """
         if auth_setting['in'] == 'cookie':
             headers['Cookie'] = auth_setting['value']
         elif auth_setting['in'] == 'header':
             if auth_setting['type'] != 'http-signature':
                 headers[auth_setting['key']] = auth_setting['value']
         elif auth_setting['in'] == 'query':
             queries.append((auth_setting['key'], auth_setting['value']))
         else:
             raise ApiValueError(
                 'Authentication token must be in `query` or `header`'
             )
 
+    def __deserialize_file(self, response):
+        """Deserializes body to file
 
-class Endpoint(object):
-    def __init__(self, settings=None, params_map=None, root_map=None,
-                 headers_map=None, api_client=None, callable=None):
-        """Creates an endpoint
-
-        Args:
-            settings (dict): see below key value pairs
-                'response_type' (tuple/None): response type
-                'auth' (list): a list of auth type keys
-                'endpoint_path' (str): the endpoint path
-                'operation_id' (str): endpoint string identifier
-                'http_method' (str): POST/PUT/PATCH/GET etc
-                'servers' (list): list of str servers that this endpoint is at
-            params_map (dict): see below key value pairs
-                'all' (list): list of str endpoint parameter names
-                'required' (list): list of required parameter names
-                'nullable' (list): list of nullable parameter names
-                'enum' (list): list of parameters with enum values
-                'validation' (list): list of parameters with validations
-            root_map
-                'validations' (dict): the dict mapping endpoint parameter tuple
-                    paths to their validation dictionaries
-                'allowed_values' (dict): the dict mapping endpoint parameter
-                    tuple paths to their allowed_values (enum) dictionaries
-                'openapi_types' (dict): param_name to openapi type
-                'attribute_map' (dict): param_name to camelCase name
-                'location_map' (dict): param_name to  'body', 'file', 'form',
-                    'header', 'path', 'query'
-                collection_format_map (dict): param_name to `csv` etc.
-            headers_map (dict): see below key value pairs
-                'accept' (list): list of Accept header strings
-                'content_type' (list): list of Content-Type header strings
-            api_client (ApiClient) api client instance
-            callable (function): the function which is invoked when the
-                Endpoint is called
-        """
-        self.settings = settings
-        self.params_map = params_map
-        self.params_map['all'].extend([
-            'async_req',
-            '_host_index',
-            '_preload_content',
-            '_request_timeout',
-            '_return_http_data_only',
-            '_check_input_type',
-            '_check_return_type',
-            '_content_type',
-            '_spec_property_naming',
-            '_request_auths'
-        ])
-        self.params_map['nullable'].extend(['_request_timeout'])
-        self.validations = root_map['validations']
-        self.allowed_values = root_map['allowed_values']
-        self.openapi_types = root_map['openapi_types']
-        extra_types = {
-            'async_req': (bool,),
-            '_host_index': (none_type, int),
-            '_preload_content': (bool,),
-            '_request_timeout': (none_type, float, (float,), [float], int, (int,), [int]),
-            '_return_http_data_only': (bool,),
-            '_check_input_type': (bool,),
-            '_check_return_type': (bool,),
-            '_spec_property_naming': (bool,),
-            '_content_type': (none_type, str),
-            '_request_auths': (none_type, list)
-        }
-        self.openapi_types.update(extra_types)
-        self.attribute_map = root_map['attribute_map']
-        self.location_map = root_map['location_map']
-        self.collection_format_map = root_map['collection_format_map']
-        self.headers_map = headers_map
-        self.api_client = api_client
-        self.callable = callable
-
-    def __validate_inputs(self, kwargs):
-        for param in self.params_map['enum']:
-            if param in kwargs:
-                check_allowed_values(
-                    self.allowed_values,
-                    (param,),
-                    kwargs[param]
-                )
+        Saves response body into a file in a temporary folder,
+        using the filename from the `Content-Disposition` header if provided.
 
-        for param in self.params_map['validation']:
-            if param in kwargs:
-                check_validations(
-                    self.validations,
-                    (param,),
-                    kwargs[param],
-                    configuration=self.api_client.configuration
-                )
+        :param response:  RESTResponse.
+        :return: file path.
+        """
+        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
+        os.close(fd)
+        os.remove(path)
 
-        if kwargs['_check_input_type'] is False:
-            return
+        content_disposition = response.getheader("Content-Disposition")
+        if content_disposition:
+            filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
+                                 content_disposition).group(1)
+            path = os.path.join(os.path.dirname(path), filename)
 
-        for key, value in kwargs.items():
-            fixed_val = validate_and_convert_types(
-                value,
-                self.openapi_types[key],
-                [key],
-                kwargs['_spec_property_naming'],
-                kwargs['_check_input_type'],
-                configuration=self.api_client.configuration
-            )
-            kwargs[key] = fixed_val
+        with open(path, "wb") as f:
+            f.write(response.data)
 
-    def __gather_params(self, kwargs):
-        params = {
-            'body': None,
-            'collection_format': {},
-            'file': {},
-            'form': [],
-            'header': {},
-            'path': {},
-            'query': []
-        }
-
-        for param_name, param_value in kwargs.items():
-            param_location = self.location_map.get(param_name)
-            if param_location is None:
-                continue
-            if param_location:
-                if param_location == 'body':
-                    params['body'] = param_value
-                    continue
-                base_name = self.attribute_map[param_name]
-                if (param_location == 'form' and
-                        self.openapi_types[param_name] == (file_type,)):
-                    params['file'][base_name] = [param_value]
-                elif (param_location == 'form' and
-                        self.openapi_types[param_name] == ([file_type],)):
-                    # param_value is already a list
-                    params['file'][base_name] = param_value
-                elif param_location in {'form', 'query'}:
-                    param_value_full = (base_name, param_value)
-                    params[param_location].append(param_value_full)
-                if param_location not in {'form', 'query'}:
-                    params[param_location][base_name] = param_value
-                collection_format = self.collection_format_map.get(param_name)
-                if collection_format:
-                    params['collection_format'][base_name] = collection_format
+        return path
 
-        return params
+    def __deserialize_primitive(self, data, klass):
+        """Deserializes string to primitive type.
 
-    def __call__(self, *args, **kwargs):
-        """ This method is invoked when endpoints are called
-        Example:
+        :param data: str.
+        :param klass: class literal.
+
+        :return: int, long, float, str, bool.
+        """
+        try:
+            return klass(data)
+        except UnicodeEncodeError:
+            return str(data)
+        except TypeError:
+            return data
 
-        api_instance = ConvertApi()
-        api_instance.run_convert_to_gltf  # this is an instance of the class Endpoint
-        api_instance.run_convert_to_gltf()  # this invokes api_instance.run_convert_to_gltf.__call__()
-        which then invokes the callable functions stored in that endpoint at
-        api_instance.run_convert_to_gltf.callable or self.callable in this class
+    def __deserialize_object(self, value):
+        """Return an original value.
 
+        :return: object.
         """
-        return self.callable(self, *args, **kwargs)
+        return value
 
-    def call_with_http_info(self, **kwargs):
+    def __deserialize_date(self, string):
+        """Deserializes string to date.
 
+        :param string: str.
+        :return: date.
+        """
         try:
-            index = self.api_client.configuration.server_operation_index.get(
-                self.settings['operation_id'], self.api_client.configuration.server_index
-            ) if kwargs['_host_index'] is None else kwargs['_host_index']
-            server_variables = self.api_client.configuration.server_operation_variables.get(
-                self.settings['operation_id'], self.api_client.configuration.server_variables
-            )
-            _host = self.api_client.configuration.get_host_from_settings(
-                index, variables=server_variables, servers=self.settings['servers']
+            return parse(string).date()
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason="Failed to parse `{0}` as date object".format(string)
             )
-        except IndexError:
-            if self.settings['servers']:
-                raise ApiValueError(
-                    "Invalid host index. Must be 0 <= index < %s" %
-                    len(self.settings['servers'])
-                )
-            _host = None
 
-        for key, value in kwargs.items():
-            if key not in self.params_map['all']:
-                raise ApiTypeError(
-                    "Got an unexpected parameter '%s'"
-                    " to method `%s`" %
-                    (key, self.settings['operation_id'])
-                )
-            # only throw this nullable ApiValueError if _check_input_type
-            # is False, if _check_input_type==True we catch this case
-            # in self.__validate_inputs
-            if (key not in self.params_map['nullable'] and value is None
-                    and kwargs['_check_input_type'] is False):
-                raise ApiValueError(
-                    "Value may not be None for non-nullable parameter `%s`"
-                    " when calling `%s`" %
-                    (key, self.settings['operation_id'])
-                )
+    def __deserialize_datetime(self, string):
+        """Deserializes string to datetime.
 
-        for key in self.params_map['required']:
-            if key not in kwargs.keys():
-                raise ApiValueError(
-                    "Missing the required parameter `%s` when calling "
-                    "`%s`" % (key, self.settings['operation_id'])
-                )
+        The string should be in iso8601 datetime format.
 
-        self.__validate_inputs(kwargs)
+        :param string: str.
+        :return: datetime.
+        """
+        try:
+            return parse(string)
+        except ImportError:
+            return string
+        except ValueError:
+            raise rest.ApiException(
+                status=0,
+                reason=(
+                    "Failed to parse `{0}` as datetime object"
+                    .format(string)
+                )
+            )
 
-        params = self.__gather_params(kwargs)
+    def __deserialize_model(self, data, klass):
+        """Deserializes list or dict to model.
 
-        accept_headers_list = self.headers_map['accept']
-        if accept_headers_list:
-            params['header']['Accept'] = self.api_client.select_header_accept(
-                accept_headers_list)
+        :param data: dict, list.
+        :param klass: class literal.
+        :return: model object.
+        """
 
-        if kwargs.get('_content_type'):
-            params['header']['Content-Type'] = kwargs['_content_type']
-        else:
-            content_type_headers_list = self.headers_map['content_type']
-            if content_type_headers_list:
-                if params['body'] != "":
-                    content_types_list = self.api_client.select_header_content_type(
-                        content_type_headers_list, self.settings['http_method'],
-                        params['body'])
-                    if content_types_list:
-                        params['header']['Content-Type'] = content_types_list
-
-        return self.api_client.call_api(
-            self.settings['endpoint_path'], self.settings['http_method'],
-            params['path'],
-            params['query'],
-            params['header'],
-            body=params['body'],
-            post_params=params['form'],
-            files=params['file'],
-            response_type=self.settings['response_type'],
-            auth_settings=self.settings['auth'],
-            async_req=kwargs['async_req'],
-            _check_type=kwargs['_check_return_type'],
-            _return_http_data_only=kwargs['_return_http_data_only'],
-            _preload_content=kwargs['_preload_content'],
-            _request_timeout=kwargs['_request_timeout'],
-            _host=_host,
-            _request_auths=kwargs['_request_auths'],
-            collection_formats=params['collection_format'])
+        return klass.from_dict(data)
```

## vrt_lss_packer/configuration.py

```diff
@@ -1,94 +1,72 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import copy
 import logging
 import multiprocessing
 import sys
 import urllib3
 
-from http import client as http_client
+import http.client as httplib
 from vrt_lss_packer.exceptions import ApiValueError
 
-
 JSON_SCHEMA_VALIDATION_KEYWORDS = {
     'multipleOf', 'maximum', 'exclusiveMaximum',
     'minimum', 'exclusiveMinimum', 'maxLength',
     'minLength', 'pattern', 'maxItems', 'minItems'
 }
 
 class Configuration(object):
-    """NOTE: This class is auto generated by OpenAPI Generator
-
-    Do not edit the class manually.
+    """This class contains various settings of the API client.
 
-    :param host: Base url
+    :param host: Base url.
     :param api_key: Dict to store API key(s).
       Each entry in the dict specifies an API key.
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is the API key secret.
-    :param api_key_prefix: Dict to store API prefix (e.g. Bearer)
+    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
       The dict key is the name of the security scheme in the OAS specification.
       The dict value is an API key prefix when generating the auth data.
-    :param username: Username for HTTP basic authentication
-    :param password: Password for HTTP basic authentication
-    :param discard_unknown_keys: Boolean value indicating whether to discard
-      unknown properties. A server may send a response that includes additional
-      properties that are not known by the client in the following scenarios:
-      1. The OpenAPI document is incomplete, i.e. it does not match the server
-         implementation.
-      2. The client was generated using an older version of the OpenAPI document
-         and the server has been upgraded since then.
-      If a schema in the OpenAPI document defines the additionalProperties attribute,
-      then all undeclared properties received by the server are injected into the
-      additional properties map. In that case, there are undeclared properties, and
-      nothing to discard.
-    :param disabled_client_side_validations (string): Comma-separated list of
-      JSON schema validation keywords to disable JSON schema structural validation
-      rules. The following keywords may be specified: multipleOf, maximum,
-      exclusiveMaximum, minimum, exclusiveMinimum, maxLength, minLength, pattern,
-      maxItems, minItems.
-      By default, the validation is performed for data generated locally by the client
-      and data received from the server, independent of any validation performed by
-      the server side. If the input data does not satisfy the JSON schema validation
-      rules specified in the OpenAPI document, an exception is raised.
-      If disabled_client_side_validations is set, structural validation is
-      disabled. This can be useful to troubleshoot data validation problem, such as
-      when the OpenAPI document validation rules do not match the actual API data
-      received by the server.
+    :param username: Username for HTTP basic authentication.
+    :param password: Password for HTTP basic authentication.
+    :param access_token: Access token.
     :param server_index: Index to servers configuration.
     :param server_variables: Mapping with string values to replace variables in
       templated server configuration. The validation of enums is performed for
       variables with defined enum values before.
     :param server_operation_index: Mapping from operation ID to an index to server
       configuration.
     :param server_operation_variables: Mapping from operation ID to a mapping with
       string values to replace variables in templated server configuration.
       The validation of enums is performed for variables with defined enum values before.
     :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
-      in PEM format
+      in PEM format.
 
     :Example:
     """
 
     _default = None
 
     def __init__(self, host=None,
                  api_key=None, api_key_prefix=None,
-                 access_token=None,
                  username=None, password=None,
-                 discard_unknown_keys=False,
-                 disabled_client_side_validations="",
+                 access_token=None,
                  server_index=None, server_variables=None,
                  server_operation_index=None, server_operation_variables=None,
                  ssl_ca_cert=None,
                  ):
         """Constructor
         """
         self._base_path = "https://api.edge.veeroute.tech" if host is None else host
@@ -102,15 +80,14 @@
         self.server_operation_variables = server_operation_variables or {}
         """Default server variables
         """
         self.temp_folder_path = None
         """Temp file folder for downloading files
         """
         # Authentication Settings
-        self.access_token = access_token
         self.api_key = {}
         if api_key:
             self.api_key = api_key
         """dict to store API key(s)
         """
         self.api_key_prefix = {}
         if api_key_prefix:
@@ -122,16 +99,17 @@
         """
         self.username = username
         """Username for HTTP basic authentication
         """
         self.password = password
         """Password for HTTP basic authentication
         """
-        self.discard_unknown_keys = discard_unknown_keys
-        self.disabled_client_side_validations = disabled_client_side_validations
+        self.access_token = access_token
+        """Access token
+        """
         self.logger = {}
         """Logging Settings
         """
         self.logger["package_logger"] = logging.getLogger("vrt_lss_packer")
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         """Log format
@@ -174,31 +152,37 @@
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
         """
 
         self.proxy = None
         """Proxy URL
         """
-        self.no_proxy = None
-        """bypass proxy for host in the no_proxy list.
-        """
         self.proxy_headers = None
         """Proxy headers
         """
         self.safe_chars_for_path_param = ''
         """Safe chars for path_param
         """
         self.retries = None
         """Adding retries to override urllib3 default value 3
         """
         # Enable client side validation
         self.client_side_validation = True
 
-        # Options to pass down to the underlying urllib3 socket
         self.socket_options = None
+        """Options to pass down to the underlying urllib3 socket
+        """
+
+        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
+        """datetime format
+        """
+
+        self.date_format = "%Y-%m-%d"
+        """date format
+        """
 
     def __deepcopy__(self, memo):
         cls = self.__class__
         result = cls.__new__(cls)
         memo[id(self)] = result
         for k, v in self.__dict__.items():
             if k not in ('logger', 'logger_file_handler'):
@@ -208,46 +192,49 @@
         # use setters to configure loggers
         result.logger_file = self.logger_file
         result.debug = self.debug
         return result
 
     def __setattr__(self, name, value):
         object.__setattr__(self, name, value)
-        if name == 'disabled_client_side_validations':
-            s = set(filter(None, value.split(',')))
-            for v in s:
-                if v not in JSON_SCHEMA_VALIDATION_KEYWORDS:
-                    raise ApiValueError(
-                        "Invalid keyword: '{0}''".format(v))
-            self._disabled_client_side_validations = s
 
     @classmethod
     def set_default(cls, default):
         """Set default instance of configuration.
 
         It stores default configuration, which can be
         returned by get_default_copy method.
 
         :param default: object of Configuration
         """
-        cls._default = copy.deepcopy(default)
+        cls._default = default
 
     @classmethod
     def get_default_copy(cls):
-        """Return new instance of configuration.
+        """Deprecated. Please use `get_default` instead.
+
+        Deprecated. Please use `get_default` instead.
+
+        :return: The configuration object.
+        """
+        return cls.get_default()
+
+    @classmethod
+    def get_default(cls):
+        """Return the default configuration.
 
         This method returns newly created, based on default constructor,
         object of Configuration class or returns a copy of default
-        configuration passed by the set_default method.
+        configuration.
 
         :return: The configuration object.
         """
-        if cls._default is not None:
-            return copy.deepcopy(cls._default)
-        return Configuration()
+        if cls._default is None:
+            cls._default = Configuration()
+        return cls._default
 
     @property
     def logger_file(self):
         """The logger file.
 
         If the logger_file is None, then add stream handler and remove file
         handler. Otherwise, add file handler and remove stream handler.
@@ -293,23 +280,23 @@
         :type: bool
         """
         self.__debug = value
         if self.__debug:
             # if debug status is True, turn on debug logging
             for _, logger in self.logger.items():
                 logger.setLevel(logging.DEBUG)
-            # turn on http_client debug
-            http_client.HTTPConnection.debuglevel = 1
+            # turn on httplib debug
+            httplib.HTTPConnection.debuglevel = 1
         else:
             # if debug status is False, turn off debug logging,
             # setting log level to default `logging.WARNING`
             for _, logger in self.logger.items():
                 logger.setLevel(logging.WARNING)
-            # turn off http_client debug
-            http_client.HTTPConnection.debuglevel = 0
+            # turn off httplib debug
+            httplib.HTTPConnection.debuglevel = 0
 
     @property
     def logger_format(self):
         """The logger format.
 
         The logger_formatter will be updated when sets logger_format.
 
@@ -382,16 +369,16 @@
         """Gets the essential information for debugging.
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
-               "Version of the API: 6.4.1962\n"\
-               "SDK Package Version: 6.4.1962".\
+               "Version of the API: 6.5.1990\n"\
+               "SDK Package Version: 6.5.1990".\
                format(env=sys.platform, pyversion=sys.version)
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

## vrt_lss_packer/exceptions.py

```diff
@@ -1,15 +1,20 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
-"""
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
 
+    Do not edit the code manually
+
+    2023 Veeroute
+"""
 
 
 class OpenApiException(Exception):
     """The base exception class for all OpenAPIExceptions"""
 
 
 class ApiTypeError(OpenApiException, TypeError):
@@ -107,15 +112,15 @@
             self.status = status
             self.reason = reason
             self.body = None
             self.headers = None
 
     def __str__(self):
         """Custom error messages for exception"""
-        error_message = "Status Code: {0}\n"\
+        error_message = "({0})\n"\
                         "Reason: {1}\n".format(self.status, self.reason)
         if self.headers:
             error_message += "HTTP response headers: {0}\n".format(
                 self.headers)
 
         if self.body:
             error_message += "HTTP response body: {0}\n".format(self.body)
```

## vrt_lss_packer/rest.py

```diff
@@ -1,26 +1,30 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import io
 import json
 import logging
 import re
 import ssl
-from urllib.parse import urlencode
-from urllib.parse import urlparse
-from urllib.request import proxy_bypass_environment
+
+from urllib.parse import urlencode, quote_plus
 import urllib3
-import ipaddress
 
 from vrt_lss_packer.exceptions import ApiException, UnauthorizedException, ForbiddenException, NotFoundException, ServiceException, ApiValueError
 
 
 logger = logging.getLogger(__name__)
 
 
@@ -30,54 +34,54 @@
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
         self.data = resp.data
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
-        return self.urllib3_response.getheaders()
+        return self.urllib3_response.headers
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
-        return self.urllib3_response.getheader(name, default)
+        return self.urllib3_response.headers.get(name, default)
 
 
 class RESTClientObject(object):
 
     def __init__(self, configuration, pools_size=4, maxsize=None):
         # urllib3.PoolManager will pass all kw parameters to connectionpool
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  
-        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  
-        # maxsize is the number of requests to host that are allowed in parallel  
-        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
+        # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/connectionpool.py#L680  # noqa: E501
+        # maxsize is the number of requests to host that are allowed in parallel  # noqa: E501
+        # Custom SSL certificates and client certificates: http://urllib3.readthedocs.io/en/latest/advanced-usage.html  # noqa: E501
 
         # cert_reqs
         if configuration.verify_ssl:
             cert_reqs = ssl.CERT_REQUIRED
         else:
             cert_reqs = ssl.CERT_NONE
 
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
-            addition_pool_args['assert_hostname'] = configuration.assert_hostname  
+            addition_pool_args['assert_hostname'] = configuration.assert_hostname  # noqa: E501
 
         if configuration.retries is not None:
             addition_pool_args['retries'] = configuration.retries
 
         if configuration.socket_options is not None:
             addition_pool_args['socket_options'] = configuration.socket_options
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
                 maxsize = 4
 
         # https pool manager
-        if configuration.proxy and not should_bypass_proxies(configuration.host, no_proxy=configuration.no_proxy or ''):
+        if configuration.proxy:
             self.pool_manager = urllib3.ProxyManager(
                 num_pools=pools_size,
                 maxsize=maxsize,
                 cert_reqs=cert_reqs,
                 ca_certs=configuration.ssl_ca_cert,
                 cert_file=configuration.cert_file,
                 key_file=configuration.key_file,
@@ -124,43 +128,43 @@
         if post_params and body:
             raise ApiValueError(
                 "body parameter cannot be used with post_params parameter."
             )
 
         post_params = post_params or {}
         headers = headers or {}
+        # url already contains the URL query string
+        # so reset query_params to empty dict
+        query_params = {}
 
         timeout = None
         if _request_timeout:
-            if isinstance(_request_timeout, (int, float)):
+            if isinstance(_request_timeout, (int,float)):  # noqa: E501,F821
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif (isinstance(_request_timeout, tuple) and
                   len(_request_timeout) == 2):
                 timeout = urllib3.Timeout(
                     connect=_request_timeout[0], read=_request_timeout[1])
 
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
             if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
-                # Only set a default Content-Type for POST, PUT, PATCH and OPTIONS requests
-                if (method != 'DELETE') and ('Content-Type' not in headers):
-                    headers['Content-Type'] = 'application/json'
-                if query_params:
-                    url += '?' + urlencode(query_params)
-                if ('Content-Type' not in headers) or (re.search('json', headers['Content-Type'], re.IGNORECASE)):
+
+                # no content type provided or payload is json
+                if not headers.get('Content-Type') or re.search('json', headers['Content-Type'], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
                         method, url,
                         body=request_body,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
-                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  
+                elif headers['Content-Type'] == 'application/x-www-form-urlencoded':  # noqa: E501
                     r = self.pool_manager.request(
                         method, url,
                         fields=post_params,
                         encode_multipart=False,
                         preload_content=_preload_content,
                         timeout=timeout,
                         headers=headers)
@@ -192,15 +196,15 @@
                     msg = """Cannot prepare a request message for provided
                              arguments. Please check that your arguments match
                              declared content type."""
                     raise ApiException(status=0, reason=msg)
             # For `GET`, `HEAD`
             else:
                 r = self.pool_manager.request(method, url,
-                                              fields=query_params,
+                                              fields={},
                                               preload_content=_preload_content,
                                               timeout=timeout,
                                               headers=headers)
         except urllib3.exceptions.SSLError as e:
             msg = "{0}\n{1}".format(type(e).__name__, str(e))
             raise ApiException(status=0, reason=msg)
 
@@ -223,123 +227,71 @@
             if 500 <= r.status <= 599:
                 raise ServiceException(http_resp=r)
 
             raise ApiException(http_resp=r)
 
         return r
 
-    def GET(self, url, headers=None, query_params=None, _preload_content=True,
+    def get_request(self, url, headers=None, query_params=None, _preload_content=True,
             _request_timeout=None):
         return self.request("GET", url,
                             headers=headers,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             query_params=query_params)
 
-    def HEAD(self, url, headers=None, query_params=None, _preload_content=True,
+    def head_request(self, url, headers=None, query_params=None, _preload_content=True,
              _request_timeout=None):
         return self.request("HEAD", url,
                             headers=headers,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             query_params=query_params)
 
-    def OPTIONS(self, url, headers=None, query_params=None, post_params=None,
+    def options_request(self, url, headers=None, query_params=None, post_params=None,
                 body=None, _preload_content=True, _request_timeout=None):
         return self.request("OPTIONS", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def DELETE(self, url, headers=None, query_params=None, body=None,
+    def delete_request(self, url, headers=None, query_params=None, body=None,
                _preload_content=True, _request_timeout=None):
         return self.request("DELETE", url,
                             headers=headers,
                             query_params=query_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def POST(self, url, headers=None, query_params=None, post_params=None,
+    def post_request(self, url, headers=None, query_params=None, post_params=None,
              body=None, _preload_content=True, _request_timeout=None):
         return self.request("POST", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def PUT(self, url, headers=None, query_params=None, post_params=None,
+    def put_request(self, url, headers=None, query_params=None, post_params=None,
             body=None, _preload_content=True, _request_timeout=None):
         return self.request("PUT", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
 
-    def PATCH(self, url, headers=None, query_params=None, post_params=None,
+    def patch_request(self, url, headers=None, query_params=None, post_params=None,
               body=None, _preload_content=True, _request_timeout=None):
         return self.request("PATCH", url,
                             headers=headers,
                             query_params=query_params,
                             post_params=post_params,
                             _preload_content=_preload_content,
                             _request_timeout=_request_timeout,
                             body=body)
-
-# end of class RESTClientObject
-def is_ipv4(target):
-    """ Test if IPv4 address or not
-    """
-    try:
-       chk = ipaddress.IPv4Address(target)
-       return True
-    except ipaddress.AddressValueError:
-       return False
-
-def in_ipv4net(target, net):
-    """ Test if target belongs to given IPv4 network
-    """
-    try:
-        nw = ipaddress.IPv4Network(net)
-        ip = ipaddress.IPv4Address(target)
-        if ip in nw:
-            return True
-        return False
-    except ipaddress.AddressValueError:
-        return False
-    except ipaddress.NetmaskValueError:
-        return False
-
-def should_bypass_proxies(url, no_proxy=None):
-    """ Yet another requests.should_bypass_proxies
-    Test if proxies should not be used for a particular url.
-    """
-
-    parsed = urlparse(url)
-
-    # special cases
-    if parsed.hostname in [None, '']:
-        return True
-
-    # special cases
-    if no_proxy in [None , '']:
-        return False
-    if no_proxy == '*':
-        return True
-
-    no_proxy = no_proxy.lower().replace(' ','');
-    entries = (
-        host for host in no_proxy.split(',') if host
-    )
-
-    if is_ipv4(parsed.hostname):
-        for item in entries:
-           if in_ipv4net(parsed.hostname, item):
-               return True
-    return proxy_bypass_environment(parsed.hostname, {'no': no_proxy} )
```

## vrt_lss_packer/api/__init__.py

```diff
@@ -1,3 +1,7 @@
-# do not import all apis into this module because that uses a lot of memory and stack frames
-# if you need the ability to import all apis from one package, import them with
-# from vrt_lss_packer.apis import ConvertApi
+# flake8: noqa
+
+# import apis into api package
+from vrt_lss_packer.api.convert_api import ConvertApi
+from vrt_lss_packer.api.pack_api import PackApi
+from vrt_lss_packer.api.system_api import SystemApi
+
```

## vrt_lss_packer/api/convert_api.py

```diff
@@ -1,178 +1,201 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_packer.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_packer.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field
+
+from vrt_lss_packer.models.render_task import RenderTask
+
+from vrt_lss_packer.api_client import ApiClient
+from vrt_lss_packer.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_packer.model.inline_response400 import InlineResponse400
-from vrt_lss_packer.model.inline_response401 import InlineResponse401
-from vrt_lss_packer.model.inline_response402 import InlineResponse402
-from vrt_lss_packer.model.inline_response403 import InlineResponse403
-from vrt_lss_packer.model.inline_response429 import InlineResponse429
-from vrt_lss_packer.model.inline_response500 import InlineResponse500
-from vrt_lss_packer.model.render_task import RenderTask
 
 
 class ConvertApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.run_convert_to_gltf_endpoint = _Endpoint(
-            settings={
-                'response_type': (str,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/convert/gltf',
-                'operation_id': 'run_convert_to_gltf',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'render_task',
-                ],
-                'required': [
-                    'render_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'render_task':
-                        (RenderTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'render_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/octet-stream',
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def run_convert_to_gltf(
-        self,
-        render_task,
-        **kwargs
-    ):
-        """Convert (glTF)  
+    @validate_arguments
+    def run_convert_to_gltf(self, render_task : Annotated[RenderTask, Field(..., description="Data for convertation.")], **kwargs) -> bytearray:  # noqa: E501
+        """Convert (glTF)  # noqa: E501
 
-        Used for render of input and output data to the [glTF](https://en.wikipedia.org/wiki/GlTF) format.  
+        Used for render of input and output data to the [glTF](https://en.wikipedia.org/wiki/GlTF) format.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_convert_to_gltf(render_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            render_task (RenderTask): Data for convertation.
+        :param render_task: Data for convertation. (required)
+        :type render_task: RenderTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: bytearray
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_convert_to_gltf_with_http_info(render_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_convert_to_gltf_with_http_info(self, render_task : Annotated[RenderTask, Field(..., description="Data for convertation.")], **kwargs):  # noqa: E501
+        """Convert (glTF)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            str
-                If the method is called asynchronously, returns the request
-                thread.
+        Used for render of input and output data to the [glTF](https://en.wikipedia.org/wiki/GlTF) format.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_convert_to_gltf_with_http_info(render_task, async_req=True)
+        >>> result = thread.get()
+
+        :param render_task: Data for convertation. (required)
+        :type render_task: RenderTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['render_task'] = \
-            render_task
-        return self.run_convert_to_gltf_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'render_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_convert_to_gltf" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['render_task']:
+            _body_params = _params['render_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/octet-stream', 'application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "bytearray",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '403': "General403",
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/convert/gltf', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_packer/api/pack_api.py

```diff
@@ -1,987 +1,1109 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_packer.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_packer.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, StrictStr
+
+from vrt_lss_packer.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_packer.models.calculation_state import CalculationState
+from vrt_lss_packer.models.pack_result import PackResult
+from vrt_lss_packer.models.pack_task import PackTask
+from vrt_lss_packer.models.validate_result import ValidateResult
+
+from vrt_lss_packer.api_client import ApiClient
+from vrt_lss_packer.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_packer.model.calculation_async_result import CalculationAsyncResult
-from vrt_lss_packer.model.calculation_state import CalculationState
-from vrt_lss_packer.model.inline_response400 import InlineResponse400
-from vrt_lss_packer.model.inline_response401 import InlineResponse401
-from vrt_lss_packer.model.inline_response402 import InlineResponse402
-from vrt_lss_packer.model.inline_response404 import InlineResponse404
-from vrt_lss_packer.model.inline_response429 import InlineResponse429
-from vrt_lss_packer.model.inline_response500 import InlineResponse500
-from vrt_lss_packer.model.pack_result import PackResult
-from vrt_lss_packer.model.pack_task import PackTask
-from vrt_lss_packer.model.validate_result import ValidateResult
 
 
 class PackApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.cancel_pack_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/calculation_async/{id}',
-                'operation_id': 'cancel_pack_calculation',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.delete_pack_result_endpoint = _Endpoint(
-            settings={
-                'response_type': None,
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/result/{id}',
-                'operation_id': 'delete_pack_result',
-                'http_method': 'DELETE',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_pack_calculation_state_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationState,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/calculation_async/{id}',
-                'operation_id': 'read_pack_calculation_state',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.read_pack_result_endpoint = _Endpoint(
-            settings={
-                'response_type': (PackResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/result/{id}',
-                'operation_id': 'read_pack_result',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'id',
-                ],
-                'required': [
-                    'id',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'id':
-                        (str,),
-                },
-                'attribute_map': {
-                    'id': 'id',
-                },
-                'location_map': {
-                    'id': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.run_pack_calculation_endpoint = _Endpoint(
-            settings={
-                'response_type': (PackResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/calculation',
-                'operation_id': 'run_pack_calculation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'pack_task',
-                ],
-                'required': [
-                    'pack_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'pack_task':
-                        (PackTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'pack_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_pack_calculation_async_endpoint = _Endpoint(
-            settings={
-                'response_type': (CalculationAsyncResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/calculation_async',
-                'operation_id': 'run_pack_calculation_async',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'pack_task',
-                ],
-                'required': [
-                    'pack_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'pack_task':
-                        (PackTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'pack_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
-        self.run_pack_validation_endpoint = _Endpoint(
-            settings={
-                'response_type': (ValidateResult,),
-                'auth': [
-                    'ApiKeyAuth'
-                ],
-                'endpoint_path': '/packer/pack/validation',
-                'operation_id': 'run_pack_validation',
-                'http_method': 'POST',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'pack_task',
-                ],
-                'required': [
-                    'pack_task',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'pack_task':
-                        (PackTask,),
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                    'pack_task': 'body',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [
-                    'application/json'
-                ]
-            },
-            api_client=api_client
-        )
 
-    def cancel_pack_calculation(
-        self,
-        id,
-        **kwargs
-    ):
-        """Cancel calculation  
+    @validate_arguments
+    def cancel_pack_calculation(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Cancel calculation  # noqa: E501
 
-        Cancel calculation process by the calculation identifier.  
+        Cancel calculation process by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.cancel_pack_calculation(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.cancel_pack_calculation_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def cancel_pack_calculation_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Cancel calculation  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        Cancel calculation process by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.cancel_pack_calculation_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.cancel_pack_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def delete_pack_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Result removal  
 
-        Removal of the planning result by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method cancel_pack_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/packer/pack/calculation_async/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def delete_pack_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> None:  # noqa: E501
+        """Result removal  # noqa: E501
+
+        Removal of the planning result by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.delete_pack_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.delete_pack_result_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def delete_pack_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Result removal  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            None
-                If the method is called asynchronously, returns the request
-                thread.
+        Removal of the planning result by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.delete_pack_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: None
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.delete_pack_result_endpoint.call_with_http_info(**kwargs)
-
-    def read_pack_calculation_state(
-        self,
-        id,
-        **kwargs
-    ):
-        """Calculation state  
 
-        Read calculation state by the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method delete_pack_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {}
+
+        return self.api_client.call_api(
+            '/packer/pack/result/{id}', 'DELETE',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_pack_calculation_state(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> CalculationState:  # noqa: E501
+        """Calculation state  # noqa: E501
+
+        Read calculation state by the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_pack_calculation_state(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationState
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_pack_calculation_state_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def read_pack_calculation_state_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Calculation state  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationState
-                If the method is called asynchronously, returns the request
-                thread.
+        Read calculation state by the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_pack_calculation_state_with_http_info(id, async_req=True)
+        >>> result = thread.get()
+
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationState, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_pack_calculation_state_endpoint.call_with_http_info(**kwargs)
-
-    def read_pack_result(
-        self,
-        id,
-        **kwargs
-    ):
-        """Getting the result  
 
-        Getting the result based on the calculation identifier.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_pack_calculation_state" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationState",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/pack/calculation_async/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def read_pack_result(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs) -> PackResult:  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the result based on the calculation identifier.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.read_pack_result(id, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            id (str): Calculation identifier.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PackResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.read_pack_result_with_http_info(id, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def read_pack_result_with_http_info(self, id : Annotated[StrictStr, Field(..., description="Calculation identifier.")], **kwargs):  # noqa: E501
+        """Getting the result  # noqa: E501
+
+        Getting the result based on the calculation identifier.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.read_pack_result_with_http_info(id, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PackResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param id: Calculation identifier. (required)
+        :type id: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PackResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['id'] = \
-            id
-        return self.read_pack_result_endpoint.call_with_http_info(**kwargs)
-
-    def run_pack_calculation(
-        self,
-        pack_task,
-        **kwargs
-    ):
-        """Packing (SYNC)  
 
-        Planning the optimal package.  
+        _params = locals()
+
+        _all_params = [
+            'id'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method read_pack_result" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['id']:
+            _path_params['id'] = _params['id']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PackResult",
+            '202': "PackResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/pack/result/{id}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_pack_calculation(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs) -> PackResult:  # noqa: E501
+        """Packing (SYNC)  # noqa: E501
+
+        Planning the optimal package.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_pack_calculation(pack_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            pack_task (PackTask): Data for calculation.
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: PackResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_pack_calculation_with_http_info(pack_task, **kwargs)  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            PackResult
-                If the method is called asynchronously, returns the request
-                thread.
+    @validate_arguments
+    def run_pack_calculation_with_http_info(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs):  # noqa: E501
+        """Packing (SYNC)  # noqa: E501
+
+        Planning the optimal package.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_pack_calculation_with_http_info(pack_task, async_req=True)
+        >>> result = thread.get()
+
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(PackResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['pack_task'] = \
-            pack_task
-        return self.run_pack_calculation_endpoint.call_with_http_info(**kwargs)
-
-    def run_pack_calculation_async(
-        self,
-        pack_task,
-        **kwargs
-    ):
-        """Packing (ASYNC)  
 
-        The result can be obtained using the [result](#operation/read_pack_result) method,  removing - with [delete](#operation/delete_pack_result).   
+        _params = locals()
+
+        _all_params = [
+            'pack_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_pack_calculation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['pack_task']:
+            _body_params = _params['pack_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "PackResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/pack/calculation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_pack_calculation_async(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs) -> CalculationAsyncResult:  # noqa: E501
+        """Packing (ASYNC)  # noqa: E501
+
+        The result can be obtained using the [result](#operation/read_pack_result) method,  removing - with [delete](#operation/delete_pack_result).   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_pack_calculation_async(pack_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            pack_task (PackTask): Data for calculation.
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CalculationAsyncResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_pack_calculation_async_with_http_info(pack_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_pack_calculation_async_with_http_info(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs):  # noqa: E501
+        """Packing (ASYNC)  # noqa: E501
+
+        The result can be obtained using the [result](#operation/read_pack_result) method,  removing - with [delete](#operation/delete_pack_result).   # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_pack_calculation_async_with_http_info(pack_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CalculationAsyncResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CalculationAsyncResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['pack_task'] = \
-            pack_task
-        return self.run_pack_calculation_async_endpoint.call_with_http_info(**kwargs)
-
-    def run_pack_validation(
-        self,
-        pack_task,
-        **kwargs
-    ):
-        """Data validation  
 
-        Checking data before planning.  
+        _params = locals()
+
+        _all_params = [
+            'pack_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_pack_calculation_async" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['pack_task']:
+            _body_params = _params['pack_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "CalculationAsyncResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/pack/calculation_async', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def run_pack_validation(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs) -> ValidateResult:  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Checking data before planning.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.run_pack_validation(pack_task, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            pack_task (PackTask): Data for calculation.
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: ValidateResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.run_pack_validation_with_http_info(pack_task, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def run_pack_validation_with_http_info(self, pack_task : Annotated[PackTask, Field(..., description="Data for calculation.")], **kwargs):  # noqa: E501
+        """Data validation  # noqa: E501
+
+        Checking data before planning.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.run_pack_validation_with_http_info(pack_task, async_req=True)
+        >>> result = thread.get()
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            ValidateResult
-                If the method is called asynchronously, returns the request
-                thread.
+        :param pack_task: Data for calculation. (required)
+        :type pack_task: PackTask
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(ValidateResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['pack_task'] = \
-            pack_task
-        return self.run_pack_validation_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+            'pack_task'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method run_pack_validation" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        if _params['pack_task']:
+            _body_params = _params['pack_task']
+
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # set the HTTP header `Content-Type`
+        _content_types_list = _params.get('_content_type',
+            self.api_client.select_header_content_type(
+                ['application/json']))
+        if _content_types_list:
+                _header_params['Content-Type'] = _content_types_list
+
+        # authentication setting
+        _auth_settings = ['ApiKeyAuth']  # noqa: E501
+
+        _response_types_map = {
+            '200': "ValidateResult",
+            '400': "Custom400WithErrorsAndWarnings",
+            '401': "General401",
+            '402': "General402",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/pack/validation', 'POST',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_packer/api/system_api.py

```diff
@@ -1,419 +1,477 @@
+# coding: utf-8
+
 """
     VRt.Packer [PC]
 
-    The version of the OpenAPI document: 6.4.1962
-    Contact: servicedesk@veeroute.com
-    Auto Generated
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
 """
 
 
 import re  # noqa: F401
-import sys  # noqa: F401
 
-from vrt_lss_packer.api_client import ApiClient, Endpoint as _Endpoint
-from vrt_lss_packer.model_utils import (  # noqa: F401
-    check_allowed_values,
-    check_validations,
-    date,
-    datetime,
-    file_type,
-    none_type,
-    validate_and_convert_types
+from pydantic import validate_arguments, ValidationError
+from typing_extensions import Annotated
+
+from pydantic import Field, constr
+
+from vrt_lss_packer.models.check_result import CheckResult
+from vrt_lss_packer.models.version_result import VersionResult
+
+from vrt_lss_packer.api_client import ApiClient
+from vrt_lss_packer.exceptions import (  # noqa: F401
+    ApiTypeError,
+    ApiValueError
 )
-from vrt_lss_packer.model.check_result import CheckResult
-from vrt_lss_packer.model.inline_response404 import InlineResponse404
-from vrt_lss_packer.model.inline_response429 import InlineResponse429
-from vrt_lss_packer.model.inline_response500 import InlineResponse500
-from vrt_lss_packer.model.version_result import VersionResult
 
 
 class SystemApi(object):
     """NOTE: This class is auto generated by OpenAPI Generator
+    Ref: https://openapi-generator.tech
 
     Do not edit the class manually.
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
-            api_client = ApiClient()
+            api_client = ApiClient.get_default()
         self.api_client = api_client
-        self.check_endpoint = _Endpoint(
-            settings={
-                'response_type': (CheckResult,),
-                'auth': [],
-                'endpoint_path': '/packer/system/check',
-                'operation_id': 'check',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                ],
-                'required': [],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.file_endpoint = _Endpoint(
-            settings={
-                'response_type': (str,),
-                'auth': [],
-                'endpoint_path': '/packer/file/{filename}',
-                'operation_id': 'file',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                    'filename',
-                ],
-                'required': [
-                    'filename',
-                ],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                    'filename',
-                ]
-            },
-            root_map={
-                'validations': {
-                    ('filename',): {
-                        'max_length': 128,
-                        'min_length': 6,
-                    },
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                    'filename':
-                        (str,),
-                },
-                'attribute_map': {
-                    'filename': 'filename',
-                },
-                'location_map': {
-                    'filename': 'path',
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'text/html',
-                    'text/plain',
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
-        self.version_endpoint = _Endpoint(
-            settings={
-                'response_type': (VersionResult,),
-                'auth': [],
-                'endpoint_path': '/packer/system/version',
-                'operation_id': 'version',
-                'http_method': 'GET',
-                'servers': None,
-            },
-            params_map={
-                'all': [
-                ],
-                'required': [],
-                'nullable': [
-                ],
-                'enum': [
-                ],
-                'validation': [
-                ]
-            },
-            root_map={
-                'validations': {
-                },
-                'allowed_values': {
-                },
-                'openapi_types': {
-                },
-                'attribute_map': {
-                },
-                'location_map': {
-                },
-                'collection_format_map': {
-                }
-            },
-            headers_map={
-                'accept': [
-                    'application/json'
-                ],
-                'content_type': [],
-            },
-            api_client=api_client
-        )
 
-    def check(
-        self,
-        **kwargs
-    ):
-        """Checking the availability  
+    @validate_arguments
+    def check(self, **kwargs) -> CheckResult:  # noqa: E501
+        """Checking the availability  # noqa: E501
 
-        Checking the service availability.  
+        Checking the service availability.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.check(async_req=True)
         >>> result = thread.get()
 
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: CheckResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.check_with_http_info(**kwargs)  # noqa: E501
+
+    @validate_arguments
+    def check_with_http_info(self, **kwargs):  # noqa: E501
+        """Checking the availability  # noqa: E501
+
+        Checking the service availability.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            CheckResult
-                If the method is called asynchronously, returns the request
-                thread.
+        >>> thread = api.check_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(CheckResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        return self.check_endpoint.call_with_http_info(**kwargs)
-
-    def file(
-        self,
-        filename,
-        **kwargs
-    ):
-        """Getting the documentation  
 
-        Getting the file with this service documentation.  
+        _params = locals()
+
+        _all_params = [
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method check" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "CheckResult",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/system/check', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def file(self, filename : Annotated[constr(strict=True, max_length=128, min_length=6), Field(..., description="File name.")], **kwargs) -> str:  # noqa: E501
+        """Getting the documentation  # noqa: E501
+
+        Getting the file with this service documentation.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.file(filename, async_req=True)
         >>> result = thread.get()
 
-        Args:
-            filename (str): File name.
+        :param filename: File name. (required)
+        :type filename: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: str
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.file_with_http_info(filename, **kwargs)  # noqa: E501
+
+    @validate_arguments
+    def file_with_http_info(self, filename : Annotated[constr(strict=True, max_length=128, min_length=6), Field(..., description="File name.")], **kwargs):  # noqa: E501
+        """Getting the documentation  # noqa: E501
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            str
-                If the method is called asynchronously, returns the request
-                thread.
+        Getting the file with this service documentation.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+
+        >>> thread = api.file_with_http_info(filename, async_req=True)
+        >>> result = thread.get()
+
+        :param filename: File name. (required)
+        :type filename: str
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        kwargs['filename'] = \
-            filename
-        return self.file_endpoint.call_with_http_info(**kwargs)
-
-    def version(
-        self,
-        **kwargs
-    ):
-        """Getting the service version  
 
-        Getting the service version.  
+        _params = locals()
+
+        _all_params = [
+            'filename'
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method file" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+        if _params['filename']:
+            _path_params['filename'] = _params['filename']
+
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['text/html', 'text/plain', 'application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "str",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/file/{filename}', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
+
+    @validate_arguments
+    def version(self, **kwargs) -> VersionResult:  # noqa: E501
+        """Getting the service version  # noqa: E501
+
+        Getting the service version.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.version(async_req=True)
         >>> result = thread.get()
 
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: VersionResult
+        """
+        kwargs['_return_http_data_only'] = True
+        return self.version_with_http_info(**kwargs)  # noqa: E501
+
+    @validate_arguments
+    def version_with_http_info(self, **kwargs):  # noqa: E501
+        """Getting the service version  # noqa: E501
+
+        Getting the service version.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
 
-        Keyword Args:
-            _return_http_data_only (bool): response data without head status
-                code and headers. Default is True.
-            _preload_content (bool): if False, the urllib3.HTTPResponse object
-                will be returned without reading/decoding response data.
-                Default is True.
-            _request_timeout (int/float/tuple): timeout setting for this request. If
-                one number provided, it will be total request timeout. It can also
-                be a pair (tuple) of (connection, read) timeouts.
-                Default is None.
-            _check_input_type (bool): specifies if type checking
-                should be done one the data sent to the server.
-                Default is True.
-            _check_return_type (bool): specifies if type checking
-                should be done one the data received from the server.
-                Default is True.
-            _spec_property_naming (bool): True if the variable names in the input data
-                are serialized names, as specified in the OpenAPI document.
-                False if the variable names in the input data
-                are pythonic names, e.g. snake case (default)
-            _content_type (str/None): force body content-type.
-                Default is None and content-type will be predicted by allowed
-                content-types and body.
-            _host_index (int/None): specifies the index of the server
-                that we want to use.
-                Default is read from the configuration.
-            _request_auths (list): set to override the auth_settings for an a single
-                request; this effectively ignores the authentication
-                in the spec for a single request.
-                Default is None
-            async_req (bool): execute request asynchronously
-
-        Returns:
-            VersionResult
-                If the method is called asynchronously, returns the request
-                thread.
+        >>> thread = api.version_with_http_info(async_req=True)
+        >>> result = thread.get()
+
+        :param async_req: Whether to execute the request asynchronously.
+        :type async_req: bool, optional
+        :param _return_http_data_only: response data without head status code
+                                       and headers
+        :type _return_http_data_only: bool, optional
+        :param _preload_content: if False, the urllib3.HTTPResponse object will
+                                 be returned without reading/decoding response
+                                 data. Default is True.
+        :type _preload_content: bool, optional
+        :param _request_timeout: timeout setting for this request. If one
+                                 number provided, it will be total request
+                                 timeout. It can also be a pair (tuple) of
+                                 (connection, read) timeouts.
+        :param _request_auth: set to override the auth_settings for an a single
+                              request; this effectively ignores the authentication
+                              in the spec for a single request.
+        :type _request_auth: dict, optional
+        :type _content_type: string, optional: force content-type for the request
+        :return: Returns the result object.
+                 If the method is called asynchronously,
+                 returns the request thread.
+        :rtype: tuple(VersionResult, status_code(int), headers(HTTPHeaderDict))
         """
-        kwargs['async_req'] = kwargs.get(
-            'async_req', False
-        )
-        kwargs['_return_http_data_only'] = kwargs.get(
-            '_return_http_data_only', True
-        )
-        kwargs['_preload_content'] = kwargs.get(
-            '_preload_content', True
-        )
-        kwargs['_request_timeout'] = kwargs.get(
-            '_request_timeout', None
-        )
-        kwargs['_check_input_type'] = kwargs.get(
-            '_check_input_type', True
-        )
-        kwargs['_check_return_type'] = kwargs.get(
-            '_check_return_type', True
-        )
-        kwargs['_spec_property_naming'] = kwargs.get(
-            '_spec_property_naming', False
-        )
-        kwargs['_content_type'] = kwargs.get(
-            '_content_type')
-        kwargs['_host_index'] = kwargs.get('_host_index')
-        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
-        return self.version_endpoint.call_with_http_info(**kwargs)
 
+        _params = locals()
+
+        _all_params = [
+        ]
+        _all_params.extend(
+            [
+                'async_req',
+                '_return_http_data_only',
+                '_preload_content',
+                '_request_timeout',
+                '_request_auth',
+                '_content_type',
+                '_headers'
+            ]
+        )
+
+        # validate the arguments
+        for _key, _val in _params['kwargs'].items():
+            if _key not in _all_params:
+                raise ApiTypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method version" % _key
+                )
+            _params[_key] = _val
+        del _params['kwargs']
+
+        _collection_formats = {}
+
+        # process the path parameters
+        _path_params = {}
+
+        # process the query parameters
+        _query_params = []
+        # process the header parameters
+        _header_params = dict(_params.get('_headers', {}))
+        # process the form parameters
+        _form_params = []
+        _files = {}
+        # process the body parameter
+        _body_params = None
+        # set the HTTP header `Accept`
+        _header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json'])  # noqa: E501
+
+        # authentication setting
+        _auth_settings = []  # noqa: E501
+
+        _response_types_map = {
+            '200': "VersionResult",
+            '404': "General404",
+            '405': None,
+            '406': None,
+            '415': None,
+            '429': "General429",
+            '500': "General500",
+            '501': None,
+            '502': None,
+            '503': None,
+            '504': None,
+        }
+
+        return self.api_client.call_api(
+            '/packer/system/version', 'GET',
+            _path_params,
+            _query_params,
+            _header_params,
+            body=_body_params,
+            post_params=_form_params,
+            files=_files,
+            response_types_map=_response_types_map,
+            auth_settings=_auth_settings,
+            async_req=_params.get('async_req'),
+            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
+            _preload_content=_params.get('_preload_content', True),
+            _request_timeout=_params.get('_request_timeout'),
+            collection_formats=_collection_formats,
+            _request_auth=_params.get('_request_auth'))
```

## vrt_lss_packer/models/__init__.py

```diff
@@ -1,60 +1,58 @@
+# coding: utf-8
+
 # flake8: noqa
+"""
+    VRt.Packer [PC]
+
+    The version of the OpenAPI document: 6.5.1990
+
+    Generated by OpenAPI Generator: 6.5.0
+
+    Do not edit the code manually
+
+    2023 Veeroute
+"""
+
 
-# import all models into this package
-# if you have many models here with many references from one model to another this may
-# raise a RecursionError
-# to avoid this, import only the models that you directly need like:
-# from from vrt_lss_packer.model.pet import Pet
-# or import this package, but before doing it, use:
-# import sys
-# sys.setrecursionlimit(n)
-
-from vrt_lss_packer.model.attribute import Attribute
-from vrt_lss_packer.model.attributes import Attributes
-from vrt_lss_packer.model.blueprint import Blueprint
-from vrt_lss_packer.model.calculation_async_result import CalculationAsyncResult
-from vrt_lss_packer.model.calculation_info import CalculationInfo
-from vrt_lss_packer.model.calculation_progress import CalculationProgress
-from vrt_lss_packer.model.calculation_settings import CalculationSettings
-from vrt_lss_packer.model.calculation_state import CalculationState
-from vrt_lss_packer.model.calculation_status import CalculationStatus
-from vrt_lss_packer.model.check_result import CheckResult
-from vrt_lss_packer.model.coordinates import Coordinates
-from vrt_lss_packer.model.dimensions import Dimensions
-from vrt_lss_packer.model.entity_error import EntityError
-from vrt_lss_packer.model.entity_error_list import EntityErrorList
-from vrt_lss_packer.model.entity_error_type import EntityErrorType
-from vrt_lss_packer.model.entity_path import EntityPath
-from vrt_lss_packer.model.entity_type import EntityType
-from vrt_lss_packer.model.entity_warning import EntityWarning
-from vrt_lss_packer.model.entity_warning_list import EntityWarningList
-from vrt_lss_packer.model.entity_warning_type import EntityWarningType
-from vrt_lss_packer.model.inline_response400 import InlineResponse400
-from vrt_lss_packer.model.inline_response401 import InlineResponse401
-from vrt_lss_packer.model.inline_response402 import InlineResponse402
-from vrt_lss_packer.model.inline_response403 import InlineResponse403
-from vrt_lss_packer.model.inline_response404 import InlineResponse404
-from vrt_lss_packer.model.inline_response404_detail import InlineResponse404Detail
-from vrt_lss_packer.model.inline_response429 import InlineResponse429
-from vrt_lss_packer.model.inline_response500 import InlineResponse500
-from vrt_lss_packer.model.operation_id import OperationId
-from vrt_lss_packer.model.pack_result import PackResult
-from vrt_lss_packer.model.pack_settings import PackSettings
-from vrt_lss_packer.model.pack_statistics import PackStatistics
-from vrt_lss_packer.model.pack_task import PackTask
-from vrt_lss_packer.model.package import Package
-from vrt_lss_packer.model.package_layout import PackageLayout
-from vrt_lss_packer.model.package_statistics import PackageStatistics
-from vrt_lss_packer.model.package_type import PackageType
-from vrt_lss_packer.model.product import Product
-from vrt_lss_packer.model.product_group_layout import ProductGroupLayout
-from vrt_lss_packer.model.product_layout import ProductLayout
-from vrt_lss_packer.model.render_task import RenderTask
-from vrt_lss_packer.model.schema_error import SchemaError
-from vrt_lss_packer.model.schema_error_list import SchemaErrorList
-from vrt_lss_packer.model.service_name import ServiceName
-from vrt_lss_packer.model.time_duration import TimeDuration
-from vrt_lss_packer.model.tracedata import Tracedata
-from vrt_lss_packer.model.unpacked_items import UnpackedItems
-from vrt_lss_packer.model.validate_result import ValidateResult
-from vrt_lss_packer.model.version_result import VersionResult
+# import models into model package
+from vrt_lss_packer.models.attribute import Attribute
+from vrt_lss_packer.models.calculation_async_result import CalculationAsyncResult
+from vrt_lss_packer.models.calculation_info import CalculationInfo
+from vrt_lss_packer.models.calculation_settings import CalculationSettings
+from vrt_lss_packer.models.calculation_state import CalculationState
+from vrt_lss_packer.models.calculation_status import CalculationStatus
+from vrt_lss_packer.models.check_result import CheckResult
+from vrt_lss_packer.models.coordinates import Coordinates
+from vrt_lss_packer.models.custom400_with_errors_and_warnings import Custom400WithErrorsAndWarnings
+from vrt_lss_packer.models.dimensions import Dimensions
+from vrt_lss_packer.models.entity_error import EntityError
+from vrt_lss_packer.models.entity_error_type import EntityErrorType
+from vrt_lss_packer.models.entity_path import EntityPath
+from vrt_lss_packer.models.entity_type import EntityType
+from vrt_lss_packer.models.entity_warning import EntityWarning
+from vrt_lss_packer.models.entity_warning_type import EntityWarningType
+from vrt_lss_packer.models.general401 import General401
+from vrt_lss_packer.models.general402 import General402
+from vrt_lss_packer.models.general403 import General403
+from vrt_lss_packer.models.general404 import General404
+from vrt_lss_packer.models.general404_detail import General404Detail
+from vrt_lss_packer.models.general429 import General429
+from vrt_lss_packer.models.general500 import General500
+from vrt_lss_packer.models.pack_result import PackResult
+from vrt_lss_packer.models.pack_settings import PackSettings
+from vrt_lss_packer.models.pack_statistics import PackStatistics
+from vrt_lss_packer.models.pack_task import PackTask
+from vrt_lss_packer.models.package import Package
+from vrt_lss_packer.models.package_layout import PackageLayout
+from vrt_lss_packer.models.package_statistics import PackageStatistics
+from vrt_lss_packer.models.package_type import PackageType
+from vrt_lss_packer.models.product import Product
+from vrt_lss_packer.models.product_group_layout import ProductGroupLayout
+from vrt_lss_packer.models.product_layout import ProductLayout
+from vrt_lss_packer.models.render_task import RenderTask
+from vrt_lss_packer.models.schema_error import SchemaError
+from vrt_lss_packer.models.service_name import ServiceName
+from vrt_lss_packer.models.tracedata import Tracedata
+from vrt_lss_packer.models.unpacked_items import UnpackedItems
+from vrt_lss_packer.models.validate_result import ValidateResult
+from vrt_lss_packer.models.version_result import VersionResult
```

## Comparing `vrt_lss_packer-6.4.1962.dist-info/RECORD` & `vrt_lss_packer-6.5.1990.dist-info/RECORD`

 * *Files 27% similar despite different names*

```diff
@@ -1,66 +1,55 @@
-vrt_lss_packer/__init__.py,sha256=260ib1_z9QpEt3l1WxExIuKbtSljRg72sctUQab359E,662
-vrt_lss_packer/api_client.py,sha256=oQVn0HurlfO-5UqhM00L_QXtuc3j0Jxs2WU_EEo7vlA,38703
-vrt_lss_packer/configuration.py,sha256=ErdMaIPI-5TmZYHoxm7RE22YuYhWTeC-bdBvuk2l-XU,16601
-vrt_lss_packer/exceptions.py,sha256=RvhKLaR_8K0TiX_oNVuX09_hNnWaaL0wRFzozuF5Yvk,4992
-vrt_lss_packer/model_utils.py,sha256=-ZuOpaJbg2dUBxEiC9wZ06sXpntwiNRLva2sXzt1-Zc,82280
-vrt_lss_packer/rest.py,sha256=Sg_vDLUcvp_qSbV-nrsjlWjZyXYH-JIRh-1fXeIsxz4,14014
-vrt_lss_packer/api/__init__.py,sha256=cKz67caw9zJssnbaPD5hnIfrmDHyrQ5LjzDGBeDTSKI,218
-vrt_lss_packer/api/convert_api.py,sha256=1H-ydu00vmbWIuJC4sJfEyN6BotOo88Gfu6yVVskx_U,6333
-vrt_lss_packer/api/pack_api.py,sha256=4ZT2JMqH73fgINV7dz173E4RQ1T_zACLu4VZiSHaUaQ,36462
-vrt_lss_packer/api/system_api.py,sha256=FKY0G6u9A05I9PNDNDur2T9U9NY81NUUIrwaqKUoDFs,15150
-vrt_lss_packer/apis/__init__.py,sha256=mUTL3HybFIpA_GGVMWeAq3A0LCJtILElURHAVpFtYyo,581
-vrt_lss_packer/model/__init__.py,sha256=pQfMTQWfvDLFfP8EuMaGQff1p_pdDrt9WgIic2e_kq4,348
-vrt_lss_packer/model/attribute.py,sha256=NARMabMQANsXeYhMsOtuF43wCcLAJsdJh7LrAxWYcX0,11410
-vrt_lss_packer/model/attributes.py,sha256=OqhAkJGcOYWDKcgXP2lUGXrWiCqqYtLLAs_5l5Kl90Y,11623
-vrt_lss_packer/model/blueprint.py,sha256=BpY-rG8f7ZX9bCrKrXvSmfF92yWaxfaIR429bxxCIAg,12226
-vrt_lss_packer/model/calculation_async_result.py,sha256=PRlf8-_nq8psZR0hz9npwxCcU03zQxQQrLKtedfj9wE,11429
-vrt_lss_packer/model/calculation_info.py,sha256=G4RlEP2laA2Ui7spHNZSO2IdPPKzzaDcaip1ObUpQm8,13486
-vrt_lss_packer/model/calculation_progress.py,sha256=rCWVGQHIM6yC5zF313VwGvjdJRxLQhL8s1y0CKMnGuI,11701
-vrt_lss_packer/model/calculation_settings.py,sha256=z5jYZq0Kgv8PFmitR1tmAnZePrHS8nCQMh_HzDX2Y-c,14949
-vrt_lss_packer/model/calculation_state.py,sha256=qdvbBW4pxd-bjfSfn1KDGcLP4iBPI5Xb3-yWeWbE3oE,11937
-vrt_lss_packer/model/calculation_status.py,sha256=g1NO2UnsJ4RmnBamtHO0aHRjZgIxKV5dE9O8l2BmxJ8,14741
-vrt_lss_packer/model/check_result.py,sha256=iHcMEzM2_BzL8u4mV7YtZ7Md08Gv07L2AoiUwQzm29I,11161
-vrt_lss_packer/model/coordinates.py,sha256=Lu3yVPRYnKp0gS2SiMXf5RekhzD4ZO6t1IrNbuDY80E,11850
-vrt_lss_packer/model/dimensions.py,sha256=Ri18hwjy5PRJeYvEJDaMU192_cwQDyB1tYWlHC5oezw,12155
-vrt_lss_packer/model/entity_error.py,sha256=6ooUTUBqlVEaUoZDlsSUh8fyxbG4zYdqIMiHv-_ekiQ,12005
-vrt_lss_packer/model/entity_error_list.py,sha256=KxY6UIK0PPcIByqJEmKMlKK8iGKZqEOAbFU3HrlTnMU,12146
-vrt_lss_packer/model/entity_error_type.py,sha256=0qo1rd77iNztu1T7JWnJS_4bIwg7jHzGA_eiadGhjfE,17871
-vrt_lss_packer/model/entity_path.py,sha256=vYoY6UZXspJXccLwkehyaCrQXR3O6xnIwel21hD1Gj8,11794
-vrt_lss_packer/model/entity_type.py,sha256=faeXhtxhteaHcUvB5_cinZJIcSqQFutcHIWAjZNW6wU,11954
-vrt_lss_packer/model/entity_warning.py,sha256=DwRTEDkm0BJ3jptMA8KFEV0Gx7UoKO5KdvNx6SuTfyg,12033
-vrt_lss_packer/model/entity_warning_list.py,sha256=572rZy9TqGFeUhtTwAFW0dFlpokv_LZ9G4M-rl0eeAY,12618
-vrt_lss_packer/model/entity_warning_type.py,sha256=e3vhh3sXGddk2oTkqc2Nnq9qf1udFJll6PpulWv8HJg,15099
-vrt_lss_packer/model/inline_response400.py,sha256=fFd9ArgA-tb8Nyb7u46u2HIWewMsFy3_DXMzVsgMqHw,12710
-vrt_lss_packer/model/inline_response401.py,sha256=cCkjHBTe3c6HVZ-I96_oxydnQnf4gL-dd1cjdZ0sF_o,11717
-vrt_lss_packer/model/inline_response402.py,sha256=dNiXtuIpSgP8auQPKdZ8atk6byoOotlXnxvN5Zqq-5U,11717
-vrt_lss_packer/model/inline_response403.py,sha256=i00FS6n6ig2p4_spYM02roT-hjJILczJy3PTTw6weXs,11717
-vrt_lss_packer/model/inline_response404.py,sha256=GwYJX4fJ-28uRrnBmD24AdrRIppmYNFC0wNJrALSA_c,11856
-vrt_lss_packer/model/inline_response404_detail.py,sha256=waFBzj6fUNiGvq06Ujn4B_yk6N_5G9mdtq6jFbQ_VnU,11524
-vrt_lss_packer/model/inline_response429.py,sha256=ElUO3Ym_Y5VL1etQoA0XoMUjrFlR6WeufrwkmZLVrmk,11717
-vrt_lss_packer/model/inline_response500.py,sha256=UMK-Src9BWZ9beGAA1MqaRgErfaOB6UQ3EjJbRmIqlQ,11717
-vrt_lss_packer/model/operation_id.py,sha256=AbRL4Ld4FC5jAMHsBh6PouVvxcvqA3By6U1eP0uvF-g,11677
-vrt_lss_packer/model/pack_result.py,sha256=Fv2jZSF4TmT6Wk_OCN_MNaYF8GaJ7iGbri-J4-QX5v0,13281
-vrt_lss_packer/model/pack_settings.py,sha256=nXug6I840ecXHH2icXwPwc0_miM4owJByimI_Ic3Fck,11237
-vrt_lss_packer/model/pack_statistics.py,sha256=D508s1NrFGltd-eCulTPmyFQxvLwbHt7_BOXWZfyCsM,13450
-vrt_lss_packer/model/pack_task.py,sha256=Qc9YWde7sBk-2e2eIL0ELcirwIiy-7yTXl8YPuxnB8c,12232
-vrt_lss_packer/model/package.py,sha256=_G3TsdiNKLLFWGgITze0F1dvCg-ev9WNXblq4yEr7Wk,12996
-vrt_lss_packer/model/package_layout.py,sha256=IS6RZOq2ThiV-iasoUQzVWEwDrQcSJSGknwq66yR8ig,13153
-vrt_lss_packer/model/package_statistics.py,sha256=m-GyuNoB-Xcnd8Ab5_Sofh1HM50qWnNHbHJYn3wSvjY,14892
-vrt_lss_packer/model/package_type.py,sha256=hNro8sVKlTy1gN8mU9XygJz6ITMnxRB6iwkqdWX-UTI,13489
-vrt_lss_packer/model/product.py,sha256=aqj-Ktm8KWSMYBTpQtEs5gikJ2qopl6HNqjNydNVhIU,13534
-vrt_lss_packer/model/product_group_layout.py,sha256=ZSm_2Iggr6hwMCjj8WvFl9IgShX29r2gr5ndFj1b9TY,12572
-vrt_lss_packer/model/product_layout.py,sha256=24SBbp9j6BZn9csyN6WMaGLIotIlRU1JQOsFlsLGpFE,11968
-vrt_lss_packer/model/render_task.py,sha256=PHp82iCJxmXyT7PMNTIE1ekflkJ422Mqx-R7NFuSI20,12094
-vrt_lss_packer/model/schema_error.py,sha256=9LyNO8yW-gbqiFaX3How_d6oo70WnwptezKXj0vglcc,11395
-vrt_lss_packer/model/schema_error_list.py,sha256=q2tRJAI5kzkXZVvz7wRt_7Me07XetzF47P_2fSGMCzE,11850
-vrt_lss_packer/model/service_name.py,sha256=C6aQbws_I1vyiLwaxvqSrxkmo9hV6nfyr2bKU1hU62M,12525
-vrt_lss_packer/model/time_duration.py,sha256=7v53G-JlUUbJYE1luwtXBoVfNwsj86JDORzPRgU_KMA,11764
-vrt_lss_packer/model/tracedata.py,sha256=0-hthXBLBeooUIV5_r3PDHosMQsX_2Nt5La8tTc1VHE,13380
-vrt_lss_packer/model/unpacked_items.py,sha256=HUgam9WUPVOJskzaGHF9FsvK4SrNIxeHj7Jvx9rbsjM,11464
-vrt_lss_packer/model/validate_result.py,sha256=DVIFpnFTEvnqwvziBMUpk58zt-u3bFgz0xK5sPPHHPg,11595
-vrt_lss_packer/model/version_result.py,sha256=WW8H9s-oifm_sY1zkSyFybNkEuqFjcy4YWHBnYB9UiY,12588
-vrt_lss_packer/models/__init__.py,sha256=TcUqwTe8QLWm7zoHvfBU9Q8x6B-l3ceX9MA0fyM4KpI,3474
-vrt_lss_packer-6.4.1962.dist-info/METADATA,sha256=Sz5FZCXq-f1K3BM3Voousp2WgKc8RguJ7HAFhCBhvBg,360
-vrt_lss_packer-6.4.1962.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-vrt_lss_packer-6.4.1962.dist-info/top_level.txt,sha256=GOd336Z7gFS80QqhxJaOmRfCuK5HJbfV_Rchzs7w0HE,15
-vrt_lss_packer-6.4.1962.dist-info/RECORD,,
+vrt_lss_packer/__init__.py,sha256=pMbxZvFWXyDMfHssZ1CZFZjkpaz5qw8elnRRnEXS_0c,3451
+vrt_lss_packer/api_client.py,sha256=Mni7-IHnGpCh6b3a3BfNKEtmtSZgd0JOQafymUPZ68g,29529
+vrt_lss_packer/configuration.py,sha256=rVl34cq1ALjvbYhCwhskr1Hty2xTpJeR8CS5tpKJoVg,14664
+vrt_lss_packer/exceptions.py,sha256=6-NmtVQ6OTj8-eGI9szFCRbspB-zbnX6RS2cQK_w8qk,5037
+vrt_lss_packer/rest.py,sha256=3mt7abVGqLPqDmwqHWYQ48Ye-JGYkg1aUkEfWMWn9-Q,12557
+vrt_lss_packer/api/__init__.py,sha256=10KucTDcFst5l1nXuw-5xS-_MRg-BV-0XAOb3ig4pNc,202
+vrt_lss_packer/api/convert_api.py,sha256=m-PdQDY7GL0jXCVQWP2Uhu5eX_ku9eEmJuAjlYvhQ44,7706
+vrt_lss_packer/api/pack_api.py,sha256=4nLvMEcdS-u6zjWu1UZKrWFQo2w5eLpYq1wnKevflhE,45958
+vrt_lss_packer/api/system_api.py,sha256=Ju7beZyWRjqcE3UHoA9u8DKQx-fCpkkTVqjYZ36XWEw,18556
+vrt_lss_packer/models/__init__.py,sha256=vFqTDuEnrxVGgsNf7YIcAbY0B6kVEuqy-gWHzZ81TnU,2803
+vrt_lss_packer/models/attribute.py,sha256=_Q1oVnG0IR80ARc6SOAn03seQgby2naoL4UrFEVqrKE,1929
+vrt_lss_packer/models/calculation_async_result.py,sha256=4A69MUN124r2q2LfVCC_qSHRBAgMeRd2MQhwEUkv2IM,2255
+vrt_lss_packer/models/calculation_info.py,sha256=67L3cerLvy093LuZojukf3K32jZ4X1bUgeISMEXAByA,6522
+vrt_lss_packer/models/calculation_settings.py,sha256=fkGvNWAJslOXTK8qJWLJNYRmzwIdKLcTrvpWhObtok0,5333
+vrt_lss_packer/models/calculation_state.py,sha256=MEMtm51mvsd8MHft8e3kYaoqh8bh01pslAMkq8dDPNo,2716
+vrt_lss_packer/models/calculation_status.py,sha256=0X7yYcHEGu6-iQf2KrdWt7bcyKfZa3fk8d9i-kx-Nz8,1232
+vrt_lss_packer/models/check_result.py,sha256=DOEvAXtcFf7KZy5zeC6ki7riDvKPzOnKo26vXIZWYdo,1802
+vrt_lss_packer/models/coordinates.py,sha256=PY2dDYCobPSCfOJVRr839pbAJIejC6EH7LVxxz6ZEdc,2167
+vrt_lss_packer/models/custom400_with_errors_and_warnings.py,sha256=6ItoOOTI5sYSpsSBtBxnsMbvlxb0rSLG8C7rXn6bvy4,4805
+vrt_lss_packer/models/dimensions.py,sha256=7sWdQvQ5cljkd5htCVzGzOMJdGl97_ZHeIliWh7q_7U,2247
+vrt_lss_packer/models/entity_error.py,sha256=eIZZyTThnWfRGEK_XJi6_ES0Kl69Pzb3YQaFOviSw-w,2863
+vrt_lss_packer/models/entity_error_type.py,sha256=d71hoVXdQS2WJNN_e-e3XewT7tED6b0sCFT9MxC0_fc,2111
+vrt_lss_packer/models/entity_path.py,sha256=MsDUJNQ4DDhGBwUleZ5yTDG26ZWBbrANu02qR1cdqU8,2847
+vrt_lss_packer/models/entity_type.py,sha256=BFxC6rxYjksMMHfBsuGiJTwRrHJXHDqWumdFqwvrm24,500
+vrt_lss_packer/models/entity_warning.py,sha256=alanzP5NrJ2HkCNdanjKApKbhDZ7tIny_SkPIaIikeo,2889
+vrt_lss_packer/models/entity_warning_type.py,sha256=D3j0waB7G-BFGMRrHnDMiObUuDgcqDZiIWu7ugQNxLU,1335
+vrt_lss_packer/models/general401.py,sha256=9yxmgANpll62XLgR2wgM7siWp_AjUnY1Rb3YfAoTm6c,2394
+vrt_lss_packer/models/general402.py,sha256=9wnJtNxt5vxOt9URl4n0Up67YpgfrKLwZLLD2uoF3lc,2394
+vrt_lss_packer/models/general403.py,sha256=MdrcS6JiNDxli8t8XrONIgBWAvVIgZ4N2UnA-Ov4BRk,2394
+vrt_lss_packer/models/general404.py,sha256=ckaemBUPTwxUPPGX8cfkRH3jj_PrN-NbGSbbRF1vLWI,2648
+vrt_lss_packer/models/general404_detail.py,sha256=RgTQlu2JpfrySCGzmHWUhdVpzQJ4ZQd3drPad6yKFrs,2052
+vrt_lss_packer/models/general429.py,sha256=5M83W--zXlkuoxX7cmFN1qrfbtX_F2O9UEI79X-syJc,2394
+vrt_lss_packer/models/general500.py,sha256=HYujoZ36l4t8SNSt25crpAN4g1DnL1URCF8Yir23hOg,2394
+vrt_lss_packer/models/pack_result.py,sha256=_sAvxIswIHxSJx9oGlesi38KF9zLrdCbOgsPOhZioo8,5134
+vrt_lss_packer/models/pack_settings.py,sha256=b1R4_wlWNc7q9-1hdpDxGckJqasNia4Vm3XB8kKy6dQ,2202
+vrt_lss_packer/models/pack_statistics.py,sha256=WcHbB7PGmCcKe48ATt4SfqRJbdii3lV_vWz1Cz7RoIo,3316
+vrt_lss_packer/models/pack_task.py,sha256=6l9fUoAJzekq0UfK-pxZiovR3hcxl93BPZVbw9GuFgM,3436
+vrt_lss_packer/models/package.py,sha256=fGj6uihtp7ENra7YSQRLhW6nAnKaz0KylRpdTALmOkE,4012
+vrt_lss_packer/models/package_layout.py,sha256=TYrlmEffFTZcf6UARtnLp-nTMBp64nvw-LT5UNswv6Q,4145
+vrt_lss_packer/models/package_statistics.py,sha256=NLEJRxKUqTstTnHlc-vvevyLGlqups5-diD9Pp19_Xc,3457
+vrt_lss_packer/models/package_type.py,sha256=TRSngk0VWwPMKLV9NveeazSCK6-D7J1aXgbdsz279Xs,878
+vrt_lss_packer/models/product.py,sha256=hkMlcMBhddK9YREzAA0O4F9TEbnzvT0C6Rvr5HMd8_w,3885
+vrt_lss_packer/models/product_group_layout.py,sha256=I9avz3tFlZiVbj5lC5Yh1CF_OJO-5DB5hN_Lo7b3gao,3559
+vrt_lss_packer/models/product_layout.py,sha256=dqyOseBa3W3P121D8H6wKIjR0zabAFBmu7WBLXn6VsY,2669
+vrt_lss_packer/models/render_task.py,sha256=rzQydpF2WZpBbeMjGvAFb9dNlONuKd_eGeDL57MlqcU,3645
+vrt_lss_packer/models/schema_error.py,sha256=Oehe9-F0xASAaLIuiXfNFaT3hMLFJkSFOPXUnFdHyTI,2176
+vrt_lss_packer/models/service_name.py,sha256=B6Siaxy6VkgKU4DfgvFdO9qiVEUV5eI4bMoqyZ5pCPc,676
+vrt_lss_packer/models/tracedata.py,sha256=YX4MqkgU7D6IZzrsbXobbFwbahbxeDOgubexCcbCb_k,3280
+vrt_lss_packer/models/unpacked_items.py,sha256=M3OzjEZ_g5lkQj_kRN-MHKhTyCvj_oSE45mIONqemeY,2227
+vrt_lss_packer/models/validate_result.py,sha256=GYcYvOhKo8sMAxnK6N7kAJaC2OGC0pYRVOQwdM0h3Xo,2897
+vrt_lss_packer/models/version_result.py,sha256=YKM1gGE3RT_vIU1RHv5rCEsXvZ9Dn0jcEcSrwDsNC3k,2505
+vrt_lss_packer-6.5.1990.dist-info/METADATA,sha256=KwGgwC_GfWdCIHkAIA6JtLlFkSvIP_YMZcJ5kbxc83Y,3448
+vrt_lss_packer-6.5.1990.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+vrt_lss_packer-6.5.1990.dist-info/top_level.txt,sha256=GOd336Z7gFS80QqhxJaOmRfCuK5HJbfV_Rchzs7w0HE,15
+vrt_lss_packer-6.5.1990.dist-info/RECORD,,
```

