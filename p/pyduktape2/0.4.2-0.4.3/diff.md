# Comparing `tmp/pyduktape2-0.4.2.tar.gz` & `tmp/pyduktape2-0.4.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyduktape2-0.4.2.tar", last modified: Sat Oct  9 08:17:10 2021, max compression
+gzip compressed data, was "pyduktape2-0.4.3.tar", last modified: Fri May  5 17:37:13 2023, max compression
```

## Comparing `pyduktape2-0.4.2.tar` & `pyduktape2-0.4.3.tar`

### file list

```diff
@@ -1,21 +1,27 @@
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-09 08:17:10.060383 pyduktape2-0.4.2/
--rw-r--r--   0 runner    (1001) docker     (121)      216 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (121)     6176 2021-10-09 08:17:10.056383 pyduktape2-0.4.2/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)     5634 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/README.rst
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-09 08:17:10.052383 pyduktape2-0.4.2/pyduktape2.egg-info/
--rw-r--r--   0 runner    (1001) docker     (121)     6176 2021-10-09 08:17:09.000000 pyduktape2-0.4.2/pyduktape2.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (121)      375 2021-10-09 08:17:10.000000 pyduktape2-0.4.2/pyduktape2.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (121)        1 2021-10-09 08:17:09.000000 pyduktape2-0.4.2/pyduktape2.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (121)        7 2021-10-09 08:17:09.000000 pyduktape2-0.4.2/pyduktape2.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (121)       11 2021-10-09 08:17:09.000000 pyduktape2-0.4.2/pyduktape2.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (121)    23823 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/pyduktape2.pyx
--rw-r--r--   0 runner    (1001) docker     (121)       38 2021-10-09 08:17:10.060383 pyduktape2-0.4.2/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (121)     1179 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (121)        0 2021-10-09 08:17:10.056383 pyduktape2-0.4.2/vendor/
--rw-r--r--   0 runner    (1001) docker     (121)   127208 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duk_config.h
--rw-r--r--   0 runner    (1001) docker     (121)    17420 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duk_module_duktape.c
--rw-r--r--   0 runner    (1001) docker     (121)      538 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duk_module_duktape.h
--rw-r--r--   0 runner    (1001) docker     (121)     3769 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duk_print_alert.c
--rw-r--r--   0 runner    (1001) docker     (121)      354 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duk_print_alert.h
--rw-r--r--   0 runner    (1001) docker     (121)  3675329 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duktape.c
--rw-r--r--   0 runner    (1001) docker     (121)    74951 2021-10-09 08:17:04.000000 pyduktape2-0.4.2/vendor/duktape.h
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-05 17:37:13.647817 pyduktape2-0.4.3/
+-rw-r--r--   0 runner    (1001) docker     (123)      718 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/COPYRIGHT.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    15220 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      312 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     6182 2023-05-05 17:37:13.647817 pyduktape2-0.4.3/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     5634 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/README.rst
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-05 17:37:13.643817 pyduktape2-0.4.3/pyduktape2.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     6182 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)      475 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/not-zip-safe
+-rw-r--r--   0 runner    (1001) docker     (123)        7 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       11 2023-05-05 17:37:13.000000 pyduktape2-0.4.3/pyduktape2.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (123)    23823 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/pyduktape2.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-05-05 17:37:13.647817 pyduktape2-0.4.3/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1231 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-05 17:37:13.643817 pyduktape2-0.4.3/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)    12135 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/tests/test_context.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-05-05 17:37:13.647817 pyduktape2-0.4.3/vendor/
+-rw-r--r--   0 runner    (1001) docker     (123)     1109 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/LICENSE.txt
+-rw-r--r--   0 runner    (1001) docker     (123)   127205 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duk_config.h
+-rw-r--r--   0 runner    (1001) docker     (123)    17420 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duk_module_duktape.c
+-rw-r--r--   0 runner    (1001) docker     (123)      538 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duk_module_duktape.h
+-rw-r--r--   0 runner    (1001) docker     (123)     3769 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duk_print_alert.c
+-rw-r--r--   0 runner    (1001) docker     (123)      354 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duk_print_alert.h
+-rw-r--r--   0 runner    (1001) docker     (123)  3683429 2023-05-05 17:37:06.000000 pyduktape2-0.4.3/vendor/duktape.c
+-rw-r--r--   0 runner    (1001) docker     (123)    75259 2023-05-05 17:37:07.000000 pyduktape2-0.4.3/vendor/duktape.h
```

### Comparing `pyduktape2-0.4.2/PKG-INFO` & `pyduktape2-0.4.3/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 Metadata-Version: 2.1
 Name: pyduktape2
-Version: 0.4.2
+Version: 0.4.3
 Summary: Python integration for the Duktape Javascript interpreter
 Home-page: https://github.com/phith0n/pyduktape2
 Author: Stefano Dissegna
 License: GPL
 Keywords: javascript duktape embed
-Platform: UNKNOWN
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: JavaScript
 Classifier: Topic :: Software Development :: Interpreters
+License-File: LICENSE.txt
 
 Introduction
 ############
 
 Pyduktape is a python wrapper around `Duktape <http://duktape.org/>`_,
 an embeddable Javascript interpreter.
 
@@ -204,9 +204,7 @@
     var items = x.items();
     for (var i = 0; i < items.length; i++) {
         print(items[i][0] + ' = ' + items[i][1]);
     }
     """)
     context.set_globals(x=dict(a=1, b=2))
     context.eval_js('for (var k in x) { print(k + ' = ' + x[k]); }')
-
-
```

### Comparing `pyduktape2-0.4.2/README.rst` & `pyduktape2-0.4.3/README.rst`

 * *Files identical despite different names*

### Comparing `pyduktape2-0.4.2/pyduktape2.egg-info/PKG-INFO` & `pyduktape2-0.4.3/pyduktape2.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 Metadata-Version: 2.1
 Name: pyduktape2
-Version: 0.4.2
+Version: 0.4.3
 Summary: Python integration for the Duktape Javascript interpreter
 Home-page: https://github.com/phith0n/pyduktape2
 Author: Stefano Dissegna
 License: GPL
 Keywords: javascript duktape embed
-Platform: UNKNOWN
 Classifier: Development Status :: 2 - Pre-Alpha
 Classifier: License :: OSI Approved :: GNU General Public License v2 (GPLv2)
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: JavaScript
 Classifier: Topic :: Software Development :: Interpreters
+License-File: LICENSE.txt
 
 Introduction
 ############
 
 Pyduktape is a python wrapper around `Duktape <http://duktape.org/>`_,
 an embeddable Javascript interpreter.
 
@@ -204,9 +204,7 @@
     var items = x.items();
     for (var i = 0; i < items.length; i++) {
         print(items[i][0] + ' = ' + items[i][1]);
     }
     """)
     context.set_globals(x=dict(a=1, b=2))
     context.eval_js('for (var k in x) { print(k + ' = ' + x[k]); }')
-
-
```

### Comparing `pyduktape2-0.4.2/pyduktape2.pyx` & `pyduktape2-0.4.3/pyduktape2.pyx`

 * *Files identical despite different names*

### Comparing `pyduktape2-0.4.2/setup.py` & `pyduktape2-0.4.3/setup.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,15 +12,15 @@
       'pyduktape2',
       ['pyduktape2.pyx']
     )
 ]
 
 setup(
     name='pyduktape2',
-    version='0.4.2',
+    version='0.4.3',
     author='Stefano Dissegna',
     description='Python integration for the Duktape Javascript interpreter',
     long_description=long_description,
     url='https://github.com/phith0n/pyduktape2',
     license='GPL',
     keywords='javascript duktape embed',
     classifiers=[
@@ -31,8 +31,10 @@
         'Topic :: Software Development :: Interpreters',
     ],
     packages=find_packages(exclude=['tests']),
     setup_requires=['setuptools>=18.0', 'Cython'],
     test_suite='tests',
     install_requires=['Cython'],
     ext_modules=extensions,
+    include_package_data=True,
+    zip_safe=False
 )
```

### Comparing `pyduktape2-0.4.2/vendor/duk_config.h` & `pyduktape2-0.4.3/vendor/duk_config.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 /*
  *  duk_config.h configuration header generated by genconfig.py.
  *
- *  Git commit: fffa346eff06a8764b02c31d4336f63a773a95c3
- *  Git describe: v2.6.0
- *  Git branch: v2-maintenance
+ *  Git commit: 03d4d728f8365021de6955c649e6dcd05dcca99f
+ *  Git describe: 03d4d72-dirty
+ *  Git branch: HEAD
  *
  *  Supported platforms:
  *      - Mac OSX, iPhone, Darwin
  *      - Orbis
  *      - OpenBSD
  *      - Generic BSD
  *      - Atari ST TOS
```

### Comparing `pyduktape2-0.4.2/vendor/duk_module_duktape.c` & `pyduktape2-0.4.3/vendor/duk_module_duktape.c`

 * *Files identical despite different names*

### Comparing `pyduktape2-0.4.2/vendor/duk_module_duktape.h` & `pyduktape2-0.4.3/vendor/duk_module_duktape.h`

 * *Files identical despite different names*

### Comparing `pyduktape2-0.4.2/vendor/duk_print_alert.c` & `pyduktape2-0.4.3/vendor/duk_print_alert.c`

 * *Files identical despite different names*

### Comparing `pyduktape2-0.4.2/vendor/duktape.c` & `pyduktape2-0.4.3/vendor/duktape.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 /*
- *  Single source autogenerated distributable for Duktape 2.6.0.
+ *  Single source autogenerated distributable for Duktape 2.7.0.
  *
- *  Git commit fffa346eff06a8764b02c31d4336f63a773a95c3 (v2.6.0).
- *  Git branch v2-maintenance.
+ *  Git commit 03d4d728f8365021de6955c649e6dcd05dcca99f (03d4d72-dirty).
+ *  Git branch HEAD.
  *
  *  See Duktape AUTHORS.rst and LICENSE.txt for copyright and
  *  licensing information.
  */
 
 /* LICENSE.txt */
 /*
 *  ===============
 *  Duktape license
 *  ===============
 *
 *  (http://opensource.org/licenses/MIT)
 *
-*  Copyright (c) 2013-2019 by Duktape authors (see AUTHORS.rst)
+*  Copyright (c) 2013-present by Duktape authors (see AUTHORS.rst)
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
@@ -101,14 +101,20 @@
 *  * TheBrokenRail (https://github.com/TheBrokenRail)
 *  * Jesse Doyle (https://github.com/jessedoyle)
 *  * Gero Kuehn (https://github.com/dc6jgk)
 *  * James Swift (https://github.com/phraemer)
 *  * Luis de Bethencourt (https://github.com/luisbg)
 *  * Ian Whyman (https://github.com/v00d00)
 *  * Rick Sayre (https://github.com/whorfin)
+*  * Craig Leres (https://github.com/leres)
+*  * Maurici Abad (https://github.com/mauriciabad)
+*  * Nancy Li (https://github.com/NancyLi1013)
+*  * William Parks (https://github.com/WilliamParks)
+*  * Sam Hellawell (https://github.com/samhellawell)
+*  * Vladislavs Sokurenko (https://github.com/sokurenko)
 *
 *  Other contributions
 *  ===================
 *
 *  The following people have contributed something other than code (e.g. reported
 *  bugs, provided ideas, etc; roughly in order of appearance):
 *
@@ -265,144 +271,150 @@
 #if defined(DUK_USE_64BIT_OPS)
 	duk_uint64_t ull[1];
 #endif
 	duk_uint32_t ui[2];
 	duk_uint16_t us[4];
 	duk_uint8_t uc[8];
 #if defined(DUK_USE_PACKED_TVAL)
-	void *vp[2];  /* used by packed duk_tval, assumes sizeof(void *) == 4 */
+	void *vp[2]; /* used by packed duk_tval, assumes sizeof(void *) == 4 */
 #endif
 };
 
 typedef union duk_double_union duk_double_union;
 
 /*
  *  Indexes of various types with respect to big endian (logical) layout
  */
 
 #if defined(DUK_USE_DOUBLE_LE)
 #if defined(DUK_USE_64BIT_OPS)
-#define DUK_DBL_IDX_ULL0   0
+#define DUK_DBL_IDX_ULL0 0
 #endif
-#define DUK_DBL_IDX_UI0    1
-#define DUK_DBL_IDX_UI1    0
-#define DUK_DBL_IDX_US0    3
-#define DUK_DBL_IDX_US1    2
-#define DUK_DBL_IDX_US2    1
-#define DUK_DBL_IDX_US3    0
-#define DUK_DBL_IDX_UC0    7
-#define DUK_DBL_IDX_UC1    6
-#define DUK_DBL_IDX_UC2    5
-#define DUK_DBL_IDX_UC3    4
-#define DUK_DBL_IDX_UC4    3
-#define DUK_DBL_IDX_UC5    2
-#define DUK_DBL_IDX_UC6    1
-#define DUK_DBL_IDX_UC7    0
-#define DUK_DBL_IDX_VP0    DUK_DBL_IDX_UI0  /* packed tval */
-#define DUK_DBL_IDX_VP1    DUK_DBL_IDX_UI1  /* packed tval */
+#define DUK_DBL_IDX_UI0 1
+#define DUK_DBL_IDX_UI1 0
+#define DUK_DBL_IDX_US0 3
+#define DUK_DBL_IDX_US1 2
+#define DUK_DBL_IDX_US2 1
+#define DUK_DBL_IDX_US3 0
+#define DUK_DBL_IDX_UC0 7
+#define DUK_DBL_IDX_UC1 6
+#define DUK_DBL_IDX_UC2 5
+#define DUK_DBL_IDX_UC3 4
+#define DUK_DBL_IDX_UC4 3
+#define DUK_DBL_IDX_UC5 2
+#define DUK_DBL_IDX_UC6 1
+#define DUK_DBL_IDX_UC7 0
+#define DUK_DBL_IDX_VP0 DUK_DBL_IDX_UI0 /* packed tval */
+#define DUK_DBL_IDX_VP1 DUK_DBL_IDX_UI1 /* packed tval */
 #elif defined(DUK_USE_DOUBLE_BE)
 #if defined(DUK_USE_64BIT_OPS)
-#define DUK_DBL_IDX_ULL0   0
+#define DUK_DBL_IDX_ULL0 0
 #endif
-#define DUK_DBL_IDX_UI0    0
-#define DUK_DBL_IDX_UI1    1
-#define DUK_DBL_IDX_US0    0
-#define DUK_DBL_IDX_US1    1
-#define DUK_DBL_IDX_US2    2
-#define DUK_DBL_IDX_US3    3
-#define DUK_DBL_IDX_UC0    0
-#define DUK_DBL_IDX_UC1    1
-#define DUK_DBL_IDX_UC2    2
-#define DUK_DBL_IDX_UC3    3
-#define DUK_DBL_IDX_UC4    4
-#define DUK_DBL_IDX_UC5    5
-#define DUK_DBL_IDX_UC6    6
-#define DUK_DBL_IDX_UC7    7
-#define DUK_DBL_IDX_VP0    DUK_DBL_IDX_UI0  /* packed tval */
-#define DUK_DBL_IDX_VP1    DUK_DBL_IDX_UI1  /* packed tval */
+#define DUK_DBL_IDX_UI0 0
+#define DUK_DBL_IDX_UI1 1
+#define DUK_DBL_IDX_US0 0
+#define DUK_DBL_IDX_US1 1
+#define DUK_DBL_IDX_US2 2
+#define DUK_DBL_IDX_US3 3
+#define DUK_DBL_IDX_UC0 0
+#define DUK_DBL_IDX_UC1 1
+#define DUK_DBL_IDX_UC2 2
+#define DUK_DBL_IDX_UC3 3
+#define DUK_DBL_IDX_UC4 4
+#define DUK_DBL_IDX_UC5 5
+#define DUK_DBL_IDX_UC6 6
+#define DUK_DBL_IDX_UC7 7
+#define DUK_DBL_IDX_VP0 DUK_DBL_IDX_UI0 /* packed tval */
+#define DUK_DBL_IDX_VP1 DUK_DBL_IDX_UI1 /* packed tval */
 #elif defined(DUK_USE_DOUBLE_ME)
 #if defined(DUK_USE_64BIT_OPS)
-#define DUK_DBL_IDX_ULL0   0  /* not directly applicable, byte order differs from a double */
+#define DUK_DBL_IDX_ULL0 0 /* not directly applicable, byte order differs from a double */
 #endif
-#define DUK_DBL_IDX_UI0    0
-#define DUK_DBL_IDX_UI1    1
-#define DUK_DBL_IDX_US0    1
-#define DUK_DBL_IDX_US1    0
-#define DUK_DBL_IDX_US2    3
-#define DUK_DBL_IDX_US3    2
-#define DUK_DBL_IDX_UC0    3
-#define DUK_DBL_IDX_UC1    2
-#define DUK_DBL_IDX_UC2    1
-#define DUK_DBL_IDX_UC3    0
-#define DUK_DBL_IDX_UC4    7
-#define DUK_DBL_IDX_UC5    6
-#define DUK_DBL_IDX_UC6    5
-#define DUK_DBL_IDX_UC7    4
-#define DUK_DBL_IDX_VP0    DUK_DBL_IDX_UI0  /* packed tval */
-#define DUK_DBL_IDX_VP1    DUK_DBL_IDX_UI1  /* packed tval */
+#define DUK_DBL_IDX_UI0 0
+#define DUK_DBL_IDX_UI1 1
+#define DUK_DBL_IDX_US0 1
+#define DUK_DBL_IDX_US1 0
+#define DUK_DBL_IDX_US2 3
+#define DUK_DBL_IDX_US3 2
+#define DUK_DBL_IDX_UC0 3
+#define DUK_DBL_IDX_UC1 2
+#define DUK_DBL_IDX_UC2 1
+#define DUK_DBL_IDX_UC3 0
+#define DUK_DBL_IDX_UC4 7
+#define DUK_DBL_IDX_UC5 6
+#define DUK_DBL_IDX_UC6 5
+#define DUK_DBL_IDX_UC7 4
+#define DUK_DBL_IDX_VP0 DUK_DBL_IDX_UI0 /* packed tval */
+#define DUK_DBL_IDX_VP1 DUK_DBL_IDX_UI1 /* packed tval */
 #else
 #error internal error
 #endif
 
 /*
  *  Helper macros for reading/writing memory representation parts, used
  *  by duk_numconv.c and duk_tval.h.
  */
 
-#define DUK_DBLUNION_SET_DOUBLE(u,v)  do {  \
+#define DUK_DBLUNION_SET_DOUBLE(u, v) \
+	do { \
 		(u)->d = (v); \
 	} while (0)
 
-#define DUK_DBLUNION_SET_HIGH32(u,v)  do {  \
+#define DUK_DBLUNION_SET_HIGH32(u, v) \
+	do { \
 		(u)->ui[DUK_DBL_IDX_UI0] = (duk_uint32_t) (v); \
 	} while (0)
 
 #if defined(DUK_USE_64BIT_OPS)
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u,v)  do { \
+#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u, v) \
+	do { \
 		(u)->ull[DUK_DBL_IDX_ULL0] = (duk_uint64_t) (v); \
 	} while (0)
 #else
-#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u,v)  do { \
+#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u, v) \
+	do { \
 		(u)->ull[DUK_DBL_IDX_ULL0] = ((duk_uint64_t) (v)) << 32; \
 	} while (0)
 #endif
-#else  /* DUK_USE_64BIT_OPS */
-#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u,v)  do { \
+#else /* DUK_USE_64BIT_OPS */
+#define DUK_DBLUNION_SET_HIGH32_ZERO_LOW32(u, v) \
+	do { \
 		(u)->ui[DUK_DBL_IDX_UI0] = (duk_uint32_t) (v); \
 		(u)->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) 0; \
 	} while (0)
-#endif  /* DUK_USE_64BIT_OPS */
+#endif /* DUK_USE_64BIT_OPS */
 
-#define DUK_DBLUNION_SET_LOW32(u,v)  do {  \
+#define DUK_DBLUNION_SET_LOW32(u, v) \
+	do { \
 		(u)->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (v); \
 	} while (0)
 
-#define DUK_DBLUNION_GET_DOUBLE(u)  ((u)->d)
-#define DUK_DBLUNION_GET_HIGH32(u)  ((u)->ui[DUK_DBL_IDX_UI0])
-#define DUK_DBLUNION_GET_LOW32(u)   ((u)->ui[DUK_DBL_IDX_UI1])
+#define DUK_DBLUNION_GET_DOUBLE(u) ((u)->d)
+#define DUK_DBLUNION_GET_HIGH32(u) ((u)->ui[DUK_DBL_IDX_UI0])
+#define DUK_DBLUNION_GET_LOW32(u)  ((u)->ui[DUK_DBL_IDX_UI1])
 
 #if defined(DUK_USE_64BIT_OPS)
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK_DBLUNION_SET_UINT64(u,v)  do { \
+#define DUK_DBLUNION_SET_UINT64(u, v) \
+	do { \
 		(u)->ui[DUK_DBL_IDX_UI0] = (duk_uint32_t) ((v) >> 32); \
 		(u)->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (v); \
 	} while (0)
-#define DUK_DBLUNION_GET_UINT64(u) \
-	((((duk_uint64_t) (u)->ui[DUK_DBL_IDX_UI0]) << 32) | \
-	 ((duk_uint64_t) (u)->ui[DUK_DBL_IDX_UI1]))
+#define DUK_DBLUNION_GET_UINT64(u) ((((duk_uint64_t) (u)->ui[DUK_DBL_IDX_UI0]) << 32) | ((duk_uint64_t) (u)->ui[DUK_DBL_IDX_UI1]))
 #else
-#define DUK_DBLUNION_SET_UINT64(u,v)  do { \
+#define DUK_DBLUNION_SET_UINT64(u, v) \
+	do { \
 		(u)->ull[DUK_DBL_IDX_ULL0] = (duk_uint64_t) (v); \
 	} while (0)
-#define DUK_DBLUNION_GET_UINT64(u)  ((u)->ull[DUK_DBL_IDX_ULL0])
+#define DUK_DBLUNION_GET_UINT64(u) ((u)->ull[DUK_DBL_IDX_ULL0])
 #endif
-#define DUK_DBLUNION_SET_INT64(u,v) DUK_DBLUNION_SET_UINT64((u), (duk_uint64_t) (v))
-#define DUK_DBLUNION_GET_INT64(u)   ((duk_int64_t) DUK_DBLUNION_GET_UINT64((u)))
-#endif  /* DUK_USE_64BIT_OPS */
+#define DUK_DBLUNION_SET_INT64(u, v) DUK_DBLUNION_SET_UINT64((u), (duk_uint64_t) (v))
+#define DUK_DBLUNION_GET_INT64(u)    ((duk_int64_t) DUK_DBLUNION_GET_UINT64((u)))
+#endif /* DUK_USE_64BIT_OPS */
 
 /*
  *  Double NaN manipulation macros related to NaN normalization needed when
  *  using the packed duk_tval representation.  NaN normalization is necessary
  *  to keep double values compatible with the duk_tval format.
  *
  *  When packed duk_tval is used, the NaN space is used to store pointers
@@ -425,193 +437,182 @@
  *  swapped; hence the #if defined()s below for ULL writes with DUK_USE_DOUBLE_ME.
  *  This is not full ARM support but suffices for some environments.
  */
 
 #if defined(DUK_USE_64BIT_OPS)
 #if defined(DUK_USE_DOUBLE_ME)
 /* Macros for 64-bit ops + mixed endian doubles. */
-#define DUK__DBLUNION_SET_NAN_FULL(u)  do { \
+#define DUK__DBLUNION_SET_NAN_FULL(u) \
+	do { \
 		(u)->ull[DUK_DBL_IDX_ULL0] = DUK_U64_CONSTANT(0x000000007ff80000); \
 	} while (0)
 #define DUK__DBLUNION_IS_NAN_FULL(u) \
 	((((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0x000000007ff00000)) == DUK_U64_CONSTANT(0x000000007ff00000)) && \
 	 ((((u)->ull[DUK_DBL_IDX_ULL0]) & DUK_U64_CONSTANT(0xffffffff000fffff)) != 0))
-#define DUK__DBLUNION_IS_NORMALIZED_NAN_FULL(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x000000007ff80000))
+#define DUK__DBLUNION_IS_NORMALIZED_NAN_FULL(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x000000007ff80000))
 #define DUK__DBLUNION_IS_ANYINF(u) \
 	(((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0xffffffff7fffffff)) == DUK_U64_CONSTANT(0x000000007ff00000))
-#define DUK__DBLUNION_IS_POSINF(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x000000007ff00000))
-#define DUK__DBLUNION_IS_NEGINF(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x00000000fff00000))
+#define DUK__DBLUNION_IS_POSINF(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x000000007ff00000))
+#define DUK__DBLUNION_IS_NEGINF(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x00000000fff00000))
 #define DUK__DBLUNION_IS_ANYZERO(u) \
 	(((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0xffffffff7fffffff)) == DUK_U64_CONSTANT(0x0000000000000000))
-#define DUK__DBLUNION_IS_POSZERO(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000000000000))
-#define DUK__DBLUNION_IS_NEGZERO(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000080000000))
+#define DUK__DBLUNION_IS_POSZERO(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000000000000))
+#define DUK__DBLUNION_IS_NEGZERO(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000080000000))
 #else
 /* Macros for 64-bit ops + big/little endian doubles. */
-#define DUK__DBLUNION_SET_NAN_FULL(u)  do { \
+#define DUK__DBLUNION_SET_NAN_FULL(u) \
+	do { \
 		(u)->ull[DUK_DBL_IDX_ULL0] = DUK_U64_CONSTANT(0x7ff8000000000000); \
 	} while (0)
 #define DUK__DBLUNION_IS_NAN_FULL(u) \
 	((((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0x7ff0000000000000)) == DUK_U64_CONSTANT(0x7ff0000000000000)) && \
 	 ((((u)->ull[DUK_DBL_IDX_ULL0]) & DUK_U64_CONSTANT(0x000fffffffffffff)) != 0))
-#define DUK__DBLUNION_IS_NORMALIZED_NAN_FULL(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x7ff8000000000000))
+#define DUK__DBLUNION_IS_NORMALIZED_NAN_FULL(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x7ff8000000000000))
 #define DUK__DBLUNION_IS_ANYINF(u) \
 	(((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0x7fffffffffffffff)) == DUK_U64_CONSTANT(0x7ff0000000000000))
-#define DUK__DBLUNION_IS_POSINF(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x7ff0000000000000))
-#define DUK__DBLUNION_IS_NEGINF(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0xfff0000000000000))
+#define DUK__DBLUNION_IS_POSINF(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x7ff0000000000000))
+#define DUK__DBLUNION_IS_NEGINF(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0xfff0000000000000))
 #define DUK__DBLUNION_IS_ANYZERO(u) \
 	(((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0x7fffffffffffffff)) == DUK_U64_CONSTANT(0x0000000000000000))
-#define DUK__DBLUNION_IS_POSZERO(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000000000000))
-#define DUK__DBLUNION_IS_NEGZERO(u) \
-	((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x8000000000000000))
+#define DUK__DBLUNION_IS_POSZERO(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x0000000000000000))
+#define DUK__DBLUNION_IS_NEGZERO(u) ((u)->ull[DUK_DBL_IDX_ULL0] == DUK_U64_CONSTANT(0x8000000000000000))
 #endif
-#else  /* DUK_USE_64BIT_OPS */
+#else /* DUK_USE_64BIT_OPS */
 /* Macros for no 64-bit ops, any endianness. */
-#define DUK__DBLUNION_SET_NAN_FULL(u)  do { \
+#define DUK__DBLUNION_SET_NAN_FULL(u) \
+	do { \
 		(u)->ui[DUK_DBL_IDX_UI0] = (duk_uint32_t) 0x7ff80000UL; \
 		(u)->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) 0x00000000UL; \
 	} while (0)
 #define DUK__DBLUNION_IS_NAN_FULL(u) \
 	((((u)->ui[DUK_DBL_IDX_UI0] & 0x7ff00000UL) == 0x7ff00000UL) && \
-	 (((u)->ui[DUK_DBL_IDX_UI0] & 0x000fffffUL) != 0 || \
-          (u)->ui[DUK_DBL_IDX_UI1] != 0))
+	 (((u)->ui[DUK_DBL_IDX_UI0] & 0x000fffffUL) != 0 || (u)->ui[DUK_DBL_IDX_UI1] != 0))
 #define DUK__DBLUNION_IS_NORMALIZED_NAN_FULL(u) \
-	(((u)->ui[DUK_DBL_IDX_UI0] == 0x7ff80000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+	(((u)->ui[DUK_DBL_IDX_UI0] == 0x7ff80000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
 #define DUK__DBLUNION_IS_ANYINF(u) \
-	((((u)->ui[DUK_DBL_IDX_UI0] & 0x7fffffffUL) == 0x7ff00000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
-#define DUK__DBLUNION_IS_POSINF(u) \
-	(((u)->ui[DUK_DBL_IDX_UI0] == 0x7ff00000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
-#define DUK__DBLUNION_IS_NEGINF(u) \
-	(((u)->ui[DUK_DBL_IDX_UI0] == 0xfff00000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+	((((u)->ui[DUK_DBL_IDX_UI0] & 0x7fffffffUL) == 0x7ff00000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+#define DUK__DBLUNION_IS_POSINF(u) (((u)->ui[DUK_DBL_IDX_UI0] == 0x7ff00000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+#define DUK__DBLUNION_IS_NEGINF(u) (((u)->ui[DUK_DBL_IDX_UI0] == 0xfff00000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
 #define DUK__DBLUNION_IS_ANYZERO(u) \
-	((((u)->ui[DUK_DBL_IDX_UI0] & 0x7fffffffUL) == 0x00000000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
-#define DUK__DBLUNION_IS_POSZERO(u) \
-	(((u)->ui[DUK_DBL_IDX_UI0] == 0x00000000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
-#define DUK__DBLUNION_IS_NEGZERO(u) \
-	(((u)->ui[DUK_DBL_IDX_UI0] == 0x80000000UL) && \
-	 ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
-#endif  /* DUK_USE_64BIT_OPS */
+	((((u)->ui[DUK_DBL_IDX_UI0] & 0x7fffffffUL) == 0x00000000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+#define DUK__DBLUNION_IS_POSZERO(u) (((u)->ui[DUK_DBL_IDX_UI0] == 0x00000000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+#define DUK__DBLUNION_IS_NEGZERO(u) (((u)->ui[DUK_DBL_IDX_UI0] == 0x80000000UL) && ((u)->ui[DUK_DBL_IDX_UI1] == 0x00000000UL))
+#endif /* DUK_USE_64BIT_OPS */
 
-#define DUK__DBLUNION_SET_NAN_NOTFULL(u)  do { \
+#define DUK__DBLUNION_SET_NAN_NOTFULL(u) \
+	do { \
 		(u)->us[DUK_DBL_IDX_US0] = 0x7ff8UL; \
 	} while (0)
 
 #define DUK__DBLUNION_IS_NAN_NOTFULL(u) \
 	/* E == 0x7ff, topmost four bits of F != 0 => assume NaN */ \
-	((((u)->us[DUK_DBL_IDX_US0] & 0x7ff0UL) == 0x7ff0UL) && \
-	 (((u)->us[DUK_DBL_IDX_US0] & 0x000fUL) != 0x0000UL))
+	((((u)->us[DUK_DBL_IDX_US0] & 0x7ff0UL) == 0x7ff0UL) && (((u)->us[DUK_DBL_IDX_US0] & 0x000fUL) != 0x0000UL))
 
 #define DUK__DBLUNION_IS_NORMALIZED_NAN_NOTFULL(u) \
 	/* E == 0x7ff, F == 8 => normalized NaN */ \
 	((u)->us[DUK_DBL_IDX_US0] == 0x7ff8UL)
 
-#define DUK__DBLUNION_NORMALIZE_NAN_CHECK_FULL(u)  do { \
+#define DUK__DBLUNION_NORMALIZE_NAN_CHECK_FULL(u) \
+	do { \
 		if (DUK__DBLUNION_IS_NAN_FULL((u))) { \
 			DUK__DBLUNION_SET_NAN_FULL((u)); \
 		} \
 	} while (0)
 
-#define DUK__DBLUNION_NORMALIZE_NAN_CHECK_NOTFULL(u)  do { \
+#define DUK__DBLUNION_NORMALIZE_NAN_CHECK_NOTFULL(u) \
+	do { \
 		/* Check must be full. */ \
 		if (DUK__DBLUNION_IS_NAN_FULL((u))) { \
 			DUK__DBLUNION_SET_NAN_NOTFULL((u)); \
 		} \
 	} while (0)
 
 /* Concrete macros for NaN handling used by the implementation internals.
  * Chosen so that they match the duk_tval representation: with a packed
  * duk_tval, ensure NaNs are properly normalized; with a non-packed duk_tval
  * these are essentially NOPs.
  */
 
 #if defined(DUK_USE_PACKED_TVAL)
-#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u)  DUK__DBLUNION_NORMALIZE_NAN_CHECK_FULL((u))
-#define DUK_DBLUNION_IS_NAN(u)               DUK__DBLUNION_IS_NAN_FULL((u))
-#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)    DUK__DBLUNION_IS_NORMALIZED_NAN_FULL((u))
-#define DUK_DBLUNION_SET_NAN(d)              DUK__DBLUNION_SET_NAN_FULL((d))
+#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u) DUK__DBLUNION_NORMALIZE_NAN_CHECK_FULL((u))
+#define DUK_DBLUNION_IS_NAN(u)              DUK__DBLUNION_IS_NAN_FULL((u))
+#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)   DUK__DBLUNION_IS_NORMALIZED_NAN_FULL((u))
+#define DUK_DBLUNION_SET_NAN(d)             DUK__DBLUNION_SET_NAN_FULL((d))
 #if 0
-#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u)  DUK__DBLUNION_NORMALIZE_NAN_CHECK_NOTFULL((u))
-#define DUK_DBLUNION_IS_NAN(u)               DUK__DBLUNION_IS_NAN_NOTFULL((u))
-#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)    DUK__DBLUNION_IS_NORMALIZED_NAN_NOTFULL((u))
-#define DUK_DBLUNION_SET_NAN(d)              DUK__DBLUNION_SET_NAN_NOTFULL((d))
+#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u) DUK__DBLUNION_NORMALIZE_NAN_CHECK_NOTFULL((u))
+#define DUK_DBLUNION_IS_NAN(u)              DUK__DBLUNION_IS_NAN_NOTFULL((u))
+#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)   DUK__DBLUNION_IS_NORMALIZED_NAN_NOTFULL((u))
+#define DUK_DBLUNION_SET_NAN(d)             DUK__DBLUNION_SET_NAN_NOTFULL((d))
 #endif
 #define DUK_DBLUNION_IS_NORMALIZED(u) \
-	(!DUK_DBLUNION_IS_NAN((u)) ||  /* either not a NaN */ \
-	 DUK_DBLUNION_IS_NORMALIZED_NAN((u)))  /* or is a normalized NaN */
-#else  /* DUK_USE_PACKED_TVAL */
-#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u)  /* nop: no need to normalize */
-#define DUK_DBLUNION_IS_NAN(u)               DUK__DBLUNION_IS_NAN_FULL((u))  /* (DUK_ISNAN((u)->d)) */
-#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)    DUK__DBLUNION_IS_NAN_FULL((u))  /* (DUK_ISNAN((u)->d)) */
-#define DUK_DBLUNION_IS_NORMALIZED(u)        1  /* all doubles are considered normalized */
-#define DUK_DBLUNION_SET_NAN(u)  do { \
+	(!DUK_DBLUNION_IS_NAN((u)) || /* either not a NaN */ \
+	 DUK_DBLUNION_IS_NORMALIZED_NAN((u))) /* or is a normalized NaN */
+#else /* DUK_USE_PACKED_TVAL */
+#define DUK_DBLUNION_NORMALIZE_NAN_CHECK(u) /* nop: no need to normalize */
+#define DUK_DBLUNION_IS_NAN(u)              DUK__DBLUNION_IS_NAN_FULL((u)) /* (DUK_ISNAN((u)->d)) */
+#define DUK_DBLUNION_IS_NORMALIZED_NAN(u)   DUK__DBLUNION_IS_NAN_FULL((u)) /* (DUK_ISNAN((u)->d)) */
+#define DUK_DBLUNION_IS_NORMALIZED(u)       1 /* all doubles are considered normalized */
+#define DUK_DBLUNION_SET_NAN(u) \
+	do { \
 		/* in non-packed representation we don't care about which NaN is used */ \
 		(u)->d = DUK_DOUBLE_NAN; \
 	} while (0)
-#endif  /* DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_PACKED_TVAL */
 
 #define DUK_DBLUNION_IS_ANYINF(u) DUK__DBLUNION_IS_ANYINF((u))
 #define DUK_DBLUNION_IS_POSINF(u) DUK__DBLUNION_IS_POSINF((u))
 #define DUK_DBLUNION_IS_NEGINF(u) DUK__DBLUNION_IS_NEGINF((u))
 
 #define DUK_DBLUNION_IS_ANYZERO(u) DUK__DBLUNION_IS_ANYZERO((u))
 #define DUK_DBLUNION_IS_POSZERO(u) DUK__DBLUNION_IS_POSZERO((u))
 #define DUK_DBLUNION_IS_NEGZERO(u) DUK__DBLUNION_IS_NEGZERO((u))
 
 /* XXX: native 64-bit byteswaps when available */
 
 /* 64-bit byteswap, same operation independent of target endianness. */
-#define DUK_DBLUNION_BSWAP64(u) do { \
+#define DUK_DBLUNION_BSWAP64(u) \
+	do { \
 		duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; \
 		duk__bswaptmp1 = (u)->ui[0]; \
 		duk__bswaptmp2 = (u)->ui[1]; \
 		duk__bswaptmp1 = DUK_BSWAP32(duk__bswaptmp1); \
 		duk__bswaptmp2 = DUK_BSWAP32(duk__bswaptmp2); \
 		(u)->ui[0] = duk__bswaptmp2; \
 		(u)->ui[1] = duk__bswaptmp1; \
 	} while (0)
 
 /* Byteswap an IEEE double in the duk_double_union from host to network
  * order.  For a big endian target this is a no-op.
  */
 #if defined(DUK_USE_DOUBLE_LE)
-#define DUK_DBLUNION_DOUBLE_HTON(u) do { \
+#define DUK_DBLUNION_DOUBLE_HTON(u) \
+	do { \
 		duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; \
 		duk__bswaptmp1 = (u)->ui[0]; \
 		duk__bswaptmp2 = (u)->ui[1]; \
 		duk__bswaptmp1 = DUK_BSWAP32(duk__bswaptmp1); \
 		duk__bswaptmp2 = DUK_BSWAP32(duk__bswaptmp2); \
 		(u)->ui[0] = duk__bswaptmp2; \
 		(u)->ui[1] = duk__bswaptmp1; \
 	} while (0)
 #elif defined(DUK_USE_DOUBLE_ME)
-#define DUK_DBLUNION_DOUBLE_HTON(u) do { \
+#define DUK_DBLUNION_DOUBLE_HTON(u) \
+	do { \
 		duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; \
 		duk__bswaptmp1 = (u)->ui[0]; \
 		duk__bswaptmp2 = (u)->ui[1]; \
 		duk__bswaptmp1 = DUK_BSWAP32(duk__bswaptmp1); \
 		duk__bswaptmp2 = DUK_BSWAP32(duk__bswaptmp2); \
 		(u)->ui[0] = duk__bswaptmp1; \
 		(u)->ui[1] = duk__bswaptmp2; \
 	} while (0)
 #elif defined(DUK_USE_DOUBLE_BE)
-#define DUK_DBLUNION_DOUBLE_HTON(u) do { } while (0)
+#define DUK_DBLUNION_DOUBLE_HTON(u) \
+	do { \
+	} while (0)
 #else
 #error internal error, double endianness insane
 #endif
 
 /* Reverse operation is the same. */
 #define DUK_DBLUNION_DOUBLE_NTOH(u) DUK_DBLUNION_DOUBLE_HTON((u))
 
@@ -620,15 +621,15 @@
 #define DUK_DBLUNION_HAS_SIGNBIT(u) (((u)->ull[DUK_DBL_IDX_ULL0] & DUK_U64_CONSTANT(0x8000000000000000)) != 0)
 #define DUK_DBLUNION_GET_SIGNBIT(u) (((u)->ull[DUK_DBL_IDX_ULL0] >> 63U))
 #else
 #define DUK_DBLUNION_HAS_SIGNBIT(u) (((u)->ui[DUK_DBL_IDX_UI0] & 0x80000000UL) != 0)
 #define DUK_DBLUNION_GET_SIGNBIT(u) (((u)->ui[DUK_DBL_IDX_UI0] >> 31U))
 #endif
 
-#endif  /* DUK_DBLUNION_H_INCLUDED */
+#endif /* DUK_DBLUNION_H_INCLUDED */
 /* #include duk_fltunion.h */
 #line 1 "duk_fltunion.h"
 /*
  *  Union to access IEEE float memory representation.
  */
 
 #if !defined(DUK_FLTUNION_H_INCLUDED)
@@ -642,47 +643,47 @@
 	duk_uint16_t us[2];
 	duk_uint8_t uc[4];
 };
 
 typedef union duk_float_union duk_float_union;
 
 #if defined(DUK_USE_DOUBLE_LE) || defined(DUK_USE_DOUBLE_ME)
-#define DUK_FLT_IDX_UI0    0
-#define DUK_FLT_IDX_US0    1
-#define DUK_FLT_IDX_US1    0
-#define DUK_FLT_IDX_UC0    3
-#define DUK_FLT_IDX_UC1    2
-#define DUK_FLT_IDX_UC2    1
-#define DUK_FLT_IDX_UC3    0
+#define DUK_FLT_IDX_UI0 0
+#define DUK_FLT_IDX_US0 1
+#define DUK_FLT_IDX_US1 0
+#define DUK_FLT_IDX_UC0 3
+#define DUK_FLT_IDX_UC1 2
+#define DUK_FLT_IDX_UC2 1
+#define DUK_FLT_IDX_UC3 0
 #elif defined(DUK_USE_DOUBLE_BE)
-#define DUK_FLT_IDX_UI0    0
-#define DUK_FLT_IDX_US0    0
-#define DUK_FLT_IDX_US1    1
-#define DUK_FLT_IDX_UC0    0
-#define DUK_FLT_IDX_UC1    1
-#define DUK_FLT_IDX_UC2    2
-#define DUK_FLT_IDX_UC3    3
+#define DUK_FLT_IDX_UI0 0
+#define DUK_FLT_IDX_US0 0
+#define DUK_FLT_IDX_US1 1
+#define DUK_FLT_IDX_UC0 0
+#define DUK_FLT_IDX_UC1 1
+#define DUK_FLT_IDX_UC2 2
+#define DUK_FLT_IDX_UC3 3
 #else
 #error internal error
 #endif
 
-#endif  /* DUK_FLTUNION_H_INCLUDED */
+#endif /* DUK_FLTUNION_H_INCLUDED */
 /* #include duk_replacements.h */
 #line 1 "duk_replacements.h"
 #if !defined(DUK_REPLACEMENTS_H_INCLUDED)
 #define DUK_REPLACEMENTS_H_INCLUDED
 
 #if !defined(DUK_SINGLE_FILE)
 #if defined(DUK_USE_COMPUTED_INFINITY)
 DUK_INTERNAL_DECL double duk_computed_infinity;
 #endif
 #if defined(DUK_USE_COMPUTED_NAN)
 DUK_INTERNAL_DECL double duk_computed_nan;
 #endif
-#endif  /* !DUK_SINGLE_FILE */
+#endif /* !DUK_SINGLE_FILE */
 
 #if defined(DUK_USE_REPL_FPCLASSIFY)
 DUK_INTERNAL_DECL int duk_repl_fpclassify(double x);
 #endif
 #if defined(DUK_USE_REPL_SIGNBIT)
 DUK_INTERNAL_DECL int duk_repl_signbit(double x);
 #endif
@@ -692,15 +693,15 @@
 #if defined(DUK_USE_REPL_ISNAN)
 DUK_INTERNAL_DECL int duk_repl_isnan(double x);
 #endif
 #if defined(DUK_USE_REPL_ISINF)
 DUK_INTERNAL_DECL int duk_repl_isinf(double x);
 #endif
 
-#endif  /* DUK_REPLACEMENTS_H_INCLUDED */
+#endif /* DUK_REPLACEMENTS_H_INCLUDED */
 /* #include duk_jmpbuf.h */
 #line 1 "duk_jmpbuf.h"
 /*
  *  Wrapper for jmp_buf.
  *
  *  This is used because jmp_buf is an array type for backward compatibility.
  *  Wrapping jmp_buf in a struct makes pointer references, sizeof, etc,
@@ -710,23 +711,23 @@
  */
 
 #if !defined(DUK_JMPBUF_H_INCLUDED)
 #define DUK_JMPBUF_H_INCLUDED
 
 #if defined(DUK_USE_CPP_EXCEPTIONS)
 struct duk_jmpbuf {
-	duk_small_int_t dummy;  /* unused */
+	duk_small_int_t dummy; /* unused */
 };
 #else
 struct duk_jmpbuf {
 	DUK_JMPBUF_TYPE jb;
 };
 #endif
 
-#endif  /* DUK_JMPBUF_H_INCLUDED */
+#endif /* DUK_JMPBUF_H_INCLUDED */
 /* #include duk_exception.h */
 #line 1 "duk_exception.h"
 /*
  *  Exceptions for Duktape internal throws when C++ exceptions are used
  *  for long control transfers.
  */
 
@@ -745,20 +746,21 @@
 
 /* Fatal error, thrown as a specific C++ exception with C++ exceptions
  * enabled.  It is unsafe to continue; doing so may cause crashes or memory
  * leaks.  This is intended to be either uncaught, or caught by user code
  * aware of the "unsafe to continue" semantics.
  */
 class duk_fatal_exception : public virtual std::runtime_error {
- public:
-	duk_fatal_exception(const char *message) : std::runtime_error(message) {}
+      public:
+	duk_fatal_exception(const char *message) : std::runtime_error(message) {
+	}
 };
 #endif
 
-#endif  /* DUK_EXCEPTION_H_INCLUDED */
+#endif /* DUK_EXCEPTION_H_INCLUDED */
 /* #include duk_forwdecl.h */
 #line 1 "duk_forwdecl.h"
 /*
  *  Forward declarations for all Duktape structures.
  */
 
 #if !defined(DUK_FORWDECL_H_INCLUDED)
@@ -886,15 +888,15 @@
 typedef struct duk_compiler_instr duk_compiler_instr;
 typedef struct duk_compiler_func duk_compiler_func;
 typedef struct duk_compiler_ctx duk_compiler_ctx;
 
 typedef struct duk_re_matcher_ctx duk_re_matcher_ctx;
 typedef struct duk_re_compiler_ctx duk_re_compiler_ctx;
 
-#endif  /* DUK_FORWDECL_H_INCLUDED */
+#endif /* DUK_FORWDECL_H_INCLUDED */
 /* #include duk_tval.h */
 #line 1 "duk_tval.h"
 /*
  *  Tagged type definition (duk_tval) and accessor macros.
  *
  *  Access all fields through the accessor macros, as the representation
  *  is quite tricky.
@@ -932,256 +934,285 @@
 	duk_uint16_t a;
 	duk_uint16_t b;
 	duk_uint16_t c;
 	duk_uint16_t d;
 } duk_tval_unused;
 
 /* tags */
-#define DUK_TAG_NORMALIZED_NAN    0x7ff8UL   /* the NaN variant we use */
+#define DUK_TAG_NORMALIZED_NAN 0x7ff8UL /* the NaN variant we use */
 /* avoid tag 0xfff0, no risk of confusion with negative infinity */
-#define DUK_TAG_MIN               0xfff1UL
+#define DUK_TAG_MIN            0xfff1UL
 #if defined(DUK_USE_FASTINT)
-#define DUK_TAG_FASTINT           0xfff1UL   /* embed: integer value */
+#define DUK_TAG_FASTINT 0xfff1UL /* embed: integer value */
 #endif
-#define DUK_TAG_UNUSED            0xfff2UL   /* marker; not actual tagged value */
-#define DUK_TAG_UNDEFINED         0xfff3UL   /* embed: nothing */
-#define DUK_TAG_NULL              0xfff4UL   /* embed: nothing */
-#define DUK_TAG_BOOLEAN           0xfff5UL   /* embed: 0 or 1 (false or true) */
+#define DUK_TAG_UNUSED    0xfff2UL /* marker; not actual tagged value */
+#define DUK_TAG_UNDEFINED 0xfff3UL /* embed: nothing */
+#define DUK_TAG_NULL      0xfff4UL /* embed: nothing */
+#define DUK_TAG_BOOLEAN   0xfff5UL /* embed: 0 or 1 (false or true) */
 /* DUK_TAG_NUMBER would logically go here, but it has multiple 'tags' */
-#define DUK_TAG_POINTER           0xfff6UL   /* embed: void ptr */
-#define DUK_TAG_LIGHTFUNC         0xfff7UL   /* embed: func ptr */
-#define DUK_TAG_STRING            0xfff8UL   /* embed: duk_hstring ptr */
-#define DUK_TAG_OBJECT            0xfff9UL   /* embed: duk_hobject ptr */
-#define DUK_TAG_BUFFER            0xfffaUL   /* embed: duk_hbuffer ptr */
-#define DUK_TAG_MAX               0xfffaUL
+#define DUK_TAG_POINTER   0xfff6UL /* embed: void ptr */
+#define DUK_TAG_LIGHTFUNC 0xfff7UL /* embed: func ptr */
+#define DUK_TAG_STRING    0xfff8UL /* embed: duk_hstring ptr */
+#define DUK_TAG_OBJECT    0xfff9UL /* embed: duk_hobject ptr */
+#define DUK_TAG_BUFFER    0xfffaUL /* embed: duk_hbuffer ptr */
+#define DUK_TAG_MAX       0xfffaUL
 
 /* for convenience */
-#define DUK_XTAG_BOOLEAN_FALSE    0xfff50000UL
-#define DUK_XTAG_BOOLEAN_TRUE     0xfff50001UL
+#define DUK_XTAG_BOOLEAN_FALSE 0xfff50000UL
+#define DUK_XTAG_BOOLEAN_TRUE  0xfff50001UL
 
-#define DUK_TVAL_IS_VALID_TAG(tv) \
-	(DUK_TVAL_GET_TAG((tv)) - DUK_TAG_MIN <= DUK_TAG_MAX - DUK_TAG_MIN)
+#define DUK_TVAL_IS_VALID_TAG(tv) (DUK_TVAL_GET_TAG((tv)) - DUK_TAG_MIN <= DUK_TAG_MAX - DUK_TAG_MIN)
 
 /* DUK_TVAL_UNUSED initializer for duk_tval_unused, works for any endianness. */
 #define DUK_TVAL_UNUSED_INITIALIZER() \
 	{ DUK_TAG_UNUSED, DUK_TAG_UNUSED, DUK_TAG_UNUSED, DUK_TAG_UNUSED }
 
 /* two casts to avoid gcc warning: "warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]" */
 #if defined(DUK_USE_64BIT_OPS)
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK__TVAL_SET_TAGGEDPOINTER(tv,h,tag)  do { \
+#define DUK__TVAL_SET_TAGGEDPOINTER(tv, h, tag) \
+	do { \
 		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) (tag)) << 16) | (((duk_uint64_t) (duk_uint32_t) (h)) << 32); \
 	} while (0)
 #else
-#define DUK__TVAL_SET_TAGGEDPOINTER(tv,h,tag)  do { \
+#define DUK__TVAL_SET_TAGGEDPOINTER(tv, h, tag) \
+	do { \
 		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) (tag)) << 48) | ((duk_uint64_t) (duk_uint32_t) (h)); \
 	} while (0)
 #endif
-#else  /* DUK_USE_64BIT_OPS */
-#define DUK__TVAL_SET_TAGGEDPOINTER(tv,h,tag)  do { \
+#else /* DUK_USE_64BIT_OPS */
+#define DUK__TVAL_SET_TAGGEDPOINTER(tv, h, tag) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->ui[DUK_DBL_IDX_UI0] = ((duk_uint32_t) (tag)) << 16; \
 		duk__tv->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (h); \
 	} while (0)
-#endif  /* DUK_USE_64BIT_OPS */
+#endif /* DUK_USE_64BIT_OPS */
 
 #if defined(DUK_USE_64BIT_OPS)
 /* Double casting for pointer to avoid gcc warning (cast from pointer to integer of different size) */
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK__TVAL_SET_LIGHTFUNC(tv,fp,flags)  do { \
-		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_LIGHTFUNC) << 16) | \
-		                              ((duk_uint64_t) (flags)) | \
+#define DUK__TVAL_SET_LIGHTFUNC(tv, fp, flags) \
+	do { \
+		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_LIGHTFUNC) << 16) | ((duk_uint64_t) (flags)) | \
 		                              (((duk_uint64_t) (duk_uint32_t) (fp)) << 32); \
 	} while (0)
 #else
-#define DUK__TVAL_SET_LIGHTFUNC(tv,fp,flags)  do { \
-		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_LIGHTFUNC) << 48) | \
-		                              (((duk_uint64_t) (flags)) << 32) | \
+#define DUK__TVAL_SET_LIGHTFUNC(tv, fp, flags) \
+	do { \
+		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_LIGHTFUNC) << 48) | (((duk_uint64_t) (flags)) << 32) | \
 		                              ((duk_uint64_t) (duk_uint32_t) (fp)); \
 	} while (0)
 #endif
-#else  /* DUK_USE_64BIT_OPS */
-#define DUK__TVAL_SET_LIGHTFUNC(tv,fp,flags)  do { \
+#else /* DUK_USE_64BIT_OPS */
+#define DUK__TVAL_SET_LIGHTFUNC(tv, fp, flags) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->ui[DUK_DBL_IDX_UI0] = (((duk_uint32_t) DUK_TAG_LIGHTFUNC) << 16) | ((duk_uint32_t) (flags)); \
 		duk__tv->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (fp); \
 	} while (0)
-#endif  /* DUK_USE_64BIT_OPS */
+#endif /* DUK_USE_64BIT_OPS */
 
 #if defined(DUK_USE_FASTINT)
 /* Note: masking is done for 'i' to deal with negative numbers correctly */
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK__TVAL_SET_I48(tv,i)  do { \
+#define DUK__TVAL_SET_I48(tv, i) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
-		duk__tv->ui[DUK_DBL_IDX_UI0] = ((duk_uint32_t) DUK_TAG_FASTINT) << 16 | (((duk_uint32_t) ((i) >> 32)) & 0x0000ffffUL); \
+		duk__tv->ui[DUK_DBL_IDX_UI0] = \
+		    ((duk_uint32_t) DUK_TAG_FASTINT) << 16 | (((duk_uint32_t) ((i) >> 32)) & 0x0000ffffUL); \
 		duk__tv->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (i); \
 	} while (0)
-#define DUK__TVAL_SET_U32(tv,i)  do { \
+#define DUK__TVAL_SET_U32(tv, i) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->ui[DUK_DBL_IDX_UI0] = ((duk_uint32_t) DUK_TAG_FASTINT) << 16; \
 		duk__tv->ui[DUK_DBL_IDX_UI1] = (duk_uint32_t) (i); \
 	} while (0)
 #else
-#define DUK__TVAL_SET_I48(tv,i)  do { \
-		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_FASTINT) << 48) | (((duk_uint64_t) (i)) & DUK_U64_CONSTANT(0x0000ffffffffffff)); \
+#define DUK__TVAL_SET_I48(tv, i) \
+	do { \
+		(tv)->ull[DUK_DBL_IDX_ULL0] = \
+		    (((duk_uint64_t) DUK_TAG_FASTINT) << 48) | (((duk_uint64_t) (i)) & DUK_U64_CONSTANT(0x0000ffffffffffff)); \
 	} while (0)
-#define DUK__TVAL_SET_U32(tv,i)  do { \
+#define DUK__TVAL_SET_U32(tv, i) \
+	do { \
 		(tv)->ull[DUK_DBL_IDX_ULL0] = (((duk_uint64_t) DUK_TAG_FASTINT) << 48) | (duk_uint64_t) (i); \
 	} while (0)
 #endif
 
 /* This needs to go through a cast because sign extension is needed. */
-#define DUK__TVAL_SET_I32(tv,i)  do { \
+#define DUK__TVAL_SET_I32(tv, i) \
+	do { \
 		duk_int64_t duk__tmp = (duk_int64_t) (i); \
 		DUK_TVAL_SET_I48((tv), duk__tmp); \
 	} while (0)
 
 /* XXX: Clumsy sign extend and masking of 16 topmost bits. */
 #if defined(DUK_USE_DOUBLE_ME)
-#define DUK__TVAL_GET_FASTINT(tv)      (((duk_int64_t) ((((duk_uint64_t) (tv)->ui[DUK_DBL_IDX_UI0]) << 32) | ((duk_uint64_t) (tv)->ui[DUK_DBL_IDX_UI1]))) << 16 >> 16)
-#else
-#define DUK__TVAL_GET_FASTINT(tv)      ((((duk_int64_t) (tv)->ull[DUK_DBL_IDX_ULL0]) << 16) >> 16)
-#endif
-#define DUK__TVAL_GET_FASTINT_U32(tv)  ((tv)->ui[DUK_DBL_IDX_UI1])
-#define DUK__TVAL_GET_FASTINT_I32(tv)  ((duk_int32_t) (tv)->ui[DUK_DBL_IDX_UI1])
-#endif  /* DUK_USE_FASTINT */
+#define DUK__TVAL_GET_FASTINT(tv) \
+	(((duk_int64_t) ((((duk_uint64_t) (tv)->ui[DUK_DBL_IDX_UI0]) << 32) | ((duk_uint64_t) (tv)->ui[DUK_DBL_IDX_UI1]))) \
+	     << 16 >> \
+	 16)
+#else
+#define DUK__TVAL_GET_FASTINT(tv) ((((duk_int64_t) (tv)->ull[DUK_DBL_IDX_ULL0]) << 16) >> 16)
+#endif
+#define DUK__TVAL_GET_FASTINT_U32(tv) ((tv)->ui[DUK_DBL_IDX_UI1])
+#define DUK__TVAL_GET_FASTINT_I32(tv) ((duk_int32_t) (tv)->ui[DUK_DBL_IDX_UI1])
+#endif /* DUK_USE_FASTINT */
 
-#define DUK_TVAL_SET_UNDEFINED(tv)  do { \
+#define DUK_TVAL_SET_UNDEFINED(tv) \
+	do { \
 		(tv)->us[DUK_DBL_IDX_US0] = (duk_uint16_t) DUK_TAG_UNDEFINED; \
 	} while (0)
-#define DUK_TVAL_SET_UNUSED(tv)  do { \
+#define DUK_TVAL_SET_UNUSED(tv) \
+	do { \
 		(tv)->us[DUK_DBL_IDX_US0] = (duk_uint16_t) DUK_TAG_UNUSED; \
 	} while (0)
-#define DUK_TVAL_SET_NULL(tv)  do { \
+#define DUK_TVAL_SET_NULL(tv) \
+	do { \
 		(tv)->us[DUK_DBL_IDX_US0] = (duk_uint16_t) DUK_TAG_NULL; \
 	} while (0)
 
-#define DUK_TVAL_SET_BOOLEAN(tv,val)         DUK_DBLUNION_SET_HIGH32((tv), (((duk_uint32_t) DUK_TAG_BOOLEAN) << 16) | ((duk_uint32_t) (val)))
+#define DUK_TVAL_SET_BOOLEAN(tv, val) \
+	DUK_DBLUNION_SET_HIGH32((tv), (((duk_uint32_t) DUK_TAG_BOOLEAN) << 16) | ((duk_uint32_t) (val)))
 
-#define DUK_TVAL_SET_NAN(tv)                 DUK_DBLUNION_SET_NAN_FULL((tv))
+#define DUK_TVAL_SET_NAN(tv) DUK_DBLUNION_SET_NAN_FULL((tv))
 
 /* Assumes that caller has normalized NaNs, otherwise trouble ahead. */
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_DOUBLE(tv,d)  do { \
+#define DUK_TVAL_SET_DOUBLE(tv, d) \
+	do { \
 		duk_double_t duk__dblval; \
 		duk__dblval = (d); \
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(duk__dblval); \
 		DUK_DBLUNION_SET_DOUBLE((tv), duk__dblval); \
 	} while (0)
-#define DUK_TVAL_SET_I48(tv,i)               DUK__TVAL_SET_I48((tv), (i))
-#define DUK_TVAL_SET_I32(tv,i)               DUK__TVAL_SET_I32((tv), (i))
-#define DUK_TVAL_SET_U32(tv,i)               DUK__TVAL_SET_U32((tv), (i))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv,d)  duk_tval_set_number_chkfast_fast((tv), (d))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv,d)  duk_tval_set_number_chkfast_slow((tv), (d))
-#define DUK_TVAL_SET_NUMBER(tv,d)            DUK_TVAL_SET_DOUBLE((tv), (d))
-#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv)  do { \
+#define DUK_TVAL_SET_I48(tv, i)                 DUK__TVAL_SET_I48((tv), (i))
+#define DUK_TVAL_SET_I32(tv, i)                 DUK__TVAL_SET_I32((tv), (i))
+#define DUK_TVAL_SET_U32(tv, i)                 DUK__TVAL_SET_U32((tv), (i))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv, d) duk_tval_set_number_chkfast_fast((tv), (d))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, d) duk_tval_set_number_chkfast_slow((tv), (d))
+#define DUK_TVAL_SET_NUMBER(tv, d)              DUK_TVAL_SET_DOUBLE((tv), (d))
+#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__d; \
 		duk__tv = (tv); \
 		if (DUK_TVAL_IS_DOUBLE(duk__tv)) { \
 			duk__d = DUK_TVAL_GET_DOUBLE(duk__tv); \
 			DUK_TVAL_SET_NUMBER_CHKFAST_FAST(duk__tv, duk__d); \
 		} \
 	} while (0)
-#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv)  do { \
+#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__d; \
 		duk__tv = (tv); \
 		if (DUK_TVAL_IS_DOUBLE(duk__tv)) { \
 			duk__d = DUK_TVAL_GET_DOUBLE(duk__tv); \
 			DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(duk__tv, duk__d); \
 		} \
 	} while (0)
-#else  /* DUK_USE_FASTINT */
-#define DUK_TVAL_SET_DOUBLE(tv,d)  do { \
+#else /* DUK_USE_FASTINT */
+#define DUK_TVAL_SET_DOUBLE(tv, d) \
+	do { \
 		duk_double_t duk__dblval; \
 		duk__dblval = (d); \
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(duk__dblval); \
 		DUK_DBLUNION_SET_DOUBLE((tv), duk__dblval); \
 	} while (0)
-#define DUK_TVAL_SET_I48(tv,i)               DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i))  /* XXX: fast int-to-double */
-#define DUK_TVAL_SET_I32(tv,i)               DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i))
-#define DUK_TVAL_SET_U32(tv,i)               DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv,d)    DUK_TVAL_SET_DOUBLE((tv), (d))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv,d)    DUK_TVAL_SET_DOUBLE((tv), (d))
-#define DUK_TVAL_SET_NUMBER(tv,d)            DUK_TVAL_SET_DOUBLE((tv), (d))
-#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv)  do { } while (0)
-#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv)  do { } while (0)
-#endif  /* DUK_USE_FASTINT */
-
-#define DUK_TVAL_SET_FASTINT(tv,i)           DUK_TVAL_SET_I48((tv), (i))  /* alias */
-
-#define DUK_TVAL_SET_LIGHTFUNC(tv,fp,flags)  DUK__TVAL_SET_LIGHTFUNC((tv), (fp), (flags))
-#define DUK_TVAL_SET_STRING(tv,h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_STRING)
-#define DUK_TVAL_SET_OBJECT(tv,h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_OBJECT)
-#define DUK_TVAL_SET_BUFFER(tv,h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_BUFFER)
-#define DUK_TVAL_SET_POINTER(tv,p)           DUK__TVAL_SET_TAGGEDPOINTER((tv), (p), DUK_TAG_POINTER)
-
-#define DUK_TVAL_SET_TVAL(tv,x)              do { *(tv) = *(x); } while (0)
+#define DUK_TVAL_SET_I48(tv, i)                 DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i)) /* XXX: fast int-to-double */
+#define DUK_TVAL_SET_I32(tv, i)                 DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i))
+#define DUK_TVAL_SET_U32(tv, i)                 DUK_TVAL_SET_DOUBLE((tv), (duk_double_t) (i))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv, d) DUK_TVAL_SET_DOUBLE((tv), (d))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, d) DUK_TVAL_SET_DOUBLE((tv), (d))
+#define DUK_TVAL_SET_NUMBER(tv, d)              DUK_TVAL_SET_DOUBLE((tv), (d))
+#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv) \
+	do { \
+	} while (0)
+#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv) \
+	do { \
+	} while (0)
+#endif /* DUK_USE_FASTINT */
+
+#define DUK_TVAL_SET_FASTINT(tv, i) DUK_TVAL_SET_I48((tv), (i)) /* alias */
+
+#define DUK_TVAL_SET_LIGHTFUNC(tv, fp, flags) DUK__TVAL_SET_LIGHTFUNC((tv), (fp), (flags))
+#define DUK_TVAL_SET_STRING(tv, h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_STRING)
+#define DUK_TVAL_SET_OBJECT(tv, h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_OBJECT)
+#define DUK_TVAL_SET_BUFFER(tv, h)            DUK__TVAL_SET_TAGGEDPOINTER((tv), (h), DUK_TAG_BUFFER)
+#define DUK_TVAL_SET_POINTER(tv, p)           DUK__TVAL_SET_TAGGEDPOINTER((tv), (p), DUK_TAG_POINTER)
+
+#define DUK_TVAL_SET_TVAL(tv, x) \
+	do { \
+		*(tv) = *(x); \
+	} while (0)
 
 /* getters */
-#define DUK_TVAL_GET_BOOLEAN(tv)             ((duk_small_uint_t) (tv)->us[DUK_DBL_IDX_US1])
+#define DUK_TVAL_GET_BOOLEAN(tv) ((duk_small_uint_t) (tv)->us[DUK_DBL_IDX_US1])
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_GET_DOUBLE(tv)              ((tv)->d)
-#define DUK_TVAL_GET_FASTINT(tv)             DUK__TVAL_GET_FASTINT((tv))
-#define DUK_TVAL_GET_FASTINT_U32(tv)         DUK__TVAL_GET_FASTINT_U32((tv))
-#define DUK_TVAL_GET_FASTINT_I32(tv)         DUK__TVAL_GET_FASTINT_I32((tv))
-#define DUK_TVAL_GET_NUMBER(tv)              duk_tval_get_number_packed((tv))
+#define DUK_TVAL_GET_DOUBLE(tv)      ((tv)->d)
+#define DUK_TVAL_GET_FASTINT(tv)     DUK__TVAL_GET_FASTINT((tv))
+#define DUK_TVAL_GET_FASTINT_U32(tv) DUK__TVAL_GET_FASTINT_U32((tv))
+#define DUK_TVAL_GET_FASTINT_I32(tv) DUK__TVAL_GET_FASTINT_I32((tv))
+#define DUK_TVAL_GET_NUMBER(tv)      duk_tval_get_number_packed((tv))
 #else
-#define DUK_TVAL_GET_NUMBER(tv)              ((tv)->d)
-#define DUK_TVAL_GET_DOUBLE(tv)              ((tv)->d)
+#define DUK_TVAL_GET_NUMBER(tv) ((tv)->d)
+#define DUK_TVAL_GET_DOUBLE(tv) ((tv)->d)
 #endif
-#define DUK_TVAL_GET_LIGHTFUNC(tv,out_fp,out_flags)  do { \
+#define DUK_TVAL_GET_LIGHTFUNC(tv, out_fp, out_flags) \
+	do { \
 		(out_flags) = (tv)->ui[DUK_DBL_IDX_UI0] & 0xffffUL; \
 		(out_fp) = (duk_c_function) (tv)->ui[DUK_DBL_IDX_UI1]; \
 	} while (0)
-#define DUK_TVAL_GET_LIGHTFUNC_FUNCPTR(tv)   ((duk_c_function) ((tv)->ui[DUK_DBL_IDX_UI1]))
-#define DUK_TVAL_GET_LIGHTFUNC_FLAGS(tv)     (((duk_small_uint_t) (tv)->ui[DUK_DBL_IDX_UI0]) & 0xffffUL)
-#define DUK_TVAL_GET_STRING(tv)              ((duk_hstring *) (tv)->vp[DUK_DBL_IDX_VP1])
-#define DUK_TVAL_GET_OBJECT(tv)              ((duk_hobject *) (tv)->vp[DUK_DBL_IDX_VP1])
-#define DUK_TVAL_GET_BUFFER(tv)              ((duk_hbuffer *) (tv)->vp[DUK_DBL_IDX_VP1])
-#define DUK_TVAL_GET_POINTER(tv)             ((void *) (tv)->vp[DUK_DBL_IDX_VP1])
-#define DUK_TVAL_GET_HEAPHDR(tv)             ((duk_heaphdr *) (tv)->vp[DUK_DBL_IDX_VP1])
+#define DUK_TVAL_GET_LIGHTFUNC_FUNCPTR(tv) ((duk_c_function) ((tv)->ui[DUK_DBL_IDX_UI1]))
+#define DUK_TVAL_GET_LIGHTFUNC_FLAGS(tv)   (((duk_small_uint_t) (tv)->ui[DUK_DBL_IDX_UI0]) & 0xffffUL)
+#define DUK_TVAL_GET_STRING(tv)            ((duk_hstring *) (tv)->vp[DUK_DBL_IDX_VP1])
+#define DUK_TVAL_GET_OBJECT(tv)            ((duk_hobject *) (tv)->vp[DUK_DBL_IDX_VP1])
+#define DUK_TVAL_GET_BUFFER(tv)            ((duk_hbuffer *) (tv)->vp[DUK_DBL_IDX_VP1])
+#define DUK_TVAL_GET_POINTER(tv)           ((void *) (tv)->vp[DUK_DBL_IDX_VP1])
+#define DUK_TVAL_GET_HEAPHDR(tv)           ((duk_heaphdr *) (tv)->vp[DUK_DBL_IDX_VP1])
 
 /* decoding */
-#define DUK_TVAL_GET_TAG(tv)                 ((duk_small_uint_t) (tv)->us[DUK_DBL_IDX_US0])
+#define DUK_TVAL_GET_TAG(tv) ((duk_small_uint_t) (tv)->us[DUK_DBL_IDX_US0])
 
-#define DUK_TVAL_IS_UNDEFINED(tv)            (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_UNDEFINED)
-#define DUK_TVAL_IS_UNUSED(tv)               (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_UNUSED)
-#define DUK_TVAL_IS_NULL(tv)                 (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_NULL)
-#define DUK_TVAL_IS_BOOLEAN(tv)              (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_BOOLEAN)
-#define DUK_TVAL_IS_BOOLEAN_TRUE(tv)         ((tv)->ui[DUK_DBL_IDX_UI0] == DUK_XTAG_BOOLEAN_TRUE)
-#define DUK_TVAL_IS_BOOLEAN_FALSE(tv)        ((tv)->ui[DUK_DBL_IDX_UI0] == DUK_XTAG_BOOLEAN_FALSE)
-#define DUK_TVAL_IS_LIGHTFUNC(tv)            (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_LIGHTFUNC)
-#define DUK_TVAL_IS_STRING(tv)               (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_STRING)
-#define DUK_TVAL_IS_OBJECT(tv)               (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_OBJECT)
-#define DUK_TVAL_IS_BUFFER(tv)               (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_BUFFER)
-#define DUK_TVAL_IS_POINTER(tv)              (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_POINTER)
+#define DUK_TVAL_IS_UNDEFINED(tv)     (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_UNDEFINED)
+#define DUK_TVAL_IS_UNUSED(tv)        (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_UNUSED)
+#define DUK_TVAL_IS_NULL(tv)          (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_NULL)
+#define DUK_TVAL_IS_BOOLEAN(tv)       (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_BOOLEAN)
+#define DUK_TVAL_IS_BOOLEAN_TRUE(tv)  ((tv)->ui[DUK_DBL_IDX_UI0] == DUK_XTAG_BOOLEAN_TRUE)
+#define DUK_TVAL_IS_BOOLEAN_FALSE(tv) ((tv)->ui[DUK_DBL_IDX_UI0] == DUK_XTAG_BOOLEAN_FALSE)
+#define DUK_TVAL_IS_LIGHTFUNC(tv)     (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_LIGHTFUNC)
+#define DUK_TVAL_IS_STRING(tv)        (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_STRING)
+#define DUK_TVAL_IS_OBJECT(tv)        (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_OBJECT)
+#define DUK_TVAL_IS_BUFFER(tv)        (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_BUFFER)
+#define DUK_TVAL_IS_POINTER(tv)       (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_POINTER)
 #if defined(DUK_USE_FASTINT)
 /* 0xfff0 is -Infinity */
-#define DUK_TVAL_IS_DOUBLE(tv)               (DUK_TVAL_GET_TAG((tv)) <= 0xfff0UL)
-#define DUK_TVAL_IS_FASTINT(tv)              (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_FASTINT)
-#define DUK_TVAL_IS_NUMBER(tv)               (DUK_TVAL_GET_TAG((tv)) <= 0xfff1UL)
+#define DUK_TVAL_IS_DOUBLE(tv)  (DUK_TVAL_GET_TAG((tv)) <= 0xfff0UL)
+#define DUK_TVAL_IS_FASTINT(tv) (DUK_TVAL_GET_TAG((tv)) == DUK_TAG_FASTINT)
+#define DUK_TVAL_IS_NUMBER(tv)  (DUK_TVAL_GET_TAG((tv)) <= 0xfff1UL)
 #else
-#define DUK_TVAL_IS_NUMBER(tv)               (DUK_TVAL_GET_TAG((tv)) <= 0xfff0UL)
-#define DUK_TVAL_IS_DOUBLE(tv)               DUK_TVAL_IS_NUMBER((tv))
+#define DUK_TVAL_IS_NUMBER(tv) (DUK_TVAL_GET_TAG((tv)) <= 0xfff0UL)
+#define DUK_TVAL_IS_DOUBLE(tv) DUK_TVAL_IS_NUMBER((tv))
 #endif
 
 /* This is performance critical because it appears in every DECREF. */
-#define DUK_TVAL_IS_HEAP_ALLOCATED(tv)       (DUK_TVAL_GET_TAG((tv)) >= DUK_TAG_STRING)
+#define DUK_TVAL_IS_HEAP_ALLOCATED(tv) (DUK_TVAL_GET_TAG((tv)) >= DUK_TAG_STRING)
 
 #if defined(DUK_USE_FASTINT)
 DUK_INTERNAL_DECL duk_double_t duk_tval_get_number_packed(duk_tval *tv);
 #endif
 
-#else  /* DUK_USE_PACKED_TVAL */
+#else /* DUK_USE_PACKED_TVAL */
 /* ======================================================================== */
 
 /*
  *  Portable 12-byte representation
  */
 
 /* Note: not initializing all bytes is normally not an issue: Duktape won't
@@ -1197,15 +1228,15 @@
 struct duk_tval_struct {
 	duk_small_uint_t t;
 	duk_small_uint_t v_extra;
 	union {
 		duk_double_t d;
 		duk_small_int_t i;
 #if defined(DUK_USE_FASTINT)
-		duk_int64_t fi;  /* if present, forces 16-byte duk_tval */
+		duk_int64_t fi; /* if present, forces 16-byte duk_tval */
 #endif
 		void *voidptr;
 		duk_hstring *hstring;
 		duk_hobject *hobject;
 		duk_hcompfunc *hcompfunc;
 		duk_hnatfunc *hnatfunc;
 		duk_hthread *hthread;
@@ -1225,216 +1256,226 @@
 	 */
 	duk_double_t d;
 } duk_tval_unused;
 
 #define DUK_TVAL_UNUSED_INITIALIZER() \
 	{ DUK_TAG_UNUSED, 0, 0.0 }
 
-#define DUK_TAG_MIN                   0
-#define DUK_TAG_NUMBER                0  /* DUK_TAG_NUMBER only defined for non-packed duk_tval */
+#define DUK_TAG_MIN    0
+#define DUK_TAG_NUMBER 0 /* DUK_TAG_NUMBER only defined for non-packed duk_tval */
 #if defined(DUK_USE_FASTINT)
-#define DUK_TAG_FASTINT               1
+#define DUK_TAG_FASTINT 1
 #endif
-#define DUK_TAG_UNDEFINED             2
-#define DUK_TAG_NULL                  3
-#define DUK_TAG_BOOLEAN               4
-#define DUK_TAG_POINTER               5
-#define DUK_TAG_LIGHTFUNC             6
-#define DUK_TAG_UNUSED                7  /* marker; not actual tagged type */
-#define DUK_TAG_STRING                8  /* first heap allocated, match bit boundary */
-#define DUK_TAG_OBJECT                9
-#define DUK_TAG_BUFFER                10
-#define DUK_TAG_MAX                   10
+#define DUK_TAG_UNDEFINED 2
+#define DUK_TAG_NULL      3
+#define DUK_TAG_BOOLEAN   4
+#define DUK_TAG_POINTER   5
+#define DUK_TAG_LIGHTFUNC 6
+#define DUK_TAG_UNUSED    7 /* marker; not actual tagged type */
+#define DUK_TAG_STRING    8 /* first heap allocated, match bit boundary */
+#define DUK_TAG_OBJECT    9
+#define DUK_TAG_BUFFER    10
+#define DUK_TAG_MAX       10
 
-#define DUK_TVAL_IS_VALID_TAG(tv) \
-	(DUK_TVAL_GET_TAG((tv)) - DUK_TAG_MIN <= DUK_TAG_MAX - DUK_TAG_MIN)
+#define DUK_TVAL_IS_VALID_TAG(tv) (DUK_TVAL_GET_TAG((tv)) - DUK_TAG_MIN <= DUK_TAG_MAX - DUK_TAG_MIN)
 
 /* DUK_TAG_NUMBER is intentionally first, as it is the default clause in code
  * to support the 8-byte representation.  Further, it is a non-heap-allocated
  * type so it should come before DUK_TAG_STRING.  Finally, it should not break
  * the tag value ranges covered by case-clauses in a switch-case.
  */
 
 /* setters */
-#define DUK_TVAL_SET_UNDEFINED(tv)  do { \
+#define DUK_TVAL_SET_UNDEFINED(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_UNDEFINED; \
 	} while (0)
 
-#define DUK_TVAL_SET_UNUSED(tv)  do { \
+#define DUK_TVAL_SET_UNUSED(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_UNUSED; \
 	} while (0)
 
-#define DUK_TVAL_SET_NULL(tv)  do { \
+#define DUK_TVAL_SET_NULL(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_NULL; \
 	} while (0)
 
-#define DUK_TVAL_SET_BOOLEAN(tv,val)  do { \
+#define DUK_TVAL_SET_BOOLEAN(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_BOOLEAN; \
 		duk__tv->v.i = (duk_small_int_t) (val); \
 	} while (0)
 
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_DOUBLE(tv,val)  do { \
+#define DUK_TVAL_SET_DOUBLE(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__dblval; \
 		duk__dblval = (val); \
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(duk__dblval); /* nop for unpacked duk_tval */ \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_NUMBER; \
 		duk__tv->v.d = duk__dblval; \
 	} while (0)
-#define DUK_TVAL_SET_I48(tv,val)  do { \
+#define DUK_TVAL_SET_I48(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_FASTINT; \
 		duk__tv->v.fi = (val); \
 	} while (0)
-#define DUK_TVAL_SET_U32(tv,val)  do { \
+#define DUK_TVAL_SET_U32(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_FASTINT; \
 		duk__tv->v.fi = (duk_int64_t) (val); \
 	} while (0)
-#define DUK_TVAL_SET_I32(tv,val)  do { \
+#define DUK_TVAL_SET_I32(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_FASTINT; \
 		duk__tv->v.fi = (duk_int64_t) (val); \
 	} while (0)
-#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv,d) \
-	duk_tval_set_number_chkfast_fast((tv), (d))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv,d) \
-	duk_tval_set_number_chkfast_slow((tv), (d))
-#define DUK_TVAL_SET_NUMBER(tv,val) \
-	DUK_TVAL_SET_DOUBLE((tv), (val))
-#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv)  do { \
+#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv, d) duk_tval_set_number_chkfast_fast((tv), (d))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, d) duk_tval_set_number_chkfast_slow((tv), (d))
+#define DUK_TVAL_SET_NUMBER(tv, val)            DUK_TVAL_SET_DOUBLE((tv), (val))
+#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__d; \
 		duk__tv = (tv); \
 		if (DUK_TVAL_IS_DOUBLE(duk__tv)) { \
 			duk__d = DUK_TVAL_GET_DOUBLE(duk__tv); \
 			DUK_TVAL_SET_NUMBER_CHKFAST_FAST(duk__tv, duk__d); \
 		} \
 	} while (0)
-#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv)  do { \
+#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__d; \
 		duk__tv = (tv); \
 		if (DUK_TVAL_IS_DOUBLE(duk__tv)) { \
 			duk__d = DUK_TVAL_GET_DOUBLE(duk__tv); \
 			DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(duk__tv, duk__d); \
 		} \
 	} while (0)
-#else  /* DUK_USE_FASTINT */
-#define DUK_TVAL_SET_DOUBLE(tv,d) \
-	DUK_TVAL_SET_NUMBER((tv), (d))
-#define DUK_TVAL_SET_I48(tv,val) \
-	DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val))  /* XXX: fast int-to-double */
-#define DUK_TVAL_SET_U32(tv,val) \
-	DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val))
-#define DUK_TVAL_SET_I32(tv,val) \
-	DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val))
-#define DUK_TVAL_SET_NUMBER(tv,val)  do { \
+#else /* DUK_USE_FASTINT */
+#define DUK_TVAL_SET_DOUBLE(tv, d) DUK_TVAL_SET_NUMBER((tv), (d))
+#define DUK_TVAL_SET_I48(tv, val)  DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val)) /* XXX: fast int-to-double */
+#define DUK_TVAL_SET_U32(tv, val)  DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val))
+#define DUK_TVAL_SET_I32(tv, val)  DUK_TVAL_SET_NUMBER((tv), (duk_double_t) (val))
+#define DUK_TVAL_SET_NUMBER(tv, val) \
+	do { \
 		duk_tval *duk__tv; \
 		duk_double_t duk__dblval; \
 		duk__dblval = (val); \
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(duk__dblval); /* nop for unpacked duk_tval */ \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_NUMBER; \
 		duk__tv->v.d = duk__dblval; \
 	} while (0)
-#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv,d) \
-	DUK_TVAL_SET_NUMBER((tv), (d))
-#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv,d) \
-	DUK_TVAL_SET_NUMBER((tv), (d))
-#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv)  do { } while (0)
-#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv)  do { } while (0)
-#endif  /* DUK_USE_FASTINT */
+#define DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv, d) DUK_TVAL_SET_NUMBER((tv), (d))
+#define DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, d) DUK_TVAL_SET_NUMBER((tv), (d))
+#define DUK_TVAL_CHKFAST_INPLACE_FAST(tv) \
+	do { \
+	} while (0)
+#define DUK_TVAL_CHKFAST_INPLACE_SLOW(tv) \
+	do { \
+	} while (0)
+#endif /* DUK_USE_FASTINT */
 
-#define DUK_TVAL_SET_FASTINT(tv,i) \
-	DUK_TVAL_SET_I48((tv), (i))  /* alias */
+#define DUK_TVAL_SET_FASTINT(tv, i) DUK_TVAL_SET_I48((tv), (i)) /* alias */
 
-#define DUK_TVAL_SET_POINTER(tv,hptr)  do { \
+#define DUK_TVAL_SET_POINTER(tv, hptr) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_POINTER; \
 		duk__tv->v.voidptr = (hptr); \
 	} while (0)
 
-#define DUK_TVAL_SET_LIGHTFUNC(tv,fp,flags)  do { \
+#define DUK_TVAL_SET_LIGHTFUNC(tv, fp, flags) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_LIGHTFUNC; \
 		duk__tv->v_extra = (flags); \
 		duk__tv->v.lightfunc = (duk_c_function) (fp); \
 	} while (0)
 
-#define DUK_TVAL_SET_STRING(tv,hptr)  do { \
+#define DUK_TVAL_SET_STRING(tv, hptr) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_STRING; \
 		duk__tv->v.hstring = (hptr); \
 	} while (0)
 
-#define DUK_TVAL_SET_OBJECT(tv,hptr)  do { \
+#define DUK_TVAL_SET_OBJECT(tv, hptr) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_OBJECT; \
 		duk__tv->v.hobject = (hptr); \
 	} while (0)
 
-#define DUK_TVAL_SET_BUFFER(tv,hptr)  do { \
+#define DUK_TVAL_SET_BUFFER(tv, hptr) \
+	do { \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_BUFFER; \
 		duk__tv->v.hbuffer = (hptr); \
 	} while (0)
 
-#define DUK_TVAL_SET_NAN(tv)  do { \
+#define DUK_TVAL_SET_NAN(tv) \
+	do { \
 		/* in non-packed representation we don't care about which NaN is used */ \
 		duk_tval *duk__tv; \
 		duk__tv = (tv); \
 		duk__tv->t = DUK_TAG_NUMBER; \
 		duk__tv->v.d = DUK_DOUBLE_NAN; \
 	} while (0)
 
-#define DUK_TVAL_SET_TVAL(tv,x)            do { *(tv) = *(x); } while (0)
+#define DUK_TVAL_SET_TVAL(tv, x) \
+	do { \
+		*(tv) = *(x); \
+	} while (0)
 
 /* getters */
-#define DUK_TVAL_GET_BOOLEAN(tv)           ((duk_small_uint_t) (tv)->v.i)
+#define DUK_TVAL_GET_BOOLEAN(tv) ((duk_small_uint_t) (tv)->v.i)
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_GET_DOUBLE(tv)            ((tv)->v.d)
-#define DUK_TVAL_GET_FASTINT(tv)           ((tv)->v.fi)
-#define DUK_TVAL_GET_FASTINT_U32(tv)       ((duk_uint32_t) ((tv)->v.fi))
-#define DUK_TVAL_GET_FASTINT_I32(tv)       ((duk_int32_t) ((tv)->v.fi))
+#define DUK_TVAL_GET_DOUBLE(tv)      ((tv)->v.d)
+#define DUK_TVAL_GET_FASTINT(tv)     ((tv)->v.fi)
+#define DUK_TVAL_GET_FASTINT_U32(tv) ((duk_uint32_t) ((tv)->v.fi))
+#define DUK_TVAL_GET_FASTINT_I32(tv) ((duk_int32_t) ((tv)->v.fi))
 #if 0
-#define DUK_TVAL_GET_NUMBER(tv)            (DUK_TVAL_IS_FASTINT((tv)) ? \
-                                               (duk_double_t) DUK_TVAL_GET_FASTINT((tv)) : \
-                                               DUK_TVAL_GET_DOUBLE((tv)))
-#define DUK_TVAL_GET_NUMBER(tv)            duk_tval_get_number_unpacked((tv))
+#define DUK_TVAL_GET_NUMBER(tv) (DUK_TVAL_IS_FASTINT((tv)) ? (duk_double_t) DUK_TVAL_GET_FASTINT((tv)) : DUK_TVAL_GET_DOUBLE((tv)))
+#define DUK_TVAL_GET_NUMBER(tv) duk_tval_get_number_unpacked((tv))
 #else
 /* This seems reasonable overall. */
-#define DUK_TVAL_GET_NUMBER(tv)            (DUK_TVAL_IS_FASTINT((tv)) ? \
-                                               duk_tval_get_number_unpacked_fastint((tv)) : \
-                                               DUK_TVAL_GET_DOUBLE((tv)))
+#define DUK_TVAL_GET_NUMBER(tv) (DUK_TVAL_IS_FASTINT((tv)) ? duk_tval_get_number_unpacked_fastint((tv)) : DUK_TVAL_GET_DOUBLE((tv)))
 #endif
 #else
-#define DUK_TVAL_GET_NUMBER(tv)            ((tv)->v.d)
-#define DUK_TVAL_GET_DOUBLE(tv)            ((tv)->v.d)
-#endif  /* DUK_USE_FASTINT */
-#define DUK_TVAL_GET_POINTER(tv)           ((tv)->v.voidptr)
-#define DUK_TVAL_GET_LIGHTFUNC(tv,out_fp,out_flags)  do { \
+#define DUK_TVAL_GET_NUMBER(tv) ((tv)->v.d)
+#define DUK_TVAL_GET_DOUBLE(tv) ((tv)->v.d)
+#endif /* DUK_USE_FASTINT */
+#define DUK_TVAL_GET_POINTER(tv) ((tv)->v.voidptr)
+#define DUK_TVAL_GET_LIGHTFUNC(tv, out_fp, out_flags) \
+	do { \
 		(out_flags) = (duk_uint32_t) (tv)->v_extra; \
 		(out_fp) = (tv)->v.lightfunc; \
 	} while (0)
 #define DUK_TVAL_GET_LIGHTFUNC_FUNCPTR(tv) ((tv)->v.lightfunc)
 #define DUK_TVAL_GET_LIGHTFUNC_FLAGS(tv)   ((duk_small_uint_t) ((tv)->v_extra))
 #define DUK_TVAL_GET_STRING(tv)            ((tv)->v.hstring)
 #define DUK_TVAL_GET_OBJECT(tv)            ((tv)->v.hobject)
@@ -1446,96 +1487,95 @@
 #define DUK_TVAL_IS_UNDEFINED(tv)          ((tv)->t == DUK_TAG_UNDEFINED)
 #define DUK_TVAL_IS_UNUSED(tv)             ((tv)->t == DUK_TAG_UNUSED)
 #define DUK_TVAL_IS_NULL(tv)               ((tv)->t == DUK_TAG_NULL)
 #define DUK_TVAL_IS_BOOLEAN(tv)            ((tv)->t == DUK_TAG_BOOLEAN)
 #define DUK_TVAL_IS_BOOLEAN_TRUE(tv)       (((tv)->t == DUK_TAG_BOOLEAN) && ((tv)->v.i != 0))
 #define DUK_TVAL_IS_BOOLEAN_FALSE(tv)      (((tv)->t == DUK_TAG_BOOLEAN) && ((tv)->v.i == 0))
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_IS_DOUBLE(tv)             ((tv)->t == DUK_TAG_NUMBER)
-#define DUK_TVAL_IS_FASTINT(tv)            ((tv)->t == DUK_TAG_FASTINT)
-#define DUK_TVAL_IS_NUMBER(tv)             ((tv)->t == DUK_TAG_NUMBER || \
-                                            (tv)->t == DUK_TAG_FASTINT)
-#else
-#define DUK_TVAL_IS_NUMBER(tv)             ((tv)->t == DUK_TAG_NUMBER)
-#define DUK_TVAL_IS_DOUBLE(tv)             DUK_TVAL_IS_NUMBER((tv))
-#endif  /* DUK_USE_FASTINT */
-#define DUK_TVAL_IS_POINTER(tv)            ((tv)->t == DUK_TAG_POINTER)
-#define DUK_TVAL_IS_LIGHTFUNC(tv)          ((tv)->t == DUK_TAG_LIGHTFUNC)
-#define DUK_TVAL_IS_STRING(tv)             ((tv)->t == DUK_TAG_STRING)
-#define DUK_TVAL_IS_OBJECT(tv)             ((tv)->t == DUK_TAG_OBJECT)
-#define DUK_TVAL_IS_BUFFER(tv)             ((tv)->t == DUK_TAG_BUFFER)
+#define DUK_TVAL_IS_DOUBLE(tv)  ((tv)->t == DUK_TAG_NUMBER)
+#define DUK_TVAL_IS_FASTINT(tv) ((tv)->t == DUK_TAG_FASTINT)
+#define DUK_TVAL_IS_NUMBER(tv)  ((tv)->t == DUK_TAG_NUMBER || (tv)->t == DUK_TAG_FASTINT)
+#else
+#define DUK_TVAL_IS_NUMBER(tv) ((tv)->t == DUK_TAG_NUMBER)
+#define DUK_TVAL_IS_DOUBLE(tv) DUK_TVAL_IS_NUMBER((tv))
+#endif /* DUK_USE_FASTINT */
+#define DUK_TVAL_IS_POINTER(tv)   ((tv)->t == DUK_TAG_POINTER)
+#define DUK_TVAL_IS_LIGHTFUNC(tv) ((tv)->t == DUK_TAG_LIGHTFUNC)
+#define DUK_TVAL_IS_STRING(tv)    ((tv)->t == DUK_TAG_STRING)
+#define DUK_TVAL_IS_OBJECT(tv)    ((tv)->t == DUK_TAG_OBJECT)
+#define DUK_TVAL_IS_BUFFER(tv)    ((tv)->t == DUK_TAG_BUFFER)
 
 /* This is performance critical because it's needed for every DECREF.
  * Take advantage of the fact that the first heap allocated tag is 8,
  * so that bit 3 is set for all heap allocated tags (and never set for
  * non-heap-allocated tags).
  */
 #if 0
-#define DUK_TVAL_IS_HEAP_ALLOCATED(tv)     ((tv)->t >= DUK_TAG_STRING)
+#define DUK_TVAL_IS_HEAP_ALLOCATED(tv) ((tv)->t >= DUK_TAG_STRING)
 #endif
-#define DUK_TVAL_IS_HEAP_ALLOCATED(tv)     ((tv)->t & 0x08)
+#define DUK_TVAL_IS_HEAP_ALLOCATED(tv) ((tv)->t & 0x08)
 
 #if defined(DUK_USE_FASTINT)
 #if 0
 DUK_INTERNAL_DECL duk_double_t duk_tval_get_number_unpacked(duk_tval *tv);
 #endif
 DUK_INTERNAL_DECL duk_double_t duk_tval_get_number_unpacked_fastint(duk_tval *tv);
 #endif
 
-#endif  /* DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_PACKED_TVAL */
 
 /*
  *  Convenience (independent of representation)
  */
 
-#define DUK_TVAL_SET_BOOLEAN_TRUE(tv)        DUK_TVAL_SET_BOOLEAN((tv), 1)
-#define DUK_TVAL_SET_BOOLEAN_FALSE(tv)       DUK_TVAL_SET_BOOLEAN((tv), 0)
+#define DUK_TVAL_SET_BOOLEAN_TRUE(tv)  DUK_TVAL_SET_BOOLEAN((tv), 1)
+#define DUK_TVAL_SET_BOOLEAN_FALSE(tv) DUK_TVAL_SET_BOOLEAN((tv), 0)
 
-#define DUK_TVAL_STRING_IS_SYMBOL(tv) \
-	DUK_HSTRING_HAS_SYMBOL(DUK_TVAL_GET_STRING((tv)))
+#define DUK_TVAL_STRING_IS_SYMBOL(tv) DUK_HSTRING_HAS_SYMBOL(DUK_TVAL_GET_STRING((tv)))
 
 /* Lightfunc flags packing and unpacking. */
 /* Sign extend: 0x0000##00 -> 0x##000000 -> sign extend to 0xssssss##.
  * Avoid signed shifts due to portability limitations.
  */
-#define DUK_LFUNC_FLAGS_GET_MAGIC(lf_flags) \
-	((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8))
-#define DUK_LFUNC_FLAGS_GET_LENGTH(lf_flags) \
-	(((lf_flags) >> 4) & 0x0fU)
-#define DUK_LFUNC_FLAGS_GET_NARGS(lf_flags) \
-	((lf_flags) & 0x0fU)
-#define DUK_LFUNC_FLAGS_PACK(magic,length,nargs) \
-	((((duk_small_uint_t) (magic)) & 0xffU) << 8) | ((length) << 4) | (nargs)
-
-#define DUK_LFUNC_NARGS_VARARGS             0x0f   /* varargs marker */
-#define DUK_LFUNC_NARGS_MIN                 0x00
-#define DUK_LFUNC_NARGS_MAX                 0x0e   /* max, excl. varargs marker */
-#define DUK_LFUNC_LENGTH_MIN                0x00
-#define DUK_LFUNC_LENGTH_MAX                0x0f
-#define DUK_LFUNC_MAGIC_MIN                 (-0x80)
-#define DUK_LFUNC_MAGIC_MAX                 0x7f
+#define DUK_LFUNC_FLAGS_GET_MAGIC(lf_flags)        ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8))
+#define DUK_LFUNC_FLAGS_GET_LENGTH(lf_flags)       (((lf_flags) >> 4) & 0x0fU)
+#define DUK_LFUNC_FLAGS_GET_NARGS(lf_flags)        ((lf_flags) &0x0fU)
+#define DUK_LFUNC_FLAGS_PACK(magic, length, nargs) ((((duk_small_uint_t) (magic)) & 0xffU) << 8) | ((length) << 4) | (nargs)
+
+#define DUK_LFUNC_NARGS_VARARGS 0x0f /* varargs marker */
+#define DUK_LFUNC_NARGS_MIN     0x00
+#define DUK_LFUNC_NARGS_MAX     0x0e /* max, excl. varargs marker */
+#define DUK_LFUNC_LENGTH_MIN    0x00
+#define DUK_LFUNC_LENGTH_MAX    0x0f
+#define DUK_LFUNC_MAGIC_MIN     (-0x80)
+#define DUK_LFUNC_MAGIC_MAX     0x7f
 
 /* fastint constants etc */
 #if defined(DUK_USE_FASTINT)
-#define DUK_FASTINT_MIN           (DUK_I64_CONSTANT(-0x800000000000))
-#define DUK_FASTINT_MAX           (DUK_I64_CONSTANT(0x7fffffffffff))
-#define DUK_FASTINT_BITS          48
+#define DUK_FASTINT_MIN  (DUK_I64_CONSTANT(-0x800000000000))
+#define DUK_FASTINT_MAX  (DUK_I64_CONSTANT(0x7fffffffffff))
+#define DUK_FASTINT_BITS 48
 
 DUK_INTERNAL_DECL void duk_tval_set_number_chkfast_fast(duk_tval *tv, duk_double_t x);
 DUK_INTERNAL_DECL void duk_tval_set_number_chkfast_slow(duk_tval *tv, duk_double_t x);
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_tval_assert_valid(duk_tval *tv);
-#define DUK_TVAL_ASSERT_VALID(tv)  do { duk_tval_assert_valid((tv)); } while (0)
+#define DUK_TVAL_ASSERT_VALID(tv) \
+	do { \
+		duk_tval_assert_valid((tv)); \
+	} while (0)
 #else
-#define DUK_TVAL_ASSERT_VALID(tv)  do {} while (0)
+#define DUK_TVAL_ASSERT_VALID(tv) \
+	do { \
+	} while (0)
 #endif
 
-#endif  /* DUK_TVAL_H_INCLUDED */
+#endif /* DUK_TVAL_H_INCLUDED */
 /* #include duk_builtins.h */
 #line 1 "duk_builtins.h"
 /*
  *  Automatically generated by genbuiltins.py, do not edit!
  */
 
 #if !defined(DUK_BUILTINS_H_INCLUDED)
@@ -2332,28 +2372,22 @@
 /*
  *  Utilities
  */
 
 #if !defined(DUK_UTIL_H_INCLUDED)
 #define DUK_UTIL_H_INCLUDED
 
-#if defined(DUK_USE_GET_RANDOM_DOUBLE)
-#define DUK_UTIL_GET_RANDOM_DOUBLE(thr) DUK_USE_GET_RANDOM_DOUBLE((thr)->heap_udata)
-#else
-#define DUK_UTIL_GET_RANDOM_DOUBLE(thr) duk_util_tinyrandom_get_double(thr)
-#endif
-
 /*
  *  Some useful constants
  */
 
-#define DUK_DOUBLE_2TO32     4294967296.0
-#define DUK_DOUBLE_2TO31     2147483648.0
-#define DUK_DOUBLE_LOG2E     1.4426950408889634
-#define DUK_DOUBLE_LOG10E    0.4342944819032518
+#define DUK_DOUBLE_2TO32  4294967296.0
+#define DUK_DOUBLE_2TO31  2147483648.0
+#define DUK_DOUBLE_LOG2E  1.4426950408889634
+#define DUK_DOUBLE_LOG10E 0.4342944819032518
 
 /*
  *  Endian conversion
  */
 
 #if defined(DUK_USE_INTEGER_LE)
 #define DUK_HTON32(x) DUK_BSWAP32((x))
@@ -2398,41 +2432,43 @@
 
 /*
  *  Raw write/read macros for big endian, unaligned basic values.
  *  Caller ensures there's enough space.  The INC macro variants
  *  update the pointer argument automatically.
  */
 
-#define DUK_RAW_WRITE_U8(ptr,val)  do { \
+#define DUK_RAW_WRITE_U8(ptr, val) \
+	do { \
 		*(ptr) = (duk_uint8_t) (val); \
 	} while (0)
-#define DUK_RAW_WRITE_U16_BE(ptr,val) duk_raw_write_u16_be((ptr), (duk_uint16_t) (val))
-#define DUK_RAW_WRITE_U32_BE(ptr,val) duk_raw_write_u32_be((ptr), (duk_uint32_t) (val))
-#define DUK_RAW_WRITE_FLOAT_BE(ptr,val) duk_raw_write_float_be((ptr), (duk_float_t) (val))
-#define DUK_RAW_WRITE_DOUBLE_BE(ptr,val) duk_raw_write_double_be((ptr), (duk_double_t) (val))
-#define DUK_RAW_WRITE_XUTF8(ptr,val) duk_raw_write_xutf8((ptr), (duk_ucodepoint_t) (val))
+#define DUK_RAW_WRITE_U16_BE(ptr, val)    duk_raw_write_u16_be((ptr), (duk_uint16_t) (val))
+#define DUK_RAW_WRITE_U32_BE(ptr, val)    duk_raw_write_u32_be((ptr), (duk_uint32_t) (val))
+#define DUK_RAW_WRITE_FLOAT_BE(ptr, val)  duk_raw_write_float_be((ptr), (duk_float_t) (val))
+#define DUK_RAW_WRITE_DOUBLE_BE(ptr, val) duk_raw_write_double_be((ptr), (duk_double_t) (val))
+#define DUK_RAW_WRITE_XUTF8(ptr, val)     duk_raw_write_xutf8((ptr), (duk_ucodepoint_t) (val))
 
-#define DUK_RAW_WRITEINC_U8(ptr,val)  do { \
+#define DUK_RAW_WRITEINC_U8(ptr, val) \
+	do { \
 		*(ptr)++ = (duk_uint8_t) (val); \
 	} while (0)
-#define DUK_RAW_WRITEINC_U16_BE(ptr,val) duk_raw_writeinc_u16_be(&(ptr), (duk_uint16_t) (val))
-#define DUK_RAW_WRITEINC_U32_BE(ptr,val) duk_raw_writeinc_u32_be(&(ptr), (duk_uint32_t) (val))
-#define DUK_RAW_WRITEINC_FLOAT_BE(ptr,val) duk_raw_writeinc_float_be(&(ptr), (duk_float_t) (val))
-#define DUK_RAW_WRITEINC_DOUBLE_BE(ptr,val) duk_raw_writeinc_double_be(&(ptr), (duk_double_t) (val))
-#define DUK_RAW_WRITEINC_XUTF8(ptr,val) duk_raw_writeinc_xutf8(&(ptr), (duk_ucodepoint_t) (val))
-#define DUK_RAW_WRITEINC_CESU8(ptr,val) duk_raw_writeinc_cesu8(&(ptr), (duk_ucodepoint_t) (val))
-
-#define DUK_RAW_READ_U8(ptr) ((duk_uint8_t) (*(ptr)))
-#define DUK_RAW_READ_U16_BE(ptr) duk_raw_read_u16_be((ptr));
-#define DUK_RAW_READ_U32_BE(ptr) duk_raw_read_u32_be((ptr));
+#define DUK_RAW_WRITEINC_U16_BE(ptr, val)    duk_raw_writeinc_u16_be(&(ptr), (duk_uint16_t) (val))
+#define DUK_RAW_WRITEINC_U32_BE(ptr, val)    duk_raw_writeinc_u32_be(&(ptr), (duk_uint32_t) (val))
+#define DUK_RAW_WRITEINC_FLOAT_BE(ptr, val)  duk_raw_writeinc_float_be(&(ptr), (duk_float_t) (val))
+#define DUK_RAW_WRITEINC_DOUBLE_BE(ptr, val) duk_raw_writeinc_double_be(&(ptr), (duk_double_t) (val))
+#define DUK_RAW_WRITEINC_XUTF8(ptr, val)     duk_raw_writeinc_xutf8(&(ptr), (duk_ucodepoint_t) (val))
+#define DUK_RAW_WRITEINC_CESU8(ptr, val)     duk_raw_writeinc_cesu8(&(ptr), (duk_ucodepoint_t) (val))
+
+#define DUK_RAW_READ_U8(ptr)        ((duk_uint8_t) (*(ptr)))
+#define DUK_RAW_READ_U16_BE(ptr)    duk_raw_read_u16_be((ptr));
+#define DUK_RAW_READ_U32_BE(ptr)    duk_raw_read_u32_be((ptr));
 #define DUK_RAW_READ_DOUBLE_BE(ptr) duk_raw_read_double_be((ptr));
 
-#define DUK_RAW_READINC_U8(ptr) ((duk_uint8_t) (*(ptr)++))
-#define DUK_RAW_READINC_U16_BE(ptr) duk_raw_readinc_u16_be(&(ptr));
-#define DUK_RAW_READINC_U32_BE(ptr) duk_raw_readinc_u32_be(&(ptr));
+#define DUK_RAW_READINC_U8(ptr)        ((duk_uint8_t) (*(ptr)++))
+#define DUK_RAW_READINC_U16_BE(ptr)    duk_raw_readinc_u16_be(&(ptr));
+#define DUK_RAW_READINC_U32_BE(ptr)    duk_raw_readinc_u32_be(&(ptr));
 #define DUK_RAW_READINC_DOUBLE_BE(ptr) duk_raw_readinc_double_be(&(ptr));
 
 /*
  *  Double and float byte order operations.
  */
 
 DUK_INTERNAL_DECL void duk_dblunion_host_to_little(duk_double_union *u);
@@ -2471,350 +2507,389 @@
 	duk_uint8_t *p;
 	duk_uint8_t *p_base;
 	duk_uint8_t *p_limit;
 	duk_hbuffer_dynamic *buf;
 };
 
 #if defined(DUK_USE_PREFER_SIZE)
-#define DUK_BW_SLACK_ADD           64
-#define DUK_BW_SLACK_SHIFT         4    /* 2^4 -> 1/16 = 6.25% slack */
+#define DUK_BW_SLACK_ADD   64
+#define DUK_BW_SLACK_SHIFT 4 /* 2^4 -> 1/16 = 6.25% slack */
 #else
-#define DUK_BW_SLACK_ADD           64
-#define DUK_BW_SLACK_SHIFT         2    /* 2^2 -> 1/4 = 25% slack */
+#define DUK_BW_SLACK_ADD   64
+#define DUK_BW_SLACK_SHIFT 2 /* 2^2 -> 1/4 = 25% slack */
 #endif
 
 /* Initialization and finalization (compaction), converting to other types. */
 
-#define DUK_BW_INIT_PUSHBUF(thr,bw_ctx,sz) do { \
+#define DUK_BW_INIT_PUSHBUF(thr, bw_ctx, sz) \
+	do { \
 		duk_bw_init_pushbuf((thr), (bw_ctx), (sz)); \
 	} while (0)
-#define DUK_BW_INIT_WITHBUF(thr,bw_ctx,buf) do { \
+#define DUK_BW_INIT_WITHBUF(thr, bw_ctx, buf) \
+	do { \
 		duk_bw_init((thr), (bw_ctx), (buf)); \
 	} while (0)
-#define DUK_BW_COMPACT(thr,bw_ctx) do { \
+#define DUK_BW_COMPACT(thr, bw_ctx) \
+	do { \
 		/* Make underlying buffer compact to match DUK_BW_GET_SIZE(). */ \
 		duk_bw_compact((thr), (bw_ctx)); \
 	} while (0)
-#define DUK_BW_PUSH_AS_STRING(thr,bw_ctx) do { \
-		duk_push_lstring((thr), \
-		                 (const char *) (bw_ctx)->p_base, \
-		                 (duk_size_t) ((bw_ctx)->p - (bw_ctx)->p_base)); \
+#define DUK_BW_PUSH_AS_STRING(thr, bw_ctx) \
+	do { \
+		duk_push_lstring((thr), (const char *) (bw_ctx)->p_base, (duk_size_t) ((bw_ctx)->p - (bw_ctx)->p_base)); \
 	} while (0)
 
 /* Pointers may be NULL for a while when 'buf' size is zero and before any
  * ENSURE calls have been made.  Once an ENSURE has been made, the pointers
  * are required to be non-NULL so that it's always valid to use memcpy() and
  * memmove(), even for zero size.
  */
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_bw_assert_valid(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx);
-#define DUK_BW_ASSERT_VALID_EXPR(thr,bw_ctx)  (duk_bw_assert_valid((thr), (bw_ctx)))
-#define DUK_BW_ASSERT_VALID(thr,bw_ctx)  do { duk_bw_assert_valid((thr), (bw_ctx)); } while (0)
+#define DUK_BW_ASSERT_VALID_EXPR(thr, bw_ctx) (duk_bw_assert_valid((thr), (bw_ctx)))
+#define DUK_BW_ASSERT_VALID(thr, bw_ctx) \
+	do { \
+		duk_bw_assert_valid((thr), (bw_ctx)); \
+	} while (0)
 #else
-#define DUK_BW_ASSERT_VALID_EXPR(thr,bw_ctx)  DUK_ASSERT_EXPR(1)
-#define DUK_BW_ASSERT_VALID(thr,bw_ctx)  do {} while (0)
+#define DUK_BW_ASSERT_VALID_EXPR(thr, bw_ctx) DUK_ASSERT_EXPR(1)
+#define DUK_BW_ASSERT_VALID(thr, bw_ctx) \
+	do { \
+	} while (0)
 #endif
 
 /* Working with the pointer and current size. */
 
-#define DUK_BW_GET_PTR(thr,bw_ctx) \
-	((bw_ctx)->p)
-#define DUK_BW_SET_PTR(thr,bw_ctx,ptr) do { \
+#define DUK_BW_GET_PTR(thr, bw_ctx) ((bw_ctx)->p)
+#define DUK_BW_SET_PTR(thr, bw_ctx, ptr) \
+	do { \
 		(bw_ctx)->p = (ptr); \
 	} while (0)
-#define DUK_BW_ADD_PTR(thr,bw_ctx,delta) do { \
+#define DUK_BW_ADD_PTR(thr, bw_ctx, delta) \
+	do { \
 		(bw_ctx)->p += (delta); \
 	} while (0)
-#define DUK_BW_GET_BASEPTR(thr,bw_ctx) \
-	((bw_ctx)->p_base)
-#define DUK_BW_GET_LIMITPTR(thr,bw_ctx) \
-	((bw_ctx)->p_limit)
-#define DUK_BW_GET_SIZE(thr,bw_ctx) \
-	((duk_size_t) ((bw_ctx)->p - (bw_ctx)->p_base))
-#define DUK_BW_SET_SIZE(thr,bw_ctx,sz) do { \
+#define DUK_BW_GET_BASEPTR(thr, bw_ctx)  ((bw_ctx)->p_base)
+#define DUK_BW_GET_LIMITPTR(thr, bw_ctx) ((bw_ctx)->p_limit)
+#define DUK_BW_GET_SIZE(thr, bw_ctx)     ((duk_size_t) ((bw_ctx)->p - (bw_ctx)->p_base))
+#define DUK_BW_SET_SIZE(thr, bw_ctx, sz) \
+	do { \
 		DUK_ASSERT((duk_size_t) (sz) <= (duk_size_t) ((bw_ctx)->p - (bw_ctx)->p_base)); \
 		(bw_ctx)->p = (bw_ctx)->p_base + (sz); \
 	} while (0)
-#define DUK_BW_RESET_SIZE(thr,bw_ctx) do { \
+#define DUK_BW_RESET_SIZE(thr, bw_ctx) \
+	do { \
 		/* Reset to zero size, keep current limit. */ \
 		(bw_ctx)->p = (bw_ctx)->p_base; \
 	} while (0)
-#define DUK_BW_GET_BUFFER(thr,bw_ctx) \
-	((bw_ctx)->buf)
+#define DUK_BW_GET_BUFFER(thr, bw_ctx) ((bw_ctx)->buf)
 
 /* Ensuring (reserving) space. */
 
-#define DUK_BW_ENSURE(thr,bw_ctx,sz) do { \
+#define DUK_BW_ENSURE(thr, bw_ctx, sz) \
+	do { \
 		duk_size_t duk__sz, duk__space; \
 		DUK_BW_ASSERT_VALID((thr), (bw_ctx)); \
 		duk__sz = (sz); \
 		duk__space = (duk_size_t) ((bw_ctx)->p_limit - (bw_ctx)->p); \
 		if (duk__space < duk__sz) { \
 			(void) duk_bw_resize((thr), (bw_ctx), duk__sz); \
 		} \
 	} while (0)
 /* NOTE: Multiple evaluation of 'ptr' in this macro. */
 /* XXX: Rework to use an always-inline function? */
-#define DUK_BW_ENSURE_RAW(thr,bw_ctx,sz,ptr) \
-	(((duk_size_t) ((bw_ctx)->p_limit - (ptr)) >= (sz)) ? \
-	 (ptr) : \
-	 ((bw_ctx)->p = (ptr), duk_bw_resize((thr),(bw_ctx),(sz))))
-#define DUK_BW_ENSURE_GETPTR(thr,bw_ctx,sz) \
-	DUK_BW_ENSURE_RAW((thr), (bw_ctx), (sz), (bw_ctx)->p)
-#define DUK_BW_ASSERT_SPACE_EXPR(thr,bw_ctx,sz) \
+#define DUK_BW_ENSURE_RAW(thr, bw_ctx, sz, ptr) \
+	(((duk_size_t) ((bw_ctx)->p_limit - (ptr)) >= (sz)) ? (ptr) : ((bw_ctx)->p = (ptr), duk_bw_resize((thr), (bw_ctx), (sz))))
+#define DUK_BW_ENSURE_GETPTR(thr, bw_ctx, sz) DUK_BW_ENSURE_RAW((thr), (bw_ctx), (sz), (bw_ctx)->p)
+#define DUK_BW_ASSERT_SPACE_EXPR(thr, bw_ctx, sz) \
 	(DUK_BW_ASSERT_VALID_EXPR((thr), (bw_ctx)), \
 	 DUK_ASSERT_EXPR((duk_size_t) ((bw_ctx)->p_limit - (bw_ctx)->p) >= (duk_size_t) (sz)))
-#define DUK_BW_ASSERT_SPACE(thr,bw_ctx,sz) do { \
+#define DUK_BW_ASSERT_SPACE(thr, bw_ctx, sz) \
+	do { \
 		DUK_BW_ASSERT_SPACE_EXPR((thr), (bw_ctx), (sz)); \
 	} while (0)
 
 /* Miscellaneous. */
 
-#define DUK_BW_SETPTR_AND_COMPACT(thr,bw_ctx,ptr) do { \
+#define DUK_BW_SETPTR_AND_COMPACT(thr, bw_ctx, ptr) \
+	do { \
 		(bw_ctx)->p = (ptr); \
 		duk_bw_compact((thr), (bw_ctx)); \
 	} while (0)
 
 /* Fast write calls which assume you control the slack beforehand.
  * Multibyte write variants exist and use a temporary write pointer
  * because byte writes alias with anything: with a stored pointer
  * explicit pointer load/stores get generated (e.g. gcc -Os).
  */
 
-#define DUK_BW_WRITE_RAW_U8(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_U8(thr, bw_ctx, val) \
+	do { \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 1); \
 		*(bw_ctx)->p++ = (duk_uint8_t) (val); \
 	} while (0)
-#define DUK_BW_WRITE_RAW_U8_2(thr,bw_ctx,val1,val2) do { \
+#define DUK_BW_WRITE_RAW_U8_2(thr, bw_ctx, val1, val2) \
+	do { \
 		duk_uint8_t *duk__p; \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 2); \
 		duk__p = (bw_ctx)->p; \
 		*duk__p++ = (duk_uint8_t) (val1); \
 		*duk__p++ = (duk_uint8_t) (val2); \
 		(bw_ctx)->p = duk__p; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_U8_3(thr,bw_ctx,val1,val2,val3) do { \
+#define DUK_BW_WRITE_RAW_U8_3(thr, bw_ctx, val1, val2, val3) \
+	do { \
 		duk_uint8_t *duk__p; \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 3); \
 		duk__p = (bw_ctx)->p; \
 		*duk__p++ = (duk_uint8_t) (val1); \
 		*duk__p++ = (duk_uint8_t) (val2); \
 		*duk__p++ = (duk_uint8_t) (val3); \
 		(bw_ctx)->p = duk__p; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_U8_4(thr,bw_ctx,val1,val2,val3,val4) do { \
+#define DUK_BW_WRITE_RAW_U8_4(thr, bw_ctx, val1, val2, val3, val4) \
+	do { \
 		duk_uint8_t *duk__p; \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 4); \
 		duk__p = (bw_ctx)->p; \
 		*duk__p++ = (duk_uint8_t) (val1); \
 		*duk__p++ = (duk_uint8_t) (val2); \
 		*duk__p++ = (duk_uint8_t) (val3); \
 		*duk__p++ = (duk_uint8_t) (val4); \
 		(bw_ctx)->p = duk__p; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_U8_5(thr,bw_ctx,val1,val2,val3,val4,val5) do { \
+#define DUK_BW_WRITE_RAW_U8_5(thr, bw_ctx, val1, val2, val3, val4, val5) \
+	do { \
 		duk_uint8_t *duk__p; \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 5); \
 		duk__p = (bw_ctx)->p; \
 		*duk__p++ = (duk_uint8_t) (val1); \
 		*duk__p++ = (duk_uint8_t) (val2); \
 		*duk__p++ = (duk_uint8_t) (val3); \
 		*duk__p++ = (duk_uint8_t) (val4); \
 		*duk__p++ = (duk_uint8_t) (val5); \
 		(bw_ctx)->p = duk__p; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_U8_6(thr,bw_ctx,val1,val2,val3,val4,val5,val6) do { \
+#define DUK_BW_WRITE_RAW_U8_6(thr, bw_ctx, val1, val2, val3, val4, val5, val6) \
+	do { \
 		duk_uint8_t *duk__p; \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), 6); \
 		duk__p = (bw_ctx)->p; \
 		*duk__p++ = (duk_uint8_t) (val1); \
 		*duk__p++ = (duk_uint8_t) (val2); \
 		*duk__p++ = (duk_uint8_t) (val3); \
 		*duk__p++ = (duk_uint8_t) (val4); \
 		*duk__p++ = (duk_uint8_t) (val5); \
 		*duk__p++ = (duk_uint8_t) (val6); \
 		(bw_ctx)->p = duk__p; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_XUTF8(thr,bw_ctx,cp) do { \
+#define DUK_BW_WRITE_RAW_XUTF8(thr, bw_ctx, cp) \
+	do { \
 		duk_ucodepoint_t duk__cp; \
 		duk_small_int_t duk__enc_len; \
 		duk__cp = (duk_ucodepoint_t) (cp); \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), duk_unicode_get_xutf8_length(duk__cp)); \
 		duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw_ctx)->p); \
 		(bw_ctx)->p += duk__enc_len; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_CESU8(thr,bw_ctx,cp) do { \
+#define DUK_BW_WRITE_RAW_CESU8(thr, bw_ctx, cp) \
+	do { \
 		duk_ucodepoint_t duk__cp; \
 		duk_small_int_t duk__enc_len; \
 		duk__cp = (duk_ucodepoint_t) (cp); \
 		DUK_BW_ASSERT_SPACE((thr), (bw_ctx), duk_unicode_get_cesu8_length(duk__cp)); \
 		duk__enc_len = duk_unicode_encode_cesu8(duk__cp, (bw_ctx)->p); \
 		(bw_ctx)->p += duk__enc_len; \
 	} while (0)
 /* XXX: add temporary duk__p pointer here too; sharing */
 /* XXX: avoid unsafe variants */
-#define DUK_BW_WRITE_RAW_BYTES(thr,bw_ctx,valptr,valsz) do { \
+#define DUK_BW_WRITE_RAW_BYTES(thr, bw_ctx, valptr, valsz) \
+	do { \
 		const void *duk__valptr; \
 		duk_size_t duk__valsz; \
 		duk__valptr = (const void *) (valptr); \
 		duk__valsz = (duk_size_t) (valsz); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), duk__valptr, duk__valsz); \
 		(bw_ctx)->p += duk__valsz; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_CSTRING(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_CSTRING(thr, bw_ctx, val) \
+	do { \
 		const duk_uint8_t *duk__val; \
 		duk_size_t duk__val_len; \
 		duk__val = (const duk_uint8_t *) (val); \
 		duk__val_len = DUK_STRLEN((const char *) duk__val); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) duk__val, duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_HSTRING(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_HSTRING(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HSTRING_GET_BYTELEN((val)); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HSTRING_GET_DATA((val)), duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_HBUFFER(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_HBUFFER(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_GET_SIZE((val)); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_HBUFFER_FIXED(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_HBUFFER_FIXED(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_FIXED_GET_SIZE((val)); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_FIXED_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_FIXED_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_RAW_HBUFFER_DYNAMIC(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_RAW_HBUFFER_DYNAMIC(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_DYNAMIC_GET_SIZE((val)); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
 
 /* Append bytes from a slice already in the buffer. */
-#define DUK_BW_WRITE_RAW_SLICE(thr,bw,dst_off,dst_len) \
-	duk_bw_write_raw_slice((thr), (bw), (dst_off), (dst_len))
+#define DUK_BW_WRITE_RAW_SLICE(thr, bw, dst_off, dst_len) duk_bw_write_raw_slice((thr), (bw), (dst_off), (dst_len))
 
 /* Insert bytes in the middle of the buffer from an external buffer. */
-#define DUK_BW_INSERT_RAW_BYTES(thr,bw,dst_off,buf,len) \
-	duk_bw_insert_raw_bytes((thr), (bw), (dst_off), (buf), (len))
+#define DUK_BW_INSERT_RAW_BYTES(thr, bw, dst_off, buf, len) duk_bw_insert_raw_bytes((thr), (bw), (dst_off), (buf), (len))
 
 /* Insert bytes in the middle of the buffer from a slice already
  * in the buffer.  Source offset is interpreted "before" the operation.
  */
-#define DUK_BW_INSERT_RAW_SLICE(thr,bw,dst_off,src_off,len) \
-	duk_bw_insert_raw_slice((thr), (bw), (dst_off), (src_off), (len))
+#define DUK_BW_INSERT_RAW_SLICE(thr, bw, dst_off, src_off, len) duk_bw_insert_raw_slice((thr), (bw), (dst_off), (src_off), (len))
 
 /* Insert a reserved area somewhere in the buffer; caller fills it.
  * Evaluates to a (duk_uint_t *) pointing to the start of the reserved
  * area for convenience.
  */
-#define DUK_BW_INSERT_RAW_AREA(thr,bw,off,len) \
-	duk_bw_insert_raw_area((thr), (bw), (off), (len))
+#define DUK_BW_INSERT_RAW_AREA(thr, bw, off, len) duk_bw_insert_raw_area((thr), (bw), (off), (len))
 
 /* Remove a slice from inside buffer. */
-#define DUK_BW_REMOVE_RAW_SLICE(thr,bw,off,len) \
-	duk_bw_remove_raw_slice((thr), (bw), (off), (len))
+#define DUK_BW_REMOVE_RAW_SLICE(thr, bw, off, len) duk_bw_remove_raw_slice((thr), (bw), (off), (len))
 
 /* Safe write calls which will ensure space first. */
 
-#define DUK_BW_WRITE_ENSURE_U8(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_U8(thr, bw_ctx, val) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 1); \
 		DUK_BW_WRITE_RAW_U8((thr), (bw_ctx), (val)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_U8_2(thr,bw_ctx,val1,val2) do { \
+#define DUK_BW_WRITE_ENSURE_U8_2(thr, bw_ctx, val1, val2) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 2); \
 		DUK_BW_WRITE_RAW_U8_2((thr), (bw_ctx), (val1), (val2)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_U8_3(thr,bw_ctx,val1,val2,val3) do { \
+#define DUK_BW_WRITE_ENSURE_U8_3(thr, bw_ctx, val1, val2, val3) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 3); \
 		DUK_BW_WRITE_RAW_U8_3((thr), (bw_ctx), (val1), (val2), (val3)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_U8_4(thr,bw_ctx,val1,val2,val3,val4) do { \
+#define DUK_BW_WRITE_ENSURE_U8_4(thr, bw_ctx, val1, val2, val3, val4) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 4); \
 		DUK_BW_WRITE_RAW_U8_4((thr), (bw_ctx), (val1), (val2), (val3), (val4)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_U8_5(thr,bw_ctx,val1,val2,val3,val4,val5) do { \
+#define DUK_BW_WRITE_ENSURE_U8_5(thr, bw_ctx, val1, val2, val3, val4, val5) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 5); \
 		DUK_BW_WRITE_RAW_U8_5((thr), (bw_ctx), (val1), (val2), (val3), (val4), (val5)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_U8_6(thr,bw_ctx,val1,val2,val3,val4,val5,val6) do { \
+#define DUK_BW_WRITE_ENSURE_U8_6(thr, bw_ctx, val1, val2, val3, val4, val5, val6) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), 6); \
 		DUK_BW_WRITE_RAW_U8_6((thr), (bw_ctx), (val1), (val2), (val3), (val4), (val5), (val6)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_XUTF8(thr,bw_ctx,cp) do { \
+#define DUK_BW_WRITE_ENSURE_XUTF8(thr, bw_ctx, cp) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), DUK_UNICODE_MAX_XUTF8_LENGTH); \
 		DUK_BW_WRITE_RAW_XUTF8((thr), (bw_ctx), (cp)); \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_CESU8(thr,bw_ctx,cp) do { \
+#define DUK_BW_WRITE_ENSURE_CESU8(thr, bw_ctx, cp) \
+	do { \
 		DUK_BW_ENSURE((thr), (bw_ctx), DUK_UNICODE_MAX_CESU8_LENGTH); \
 		DUK_BW_WRITE_RAW_CESU8((thr), (bw_ctx), (cp)); \
 	} while (0)
 /* XXX: add temporary duk__p pointer here too; sharing */
 /* XXX: avoid unsafe */
-#define DUK_BW_WRITE_ENSURE_BYTES(thr,bw_ctx,valptr,valsz) do { \
+#define DUK_BW_WRITE_ENSURE_BYTES(thr, bw_ctx, valptr, valsz) \
+	do { \
 		const void *duk__valptr; \
 		duk_size_t duk__valsz; \
 		duk__valptr = (const void *) (valptr); \
 		duk__valsz = (duk_size_t) (valsz); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__valsz); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), duk__valptr, duk__valsz); \
 		(bw_ctx)->p += duk__valsz; \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_CSTRING(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_CSTRING(thr, bw_ctx, val) \
+	do { \
 		const duk_uint8_t *duk__val; \
 		duk_size_t duk__val_len; \
 		duk__val = (const duk_uint8_t *) (val); \
 		duk__val_len = DUK_STRLEN((const char *) duk__val); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__val_len); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) duk__val, duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_HSTRING(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_HSTRING(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HSTRING_GET_BYTELEN((val)); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__val_len); \
 		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HSTRING_GET_DATA((val)), duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_HBUFFER(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_HBUFFER(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_GET_SIZE((val)); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__val_len); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_HBUFFER_FIXED(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_HBUFFER_FIXED(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_FIXED_GET_SIZE((val)); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__val_len); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_FIXED_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_FIXED_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
-#define DUK_BW_WRITE_ENSURE_HBUFFER_DYNAMIC(thr,bw_ctx,val) do { \
+#define DUK_BW_WRITE_ENSURE_HBUFFER_DYNAMIC(thr, bw_ctx, val) \
+	do { \
 		duk_size_t duk__val_len; \
 		duk__val_len = DUK_HBUFFER_DYNAMIC_GET_SIZE((val)); \
 		DUK_BW_ENSURE((thr), (bw_ctx), duk__val_len); \
-		duk_memcpy_unsafe((void *) ((bw_ctx)->p), (const void *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((thr)->heap, (val)), duk__val_len); \
+		duk_memcpy_unsafe((void *) ((bw_ctx)->p), \
+		                  (const void *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((thr)->heap, (val)), \
+		                  duk__val_len); \
 		(bw_ctx)->p += duk__val_len; \
 	} while (0)
 
-#define DUK_BW_WRITE_ENSURE_SLICE(thr,bw,dst_off,dst_len) \
-	duk_bw_write_ensure_slice((thr), (bw), (dst_off), (dst_len))
-#define DUK_BW_INSERT_ENSURE_BYTES(thr,bw,dst_off,buf,len) \
-	duk_bw_insert_ensure_bytes((thr), (bw), (dst_off), (buf), (len))
-#define DUK_BW_INSERT_ENSURE_SLICE(thr,bw,dst_off,src_off,len) \
+#define DUK_BW_WRITE_ENSURE_SLICE(thr, bw, dst_off, dst_len)   duk_bw_write_ensure_slice((thr), (bw), (dst_off), (dst_len))
+#define DUK_BW_INSERT_ENSURE_BYTES(thr, bw, dst_off, buf, len) duk_bw_insert_ensure_bytes((thr), (bw), (dst_off), (buf), (len))
+#define DUK_BW_INSERT_ENSURE_SLICE(thr, bw, dst_off, src_off, len) \
 	duk_bw_insert_ensure_slice((thr), (bw), (dst_off), (src_off), (len))
-#define DUK_BW_INSERT_ENSURE_AREA(thr,bw,off,len) \
+#define DUK_BW_INSERT_ENSURE_AREA(thr, bw, off, len) \
 	/* Evaluates to (duk_uint8_t *) pointing to start of area. */ \
 	duk_bw_insert_ensure_area((thr), (bw), (off), (len))
-#define DUK_BW_REMOVE_ENSURE_SLICE(thr,bw,off,len) \
+#define DUK_BW_REMOVE_ENSURE_SLICE(thr, bw, off, len) \
 	/* No difference between raw/ensure because the buffer shrinks. */ \
 	DUK_BW_REMOVE_RAW_SLICE((thr), (bw), (off), (len))
 
 /*
  *  Externs and prototypes
  */
 
@@ -2822,21 +2897,21 @@
 DUK_INTERNAL_DECL const duk_uint8_t duk_lc_digits[36];
 DUK_INTERNAL_DECL const duk_uint8_t duk_uc_nybbles[16];
 DUK_INTERNAL_DECL const duk_int8_t duk_hex_dectab[256];
 #if defined(DUK_USE_HEX_FASTPATH)
 DUK_INTERNAL_DECL const duk_int16_t duk_hex_dectab_shift4[256];
 DUK_INTERNAL_DECL const duk_uint16_t duk_hex_enctab[256];
 #endif
-#endif  /* !DUK_SINGLE_FILE */
+#endif /* !DUK_SINGLE_FILE */
 
 /* Note: assumes that duk_util_probe_steps size is 32 */
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 #if !defined(DUK_SINGLE_FILE)
 DUK_INTERNAL_DECL duk_uint8_t duk_util_probe_steps[32];
-#endif  /* !DUK_SINGLE_FILE */
+#endif /* !DUK_SINGLE_FILE */
 #endif
 
 #if defined(DUK_USE_STRHASH_DENSE)
 DUK_INTERNAL_DECL duk_uint32_t duk_util_hashbytes(const duk_uint8_t *data, duk_size_t len, duk_uint32_t seed);
 #endif
 
 DUK_INTERNAL_DECL duk_uint32_t duk_bd_decode(duk_bitdecoder_ctx *ctx, duk_small_int_t bits);
@@ -2856,18 +2931,34 @@
 
 DUK_INTERNAL_DECL void duk_bw_init(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_hbuffer_dynamic *h_buf);
 DUK_INTERNAL_DECL void duk_bw_init_pushbuf(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t buf_size);
 DUK_INTERNAL_DECL duk_uint8_t *duk_bw_resize(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t sz);
 DUK_INTERNAL_DECL void duk_bw_compact(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx);
 DUK_INTERNAL_DECL void duk_bw_write_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
 DUK_INTERNAL_DECL void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
-DUK_INTERNAL_DECL void duk_bw_insert_raw_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len);
-DUK_INTERNAL_DECL void duk_bw_insert_ensure_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len);
-DUK_INTERNAL_DECL void duk_bw_insert_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len);
-DUK_INTERNAL_DECL void duk_bw_insert_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len);
+DUK_INTERNAL_DECL void duk_bw_insert_raw_bytes(duk_hthread *thr,
+                                               duk_bufwriter_ctx *bw,
+                                               duk_size_t dst_off,
+                                               const duk_uint8_t *buf,
+                                               duk_size_t len);
+DUK_INTERNAL_DECL void duk_bw_insert_ensure_bytes(duk_hthread *thr,
+                                                  duk_bufwriter_ctx *bw,
+                                                  duk_size_t dst_off,
+                                                  const duk_uint8_t *buf,
+                                                  duk_size_t len);
+DUK_INTERNAL_DECL void duk_bw_insert_raw_slice(duk_hthread *thr,
+                                               duk_bufwriter_ctx *bw,
+                                               duk_size_t dst_off,
+                                               duk_size_t src_off,
+                                               duk_size_t len);
+DUK_INTERNAL_DECL void duk_bw_insert_ensure_slice(duk_hthread *thr,
+                                                  duk_bufwriter_ctx *bw,
+                                                  duk_size_t dst_off,
+                                                  duk_size_t src_off,
+                                                  duk_size_t len);
 DUK_INTERNAL_DECL duk_uint8_t *duk_bw_insert_raw_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
 DUK_INTERNAL_DECL duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
 DUK_INTERNAL_DECL void duk_bw_remove_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
 /* No duk_bw_remove_ensure_slice(), functionality would be identical. */
 
 DUK_INTERNAL_DECL duk_uint16_t duk_raw_read_u16_be(const duk_uint8_t *p);
 DUK_INTERNAL_DECL duk_uint32_t duk_raw_read_u32_be(const duk_uint8_t *p);
@@ -2886,135 +2977,149 @@
 DUK_INTERNAL_DECL void duk_raw_writeinc_u16_be(duk_uint8_t **p, duk_uint16_t val);
 DUK_INTERNAL_DECL void duk_raw_writeinc_u32_be(duk_uint8_t **p, duk_uint32_t val);
 DUK_INTERNAL_DECL void duk_raw_writeinc_float_be(duk_uint8_t **p, duk_float_t val);
 DUK_INTERNAL_DECL void duk_raw_writeinc_double_be(duk_uint8_t **p, duk_double_t val);
 DUK_INTERNAL_DECL void duk_raw_writeinc_xutf8(duk_uint8_t **p, duk_ucodepoint_t val);
 DUK_INTERNAL_DECL void duk_raw_writeinc_cesu8(duk_uint8_t **p, duk_ucodepoint_t val);
 
-#if defined(DUK_USE_DEBUGGER_SUPPORT)  /* For now only needed by the debugger. */
+#if defined(DUK_USE_DEBUGGER_SUPPORT) /* For now only needed by the debugger. */
 DUK_INTERNAL_DECL void duk_byteswap_bytes(duk_uint8_t *p, duk_small_uint_t len);
 #endif
 
+DUK_INTERNAL_DECL duk_double_t duk_util_get_random_double(duk_hthread *thr);
+
 /* memcpy(), memmove() etc wrappers.  The plain variants like duk_memcpy()
  * assume C99+ and 'src' and 'dst' pointers must be non-NULL even when the
  * operation size is zero.  The unsafe variants like duk_memcpy_safe() deal
  * with the zero size case explicitly, and allow NULL pointers in that case
  * (which is undefined behavior in C99+).  For the majority of actual targets
  * a NULL pointer with a zero length is fine in practice.  These wrappers are
  * macros to force inlining; because there are hundreds of call sites, even a
  * few extra bytes per call site adds up to ~1kB footprint.
  */
 #if defined(DUK_USE_ALLOW_UNDEFINED_BEHAVIOR)
-#define duk_memcpy(dst,src,len)  do { \
+#define duk_memcpy(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		DUK_ASSERT(duk__src != NULL || duk__len == 0U); \
 		(void) DUK_MEMCPY(duk__dst, duk__src, (size_t) duk__len); \
 	} while (0)
-#define duk_memcpy_unsafe(dst,src,len)  duk_memcpy((dst), (src), (len))
-#define duk_memmove(dst,src,len)  do { \
+#define duk_memcpy_unsafe(dst, src, len) duk_memcpy((dst), (src), (len))
+#define duk_memmove(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		DUK_ASSERT(duk__src != NULL || duk__len == 0U); \
 		(void) DUK_MEMMOVE(duk__dst, duk__src, (size_t) duk__len); \
 	} while (0)
-#define duk_memmove_unsafe(dst,src,len)  duk_memmove((dst), (src), (len))
-#define duk_memset(dst,val,len)  do { \
+#define duk_memmove_unsafe(dst, src, len) duk_memmove((dst), (src), (len))
+#define duk_memset(dst, val, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_small_int_t duk__val = (val); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		(void) DUK_MEMSET(duk__dst, duk__val, (size_t) duk__len); \
 	} while (0)
-#define duk_memset_unsafe(dst,val,len)  duk_memset((dst), (val), (len))
-#define duk_memzero(dst,len)  do { \
+#define duk_memset_unsafe(dst, val, len) duk_memset((dst), (val), (len))
+#define duk_memzero(dst, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		(void) DUK_MEMZERO(duk__dst, (size_t) duk__len); \
 	} while (0)
-#define duk_memzero_unsafe(dst,len)  duk_memzero((dst), (len))
-#else  /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
-#define duk_memcpy(dst,src,len)  do { \
+#define duk_memzero_unsafe(dst, len) duk_memzero((dst), (len))
+#else /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
+#define duk_memcpy(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL); \
 		DUK_ASSERT(duk__src != NULL); \
 		(void) DUK_MEMCPY(duk__dst, duk__src, (size_t) duk__len); \
 	} while (0)
-#define duk_memcpy_unsafe(dst,src,len)  do { \
+#define duk_memcpy_unsafe(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		DUK_ASSERT(duk__src != NULL || duk__len == 0U); \
 		if (DUK_LIKELY(duk__len > 0U)) { \
 			DUK_ASSERT(duk__dst != NULL); \
 			DUK_ASSERT(duk__src != NULL); \
 			(void) DUK_MEMCPY(duk__dst, duk__src, (size_t) duk__len); \
 		} \
 	} while (0)
-#define duk_memmove(dst,src,len)  do { \
+#define duk_memmove(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL); \
 		DUK_ASSERT(duk__src != NULL); \
 		(void) DUK_MEMMOVE(duk__dst, duk__src, (size_t) duk__len); \
 	} while (0)
-#define duk_memmove_unsafe(dst,src,len)  do { \
+#define duk_memmove_unsafe(dst, src, len) \
+	do { \
 		void *duk__dst = (dst); \
 		const void *duk__src = (src); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		DUK_ASSERT(duk__src != NULL || duk__len == 0U); \
 		if (DUK_LIKELY(duk__len > 0U)) { \
 			DUK_ASSERT(duk__dst != NULL); \
 			DUK_ASSERT(duk__src != NULL); \
 			(void) DUK_MEMMOVE(duk__dst, duk__src, (size_t) duk__len); \
 		} \
 	} while (0)
-#define duk_memset(dst,val,len)  do { \
+#define duk_memset(dst, val, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_small_int_t duk__val = (val); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL); \
 		(void) DUK_MEMSET(duk__dst, duk__val, (size_t) duk__len); \
 	} while (0)
-#define duk_memset_unsafe(dst,val,len)  do { \
+#define duk_memset_unsafe(dst, val, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_small_int_t duk__val = (val); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		if (DUK_LIKELY(duk__len > 0U)) { \
 			DUK_ASSERT(duk__dst != NULL); \
 			(void) DUK_MEMSET(duk__dst, duk__val, (size_t) duk__len); \
 		} \
 	} while (0)
-#define duk_memzero(dst,len)  do { \
+#define duk_memzero(dst, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL); \
 		(void) DUK_MEMZERO(duk__dst, (size_t) duk__len); \
 	} while (0)
-#define duk_memzero_unsafe(dst,len)  do { \
+#define duk_memzero_unsafe(dst, len) \
+	do { \
 		void *duk__dst = (dst); \
 		duk_size_t duk__len = (len); \
 		DUK_ASSERT(duk__dst != NULL || duk__len == 0U); \
 		if (DUK_LIKELY(duk__len > 0U)) { \
 			DUK_ASSERT(duk__dst != NULL); \
 			(void) DUK_MEMZERO(duk__dst, (size_t) duk__len); \
 		} \
 	} while (0)
-#endif  /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
+#endif /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
 
 DUK_INTERNAL_DECL duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len);
 DUK_INTERNAL_DECL duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len);
 
 DUK_INTERNAL_DECL duk_bool_t duk_is_whole_get_int32_nonegzero(duk_double_t x, duk_int32_t *ival);
 DUK_INTERNAL_DECL duk_bool_t duk_is_whole_get_int32(duk_double_t x, duk_int32_t *ival);
 DUK_INTERNAL_DECL duk_bool_t duk_double_is_anyinf(duk_double_t x);
@@ -3052,18 +3157,17 @@
  *
  *          x     = 0x07 = 0b00000111
  *          x - 1 = 0x06 = 0b00000110
  *          x & (x - 1) != 0
  *
  * However, incorrectly true for x == 0 so check for that explicitly.
  */
-#define DUK_IS_POWER_OF_TWO(x) \
-	((x) != 0U && ((x) & ((x) - 1U)) == 0U)
+#define DUK_IS_POWER_OF_TWO(x) ((x) != 0U && ((x) & ((x) -1U)) == 0U)
 
-#endif  /* DUK_UTIL_H_INCLUDED */
+#endif /* DUK_UTIL_H_INCLUDED */
 /* #include duk_strings.h */
 #line 1 "duk_strings.h"
 /*
  *  Shared string macros.
  *
  *  Using shared macros helps minimize strings data size because it's easy
  *  to check if an existing string could be used.  String constants don't
@@ -3082,159 +3186,159 @@
  *  them anyway, and such strings won't end up unnecessarily in a symbol table.
  */
 
 #if !defined(DUK_ERRMSG_H_INCLUDED)
 #define DUK_ERRMSG_H_INCLUDED
 
 /* Mostly API and built-in method related */
-#define DUK_STR_INTERNAL_ERROR                   "internal error"
-#define DUK_STR_UNSUPPORTED                      "unsupported"
-#define DUK_STR_INVALID_COUNT                    "invalid count"
-#define DUK_STR_INVALID_ARGS                     "invalid args"
-#define DUK_STR_INVALID_STATE                    "invalid state"
-#define DUK_STR_INVALID_INPUT                    "invalid input"
-#define DUK_STR_INVALID_LENGTH                   "invalid length"
-#define DUK_STR_NOT_CONSTRUCTABLE                "not constructable"
-#define DUK_STR_CONSTRUCT_ONLY                   "constructor requires 'new'"
-#define DUK_STR_NOT_CALLABLE                     "not callable"
-#define DUK_STR_NOT_EXTENSIBLE                   "not extensible"
-#define DUK_STR_NOT_WRITABLE                     "not writable"
-#define DUK_STR_NOT_CONFIGURABLE                 "not configurable"
-#define DUK_STR_INVALID_CONTEXT                  "invalid context"
-#define DUK_STR_INVALID_INDEX                    "invalid args"
-#define DUK_STR_PUSH_BEYOND_ALLOC_STACK          "cannot push beyond allocated stack"
-#define DUK_STR_NOT_UNDEFINED                    "unexpected type"
-#define DUK_STR_NOT_NULL                         "unexpected type"
-#define DUK_STR_NOT_BOOLEAN                      "unexpected type"
-#define DUK_STR_NOT_NUMBER                       "unexpected type"
-#define DUK_STR_NOT_STRING                       "unexpected type"
-#define DUK_STR_NOT_OBJECT                       "unexpected type"
-#define DUK_STR_NOT_POINTER                      "unexpected type"
-#define DUK_STR_NOT_BUFFER                       "not buffer"  /* still in use with verbose messages */
-#define DUK_STR_UNEXPECTED_TYPE                  "unexpected type"
-#define DUK_STR_NOT_THREAD                       "unexpected type"
-#define DUK_STR_NOT_COMPFUNC                     "unexpected type"
-#define DUK_STR_NOT_NATFUNC                      "unexpected type"
-#define DUK_STR_NOT_C_FUNCTION                   "unexpected type"
-#define DUK_STR_NOT_FUNCTION                     "unexpected type"
-#define DUK_STR_NOT_REGEXP                       "unexpected type"
-#define DUK_STR_TOPRIMITIVE_FAILED               "coercion to primitive failed"
-#define DUK_STR_NUMBER_OUTSIDE_RANGE             "number outside range"
-#define DUK_STR_NOT_OBJECT_COERCIBLE             "not object coercible"
-#define DUK_STR_CANNOT_NUMBER_COERCE_SYMBOL      "cannot number coerce Symbol"
-#define DUK_STR_CANNOT_STRING_COERCE_SYMBOL      "cannot string coerce Symbol"
-#define DUK_STR_STRING_TOO_LONG                  "string too long"
-#define DUK_STR_BUFFER_TOO_LONG                  "buffer too long"
-#define DUK_STR_ALLOC_FAILED                     "alloc failed"
-#define DUK_STR_WRONG_BUFFER_TYPE                "wrong buffer type"
-#define DUK_STR_BASE64_ENCODE_FAILED             "base64 encode failed"
-#define DUK_STR_SOURCE_DECODE_FAILED             "source decode failed"
-#define DUK_STR_UTF8_DECODE_FAILED               "utf-8 decode failed"
-#define DUK_STR_BASE64_DECODE_FAILED             "base64 decode failed"
-#define DUK_STR_HEX_DECODE_FAILED                "hex decode failed"
-#define DUK_STR_INVALID_BYTECODE                 "invalid bytecode"
-#define DUK_STR_NO_SOURCECODE                    "no sourcecode"
-#define DUK_STR_RESULT_TOO_LONG                  "result too long"
-#define DUK_STR_INVALID_CFUNC_RC                 "invalid C function rc"
-#define DUK_STR_INVALID_INSTANCEOF_RVAL          "invalid instanceof rval"
-#define DUK_STR_INVALID_INSTANCEOF_RVAL_NOPROTO  "instanceof rval has no .prototype"
+#define DUK_STR_INTERNAL_ERROR                  "internal error"
+#define DUK_STR_UNSUPPORTED                     "unsupported"
+#define DUK_STR_INVALID_COUNT                   "invalid count"
+#define DUK_STR_INVALID_ARGS                    "invalid args"
+#define DUK_STR_INVALID_STATE                   "invalid state"
+#define DUK_STR_INVALID_INPUT                   "invalid input"
+#define DUK_STR_INVALID_LENGTH                  "invalid length"
+#define DUK_STR_NOT_CONSTRUCTABLE               "not constructable"
+#define DUK_STR_CONSTRUCT_ONLY                  "constructor requires 'new'"
+#define DUK_STR_NOT_CALLABLE                    "not callable"
+#define DUK_STR_NOT_EXTENSIBLE                  "not extensible"
+#define DUK_STR_NOT_WRITABLE                    "not writable"
+#define DUK_STR_NOT_CONFIGURABLE                "not configurable"
+#define DUK_STR_INVALID_CONTEXT                 "invalid context"
+#define DUK_STR_INVALID_INDEX                   "invalid args"
+#define DUK_STR_PUSH_BEYOND_ALLOC_STACK         "cannot push beyond allocated stack"
+#define DUK_STR_NOT_UNDEFINED                   "unexpected type"
+#define DUK_STR_NOT_NULL                        "unexpected type"
+#define DUK_STR_NOT_BOOLEAN                     "unexpected type"
+#define DUK_STR_NOT_NUMBER                      "unexpected type"
+#define DUK_STR_NOT_STRING                      "unexpected type"
+#define DUK_STR_NOT_OBJECT                      "unexpected type"
+#define DUK_STR_NOT_POINTER                     "unexpected type"
+#define DUK_STR_NOT_BUFFER                      "not buffer" /* still in use with verbose messages */
+#define DUK_STR_UNEXPECTED_TYPE                 "unexpected type"
+#define DUK_STR_NOT_THREAD                      "unexpected type"
+#define DUK_STR_NOT_COMPFUNC                    "unexpected type"
+#define DUK_STR_NOT_NATFUNC                     "unexpected type"
+#define DUK_STR_NOT_C_FUNCTION                  "unexpected type"
+#define DUK_STR_NOT_FUNCTION                    "unexpected type"
+#define DUK_STR_NOT_REGEXP                      "unexpected type"
+#define DUK_STR_TOPRIMITIVE_FAILED              "coercion to primitive failed"
+#define DUK_STR_NUMBER_OUTSIDE_RANGE            "number outside range"
+#define DUK_STR_NOT_OBJECT_COERCIBLE            "not object coercible"
+#define DUK_STR_CANNOT_NUMBER_COERCE_SYMBOL     "cannot number coerce Symbol"
+#define DUK_STR_CANNOT_STRING_COERCE_SYMBOL     "cannot string coerce Symbol"
+#define DUK_STR_STRING_TOO_LONG                 "string too long"
+#define DUK_STR_BUFFER_TOO_LONG                 "buffer too long"
+#define DUK_STR_ALLOC_FAILED                    "alloc failed"
+#define DUK_STR_WRONG_BUFFER_TYPE               "wrong buffer type"
+#define DUK_STR_BASE64_ENCODE_FAILED            "base64 encode failed"
+#define DUK_STR_SOURCE_DECODE_FAILED            "source decode failed"
+#define DUK_STR_UTF8_DECODE_FAILED              "utf-8 decode failed"
+#define DUK_STR_BASE64_DECODE_FAILED            "base64 decode failed"
+#define DUK_STR_HEX_DECODE_FAILED               "hex decode failed"
+#define DUK_STR_INVALID_BYTECODE                "invalid bytecode"
+#define DUK_STR_NO_SOURCECODE                   "no sourcecode"
+#define DUK_STR_RESULT_TOO_LONG                 "result too long"
+#define DUK_STR_INVALID_CFUNC_RC                "invalid C function rc"
+#define DUK_STR_INVALID_INSTANCEOF_RVAL         "invalid instanceof rval"
+#define DUK_STR_INVALID_INSTANCEOF_RVAL_NOPROTO "instanceof rval has no .prototype"
 
 /* JSON */
-#define DUK_STR_FMT_PTR                          "%p"
-#define DUK_STR_FMT_INVALID_JSON                 "invalid json (at offset %ld)"
-#define DUK_STR_CYCLIC_INPUT                     "cyclic input"
+#define DUK_STR_FMT_PTR          "%p"
+#define DUK_STR_FMT_INVALID_JSON "invalid json (at offset %ld)"
+#define DUK_STR_CYCLIC_INPUT     "cyclic input"
 
 /* Generic codec */
-#define DUK_STR_DEC_RECLIMIT                     "decode recursion limit"
-#define DUK_STR_ENC_RECLIMIT                     "encode recursion limit"
+#define DUK_STR_DEC_RECLIMIT "decode recursion limit"
+#define DUK_STR_ENC_RECLIMIT "encode recursion limit"
 
 /* Object property access */
-#define DUK_STR_INVALID_BASE                     "invalid base value"
-#define DUK_STR_STRICT_CALLER_READ               "cannot read strict 'caller'"
-#define DUK_STR_PROXY_REJECTED                   "proxy rejected"
-#define DUK_STR_INVALID_ARRAY_LENGTH             "invalid array length"
-#define DUK_STR_SETTER_UNDEFINED                 "setter undefined"
-#define DUK_STR_INVALID_DESCRIPTOR               "invalid descriptor"
+#define DUK_STR_INVALID_BASE         "invalid base value"
+#define DUK_STR_STRICT_CALLER_READ   "cannot read strict 'caller'"
+#define DUK_STR_PROXY_REJECTED       "proxy rejected"
+#define DUK_STR_INVALID_ARRAY_LENGTH "invalid array length"
+#define DUK_STR_SETTER_UNDEFINED     "setter undefined"
+#define DUK_STR_INVALID_DESCRIPTOR   "invalid descriptor"
 
 /* Proxy */
-#define DUK_STR_PROXY_REVOKED                    "proxy revoked"
-#define DUK_STR_INVALID_TRAP_RESULT              "invalid trap result"
+#define DUK_STR_PROXY_REVOKED       "proxy revoked"
+#define DUK_STR_INVALID_TRAP_RESULT "invalid trap result"
 
 /* Variables */
 
 /* Lexer */
-#define DUK_STR_INVALID_ESCAPE                   "invalid escape"
-#define DUK_STR_UNTERMINATED_STRING              "unterminated string"
-#define DUK_STR_UNTERMINATED_COMMENT             "unterminated comment"
-#define DUK_STR_UNTERMINATED_REGEXP              "unterminated regexp"
-#define DUK_STR_TOKEN_LIMIT                      "token limit"
-#define DUK_STR_REGEXP_SUPPORT_DISABLED          "regexp support disabled"
-#define DUK_STR_INVALID_NUMBER_LITERAL           "invalid number literal"
-#define DUK_STR_INVALID_TOKEN                    "invalid token"
+#define DUK_STR_INVALID_ESCAPE          "invalid escape"
+#define DUK_STR_UNTERMINATED_STRING     "unterminated string"
+#define DUK_STR_UNTERMINATED_COMMENT    "unterminated comment"
+#define DUK_STR_UNTERMINATED_REGEXP     "unterminated regexp"
+#define DUK_STR_TOKEN_LIMIT             "token limit"
+#define DUK_STR_REGEXP_SUPPORT_DISABLED "regexp support disabled"
+#define DUK_STR_INVALID_NUMBER_LITERAL  "invalid number literal"
+#define DUK_STR_INVALID_TOKEN           "invalid token"
 
 /* Compiler */
-#define DUK_STR_PARSE_ERROR                      "parse error"
-#define DUK_STR_DUPLICATE_LABEL                  "duplicate label"
-#define DUK_STR_INVALID_LABEL                    "invalid label"
-#define DUK_STR_INVALID_ARRAY_LITERAL            "invalid array literal"
-#define DUK_STR_INVALID_OBJECT_LITERAL           "invalid object literal"
-#define DUK_STR_INVALID_VAR_DECLARATION          "invalid variable declaration"
-#define DUK_STR_CANNOT_DELETE_IDENTIFIER         "cannot delete identifier"
-#define DUK_STR_INVALID_EXPRESSION               "invalid expression"
-#define DUK_STR_INVALID_LVALUE                   "invalid lvalue"
-#define DUK_STR_INVALID_NEWTARGET                "invalid new.target"
-#define DUK_STR_EXPECTED_IDENTIFIER              "expected identifier"
-#define DUK_STR_EMPTY_EXPR_NOT_ALLOWED           "empty expression not allowed"
-#define DUK_STR_INVALID_FOR                      "invalid for statement"
-#define DUK_STR_INVALID_SWITCH                   "invalid switch statement"
-#define DUK_STR_INVALID_BREAK_CONT_LABEL         "invalid break/continue label"
-#define DUK_STR_INVALID_RETURN                   "invalid return"
-#define DUK_STR_INVALID_TRY                      "invalid try"
-#define DUK_STR_INVALID_THROW                    "invalid throw"
-#define DUK_STR_WITH_IN_STRICT_MODE              "with in strict mode"
-#define DUK_STR_FUNC_STMT_NOT_ALLOWED            "function statement not allowed"
-#define DUK_STR_UNTERMINATED_STMT                "unterminated statement"
-#define DUK_STR_INVALID_ARG_NAME                 "invalid argument name"
-#define DUK_STR_INVALID_FUNC_NAME                "invalid function name"
-#define DUK_STR_INVALID_GETSET_NAME              "invalid getter/setter name"
-#define DUK_STR_FUNC_NAME_REQUIRED               "function name required"
+#define DUK_STR_PARSE_ERROR              "parse error"
+#define DUK_STR_DUPLICATE_LABEL          "duplicate label"
+#define DUK_STR_INVALID_LABEL            "invalid label"
+#define DUK_STR_INVALID_ARRAY_LITERAL    "invalid array literal"
+#define DUK_STR_INVALID_OBJECT_LITERAL   "invalid object literal"
+#define DUK_STR_INVALID_VAR_DECLARATION  "invalid variable declaration"
+#define DUK_STR_CANNOT_DELETE_IDENTIFIER "cannot delete identifier"
+#define DUK_STR_INVALID_EXPRESSION       "invalid expression"
+#define DUK_STR_INVALID_LVALUE           "invalid lvalue"
+#define DUK_STR_INVALID_NEWTARGET        "invalid new.target"
+#define DUK_STR_EXPECTED_IDENTIFIER      "expected identifier"
+#define DUK_STR_EMPTY_EXPR_NOT_ALLOWED   "empty expression not allowed"
+#define DUK_STR_INVALID_FOR              "invalid for statement"
+#define DUK_STR_INVALID_SWITCH           "invalid switch statement"
+#define DUK_STR_INVALID_BREAK_CONT_LABEL "invalid break/continue label"
+#define DUK_STR_INVALID_RETURN           "invalid return"
+#define DUK_STR_INVALID_TRY              "invalid try"
+#define DUK_STR_INVALID_THROW            "invalid throw"
+#define DUK_STR_WITH_IN_STRICT_MODE      "with in strict mode"
+#define DUK_STR_FUNC_STMT_NOT_ALLOWED    "function statement not allowed"
+#define DUK_STR_UNTERMINATED_STMT        "unterminated statement"
+#define DUK_STR_INVALID_ARG_NAME         "invalid argument name"
+#define DUK_STR_INVALID_FUNC_NAME        "invalid function name"
+#define DUK_STR_INVALID_GETSET_NAME      "invalid getter/setter name"
+#define DUK_STR_FUNC_NAME_REQUIRED       "function name required"
 
 /* RegExp */
-#define DUK_STR_INVALID_QUANTIFIER               "invalid regexp quantifier"
-#define DUK_STR_INVALID_QUANTIFIER_NO_ATOM       "quantifier without preceding atom"
-#define DUK_STR_INVALID_QUANTIFIER_VALUES        "quantifier values invalid (qmin > qmax)"
-#define DUK_STR_QUANTIFIER_TOO_MANY_COPIES       "quantifier requires too many atom copies"
-#define DUK_STR_UNEXPECTED_CLOSING_PAREN         "unexpected closing parenthesis"
-#define DUK_STR_UNEXPECTED_END_OF_PATTERN        "unexpected end of pattern"
-#define DUK_STR_UNEXPECTED_REGEXP_TOKEN          "unexpected token in regexp"
-#define DUK_STR_INVALID_REGEXP_FLAGS             "invalid regexp flags"
-#define DUK_STR_INVALID_REGEXP_ESCAPE            "invalid regexp escape"
-#define DUK_STR_INVALID_BACKREFS                 "invalid backreference(s)"
-#define DUK_STR_INVALID_REGEXP_CHARACTER         "invalid regexp character"
-#define DUK_STR_INVALID_REGEXP_GROUP             "invalid regexp group"
-#define DUK_STR_UNTERMINATED_CHARCLASS           "unterminated character class"
-#define DUK_STR_INVALID_RANGE                    "invalid range"
+#define DUK_STR_INVALID_QUANTIFIER         "invalid regexp quantifier"
+#define DUK_STR_INVALID_QUANTIFIER_NO_ATOM "quantifier without preceding atom"
+#define DUK_STR_INVALID_QUANTIFIER_VALUES  "quantifier values invalid (qmin > qmax)"
+#define DUK_STR_QUANTIFIER_TOO_MANY_COPIES "quantifier requires too many atom copies"
+#define DUK_STR_UNEXPECTED_CLOSING_PAREN   "unexpected closing parenthesis"
+#define DUK_STR_UNEXPECTED_END_OF_PATTERN  "unexpected end of pattern"
+#define DUK_STR_UNEXPECTED_REGEXP_TOKEN    "unexpected token in regexp"
+#define DUK_STR_INVALID_REGEXP_FLAGS       "invalid regexp flags"
+#define DUK_STR_INVALID_REGEXP_ESCAPE      "invalid regexp escape"
+#define DUK_STR_INVALID_BACKREFS           "invalid backreference(s)"
+#define DUK_STR_INVALID_REGEXP_CHARACTER   "invalid regexp character"
+#define DUK_STR_INVALID_REGEXP_GROUP       "invalid regexp group"
+#define DUK_STR_UNTERMINATED_CHARCLASS     "unterminated character class"
+#define DUK_STR_INVALID_RANGE              "invalid range"
 
 /* Limits */
-#define DUK_STR_VALSTACK_LIMIT                   "valstack limit"
-#define DUK_STR_CALLSTACK_LIMIT                  "callstack limit"
-#define DUK_STR_PROTOTYPE_CHAIN_LIMIT            "prototype chain limit"
-#define DUK_STR_BOUND_CHAIN_LIMIT                "function call bound chain limit"
-#define DUK_STR_NATIVE_STACK_LIMIT               "C stack depth limit"
-#define DUK_STR_COMPILER_RECURSION_LIMIT         "compiler recursion limit"
-#define DUK_STR_BYTECODE_LIMIT                   "bytecode limit"
-#define DUK_STR_REG_LIMIT                        "register limit"
-#define DUK_STR_TEMP_LIMIT                       "temp limit"
-#define DUK_STR_CONST_LIMIT                      "const limit"
-#define DUK_STR_FUNC_LIMIT                       "function limit"
-#define DUK_STR_REGEXP_COMPILER_RECURSION_LIMIT  "regexp compiler recursion limit"
-#define DUK_STR_REGEXP_EXECUTOR_RECURSION_LIMIT  "regexp executor recursion limit"
-#define DUK_STR_REGEXP_EXECUTOR_STEP_LIMIT       "regexp step limit"
+#define DUK_STR_VALSTACK_LIMIT                  "valstack limit"
+#define DUK_STR_CALLSTACK_LIMIT                 "callstack limit"
+#define DUK_STR_PROTOTYPE_CHAIN_LIMIT           "prototype chain limit"
+#define DUK_STR_BOUND_CHAIN_LIMIT               "function call bound chain limit"
+#define DUK_STR_NATIVE_STACK_LIMIT              "C stack depth limit"
+#define DUK_STR_COMPILER_RECURSION_LIMIT        "compiler recursion limit"
+#define DUK_STR_BYTECODE_LIMIT                  "bytecode limit"
+#define DUK_STR_REG_LIMIT                       "register limit"
+#define DUK_STR_TEMP_LIMIT                      "temp limit"
+#define DUK_STR_CONST_LIMIT                     "const limit"
+#define DUK_STR_FUNC_LIMIT                      "function limit"
+#define DUK_STR_REGEXP_COMPILER_RECURSION_LIMIT "regexp compiler recursion limit"
+#define DUK_STR_REGEXP_EXECUTOR_RECURSION_LIMIT "regexp executor recursion limit"
+#define DUK_STR_REGEXP_EXECUTOR_STEP_LIMIT      "regexp step limit"
 
-#endif  /* DUK_ERRMSG_H_INCLUDED */
+#endif /* DUK_ERRMSG_H_INCLUDED */
 /* #include duk_js_bytecode.h */
 #line 1 "duk_js_bytecode.h"
 /*
  *  ECMAScript bytecode
  */
 
 #if !defined(DUK_JS_BYTECODE_H_INCLUDED)
@@ -3314,411 +3418,402 @@
  *
  *  Macro naming is a bit misleading, e.g. "ABC" in macro name but the
  *  field layout is concretely "CBA" in the register.
  */
 
 typedef duk_uint32_t duk_instr_t;
 
-#define DUK_BC_SHIFT_OP             0
-#define DUK_BC_SHIFT_A              8
-#define DUK_BC_SHIFT_B              16
-#define DUK_BC_SHIFT_C              24
-#define DUK_BC_SHIFT_BC             DUK_BC_SHIFT_B
-#define DUK_BC_SHIFT_ABC            DUK_BC_SHIFT_A
-
-#define DUK_BC_UNSHIFTED_MASK_OP    0xffUL
-#define DUK_BC_UNSHIFTED_MASK_A     0xffUL
-#define DUK_BC_UNSHIFTED_MASK_B     0xffUL
-#define DUK_BC_UNSHIFTED_MASK_C     0xffUL
-#define DUK_BC_UNSHIFTED_MASK_BC    0xffffUL
-#define DUK_BC_UNSHIFTED_MASK_ABC   0xffffffUL
-
-#define DUK_BC_SHIFTED_MASK_OP      (DUK_BC_UNSHIFTED_MASK_OP << DUK_BC_SHIFT_OP)
-#define DUK_BC_SHIFTED_MASK_A       (DUK_BC_UNSHIFTED_MASK_A << DUK_BC_SHIFT_A)
-#define DUK_BC_SHIFTED_MASK_B       (DUK_BC_UNSHIFTED_MASK_B << DUK_BC_SHIFT_B)
-#define DUK_BC_SHIFTED_MASK_C       (DUK_BC_UNSHIFTED_MASK_C << DUK_BC_SHIFT_C)
-#define DUK_BC_SHIFTED_MASK_BC      (DUK_BC_UNSHIFTED_MASK_BC << DUK_BC_SHIFT_BC)
-#define DUK_BC_SHIFTED_MASK_ABC     (DUK_BC_UNSHIFTED_MASK_ABC << DUK_BC_SHIFT_ABC)
-
-#define DUK_DEC_OP(x)               ((x) & 0xffUL)
-#define DUK_DEC_A(x)                (((x) >> 8) & 0xffUL)
-#define DUK_DEC_B(x)                (((x) >> 16) & 0xffUL)
-#define DUK_DEC_C(x)                (((x) >> 24) & 0xffUL)
-#define DUK_DEC_BC(x)               (((x) >> 16) & 0xffffUL)
-#define DUK_DEC_ABC(x)              (((x) >> 8) & 0xffffffUL)
-
-#define DUK_ENC_OP(op)              ((duk_instr_t) (op))
-#define DUK_ENC_OP_ABC(op,abc)      ((duk_instr_t) ( \
-                                        (((duk_instr_t) (abc)) << 8) | \
-                                        ((duk_instr_t) (op)) \
-                                    ))
-#define DUK_ENC_OP_A_BC(op,a,bc)    ((duk_instr_t) ( \
-                                        (((duk_instr_t) (bc)) << 16) | \
-                                        (((duk_instr_t) (a)) << 8) | \
-                                        ((duk_instr_t) (op)) \
-                                    ))
-#define DUK_ENC_OP_A_B_C(op,a,b,c)  ((duk_instr_t) ( \
-                                        (((duk_instr_t) (c)) << 24) | \
-                                        (((duk_instr_t) (b)) << 16) | \
-                                        (((duk_instr_t) (a)) << 8) | \
-                                        ((duk_instr_t) (op)) \
-                                    ))
-#define DUK_ENC_OP_A_B(op,a,b)      DUK_ENC_OP_A_B_C((op),(a),(b),0)
-#define DUK_ENC_OP_A(op,a)          DUK_ENC_OP_A_B_C((op),(a),0,0)
-#define DUK_ENC_OP_BC(op,bc)        DUK_ENC_OP_A_BC((op),0,(bc))
+#define DUK_BC_SHIFT_OP  0
+#define DUK_BC_SHIFT_A   8
+#define DUK_BC_SHIFT_B   16
+#define DUK_BC_SHIFT_C   24
+#define DUK_BC_SHIFT_BC  DUK_BC_SHIFT_B
+#define DUK_BC_SHIFT_ABC DUK_BC_SHIFT_A
+
+#define DUK_BC_UNSHIFTED_MASK_OP  0xffUL
+#define DUK_BC_UNSHIFTED_MASK_A   0xffUL
+#define DUK_BC_UNSHIFTED_MASK_B   0xffUL
+#define DUK_BC_UNSHIFTED_MASK_C   0xffUL
+#define DUK_BC_UNSHIFTED_MASK_BC  0xffffUL
+#define DUK_BC_UNSHIFTED_MASK_ABC 0xffffffUL
+
+#define DUK_BC_SHIFTED_MASK_OP  (DUK_BC_UNSHIFTED_MASK_OP << DUK_BC_SHIFT_OP)
+#define DUK_BC_SHIFTED_MASK_A   (DUK_BC_UNSHIFTED_MASK_A << DUK_BC_SHIFT_A)
+#define DUK_BC_SHIFTED_MASK_B   (DUK_BC_UNSHIFTED_MASK_B << DUK_BC_SHIFT_B)
+#define DUK_BC_SHIFTED_MASK_C   (DUK_BC_UNSHIFTED_MASK_C << DUK_BC_SHIFT_C)
+#define DUK_BC_SHIFTED_MASK_BC  (DUK_BC_UNSHIFTED_MASK_BC << DUK_BC_SHIFT_BC)
+#define DUK_BC_SHIFTED_MASK_ABC (DUK_BC_UNSHIFTED_MASK_ABC << DUK_BC_SHIFT_ABC)
+
+#define DUK_DEC_OP(x)  ((x) &0xffUL)
+#define DUK_DEC_A(x)   (((x) >> 8) & 0xffUL)
+#define DUK_DEC_B(x)   (((x) >> 16) & 0xffUL)
+#define DUK_DEC_C(x)   (((x) >> 24) & 0xffUL)
+#define DUK_DEC_BC(x)  (((x) >> 16) & 0xffffUL)
+#define DUK_DEC_ABC(x) (((x) >> 8) & 0xffffffUL)
+
+#define DUK_ENC_OP(op)          ((duk_instr_t) (op))
+#define DUK_ENC_OP_ABC(op, abc) ((duk_instr_t) ((((duk_instr_t) (abc)) << 8) | ((duk_instr_t) (op))))
+#define DUK_ENC_OP_A_BC(op, a, bc) \
+	((duk_instr_t) ((((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (op))))
+#define DUK_ENC_OP_A_B_C(op, a, b, c) \
+	((duk_instr_t) ((((duk_instr_t) (c)) << 24) | (((duk_instr_t) (b)) << 16) | (((duk_instr_t) (a)) << 8) | \
+	                ((duk_instr_t) (op))))
+#define DUK_ENC_OP_A_B(op, a, b) DUK_ENC_OP_A_B_C((op), (a), (b), 0)
+#define DUK_ENC_OP_A(op, a)      DUK_ENC_OP_A_B_C((op), (a), 0, 0)
+#define DUK_ENC_OP_BC(op, bc)    DUK_ENC_OP_A_BC((op), 0, (bc))
 
 /* Get opcode base value with B/C reg/const flags cleared. */
-#define DUK_BC_NOREGCONST_OP(op)    ((op) & 0xfc)
+#define DUK_BC_NOREGCONST_OP(op) ((op) &0xfc)
 
 /* Constants should be signed so that signed arithmetic involving them
  * won't cause values to be coerced accidentally to unsigned.
  */
-#define DUK_BC_OP_MIN               0
-#define DUK_BC_OP_MAX               0xffL
-#define DUK_BC_A_MIN                0
-#define DUK_BC_A_MAX                0xffL
-#define DUK_BC_B_MIN                0
-#define DUK_BC_B_MAX                0xffL
-#define DUK_BC_C_MIN                0
-#define DUK_BC_C_MAX                0xffL
-#define DUK_BC_BC_MIN               0
-#define DUK_BC_BC_MAX               0xffffL
-#define DUK_BC_ABC_MIN              0
-#define DUK_BC_ABC_MAX              0xffffffL
+#define DUK_BC_OP_MIN  0
+#define DUK_BC_OP_MAX  0xffL
+#define DUK_BC_A_MIN   0
+#define DUK_BC_A_MAX   0xffL
+#define DUK_BC_B_MIN   0
+#define DUK_BC_B_MAX   0xffL
+#define DUK_BC_C_MIN   0
+#define DUK_BC_C_MAX   0xffL
+#define DUK_BC_BC_MIN  0
+#define DUK_BC_BC_MAX  0xffffL
+#define DUK_BC_ABC_MIN 0
+#define DUK_BC_ABC_MAX 0xffffffL
 
 /* Masks for B/C reg/const indicator in opcode field. */
-#define DUK_BC_REGCONST_B           (0x01UL)
-#define DUK_BC_REGCONST_C           (0x02UL)
+#define DUK_BC_REGCONST_B (0x01UL)
+#define DUK_BC_REGCONST_C (0x02UL)
 
 /* Misc. masks for opcode field. */
-#define DUK_BC_INCDECP_FLAG_DEC     (0x04UL)
-#define DUK_BC_INCDECP_FLAG_POST    (0x08UL)
+#define DUK_BC_INCDECP_FLAG_DEC  (0x04UL)
+#define DUK_BC_INCDECP_FLAG_POST (0x08UL)
 
 /* Opcodes. */
-#define DUK_OP_LDREG                0
-#define DUK_OP_STREG                1
-#define DUK_OP_JUMP                 2
-#define DUK_OP_LDCONST              3
-#define DUK_OP_LDINT                4
-#define DUK_OP_LDINTX               5
-#define DUK_OP_LDTHIS               6
-#define DUK_OP_LDUNDEF              7
-#define DUK_OP_LDNULL               8
-#define DUK_OP_LDTRUE               9
-#define DUK_OP_LDFALSE              10
-#define DUK_OP_GETVAR               11
-#define DUK_OP_BNOT                 12
-#define DUK_OP_LNOT                 13
-#define DUK_OP_UNM                  14
-#define DUK_OP_UNP                  15
-#define DUK_OP_EQ                   16
-#define DUK_OP_EQ_RR                16
-#define DUK_OP_EQ_CR                17
-#define DUK_OP_EQ_RC                18
-#define DUK_OP_EQ_CC                19
-#define DUK_OP_NEQ                  20
-#define DUK_OP_NEQ_RR               20
-#define DUK_OP_NEQ_CR               21
-#define DUK_OP_NEQ_RC               22
-#define DUK_OP_NEQ_CC               23
-#define DUK_OP_SEQ                  24
-#define DUK_OP_SEQ_RR               24
-#define DUK_OP_SEQ_CR               25
-#define DUK_OP_SEQ_RC               26
-#define DUK_OP_SEQ_CC               27
-#define DUK_OP_SNEQ                 28
-#define DUK_OP_SNEQ_RR              28
-#define DUK_OP_SNEQ_CR              29
-#define DUK_OP_SNEQ_RC              30
-#define DUK_OP_SNEQ_CC              31
-#define DUK_OP_GT                   32
-#define DUK_OP_GT_RR                32
-#define DUK_OP_GT_CR                33
-#define DUK_OP_GT_RC                34
-#define DUK_OP_GT_CC                35
-#define DUK_OP_GE                   36
-#define DUK_OP_GE_RR                36
-#define DUK_OP_GE_CR                37
-#define DUK_OP_GE_RC                38
-#define DUK_OP_GE_CC                39
-#define DUK_OP_LT                   40
-#define DUK_OP_LT_RR                40
-#define DUK_OP_LT_CR                41
-#define DUK_OP_LT_RC                42
-#define DUK_OP_LT_CC                43
-#define DUK_OP_LE                   44
-#define DUK_OP_LE_RR                44
-#define DUK_OP_LE_CR                45
-#define DUK_OP_LE_RC                46
-#define DUK_OP_LE_CC                47
-#define DUK_OP_IFTRUE               48
-#define DUK_OP_IFTRUE_R             48
-#define DUK_OP_IFTRUE_C             49
-#define DUK_OP_IFFALSE              50
-#define DUK_OP_IFFALSE_R            50
-#define DUK_OP_IFFALSE_C            51
-#define DUK_OP_ADD                  52
-#define DUK_OP_ADD_RR               52
-#define DUK_OP_ADD_CR               53
-#define DUK_OP_ADD_RC               54
-#define DUK_OP_ADD_CC               55
-#define DUK_OP_SUB                  56
-#define DUK_OP_SUB_RR               56
-#define DUK_OP_SUB_CR               57
-#define DUK_OP_SUB_RC               58
-#define DUK_OP_SUB_CC               59
-#define DUK_OP_MUL                  60
-#define DUK_OP_MUL_RR               60
-#define DUK_OP_MUL_CR               61
-#define DUK_OP_MUL_RC               62
-#define DUK_OP_MUL_CC               63
-#define DUK_OP_DIV                  64
-#define DUK_OP_DIV_RR               64
-#define DUK_OP_DIV_CR               65
-#define DUK_OP_DIV_RC               66
-#define DUK_OP_DIV_CC               67
-#define DUK_OP_MOD                  68
-#define DUK_OP_MOD_RR               68
-#define DUK_OP_MOD_CR               69
-#define DUK_OP_MOD_RC               70
-#define DUK_OP_MOD_CC               71
-#define DUK_OP_EXP                  72
-#define DUK_OP_EXP_RR               72
-#define DUK_OP_EXP_CR               73
-#define DUK_OP_EXP_RC               74
-#define DUK_OP_EXP_CC               75
-#define DUK_OP_BAND                 76
-#define DUK_OP_BAND_RR              76
-#define DUK_OP_BAND_CR              77
-#define DUK_OP_BAND_RC              78
-#define DUK_OP_BAND_CC              79
-#define DUK_OP_BOR                  80
-#define DUK_OP_BOR_RR               80
-#define DUK_OP_BOR_CR               81
-#define DUK_OP_BOR_RC               82
-#define DUK_OP_BOR_CC               83
-#define DUK_OP_BXOR                 84
-#define DUK_OP_BXOR_RR              84
-#define DUK_OP_BXOR_CR              85
-#define DUK_OP_BXOR_RC              86
-#define DUK_OP_BXOR_CC              87
-#define DUK_OP_BASL                 88
-#define DUK_OP_BASL_RR              88
-#define DUK_OP_BASL_CR              89
-#define DUK_OP_BASL_RC              90
-#define DUK_OP_BASL_CC              91
-#define DUK_OP_BLSR                 92
-#define DUK_OP_BLSR_RR              92
-#define DUK_OP_BLSR_CR              93
-#define DUK_OP_BLSR_RC              94
-#define DUK_OP_BLSR_CC              95
-#define DUK_OP_BASR                 96
-#define DUK_OP_BASR_RR              96
-#define DUK_OP_BASR_CR              97
-#define DUK_OP_BASR_RC              98
-#define DUK_OP_BASR_CC              99
-#define DUK_OP_INSTOF               100
-#define DUK_OP_INSTOF_RR            100
-#define DUK_OP_INSTOF_CR            101
-#define DUK_OP_INSTOF_RC            102
-#define DUK_OP_INSTOF_CC            103
-#define DUK_OP_IN                   104
-#define DUK_OP_IN_RR                104
-#define DUK_OP_IN_CR                105
-#define DUK_OP_IN_RC                106
-#define DUK_OP_IN_CC                107
-#define DUK_OP_GETPROP              108
-#define DUK_OP_GETPROP_RR           108
-#define DUK_OP_GETPROP_CR           109
-#define DUK_OP_GETPROP_RC           110
-#define DUK_OP_GETPROP_CC           111
-#define DUK_OP_PUTPROP              112
-#define DUK_OP_PUTPROP_RR           112
-#define DUK_OP_PUTPROP_CR           113
-#define DUK_OP_PUTPROP_RC           114
-#define DUK_OP_PUTPROP_CC           115
-#define DUK_OP_DELPROP              116
-#define DUK_OP_DELPROP_RR           116
-#define DUK_OP_DELPROP_CR_UNUSED    117  /* unused now */
-#define DUK_OP_DELPROP_RC           118
-#define DUK_OP_DELPROP_CC_UNUSED    119  /* unused now */
-#define DUK_OP_PREINCR              120  /* pre/post opcode values have constraints, */
-#define DUK_OP_PREDECR              121  /* see duk_js_executor.c and duk_js_compiler.c. */
-#define DUK_OP_POSTINCR             122
-#define DUK_OP_POSTDECR             123
-#define DUK_OP_PREINCV              124
-#define DUK_OP_PREDECV              125
-#define DUK_OP_POSTINCV             126
-#define DUK_OP_POSTDECV             127
-#define DUK_OP_PREINCP              128  /* pre/post inc/dec prop opcodes have constraints */
-#define DUK_OP_PREINCP_RR           128
-#define DUK_OP_PREINCP_CR           129
-#define DUK_OP_PREINCP_RC           130
-#define DUK_OP_PREINCP_CC           131
-#define DUK_OP_PREDECP              132
-#define DUK_OP_PREDECP_RR           132
-#define DUK_OP_PREDECP_CR           133
-#define DUK_OP_PREDECP_RC           134
-#define DUK_OP_PREDECP_CC           135
-#define DUK_OP_POSTINCP             136
-#define DUK_OP_POSTINCP_RR          136
-#define DUK_OP_POSTINCP_CR          137
-#define DUK_OP_POSTINCP_RC          138
-#define DUK_OP_POSTINCP_CC          139
-#define DUK_OP_POSTDECP             140
-#define DUK_OP_POSTDECP_RR          140
-#define DUK_OP_POSTDECP_CR          141
-#define DUK_OP_POSTDECP_RC          142
-#define DUK_OP_POSTDECP_CC          143
-#define DUK_OP_DECLVAR              144
-#define DUK_OP_DECLVAR_RR           144
-#define DUK_OP_DECLVAR_CR           145
-#define DUK_OP_DECLVAR_RC           146
-#define DUK_OP_DECLVAR_CC           147
-#define DUK_OP_REGEXP               148
-#define DUK_OP_REGEXP_RR            148
-#define DUK_OP_REGEXP_CR            149
-#define DUK_OP_REGEXP_RC            150
-#define DUK_OP_REGEXP_CC            151
-#define DUK_OP_CLOSURE              152
-#define DUK_OP_TYPEOF               153
-#define DUK_OP_TYPEOFID             154
-#define DUK_OP_PUTVAR               155
-#define DUK_OP_DELVAR               156
-#define DUK_OP_RETREG               157
-#define DUK_OP_RETUNDEF             158
-#define DUK_OP_RETCONST             159
-#define DUK_OP_RETCONSTN            160  /* return const without incref (e.g. number) */
-#define DUK_OP_LABEL                161
-#define DUK_OP_ENDLABEL             162
-#define DUK_OP_BREAK                163
-#define DUK_OP_CONTINUE             164
-#define DUK_OP_TRYCATCH             165
-#define DUK_OP_ENDTRY               166
-#define DUK_OP_ENDCATCH             167
-#define DUK_OP_ENDFIN               168
-#define DUK_OP_THROW                169
-#define DUK_OP_INVLHS               170
-#define DUK_OP_CSREG                171
-#define DUK_OP_CSVAR                172
-#define DUK_OP_CSVAR_RR             172
-#define DUK_OP_CSVAR_CR             173
-#define DUK_OP_CSVAR_RC             174
-#define DUK_OP_CSVAR_CC             175
-#define DUK_OP_CALL0                176  /* DUK_OP_CALL0 & 0x0F must be zero. */
-#define DUK_OP_CALL1                177
-#define DUK_OP_CALL2                178
-#define DUK_OP_CALL3                179
-#define DUK_OP_CALL4                180
-#define DUK_OP_CALL5                181
-#define DUK_OP_CALL6                182
-#define DUK_OP_CALL7                183
-#define DUK_OP_CALL8                184
-#define DUK_OP_CALL9                185
-#define DUK_OP_CALL10               186
-#define DUK_OP_CALL11               187
-#define DUK_OP_CALL12               188
-#define DUK_OP_CALL13               189
-#define DUK_OP_CALL14               190
-#define DUK_OP_CALL15               191
-#define DUK_OP_NEWOBJ               192
-#define DUK_OP_NEWARR               193
-#define DUK_OP_MPUTOBJ              194
-#define DUK_OP_MPUTOBJI             195
-#define DUK_OP_INITSET              196
-#define DUK_OP_INITGET              197
-#define DUK_OP_MPUTARR              198
-#define DUK_OP_MPUTARRI             199
-#define DUK_OP_SETALEN              200
-#define DUK_OP_INITENUM             201
-#define DUK_OP_NEXTENUM             202
-#define DUK_OP_NEWTARGET            203
-#define DUK_OP_DEBUGGER             204
-#define DUK_OP_NOP                  205
-#define DUK_OP_INVALID              206
-#define DUK_OP_UNUSED207            207
-#define DUK_OP_GETPROPC             208
-#define DUK_OP_GETPROPC_RR          208
-#define DUK_OP_GETPROPC_CR          209
-#define DUK_OP_GETPROPC_RC          210
-#define DUK_OP_GETPROPC_CC          211
-#define DUK_OP_UNUSED212            212
-#define DUK_OP_UNUSED213            213
-#define DUK_OP_UNUSED214            214
-#define DUK_OP_UNUSED215            215
-#define DUK_OP_UNUSED216            216
-#define DUK_OP_UNUSED217            217
-#define DUK_OP_UNUSED218            218
-#define DUK_OP_UNUSED219            219
-#define DUK_OP_UNUSED220            220
-#define DUK_OP_UNUSED221            221
-#define DUK_OP_UNUSED222            222
-#define DUK_OP_UNUSED223            223
-#define DUK_OP_UNUSED224            224
-#define DUK_OP_UNUSED225            225
-#define DUK_OP_UNUSED226            226
-#define DUK_OP_UNUSED227            227
-#define DUK_OP_UNUSED228            228
-#define DUK_OP_UNUSED229            229
-#define DUK_OP_UNUSED230            230
-#define DUK_OP_UNUSED231            231
-#define DUK_OP_UNUSED232            232
-#define DUK_OP_UNUSED233            233
-#define DUK_OP_UNUSED234            234
-#define DUK_OP_UNUSED235            235
-#define DUK_OP_UNUSED236            236
-#define DUK_OP_UNUSED237            237
-#define DUK_OP_UNUSED238            238
-#define DUK_OP_UNUSED239            239
-#define DUK_OP_UNUSED240            240
-#define DUK_OP_UNUSED241            241
-#define DUK_OP_UNUSED242            242
-#define DUK_OP_UNUSED243            243
-#define DUK_OP_UNUSED244            244
-#define DUK_OP_UNUSED245            245
-#define DUK_OP_UNUSED246            246
-#define DUK_OP_UNUSED247            247
-#define DUK_OP_UNUSED248            248
-#define DUK_OP_UNUSED249            249
-#define DUK_OP_UNUSED250            250
-#define DUK_OP_UNUSED251            251
-#define DUK_OP_UNUSED252            252
-#define DUK_OP_UNUSED253            253
-#define DUK_OP_UNUSED254            254
-#define DUK_OP_UNUSED255            255
-#define DUK_OP_NONE                 256  /* dummy value used as marker (doesn't fit in 8-bit field) */
+#define DUK_OP_LDREG             0
+#define DUK_OP_STREG             1
+#define DUK_OP_JUMP              2
+#define DUK_OP_LDCONST           3
+#define DUK_OP_LDINT             4
+#define DUK_OP_LDINTX            5
+#define DUK_OP_LDTHIS            6
+#define DUK_OP_LDUNDEF           7
+#define DUK_OP_LDNULL            8
+#define DUK_OP_LDTRUE            9
+#define DUK_OP_LDFALSE           10
+#define DUK_OP_GETVAR            11
+#define DUK_OP_BNOT              12
+#define DUK_OP_LNOT              13
+#define DUK_OP_UNM               14
+#define DUK_OP_UNP               15
+#define DUK_OP_EQ                16
+#define DUK_OP_EQ_RR             16
+#define DUK_OP_EQ_CR             17
+#define DUK_OP_EQ_RC             18
+#define DUK_OP_EQ_CC             19
+#define DUK_OP_NEQ               20
+#define DUK_OP_NEQ_RR            20
+#define DUK_OP_NEQ_CR            21
+#define DUK_OP_NEQ_RC            22
+#define DUK_OP_NEQ_CC            23
+#define DUK_OP_SEQ               24
+#define DUK_OP_SEQ_RR            24
+#define DUK_OP_SEQ_CR            25
+#define DUK_OP_SEQ_RC            26
+#define DUK_OP_SEQ_CC            27
+#define DUK_OP_SNEQ              28
+#define DUK_OP_SNEQ_RR           28
+#define DUK_OP_SNEQ_CR           29
+#define DUK_OP_SNEQ_RC           30
+#define DUK_OP_SNEQ_CC           31
+#define DUK_OP_GT                32
+#define DUK_OP_GT_RR             32
+#define DUK_OP_GT_CR             33
+#define DUK_OP_GT_RC             34
+#define DUK_OP_GT_CC             35
+#define DUK_OP_GE                36
+#define DUK_OP_GE_RR             36
+#define DUK_OP_GE_CR             37
+#define DUK_OP_GE_RC             38
+#define DUK_OP_GE_CC             39
+#define DUK_OP_LT                40
+#define DUK_OP_LT_RR             40
+#define DUK_OP_LT_CR             41
+#define DUK_OP_LT_RC             42
+#define DUK_OP_LT_CC             43
+#define DUK_OP_LE                44
+#define DUK_OP_LE_RR             44
+#define DUK_OP_LE_CR             45
+#define DUK_OP_LE_RC             46
+#define DUK_OP_LE_CC             47
+#define DUK_OP_IFTRUE            48
+#define DUK_OP_IFTRUE_R          48
+#define DUK_OP_IFTRUE_C          49
+#define DUK_OP_IFFALSE           50
+#define DUK_OP_IFFALSE_R         50
+#define DUK_OP_IFFALSE_C         51
+#define DUK_OP_ADD               52
+#define DUK_OP_ADD_RR            52
+#define DUK_OP_ADD_CR            53
+#define DUK_OP_ADD_RC            54
+#define DUK_OP_ADD_CC            55
+#define DUK_OP_SUB               56
+#define DUK_OP_SUB_RR            56
+#define DUK_OP_SUB_CR            57
+#define DUK_OP_SUB_RC            58
+#define DUK_OP_SUB_CC            59
+#define DUK_OP_MUL               60
+#define DUK_OP_MUL_RR            60
+#define DUK_OP_MUL_CR            61
+#define DUK_OP_MUL_RC            62
+#define DUK_OP_MUL_CC            63
+#define DUK_OP_DIV               64
+#define DUK_OP_DIV_RR            64
+#define DUK_OP_DIV_CR            65
+#define DUK_OP_DIV_RC            66
+#define DUK_OP_DIV_CC            67
+#define DUK_OP_MOD               68
+#define DUK_OP_MOD_RR            68
+#define DUK_OP_MOD_CR            69
+#define DUK_OP_MOD_RC            70
+#define DUK_OP_MOD_CC            71
+#define DUK_OP_EXP               72
+#define DUK_OP_EXP_RR            72
+#define DUK_OP_EXP_CR            73
+#define DUK_OP_EXP_RC            74
+#define DUK_OP_EXP_CC            75
+#define DUK_OP_BAND              76
+#define DUK_OP_BAND_RR           76
+#define DUK_OP_BAND_CR           77
+#define DUK_OP_BAND_RC           78
+#define DUK_OP_BAND_CC           79
+#define DUK_OP_BOR               80
+#define DUK_OP_BOR_RR            80
+#define DUK_OP_BOR_CR            81
+#define DUK_OP_BOR_RC            82
+#define DUK_OP_BOR_CC            83
+#define DUK_OP_BXOR              84
+#define DUK_OP_BXOR_RR           84
+#define DUK_OP_BXOR_CR           85
+#define DUK_OP_BXOR_RC           86
+#define DUK_OP_BXOR_CC           87
+#define DUK_OP_BASL              88
+#define DUK_OP_BASL_RR           88
+#define DUK_OP_BASL_CR           89
+#define DUK_OP_BASL_RC           90
+#define DUK_OP_BASL_CC           91
+#define DUK_OP_BLSR              92
+#define DUK_OP_BLSR_RR           92
+#define DUK_OP_BLSR_CR           93
+#define DUK_OP_BLSR_RC           94
+#define DUK_OP_BLSR_CC           95
+#define DUK_OP_BASR              96
+#define DUK_OP_BASR_RR           96
+#define DUK_OP_BASR_CR           97
+#define DUK_OP_BASR_RC           98
+#define DUK_OP_BASR_CC           99
+#define DUK_OP_INSTOF            100
+#define DUK_OP_INSTOF_RR         100
+#define DUK_OP_INSTOF_CR         101
+#define DUK_OP_INSTOF_RC         102
+#define DUK_OP_INSTOF_CC         103
+#define DUK_OP_IN                104
+#define DUK_OP_IN_RR             104
+#define DUK_OP_IN_CR             105
+#define DUK_OP_IN_RC             106
+#define DUK_OP_IN_CC             107
+#define DUK_OP_GETPROP           108
+#define DUK_OP_GETPROP_RR        108
+#define DUK_OP_GETPROP_CR        109
+#define DUK_OP_GETPROP_RC        110
+#define DUK_OP_GETPROP_CC        111
+#define DUK_OP_PUTPROP           112
+#define DUK_OP_PUTPROP_RR        112
+#define DUK_OP_PUTPROP_CR        113
+#define DUK_OP_PUTPROP_RC        114
+#define DUK_OP_PUTPROP_CC        115
+#define DUK_OP_DELPROP           116
+#define DUK_OP_DELPROP_RR        116
+#define DUK_OP_DELPROP_CR_UNUSED 117 /* unused now */
+#define DUK_OP_DELPROP_RC        118
+#define DUK_OP_DELPROP_CC_UNUSED 119 /* unused now */
+#define DUK_OP_PREINCR           120 /* pre/post opcode values have constraints, */
+#define DUK_OP_PREDECR           121 /* see duk_js_executor.c and duk_js_compiler.c. */
+#define DUK_OP_POSTINCR          122
+#define DUK_OP_POSTDECR          123
+#define DUK_OP_PREINCV           124
+#define DUK_OP_PREDECV           125
+#define DUK_OP_POSTINCV          126
+#define DUK_OP_POSTDECV          127
+#define DUK_OP_PREINCP           128 /* pre/post inc/dec prop opcodes have constraints */
+#define DUK_OP_PREINCP_RR        128
+#define DUK_OP_PREINCP_CR        129
+#define DUK_OP_PREINCP_RC        130
+#define DUK_OP_PREINCP_CC        131
+#define DUK_OP_PREDECP           132
+#define DUK_OP_PREDECP_RR        132
+#define DUK_OP_PREDECP_CR        133
+#define DUK_OP_PREDECP_RC        134
+#define DUK_OP_PREDECP_CC        135
+#define DUK_OP_POSTINCP          136
+#define DUK_OP_POSTINCP_RR       136
+#define DUK_OP_POSTINCP_CR       137
+#define DUK_OP_POSTINCP_RC       138
+#define DUK_OP_POSTINCP_CC       139
+#define DUK_OP_POSTDECP          140
+#define DUK_OP_POSTDECP_RR       140
+#define DUK_OP_POSTDECP_CR       141
+#define DUK_OP_POSTDECP_RC       142
+#define DUK_OP_POSTDECP_CC       143
+#define DUK_OP_DECLVAR           144
+#define DUK_OP_DECLVAR_RR        144
+#define DUK_OP_DECLVAR_CR        145
+#define DUK_OP_DECLVAR_RC        146
+#define DUK_OP_DECLVAR_CC        147
+#define DUK_OP_REGEXP            148
+#define DUK_OP_REGEXP_RR         148
+#define DUK_OP_REGEXP_CR         149
+#define DUK_OP_REGEXP_RC         150
+#define DUK_OP_REGEXP_CC         151
+#define DUK_OP_CLOSURE           152
+#define DUK_OP_TYPEOF            153
+#define DUK_OP_TYPEOFID          154
+#define DUK_OP_PUTVAR            155
+#define DUK_OP_DELVAR            156
+#define DUK_OP_RETREG            157
+#define DUK_OP_RETUNDEF          158
+#define DUK_OP_RETCONST          159
+#define DUK_OP_RETCONSTN         160 /* return const without incref (e.g. number) */
+#define DUK_OP_LABEL             161
+#define DUK_OP_ENDLABEL          162
+#define DUK_OP_BREAK             163
+#define DUK_OP_CONTINUE          164
+#define DUK_OP_TRYCATCH          165
+#define DUK_OP_ENDTRY            166
+#define DUK_OP_ENDCATCH          167
+#define DUK_OP_ENDFIN            168
+#define DUK_OP_THROW             169
+#define DUK_OP_INVLHS            170
+#define DUK_OP_CSREG             171
+#define DUK_OP_CSVAR             172
+#define DUK_OP_CSVAR_RR          172
+#define DUK_OP_CSVAR_CR          173
+#define DUK_OP_CSVAR_RC          174
+#define DUK_OP_CSVAR_CC          175
+#define DUK_OP_CALL0             176 /* DUK_OP_CALL0 & 0x0F must be zero. */
+#define DUK_OP_CALL1             177
+#define DUK_OP_CALL2             178
+#define DUK_OP_CALL3             179
+#define DUK_OP_CALL4             180
+#define DUK_OP_CALL5             181
+#define DUK_OP_CALL6             182
+#define DUK_OP_CALL7             183
+#define DUK_OP_CALL8             184
+#define DUK_OP_CALL9             185
+#define DUK_OP_CALL10            186
+#define DUK_OP_CALL11            187
+#define DUK_OP_CALL12            188
+#define DUK_OP_CALL13            189
+#define DUK_OP_CALL14            190
+#define DUK_OP_CALL15            191
+#define DUK_OP_NEWOBJ            192
+#define DUK_OP_NEWARR            193
+#define DUK_OP_MPUTOBJ           194
+#define DUK_OP_MPUTOBJI          195
+#define DUK_OP_INITSET           196
+#define DUK_OP_INITGET           197
+#define DUK_OP_MPUTARR           198
+#define DUK_OP_MPUTARRI          199
+#define DUK_OP_SETALEN           200
+#define DUK_OP_INITENUM          201
+#define DUK_OP_NEXTENUM          202
+#define DUK_OP_NEWTARGET         203
+#define DUK_OP_DEBUGGER          204
+#define DUK_OP_NOP               205
+#define DUK_OP_INVALID           206
+#define DUK_OP_UNUSED207         207
+#define DUK_OP_GETPROPC          208
+#define DUK_OP_GETPROPC_RR       208
+#define DUK_OP_GETPROPC_CR       209
+#define DUK_OP_GETPROPC_RC       210
+#define DUK_OP_GETPROPC_CC       211
+#define DUK_OP_UNUSED212         212
+#define DUK_OP_UNUSED213         213
+#define DUK_OP_UNUSED214         214
+#define DUK_OP_UNUSED215         215
+#define DUK_OP_UNUSED216         216
+#define DUK_OP_UNUSED217         217
+#define DUK_OP_UNUSED218         218
+#define DUK_OP_UNUSED219         219
+#define DUK_OP_UNUSED220         220
+#define DUK_OP_UNUSED221         221
+#define DUK_OP_UNUSED222         222
+#define DUK_OP_UNUSED223         223
+#define DUK_OP_UNUSED224         224
+#define DUK_OP_UNUSED225         225
+#define DUK_OP_UNUSED226         226
+#define DUK_OP_UNUSED227         227
+#define DUK_OP_UNUSED228         228
+#define DUK_OP_UNUSED229         229
+#define DUK_OP_UNUSED230         230
+#define DUK_OP_UNUSED231         231
+#define DUK_OP_UNUSED232         232
+#define DUK_OP_UNUSED233         233
+#define DUK_OP_UNUSED234         234
+#define DUK_OP_UNUSED235         235
+#define DUK_OP_UNUSED236         236
+#define DUK_OP_UNUSED237         237
+#define DUK_OP_UNUSED238         238
+#define DUK_OP_UNUSED239         239
+#define DUK_OP_UNUSED240         240
+#define DUK_OP_UNUSED241         241
+#define DUK_OP_UNUSED242         242
+#define DUK_OP_UNUSED243         243
+#define DUK_OP_UNUSED244         244
+#define DUK_OP_UNUSED245         245
+#define DUK_OP_UNUSED246         246
+#define DUK_OP_UNUSED247         247
+#define DUK_OP_UNUSED248         248
+#define DUK_OP_UNUSED249         249
+#define DUK_OP_UNUSED250         250
+#define DUK_OP_UNUSED251         251
+#define DUK_OP_UNUSED252         252
+#define DUK_OP_UNUSED253         253
+#define DUK_OP_UNUSED254         254
+#define DUK_OP_UNUSED255         255
+#define DUK_OP_NONE              256 /* dummy value used as marker (doesn't fit in 8-bit field) */
 
 /* XXX: Allocate flags from opcode field?  Would take 16 opcode slots
  * but avoids shuffling in more cases.  Maybe not worth it.
  */
 /* DUK_OP_TRYCATCH flags in A. */
-#define DUK_BC_TRYCATCH_FLAG_HAVE_CATCH     (1U << 0)
-#define DUK_BC_TRYCATCH_FLAG_HAVE_FINALLY   (1U << 1)
-#define DUK_BC_TRYCATCH_FLAG_CATCH_BINDING  (1U << 2)
-#define DUK_BC_TRYCATCH_FLAG_WITH_BINDING   (1U << 3)
+#define DUK_BC_TRYCATCH_FLAG_HAVE_CATCH    (1U << 0)
+#define DUK_BC_TRYCATCH_FLAG_HAVE_FINALLY  (1U << 1)
+#define DUK_BC_TRYCATCH_FLAG_CATCH_BINDING (1U << 2)
+#define DUK_BC_TRYCATCH_FLAG_WITH_BINDING  (1U << 3)
 
 /* DUK_OP_DECLVAR flags in A; bottom bits are reserved for propdesc flags
  * (DUK_PROPDESC_FLAG_XXX).
  */
-#define DUK_BC_DECLVAR_FLAG_FUNC_DECL       (1U << 4)  /* function declaration */
+#define DUK_BC_DECLVAR_FLAG_FUNC_DECL (1U << 4) /* function declaration */
 
 /* DUK_OP_CALLn flags, part of opcode field.  Three lowest bits must match
  * DUK_CALL_FLAG_xxx directly.
  */
-#define DUK_BC_CALL_FLAG_TAILCALL           (1U << 0)
-#define DUK_BC_CALL_FLAG_CONSTRUCT          (1U << 1)
-#define DUK_BC_CALL_FLAG_CALLED_AS_EVAL     (1U << 2)
-#define DUK_BC_CALL_FLAG_INDIRECT           (1U << 3)
+#define DUK_BC_CALL_FLAG_TAILCALL       (1U << 0)
+#define DUK_BC_CALL_FLAG_CONSTRUCT      (1U << 1)
+#define DUK_BC_CALL_FLAG_CALLED_AS_EVAL (1U << 2)
+#define DUK_BC_CALL_FLAG_INDIRECT       (1U << 3)
 
 /* Misc constants and helper macros. */
-#define DUK_BC_LDINT_BIAS           (1L << 15)
-#define DUK_BC_LDINTX_SHIFT         16
-#define DUK_BC_JUMP_BIAS            (1L << 23)
+#define DUK_BC_LDINT_BIAS   (1L << 15)
+#define DUK_BC_LDINTX_SHIFT 16
+#define DUK_BC_JUMP_BIAS    (1L << 23)
 
-#endif  /* DUK_JS_BYTECODE_H_INCLUDED */
+#endif /* DUK_JS_BYTECODE_H_INCLUDED */
 /* #include duk_lexer.h */
 #line 1 "duk_lexer.h"
 /*
  *  Lexer defines.
  */
 
 #if !defined(DUK_LEXER_H_INCLUDED)
@@ -3741,164 +3836,164 @@
  *  operator in "-1.0" is optimized during compilation to yield a single
  *  negative constant.
  *
  *  Token numbering is free except that reserved words are required to be
  *  in a continuous range and in a particular order.  See genstrings.py.
  */
 
-#define DUK_LEXER_INITCTX(ctx)        duk_lexer_initctx((ctx))
+#define DUK_LEXER_INITCTX(ctx) duk_lexer_initctx((ctx))
 
-#define DUK_LEXER_SETPOINT(ctx,pt)    duk_lexer_setpoint((ctx), (pt))
+#define DUK_LEXER_SETPOINT(ctx, pt) duk_lexer_setpoint((ctx), (pt))
 
-#define DUK_LEXER_GETPOINT(ctx,pt)    duk_lexer_getpoint((ctx), (pt))
+#define DUK_LEXER_GETPOINT(ctx, pt) duk_lexer_getpoint((ctx), (pt))
 
 /* Currently 6 characters of lookup are actually needed (duk_lexer.c). */
-#define DUK_LEXER_WINDOW_SIZE                     6
+#define DUK_LEXER_WINDOW_SIZE 6
 #if defined(DUK_USE_LEXER_SLIDING_WINDOW)
-#define DUK_LEXER_BUFFER_SIZE                     64
+#define DUK_LEXER_BUFFER_SIZE 64
 #endif
 
-#define DUK_TOK_MINVAL                            0
+#define DUK_TOK_MINVAL 0
 
 /* returned after EOF (infinite amount) */
-#define DUK_TOK_EOF                               0
+#define DUK_TOK_EOF 0
 
 /* identifier names (E5 Section 7.6) */
-#define DUK_TOK_IDENTIFIER                        1
+#define DUK_TOK_IDENTIFIER 1
 
 /* reserved words: keywords */
-#define DUK_TOK_START_RESERVED                    2
-#define DUK_TOK_BREAK                             2
-#define DUK_TOK_CASE                              3
-#define DUK_TOK_CATCH                             4
-#define DUK_TOK_CONTINUE                          5
-#define DUK_TOK_DEBUGGER                          6
-#define DUK_TOK_DEFAULT                           7
-#define DUK_TOK_DELETE                            8
-#define DUK_TOK_DO                                9
-#define DUK_TOK_ELSE                              10
-#define DUK_TOK_FINALLY                           11
-#define DUK_TOK_FOR                               12
-#define DUK_TOK_FUNCTION                          13
-#define DUK_TOK_IF                                14
-#define DUK_TOK_IN                                15
-#define DUK_TOK_INSTANCEOF                        16
-#define DUK_TOK_NEW                               17
-#define DUK_TOK_RETURN                            18
-#define DUK_TOK_SWITCH                            19
-#define DUK_TOK_THIS                              20
-#define DUK_TOK_THROW                             21
-#define DUK_TOK_TRY                               22
-#define DUK_TOK_TYPEOF                            23
-#define DUK_TOK_VAR                               24
-#define DUK_TOK_CONST                             25
-#define DUK_TOK_VOID                              26
-#define DUK_TOK_WHILE                             27
-#define DUK_TOK_WITH                              28
+#define DUK_TOK_START_RESERVED 2
+#define DUK_TOK_BREAK          2
+#define DUK_TOK_CASE           3
+#define DUK_TOK_CATCH          4
+#define DUK_TOK_CONTINUE       5
+#define DUK_TOK_DEBUGGER       6
+#define DUK_TOK_DEFAULT        7
+#define DUK_TOK_DELETE         8
+#define DUK_TOK_DO             9
+#define DUK_TOK_ELSE           10
+#define DUK_TOK_FINALLY        11
+#define DUK_TOK_FOR            12
+#define DUK_TOK_FUNCTION       13
+#define DUK_TOK_IF             14
+#define DUK_TOK_IN             15
+#define DUK_TOK_INSTANCEOF     16
+#define DUK_TOK_NEW            17
+#define DUK_TOK_RETURN         18
+#define DUK_TOK_SWITCH         19
+#define DUK_TOK_THIS           20
+#define DUK_TOK_THROW          21
+#define DUK_TOK_TRY            22
+#define DUK_TOK_TYPEOF         23
+#define DUK_TOK_VAR            24
+#define DUK_TOK_CONST          25
+#define DUK_TOK_VOID           26
+#define DUK_TOK_WHILE          27
+#define DUK_TOK_WITH           28
 
 /* reserved words: future reserved words */
-#define DUK_TOK_CLASS                             29
-#define DUK_TOK_ENUM                              30
-#define DUK_TOK_EXPORT                            31
-#define DUK_TOK_EXTENDS                           32
-#define DUK_TOK_IMPORT                            33
-#define DUK_TOK_SUPER                             34
+#define DUK_TOK_CLASS   29
+#define DUK_TOK_ENUM    30
+#define DUK_TOK_EXPORT  31
+#define DUK_TOK_EXTENDS 32
+#define DUK_TOK_IMPORT  33
+#define DUK_TOK_SUPER   34
 
 /* "null", "true", and "false" are always reserved words.
  * Note that "get" and "set" are not!
  */
-#define DUK_TOK_NULL                              35
-#define DUK_TOK_TRUE                              36
-#define DUK_TOK_FALSE                             37
+#define DUK_TOK_NULL  35
+#define DUK_TOK_TRUE  36
+#define DUK_TOK_FALSE 37
 
 /* reserved words: additional future reserved words in strict mode */
-#define DUK_TOK_START_STRICT_RESERVED             38  /* inclusive */
-#define DUK_TOK_IMPLEMENTS                        38
-#define DUK_TOK_INTERFACE                         39
-#define DUK_TOK_LET                               40
-#define DUK_TOK_PACKAGE                           41
-#define DUK_TOK_PRIVATE                           42
-#define DUK_TOK_PROTECTED                         43
-#define DUK_TOK_PUBLIC                            44
-#define DUK_TOK_STATIC                            45
-#define DUK_TOK_YIELD                             46
+#define DUK_TOK_START_STRICT_RESERVED 38 /* inclusive */
+#define DUK_TOK_IMPLEMENTS            38
+#define DUK_TOK_INTERFACE             39
+#define DUK_TOK_LET                   40
+#define DUK_TOK_PACKAGE               41
+#define DUK_TOK_PRIVATE               42
+#define DUK_TOK_PROTECTED             43
+#define DUK_TOK_PUBLIC                44
+#define DUK_TOK_STATIC                45
+#define DUK_TOK_YIELD                 46
 
-#define DUK_TOK_END_RESERVED                      47  /* exclusive */
+#define DUK_TOK_END_RESERVED 47 /* exclusive */
 
 /* "get" and "set" are tokens but NOT ReservedWords.  They are currently
  * parsed and identifiers and these defines are actually now unused.
  */
-#define DUK_TOK_GET                               47
-#define DUK_TOK_SET                               48
+#define DUK_TOK_GET 47
+#define DUK_TOK_SET 48
 
 /* punctuators (unlike the spec, also includes "/" and "/=") */
-#define DUK_TOK_LCURLY                            49
-#define DUK_TOK_RCURLY                            50
-#define DUK_TOK_LBRACKET                          51
-#define DUK_TOK_RBRACKET                          52
-#define DUK_TOK_LPAREN                            53
-#define DUK_TOK_RPAREN                            54
-#define DUK_TOK_PERIOD                            55
-#define DUK_TOK_SEMICOLON                         56
-#define DUK_TOK_COMMA                             57
-#define DUK_TOK_LT                                58
-#define DUK_TOK_GT                                59
-#define DUK_TOK_LE                                60
-#define DUK_TOK_GE                                61
-#define DUK_TOK_EQ                                62
-#define DUK_TOK_NEQ                               63
-#define DUK_TOK_SEQ                               64
-#define DUK_TOK_SNEQ                              65
-#define DUK_TOK_ADD                               66
-#define DUK_TOK_SUB                               67
-#define DUK_TOK_MUL                               68
-#define DUK_TOK_DIV                               69
-#define DUK_TOK_MOD                               70
-#define DUK_TOK_EXP                               71
-#define DUK_TOK_INCREMENT                         72
-#define DUK_TOK_DECREMENT                         73
-#define DUK_TOK_ALSHIFT                           74   /* named "arithmetic" because result is signed */
-#define DUK_TOK_ARSHIFT                           75
-#define DUK_TOK_RSHIFT                            76
-#define DUK_TOK_BAND                              77
-#define DUK_TOK_BOR                               78
-#define DUK_TOK_BXOR                              79
-#define DUK_TOK_LNOT                              80
-#define DUK_TOK_BNOT                              81
-#define DUK_TOK_LAND                              82
-#define DUK_TOK_LOR                               83
-#define DUK_TOK_QUESTION                          84
-#define DUK_TOK_COLON                             85
-#define DUK_TOK_EQUALSIGN                         86
-#define DUK_TOK_ADD_EQ                            87
-#define DUK_TOK_SUB_EQ                            88
-#define DUK_TOK_MUL_EQ                            89
-#define DUK_TOK_DIV_EQ                            90
-#define DUK_TOK_MOD_EQ                            91
-#define DUK_TOK_EXP_EQ                            92
-#define DUK_TOK_ALSHIFT_EQ                        93
-#define DUK_TOK_ARSHIFT_EQ                        94
-#define DUK_TOK_RSHIFT_EQ                         95
-#define DUK_TOK_BAND_EQ                           96
-#define DUK_TOK_BOR_EQ                            97
-#define DUK_TOK_BXOR_EQ                           98
+#define DUK_TOK_LCURLY     49
+#define DUK_TOK_RCURLY     50
+#define DUK_TOK_LBRACKET   51
+#define DUK_TOK_RBRACKET   52
+#define DUK_TOK_LPAREN     53
+#define DUK_TOK_RPAREN     54
+#define DUK_TOK_PERIOD     55
+#define DUK_TOK_SEMICOLON  56
+#define DUK_TOK_COMMA      57
+#define DUK_TOK_LT         58
+#define DUK_TOK_GT         59
+#define DUK_TOK_LE         60
+#define DUK_TOK_GE         61
+#define DUK_TOK_EQ         62
+#define DUK_TOK_NEQ        63
+#define DUK_TOK_SEQ        64
+#define DUK_TOK_SNEQ       65
+#define DUK_TOK_ADD        66
+#define DUK_TOK_SUB        67
+#define DUK_TOK_MUL        68
+#define DUK_TOK_DIV        69
+#define DUK_TOK_MOD        70
+#define DUK_TOK_EXP        71
+#define DUK_TOK_INCREMENT  72
+#define DUK_TOK_DECREMENT  73
+#define DUK_TOK_ALSHIFT    74 /* named "arithmetic" because result is signed */
+#define DUK_TOK_ARSHIFT    75
+#define DUK_TOK_RSHIFT     76
+#define DUK_TOK_BAND       77
+#define DUK_TOK_BOR        78
+#define DUK_TOK_BXOR       79
+#define DUK_TOK_LNOT       80
+#define DUK_TOK_BNOT       81
+#define DUK_TOK_LAND       82
+#define DUK_TOK_LOR        83
+#define DUK_TOK_QUESTION   84
+#define DUK_TOK_COLON      85
+#define DUK_TOK_EQUALSIGN  86
+#define DUK_TOK_ADD_EQ     87
+#define DUK_TOK_SUB_EQ     88
+#define DUK_TOK_MUL_EQ     89
+#define DUK_TOK_DIV_EQ     90
+#define DUK_TOK_MOD_EQ     91
+#define DUK_TOK_EXP_EQ     92
+#define DUK_TOK_ALSHIFT_EQ 93
+#define DUK_TOK_ARSHIFT_EQ 94
+#define DUK_TOK_RSHIFT_EQ  95
+#define DUK_TOK_BAND_EQ    96
+#define DUK_TOK_BOR_EQ     97
+#define DUK_TOK_BXOR_EQ    98
 
 /* literals (E5 Section 7.8), except null, true, false, which are treated
  * like reserved words (above).
  */
-#define DUK_TOK_NUMBER                            99
-#define DUK_TOK_STRING                            100
-#define DUK_TOK_REGEXP                            101
+#define DUK_TOK_NUMBER 99
+#define DUK_TOK_STRING 100
+#define DUK_TOK_REGEXP 101
 
-#define DUK_TOK_MAXVAL                            101  /* inclusive */
+#define DUK_TOK_MAXVAL 101 /* inclusive */
 
-#define DUK_TOK_INVALID                           DUK_SMALL_UINT_MAX
+#define DUK_TOK_INVALID DUK_SMALL_UINT_MAX
 
 /* Convert heap string index to a token (reserved words) */
-#define DUK_STRIDX_TO_TOK(x)                        ((x) - DUK_STRIDX_START_RESERVED + DUK_TOK_START_RESERVED)
+#define DUK_STRIDX_TO_TOK(x) ((x) -DUK_STRIDX_START_RESERVED + DUK_TOK_START_RESERVED)
 
 /* Sanity check */
 #if (DUK_TOK_MAXVAL > 255)
 #error DUK_TOK_MAXVAL too large, code assumes it fits into 8 bits
 #endif
 
 /* Sanity checks for string and token defines */
@@ -4035,65 +4130,65 @@
 #error mismatch in token defines
 #endif
 #if (DUK_STRIDX_TO_TOK(DUK_STRIDX_YIELD) != DUK_TOK_YIELD)
 #error mismatch in token defines
 #endif
 
 /* Regexp tokens */
-#define DUK_RETOK_EOF                              0
-#define DUK_RETOK_DISJUNCTION                      1
-#define DUK_RETOK_QUANTIFIER                       2
-#define DUK_RETOK_ASSERT_START                     3
-#define DUK_RETOK_ASSERT_END                       4
-#define DUK_RETOK_ASSERT_WORD_BOUNDARY             5
-#define DUK_RETOK_ASSERT_NOT_WORD_BOUNDARY         6
-#define DUK_RETOK_ASSERT_START_POS_LOOKAHEAD       7
-#define DUK_RETOK_ASSERT_START_NEG_LOOKAHEAD       8
-#define DUK_RETOK_ATOM_PERIOD                      9
-#define DUK_RETOK_ATOM_CHAR                        10
-#define DUK_RETOK_ATOM_DIGIT                       11  /* assumptions in regexp compiler */
-#define DUK_RETOK_ATOM_NOT_DIGIT                   12  /* -""- */
-#define DUK_RETOK_ATOM_WHITE                       13  /* -""- */
-#define DUK_RETOK_ATOM_NOT_WHITE                   14  /* -""- */
-#define DUK_RETOK_ATOM_WORD_CHAR                   15  /* -""- */
-#define DUK_RETOK_ATOM_NOT_WORD_CHAR               16  /* -""- */
-#define DUK_RETOK_ATOM_BACKREFERENCE               17
-#define DUK_RETOK_ATOM_START_CAPTURE_GROUP         18
-#define DUK_RETOK_ATOM_START_NONCAPTURE_GROUP      19
-#define DUK_RETOK_ATOM_START_CHARCLASS             20
-#define DUK_RETOK_ATOM_START_CHARCLASS_INVERTED    21
-#define DUK_RETOK_ATOM_END_GROUP                   22
+#define DUK_RETOK_EOF                           0
+#define DUK_RETOK_DISJUNCTION                   1
+#define DUK_RETOK_QUANTIFIER                    2
+#define DUK_RETOK_ASSERT_START                  3
+#define DUK_RETOK_ASSERT_END                    4
+#define DUK_RETOK_ASSERT_WORD_BOUNDARY          5
+#define DUK_RETOK_ASSERT_NOT_WORD_BOUNDARY      6
+#define DUK_RETOK_ASSERT_START_POS_LOOKAHEAD    7
+#define DUK_RETOK_ASSERT_START_NEG_LOOKAHEAD    8
+#define DUK_RETOK_ATOM_PERIOD                   9
+#define DUK_RETOK_ATOM_CHAR                     10
+#define DUK_RETOK_ATOM_DIGIT                    11 /* assumptions in regexp compiler */
+#define DUK_RETOK_ATOM_NOT_DIGIT                12 /* -""- */
+#define DUK_RETOK_ATOM_WHITE                    13 /* -""- */
+#define DUK_RETOK_ATOM_NOT_WHITE                14 /* -""- */
+#define DUK_RETOK_ATOM_WORD_CHAR                15 /* -""- */
+#define DUK_RETOK_ATOM_NOT_WORD_CHAR            16 /* -""- */
+#define DUK_RETOK_ATOM_BACKREFERENCE            17
+#define DUK_RETOK_ATOM_START_CAPTURE_GROUP      18
+#define DUK_RETOK_ATOM_START_NONCAPTURE_GROUP   19
+#define DUK_RETOK_ATOM_START_CHARCLASS          20
+#define DUK_RETOK_ATOM_START_CHARCLASS_INVERTED 21
+#define DUK_RETOK_ATOM_END_GROUP                22
 
 /* Constants for duk_lexer_ctx.buf. */
-#define DUK_LEXER_TEMP_BUF_LIMIT                   256
+#define DUK_LEXER_TEMP_BUF_LIMIT 256
 
 /* A token value.  Can be memcpy()'d, but note that slot1/slot2 values are on the valstack.
  * Some fields (like num, str1, str2) are only valid for specific token types and may have
  * stale values otherwise.
  */
 struct duk_token {
-	duk_small_uint_t t;           /* token type (with reserved word identification) */
-	duk_small_uint_t t_nores;     /* token type (with reserved words as DUK_TOK_IDENTIFER) */
-	duk_double_t num;             /* numeric value of token */
-	duk_hstring *str1;            /* string 1 of token (borrowed, stored to ctx->slot1_idx) */
-	duk_hstring *str2;            /* string 2 of token (borrowed, stored to ctx->slot2_idx) */
-	duk_size_t start_offset;      /* start byte offset of token in lexer input */
-	duk_int_t start_line;         /* start line of token (first char) */
-	duk_int_t num_escapes;        /* number of escapes and line continuations (for directive prologue) */
-	duk_bool_t lineterm;          /* token was preceded by a lineterm */
-	duk_bool_t allow_auto_semi;   /* token allows automatic semicolon insertion (eof or preceded by newline) */
+	duk_small_uint_t t; /* token type (with reserved word identification) */
+	duk_small_uint_t t_nores; /* token type (with reserved words as DUK_TOK_IDENTIFER) */
+	duk_double_t num; /* numeric value of token */
+	duk_hstring *str1; /* string 1 of token (borrowed, stored to ctx->slot1_idx) */
+	duk_hstring *str2; /* string 2 of token (borrowed, stored to ctx->slot2_idx) */
+	duk_size_t start_offset; /* start byte offset of token in lexer input */
+	duk_int_t start_line; /* start line of token (first char) */
+	duk_int_t num_escapes; /* number of escapes and line continuations (for directive prologue) */
+	duk_bool_t lineterm; /* token was preceded by a lineterm */
+	duk_bool_t allow_auto_semi; /* token allows automatic semicolon insertion (eof or preceded by newline) */
 };
 
-#define DUK_RE_QUANTIFIER_INFINITE         ((duk_uint32_t) 0xffffffffUL)
+#define DUK_RE_QUANTIFIER_INFINITE ((duk_uint32_t) 0xffffffffUL)
 
 /* A regexp token value. */
 struct duk_re_token {
-	duk_small_uint_t t;          /* token type */
+	duk_small_uint_t t; /* token type */
 	duk_small_uint_t greedy;
-	duk_uint32_t num;            /* numeric value (character, count) */
+	duk_uint32_t num; /* numeric value (character, count) */
 	duk_uint32_t qmin;
 	duk_uint32_t qmax;
 };
 
 /* A structure for 'snapshotting' a point for rewinding */
 struct duk_lexer_point {
 	duk_size_t offset;
@@ -4112,117 +4207,114 @@
 #if defined(DUK_USE_LEXER_SLIDING_WINDOW)
 	duk_lexer_codepoint *window; /* unicode code points, window[0] is always next, points to 'buffer' */
 	duk_lexer_codepoint buffer[DUK_LEXER_BUFFER_SIZE];
 #else
 	duk_lexer_codepoint window[DUK_LEXER_WINDOW_SIZE]; /* unicode code points, window[0] is always next */
 #endif
 
-	duk_hthread *thr;                              /* thread; minimizes argument passing */
+	duk_hthread *thr; /* thread; minimizes argument passing */
 
-	const duk_uint8_t *input;                      /* input string (may be a user pointer) */
-	duk_size_t input_length;                       /* input byte length */
-	duk_size_t input_offset;                       /* input offset for window leading edge (not window[0]) */
-	duk_int_t input_line;                          /* input linenumber at input_offset (not window[0]), init to 1 */
-
-	duk_idx_t slot1_idx;                           /* valstack slot for 1st token value */
-	duk_idx_t slot2_idx;                           /* valstack slot for 2nd token value */
-	duk_idx_t buf_idx;                             /* valstack slot for temp buffer */
-	duk_hbuffer_dynamic *buf;                      /* temp accumulation buffer */
-	duk_bufwriter_ctx bw;                          /* bufwriter for temp accumulation */
+	const duk_uint8_t *input; /* input string (may be a user pointer) */
+	duk_size_t input_length; /* input byte length */
+	duk_size_t input_offset; /* input offset for window leading edge (not window[0]) */
+	duk_int_t input_line; /* input linenumber at input_offset (not window[0]), init to 1 */
+
+	duk_idx_t slot1_idx; /* valstack slot for 1st token value */
+	duk_idx_t slot2_idx; /* valstack slot for 2nd token value */
+	duk_idx_t buf_idx; /* valstack slot for temp buffer */
+	duk_hbuffer_dynamic *buf; /* temp accumulation buffer */
+	duk_bufwriter_ctx bw; /* bufwriter for temp accumulation */
 
-	duk_int_t token_count;                         /* number of tokens parsed */
-	duk_int_t token_limit;                         /* maximum token count before error (sanity backstop) */
+	duk_int_t token_count; /* number of tokens parsed */
+	duk_int_t token_limit; /* maximum token count before error (sanity backstop) */
 
-	duk_small_uint_t flags;                        /* lexer flags, use compiler flag defines for now */
+	duk_small_uint_t flags; /* lexer flags, use compiler flag defines for now */
 };
 
 /*
  *  Prototypes
  */
 
 DUK_INTERNAL_DECL void duk_lexer_initctx(duk_lexer_ctx *lex_ctx);
 
 DUK_INTERNAL_DECL void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);
 DUK_INTERNAL_DECL void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);
 
 DUK_INTERNAL_DECL
-void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx,
-                                      duk_token *out_token,
-                                      duk_bool_t strict_mode,
-                                      duk_bool_t regexp_mode);
+void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx, duk_token *out_token, duk_bool_t strict_mode, duk_bool_t regexp_mode);
 #if defined(DUK_USE_REGEXP_SUPPORT)
 DUK_INTERNAL_DECL void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token);
 DUK_INTERNAL_DECL void duk_lexer_parse_re_ranges(duk_lexer_ctx *lex_ctx, duk_re_range_callback gen_range, void *userdata);
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
-#endif  /* DUK_LEXER_H_INCLUDED */
+#endif /* DUK_LEXER_H_INCLUDED */
 /* #include duk_js_compiler.h */
 #line 1 "duk_js_compiler.h"
 /*
  *  ECMAScript compiler.
  */
 
 #if !defined(DUK_JS_COMPILER_H_INCLUDED)
 #define DUK_JS_COMPILER_H_INCLUDED
 
 /* ECMAScript compiler limits */
-#define DUK_COMPILER_TOKEN_LIMIT           100000000L  /* 1e8: protects against deeply nested inner functions */
+#define DUK_COMPILER_TOKEN_LIMIT 100000000L /* 1e8: protects against deeply nested inner functions */
 
 /* maximum loopcount for peephole optimization */
-#define DUK_COMPILER_PEEPHOLE_MAXITER      3
+#define DUK_COMPILER_PEEPHOLE_MAXITER 3
 
 /* maximum bytecode length in instructions */
-#define DUK_COMPILER_MAX_BYTECODE_LENGTH   (256L * 1024L * 1024L)  /* 1 GB */
+#define DUK_COMPILER_MAX_BYTECODE_LENGTH (256L * 1024L * 1024L) /* 1 GB */
 
 /*
  *  Compiler intermediate values
  *
  *  Intermediate values describe either plain values (e.g. strings or
  *  numbers) or binary operations which have not yet been coerced into
  *  either a left-hand-side or right-hand-side role (e.g. object property).
  */
 
-#define DUK_IVAL_NONE          0   /* no value */
-#define DUK_IVAL_PLAIN         1   /* register, constant, or value */
-#define DUK_IVAL_ARITH         2   /* binary arithmetic; DUK_OP_ADD, DUK_OP_EQ, other binary ops */
-#define DUK_IVAL_PROP          3   /* property access */
-#define DUK_IVAL_VAR           4   /* variable access */
-
-#define DUK_ISPEC_NONE         0   /* no value */
-#define DUK_ISPEC_VALUE        1   /* value resides in 'valstack_idx' */
-#define DUK_ISPEC_REGCONST     2   /* value resides in a register or constant */
+#define DUK_IVAL_NONE  0 /* no value */
+#define DUK_IVAL_PLAIN 1 /* register, constant, or value */
+#define DUK_IVAL_ARITH 2 /* binary arithmetic; DUK_OP_ADD, DUK_OP_EQ, other binary ops */
+#define DUK_IVAL_PROP  3 /* property access */
+#define DUK_IVAL_VAR   4 /* variable access */
+
+#define DUK_ISPEC_NONE     0 /* no value */
+#define DUK_ISPEC_VALUE    1 /* value resides in 'valstack_idx' */
+#define DUK_ISPEC_REGCONST 2 /* value resides in a register or constant */
 
 /* Bit mask which indicates that a regconst is a constant instead of a register.
  * Chosen so that when a regconst is cast to duk_int32_t, all consts are
  * negative values.
  */
-#define DUK_REGCONST_CONST_MARKER    DUK_INT32_MIN  /* = -0x80000000 */
+#define DUK_REGCONST_CONST_MARKER DUK_INT32_MIN /* = -0x80000000 */
 
 /* Type to represent a reg/const reference during compilation, with <0
  * indicating a constant.  Some call sites also use -1 to indicate 'none'.
  */
 typedef duk_int32_t duk_regconst_t;
 
 typedef struct {
-	duk_small_uint_t t;          /* DUK_ISPEC_XXX */
+	duk_small_uint_t t; /* DUK_ISPEC_XXX */
 	duk_regconst_t regconst;
-	duk_idx_t valstack_idx;      /* always set; points to a reserved valstack slot */
+	duk_idx_t valstack_idx; /* always set; points to a reserved valstack slot */
 } duk_ispec;
 
 typedef struct {
 	/*
 	 *  PLAIN: x1
 	 *  ARITH: x1 <op> x2
 	 *  PROP: x1.x2
 	 *  VAR: x1 (name)
 	 */
 
 	/* XXX: can be optimized for smaller footprint esp. on 32-bit environments */
-	duk_small_uint_t t;          /* DUK_IVAL_XXX */
-	duk_small_uint_t op;         /* bytecode opcode for binary ops */
+	duk_small_uint_t t; /* DUK_IVAL_XXX */
+	duk_small_uint_t op; /* bytecode opcode for binary ops */
 	duk_ispec x1;
 	duk_ispec x2;
 } duk_ivalue;
 
 /*
  *  Bytecode instruction representation during compilation
  *
@@ -4236,30 +4328,30 @@
 #endif
 };
 
 /*
  *  Compiler state
  */
 
-#define DUK_LABEL_FLAG_ALLOW_BREAK       (1U << 0)
-#define DUK_LABEL_FLAG_ALLOW_CONTINUE    (1U << 1)
+#define DUK_LABEL_FLAG_ALLOW_BREAK    (1U << 0)
+#define DUK_LABEL_FLAG_ALLOW_CONTINUE (1U << 1)
 
-#define DUK_DECL_TYPE_VAR                0
-#define DUK_DECL_TYPE_FUNC               1
+#define DUK_DECL_TYPE_VAR  0
+#define DUK_DECL_TYPE_FUNC 1
 
 /* XXX: optimize to 16 bytes */
 typedef struct {
 	duk_small_uint_t flags;
-	duk_int_t label_id;          /* numeric label_id (-1 reserved as marker) */
-	duk_hstring *h_label;        /* borrowed label name */
-	duk_int_t catch_depth;       /* catch depth at point of definition */
-	duk_int_t pc_label;          /* pc of label statement:
-	                              * pc+1: break jump site
-	                              * pc+2: continue jump site
-	                              */
+	duk_int_t label_id; /* numeric label_id (-1 reserved as marker) */
+	duk_hstring *h_label; /* borrowed label name */
+	duk_int_t catch_depth; /* catch depth at point of definition */
+	duk_int_t pc_label; /* pc of label statement:
+	                     * pc+1: break jump site
+	                     * pc+2: continue jump site
+	                     */
 
 	/* Fast jumps (which avoid longjmp) jump directly to the jump sites
 	 * which are always known even while the iteration/switch statement
 	 * is still being parsed.  A final peephole pass "straightens out"
 	 * the jumps.
 	 */
 } duk_labelinfo;
@@ -4267,108 +4359,110 @@
 /* Compiling state of one function, eventually converted to duk_hcompfunc */
 struct duk_compiler_func {
 	/* These pointers are at the start of the struct so that they pack
 	 * nicely.  Mixing pointers and integer values is bad on some
 	 * platforms (e.g. if int is 32 bits and pointers are 64 bits).
 	 */
 
-	duk_bufwriter_ctx bw_code;          /* bufwriter for code */
+	duk_bufwriter_ctx bw_code; /* bufwriter for code */
 
-	duk_hstring *h_name;                /* function name (borrowed reference), ends up in _name */
+	duk_hstring *h_name; /* function name (borrowed reference), ends up in _name */
 	/* h_code: held in bw_code */
-	duk_hobject *h_consts;              /* array */
-	duk_hobject *h_funcs;               /* array of function templates: [func1, offset1, line1, func2, offset2, line2]
-	                                     * offset/line points to closing brace to allow skipping on pass 2
-	                                     */
-	duk_hobject *h_decls;               /* array of declarations: [ name1, val1, name2, val2, ... ]
-	                                     * valN = (typeN) | (fnum << 8), where fnum is inner func number (0 for vars)
-	                                     * record function and variable declarations in pass 1
-	                                     */
-	duk_hobject *h_labelnames;          /* array of active label names */
-	duk_hbuffer_dynamic *h_labelinfos;  /* C array of duk_labelinfo */
-	duk_hobject *h_argnames;            /* array of formal argument names (-> _Formals) */
-	duk_hobject *h_varmap;              /* variable map for pass 2 (identifier -> register number or null (unmapped)) */
+	duk_hobject *h_consts; /* array */
+	duk_hobject *h_funcs; /* array of function templates: [func1, offset1, line1, func2, offset2, line2]
+	                       * offset/line points to closing brace to allow skipping on pass 2
+	                       */
+	duk_hobject *h_decls; /* array of declarations: [ name1, val1, name2, val2, ... ]
+	                       * valN = (typeN) | (fnum << 8), where fnum is inner func number (0 for vars)
+	                       * record function and variable declarations in pass 1
+	                       */
+	duk_hobject *h_labelnames; /* array of active label names */
+	duk_hbuffer_dynamic *h_labelinfos; /* C array of duk_labelinfo */
+	duk_hobject *h_argnames; /* array of formal argument names (-> _Formals) */
+	duk_hobject *h_varmap; /* variable map for pass 2 (identifier -> register number or null (unmapped)) */
 
 	/* Value stack indices for tracking objects. */
 	/* code_idx: not needed */
 	duk_idx_t consts_idx;
 	duk_idx_t funcs_idx;
 	duk_idx_t decls_idx;
 	duk_idx_t labelnames_idx;
 	duk_idx_t labelinfos_idx;
 	duk_idx_t argnames_idx;
 	duk_idx_t varmap_idx;
 
 	/* Temp reg handling. */
-	duk_regconst_t temp_first;           /* first register that is a temporary (below: variables) */
-	duk_regconst_t temp_next;            /* next temporary register to allocate */
-	duk_regconst_t temp_max;             /* highest value of temp_reg (temp_max - 1 is highest used reg) */
+	duk_regconst_t temp_first; /* first register that is a temporary (below: variables) */
+	duk_regconst_t temp_next; /* next temporary register to allocate */
+	duk_regconst_t temp_max; /* highest value of temp_reg (temp_max - 1 is highest used reg) */
 
 	/* Shuffle registers if large number of regs/consts. */
 	duk_regconst_t shuffle1;
 	duk_regconst_t shuffle2;
 	duk_regconst_t shuffle3;
 
 	/* Stats for current expression being parsed. */
 	duk_int_t nud_count;
 	duk_int_t led_count;
-	duk_int_t paren_level;              /* parenthesis count, 0 = top level */
-	duk_bool_t expr_lhs;                /* expression is left-hand-side compatible */
-	duk_bool_t allow_in;                /* current paren level allows 'in' token */
+	duk_int_t paren_level; /* parenthesis count, 0 = top level */
+	duk_bool_t expr_lhs; /* expression is left-hand-side compatible */
+	duk_bool_t allow_in; /* current paren level allows 'in' token */
 
 	/* Misc. */
-	duk_int_t stmt_next;                /* statement id allocation (running counter) */
-	duk_int_t label_next;               /* label id allocation (running counter) */
-	duk_int_t catch_depth;              /* catch stack depth */
-	duk_int_t with_depth;               /* with stack depth (affects identifier lookups) */
-	duk_int_t fnum_next;                /* inner function numbering */
-	duk_int_t num_formals;              /* number of formal arguments */
-	duk_regconst_t reg_stmt_value;      /* register for writing value of 'non-empty' statements (global or eval code), -1 is marker */
+	duk_int_t stmt_next; /* statement id allocation (running counter) */
+	duk_int_t label_next; /* label id allocation (running counter) */
+	duk_int_t catch_depth; /* catch stack depth */
+	duk_int_t with_depth; /* with stack depth (affects identifier lookups) */
+	duk_int_t fnum_next; /* inner function numbering */
+	duk_int_t num_formals; /* number of formal arguments */
+	duk_regconst_t
+	    reg_stmt_value; /* register for writing value of 'non-empty' statements (global or eval code), -1 is marker */
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
-	duk_int_t min_line;                 /* XXX: typing (duk_hcompfunc has duk_uint32_t) */
+	duk_int_t min_line; /* XXX: typing (duk_hcompfunc has duk_uint32_t) */
 	duk_int_t max_line;
 #endif
 
 	/* Status booleans. */
-	duk_uint8_t is_function;             /* is an actual function (not global/eval code) */
-	duk_uint8_t is_eval;                 /* is eval code */
-	duk_uint8_t is_global;               /* is global code */
-	duk_uint8_t is_namebinding;          /* needs a name binding */
-	duk_uint8_t is_constructable;        /* result is constructable */
-	duk_uint8_t is_setget;               /* is a setter/getter */
-	duk_uint8_t is_strict;               /* function is strict */
-	duk_uint8_t is_notail;               /* function must not be tail called */
-	duk_uint8_t in_directive_prologue;   /* parsing in "directive prologue", recognize directives */
-	duk_uint8_t in_scanning;             /* parsing in "scanning" phase (first pass) */
-	duk_uint8_t may_direct_eval;         /* function may call direct eval */
-	duk_uint8_t id_access_arguments;     /* function refers to 'arguments' identifier */
-	duk_uint8_t id_access_slow;          /* function makes one or more slow path accesses that won't match own static variables */
-	duk_uint8_t id_access_slow_own;      /* function makes one or more slow path accesses that may match own static variables */
-	duk_uint8_t is_arguments_shadowed;   /* argument/function declaration shadows 'arguments' */
-	duk_uint8_t needs_shuffle;           /* function needs shuffle registers */
-	duk_uint8_t reject_regexp_in_adv;    /* reject RegExp literal on next advance() call; needed for handling IdentifierName productions */
-	duk_uint8_t allow_regexp_in_adv;     /* allow RegExp literal on next advance() call */
+	duk_uint8_t is_function; /* is an actual function (not global/eval code) */
+	duk_uint8_t is_eval; /* is eval code */
+	duk_uint8_t is_global; /* is global code */
+	duk_uint8_t is_namebinding; /* needs a name binding */
+	duk_uint8_t is_constructable; /* result is constructable */
+	duk_uint8_t is_setget; /* is a setter/getter */
+	duk_uint8_t is_strict; /* function is strict */
+	duk_uint8_t is_notail; /* function must not be tail called */
+	duk_uint8_t in_directive_prologue; /* parsing in "directive prologue", recognize directives */
+	duk_uint8_t in_scanning; /* parsing in "scanning" phase (first pass) */
+	duk_uint8_t may_direct_eval; /* function may call direct eval */
+	duk_uint8_t id_access_arguments; /* function refers to 'arguments' identifier */
+	duk_uint8_t id_access_slow; /* function makes one or more slow path accesses that won't match own static variables */
+	duk_uint8_t id_access_slow_own; /* function makes one or more slow path accesses that may match own static variables */
+	duk_uint8_t is_arguments_shadowed; /* argument/function declaration shadows 'arguments' */
+	duk_uint8_t needs_shuffle; /* function needs shuffle registers */
+	duk_uint8_t
+	    reject_regexp_in_adv; /* reject RegExp literal on next advance() call; needed for handling IdentifierName productions */
+	duk_uint8_t allow_regexp_in_adv; /* allow RegExp literal on next advance() call */
 };
 
 struct duk_compiler_ctx {
 	duk_hthread *thr;
 
 	/* filename being compiled (ends up in functions' '_filename' property) */
-	duk_hstring *h_filename;            /* borrowed reference */
+	duk_hstring *h_filename; /* borrowed reference */
 
 	/* lexing (tokenization) state (contains two valstack slot indices) */
 	duk_lexer_ctx lex;
 
 	/* current and previous token for parsing */
 	duk_token prev_token;
 	duk_token curr_token;
-	duk_idx_t tok11_idx;                /* curr_token slot1 (matches 'lex' slot1_idx) */
-	duk_idx_t tok12_idx;                /* curr_token slot2 (matches 'lex' slot2_idx) */
-	duk_idx_t tok21_idx;                /* prev_token slot1 */
-	duk_idx_t tok22_idx;                /* prev_token slot2 */
+	duk_idx_t tok11_idx; /* curr_token slot1 (matches 'lex' slot1_idx) */
+	duk_idx_t tok12_idx; /* curr_token slot2 (matches 'lex' slot2_idx) */
+	duk_idx_t tok21_idx; /* prev_token slot1 */
+	duk_idx_t tok22_idx; /* prev_token slot2 */
 
 	/* recursion limit */
 	duk_int_t recursion_depth;
 	duk_int_t recursion_limit;
 
 	/* code emission temporary */
 	duk_int_t emit_jumpslot_pc;
@@ -4377,103 +4471,106 @@
 	duk_compiler_func curr_func;
 };
 
 /*
  *  Prototypes
  */
 
-DUK_INTERNAL_DECL void duk_js_compile(duk_hthread *thr, const duk_uint8_t *src_buffer, duk_size_t src_length, duk_small_uint_t flags);
+DUK_INTERNAL_DECL void duk_js_compile(duk_hthread *thr,
+                                      const duk_uint8_t *src_buffer,
+                                      duk_size_t src_length,
+                                      duk_small_uint_t flags);
 
-#endif  /* DUK_JS_COMPILER_H_INCLUDED */
+#endif /* DUK_JS_COMPILER_H_INCLUDED */
 /* #include duk_regexp.h */
 #line 1 "duk_regexp.h"
 /*
  *  Regular expression structs, constants, and bytecode defines.
  */
 
 #if !defined(DUK_REGEXP_H_INCLUDED)
 #define DUK_REGEXP_H_INCLUDED
 
 /* maximum bytecode copies for {n,m} quantifiers */
-#define DUK_RE_MAX_ATOM_COPIES             1000
+#define DUK_RE_MAX_ATOM_COPIES 1000
 
 /* regexp compilation limits */
-#define DUK_RE_COMPILE_TOKEN_LIMIT         100000000L   /* 1e8 */
+#define DUK_RE_COMPILE_TOKEN_LIMIT 100000000L /* 1e8 */
 
 /* regexp execution limits */
-#define DUK_RE_EXECUTE_STEPS_LIMIT         1000000000L  /* 1e9 */
+#define DUK_RE_EXECUTE_STEPS_LIMIT 1000000000L /* 1e9 */
 
 /* regexp opcodes */
-#define DUK_REOP_MATCH                     1
-#define DUK_REOP_CHAR                      2
-#define DUK_REOP_PERIOD                    3
-#define DUK_REOP_RANGES                    4
-#define DUK_REOP_INVRANGES                 5
-#define DUK_REOP_JUMP                      6
-#define DUK_REOP_SPLIT1                    7
-#define DUK_REOP_SPLIT2                    8
-#define DUK_REOP_SQMINIMAL                 9
-#define DUK_REOP_SQGREEDY                  10
-#define DUK_REOP_SAVE                      11
-#define DUK_REOP_WIPERANGE                 12
-#define DUK_REOP_LOOKPOS                   13
-#define DUK_REOP_LOOKNEG                   14
-#define DUK_REOP_BACKREFERENCE             15
-#define DUK_REOP_ASSERT_START              16
-#define DUK_REOP_ASSERT_END                17
-#define DUK_REOP_ASSERT_WORD_BOUNDARY      18
-#define DUK_REOP_ASSERT_NOT_WORD_BOUNDARY  19
+#define DUK_REOP_MATCH                    1
+#define DUK_REOP_CHAR                     2
+#define DUK_REOP_PERIOD                   3
+#define DUK_REOP_RANGES                   4
+#define DUK_REOP_INVRANGES                5
+#define DUK_REOP_JUMP                     6
+#define DUK_REOP_SPLIT1                   7
+#define DUK_REOP_SPLIT2                   8
+#define DUK_REOP_SQMINIMAL                9
+#define DUK_REOP_SQGREEDY                 10
+#define DUK_REOP_SAVE                     11
+#define DUK_REOP_WIPERANGE                12
+#define DUK_REOP_LOOKPOS                  13
+#define DUK_REOP_LOOKNEG                  14
+#define DUK_REOP_BACKREFERENCE            15
+#define DUK_REOP_ASSERT_START             16
+#define DUK_REOP_ASSERT_END               17
+#define DUK_REOP_ASSERT_WORD_BOUNDARY     18
+#define DUK_REOP_ASSERT_NOT_WORD_BOUNDARY 19
 
 /* flags */
-#define DUK_RE_FLAG_GLOBAL                 (1U << 0)
-#define DUK_RE_FLAG_IGNORE_CASE            (1U << 1)
-#define DUK_RE_FLAG_MULTILINE              (1U << 2)
+#define DUK_RE_FLAG_GLOBAL      (1U << 0)
+#define DUK_RE_FLAG_IGNORE_CASE (1U << 1)
+#define DUK_RE_FLAG_MULTILINE   (1U << 2)
 
 struct duk_re_matcher_ctx {
 	duk_hthread *thr;
 
 	duk_uint32_t re_flags;
 	const duk_uint8_t *input;
 	const duk_uint8_t *input_end;
 	const duk_uint8_t *bytecode;
 	const duk_uint8_t *bytecode_end;
-	const duk_uint8_t **saved;  /* allocated from valstack (fixed buffer) */
+	const duk_uint8_t **saved; /* allocated from valstack (fixed buffer) */
 	duk_uint32_t nsaved;
 	duk_uint32_t recursion_depth;
 	duk_uint32_t recursion_limit;
 	duk_uint32_t steps_count;
 	duk_uint32_t steps_limit;
 };
 
 struct duk_re_compiler_ctx {
 	duk_hthread *thr;
 
 	duk_uint32_t re_flags;
 	duk_lexer_ctx lex;
 	duk_re_token curr_token;
 	duk_bufwriter_ctx bw;
-	duk_uint32_t captures;  /* highest capture number emitted so far (used as: ++captures) */
+	duk_uint32_t captures; /* highest capture number emitted so far (used as: ++captures) */
 	duk_uint32_t highest_backref;
 	duk_uint32_t recursion_depth;
 	duk_uint32_t recursion_limit;
-	duk_uint32_t nranges;  /* internal temporary value, used for char classes */
+	duk_uint32_t nranges; /* internal temporary value, used for char classes */
 };
 
 /*
  *  Prototypes
  */
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 DUK_INTERNAL_DECL void duk_regexp_compile(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_regexp_create_instance(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_regexp_match(duk_hthread *thr);
-DUK_INTERNAL_DECL void duk_regexp_match_force_global(duk_hthread *thr);  /* hacky helper for String.prototype.split() */
+DUK_INTERNAL_DECL void duk_regexp_match_force_global(duk_hthread *thr); /* hacky helper for String.prototype.split() */
 #endif
 
-#endif  /* DUK_REGEXP_H_INCLUDED */
+#endif /* DUK_REGEXP_H_INCLUDED */
 /* #include duk_heaphdr.h */
 #line 1 "duk_heaphdr.h"
 /*
  *  Heap header definition and assorted macros, including ref counting.
  *  Access all fields through the accessor macros.
  */
 
@@ -4519,15 +4616,15 @@
 #if defined(DUK_USE_REFCOUNT16)
 	duk_uint16_t h_refcount;
 #elif defined(DUK_USE_REFCOUNT32)
 	duk_uint32_t h_refcount;
 #else
 	duk_size_t h_refcount;
 #endif
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 #if defined(DUK_USE_HEAPPTR16)
 	duk_uint16_t h_next16;
 #else
 	duk_heaphdr *h_next;
 #endif
 
@@ -4567,176 +4664,185 @@
 	/* When assertions enabled, used by mark-and-sweep for refcount
 	 * validation.  Largest reasonable type; also detects overflows.
 	 */
 	duk_size_t h_assert_refcount;
 #endif
 #if defined(DUK_USE_REFCOUNT16)
 	duk_uint16_t h_refcount;
-	duk_uint16_t h_strextra16;  /* round out to 8 bytes */
+	duk_uint16_t h_strextra16; /* round out to 8 bytes */
 #elif defined(DUK_USE_REFCOUNT32)
 	duk_uint32_t h_refcount;
 #else
 	duk_size_t h_refcount;
 #endif
 #else
 	duk_uint16_t h_strextra16;
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 	duk_hstring *h_next;
 	/* No 'h_prev' pointer for strings. */
 };
 
-#define DUK_HEAPHDR_FLAGS_TYPE_MASK      0x00000003UL
-#define DUK_HEAPHDR_FLAGS_FLAG_MASK      (~DUK_HEAPHDR_FLAGS_TYPE_MASK)
+#define DUK_HEAPHDR_FLAGS_TYPE_MASK 0x00000003UL
+#define DUK_HEAPHDR_FLAGS_FLAG_MASK (~DUK_HEAPHDR_FLAGS_TYPE_MASK)
 
-                                             /* 2 bits for heap type */
-#define DUK_HEAPHDR_FLAGS_HEAP_START     2   /* 5 heap flags */
-#define DUK_HEAPHDR_FLAGS_USER_START     7   /* 25 user flags */
-
-#define DUK_HEAPHDR_HEAP_FLAG_NUMBER(n)  (DUK_HEAPHDR_FLAGS_HEAP_START + (n))
-#define DUK_HEAPHDR_USER_FLAG_NUMBER(n)  (DUK_HEAPHDR_FLAGS_USER_START + (n))
-#define DUK_HEAPHDR_HEAP_FLAG(n)         (1UL << (DUK_HEAPHDR_FLAGS_HEAP_START + (n)))
-#define DUK_HEAPHDR_USER_FLAG(n)         (1UL << (DUK_HEAPHDR_FLAGS_USER_START + (n)))
-
-#define DUK_HEAPHDR_FLAG_REACHABLE       DUK_HEAPHDR_HEAP_FLAG(0)  /* mark-and-sweep: reachable */
-#define DUK_HEAPHDR_FLAG_TEMPROOT        DUK_HEAPHDR_HEAP_FLAG(1)  /* mark-and-sweep: children not processed */
-#define DUK_HEAPHDR_FLAG_FINALIZABLE     DUK_HEAPHDR_HEAP_FLAG(2)  /* mark-and-sweep: finalizable (on current pass) */
-#define DUK_HEAPHDR_FLAG_FINALIZED       DUK_HEAPHDR_HEAP_FLAG(3)  /* mark-and-sweep: finalized (on previous pass) */
-#define DUK_HEAPHDR_FLAG_READONLY        DUK_HEAPHDR_HEAP_FLAG(4)  /* read-only object, in code section */
-
-#define DUK_HTYPE_MIN                    0
-#define DUK_HTYPE_STRING                 0
-#define DUK_HTYPE_OBJECT                 1
-#define DUK_HTYPE_BUFFER                 2
-#define DUK_HTYPE_MAX                    2
+/* 2 bits for heap type */
+#define DUK_HEAPHDR_FLAGS_HEAP_START 2 /* 5 heap flags */
+#define DUK_HEAPHDR_FLAGS_USER_START 7 /* 25 user flags */
+
+#define DUK_HEAPHDR_HEAP_FLAG_NUMBER(n) (DUK_HEAPHDR_FLAGS_HEAP_START + (n))
+#define DUK_HEAPHDR_USER_FLAG_NUMBER(n) (DUK_HEAPHDR_FLAGS_USER_START + (n))
+#define DUK_HEAPHDR_HEAP_FLAG(n)        (1UL << (DUK_HEAPHDR_FLAGS_HEAP_START + (n)))
+#define DUK_HEAPHDR_USER_FLAG(n)        (1UL << (DUK_HEAPHDR_FLAGS_USER_START + (n)))
+
+#define DUK_HEAPHDR_FLAG_REACHABLE   DUK_HEAPHDR_HEAP_FLAG(0) /* mark-and-sweep: reachable */
+#define DUK_HEAPHDR_FLAG_TEMPROOT    DUK_HEAPHDR_HEAP_FLAG(1) /* mark-and-sweep: children not processed */
+#define DUK_HEAPHDR_FLAG_FINALIZABLE DUK_HEAPHDR_HEAP_FLAG(2) /* mark-and-sweep: finalizable (on current pass) */
+#define DUK_HEAPHDR_FLAG_FINALIZED   DUK_HEAPHDR_HEAP_FLAG(3) /* mark-and-sweep: finalized (on previous pass) */
+#define DUK_HEAPHDR_FLAG_READONLY    DUK_HEAPHDR_HEAP_FLAG(4) /* read-only object, in code section */
+
+#define DUK_HTYPE_MIN    0
+#define DUK_HTYPE_STRING 0
+#define DUK_HTYPE_OBJECT 1
+#define DUK_HTYPE_BUFFER 2
+#define DUK_HTYPE_MAX    2
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HEAPHDR_GET_NEXT(heap,h) \
-	((duk_heaphdr *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->h_next16))
-#define DUK_HEAPHDR_SET_NEXT(heap,h,val)   do { \
+#define DUK_HEAPHDR_GET_NEXT(heap, h) ((duk_heaphdr *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->h_next16))
+#define DUK_HEAPHDR_SET_NEXT(heap, h, val) \
+	do { \
 		(h)->h_next16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) val); \
 	} while (0)
 #else
-#define DUK_HEAPHDR_GET_NEXT(heap,h)  ((h)->h_next)
-#define DUK_HEAPHDR_SET_NEXT(heap,h,val)   do { \
+#define DUK_HEAPHDR_GET_NEXT(heap, h) ((h)->h_next)
+#define DUK_HEAPHDR_SET_NEXT(heap, h, val) \
+	do { \
 		(h)->h_next = (val); \
 	} while (0)
 #endif
 
 #if defined(DUK_USE_DOUBLE_LINKED_HEAP)
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HEAPHDR_GET_PREV(heap,h) \
-	((duk_heaphdr *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->h_prev16))
-#define DUK_HEAPHDR_SET_PREV(heap,h,val)   do { \
+#define DUK_HEAPHDR_GET_PREV(heap, h) ((duk_heaphdr *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->h_prev16))
+#define DUK_HEAPHDR_SET_PREV(heap, h, val) \
+	do { \
 		(h)->h_prev16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (val)); \
 	} while (0)
 #else
-#define DUK_HEAPHDR_GET_PREV(heap,h)       ((h)->h_prev)
-#define DUK_HEAPHDR_SET_PREV(heap,h,val)   do { \
+#define DUK_HEAPHDR_GET_PREV(heap, h) ((h)->h_prev)
+#define DUK_HEAPHDR_SET_PREV(heap, h, val) \
+	do { \
 		(h)->h_prev = (val); \
 	} while (0)
 #endif
 #endif
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
-#define DUK_HEAPHDR_GET_REFCOUNT(h)   ((h)->h_refcount)
-#define DUK_HEAPHDR_SET_REFCOUNT(h,val)  do { \
+#define DUK_HEAPHDR_GET_REFCOUNT(h) ((h)->h_refcount)
+#define DUK_HEAPHDR_SET_REFCOUNT(h, val) \
+	do { \
 		(h)->h_refcount = (val); \
-		DUK_ASSERT((h)->h_refcount == (val));  /* No truncation. */ \
+		DUK_ASSERT((h)->h_refcount == (val)); /* No truncation. */ \
 	} while (0)
-#define DUK_HEAPHDR_PREINC_REFCOUNT(h)  (++(h)->h_refcount)  /* result: updated refcount */
-#define DUK_HEAPHDR_PREDEC_REFCOUNT(h)  (--(h)->h_refcount)  /* result: updated refcount */
+#define DUK_HEAPHDR_PREINC_REFCOUNT(h) (++(h)->h_refcount) /* result: updated refcount */
+#define DUK_HEAPHDR_PREDEC_REFCOUNT(h) (--(h)->h_refcount) /* result: updated refcount */
 #else
 /* refcount macros not defined without refcounting, caller must #if defined() now */
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /*
  *  Note: type is treated as a field separate from flags, so some masking is
  *  involved in the macros below.
  */
 
-#define DUK_HEAPHDR_GET_FLAGS_RAW(h)  ((h)->h_flags)
-#define DUK_HEAPHDR_SET_FLAGS_RAW(h,val)  do { \
-		(h)->h_flags = (val); } \
+#define DUK_HEAPHDR_GET_FLAGS_RAW(h) ((h)->h_flags)
+#define DUK_HEAPHDR_SET_FLAGS_RAW(h, val) \
+	do { \
+		(h)->h_flags = (val); \
+	} \
 	}
-#define DUK_HEAPHDR_GET_FLAGS(h)      ((h)->h_flags & DUK_HEAPHDR_FLAGS_FLAG_MASK)
-#define DUK_HEAPHDR_SET_FLAGS(h,val)  do { \
+#define DUK_HEAPHDR_GET_FLAGS(h) ((h)->h_flags & DUK_HEAPHDR_FLAGS_FLAG_MASK)
+#define DUK_HEAPHDR_SET_FLAGS(h, val) \
+	do { \
 		(h)->h_flags = ((h)->h_flags & ~(DUK_HEAPHDR_FLAGS_FLAG_MASK)) | (val); \
 	} while (0)
-#define DUK_HEAPHDR_GET_TYPE(h)       ((h)->h_flags & DUK_HEAPHDR_FLAGS_TYPE_MASK)
-#define DUK_HEAPHDR_SET_TYPE(h,val)   do { \
+#define DUK_HEAPHDR_GET_TYPE(h) ((h)->h_flags & DUK_HEAPHDR_FLAGS_TYPE_MASK)
+#define DUK_HEAPHDR_SET_TYPE(h, val) \
+	do { \
 		(h)->h_flags = ((h)->h_flags & ~(DUK_HEAPHDR_FLAGS_TYPE_MASK)) | (val); \
 	} while (0)
 
 /* Comparison for type >= DUK_HTYPE_MIN skipped; because DUK_HTYPE_MIN is zero
  * and the comparison is unsigned, it's always true and generates warnings.
  */
-#define DUK_HEAPHDR_HTYPE_VALID(h)    ( \
-	DUK_HEAPHDR_GET_TYPE((h)) <= DUK_HTYPE_MAX \
-	)
+#define DUK_HEAPHDR_HTYPE_VALID(h) (DUK_HEAPHDR_GET_TYPE((h)) <= DUK_HTYPE_MAX)
 
-#define DUK_HEAPHDR_SET_TYPE_AND_FLAGS(h,tval,fval)  do { \
-		(h)->h_flags = ((tval) & DUK_HEAPHDR_FLAGS_TYPE_MASK) | \
-		               ((fval) & DUK_HEAPHDR_FLAGS_FLAG_MASK); \
+#define DUK_HEAPHDR_SET_TYPE_AND_FLAGS(h, tval, fval) \
+	do { \
+		(h)->h_flags = ((tval) &DUK_HEAPHDR_FLAGS_TYPE_MASK) | ((fval) &DUK_HEAPHDR_FLAGS_FLAG_MASK); \
 	} while (0)
 
-#define DUK_HEAPHDR_SET_FLAG_BITS(h,bits)  do { \
+#define DUK_HEAPHDR_SET_FLAG_BITS(h, bits) \
+	do { \
 		DUK_ASSERT(((bits) & ~(DUK_HEAPHDR_FLAGS_FLAG_MASK)) == 0); \
 		(h)->h_flags |= (bits); \
 	} while (0)
 
-#define DUK_HEAPHDR_CLEAR_FLAG_BITS(h,bits)  do { \
+#define DUK_HEAPHDR_CLEAR_FLAG_BITS(h, bits) \
+	do { \
 		DUK_ASSERT(((bits) & ~(DUK_HEAPHDR_FLAGS_FLAG_MASK)) == 0); \
 		(h)->h_flags &= ~((bits)); \
 	} while (0)
 
-#define DUK_HEAPHDR_CHECK_FLAG_BITS(h,bits)  (((h)->h_flags & (bits)) != 0)
+#define DUK_HEAPHDR_CHECK_FLAG_BITS(h, bits) (((h)->h_flags & (bits)) != 0)
 
-#define DUK_HEAPHDR_SET_REACHABLE(h)      DUK_HEAPHDR_SET_FLAG_BITS((h),DUK_HEAPHDR_FLAG_REACHABLE)
-#define DUK_HEAPHDR_CLEAR_REACHABLE(h)    DUK_HEAPHDR_CLEAR_FLAG_BITS((h),DUK_HEAPHDR_FLAG_REACHABLE)
-#define DUK_HEAPHDR_HAS_REACHABLE(h)      DUK_HEAPHDR_CHECK_FLAG_BITS((h),DUK_HEAPHDR_FLAG_REACHABLE)
-
-#define DUK_HEAPHDR_SET_TEMPROOT(h)       DUK_HEAPHDR_SET_FLAG_BITS((h),DUK_HEAPHDR_FLAG_TEMPROOT)
-#define DUK_HEAPHDR_CLEAR_TEMPROOT(h)     DUK_HEAPHDR_CLEAR_FLAG_BITS((h),DUK_HEAPHDR_FLAG_TEMPROOT)
-#define DUK_HEAPHDR_HAS_TEMPROOT(h)       DUK_HEAPHDR_CHECK_FLAG_BITS((h),DUK_HEAPHDR_FLAG_TEMPROOT)
-
-#define DUK_HEAPHDR_SET_FINALIZABLE(h)    DUK_HEAPHDR_SET_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZABLE)
-#define DUK_HEAPHDR_CLEAR_FINALIZABLE(h)  DUK_HEAPHDR_CLEAR_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZABLE)
-#define DUK_HEAPHDR_HAS_FINALIZABLE(h)    DUK_HEAPHDR_CHECK_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZABLE)
-
-#define DUK_HEAPHDR_SET_FINALIZED(h)      DUK_HEAPHDR_SET_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZED)
-#define DUK_HEAPHDR_CLEAR_FINALIZED(h)    DUK_HEAPHDR_CLEAR_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZED)
-#define DUK_HEAPHDR_HAS_FINALIZED(h)      DUK_HEAPHDR_CHECK_FLAG_BITS((h),DUK_HEAPHDR_FLAG_FINALIZED)
-
-#define DUK_HEAPHDR_SET_READONLY(h)       DUK_HEAPHDR_SET_FLAG_BITS((h),DUK_HEAPHDR_FLAG_READONLY)
-#define DUK_HEAPHDR_CLEAR_READONLY(h)     DUK_HEAPHDR_CLEAR_FLAG_BITS((h),DUK_HEAPHDR_FLAG_READONLY)
-#define DUK_HEAPHDR_HAS_READONLY(h)       DUK_HEAPHDR_CHECK_FLAG_BITS((h),DUK_HEAPHDR_FLAG_READONLY)
+#define DUK_HEAPHDR_SET_REACHABLE(h)   DUK_HEAPHDR_SET_FLAG_BITS((h), DUK_HEAPHDR_FLAG_REACHABLE)
+#define DUK_HEAPHDR_CLEAR_REACHABLE(h) DUK_HEAPHDR_CLEAR_FLAG_BITS((h), DUK_HEAPHDR_FLAG_REACHABLE)
+#define DUK_HEAPHDR_HAS_REACHABLE(h)   DUK_HEAPHDR_CHECK_FLAG_BITS((h), DUK_HEAPHDR_FLAG_REACHABLE)
+
+#define DUK_HEAPHDR_SET_TEMPROOT(h)   DUK_HEAPHDR_SET_FLAG_BITS((h), DUK_HEAPHDR_FLAG_TEMPROOT)
+#define DUK_HEAPHDR_CLEAR_TEMPROOT(h) DUK_HEAPHDR_CLEAR_FLAG_BITS((h), DUK_HEAPHDR_FLAG_TEMPROOT)
+#define DUK_HEAPHDR_HAS_TEMPROOT(h)   DUK_HEAPHDR_CHECK_FLAG_BITS((h), DUK_HEAPHDR_FLAG_TEMPROOT)
+
+#define DUK_HEAPHDR_SET_FINALIZABLE(h)   DUK_HEAPHDR_SET_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZABLE)
+#define DUK_HEAPHDR_CLEAR_FINALIZABLE(h) DUK_HEAPHDR_CLEAR_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZABLE)
+#define DUK_HEAPHDR_HAS_FINALIZABLE(h)   DUK_HEAPHDR_CHECK_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZABLE)
+
+#define DUK_HEAPHDR_SET_FINALIZED(h)   DUK_HEAPHDR_SET_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZED)
+#define DUK_HEAPHDR_CLEAR_FINALIZED(h) DUK_HEAPHDR_CLEAR_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZED)
+#define DUK_HEAPHDR_HAS_FINALIZED(h)   DUK_HEAPHDR_CHECK_FLAG_BITS((h), DUK_HEAPHDR_FLAG_FINALIZED)
+
+#define DUK_HEAPHDR_SET_READONLY(h)   DUK_HEAPHDR_SET_FLAG_BITS((h), DUK_HEAPHDR_FLAG_READONLY)
+#define DUK_HEAPHDR_CLEAR_READONLY(h) DUK_HEAPHDR_CLEAR_FLAG_BITS((h), DUK_HEAPHDR_FLAG_READONLY)
+#define DUK_HEAPHDR_HAS_READONLY(h)   DUK_HEAPHDR_CHECK_FLAG_BITS((h), DUK_HEAPHDR_FLAG_READONLY)
 
 /* get or set a range of flags; m=first bit number, n=number of bits */
-#define DUK_HEAPHDR_GET_FLAG_RANGE(h,m,n)  (((h)->h_flags >> (m)) & ((1UL << (n)) - 1UL))
+#define DUK_HEAPHDR_GET_FLAG_RANGE(h, m, n) (((h)->h_flags >> (m)) & ((1UL << (n)) - 1UL))
 
-#define DUK_HEAPHDR_SET_FLAG_RANGE(h,m,n,v)  do { \
-		(h)->h_flags = \
-			((h)->h_flags & (~(((1UL << (n)) - 1UL) << (m)))) \
-			| ((v) << (m)); \
+#define DUK_HEAPHDR_SET_FLAG_RANGE(h, m, n, v) \
+	do { \
+		(h)->h_flags = ((h)->h_flags & (~(((1UL << (n)) - 1UL) << (m)))) | ((v) << (m)); \
 	} while (0)
 
 /* init pointer fields to null */
 #if defined(DUK_USE_DOUBLE_LINKED_HEAP)
-#define DUK_HEAPHDR_INIT_NULLS(h)       do { \
+#define DUK_HEAPHDR_INIT_NULLS(h) \
+	do { \
 		DUK_HEAPHDR_SET_NEXT((h), (void *) NULL); \
 		DUK_HEAPHDR_SET_PREV((h), (void *) NULL); \
 	} while (0)
 #else
-#define DUK_HEAPHDR_INIT_NULLS(h)       do { \
+#define DUK_HEAPHDR_INIT_NULLS(h) \
+	do { \
 		DUK_HEAPHDR_SET_NEXT((h), (void *) NULL); \
 	} while (0)
 #endif
 
-#define DUK_HEAPHDR_STRING_INIT_NULLS(h)  do { \
+#define DUK_HEAPHDR_STRING_INIT_NULLS(h) \
+	do { \
 		(h)->h_next = NULL; \
 	} while (0)
 
 /*
  *  Type tests
  */
 
@@ -4757,22 +4863,32 @@
 /* Check that prev/next links are consistent: if e.g. h->prev is != NULL,
  * h->prev->next should point back to h.
  */
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_heaphdr_assert_valid_subclassed(duk_heaphdr *h);
 DUK_INTERNAL_DECL void duk_heaphdr_assert_links(duk_heap *heap, duk_heaphdr *h);
 DUK_INTERNAL_DECL void duk_heaphdr_assert_valid(duk_heaphdr *h);
-#define DUK_HEAPHDR_ASSERT_LINKS(heap,h)  do { duk_heaphdr_assert_links((heap), (h)); } while (0)
-#define DUK_HEAPHDR_ASSERT_VALID(h)  do { duk_heaphdr_assert_valid((h)); } while (0)
+#define DUK_HEAPHDR_ASSERT_LINKS(heap, h) \
+	do { \
+		duk_heaphdr_assert_links((heap), (h)); \
+	} while (0)
+#define DUK_HEAPHDR_ASSERT_VALID(h) \
+	do { \
+		duk_heaphdr_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HEAPHDR_ASSERT_LINKS(heap,h)  do {} while (0)
-#define DUK_HEAPHDR_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HEAPHDR_ASSERT_LINKS(heap, h) \
+	do { \
+	} while (0)
+#define DUK_HEAPHDR_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
-#endif  /* DUK_HEAPHDR_H_INCLUDED */
+#endif /* DUK_HEAPHDR_H_INCLUDED */
 /* #include duk_refcount.h */
 #line 1 "duk_refcount.h"
 /*
  *  Reference counting helper macros.  The macros take a thread argument
  *  and must thus always be executed in a specific thread context.  The
  *  thread argument is not really needed anymore: DECREF can operate with
  *  a heap pointer only, and INCREF needs neither.
@@ -4786,673 +4902,964 @@
 #if defined(DUK_USE_ROM_OBJECTS)
 /* With ROM objects "needs refcount update" is true when the value is
  * heap allocated and is not a ROM object.
  */
 /* XXX: double evaluation for 'tv' argument. */
 #define DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv) \
 	(DUK_TVAL_IS_HEAP_ALLOCATED((tv)) && !DUK_HEAPHDR_HAS_READONLY(DUK_TVAL_GET_HEAPHDR((tv))))
-#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h)  (!DUK_HEAPHDR_HAS_READONLY((h)))
-#else  /* DUK_USE_ROM_OBJECTS */
+#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h) (!DUK_HEAPHDR_HAS_READONLY((h)))
+#else /* DUK_USE_ROM_OBJECTS */
 /* Without ROM objects "needs refcount update" == is heap allocated. */
-#define DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv)    DUK_TVAL_IS_HEAP_ALLOCATED((tv))
-#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h)  1
-#endif  /* DUK_USE_ROM_OBJECTS */
+#define DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv)   DUK_TVAL_IS_HEAP_ALLOCATED((tv))
+#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h) 1
+#endif /* DUK_USE_ROM_OBJECTS */
 
 /* Fast variants, inline refcount operations except for refzero handling.
  * Can be used explicitly when speed is always more important than size.
  * For a good compiler and a single file build, these are basically the
  * same as a forced inline.
  */
-#define DUK_TVAL_INCREF_FAST(thr,tv) do { \
+#define DUK_TVAL_INCREF_FAST(thr, tv) \
+	do { \
 		duk_tval *duk__tv = (tv); \
 		DUK_ASSERT(duk__tv != NULL); \
 		if (DUK_TVAL_NEEDS_REFCOUNT_UPDATE(duk__tv)) { \
 			duk_heaphdr *duk__h = DUK_TVAL_GET_HEAPHDR(duk__tv); \
 			DUK_ASSERT(duk__h != NULL); \
 			DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(duk__h)); \
 			DUK_HEAPHDR_PREINC_REFCOUNT(duk__h); \
-			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) != 0);  /* No wrapping. */ \
+			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) != 0); /* No wrapping. */ \
 		} \
 	} while (0)
-#define DUK_TVAL_DECREF_FAST(thr,tv) do { \
+#define DUK_TVAL_DECREF_FAST(thr, tv) \
+	do { \
 		duk_tval *duk__tv = (tv); \
 		DUK_ASSERT(duk__tv != NULL); \
 		if (DUK_TVAL_NEEDS_REFCOUNT_UPDATE(duk__tv)) { \
 			duk_heaphdr *duk__h = DUK_TVAL_GET_HEAPHDR(duk__tv); \
 			DUK_ASSERT(duk__h != NULL); \
 			DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(duk__h)); \
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) > 0); \
 			if (DUK_HEAPHDR_PREDEC_REFCOUNT(duk__h) == 0) { \
 				duk_heaphdr_refzero((thr), duk__h); \
 			} \
 		} \
 	} while (0)
-#define DUK_TVAL_DECREF_NORZ_FAST(thr,tv) do { \
+#define DUK_TVAL_DECREF_NORZ_FAST(thr, tv) \
+	do { \
 		duk_tval *duk__tv = (tv); \
 		DUK_ASSERT(duk__tv != NULL); \
 		if (DUK_TVAL_NEEDS_REFCOUNT_UPDATE(duk__tv)) { \
 			duk_heaphdr *duk__h = DUK_TVAL_GET_HEAPHDR(duk__tv); \
 			DUK_ASSERT(duk__h != NULL); \
 			DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(duk__h)); \
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) > 0); \
 			if (DUK_HEAPHDR_PREDEC_REFCOUNT(duk__h) == 0) { \
 				duk_heaphdr_refzero_norz((thr), duk__h); \
 			} \
 		} \
 	} while (0)
-#define DUK_HEAPHDR_INCREF_FAST(thr,h) do { \
+#define DUK_HEAPHDR_INCREF_FAST(thr, h) \
+	do { \
 		duk_heaphdr *duk__h = (duk_heaphdr *) (h); \
 		DUK_ASSERT(duk__h != NULL); \
 		DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(duk__h)); \
 		if (DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(duk__h)) { \
 			DUK_HEAPHDR_PREINC_REFCOUNT(duk__h); \
-			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) != 0);  /* No wrapping. */ \
+			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) != 0); /* No wrapping. */ \
 		} \
 	} while (0)
-#define DUK_HEAPHDR_DECREF_FAST_RAW(thr,h,rzcall,rzcast) do { \
+#define DUK_HEAPHDR_DECREF_FAST_RAW(thr, h, rzcall, rzcast) \
+	do { \
 		duk_heaphdr *duk__h = (duk_heaphdr *) (h); \
 		DUK_ASSERT(duk__h != NULL); \
 		DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(duk__h)); \
 		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(duk__h) > 0); \
 		if (DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(duk__h)) { \
 			if (DUK_HEAPHDR_PREDEC_REFCOUNT(duk__h) == 0) { \
 				(rzcall)((thr), (rzcast) duk__h); \
 			} \
 		} \
 	} while (0)
-#define DUK_HEAPHDR_DECREF_FAST(thr,h) \
-	DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_heaphdr_refzero,duk_heaphdr *)
-#define DUK_HEAPHDR_DECREF_NORZ_FAST(thr,h) \
-	DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_heaphdr_refzero_norz,duk_heaphdr *)
+#define DUK_HEAPHDR_DECREF_FAST(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_heaphdr_refzero, duk_heaphdr *)
+#define DUK_HEAPHDR_DECREF_NORZ_FAST(thr, h) DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_heaphdr_refzero_norz, duk_heaphdr *)
 
 /* Slow variants, call to a helper to reduce code size.
  * Can be used explicitly when size is always more important than speed.
  */
-#define DUK_TVAL_INCREF_SLOW(thr,tv)         do { duk_tval_incref((tv)); } while (0)
-#define DUK_TVAL_DECREF_SLOW(thr,tv)         do { duk_tval_decref((thr), (tv)); } while (0)
-#define DUK_TVAL_DECREF_NORZ_SLOW(thr,tv)    do { duk_tval_decref_norz((thr), (tv)); } while (0)
-#define DUK_HEAPHDR_INCREF_SLOW(thr,h)       do { duk_heaphdr_incref((duk_heaphdr *) (h)); } while (0)
-#define DUK_HEAPHDR_DECREF_SLOW(thr,h)       do { duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HEAPHDR_DECREF_NORZ_SLOW(thr,h)  do { duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HSTRING_INCREF_SLOW(thr,h)       do { duk_heaphdr_incref((duk_heaphdr *) (h)); } while (0)
-#define DUK_HSTRING_DECREF_SLOW(thr,h)       do { duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HSTRING_DECREF_NORZ_SLOW(thr,h)  do { duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HBUFFER_INCREF_SLOW(thr,h)       do { duk_heaphdr_incref((duk_heaphdr *) (h)); } while (0)
-#define DUK_HBUFFER_DECREF_SLOW(thr,h)       do { duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HBUFFER_DECREF_NORZ_SLOW(thr,h)  do { duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HOBJECT_INCREF_SLOW(thr,h)       do { duk_heaphdr_incref((duk_heaphdr *) (h)); } while (0)
-#define DUK_HOBJECT_DECREF_SLOW(thr,h)       do { duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); } while (0)
-#define DUK_HOBJECT_DECREF_NORZ_SLOW(thr,h)  do { duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); } while (0)
+#define DUK_TVAL_INCREF_SLOW(thr, tv) \
+	do { \
+		duk_tval_incref((tv)); \
+	} while (0)
+#define DUK_TVAL_DECREF_SLOW(thr, tv) \
+	do { \
+		duk_tval_decref((thr), (tv)); \
+	} while (0)
+#define DUK_TVAL_DECREF_NORZ_SLOW(thr, tv) \
+	do { \
+		duk_tval_decref_norz((thr), (tv)); \
+	} while (0)
+#define DUK_HEAPHDR_INCREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_incref((duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HEAPHDR_DECREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HEAPHDR_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HSTRING_INCREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_incref((duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HSTRING_DECREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HSTRING_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HBUFFER_INCREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_incref((duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HBUFFER_DECREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HBUFFER_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HOBJECT_INCREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_incref((duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HOBJECT_DECREF_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref((thr), (duk_heaphdr *) (h)); \
+	} while (0)
+#define DUK_HOBJECT_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+		duk_heaphdr_decref_norz((thr), (duk_heaphdr *) (h)); \
+	} while (0)
 
 /* Default variants.  Selection depends on speed/size preference.
  * Concretely: with gcc 4.8.1 -Os x64 the difference in final binary
  * is about +1kB for _FAST variants.
  */
 #if defined(DUK_USE_FAST_REFCOUNT_DEFAULT)
 /* XXX: It would be nice to specialize for specific duk_hobject subtypes
  * but current refzero queue handling prevents that.
  */
-#define DUK_TVAL_INCREF(thr,tv)                DUK_TVAL_INCREF_FAST((thr),(tv))
-#define DUK_TVAL_DECREF(thr,tv)                DUK_TVAL_DECREF_FAST((thr),(tv))
-#define DUK_TVAL_DECREF_NORZ(thr,tv)           DUK_TVAL_DECREF_NORZ_FAST((thr),(tv))
-#define DUK_HEAPHDR_INCREF(thr,h)              DUK_HEAPHDR_INCREF_FAST((thr),(h))
-#define DUK_HEAPHDR_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_heaphdr_refzero,duk_heaphdr *)
-#define DUK_HEAPHDR_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_heaphdr_refzero_norz,duk_heaphdr *)
-#define DUK_HSTRING_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HSTRING_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hstring_refzero,duk_hstring *)
-#define DUK_HSTRING_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hstring_refzero,duk_hstring *)  /* no 'norz' variant */
-#define DUK_HOBJECT_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HOBJECT_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero,duk_hobject *)
-#define DUK_HOBJECT_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero_norz,duk_hobject *)
-#define DUK_HBUFFER_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HBUFFER_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hbuffer_refzero,duk_hbuffer *)
-#define DUK_HBUFFER_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hbuffer_refzero,duk_hbuffer *)  /* no 'norz' variant */
-#define DUK_HCOMPFUNC_INCREF(thr,h)            DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HCOMPFUNC_DECREF(thr,h)            DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero,duk_hobject *)
-#define DUK_HCOMPFUNC_DECREF_NORZ(thr,h)       DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero_norz,duk_hobject *)
-#define DUK_HNATFUNC_INCREF(thr,h)             DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HNATFUNC_DECREF(thr,h)             DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero,duk_hobject *)
-#define DUK_HNATFUNC_DECREF_NORZ(thr,h)        DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero_norz,duk_hobject *)
-#define DUK_HBUFOBJ_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HBUFOBJ_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero,duk_hobject *)
-#define DUK_HBUFOBJ_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero_norz,duk_hobject *)
-#define DUK_HTHREAD_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HTHREAD_DECREF(thr,h)              DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero,duk_hobject *)
-#define DUK_HTHREAD_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_FAST_RAW((thr),(h),duk_hobject_refzero_norz,duk_hobject *)
-#else
-#define DUK_TVAL_INCREF(thr,tv)                DUK_TVAL_INCREF_SLOW((thr),(tv))
-#define DUK_TVAL_DECREF(thr,tv)                DUK_TVAL_DECREF_SLOW((thr),(tv))
-#define DUK_TVAL_DECREF_NORZ(thr,tv)           DUK_TVAL_DECREF_NORZ_SLOW((thr),(tv))
-#define DUK_HEAPHDR_INCREF(thr,h)              DUK_HEAPHDR_INCREF_SLOW((thr),(h))
-#define DUK_HEAPHDR_DECREF(thr,h)              DUK_HEAPHDR_DECREF_SLOW((thr),(h))
-#define DUK_HEAPHDR_DECREF_NORZ(thr,h)         DUK_HEAPHDR_DECREF_NORZ_SLOW((thr),(h))
-#define DUK_HSTRING_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HSTRING_DECREF(thr,h)              DUK_HSTRING_DECREF_SLOW((thr),(h))
-#define DUK_HSTRING_DECREF_NORZ(thr,h)         DUK_HSTRING_DECREF_NORZ_SLOW((thr),(h))
-#define DUK_HOBJECT_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HOBJECT_DECREF(thr,h)              DUK_HOBJECT_DECREF_SLOW((thr),(h))
-#define DUK_HOBJECT_DECREF_NORZ(thr,h)         DUK_HOBJECT_DECREF_NORZ_SLOW((thr),(h))
-#define DUK_HBUFFER_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) (h))
-#define DUK_HBUFFER_DECREF(thr,h)              DUK_HBUFFER_DECREF_SLOW((thr),(h))
-#define DUK_HBUFFER_DECREF_NORZ(thr,h)         DUK_HBUFFER_DECREF_NORZ_SLOW((thr),(h))
-#define DUK_HCOMPFUNC_INCREF(thr,h)            DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HCOMPFUNC_DECREF(thr,h)            DUK_HOBJECT_DECREF_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HCOMPFUNC_DECREF_NORZ(thr,h)       DUK_HOBJECT_DECREF_NORZ_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HNATFUNC_INCREF(thr,h)             DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HNATFUNC_DECREF(thr,h)             DUK_HOBJECT_DECREF_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HNATFUNC_DECREF_NORZ(thr,h)        DUK_HOBJECT_DECREF_NORZ_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HBUFOBJ_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HBUFOBJ_DECREF(thr,h)              DUK_HOBJECT_DECREF_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HBUFOB_DECREF_NORZ(thr,h)          DUK_HOBJECT_DECREF_NORZ_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HTHREAD_INCREF(thr,h)              DUK_HEAPHDR_INCREF((thr),(duk_heaphdr *) &(h)->obj)
-#define DUK_HTHREAD_DECREF(thr,h)              DUK_HOBJECT_DECREF_SLOW((thr),(duk_hobject *) &(h)->obj)
-#define DUK_HTHREAD_DECREF_NORZ(thr,h)         DUK_HOBJECT_DECREF_NORZ_SLOW((thr),(duk_hobject *) &(h)->obj)
+#define DUK_TVAL_INCREF(thr, tv)        DUK_TVAL_INCREF_FAST((thr), (tv))
+#define DUK_TVAL_DECREF(thr, tv)        DUK_TVAL_DECREF_FAST((thr), (tv))
+#define DUK_TVAL_DECREF_NORZ(thr, tv)   DUK_TVAL_DECREF_NORZ_FAST((thr), (tv))
+#define DUK_HEAPHDR_INCREF(thr, h)      DUK_HEAPHDR_INCREF_FAST((thr), (h))
+#define DUK_HEAPHDR_DECREF(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_heaphdr_refzero, duk_heaphdr *)
+#define DUK_HEAPHDR_DECREF_NORZ(thr, h) DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_heaphdr_refzero_norz, duk_heaphdr *)
+#define DUK_HSTRING_INCREF(thr, h)      DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HSTRING_DECREF(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hstring_refzero, duk_hstring *)
+#define DUK_HSTRING_DECREF_NORZ(thr, h) \
+	DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hstring_refzero, duk_hstring *) /* no 'norz' variant */
+#define DUK_HOBJECT_INCREF(thr, h)      DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HOBJECT_DECREF(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero, duk_hobject *)
+#define DUK_HOBJECT_DECREF_NORZ(thr, h) DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero_norz, duk_hobject *)
+#define DUK_HBUFFER_INCREF(thr, h)      DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HBUFFER_DECREF(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hbuffer_refzero, duk_hbuffer *)
+#define DUK_HBUFFER_DECREF_NORZ(thr, h) \
+	DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hbuffer_refzero, duk_hbuffer *) /* no 'norz' variant */
+#define DUK_HCOMPFUNC_INCREF(thr, h)      DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HCOMPFUNC_DECREF(thr, h)      DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero, duk_hobject *)
+#define DUK_HCOMPFUNC_DECREF_NORZ(thr, h) DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero_norz, duk_hobject *)
+#define DUK_HNATFUNC_INCREF(thr, h)       DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HNATFUNC_DECREF(thr, h)       DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero, duk_hobject *)
+#define DUK_HNATFUNC_DECREF_NORZ(thr, h)  DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero_norz, duk_hobject *)
+#define DUK_HBUFOBJ_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HBUFOBJ_DECREF(thr, h)        DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero, duk_hobject *)
+#define DUK_HBUFOBJ_DECREF_NORZ(thr, h)   DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero_norz, duk_hobject *)
+#define DUK_HTHREAD_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HTHREAD_DECREF(thr, h)        DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero, duk_hobject *)
+#define DUK_HTHREAD_DECREF_NORZ(thr, h)   DUK_HEAPHDR_DECREF_FAST_RAW((thr), (h), duk_hobject_refzero_norz, duk_hobject *)
+#else
+#define DUK_TVAL_INCREF(thr, tv)          DUK_TVAL_INCREF_SLOW((thr), (tv))
+#define DUK_TVAL_DECREF(thr, tv)          DUK_TVAL_DECREF_SLOW((thr), (tv))
+#define DUK_TVAL_DECREF_NORZ(thr, tv)     DUK_TVAL_DECREF_NORZ_SLOW((thr), (tv))
+#define DUK_HEAPHDR_INCREF(thr, h)        DUK_HEAPHDR_INCREF_SLOW((thr), (h))
+#define DUK_HEAPHDR_DECREF(thr, h)        DUK_HEAPHDR_DECREF_SLOW((thr), (h))
+#define DUK_HEAPHDR_DECREF_NORZ(thr, h)   DUK_HEAPHDR_DECREF_NORZ_SLOW((thr), (h))
+#define DUK_HSTRING_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HSTRING_DECREF(thr, h)        DUK_HSTRING_DECREF_SLOW((thr), (h))
+#define DUK_HSTRING_DECREF_NORZ(thr, h)   DUK_HSTRING_DECREF_NORZ_SLOW((thr), (h))
+#define DUK_HOBJECT_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HOBJECT_DECREF(thr, h)        DUK_HOBJECT_DECREF_SLOW((thr), (h))
+#define DUK_HOBJECT_DECREF_NORZ(thr, h)   DUK_HOBJECT_DECREF_NORZ_SLOW((thr), (h))
+#define DUK_HBUFFER_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h))
+#define DUK_HBUFFER_DECREF(thr, h)        DUK_HBUFFER_DECREF_SLOW((thr), (h))
+#define DUK_HBUFFER_DECREF_NORZ(thr, h)   DUK_HBUFFER_DECREF_NORZ_SLOW((thr), (h))
+#define DUK_HCOMPFUNC_INCREF(thr, h)      DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HCOMPFUNC_DECREF(thr, h)      DUK_HOBJECT_DECREF_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HCOMPFUNC_DECREF_NORZ(thr, h) DUK_HOBJECT_DECREF_NORZ_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HNATFUNC_INCREF(thr, h)       DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HNATFUNC_DECREF(thr, h)       DUK_HOBJECT_DECREF_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HNATFUNC_DECREF_NORZ(thr, h)  DUK_HOBJECT_DECREF_NORZ_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HBUFOBJ_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HBUFOBJ_DECREF(thr, h)        DUK_HOBJECT_DECREF_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HBUFOB_DECREF_NORZ(thr, h)    DUK_HOBJECT_DECREF_NORZ_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HTHREAD_INCREF(thr, h)        DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) &(h)->obj)
+#define DUK_HTHREAD_DECREF(thr, h)        DUK_HOBJECT_DECREF_SLOW((thr), (duk_hobject *) &(h)->obj)
+#define DUK_HTHREAD_DECREF_NORZ(thr, h)   DUK_HOBJECT_DECREF_NORZ_SLOW((thr), (duk_hobject *) &(h)->obj)
 #endif
 
 /* Convenience for some situations; the above macros don't allow NULLs
  * for performance reasons.  Macros cover only actually needed cases.
  */
-#define DUK_HEAPHDR_INCREF_ALLOWNULL(thr,h) do { \
+#define DUK_HEAPHDR_INCREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HEAPHDR_INCREF((thr), (duk_heaphdr *) (h)); \
 		} \
 	} while (0)
-#define DUK_HEAPHDR_DECREF_ALLOWNULL(thr,h) do { \
+#define DUK_HEAPHDR_DECREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HEAPHDR_DECREF((thr), (duk_heaphdr *) (h)); \
 		} \
 	} while (0)
-#define DUK_HEAPHDR_DECREF_NORZ_ALLOWNULL(thr,h) do { \
+#define DUK_HEAPHDR_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HEAPHDR_DECREF_NORZ((thr), (duk_heaphdr *) (h)); \
 		} \
 	} while (0)
-#define DUK_HOBJECT_INCREF_ALLOWNULL(thr,h) do { \
+#define DUK_HOBJECT_INCREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HOBJECT_INCREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HOBJECT_DECREF_ALLOWNULL(thr,h) do { \
+#define DUK_HOBJECT_DECREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HOBJECT_DECREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr,h) do { \
+#define DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HOBJECT_DECREF_NORZ((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HBUFFER_INCREF_ALLOWNULL(thr,h) do { \
+#define DUK_HBUFFER_INCREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HBUFFER_INCREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HBUFFER_DECREF_ALLOWNULL(thr,h) do { \
+#define DUK_HBUFFER_DECREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HBUFFER_DECREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HBUFFER_DECREF_NORZ_ALLOWNULL(thr,h) do { \
+#define DUK_HBUFFER_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HBUFFER_DECREF_NORZ((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HTHREAD_INCREF_ALLOWNULL(thr,h) do { \
+#define DUK_HTHREAD_INCREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HTHREAD_INCREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HTHREAD_DECREF_ALLOWNULL(thr,h) do { \
+#define DUK_HTHREAD_DECREF_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HTHREAD_DECREF((thr), (h)); \
 		} \
 	} while (0)
-#define DUK_HTHREAD_DECREF_NORZ_ALLOWNULL(thr,h) do { \
+#define DUK_HTHREAD_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
 		if ((h) != NULL) { \
 			DUK_HTHREAD_DECREF_NORZ((thr), (h)); \
 		} \
 	} while (0)
 
 /* Called after one or more DECREF NORZ calls to handle pending side effects.
  * At present DECREF NORZ does freeing inline but doesn't execute finalizers,
  * so these macros check for pending finalizers and execute them.  The FAST
  * variant is performance critical.
  */
 #if defined(DUK_USE_FINALIZER_SUPPORT)
-#define DUK_REFZERO_CHECK_FAST(thr) do { \
+#define DUK_REFZERO_CHECK_FAST(thr) \
+	do { \
 		duk_refzero_check_fast((thr)); \
 	} while (0)
-#define DUK_REFZERO_CHECK_SLOW(thr) do { \
+#define DUK_REFZERO_CHECK_SLOW(thr) \
+	do { \
 		duk_refzero_check_slow((thr)); \
 	} while (0)
-#else  /* DUK_USE_FINALIZER_SUPPORT */
-#define DUK_REFZERO_CHECK_FAST(thr) do { } while (0)
-#define DUK_REFZERO_CHECK_SLOW(thr) do { } while (0)
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#else /* DUK_USE_FINALIZER_SUPPORT */
+#define DUK_REFZERO_CHECK_FAST(thr) \
+	do { \
+	} while (0)
+#define DUK_REFZERO_CHECK_SLOW(thr) \
+	do { \
+	} while (0)
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 /*
  *  Macros to set a duk_tval and update refcount of the target (decref the
  *  old value and incref the new value if necessary).  This is both performance
  *  and footprint critical; any changes made should be measured for size/speed.
  */
 
-#define DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_UNDEFINED(tv__dst); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_UNDEFINED(tv__dst); \
 		DUK_TVAL_DECREF_NORZ((thr), &tv__tmp); \
 	} while (0)
 
-#define DUK_TVAL_SET_UNUSED_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_UNUSED_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_UNUSED(tv__dst); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_NULL_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NULL_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_NULL(tv__dst); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_BOOLEAN(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_NUMBER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NUMBER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_NUMBER(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
-#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
-#define DUK_TVAL_SET_DOUBLE_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_DOUBLE_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_DOUBLE(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
-#define DUK_TVAL_SET_NAN_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NAN_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_NAN(tv__dst); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_I48_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_I48_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_I48(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
-#define DUK_TVAL_SET_I32_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_I32_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_I32(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
-#define DUK_TVAL_SET_U32_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_U32_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_U32(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 #else
-#define DUK_TVAL_SET_DOUBLE_CAST_UPDREF(thr,tvptr_dst,newval) \
+#define DUK_TVAL_SET_DOUBLE_CAST_UPDREF(thr, tvptr_dst, newval) \
 	DUK_TVAL_SET_DOUBLE_UPDREF((thr), (tvptr_dst), (duk_double_t) (newval))
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
-#define DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0(thr,tvptr_dst,lf_v,lf_fp,lf_flags) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0(thr, tvptr_dst, lf_v, lf_fp, lf_flags) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_LIGHTFUNC(tv__dst, (lf_v), (lf_fp), (lf_flags)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_STRING_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_STRING_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_STRING(tv__dst, (newval)); \
 		DUK_HSTRING_INCREF((thr), (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_OBJECT_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_OBJECT_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_OBJECT(tv__dst, (newval)); \
 		DUK_HOBJECT_INCREF((thr), (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_BUFFER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_BUFFER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_BUFFER(tv__dst, (newval)); \
 		DUK_HBUFFER_INCREF((thr), (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
-#define DUK_TVAL_SET_POINTER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_POINTER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_POINTER(tv__dst, (newval)); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
 /* DUK_TVAL_SET_TVAL_UPDREF() is used a lot in executor, property lookups,
  * etc, so it's very important for performance.  Measure when changing.
  *
  * NOTE: the source and destination duk_tval pointers may be the same, and
  * the macros MUST deal with that correctly.
  */
 
 /* Original idiom used, minimal code size. */
-#define DUK_TVAL_SET_TVAL_UPDREF_ALT0(thr,tvptr_dst,tvptr_src) do { \
-		duk_tval *tv__dst, *tv__src; duk_tval tv__tmp; \
-		tv__dst = (tvptr_dst); tv__src = (tvptr_src); \
+#define DUK_TVAL_SET_TVAL_UPDREF_ALT0(thr, tvptr_dst, tvptr_src) \
+	do { \
+		duk_tval *tv__dst, *tv__src; \
+		duk_tval tv__tmp; \
+		tv__dst = (tvptr_dst); \
+		tv__src = (tvptr_src); \
 		DUK_TVAL_SET_TVAL(&tv__tmp, tv__dst); \
 		DUK_TVAL_SET_TVAL(tv__dst, tv__src); \
 		DUK_TVAL_INCREF((thr), tv__src); \
-		DUK_TVAL_DECREF((thr), &tv__tmp);  /* side effects */ \
+		DUK_TVAL_DECREF((thr), &tv__tmp); /* side effects */ \
 	} while (0)
 
 /* Faster alternative: avoid making a temporary copy of tvptr_dst and use
  * fast incref/decref macros.
  */
-#define DUK_TVAL_SET_TVAL_UPDREF_ALT1(thr,tvptr_dst,tvptr_src) do { \
-		duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; \
-		tv__dst = (tvptr_dst); tv__src = (tvptr_src); \
+#define DUK_TVAL_SET_TVAL_UPDREF_ALT1(thr, tvptr_dst, tvptr_src) \
+	do { \
+		duk_tval *tv__dst, *tv__src; \
+		duk_heaphdr *h__obj; \
+		tv__dst = (tvptr_dst); \
+		tv__src = (tvptr_src); \
 		DUK_TVAL_INCREF_FAST((thr), tv__src); \
 		if (DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv__dst)) { \
 			h__obj = DUK_TVAL_GET_HEAPHDR(tv__dst); \
 			DUK_ASSERT(h__obj != NULL); \
 			DUK_TVAL_SET_TVAL(tv__dst, tv__src); \
-			DUK_HEAPHDR_DECREF_FAST((thr), h__obj);  /* side effects */ \
+			DUK_HEAPHDR_DECREF_FAST((thr), h__obj); /* side effects */ \
 		} else { \
 			DUK_TVAL_SET_TVAL(tv__dst, tv__src); \
 		} \
 	} while (0)
 
 /* XXX: no optimized variants yet */
-#define DUK_TVAL_SET_UNDEFINED_UPDREF         DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
-#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ    DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ_ALT0
-#define DUK_TVAL_SET_UNUSED_UPDREF            DUK_TVAL_SET_UNUSED_UPDREF_ALT0
-#define DUK_TVAL_SET_NULL_UPDREF              DUK_TVAL_SET_NULL_UPDREF_ALT0
-#define DUK_TVAL_SET_BOOLEAN_UPDREF           DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0
-#define DUK_TVAL_SET_NUMBER_UPDREF            DUK_TVAL_SET_NUMBER_UPDREF_ALT0
-#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF    DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0
-#define DUK_TVAL_SET_DOUBLE_UPDREF            DUK_TVAL_SET_DOUBLE_UPDREF_ALT0
-#define DUK_TVAL_SET_NAN_UPDREF               DUK_TVAL_SET_NAN_UPDREF_ALT0
+#define DUK_TVAL_SET_UNDEFINED_UPDREF      DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
+#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ_ALT0
+#define DUK_TVAL_SET_UNUSED_UPDREF         DUK_TVAL_SET_UNUSED_UPDREF_ALT0
+#define DUK_TVAL_SET_NULL_UPDREF           DUK_TVAL_SET_NULL_UPDREF_ALT0
+#define DUK_TVAL_SET_BOOLEAN_UPDREF        DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0
+#define DUK_TVAL_SET_NUMBER_UPDREF         DUK_TVAL_SET_NUMBER_UPDREF_ALT0
+#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0
+#define DUK_TVAL_SET_DOUBLE_UPDREF         DUK_TVAL_SET_DOUBLE_UPDREF_ALT0
+#define DUK_TVAL_SET_NAN_UPDREF            DUK_TVAL_SET_NAN_UPDREF_ALT0
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_I48_UPDREF               DUK_TVAL_SET_I48_UPDREF_ALT0
-#define DUK_TVAL_SET_I32_UPDREF               DUK_TVAL_SET_I32_UPDREF_ALT0
-#define DUK_TVAL_SET_U32_UPDREF               DUK_TVAL_SET_U32_UPDREF_ALT0
-#else
-#define DUK_TVAL_SET_I48_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF  /* XXX: fast int-to-double */
-#define DUK_TVAL_SET_I32_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF
-#define DUK_TVAL_SET_U32_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF
-#endif  /* DUK_USE_FASTINT */
-#define DUK_TVAL_SET_FASTINT_UPDREF           DUK_TVAL_SET_I48_UPDREF  /* convenience */
-#define DUK_TVAL_SET_LIGHTFUNC_UPDREF         DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0
-#define DUK_TVAL_SET_STRING_UPDREF            DUK_TVAL_SET_STRING_UPDREF_ALT0
-#define DUK_TVAL_SET_OBJECT_UPDREF            DUK_TVAL_SET_OBJECT_UPDREF_ALT0
-#define DUK_TVAL_SET_BUFFER_UPDREF            DUK_TVAL_SET_BUFFER_UPDREF_ALT0
-#define DUK_TVAL_SET_POINTER_UPDREF           DUK_TVAL_SET_POINTER_UPDREF_ALT0
+#define DUK_TVAL_SET_I48_UPDREF DUK_TVAL_SET_I48_UPDREF_ALT0
+#define DUK_TVAL_SET_I32_UPDREF DUK_TVAL_SET_I32_UPDREF_ALT0
+#define DUK_TVAL_SET_U32_UPDREF DUK_TVAL_SET_U32_UPDREF_ALT0
+#else
+#define DUK_TVAL_SET_I48_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF /* XXX: fast int-to-double */
+#define DUK_TVAL_SET_I32_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF
+#define DUK_TVAL_SET_U32_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF
+#endif /* DUK_USE_FASTINT */
+#define DUK_TVAL_SET_FASTINT_UPDREF   DUK_TVAL_SET_I48_UPDREF /* convenience */
+#define DUK_TVAL_SET_LIGHTFUNC_UPDREF DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0
+#define DUK_TVAL_SET_STRING_UPDREF    DUK_TVAL_SET_STRING_UPDREF_ALT0
+#define DUK_TVAL_SET_OBJECT_UPDREF    DUK_TVAL_SET_OBJECT_UPDREF_ALT0
+#define DUK_TVAL_SET_BUFFER_UPDREF    DUK_TVAL_SET_BUFFER_UPDREF_ALT0
+#define DUK_TVAL_SET_POINTER_UPDREF   DUK_TVAL_SET_POINTER_UPDREF_ALT0
 
 #if defined(DUK_USE_FAST_REFCOUNT_DEFAULT)
 /* Optimized for speed. */
-#define DUK_TVAL_SET_TVAL_UPDREF              DUK_TVAL_SET_TVAL_UPDREF_ALT1
-#define DUK_TVAL_SET_TVAL_UPDREF_FAST         DUK_TVAL_SET_TVAL_UPDREF_ALT1
-#define DUK_TVAL_SET_TVAL_UPDREF_SLOW         DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_TVAL_UPDREF      DUK_TVAL_SET_TVAL_UPDREF_ALT1
+#define DUK_TVAL_SET_TVAL_UPDREF_FAST DUK_TVAL_SET_TVAL_UPDREF_ALT1
+#define DUK_TVAL_SET_TVAL_UPDREF_SLOW DUK_TVAL_SET_TVAL_UPDREF_ALT0
 #else
 /* Optimized for size. */
-#define DUK_TVAL_SET_TVAL_UPDREF              DUK_TVAL_SET_TVAL_UPDREF_ALT0
-#define DUK_TVAL_SET_TVAL_UPDREF_FAST         DUK_TVAL_SET_TVAL_UPDREF_ALT0
-#define DUK_TVAL_SET_TVAL_UPDREF_SLOW         DUK_TVAL_SET_TVAL_UPDREF_ALT0
-#endif
-
-#else  /* DUK_USE_REFERENCE_COUNTING */
-
-#define DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv)     0
-#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h)   0
-
-#define DUK_TVAL_INCREF_FAST(thr,v)            do {} while (0) /* nop */
-#define DUK_TVAL_DECREF_FAST(thr,v)            do {} while (0) /* nop */
-#define DUK_TVAL_DECREF_NORZ_FAST(thr,v)       do {} while (0) /* nop */
-#define DUK_TVAL_INCREF_SLOW(thr,v)            do {} while (0) /* nop */
-#define DUK_TVAL_DECREF_SLOW(thr,v)            do {} while (0) /* nop */
-#define DUK_TVAL_DECREF_NORZ_SLOW(thr,v)       do {} while (0) /* nop */
-#define DUK_TVAL_INCREF(thr,v)                 do {} while (0) /* nop */
-#define DUK_TVAL_DECREF(thr,v)                 do {} while (0) /* nop */
-#define DUK_TVAL_DECREF_NORZ(thr,v)            do {} while (0) /* nop */
-#define DUK_HEAPHDR_INCREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF_NORZ_FAST(thr,h)    do {} while (0) /* nop */
-#define DUK_HEAPHDR_INCREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF_NORZ_SLOW(thr,h)    do {} while (0) /* nop */
-#define DUK_HEAPHDR_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HEAPHDR_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-#define DUK_HSTRING_INCREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF_NORZ_FAST(thr,h)    do {} while (0) /* nop */
-#define DUK_HSTRING_INCREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF_NORZ_SLOW(thr,h)    do {} while (0) /* nop */
-#define DUK_HSTRING_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HSTRING_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_INCREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_NORZ_FAST(thr,h)    do {} while (0) /* nop */
-#define DUK_HOBJECT_INCREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_NORZ_SLOW(thr,h)    do {} while (0) /* nop */
-#define DUK_HOBJECT_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-#define DUK_HBUFFER_INCREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_FAST(thr,h)         do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_NORZ_FAST(thr,h)    do {} while (0) /* nop */
-#define DUK_HBUFFER_INCREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_SLOW(thr,h)         do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_NORZ_SLOW(thr,h)    do {} while (0) /* nop */
-#define DUK_HBUFFER_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-
-#define DUK_HCOMPFUNC_INCREF(thr,h)            do {} while (0) /* nop */
-#define DUK_HCOMPFUNC_DECREF(thr,h)            do {} while (0) /* nop */
-#define DUK_HCOMPFUNC_DECREF_NORZ(thr,h)       do {} while (0) /* nop */
-#define DUK_HNATFUNC_INCREF(thr,h)             do {} while (0) /* nop */
-#define DUK_HNATFUNC_DECREF(thr,h)             do {} while (0) /* nop */
-#define DUK_HNATFUNC_DECREF_NORZ(thr,h)        do {} while (0) /* nop */
-#define DUK_HBUFOBJ_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HBUFOBJ_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HBUFOBJ_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-#define DUK_HTHREAD_INCREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HTHREAD_DECREF(thr,h)              do {} while (0) /* nop */
-#define DUK_HTHREAD_DECREF_NORZ(thr,h)         do {} while (0) /* nop */
-#define DUK_HOBJECT_INCREF_ALLOWNULL(thr,h)    do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_ALLOWNULL(thr,h)    do {} while (0) /* nop */
-#define DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr,h)  do {} while (0) /* nop */
-#define DUK_HBUFFER_INCREF_ALLOWNULL(thr,h)    do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_ALLOWNULL(thr,h)    do {} while (0) /* nop */
-#define DUK_HBUFFER_DECREF_NORZ_ALLOWNULL(thr,h)  do {} while (0) /* nop */
-
-#define DUK_REFZERO_CHECK_FAST(thr)            do {} while (0) /* nop */
-#define DUK_REFZERO_CHECK_SLOW(thr)            do {} while (0) /* nop */
-
-#define DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_TVAL_UPDREF      DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_TVAL_UPDREF_FAST DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_TVAL_UPDREF_SLOW DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#endif
+
+#else /* DUK_USE_REFERENCE_COUNTING */
+
+#define DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv)   0
+#define DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(h) 0
+
+#define DUK_TVAL_INCREF_FAST(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF_FAST(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF_NORZ_FAST(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_INCREF_SLOW(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF_SLOW(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF_NORZ_SLOW(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_INCREF(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_TVAL_DECREF_NORZ(thr, v) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_INCREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF_NORZ_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_INCREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HEAPHDR_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_INCREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF_NORZ_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_INCREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HSTRING_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_INCREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_NORZ_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_INCREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_INCREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_NORZ_FAST(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_INCREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_NORZ_SLOW(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+
+#define DUK_HCOMPFUNC_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HCOMPFUNC_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HCOMPFUNC_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HNATFUNC_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HNATFUNC_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HNATFUNC_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFOBJ_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFOBJ_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFOBJ_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HTHREAD_INCREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HTHREAD_DECREF(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HTHREAD_DECREF_NORZ(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_INCREF_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_INCREF_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+#define DUK_HBUFFER_DECREF_NORZ_ALLOWNULL(thr, h) \
+	do { \
+	} while (0) /* nop */
+
+#define DUK_REFZERO_CHECK_FAST(thr) \
+	do { \
+	} while (0) /* nop */
+#define DUK_REFZERO_CHECK_SLOW(thr) \
+	do { \
+	} while (0) /* nop */
+
+#define DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_UNDEFINED(tv__dst); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_UNUSED_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_UNUSED_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_UNUSED(tv__dst); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_NULL_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NULL_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_NULL(tv__dst); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_BOOLEAN(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_NUMBER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NUMBER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_NUMBER(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
-#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_NUMBER_CHKFAST_FAST(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
-#define DUK_TVAL_SET_DOUBLE_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_DOUBLE_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_DOUBLE(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
-#define DUK_TVAL_SET_NAN_UPDREF_ALT0(thr,tvptr_dst) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_NAN_UPDREF_ALT0(thr, tvptr_dst) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_NAN(tv__dst); \
 		DUK_UNREF((thr)); \
 	} while (0)
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_I48_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_I48_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_I48(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
-#define DUK_TVAL_SET_I32_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_I32_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_I32(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
-#define DUK_TVAL_SET_U32_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_U32_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_U32(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 #else
-#define DUK_TVAL_SET_DOUBLE_CAST_UPDREF(thr,tvptr_dst,newval) \
+#define DUK_TVAL_SET_DOUBLE_CAST_UPDREF(thr, tvptr_dst, newval) \
 	DUK_TVAL_SET_DOUBLE_UPDREF((thr), (tvptr_dst), (duk_double_t) (newval))
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
-#define DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0(thr,tvptr_dst,lf_v,lf_fp,lf_flags) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0(thr, tvptr_dst, lf_v, lf_fp, lf_flags) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_LIGHTFUNC(tv__dst, (lf_v), (lf_fp), (lf_flags)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_STRING_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_STRING_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_STRING(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_OBJECT_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_OBJECT_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_OBJECT(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_BUFFER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_BUFFER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_BUFFER(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_POINTER_UPDREF_ALT0(thr,tvptr_dst,newval) do { \
-		duk_tval *tv__dst; tv__dst = (tvptr_dst); \
+#define DUK_TVAL_SET_POINTER_UPDREF_ALT0(thr, tvptr_dst, newval) \
+	do { \
+		duk_tval *tv__dst; \
+		tv__dst = (tvptr_dst); \
 		DUK_TVAL_SET_POINTER(tv__dst, (newval)); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_TVAL_UPDREF_ALT0(thr,tvptr_dst,tvptr_src) do { \
+#define DUK_TVAL_SET_TVAL_UPDREF_ALT0(thr, tvptr_dst, tvptr_src) \
+	do { \
 		duk_tval *tv__dst, *tv__src; \
-		tv__dst = (tvptr_dst); tv__src = (tvptr_src); \
+		tv__dst = (tvptr_dst); \
+		tv__src = (tvptr_src); \
 		DUK_TVAL_SET_TVAL(tv__dst, tv__src); \
 		DUK_UNREF((thr)); \
 	} while (0)
 
-#define DUK_TVAL_SET_UNDEFINED_UPDREF         DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
-#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ    DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
-#define DUK_TVAL_SET_UNUSED_UPDREF            DUK_TVAL_SET_UNUSED_UPDREF_ALT0
-#define DUK_TVAL_SET_NULL_UPDREF              DUK_TVAL_SET_NULL_UPDREF_ALT0
-#define DUK_TVAL_SET_BOOLEAN_UPDREF           DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0
-#define DUK_TVAL_SET_NUMBER_UPDREF            DUK_TVAL_SET_NUMBER_UPDREF_ALT0
-#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF    DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0
-#define DUK_TVAL_SET_DOUBLE_UPDREF            DUK_TVAL_SET_DOUBLE_UPDREF_ALT0
-#define DUK_TVAL_SET_NAN_UPDREF               DUK_TVAL_SET_NAN_UPDREF_ALT0
+#define DUK_TVAL_SET_UNDEFINED_UPDREF      DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
+#define DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ DUK_TVAL_SET_UNDEFINED_UPDREF_ALT0
+#define DUK_TVAL_SET_UNUSED_UPDREF         DUK_TVAL_SET_UNUSED_UPDREF_ALT0
+#define DUK_TVAL_SET_NULL_UPDREF           DUK_TVAL_SET_NULL_UPDREF_ALT0
+#define DUK_TVAL_SET_BOOLEAN_UPDREF        DUK_TVAL_SET_BOOLEAN_UPDREF_ALT0
+#define DUK_TVAL_SET_NUMBER_UPDREF         DUK_TVAL_SET_NUMBER_UPDREF_ALT0
+#define DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF_ALT0
+#define DUK_TVAL_SET_DOUBLE_UPDREF         DUK_TVAL_SET_DOUBLE_UPDREF_ALT0
+#define DUK_TVAL_SET_NAN_UPDREF            DUK_TVAL_SET_NAN_UPDREF_ALT0
 #if defined(DUK_USE_FASTINT)
-#define DUK_TVAL_SET_I48_UPDREF               DUK_TVAL_SET_I48_UPDREF_ALT0
-#define DUK_TVAL_SET_I32_UPDREF               DUK_TVAL_SET_I32_UPDREF_ALT0
-#define DUK_TVAL_SET_U32_UPDREF               DUK_TVAL_SET_U32_UPDREF_ALT0
-#else
-#define DUK_TVAL_SET_I48_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF  /* XXX: fast-int-to-double */
-#define DUK_TVAL_SET_I32_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF
-#define DUK_TVAL_SET_U32_UPDREF               DUK_TVAL_SET_DOUBLE_CAST_UPDREF
-#endif  /* DUK_USE_FASTINT */
-#define DUK_TVAL_SET_FASTINT_UPDREF           DUK_TVAL_SET_I48_UPDREF  /* convenience */
-#define DUK_TVAL_SET_LIGHTFUNC_UPDREF         DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0
-#define DUK_TVAL_SET_STRING_UPDREF            DUK_TVAL_SET_STRING_UPDREF_ALT0
-#define DUK_TVAL_SET_OBJECT_UPDREF            DUK_TVAL_SET_OBJECT_UPDREF_ALT0
-#define DUK_TVAL_SET_BUFFER_UPDREF            DUK_TVAL_SET_BUFFER_UPDREF_ALT0
-#define DUK_TVAL_SET_POINTER_UPDREF           DUK_TVAL_SET_POINTER_UPDREF_ALT0
-
-#define DUK_TVAL_SET_TVAL_UPDREF              DUK_TVAL_SET_TVAL_UPDREF_ALT0
-#define DUK_TVAL_SET_TVAL_UPDREF_FAST         DUK_TVAL_SET_TVAL_UPDREF_ALT0
-#define DUK_TVAL_SET_TVAL_UPDREF_SLOW         DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_I48_UPDREF DUK_TVAL_SET_I48_UPDREF_ALT0
+#define DUK_TVAL_SET_I32_UPDREF DUK_TVAL_SET_I32_UPDREF_ALT0
+#define DUK_TVAL_SET_U32_UPDREF DUK_TVAL_SET_U32_UPDREF_ALT0
+#else
+#define DUK_TVAL_SET_I48_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF /* XXX: fast-int-to-double */
+#define DUK_TVAL_SET_I32_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF
+#define DUK_TVAL_SET_U32_UPDREF DUK_TVAL_SET_DOUBLE_CAST_UPDREF
+#endif /* DUK_USE_FASTINT */
+#define DUK_TVAL_SET_FASTINT_UPDREF   DUK_TVAL_SET_I48_UPDREF /* convenience */
+#define DUK_TVAL_SET_LIGHTFUNC_UPDREF DUK_TVAL_SET_LIGHTFUNC_UPDREF_ALT0
+#define DUK_TVAL_SET_STRING_UPDREF    DUK_TVAL_SET_STRING_UPDREF_ALT0
+#define DUK_TVAL_SET_OBJECT_UPDREF    DUK_TVAL_SET_OBJECT_UPDREF_ALT0
+#define DUK_TVAL_SET_BUFFER_UPDREF    DUK_TVAL_SET_BUFFER_UPDREF_ALT0
+#define DUK_TVAL_SET_POINTER_UPDREF   DUK_TVAL_SET_POINTER_UPDREF_ALT0
+
+#define DUK_TVAL_SET_TVAL_UPDREF      DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_TVAL_UPDREF_FAST DUK_TVAL_SET_TVAL_UPDREF_ALT0
+#define DUK_TVAL_SET_TVAL_UPDREF_SLOW DUK_TVAL_SET_TVAL_UPDREF_ALT0
 
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /*
  *  Some convenience macros that don't have optimized implementations now.
  */
 
-#define DUK_TVAL_SET_TVAL_UPDREF_NORZ(thr,tv_dst,tv_src) do { \
+#define DUK_TVAL_SET_TVAL_UPDREF_NORZ(thr, tv_dst, tv_src) \
+	do { \
 		duk_hthread *duk__thr = (thr); \
 		duk_tval *duk__dst = (tv_dst); \
 		duk_tval *duk__src = (tv_src); \
 		DUK_UNREF(duk__thr); \
 		DUK_TVAL_DECREF_NORZ(thr, duk__dst); \
 		DUK_TVAL_SET_TVAL(duk__dst, duk__src); \
 		DUK_TVAL_INCREF(thr, duk__dst); \
 	} while (0)
 
-#define DUK_TVAL_SET_U32_UPDREF_NORZ(thr,tv_dst,val) do { \
+#define DUK_TVAL_SET_U32_UPDREF_NORZ(thr, tv_dst, val) \
+	do { \
 		duk_hthread *duk__thr = (thr); \
 		duk_tval *duk__dst = (tv_dst); \
 		duk_uint32_t duk__val = (duk_uint32_t) (val); \
 		DUK_UNREF(duk__thr); \
 		DUK_TVAL_DECREF_NORZ(thr, duk__dst); \
 		DUK_TVAL_SET_U32(duk__dst, duk__val); \
 	} while (0)
@@ -5464,42 +5871,42 @@
 #if defined(DUK_USE_REFERENCE_COUNTING)
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_INTERNAL_DECL void duk_refzero_check_slow(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_refzero_check_fast(duk_hthread *thr);
 #endif
 DUK_INTERNAL_DECL void duk_heaphdr_refcount_finalize_norz(duk_heap *heap, duk_heaphdr *hdr);
 DUK_INTERNAL_DECL void duk_hobject_refcount_finalize_norz(duk_heap *heap, duk_hobject *h);
-#if 0  /* Not needed: fast path handles inline; slow path uses duk_heaphdr_decref() which is needed anyway. */
+#if 0 /* Not needed: fast path handles inline; slow path uses duk_heaphdr_decref() which is needed anyway. */
 DUK_INTERNAL_DECL void duk_hstring_decref(duk_hthread *thr, duk_hstring *h);
 DUK_INTERNAL_DECL void duk_hstring_decref_norz(duk_hthread *thr, duk_hstring *h);
 DUK_INTERNAL_DECL void duk_hbuffer_decref(duk_hthread *thr, duk_hbuffer *h);
 DUK_INTERNAL_DECL void duk_hbuffer_decref_norz(duk_hthread *thr, duk_hbuffer *h);
 DUK_INTERNAL_DECL void duk_hobject_decref(duk_hthread *thr, duk_hobject *h);
 DUK_INTERNAL_DECL void duk_hobject_decref_norz(duk_hthread *thr, duk_hobject *h);
 #endif
 DUK_INTERNAL_DECL void duk_heaphdr_refzero(duk_hthread *thr, duk_heaphdr *h);
 DUK_INTERNAL_DECL void duk_heaphdr_refzero_norz(duk_hthread *thr, duk_heaphdr *h);
 #if defined(DUK_USE_FAST_REFCOUNT_DEFAULT)
-DUK_INTERNAL_DECL void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h);  /* no 'norz' variant */
-DUK_INTERNAL_DECL void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h);  /* no 'norz' variant */
+DUK_INTERNAL_DECL void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h); /* no 'norz' variant */
+DUK_INTERNAL_DECL void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h); /* no 'norz' variant */
 DUK_INTERNAL_DECL void duk_hobject_refzero(duk_hthread *thr, duk_hobject *h);
 DUK_INTERNAL_DECL void duk_hobject_refzero_norz(duk_hthread *thr, duk_hobject *h);
 #else
 DUK_INTERNAL_DECL void duk_tval_incref(duk_tval *tv);
 DUK_INTERNAL_DECL void duk_tval_decref(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL void duk_tval_decref_norz(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL void duk_heaphdr_incref(duk_heaphdr *h);
 DUK_INTERNAL_DECL void duk_heaphdr_decref(duk_hthread *thr, duk_heaphdr *h);
 DUK_INTERNAL_DECL void duk_heaphdr_decref_norz(duk_hthread *thr, duk_heaphdr *h);
 #endif
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 /* no refcounting */
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
-#endif  /* DUK_REFCOUNT_H_INCLUDED */
+#endif /* DUK_REFCOUNT_H_INCLUDED */
 /* #include duk_api_internal.h */
 #line 1 "duk_api_internal.h"
 /*
  *  Internal API calls which have (stack and other) semantics similar
  *  to the public API.
  */
 
@@ -5508,38 +5915,38 @@
 
 /* Inline macro helpers. */
 #if defined(DUK_USE_PREFER_SIZE)
 #define DUK_INLINE_PERF
 #define DUK_ALWAYS_INLINE_PERF
 #define DUK_NOINLINE_PERF
 #else
-#define DUK_INLINE_PERF DUK_INLINE
+#define DUK_INLINE_PERF        DUK_INLINE
 #define DUK_ALWAYS_INLINE_PERF DUK_ALWAYS_INLINE
-#define DUK_NOINLINE_PERF DUK_NOINLINE
+#define DUK_NOINLINE_PERF      DUK_NOINLINE
 #endif
 
 /* Inline macro helpers, for bytecode executor. */
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 #define DUK_EXEC_INLINE_PERF
 #define DUK_EXEC_ALWAYS_INLINE_PERF
 #define DUK_EXEC_NOINLINE_PERF
 #else
-#define DUK_EXEC_INLINE_PERF DUK_INLINE
+#define DUK_EXEC_INLINE_PERF        DUK_INLINE
 #define DUK_EXEC_ALWAYS_INLINE_PERF DUK_ALWAYS_INLINE
-#define DUK_EXEC_NOINLINE_PERF DUK_NOINLINE
+#define DUK_EXEC_NOINLINE_PERF      DUK_NOINLINE
 #endif
 
 /* duk_push_sprintf constants */
-#define DUK_PUSH_SPRINTF_INITIAL_SIZE  256L
-#define DUK_PUSH_SPRINTF_SANITY_LIMIT  (1L * 1024L * 1024L * 1024L)
+#define DUK_PUSH_SPRINTF_INITIAL_SIZE 256L
+#define DUK_PUSH_SPRINTF_SANITY_LIMIT (1L * 1024L * 1024L * 1024L)
 
 /* Flag ORed to err_code to indicate __FILE__ / __LINE__ is not
  * blamed as source of error for error fileName / lineNumber.
  */
-#define DUK_ERRCODE_FLAG_NOBLAME_FILELINE  (1L << 24)
+#define DUK_ERRCODE_FLAG_NOBLAME_FILELINE (1L << 24)
 
 /* Current convention is to use duk_size_t for value stack sizes and global indices,
  * and duk_idx_t for local frame indices.
  */
 DUK_INTERNAL_DECL void duk_valstack_grow_check_throw(duk_hthread *thr, duk_size_t min_bytes);
 DUK_INTERNAL_DECL duk_bool_t duk_valstack_grow_check_nothrow(duk_hthread *thr, duk_size_t min_bytes);
 DUK_INTERNAL_DECL void duk_valstack_shrink_check_nothrow(duk_hthread *thr, duk_bool_t snug);
@@ -5593,32 +6000,25 @@
 /* Get a borrowed duk_tval pointer to the current 'this' binding.  Caller must
  * make sure there's an active callstack entry.  Note that the returned pointer
  * is unstable with regards to side effects.
  */
 DUK_INTERNAL_DECL duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr);
 
 /* XXX: add fastint support? */
-#define duk_push_u64(thr,val) \
-	duk_push_number((thr), (duk_double_t) (val))
-#define duk_push_i64(thr,val) \
-	duk_push_number((thr), (duk_double_t) (val))
+#define duk_push_u64(thr, val) duk_push_number((thr), (duk_double_t) (val))
+#define duk_push_i64(thr, val) duk_push_number((thr), (duk_double_t) (val))
 
 /* duk_push_(u)int() is guaranteed to support at least (un)signed 32-bit range */
-#define duk_push_u32(thr,val) \
-	duk_push_uint((thr), (duk_uint_t) (val))
-#define duk_push_i32(thr,val) \
-	duk_push_int((thr), (duk_int_t) (val))
+#define duk_push_u32(thr, val) duk_push_uint((thr), (duk_uint_t) (val))
+#define duk_push_i32(thr, val) duk_push_int((thr), (duk_int_t) (val))
 
 /* sometimes stack and array indices need to go on the stack */
-#define duk_push_idx(thr,val) \
-	duk_push_int((thr), (duk_int_t) (val))
-#define duk_push_uarridx(thr,val) \
-	duk_push_uint((thr), (duk_uint_t) (val))
-#define duk_push_size_t(thr,val) \
-	duk_push_uint((thr), (duk_uint_t) (val))  /* XXX: assumed to fit for now */
+#define duk_push_idx(thr, val)     duk_push_int((thr), (duk_int_t) (val))
+#define duk_push_uarridx(thr, val) duk_push_uint((thr), (duk_uint_t) (val))
+#define duk_push_size_t(thr, val)  duk_push_uint((thr), (duk_uint_t) (val)) /* XXX: assumed to fit for now */
 
 DUK_INTERNAL_DECL duk_bool_t duk_is_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
 
 DUK_INTERNAL_DECL duk_bool_t duk_is_callable_tval(duk_hthread *thr, duk_tval *tv);
 
 DUK_INTERNAL_DECL duk_bool_t duk_is_bare_object(duk_hthread *thr, duk_idx_t idx);
 
@@ -5627,27 +6027,31 @@
 DUK_INTERNAL_DECL const char *duk_get_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hobject *duk_get_hobject(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hbuffer *duk_get_hbuffer(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hthread *duk_get_hthread(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hcompfunc *duk_get_hcompfunc(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hnatfunc *duk_get_hnatfunc(duk_hthread *thr, duk_idx_t idx);
 
-DUK_INTERNAL_DECL void *duk_get_buffer_data_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len, duk_bool_t throw_flag, duk_bool_t *out_isbuffer);
+DUK_INTERNAL_DECL void *duk_get_buffer_data_raw(duk_hthread *thr,
+                                                duk_idx_t idx,
+                                                duk_size_t *out_size,
+                                                void *def_ptr,
+                                                duk_size_t def_len,
+                                                duk_bool_t throw_flag,
+                                                duk_bool_t *out_isbuffer);
 
 DUK_INTERNAL_DECL duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);
 
 DUK_INTERNAL_DECL duk_hobject *duk_get_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
 DUK_INTERNAL_DECL duk_hobject *duk_require_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
 DUK_INTERNAL_DECL duk_hobject *duk_require_hobject_accept_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
-#define duk_require_hobject_promote_lfunc(thr,idx) \
-	duk_require_hobject_promote_mask((thr), (idx), DUK_TYPE_MASK_LIGHTFUNC)
-#define duk_get_hobject_promote_lfunc(thr,idx) \
-	duk_get_hobject_promote_mask((thr), (idx), DUK_TYPE_MASK_LIGHTFUNC)
+#define duk_require_hobject_promote_lfunc(thr, idx) duk_require_hobject_promote_mask((thr), (idx), DUK_TYPE_MASK_LIGHTFUNC)
+#define duk_get_hobject_promote_lfunc(thr, idx)     duk_get_hobject_promote_mask((thr), (idx), DUK_TYPE_MASK_LIGHTFUNC)
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL_DECL void *duk_get_voidptr(duk_hthread *thr, duk_idx_t idx);
 #endif
 
 DUK_INTERNAL_DECL duk_hstring *duk_known_hstring(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hobject *duk_known_hobject(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hbuffer *duk_known_hbuffer(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL duk_hcompfunc *duk_known_hcompfunc(duk_hthread *thr, duk_idx_t idx);
@@ -5662,20 +6066,24 @@
 DUK_INTERNAL_DECL duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx);
 
 DUK_INTERNAL_DECL duk_double_t duk_to_number_m1(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_double_t duk_to_number_m2(duk_hthread *thr);
 
 DUK_INTERNAL_DECL duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr);
 
-#if defined(DUK_USE_DEBUGGER_SUPPORT)  /* only needed by debugger for now */
+#if defined(DUK_USE_DEBUGGER_SUPPORT) /* only needed by debugger for now */
 DUK_INTERNAL_DECL duk_hstring *duk_safe_to_hstring(duk_hthread *thr, duk_idx_t idx);
 #endif
 DUK_INTERNAL_DECL void duk_push_class_string_tval(duk_hthread *thr, duk_tval *tv, duk_bool_t avoid_side_effects);
 
-DUK_INTERNAL_DECL duk_int_t duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped);  /* out_clamped=NULL, RangeError if outside range */
+DUK_INTERNAL_DECL duk_int_t duk_to_int_clamped_raw(duk_hthread *thr,
+                                                   duk_idx_t idx,
+                                                   duk_int_t minval,
+                                                   duk_int_t maxval,
+                                                   duk_bool_t *out_clamped); /* out_clamped=NULL, RangeError if outside range */
 DUK_INTERNAL_DECL duk_int_t duk_to_int_clamped(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);
 DUK_INTERNAL_DECL duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL_DECL duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx);
 #endif
 DUK_INTERNAL_DECL duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx);
 
@@ -5692,21 +6100,23 @@
 DUK_INTERNAL_DECL duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);
 
 DUK_INTERNAL_DECL void duk_push_hstring(duk_hthread *thr, duk_hstring *h);
 DUK_INTERNAL_DECL void duk_push_hstring_stridx(duk_hthread *thr, duk_small_uint_t stridx);
 DUK_INTERNAL_DECL void duk_push_hstring_empty(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_push_hobject(duk_hthread *thr, duk_hobject *h);
 DUK_INTERNAL_DECL void duk_push_hbuffer(duk_hthread *thr, duk_hbuffer *h);
-#define duk_push_hthread(thr,h) \
-	duk_push_hobject((thr), (duk_hobject *) (h))
-#define duk_push_hnatfunc(thr,h) \
-	duk_push_hobject((thr), (duk_hobject *) (h))
+#define duk_push_hthread(thr, h)  duk_push_hobject((thr), (duk_hobject *) (h))
+#define duk_push_hnatfunc(thr, h) duk_push_hobject((thr), (duk_hobject *) (h))
 DUK_INTERNAL_DECL void duk_push_hobject_bidx(duk_hthread *thr, duk_small_int_t builtin_idx);
-DUK_INTERNAL_DECL duk_hobject *duk_push_object_helper(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx);
-DUK_INTERNAL_DECL duk_hobject *duk_push_object_helper_proto(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_hobject *proto);
+DUK_INTERNAL_DECL duk_hobject *duk_push_object_helper(duk_hthread *thr,
+                                                      duk_uint_t hobject_flags_and_class,
+                                                      duk_small_int_t prototype_bidx);
+DUK_INTERNAL_DECL duk_hobject *duk_push_object_helper_proto(duk_hthread *thr,
+                                                            duk_uint_t hobject_flags_and_class,
+                                                            duk_hobject *proto);
 DUK_INTERNAL_DECL duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_hboundfunc *duk_push_hboundfunc(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs);
 DUK_INTERNAL_DECL void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs);
 
 /* XXX: duk_push_harray() and duk_push_hcompfunc() are inconsistent with
  * duk_push_hobject() etc which don't create a new value.
@@ -5715,19 +6125,21 @@
 DUK_INTERNAL_DECL duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size);
 DUK_INTERNAL_DECL duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size);
 
 DUK_INTERNAL_DECL void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz);
 DUK_INTERNAL_DECL void duk_push_lightfunc_name_raw(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags);
 DUK_INTERNAL_DECL void duk_push_lightfunc_name(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv);
-#if 0  /* not used yet */
+#if 0 /* not used yet */
 DUK_INTERNAL_DECL void duk_push_hnatfunc_name(duk_hthread *thr, duk_hnatfunc *h);
 #endif
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-DUK_INTERNAL_DECL duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx);
+DUK_INTERNAL_DECL duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr,
+                                                   duk_uint_t hobject_flags_and_class,
+                                                   duk_small_int_t prototype_bidx);
 #endif
 
 DUK_INTERNAL_DECL void *duk_push_fixed_buffer_nozero(duk_hthread *thr, duk_size_t len);
 DUK_INTERNAL_DECL void *duk_push_fixed_buffer_zero(duk_hthread *thr, duk_size_t len);
 
 DUK_INTERNAL_DECL const char *duk_push_string_readable(duk_hthread *thr, duk_idx_t idx);
 DUK_INTERNAL_DECL const char *duk_push_string_tval_readable(duk_hthread *thr, duk_tval *tv);
@@ -5736,88 +6148,94 @@
 /* The duk_xxx_prop_stridx_short() variants expect their arguments to be short
  * enough to be packed into a single 32-bit integer argument.  Argument limits
  * vary per call; typically 16 bits are assigned to the signed value stack index
  * and the stridx.  In practice these work well for footprint with constant
  * arguments and such call sites are also easiest to verify to be correct.
  */
 
-DUK_INTERNAL_DECL duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);     /* [] -> [val] */
+DUK_INTERNAL_DECL duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx); /* [] -> [val] */
 DUK_INTERNAL_DECL duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_get_prop_stridx_short(thr,obj_idx,stridx) \
+#define duk_get_prop_stridx_short(thr, obj_idx, stridx) \
 	(DUK_ASSERT_EXPR((duk_int_t) (obj_idx) >= -0x8000L && (duk_int_t) (obj_idx) <= 0x7fffL), \
 	 DUK_ASSERT_EXPR((duk_int_t) (stridx) >= 0 && (duk_int_t) (stridx) <= 0xffffL), \
 	 duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 16) + ((duk_uint_t) (stridx))))
-DUK_INTERNAL_DECL duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_bool_t *out_has_prop);  /* [] -> [] */
+DUK_INTERNAL_DECL duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr,
+                                                         duk_idx_t obj_idx,
+                                                         duk_small_uint_t stridx,
+                                                         duk_bool_t *out_has_prop); /* [] -> [] */
 
 DUK_INTERNAL_DECL duk_bool_t duk_xget_owndataprop(duk_hthread *thr, duk_idx_t obj_idx);
 DUK_INTERNAL_DECL duk_bool_t duk_xget_owndataprop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
 DUK_INTERNAL_DECL duk_bool_t duk_xget_owndataprop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_xget_owndataprop_stridx_short(thr,obj_idx,stridx) \
+#define duk_xget_owndataprop_stridx_short(thr, obj_idx, stridx) \
 	(DUK_ASSERT_EXPR((duk_int_t) (obj_idx) >= -0x8000L && (duk_int_t) (obj_idx) <= 0x7fffL), \
 	 DUK_ASSERT_EXPR((duk_int_t) (stridx) >= 0 && (duk_int_t) (stridx) <= 0xffffL), \
 	 duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 16) + ((duk_uint_t) (stridx))))
 
-DUK_INTERNAL_DECL duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);     /* [val] -> [] */
+DUK_INTERNAL_DECL duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx); /* [val] -> [] */
 DUK_INTERNAL_DECL duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_put_prop_stridx_short(thr,obj_idx,stridx) \
+#define duk_put_prop_stridx_short(thr, obj_idx, stridx) \
 	(DUK_ASSERT_EXPR((duk_int_t) (obj_idx) >= -0x8000L && (duk_int_t) (obj_idx) <= 0x7fffL), \
 	 DUK_ASSERT_EXPR((duk_int_t) (stridx) >= 0 && (duk_int_t) (stridx) <= 0xffffL), \
 	 duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 16) + ((duk_uint_t) (stridx))))
 
-DUK_INTERNAL_DECL duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);     /* [] -> [] */
-#if 0  /* Too few call sites to be useful. */
+DUK_INTERNAL_DECL duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx); /* [] -> [] */
+#if 0 /* Too few call sites to be useful. */
 DUK_INTERNAL_DECL duk_bool_t duk_del_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_del_prop_stridx_short(thr,obj_idx,stridx) \
+#define duk_del_prop_stridx_short(thr, obj_idx, stridx) \
 	(DUK_ASSERT_EXPR((obj_idx) >= -0x8000L && (obj_idx) <= 0x7fffL), \
 	 DUK_ASSERT_EXPR((stridx) >= 0 && (stridx) <= 0xffffL), \
 	 duk_del_prop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 16) + ((duk_uint_t) (stridx))))
 #endif
-#define duk_del_prop_stridx_short(thr,obj_idx,stridx) \
-	duk_del_prop_stridx((thr), (obj_idx), (stridx))
+#define duk_del_prop_stridx_short(thr, obj_idx, stridx) duk_del_prop_stridx((thr), (obj_idx), (stridx))
 
-DUK_INTERNAL_DECL duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);     /* [] -> [] */
-#if 0  /* Too few call sites to be useful. */
+DUK_INTERNAL_DECL duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx); /* [] -> [] */
+#if 0 /* Too few call sites to be useful. */
 DUK_INTERNAL_DECL duk_bool_t duk_has_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_has_prop_stridx_short(thr,obj_idx,stridx) \
+#define duk_has_prop_stridx_short(thr, obj_idx, stridx) \
 	(DUK_ASSERT_EXPR((obj_idx) >= -0x8000L && (obj_idx) <= 0x7fffL), \
 	 DUK_ASSERT_EXPR((stridx) >= 0 && (stridx) <= 0xffffL), \
 	 duk_has_prop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 16) + ((duk_uint_t) (stridx))))
 #endif
-#define duk_has_prop_stridx_short(thr,obj_idx,stridx) \
-	duk_has_prop_stridx((thr), (obj_idx), (stridx))
+#define duk_has_prop_stridx_short(thr, obj_idx, stridx) duk_has_prop_stridx((thr), (obj_idx), (stridx))
 
-DUK_INTERNAL_DECL void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags);  /* [key val] -> [] */
+DUK_INTERNAL_DECL void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags); /* [key val] -> [] */
 
-DUK_INTERNAL_DECL void duk_xdef_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx, duk_small_uint_t desc_flags);  /* [val] -> [] */
+DUK_INTERNAL_DECL void duk_xdef_prop_index(duk_hthread *thr,
+                                           duk_idx_t obj_idx,
+                                           duk_uarridx_t arr_idx,
+                                           duk_small_uint_t desc_flags); /* [val] -> [] */
 
 /* XXX: Because stridx and desc_flags have a limited range, this call could
  * always pack stridx and desc_flags into a single argument.
  */
-DUK_INTERNAL_DECL void duk_xdef_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_uint_t desc_flags);  /* [val] -> [] */
+DUK_INTERNAL_DECL void duk_xdef_prop_stridx(duk_hthread *thr,
+                                            duk_idx_t obj_idx,
+                                            duk_small_uint_t stridx,
+                                            duk_small_uint_t desc_flags); /* [val] -> [] */
 DUK_INTERNAL_DECL void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
-#define duk_xdef_prop_stridx_short(thr,obj_idx,stridx,desc_flags) \
+#define duk_xdef_prop_stridx_short(thr, obj_idx, stridx, desc_flags) \
 	(DUK_ASSERT_EXPR((duk_int_t) (obj_idx) >= -0x80L && (duk_int_t) (obj_idx) <= 0x7fL), \
 	 DUK_ASSERT_EXPR((duk_int_t) (stridx) >= 0 && (duk_int_t) (stridx) <= 0xffffL), \
 	 DUK_ASSERT_EXPR((duk_int_t) (desc_flags) >= 0 && (duk_int_t) (desc_flags) <= 0xffL), \
-	 duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (obj_idx)) << 24) + (((duk_uint_t) (stridx)) << 8) + (duk_uint_t) (desc_flags)))
-
-#define duk_xdef_prop_wec(thr,obj_idx) \
-	duk_xdef_prop((thr), (obj_idx), DUK_PROPDESC_FLAGS_WEC)
-#define duk_xdef_prop_index_wec(thr,obj_idx,arr_idx) \
-	duk_xdef_prop_index((thr), (obj_idx), (arr_idx), DUK_PROPDESC_FLAGS_WEC)
-#define duk_xdef_prop_stridx_wec(thr,obj_idx,stridx) \
-	duk_xdef_prop_stridx((thr), (obj_idx), (stridx), DUK_PROPDESC_FLAGS_WEC)
-#define duk_xdef_prop_stridx_short_wec(thr,obj_idx,stridx) \
+	 duk_xdef_prop_stridx_short_raw((thr), \
+	                                (((duk_uint_t) (obj_idx)) << 24) + (((duk_uint_t) (stridx)) << 8) + \
+	                                    (duk_uint_t) (desc_flags)))
+
+#define duk_xdef_prop_wec(thr, obj_idx)                duk_xdef_prop((thr), (obj_idx), DUK_PROPDESC_FLAGS_WEC)
+#define duk_xdef_prop_index_wec(thr, obj_idx, arr_idx) duk_xdef_prop_index((thr), (obj_idx), (arr_idx), DUK_PROPDESC_FLAGS_WEC)
+#define duk_xdef_prop_stridx_wec(thr, obj_idx, stridx) duk_xdef_prop_stridx((thr), (obj_idx), (stridx), DUK_PROPDESC_FLAGS_WEC)
+#define duk_xdef_prop_stridx_short_wec(thr, obj_idx, stridx) \
 	duk_xdef_prop_stridx_short((thr), (obj_idx), (stridx), DUK_PROPDESC_FLAGS_WEC)
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL_DECL void duk_xdef_prop_stridx_builtin(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_int_t builtin_idx, duk_small_uint_t desc_flags);  /* [] -> [] */
 #endif
 
-DUK_INTERNAL_DECL void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);  /* [] -> [] */
+DUK_INTERNAL_DECL void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx); /* [] -> [] */
 
 DUK_INTERNAL_DECL duk_bool_t duk_get_method_stridx(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t stridx);
 
 DUK_INTERNAL_DECL void duk_pack(duk_hthread *thr, duk_idx_t count);
 DUK_INTERNAL_DECL duk_idx_t duk_unpack_array_like(duk_hthread *thr, duk_idx_t idx);
 #if 0
 DUK_INTERNAL_DECL void duk_unpack(duk_hthread *thr);
@@ -5858,36 +6276,32 @@
 DUK_INTERNAL_DECL void duk_clear_prototype(duk_hthread *thr, duk_idx_t idx);
 
 /* Raw internal valstack access macros: access is unsafe so call site
  * must have a guarantee that the index is valid.  When that is the case,
  * using these macro results in faster and smaller code than duk_get_tval().
  * Both 'ctx' and 'idx' are evaluted multiple times, but only for asserts.
  */
-#define DUK_ASSERT_VALID_NEGIDX(thr,idx) \
+#define DUK_ASSERT_VALID_NEGIDX(thr, idx) \
 	(DUK_ASSERT_EXPR((duk_int_t) (idx) < 0), DUK_ASSERT_EXPR(duk_is_valid_index((thr), (idx))))
-#define DUK_ASSERT_VALID_POSIDX(thr,idx) \
+#define DUK_ASSERT_VALID_POSIDX(thr, idx) \
 	(DUK_ASSERT_EXPR((duk_int_t) (idx) >= 0), DUK_ASSERT_EXPR(duk_is_valid_index((thr), (idx))))
-#define DUK_GET_TVAL_NEGIDX(thr,idx) \
-	(DUK_ASSERT_VALID_NEGIDX((thr),(idx)), ((duk_hthread *) (thr))->valstack_top + (idx))
-#define DUK_GET_TVAL_POSIDX(thr,idx) \
-	(DUK_ASSERT_VALID_POSIDX((thr),(idx)), ((duk_hthread *) (thr))->valstack_bottom + (idx))
-#define DUK_GET_HOBJECT_NEGIDX(thr,idx) \
-	(DUK_ASSERT_VALID_NEGIDX((thr),(idx)), DUK_TVAL_GET_OBJECT(((duk_hthread *) (thr))->valstack_top + (idx)))
-#define DUK_GET_HOBJECT_POSIDX(thr,idx) \
-	(DUK_ASSERT_VALID_POSIDX((thr),(idx)), DUK_TVAL_GET_OBJECT(((duk_hthread *) (thr))->valstack_bottom + (idx)))
-
-#define DUK_GET_THIS_TVAL_PTR(thr) \
-	(DUK_ASSERT_EXPR((thr)->valstack_bottom > (thr)->valstack), \
-	 (thr)->valstack_bottom - 1)
+#define DUK_GET_TVAL_NEGIDX(thr, idx) (DUK_ASSERT_VALID_NEGIDX((thr), (idx)), ((duk_hthread *) (thr))->valstack_top + (idx))
+#define DUK_GET_TVAL_POSIDX(thr, idx) (DUK_ASSERT_VALID_POSIDX((thr), (idx)), ((duk_hthread *) (thr))->valstack_bottom + (idx))
+#define DUK_GET_HOBJECT_NEGIDX(thr, idx) \
+	(DUK_ASSERT_VALID_NEGIDX((thr), (idx)), DUK_TVAL_GET_OBJECT(((duk_hthread *) (thr))->valstack_top + (idx)))
+#define DUK_GET_HOBJECT_POSIDX(thr, idx) \
+	(DUK_ASSERT_VALID_POSIDX((thr), (idx)), DUK_TVAL_GET_OBJECT(((duk_hthread *) (thr))->valstack_bottom + (idx)))
+
+#define DUK_GET_THIS_TVAL_PTR(thr) (DUK_ASSERT_EXPR((thr)->valstack_bottom > (thr)->valstack), (thr)->valstack_bottom - 1)
 
 DUK_INTERNAL_DECL duk_double_t duk_time_get_ecmascript_time(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_double_t duk_time_get_ecmascript_time_nofrac(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_double_t duk_time_get_monotonic_time(duk_hthread *thr);
 
-#endif  /* DUK_API_INTERNAL_H_INCLUDED */
+#endif /* DUK_API_INTERNAL_H_INCLUDED */
 /* #include duk_hstring.h */
 #line 1 "duk_hstring.h"
 /*
  *  Heap string representation.
  *
  *  Strings are byte sequences ordinarily stored in extended UTF-8 format,
  *  allowing values larger than the official UTF-8 range (used internally)
@@ -5911,161 +6325,170 @@
  *
  * E5.1 makes provisions to support strings longer than 4G characters.
  * This limit should be eliminated on 64-bit platforms (and increased
  * closer to maximum support on 32-bit platforms).
  */
 
 #if defined(DUK_USE_STRLEN16)
-#define DUK_HSTRING_MAX_BYTELEN                     (0x0000ffffUL)
+#define DUK_HSTRING_MAX_BYTELEN (0x0000ffffUL)
 #else
-#define DUK_HSTRING_MAX_BYTELEN                     (0x7fffffffUL)
+#define DUK_HSTRING_MAX_BYTELEN (0x7fffffffUL)
 #endif
 
 /* XXX: could add flags for "is valid CESU-8" (ECMAScript compatible strings),
  * "is valid UTF-8", "is valid extended UTF-8" (internal strings are not,
  * regexp bytecode is), and "contains non-BMP characters".  These are not
  * needed right now.
  */
 
 /* With lowmem builds the high 16 bits of duk_heaphdr are used for other
  * purposes, so this leaves 7 duk_heaphdr flags and 9 duk_hstring flags.
  */
-#define DUK_HSTRING_FLAG_ASCII                      DUK_HEAPHDR_USER_FLAG(0)  /* string is ASCII, clen == blen */
-#define DUK_HSTRING_FLAG_ARRIDX                     DUK_HEAPHDR_USER_FLAG(1)  /* string is a valid array index */
-#define DUK_HSTRING_FLAG_SYMBOL                     DUK_HEAPHDR_USER_FLAG(2)  /* string is a symbol (invalid utf-8) */
-#define DUK_HSTRING_FLAG_HIDDEN                     DUK_HEAPHDR_USER_FLAG(3)  /* string is a hidden symbol (implies symbol, Duktape 1.x internal string) */
-#define DUK_HSTRING_FLAG_RESERVED_WORD              DUK_HEAPHDR_USER_FLAG(4)  /* string is a reserved word (non-strict) */
-#define DUK_HSTRING_FLAG_STRICT_RESERVED_WORD       DUK_HEAPHDR_USER_FLAG(5)  /* string is a reserved word (strict) */
-#define DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS          DUK_HEAPHDR_USER_FLAG(6)  /* string is 'eval' or 'arguments' */
-#define DUK_HSTRING_FLAG_EXTDATA                    DUK_HEAPHDR_USER_FLAG(7)  /* string data is external (duk_hstring_external) */
-#define DUK_HSTRING_FLAG_PINNED_LITERAL             DUK_HEAPHDR_USER_FLAG(8)  /* string is a literal, and pinned */
-
-#define DUK_HSTRING_HAS_ASCII(x)                    DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
-#define DUK_HSTRING_HAS_ARRIDX(x)                   DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
-#define DUK_HSTRING_HAS_SYMBOL(x)                   DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
-#define DUK_HSTRING_HAS_HIDDEN(x)                   DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
-#define DUK_HSTRING_HAS_RESERVED_WORD(x)            DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
-#define DUK_HSTRING_HAS_STRICT_RESERVED_WORD(x)     DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
-#define DUK_HSTRING_HAS_EVAL_OR_ARGUMENTS(x)        DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
-#define DUK_HSTRING_HAS_EXTDATA(x)                  DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
-#define DUK_HSTRING_HAS_PINNED_LITERAL(x)           DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
-
-#define DUK_HSTRING_SET_ASCII(x)                    DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
-#define DUK_HSTRING_SET_ARRIDX(x)                   DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
-#define DUK_HSTRING_SET_SYMBOL(x)                   DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
-#define DUK_HSTRING_SET_HIDDEN(x)                   DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
-#define DUK_HSTRING_SET_RESERVED_WORD(x)            DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
-#define DUK_HSTRING_SET_STRICT_RESERVED_WORD(x)     DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
-#define DUK_HSTRING_SET_EVAL_OR_ARGUMENTS(x)        DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
-#define DUK_HSTRING_SET_EXTDATA(x)                  DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
-#define DUK_HSTRING_SET_PINNED_LITERAL(x)           DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
-
-#define DUK_HSTRING_CLEAR_ASCII(x)                  DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
-#define DUK_HSTRING_CLEAR_ARRIDX(x)                 DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
-#define DUK_HSTRING_CLEAR_SYMBOL(x)                 DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
-#define DUK_HSTRING_CLEAR_HIDDEN(x)                 DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
-#define DUK_HSTRING_CLEAR_RESERVED_WORD(x)          DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
-#define DUK_HSTRING_CLEAR_STRICT_RESERVED_WORD(x)   DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
-#define DUK_HSTRING_CLEAR_EVAL_OR_ARGUMENTS(x)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
-#define DUK_HSTRING_CLEAR_EXTDATA(x)                DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
-#define DUK_HSTRING_CLEAR_PINNED_LITERAL(x)         DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
-
-#if 0  /* Slightly smaller code without explicit flag, but explicit flag
-        * is very useful when 'clen' is dropped.
-        */
-#define DUK_HSTRING_IS_ASCII(x)                     (DUK_HSTRING_GET_BYTELEN((x)) == DUK_HSTRING_GET_CHARLEN((x)))
+#define DUK_HSTRING_FLAG_ASCII  DUK_HEAPHDR_USER_FLAG(0) /* string is ASCII, clen == blen */
+#define DUK_HSTRING_FLAG_ARRIDX DUK_HEAPHDR_USER_FLAG(1) /* string is a valid array index */
+#define DUK_HSTRING_FLAG_SYMBOL DUK_HEAPHDR_USER_FLAG(2) /* string is a symbol (invalid utf-8) */
+#define DUK_HSTRING_FLAG_HIDDEN \
+	DUK_HEAPHDR_USER_FLAG(3) /* string is a hidden symbol (implies symbol, Duktape 1.x internal string) */
+#define DUK_HSTRING_FLAG_RESERVED_WORD        DUK_HEAPHDR_USER_FLAG(4) /* string is a reserved word (non-strict) */
+#define DUK_HSTRING_FLAG_STRICT_RESERVED_WORD DUK_HEAPHDR_USER_FLAG(5) /* string is a reserved word (strict) */
+#define DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS    DUK_HEAPHDR_USER_FLAG(6) /* string is 'eval' or 'arguments' */
+#define DUK_HSTRING_FLAG_EXTDATA              DUK_HEAPHDR_USER_FLAG(7) /* string data is external (duk_hstring_external) */
+#define DUK_HSTRING_FLAG_PINNED_LITERAL       DUK_HEAPHDR_USER_FLAG(8) /* string is a literal, and pinned */
+
+#define DUK_HSTRING_HAS_ASCII(x)                DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
+#define DUK_HSTRING_HAS_ARRIDX(x)               DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
+#define DUK_HSTRING_HAS_SYMBOL(x)               DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
+#define DUK_HSTRING_HAS_HIDDEN(x)               DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
+#define DUK_HSTRING_HAS_RESERVED_WORD(x)        DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
+#define DUK_HSTRING_HAS_STRICT_RESERVED_WORD(x) DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
+#define DUK_HSTRING_HAS_EVAL_OR_ARGUMENTS(x)    DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
+#define DUK_HSTRING_HAS_EXTDATA(x)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
+#define DUK_HSTRING_HAS_PINNED_LITERAL(x)       DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
+
+#define DUK_HSTRING_SET_ASCII(x)                DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
+#define DUK_HSTRING_SET_ARRIDX(x)               DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
+#define DUK_HSTRING_SET_SYMBOL(x)               DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
+#define DUK_HSTRING_SET_HIDDEN(x)               DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
+#define DUK_HSTRING_SET_RESERVED_WORD(x)        DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
+#define DUK_HSTRING_SET_STRICT_RESERVED_WORD(x) DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
+#define DUK_HSTRING_SET_EVAL_OR_ARGUMENTS(x)    DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
+#define DUK_HSTRING_SET_EXTDATA(x)              DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
+#define DUK_HSTRING_SET_PINNED_LITERAL(x)       DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
+
+#define DUK_HSTRING_CLEAR_ASCII(x)                DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ASCII)
+#define DUK_HSTRING_CLEAR_ARRIDX(x)               DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_ARRIDX)
+#define DUK_HSTRING_CLEAR_SYMBOL(x)               DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_SYMBOL)
+#define DUK_HSTRING_CLEAR_HIDDEN(x)               DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_HIDDEN)
+#define DUK_HSTRING_CLEAR_RESERVED_WORD(x)        DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_RESERVED_WORD)
+#define DUK_HSTRING_CLEAR_STRICT_RESERVED_WORD(x) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_STRICT_RESERVED_WORD)
+#define DUK_HSTRING_CLEAR_EVAL_OR_ARGUMENTS(x)    DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS)
+#define DUK_HSTRING_CLEAR_EXTDATA(x)              DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_EXTDATA)
+#define DUK_HSTRING_CLEAR_PINNED_LITERAL(x)       DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HSTRING_FLAG_PINNED_LITERAL)
+
+#if 0 /* Slightly smaller code without explicit flag, but explicit flag \
+       * is very useful when 'clen' is dropped. \
+       */
+#define DUK_HSTRING_IS_ASCII(x) (DUK_HSTRING_GET_BYTELEN((x)) == DUK_HSTRING_GET_CHARLEN((x)))
 #endif
-#define DUK_HSTRING_IS_ASCII(x)                     DUK_HSTRING_HAS_ASCII((x))  /* lazily set! */
-#define DUK_HSTRING_IS_EMPTY(x)                     (DUK_HSTRING_GET_BYTELEN((x)) == 0)
+#define DUK_HSTRING_IS_ASCII(x) DUK_HSTRING_HAS_ASCII((x)) /* lazily set! */
+#define DUK_HSTRING_IS_EMPTY(x) (DUK_HSTRING_GET_BYTELEN((x)) == 0)
 
 #if defined(DUK_USE_STRHASH16)
-#define DUK_HSTRING_GET_HASH(x)                     ((x)->hdr.h_flags >> 16)
-#define DUK_HSTRING_SET_HASH(x,v) do { \
+#define DUK_HSTRING_GET_HASH(x) ((x)->hdr.h_flags >> 16)
+#define DUK_HSTRING_SET_HASH(x, v) \
+	do { \
 		(x)->hdr.h_flags = ((x)->hdr.h_flags & 0x0000ffffUL) | ((v) << 16); \
 	} while (0)
 #else
-#define DUK_HSTRING_GET_HASH(x)                     ((x)->hash)
-#define DUK_HSTRING_SET_HASH(x,v) do { \
+#define DUK_HSTRING_GET_HASH(x) ((x)->hash)
+#define DUK_HSTRING_SET_HASH(x, v) \
+	do { \
 		(x)->hash = (v); \
 	} while (0)
 #endif
 
 #if defined(DUK_USE_STRLEN16)
-#define DUK_HSTRING_GET_BYTELEN(x)                  ((x)->hdr.h_strextra16)
-#define DUK_HSTRING_SET_BYTELEN(x,v) do { \
+#define DUK_HSTRING_GET_BYTELEN(x) ((x)->hdr.h_strextra16)
+#define DUK_HSTRING_SET_BYTELEN(x, v) \
+	do { \
 		(x)->hdr.h_strextra16 = (v); \
 	} while (0)
 #if defined(DUK_USE_HSTRING_CLEN)
-#define DUK_HSTRING_GET_CHARLEN(x)                  duk_hstring_get_charlen((x))
-#define DUK_HSTRING_SET_CHARLEN(x,v) do { \
+#define DUK_HSTRING_GET_CHARLEN(x) duk_hstring_get_charlen((x))
+#define DUK_HSTRING_SET_CHARLEN(x, v) \
+	do { \
 		(x)->clen16 = (v); \
 	} while (0)
 #else
-#define DUK_HSTRING_GET_CHARLEN(x)                  duk_hstring_get_charlen((x))
-#define DUK_HSTRING_SET_CHARLEN(x,v) do { \
-		DUK_ASSERT(0);  /* should never be called */ \
+#define DUK_HSTRING_GET_CHARLEN(x) duk_hstring_get_charlen((x))
+#define DUK_HSTRING_SET_CHARLEN(x, v) \
+	do { \
+		DUK_ASSERT(0); /* should never be called */ \
 	} while (0)
 #endif
 #else
-#define DUK_HSTRING_GET_BYTELEN(x)                  ((x)->blen)
-#define DUK_HSTRING_SET_BYTELEN(x,v) do { \
+#define DUK_HSTRING_GET_BYTELEN(x) ((x)->blen)
+#define DUK_HSTRING_SET_BYTELEN(x, v) \
+	do { \
 		(x)->blen = (v); \
 	} while (0)
-#define DUK_HSTRING_GET_CHARLEN(x)                  duk_hstring_get_charlen((x))
-#define DUK_HSTRING_SET_CHARLEN(x,v) do { \
+#define DUK_HSTRING_GET_CHARLEN(x) duk_hstring_get_charlen((x))
+#define DUK_HSTRING_SET_CHARLEN(x, v) \
+	do { \
 		(x)->clen = (v); \
 	} while (0)
 #endif
 
 #if defined(DUK_USE_HSTRING_EXTDATA)
-#define DUK_HSTRING_GET_EXTDATA(x) \
-	((x)->extdata)
+#define DUK_HSTRING_GET_EXTDATA(x) ((x)->extdata)
 #define DUK_HSTRING_GET_DATA(x) \
-	(DUK_HSTRING_HAS_EXTDATA((x)) ? \
-		DUK_HSTRING_GET_EXTDATA((const duk_hstring_external *) (x)) : ((const duk_uint8_t *) ((x) + 1)))
+	(DUK_HSTRING_HAS_EXTDATA((x)) ? DUK_HSTRING_GET_EXTDATA((const duk_hstring_external *) (x)) : \
+                                        ((const duk_uint8_t *) ((x) + 1)))
 #else
-#define DUK_HSTRING_GET_DATA(x) \
-	((const duk_uint8_t *) ((x) + 1))
+#define DUK_HSTRING_GET_DATA(x) ((const duk_uint8_t *) ((x) + 1))
 #endif
 
-#define DUK_HSTRING_GET_DATA_END(x) \
-	(DUK_HSTRING_GET_DATA((x)) + (x)->blen)
+#define DUK_HSTRING_GET_DATA_END(x) (DUK_HSTRING_GET_DATA((x)) + (x)->blen)
 
 /* Marker value; in E5 2^32-1 is not a valid array index (2^32-2 is highest
  * valid).
  */
-#define DUK_HSTRING_NO_ARRAY_INDEX  (0xffffffffUL)
+#define DUK_HSTRING_NO_ARRAY_INDEX (0xffffffffUL)
 
 #if defined(DUK_USE_HSTRING_ARRIDX)
-#define DUK_HSTRING_GET_ARRIDX_FAST(h)  ((h)->arridx)
-#define DUK_HSTRING_GET_ARRIDX_SLOW(h)  ((h)->arridx)
+#define DUK_HSTRING_GET_ARRIDX_FAST(h) ((h)->arridx)
+#define DUK_HSTRING_GET_ARRIDX_SLOW(h) ((h)->arridx)
 #else
 /* Get array index related to string (or return DUK_HSTRING_NO_ARRAY_INDEX);
  * avoids helper call if string has no array index value.
  */
-#define DUK_HSTRING_GET_ARRIDX_FAST(h)  \
+#define DUK_HSTRING_GET_ARRIDX_FAST(h) \
 	(DUK_HSTRING_HAS_ARRIDX((h)) ? duk_js_to_arrayindex_hstring_fast_known((h)) : DUK_HSTRING_NO_ARRAY_INDEX)
 
 /* Slower but more compact variant. */
-#define DUK_HSTRING_GET_ARRIDX_SLOW(h)  \
-	(duk_js_to_arrayindex_hstring_fast((h)))
+#define DUK_HSTRING_GET_ARRIDX_SLOW(h) (duk_js_to_arrayindex_hstring_fast((h)))
 #endif
 
 /* XXX: these actually fit into duk_hstring */
-#define DUK_SYMBOL_TYPE_HIDDEN 0
-#define DUK_SYMBOL_TYPE_GLOBAL 1
-#define DUK_SYMBOL_TYPE_LOCAL 2
+#define DUK_SYMBOL_TYPE_HIDDEN    0
+#define DUK_SYMBOL_TYPE_GLOBAL    1
+#define DUK_SYMBOL_TYPE_LOCAL     2
 #define DUK_SYMBOL_TYPE_WELLKNOWN 3
 
 /* Assertion for duk_hstring validity. */
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hstring_assert_valid(duk_hstring *h);
-#define DUK_HSTRING_ASSERT_VALID(h)  do { duk_hstring_assert_valid((h)); } while (0)
+#define DUK_HSTRING_ASSERT_VALID(h) \
+	do { \
+		duk_hstring_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HSTRING_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HSTRING_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Misc
  */
 
 struct duk_hstring {
@@ -6127,22 +6550,25 @@
 	const duk_uint8_t *extdata;
 };
 
 /*
  *  Prototypes
  */
 
-DUK_INTERNAL_DECL duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr, duk_hstring *h, duk_uint_t pos, duk_bool_t surrogate_aware);
+DUK_INTERNAL_DECL duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr,
+                                                                duk_hstring *h,
+                                                                duk_uint_t pos,
+                                                                duk_bool_t surrogate_aware);
 DUK_INTERNAL_DECL duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr);
 DUK_INTERNAL_DECL duk_size_t duk_hstring_get_charlen(duk_hstring *h);
 #if !defined(DUK_USE_HSTRING_LAZY_CLEN)
 DUK_INTERNAL_DECL void duk_hstring_init_charlen(duk_hstring *h);
 #endif
 
-#endif  /* DUK_HSTRING_H_INCLUDED */
+#endif /* DUK_HSTRING_H_INCLUDED */
 /* #include duk_hobject.h */
 #line 1 "duk_hobject.h"
 /*
  *  Heap object representation.
  *
  *  Heap objects are used for ECMAScript objects, arrays, and functions,
  *  but also for internal control like declarative and object environment
@@ -6178,366 +6604,347 @@
 /* Object flags.  Make sure this stays in sync with debugger object
  * inspection code.
  */
 
 /* XXX: some flags are object subtype specific (e.g. common to all function
  * subtypes, duk_harray, etc) and could be reused for different subtypes.
  */
-#define DUK_HOBJECT_FLAG_EXTENSIBLE            DUK_HEAPHDR_USER_FLAG(0)   /* object is extensible */
-#define DUK_HOBJECT_FLAG_CONSTRUCTABLE         DUK_HEAPHDR_USER_FLAG(1)   /* object is constructable */
-#define DUK_HOBJECT_FLAG_CALLABLE              DUK_HEAPHDR_USER_FLAG(2)   /* object is callable */
-#define DUK_HOBJECT_FLAG_BOUNDFUNC             DUK_HEAPHDR_USER_FLAG(3)   /* object established using Function.prototype.bind() */
-#define DUK_HOBJECT_FLAG_COMPFUNC              DUK_HEAPHDR_USER_FLAG(4)   /* object is a compiled function (duk_hcompfunc) */
-#define DUK_HOBJECT_FLAG_NATFUNC               DUK_HEAPHDR_USER_FLAG(5)   /* object is a native function (duk_hnatfunc) */
-#define DUK_HOBJECT_FLAG_BUFOBJ                DUK_HEAPHDR_USER_FLAG(6)   /* object is a buffer object (duk_hbufobj) (always exotic) */
-#define DUK_HOBJECT_FLAG_FASTREFS              DUK_HEAPHDR_USER_FLAG(7)   /* object has no fields needing DECREF/marking beyond base duk_hobject header */
-#define DUK_HOBJECT_FLAG_ARRAY_PART            DUK_HEAPHDR_USER_FLAG(8)   /* object has an array part (a_size may still be 0) */
-#define DUK_HOBJECT_FLAG_STRICT                DUK_HEAPHDR_USER_FLAG(9)   /* function: function object is strict */
-#define DUK_HOBJECT_FLAG_NOTAIL                DUK_HEAPHDR_USER_FLAG(10)  /* function: function must not be tail called */
-#define DUK_HOBJECT_FLAG_NEWENV                DUK_HEAPHDR_USER_FLAG(11)  /* function: create new environment when called (see duk_hcompfunc) */
-#define DUK_HOBJECT_FLAG_NAMEBINDING           DUK_HEAPHDR_USER_FLAG(12)  /* function: create binding for func name (function templates only, used for named function expressions) */
-#define DUK_HOBJECT_FLAG_CREATEARGS            DUK_HEAPHDR_USER_FLAG(13)  /* function: create an arguments object on function call */
-#define DUK_HOBJECT_FLAG_HAVE_FINALIZER        DUK_HEAPHDR_USER_FLAG(14)  /* object has a callable (own) finalizer property */
-#define DUK_HOBJECT_FLAG_EXOTIC_ARRAY          DUK_HEAPHDR_USER_FLAG(15)  /* 'Array' object, array length and index exotic behavior */
-#define DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ      DUK_HEAPHDR_USER_FLAG(16)  /* 'String' object, array index exotic behavior */
-#define DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS      DUK_HEAPHDR_USER_FLAG(17)  /* 'Arguments' object and has arguments exotic behavior (non-strict callee) */
-#define DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ       DUK_HEAPHDR_USER_FLAG(18)  /* 'Proxy' object */
-#define DUK_HOBJECT_FLAG_SPECIAL_CALL          DUK_HEAPHDR_USER_FLAG(19)  /* special casing in call behavior, for .call(), .apply(), etc. */
+#define DUK_HOBJECT_FLAG_EXTENSIBLE    DUK_HEAPHDR_USER_FLAG(0) /* object is extensible */
+#define DUK_HOBJECT_FLAG_CONSTRUCTABLE DUK_HEAPHDR_USER_FLAG(1) /* object is constructable */
+#define DUK_HOBJECT_FLAG_CALLABLE      DUK_HEAPHDR_USER_FLAG(2) /* object is callable */
+#define DUK_HOBJECT_FLAG_BOUNDFUNC     DUK_HEAPHDR_USER_FLAG(3) /* object established using Function.prototype.bind() */
+#define DUK_HOBJECT_FLAG_COMPFUNC      DUK_HEAPHDR_USER_FLAG(4) /* object is a compiled function (duk_hcompfunc) */
+#define DUK_HOBJECT_FLAG_NATFUNC       DUK_HEAPHDR_USER_FLAG(5) /* object is a native function (duk_hnatfunc) */
+#define DUK_HOBJECT_FLAG_BUFOBJ        DUK_HEAPHDR_USER_FLAG(6) /* object is a buffer object (duk_hbufobj) (always exotic) */
+#define DUK_HOBJECT_FLAG_FASTREFS \
+	DUK_HEAPHDR_USER_FLAG(7) /* object has no fields needing DECREF/marking beyond base duk_hobject header */
+#define DUK_HOBJECT_FLAG_ARRAY_PART DUK_HEAPHDR_USER_FLAG(8) /* object has an array part (a_size may still be 0) */
+#define DUK_HOBJECT_FLAG_STRICT     DUK_HEAPHDR_USER_FLAG(9) /* function: function object is strict */
+#define DUK_HOBJECT_FLAG_NOTAIL     DUK_HEAPHDR_USER_FLAG(10) /* function: function must not be tail called */
+#define DUK_HOBJECT_FLAG_NEWENV     DUK_HEAPHDR_USER_FLAG(11) /* function: create new environment when called (see duk_hcompfunc) */
+#define DUK_HOBJECT_FLAG_NAMEBINDING \
+	DUK_HEAPHDR_USER_FLAG( \
+	    12) /* function: create binding for func name (function templates only, used for named function expressions) */
+#define DUK_HOBJECT_FLAG_CREATEARGS       DUK_HEAPHDR_USER_FLAG(13) /* function: create an arguments object on function call */
+#define DUK_HOBJECT_FLAG_HAVE_FINALIZER   DUK_HEAPHDR_USER_FLAG(14) /* object has a callable (own) finalizer property */
+#define DUK_HOBJECT_FLAG_EXOTIC_ARRAY     DUK_HEAPHDR_USER_FLAG(15) /* 'Array' object, array length and index exotic behavior */
+#define DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ DUK_HEAPHDR_USER_FLAG(16) /* 'String' object, array index exotic behavior */
+#define DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS \
+	DUK_HEAPHDR_USER_FLAG(17) /* 'Arguments' object and has arguments exotic behavior (non-strict callee) */
+#define DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ DUK_HEAPHDR_USER_FLAG(18) /* 'Proxy' object */
+#define DUK_HOBJECT_FLAG_SPECIAL_CALL    DUK_HEAPHDR_USER_FLAG(19) /* special casing in call behavior, for .call(), .apply(), etc. */
 
-#define DUK_HOBJECT_FLAG_CLASS_BASE            DUK_HEAPHDR_USER_FLAG_NUMBER(20)
-#define DUK_HOBJECT_FLAG_CLASS_BITS            5
+#define DUK_HOBJECT_FLAG_CLASS_BASE DUK_HEAPHDR_USER_FLAG_NUMBER(20)
+#define DUK_HOBJECT_FLAG_CLASS_BITS 5
 
-#define DUK_HOBJECT_GET_CLASS_NUMBER(h)        \
+#define DUK_HOBJECT_GET_CLASS_NUMBER(h) \
 	DUK_HEAPHDR_GET_FLAG_RANGE(&(h)->hdr, DUK_HOBJECT_FLAG_CLASS_BASE, DUK_HOBJECT_FLAG_CLASS_BITS)
-#define DUK_HOBJECT_SET_CLASS_NUMBER(h,v)      \
+#define DUK_HOBJECT_SET_CLASS_NUMBER(h, v) \
 	DUK_HEAPHDR_SET_FLAG_RANGE(&(h)->hdr, DUK_HOBJECT_FLAG_CLASS_BASE, DUK_HOBJECT_FLAG_CLASS_BITS, (v))
 
-#define DUK_HOBJECT_GET_CLASS_MASK(h)          \
+#define DUK_HOBJECT_GET_CLASS_MASK(h) \
 	(1UL << DUK_HEAPHDR_GET_FLAG_RANGE(&(h)->hdr, DUK_HOBJECT_FLAG_CLASS_BASE, DUK_HOBJECT_FLAG_CLASS_BITS))
 
 /* Macro for creating flag initializer from a class number.
  * Unsigned type cast is needed to avoid warnings about coercing
  * a signed integer to an unsigned one; the largest class values
  * have the highest bit (bit 31) set which causes this.
  */
-#define DUK_HOBJECT_CLASS_AS_FLAGS(v)          (((duk_uint_t) (v)) << DUK_HOBJECT_FLAG_CLASS_BASE)
+#define DUK_HOBJECT_CLASS_AS_FLAGS(v) (((duk_uint_t) (v)) << DUK_HOBJECT_FLAG_CLASS_BASE)
 
 /* E5 Section 8.6.2 + custom classes */
-#define DUK_HOBJECT_CLASS_NONE                 0
-#define DUK_HOBJECT_CLASS_OBJECT               1
-#define DUK_HOBJECT_CLASS_ARRAY                2
-#define DUK_HOBJECT_CLASS_FUNCTION             3
-#define DUK_HOBJECT_CLASS_ARGUMENTS            4
-#define DUK_HOBJECT_CLASS_BOOLEAN              5
-#define DUK_HOBJECT_CLASS_DATE                 6
-#define DUK_HOBJECT_CLASS_ERROR                7
-#define DUK_HOBJECT_CLASS_JSON                 8
-#define DUK_HOBJECT_CLASS_MATH                 9
-#define DUK_HOBJECT_CLASS_NUMBER               10
-#define DUK_HOBJECT_CLASS_REGEXP               11
-#define DUK_HOBJECT_CLASS_STRING               12
-#define DUK_HOBJECT_CLASS_GLOBAL               13
-#define DUK_HOBJECT_CLASS_SYMBOL               14
-#define DUK_HOBJECT_CLASS_OBJENV               15  /* custom */
-#define DUK_HOBJECT_CLASS_DECENV               16  /* custom */
-#define DUK_HOBJECT_CLASS_POINTER              17  /* custom */
-#define DUK_HOBJECT_CLASS_THREAD               18  /* custom; implies DUK_HOBJECT_IS_THREAD */
-#define DUK_HOBJECT_CLASS_BUFOBJ_MIN           19
-#define DUK_HOBJECT_CLASS_ARRAYBUFFER          19  /* implies DUK_HOBJECT_IS_BUFOBJ */
-#define DUK_HOBJECT_CLASS_DATAVIEW             20
-#define DUK_HOBJECT_CLASS_INT8ARRAY            21
-#define DUK_HOBJECT_CLASS_UINT8ARRAY           22
-#define DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY    23
-#define DUK_HOBJECT_CLASS_INT16ARRAY           24
-#define DUK_HOBJECT_CLASS_UINT16ARRAY          25
-#define DUK_HOBJECT_CLASS_INT32ARRAY           26
-#define DUK_HOBJECT_CLASS_UINT32ARRAY          27
-#define DUK_HOBJECT_CLASS_FLOAT32ARRAY         28
-#define DUK_HOBJECT_CLASS_FLOAT64ARRAY         29
-#define DUK_HOBJECT_CLASS_BUFOBJ_MAX           29
-#define DUK_HOBJECT_CLASS_MAX                  29
+#define DUK_HOBJECT_CLASS_NONE              0
+#define DUK_HOBJECT_CLASS_OBJECT            1
+#define DUK_HOBJECT_CLASS_ARRAY             2
+#define DUK_HOBJECT_CLASS_FUNCTION          3
+#define DUK_HOBJECT_CLASS_ARGUMENTS         4
+#define DUK_HOBJECT_CLASS_BOOLEAN           5
+#define DUK_HOBJECT_CLASS_DATE              6
+#define DUK_HOBJECT_CLASS_ERROR             7
+#define DUK_HOBJECT_CLASS_JSON              8
+#define DUK_HOBJECT_CLASS_MATH              9
+#define DUK_HOBJECT_CLASS_NUMBER            10
+#define DUK_HOBJECT_CLASS_REGEXP            11
+#define DUK_HOBJECT_CLASS_STRING            12
+#define DUK_HOBJECT_CLASS_GLOBAL            13
+#define DUK_HOBJECT_CLASS_SYMBOL            14
+#define DUK_HOBJECT_CLASS_OBJENV            15 /* custom */
+#define DUK_HOBJECT_CLASS_DECENV            16 /* custom */
+#define DUK_HOBJECT_CLASS_POINTER           17 /* custom */
+#define DUK_HOBJECT_CLASS_THREAD            18 /* custom; implies DUK_HOBJECT_IS_THREAD */
+#define DUK_HOBJECT_CLASS_BUFOBJ_MIN        19
+#define DUK_HOBJECT_CLASS_ARRAYBUFFER       19 /* implies DUK_HOBJECT_IS_BUFOBJ */
+#define DUK_HOBJECT_CLASS_DATAVIEW          20
+#define DUK_HOBJECT_CLASS_INT8ARRAY         21
+#define DUK_HOBJECT_CLASS_UINT8ARRAY        22
+#define DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY 23
+#define DUK_HOBJECT_CLASS_INT16ARRAY        24
+#define DUK_HOBJECT_CLASS_UINT16ARRAY       25
+#define DUK_HOBJECT_CLASS_INT32ARRAY        26
+#define DUK_HOBJECT_CLASS_UINT32ARRAY       27
+#define DUK_HOBJECT_CLASS_FLOAT32ARRAY      28
+#define DUK_HOBJECT_CLASS_FLOAT64ARRAY      29
+#define DUK_HOBJECT_CLASS_BUFOBJ_MAX        29
+#define DUK_HOBJECT_CLASS_MAX               29
 
 /* Class masks. */
-#define DUK_HOBJECT_CMASK_ALL                  ((1UL << (DUK_HOBJECT_CLASS_MAX + 1)) - 1UL)
-#define DUK_HOBJECT_CMASK_NONE                 (1UL << DUK_HOBJECT_CLASS_NONE)
-#define DUK_HOBJECT_CMASK_ARGUMENTS            (1UL << DUK_HOBJECT_CLASS_ARGUMENTS)
-#define DUK_HOBJECT_CMASK_ARRAY                (1UL << DUK_HOBJECT_CLASS_ARRAY)
-#define DUK_HOBJECT_CMASK_BOOLEAN              (1UL << DUK_HOBJECT_CLASS_BOOLEAN)
-#define DUK_HOBJECT_CMASK_DATE                 (1UL << DUK_HOBJECT_CLASS_DATE)
-#define DUK_HOBJECT_CMASK_ERROR                (1UL << DUK_HOBJECT_CLASS_ERROR)
-#define DUK_HOBJECT_CMASK_FUNCTION             (1UL << DUK_HOBJECT_CLASS_FUNCTION)
-#define DUK_HOBJECT_CMASK_JSON                 (1UL << DUK_HOBJECT_CLASS_JSON)
-#define DUK_HOBJECT_CMASK_MATH                 (1UL << DUK_HOBJECT_CLASS_MATH)
-#define DUK_HOBJECT_CMASK_NUMBER               (1UL << DUK_HOBJECT_CLASS_NUMBER)
-#define DUK_HOBJECT_CMASK_OBJECT               (1UL << DUK_HOBJECT_CLASS_OBJECT)
-#define DUK_HOBJECT_CMASK_REGEXP               (1UL << DUK_HOBJECT_CLASS_REGEXP)
-#define DUK_HOBJECT_CMASK_STRING               (1UL << DUK_HOBJECT_CLASS_STRING)
-#define DUK_HOBJECT_CMASK_GLOBAL               (1UL << DUK_HOBJECT_CLASS_GLOBAL)
-#define DUK_HOBJECT_CMASK_SYMBOL               (1UL << DUK_HOBJECT_CLASS_SYMBOL)
-#define DUK_HOBJECT_CMASK_OBJENV               (1UL << DUK_HOBJECT_CLASS_OBJENV)
-#define DUK_HOBJECT_CMASK_DECENV               (1UL << DUK_HOBJECT_CLASS_DECENV)
-#define DUK_HOBJECT_CMASK_POINTER              (1UL << DUK_HOBJECT_CLASS_POINTER)
-#define DUK_HOBJECT_CMASK_ARRAYBUFFER          (1UL << DUK_HOBJECT_CLASS_ARRAYBUFFER)
-#define DUK_HOBJECT_CMASK_DATAVIEW             (1UL << DUK_HOBJECT_CLASS_DATAVIEW)
-#define DUK_HOBJECT_CMASK_INT8ARRAY            (1UL << DUK_HOBJECT_CLASS_INT8ARRAY)
-#define DUK_HOBJECT_CMASK_UINT8ARRAY           (1UL << DUK_HOBJECT_CLASS_UINT8ARRAY)
-#define DUK_HOBJECT_CMASK_UINT8CLAMPEDARRAY    (1UL << DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY)
-#define DUK_HOBJECT_CMASK_INT16ARRAY           (1UL << DUK_HOBJECT_CLASS_INT16ARRAY)
-#define DUK_HOBJECT_CMASK_UINT16ARRAY          (1UL << DUK_HOBJECT_CLASS_UINT16ARRAY)
-#define DUK_HOBJECT_CMASK_INT32ARRAY           (1UL << DUK_HOBJECT_CLASS_INT32ARRAY)
-#define DUK_HOBJECT_CMASK_UINT32ARRAY          (1UL << DUK_HOBJECT_CLASS_UINT32ARRAY)
-#define DUK_HOBJECT_CMASK_FLOAT32ARRAY         (1UL << DUK_HOBJECT_CLASS_FLOAT32ARRAY)
-#define DUK_HOBJECT_CMASK_FLOAT64ARRAY         (1UL << DUK_HOBJECT_CLASS_FLOAT64ARRAY)
+#define DUK_HOBJECT_CMASK_ALL               ((1UL << (DUK_HOBJECT_CLASS_MAX + 1)) - 1UL)
+#define DUK_HOBJECT_CMASK_NONE              (1UL << DUK_HOBJECT_CLASS_NONE)
+#define DUK_HOBJECT_CMASK_ARGUMENTS         (1UL << DUK_HOBJECT_CLASS_ARGUMENTS)
+#define DUK_HOBJECT_CMASK_ARRAY             (1UL << DUK_HOBJECT_CLASS_ARRAY)
+#define DUK_HOBJECT_CMASK_BOOLEAN           (1UL << DUK_HOBJECT_CLASS_BOOLEAN)
+#define DUK_HOBJECT_CMASK_DATE              (1UL << DUK_HOBJECT_CLASS_DATE)
+#define DUK_HOBJECT_CMASK_ERROR             (1UL << DUK_HOBJECT_CLASS_ERROR)
+#define DUK_HOBJECT_CMASK_FUNCTION          (1UL << DUK_HOBJECT_CLASS_FUNCTION)
+#define DUK_HOBJECT_CMASK_JSON              (1UL << DUK_HOBJECT_CLASS_JSON)
+#define DUK_HOBJECT_CMASK_MATH              (1UL << DUK_HOBJECT_CLASS_MATH)
+#define DUK_HOBJECT_CMASK_NUMBER            (1UL << DUK_HOBJECT_CLASS_NUMBER)
+#define DUK_HOBJECT_CMASK_OBJECT            (1UL << DUK_HOBJECT_CLASS_OBJECT)
+#define DUK_HOBJECT_CMASK_REGEXP            (1UL << DUK_HOBJECT_CLASS_REGEXP)
+#define DUK_HOBJECT_CMASK_STRING            (1UL << DUK_HOBJECT_CLASS_STRING)
+#define DUK_HOBJECT_CMASK_GLOBAL            (1UL << DUK_HOBJECT_CLASS_GLOBAL)
+#define DUK_HOBJECT_CMASK_SYMBOL            (1UL << DUK_HOBJECT_CLASS_SYMBOL)
+#define DUK_HOBJECT_CMASK_OBJENV            (1UL << DUK_HOBJECT_CLASS_OBJENV)
+#define DUK_HOBJECT_CMASK_DECENV            (1UL << DUK_HOBJECT_CLASS_DECENV)
+#define DUK_HOBJECT_CMASK_POINTER           (1UL << DUK_HOBJECT_CLASS_POINTER)
+#define DUK_HOBJECT_CMASK_ARRAYBUFFER       (1UL << DUK_HOBJECT_CLASS_ARRAYBUFFER)
+#define DUK_HOBJECT_CMASK_DATAVIEW          (1UL << DUK_HOBJECT_CLASS_DATAVIEW)
+#define DUK_HOBJECT_CMASK_INT8ARRAY         (1UL << DUK_HOBJECT_CLASS_INT8ARRAY)
+#define DUK_HOBJECT_CMASK_UINT8ARRAY        (1UL << DUK_HOBJECT_CLASS_UINT8ARRAY)
+#define DUK_HOBJECT_CMASK_UINT8CLAMPEDARRAY (1UL << DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY)
+#define DUK_HOBJECT_CMASK_INT16ARRAY        (1UL << DUK_HOBJECT_CLASS_INT16ARRAY)
+#define DUK_HOBJECT_CMASK_UINT16ARRAY       (1UL << DUK_HOBJECT_CLASS_UINT16ARRAY)
+#define DUK_HOBJECT_CMASK_INT32ARRAY        (1UL << DUK_HOBJECT_CLASS_INT32ARRAY)
+#define DUK_HOBJECT_CMASK_UINT32ARRAY       (1UL << DUK_HOBJECT_CLASS_UINT32ARRAY)
+#define DUK_HOBJECT_CMASK_FLOAT32ARRAY      (1UL << DUK_HOBJECT_CLASS_FLOAT32ARRAY)
+#define DUK_HOBJECT_CMASK_FLOAT64ARRAY      (1UL << DUK_HOBJECT_CLASS_FLOAT64ARRAY)
 
 #define DUK_HOBJECT_CMASK_ALL_BUFOBJS \
-	(DUK_HOBJECT_CMASK_ARRAYBUFFER | \
-	 DUK_HOBJECT_CMASK_DATAVIEW | \
-	 DUK_HOBJECT_CMASK_INT8ARRAY | \
-	 DUK_HOBJECT_CMASK_UINT8ARRAY | \
-	 DUK_HOBJECT_CMASK_UINT8CLAMPEDARRAY | \
-	 DUK_HOBJECT_CMASK_INT16ARRAY | \
-	 DUK_HOBJECT_CMASK_UINT16ARRAY | \
-	 DUK_HOBJECT_CMASK_INT32ARRAY | \
-	 DUK_HOBJECT_CMASK_UINT32ARRAY | \
-	 DUK_HOBJECT_CMASK_FLOAT32ARRAY | \
+	(DUK_HOBJECT_CMASK_ARRAYBUFFER | DUK_HOBJECT_CMASK_DATAVIEW | DUK_HOBJECT_CMASK_INT8ARRAY | DUK_HOBJECT_CMASK_UINT8ARRAY | \
+	 DUK_HOBJECT_CMASK_UINT8CLAMPEDARRAY | DUK_HOBJECT_CMASK_INT16ARRAY | DUK_HOBJECT_CMASK_UINT16ARRAY | \
+	 DUK_HOBJECT_CMASK_INT32ARRAY | DUK_HOBJECT_CMASK_UINT32ARRAY | DUK_HOBJECT_CMASK_FLOAT32ARRAY | \
 	 DUK_HOBJECT_CMASK_FLOAT64ARRAY)
 
-#define DUK_HOBJECT_IS_OBJENV(h)               (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_OBJENV)
-#define DUK_HOBJECT_IS_DECENV(h)               (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_DECENV)
-#define DUK_HOBJECT_IS_ENV(h)                  (DUK_HOBJECT_IS_OBJENV((h)) || DUK_HOBJECT_IS_DECENV((h)))
-#define DUK_HOBJECT_IS_ARRAY(h)                DUK_HOBJECT_HAS_EXOTIC_ARRAY((h))  /* Rely on class Array <=> exotic Array */
-#define DUK_HOBJECT_IS_BOUNDFUNC(h)            DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
-#define DUK_HOBJECT_IS_COMPFUNC(h)             DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
-#define DUK_HOBJECT_IS_NATFUNC(h)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_IS_OBJENV(h)    (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_OBJENV)
+#define DUK_HOBJECT_IS_DECENV(h)    (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_DECENV)
+#define DUK_HOBJECT_IS_ENV(h)       (DUK_HOBJECT_IS_OBJENV((h)) || DUK_HOBJECT_IS_DECENV((h)))
+#define DUK_HOBJECT_IS_ARRAY(h)     DUK_HOBJECT_HAS_EXOTIC_ARRAY((h)) /* Rely on class Array <=> exotic Array */
+#define DUK_HOBJECT_IS_BOUNDFUNC(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
+#define DUK_HOBJECT_IS_COMPFUNC(h)  DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
+#define DUK_HOBJECT_IS_NATFUNC(h)   DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-#define DUK_HOBJECT_IS_BUFOBJ(h)               DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
+#define DUK_HOBJECT_IS_BUFOBJ(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
 #else
-#define DUK_HOBJECT_IS_BUFOBJ(h)               0
+#define DUK_HOBJECT_IS_BUFOBJ(h) 0
 #endif
-#define DUK_HOBJECT_IS_THREAD(h)               (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_THREAD)
+#define DUK_HOBJECT_IS_THREAD(h) (DUK_HOBJECT_GET_CLASS_NUMBER((h)) == DUK_HOBJECT_CLASS_THREAD)
 #if defined(DUK_USE_ES6_PROXY)
-#define DUK_HOBJECT_IS_PROXY(h)                DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ((h))
+#define DUK_HOBJECT_IS_PROXY(h) DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ((h))
 #else
-#define DUK_HOBJECT_IS_PROXY(h)                0
+#define DUK_HOBJECT_IS_PROXY(h) 0
 #endif
 
-#define DUK_HOBJECT_IS_NONBOUND_FUNCTION(h)    DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, \
-                                                        DUK_HOBJECT_FLAG_COMPFUNC | \
-                                                        DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_IS_NONBOUND_FUNCTION(h) \
+	DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC | DUK_HOBJECT_FLAG_NATFUNC)
 
-#define DUK_HOBJECT_IS_FUNCTION(h)             DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, \
-                                                        DUK_HOBJECT_FLAG_BOUNDFUNC | \
-                                                        DUK_HOBJECT_FLAG_COMPFUNC | \
-                                                        DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_IS_FUNCTION(h) \
+	DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC | DUK_HOBJECT_FLAG_COMPFUNC | DUK_HOBJECT_FLAG_NATFUNC)
 
-#define DUK_HOBJECT_IS_CALLABLE(h)             DUK_HOBJECT_HAS_CALLABLE((h))
+#define DUK_HOBJECT_IS_CALLABLE(h) DUK_HOBJECT_HAS_CALLABLE((h))
 
 /* Object has any exotic behavior(s). */
-#define DUK_HOBJECT_EXOTIC_BEHAVIOR_FLAGS      (DUK_HOBJECT_FLAG_EXOTIC_ARRAY | \
-                                                DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS | \
-                                                DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ | \
-                                                DUK_HOBJECT_FLAG_BUFOBJ | \
-                                                DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
-#define DUK_HOBJECT_HAS_EXOTIC_BEHAVIOR(h)     DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_EXOTIC_BEHAVIOR_FLAGS)
+#define DUK_HOBJECT_EXOTIC_BEHAVIOR_FLAGS \
+	(DUK_HOBJECT_FLAG_EXOTIC_ARRAY | DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS | DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ | \
+	 DUK_HOBJECT_FLAG_BUFOBJ | DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
+#define DUK_HOBJECT_HAS_EXOTIC_BEHAVIOR(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_EXOTIC_BEHAVIOR_FLAGS)
 
 /* Object has any virtual properties (not counting Proxy behavior). */
-#define DUK_HOBJECT_VIRTUAL_PROPERTY_FLAGS     (DUK_HOBJECT_FLAG_EXOTIC_ARRAY | \
-                                                DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ | \
-                                                DUK_HOBJECT_FLAG_BUFOBJ)
-#define DUK_HOBJECT_HAS_VIRTUAL_PROPERTIES(h)  DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_VIRTUAL_PROPERTY_FLAGS)
-
-#define DUK_HOBJECT_HAS_EXTENSIBLE(h)          DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
-#define DUK_HOBJECT_HAS_CONSTRUCTABLE(h)       DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
-#define DUK_HOBJECT_HAS_CALLABLE(h)            DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
-#define DUK_HOBJECT_HAS_BOUNDFUNC(h)           DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
-#define DUK_HOBJECT_HAS_COMPFUNC(h)            DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
-#define DUK_HOBJECT_HAS_NATFUNC(h)             DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_VIRTUAL_PROPERTY_FLAGS \
+	(DUK_HOBJECT_FLAG_EXOTIC_ARRAY | DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ | DUK_HOBJECT_FLAG_BUFOBJ)
+#define DUK_HOBJECT_HAS_VIRTUAL_PROPERTIES(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_VIRTUAL_PROPERTY_FLAGS)
+
+#define DUK_HOBJECT_HAS_EXTENSIBLE(h)    DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
+#define DUK_HOBJECT_HAS_CONSTRUCTABLE(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
+#define DUK_HOBJECT_HAS_CALLABLE(h)      DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
+#define DUK_HOBJECT_HAS_BOUNDFUNC(h)     DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
+#define DUK_HOBJECT_HAS_COMPFUNC(h)      DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
+#define DUK_HOBJECT_HAS_NATFUNC(h)       DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-#define DUK_HOBJECT_HAS_BUFOBJ(h)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
+#define DUK_HOBJECT_HAS_BUFOBJ(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
 #else
-#define DUK_HOBJECT_HAS_BUFOBJ(h)              0
+#define DUK_HOBJECT_HAS_BUFOBJ(h) 0
 #endif
-#define DUK_HOBJECT_HAS_FASTREFS(h)            DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
-#define DUK_HOBJECT_HAS_ARRAY_PART(h)          DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
-#define DUK_HOBJECT_HAS_STRICT(h)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
-#define DUK_HOBJECT_HAS_NOTAIL(h)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
-#define DUK_HOBJECT_HAS_NEWENV(h)              DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
-#define DUK_HOBJECT_HAS_NAMEBINDING(h)         DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
-#define DUK_HOBJECT_HAS_CREATEARGS(h)          DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
-#define DUK_HOBJECT_HAS_HAVE_FINALIZER(h)      DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
-#define DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)        DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
-#define DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(h)    DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
-#define DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(h)    DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
+#define DUK_HOBJECT_HAS_FASTREFS(h)         DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
+#define DUK_HOBJECT_HAS_ARRAY_PART(h)       DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
+#define DUK_HOBJECT_HAS_STRICT(h)           DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
+#define DUK_HOBJECT_HAS_NOTAIL(h)           DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
+#define DUK_HOBJECT_HAS_NEWENV(h)           DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
+#define DUK_HOBJECT_HAS_NAMEBINDING(h)      DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
+#define DUK_HOBJECT_HAS_CREATEARGS(h)       DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
+#define DUK_HOBJECT_HAS_HAVE_FINALIZER(h)   DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
+#define DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)     DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
+#define DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
+#define DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
 #if defined(DUK_USE_ES6_PROXY)
-#define DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(h)     DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
+#define DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
 #else
-#define DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(h)     0
+#define DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(h) 0
 #endif
-#define DUK_HOBJECT_HAS_SPECIAL_CALL(h)        DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
+#define DUK_HOBJECT_HAS_SPECIAL_CALL(h) DUK_HEAPHDR_CHECK_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
 
-#define DUK_HOBJECT_SET_EXTENSIBLE(h)          DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
-#define DUK_HOBJECT_SET_CONSTRUCTABLE(h)       DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
-#define DUK_HOBJECT_SET_CALLABLE(h)            DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
-#define DUK_HOBJECT_SET_BOUNDFUNC(h)           DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
-#define DUK_HOBJECT_SET_COMPFUNC(h)            DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
-#define DUK_HOBJECT_SET_NATFUNC(h)             DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_SET_EXTENSIBLE(h)    DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
+#define DUK_HOBJECT_SET_CONSTRUCTABLE(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
+#define DUK_HOBJECT_SET_CALLABLE(h)      DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
+#define DUK_HOBJECT_SET_BOUNDFUNC(h)     DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
+#define DUK_HOBJECT_SET_COMPFUNC(h)      DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
+#define DUK_HOBJECT_SET_NATFUNC(h)       DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-#define DUK_HOBJECT_SET_BUFOBJ(h)              DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
+#define DUK_HOBJECT_SET_BUFOBJ(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
 #endif
-#define DUK_HOBJECT_SET_FASTREFS(h)            DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
-#define DUK_HOBJECT_SET_ARRAY_PART(h)          DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
-#define DUK_HOBJECT_SET_STRICT(h)              DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
-#define DUK_HOBJECT_SET_NOTAIL(h)              DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
-#define DUK_HOBJECT_SET_NEWENV(h)              DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
-#define DUK_HOBJECT_SET_NAMEBINDING(h)         DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
-#define DUK_HOBJECT_SET_CREATEARGS(h)          DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
-#define DUK_HOBJECT_SET_HAVE_FINALIZER(h)      DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
-#define DUK_HOBJECT_SET_EXOTIC_ARRAY(h)        DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
-#define DUK_HOBJECT_SET_EXOTIC_STRINGOBJ(h)    DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
-#define DUK_HOBJECT_SET_EXOTIC_ARGUMENTS(h)    DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
+#define DUK_HOBJECT_SET_FASTREFS(h)         DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
+#define DUK_HOBJECT_SET_ARRAY_PART(h)       DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
+#define DUK_HOBJECT_SET_STRICT(h)           DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
+#define DUK_HOBJECT_SET_NOTAIL(h)           DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
+#define DUK_HOBJECT_SET_NEWENV(h)           DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
+#define DUK_HOBJECT_SET_NAMEBINDING(h)      DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
+#define DUK_HOBJECT_SET_CREATEARGS(h)       DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
+#define DUK_HOBJECT_SET_HAVE_FINALIZER(h)   DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
+#define DUK_HOBJECT_SET_EXOTIC_ARRAY(h)     DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
+#define DUK_HOBJECT_SET_EXOTIC_STRINGOBJ(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
+#define DUK_HOBJECT_SET_EXOTIC_ARGUMENTS(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
 #if defined(DUK_USE_ES6_PROXY)
-#define DUK_HOBJECT_SET_EXOTIC_PROXYOBJ(h)     DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
+#define DUK_HOBJECT_SET_EXOTIC_PROXYOBJ(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
 #endif
-#define DUK_HOBJECT_SET_SPECIAL_CALL(h)        DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
+#define DUK_HOBJECT_SET_SPECIAL_CALL(h) DUK_HEAPHDR_SET_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
 
-#define DUK_HOBJECT_CLEAR_EXTENSIBLE(h)        DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
-#define DUK_HOBJECT_CLEAR_CONSTRUCTABLE(h)     DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
-#define DUK_HOBJECT_CLEAR_CALLABLE(h)          DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
-#define DUK_HOBJECT_CLEAR_BOUNDFUNC(h)         DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
-#define DUK_HOBJECT_CLEAR_COMPFUNC(h)          DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
-#define DUK_HOBJECT_CLEAR_NATFUNC(h)           DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
+#define DUK_HOBJECT_CLEAR_EXTENSIBLE(h)    DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXTENSIBLE)
+#define DUK_HOBJECT_CLEAR_CONSTRUCTABLE(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CONSTRUCTABLE)
+#define DUK_HOBJECT_CLEAR_CALLABLE(h)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CALLABLE)
+#define DUK_HOBJECT_CLEAR_BOUNDFUNC(h)     DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BOUNDFUNC)
+#define DUK_HOBJECT_CLEAR_COMPFUNC(h)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_COMPFUNC)
+#define DUK_HOBJECT_CLEAR_NATFUNC(h)       DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NATFUNC)
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-#define DUK_HOBJECT_CLEAR_BUFOBJ(h)            DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
+#define DUK_HOBJECT_CLEAR_BUFOBJ(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_BUFOBJ)
 #endif
-#define DUK_HOBJECT_CLEAR_FASTREFS(h)          DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
-#define DUK_HOBJECT_CLEAR_ARRAY_PART(h)        DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
-#define DUK_HOBJECT_CLEAR_STRICT(h)            DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
-#define DUK_HOBJECT_CLEAR_NOTAIL(h)            DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
-#define DUK_HOBJECT_CLEAR_NEWENV(h)            DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
-#define DUK_HOBJECT_CLEAR_NAMEBINDING(h)       DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
-#define DUK_HOBJECT_CLEAR_CREATEARGS(h)        DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
-#define DUK_HOBJECT_CLEAR_HAVE_FINALIZER(h)    DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
-#define DUK_HOBJECT_CLEAR_EXOTIC_ARRAY(h)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
-#define DUK_HOBJECT_CLEAR_EXOTIC_STRINGOBJ(h)  DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
-#define DUK_HOBJECT_CLEAR_EXOTIC_ARGUMENTS(h)  DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
+#define DUK_HOBJECT_CLEAR_FASTREFS(h)         DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_FASTREFS)
+#define DUK_HOBJECT_CLEAR_ARRAY_PART(h)       DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_ARRAY_PART)
+#define DUK_HOBJECT_CLEAR_STRICT(h)           DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_STRICT)
+#define DUK_HOBJECT_CLEAR_NOTAIL(h)           DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NOTAIL)
+#define DUK_HOBJECT_CLEAR_NEWENV(h)           DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NEWENV)
+#define DUK_HOBJECT_CLEAR_NAMEBINDING(h)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_NAMEBINDING)
+#define DUK_HOBJECT_CLEAR_CREATEARGS(h)       DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_CREATEARGS)
+#define DUK_HOBJECT_CLEAR_HAVE_FINALIZER(h)   DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_HAVE_FINALIZER)
+#define DUK_HOBJECT_CLEAR_EXOTIC_ARRAY(h)     DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARRAY)
+#define DUK_HOBJECT_CLEAR_EXOTIC_STRINGOBJ(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ)
+#define DUK_HOBJECT_CLEAR_EXOTIC_ARGUMENTS(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS)
 #if defined(DUK_USE_ES6_PROXY)
-#define DUK_HOBJECT_CLEAR_EXOTIC_PROXYOBJ(h)   DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
+#define DUK_HOBJECT_CLEAR_EXOTIC_PROXYOBJ(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ)
 #endif
-#define DUK_HOBJECT_CLEAR_SPECIAL_CALL(h)      DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
+#define DUK_HOBJECT_CLEAR_SPECIAL_CALL(h) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(h)->hdr, DUK_HOBJECT_FLAG_SPECIAL_CALL)
 
 /* Object can/cannot use FASTREFS, i.e. has no strong reference fields beyond
  * duk_hobject base header.  This is used just for asserts so doesn't need to
  * be optimized.
  */
 #define DUK_HOBJECT_PROHIBITS_FASTREFS(h) \
-	(DUK_HOBJECT_IS_COMPFUNC((h)) || DUK_HOBJECT_IS_DECENV((h)) || DUK_HOBJECT_IS_OBJENV((h)) || \
-	 DUK_HOBJECT_IS_BUFOBJ((h)) || DUK_HOBJECT_IS_THREAD((h)) || DUK_HOBJECT_IS_PROXY((h)) || \
-	 DUK_HOBJECT_IS_BOUNDFUNC((h)))
+	(DUK_HOBJECT_IS_COMPFUNC((h)) || DUK_HOBJECT_IS_DECENV((h)) || DUK_HOBJECT_IS_OBJENV((h)) || DUK_HOBJECT_IS_BUFOBJ((h)) || \
+	 DUK_HOBJECT_IS_THREAD((h)) || DUK_HOBJECT_IS_PROXY((h)) || DUK_HOBJECT_IS_BOUNDFUNC((h)))
 #define DUK_HOBJECT_ALLOWS_FASTREFS(h) (!DUK_HOBJECT_PROHIBITS_FASTREFS((h)))
 
 /* Flags used for property attributes in duk_propdesc and packed flags.
  * Must fit into 8 bits.
  */
-#define DUK_PROPDESC_FLAG_WRITABLE              (1U << 0)    /* E5 Section 8.6.1 */
-#define DUK_PROPDESC_FLAG_ENUMERABLE            (1U << 1)    /* E5 Section 8.6.1 */
-#define DUK_PROPDESC_FLAG_CONFIGURABLE          (1U << 2)    /* E5 Section 8.6.1 */
-#define DUK_PROPDESC_FLAG_ACCESSOR              (1U << 3)    /* accessor */
-#define DUK_PROPDESC_FLAG_VIRTUAL               (1U << 4)    /* property is virtual: used in duk_propdesc, never stored
-                                                             * (used by e.g. buffer virtual properties)
-                                                             */
-#define DUK_PROPDESC_FLAGS_MASK                 (DUK_PROPDESC_FLAG_WRITABLE | \
-                                                 DUK_PROPDESC_FLAG_ENUMERABLE | \
-                                                 DUK_PROPDESC_FLAG_CONFIGURABLE | \
-                                                 DUK_PROPDESC_FLAG_ACCESSOR)
+#define DUK_PROPDESC_FLAG_WRITABLE     (1U << 0) /* E5 Section 8.6.1 */
+#define DUK_PROPDESC_FLAG_ENUMERABLE   (1U << 1) /* E5 Section 8.6.1 */
+#define DUK_PROPDESC_FLAG_CONFIGURABLE (1U << 2) /* E5 Section 8.6.1 */
+#define DUK_PROPDESC_FLAG_ACCESSOR     (1U << 3) /* accessor */
+#define DUK_PROPDESC_FLAG_VIRTUAL \
+	(1U << 4) /* property is virtual: used in duk_propdesc, never stored \
+	           * (used by e.g. buffer virtual properties) \
+	           */
+#define DUK_PROPDESC_FLAGS_MASK \
+	(DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE | DUK_PROPDESC_FLAG_CONFIGURABLE | DUK_PROPDESC_FLAG_ACCESSOR)
 
 /* Additional flags which are passed in the same flags argument as property
  * flags but are not stored in object properties.
  */
-#define DUK_PROPDESC_FLAG_NO_OVERWRITE          (1U << 4)    /* internal define property: skip write silently if exists */
+#define DUK_PROPDESC_FLAG_NO_OVERWRITE (1U << 4) /* internal define property: skip write silently if exists */
 
 /* Convenience defines for property attributes. */
-#define DUK_PROPDESC_FLAGS_NONE                 0
-#define DUK_PROPDESC_FLAGS_W                    (DUK_PROPDESC_FLAG_WRITABLE)
-#define DUK_PROPDESC_FLAGS_E                    (DUK_PROPDESC_FLAG_ENUMERABLE)
-#define DUK_PROPDESC_FLAGS_C                    (DUK_PROPDESC_FLAG_CONFIGURABLE)
-#define DUK_PROPDESC_FLAGS_WE                   (DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE)
-#define DUK_PROPDESC_FLAGS_WC                   (DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_CONFIGURABLE)
-#define DUK_PROPDESC_FLAGS_EC                   (DUK_PROPDESC_FLAG_ENUMERABLE | DUK_PROPDESC_FLAG_CONFIGURABLE)
-#define DUK_PROPDESC_FLAGS_WEC                  (DUK_PROPDESC_FLAG_WRITABLE | \
-                                                 DUK_PROPDESC_FLAG_ENUMERABLE | \
-                                                 DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_PROPDESC_FLAGS_NONE 0
+#define DUK_PROPDESC_FLAGS_W    (DUK_PROPDESC_FLAG_WRITABLE)
+#define DUK_PROPDESC_FLAGS_E    (DUK_PROPDESC_FLAG_ENUMERABLE)
+#define DUK_PROPDESC_FLAGS_C    (DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_PROPDESC_FLAGS_WE   (DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE)
+#define DUK_PROPDESC_FLAGS_WC   (DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_PROPDESC_FLAGS_EC   (DUK_PROPDESC_FLAG_ENUMERABLE | DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_PROPDESC_FLAGS_WEC  (DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE | DUK_PROPDESC_FLAG_CONFIGURABLE)
 
 /* Flags for duk_hobject_get_own_propdesc() and variants. */
-#define DUK_GETDESC_FLAG_PUSH_VALUE          (1U << 0)  /* push value to stack */
-#define DUK_GETDESC_FLAG_IGNORE_PROTOLOOP    (1U << 1)  /* don't throw for prototype loop */
+#define DUK_GETDESC_FLAG_PUSH_VALUE       (1U << 0) /* push value to stack */
+#define DUK_GETDESC_FLAG_IGNORE_PROTOLOOP (1U << 1) /* don't throw for prototype loop */
 
 /*
  *  Macro for object validity check
  *
  *  Assert for currently guaranteed relations between flags, for instance.
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hobject_assert_valid(duk_hobject *h);
-#define DUK_HOBJECT_ASSERT_VALID(h)  do { duk_hobject_assert_valid((h)); } while (0)
+#define DUK_HOBJECT_ASSERT_VALID(h) \
+	do { \
+		duk_hobject_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HOBJECT_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HOBJECT_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Macros to access the 'props' allocation.
  */
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HOBJECT_GET_PROPS(heap,h) \
-	((duk_uint8_t *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, ((duk_heaphdr *) (h))->h_extra16))
-#define DUK_HOBJECT_SET_PROPS(heap,h,x) do { \
+#define DUK_HOBJECT_GET_PROPS(heap, h) ((duk_uint8_t *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, ((duk_heaphdr *) (h))->h_extra16))
+#define DUK_HOBJECT_SET_PROPS(heap, h, x) \
+	do { \
 		((duk_heaphdr *) (h))->h_extra16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (x)); \
 	} while (0)
 #else
-#define DUK_HOBJECT_GET_PROPS(heap,h) \
-	((h)->props)
-#define DUK_HOBJECT_SET_PROPS(heap,h,x) do { \
+#define DUK_HOBJECT_GET_PROPS(heap, h) ((h)->props)
+#define DUK_HOBJECT_SET_PROPS(heap, h, x) \
+	do { \
 		(h)->props = (duk_uint8_t *) (x); \
 	} while (0)
 #endif
 
 #if defined(DUK_USE_HOBJECT_LAYOUT_1)
 /* LAYOUT 1 */
-#define DUK_HOBJECT_E_GET_KEY_BASE(heap,h) \
-	((duk_hstring **) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) \
-	))
-#define DUK_HOBJECT_E_GET_VALUE_BASE(heap,h) \
-	((duk_propvalue *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_hstring *) \
-	))
-#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap,h) \
-	((duk_uint8_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) \
-	))
-#define DUK_HOBJECT_A_GET_BASE(heap,h) \
-	((duk_tval *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) \
-	))
-#define DUK_HOBJECT_H_GET_BASE(heap,h) \
-	((duk_uint32_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
-			DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) \
-	))
-#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent,n_arr,n_hash) \
-	( \
-		(n_ent) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
-		(n_arr) * sizeof(duk_tval) + \
-		(n_hash) * sizeof(duk_uint32_t) \
-	)
-#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base,set_e_k,set_e_pv,set_e_f,set_a,set_h,n_ent,n_arr,n_hash)  do { \
+#define DUK_HOBJECT_E_GET_KEY_BASE(heap, h) ((duk_hstring **) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h))))
+#define DUK_HOBJECT_E_GET_VALUE_BASE(heap, h) \
+	((duk_propvalue *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_hstring *)))
+#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap, h) \
+	((duk_uint8_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                           DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))
+#define DUK_HOBJECT_A_GET_BASE(heap, h) \
+	((duk_tval *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                        DUK_HOBJECT_GET_ESIZE((h)) * \
+	                            (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t))))
+#define DUK_HOBJECT_H_GET_BASE(heap, h) \
+	((duk_uint32_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                            DUK_HOBJECT_GET_ESIZE((h)) * \
+	                                (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
+	                            DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval)))
+#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent, n_arr, n_hash) \
+	((n_ent) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + (n_arr) * sizeof(duk_tval) + \
+	 (n_hash) * sizeof(duk_uint32_t))
+#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base, set_e_k, set_e_pv, set_e_f, set_a, set_h, n_ent, n_arr, n_hash) \
+	do { \
 		(set_e_k) = (duk_hstring **) (void *) (p_base); \
 		(set_e_pv) = (duk_propvalue *) (void *) ((set_e_k) + (n_ent)); \
 		(set_e_f) = (duk_uint8_t *) (void *) ((set_e_pv) + (n_ent)); \
 		(set_a) = (duk_tval *) (void *) ((set_e_f) + (n_ent)); \
 		(set_h) = (duk_uint32_t *) (void *) ((set_a) + (n_arr)); \
 	} while (0)
 #elif defined(DUK_USE_HOBJECT_LAYOUT_2)
@@ -6547,318 +6954,332 @@
 #elif (DUK_USE_ALIGN_BY == 8)
 #define DUK_HOBJECT_E_FLAG_PADDING(e_sz) ((8 - (e_sz)) & 0x07)
 #elif (DUK_USE_ALIGN_BY == 1)
 #define DUK_HOBJECT_E_FLAG_PADDING(e_sz) 0
 #else
 #error invalid DUK_USE_ALIGN_BY
 #endif
-#define DUK_HOBJECT_E_GET_KEY_BASE(heap,h) \
-	((duk_hstring **) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue) \
-	))
-#define DUK_HOBJECT_E_GET_VALUE_BASE(heap,h) \
-	((duk_propvalue *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) \
-	))
-#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap,h) \
-	((duk_uint8_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue)) \
-	))
-#define DUK_HOBJECT_A_GET_BASE(heap,h) \
-	((duk_tval *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
-			DUK_HOBJECT_E_FLAG_PADDING(DUK_HOBJECT_GET_ESIZE((h))) \
-	))
-#define DUK_HOBJECT_H_GET_BASE(heap,h) \
-	((duk_uint32_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
-			DUK_HOBJECT_E_FLAG_PADDING(DUK_HOBJECT_GET_ESIZE((h))) + \
-			DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) \
-	))
-#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent,n_arr,n_hash) \
-	( \
-		(n_ent) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
-		DUK_HOBJECT_E_FLAG_PADDING((n_ent)) + \
-		(n_arr) * sizeof(duk_tval) + \
-		(n_hash) * sizeof(duk_uint32_t) \
-	)
-#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base,set_e_k,set_e_pv,set_e_f,set_a,set_h,n_ent,n_arr,n_hash)  do { \
+#define DUK_HOBJECT_E_GET_KEY_BASE(heap, h) \
+	((duk_hstring **) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue)))
+#define DUK_HOBJECT_E_GET_VALUE_BASE(heap, h) ((duk_propvalue *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h))))
+#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap, h) \
+	((duk_uint8_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                           DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))
+#define DUK_HOBJECT_A_GET_BASE(heap, h) \
+	((duk_tval *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                        DUK_HOBJECT_GET_ESIZE((h)) * \
+	                            (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
+	                        DUK_HOBJECT_E_FLAG_PADDING(DUK_HOBJECT_GET_ESIZE((h)))))
+#define DUK_HOBJECT_H_GET_BASE(heap, h) \
+	((duk_uint32_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                            DUK_HOBJECT_GET_ESIZE((h)) * \
+	                                (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + \
+	                            DUK_HOBJECT_E_FLAG_PADDING(DUK_HOBJECT_GET_ESIZE((h))) + \
+	                            DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval)))
+#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent, n_arr, n_hash) \
+	((n_ent) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + DUK_HOBJECT_E_FLAG_PADDING((n_ent)) + \
+	 (n_arr) * sizeof(duk_tval) + (n_hash) * sizeof(duk_uint32_t))
+#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base, set_e_k, set_e_pv, set_e_f, set_a, set_h, n_ent, n_arr, n_hash) \
+	do { \
 		(set_e_pv) = (duk_propvalue *) (void *) (p_base); \
 		(set_e_k) = (duk_hstring **) (void *) ((set_e_pv) + (n_ent)); \
 		(set_e_f) = (duk_uint8_t *) (void *) ((set_e_k) + (n_ent)); \
-		(set_a) = (duk_tval *) (void *) (((duk_uint8_t *) (set_e_f)) + \
-		                                 sizeof(duk_uint8_t) * (n_ent) + \
+		(set_a) = (duk_tval *) (void *) (((duk_uint8_t *) (set_e_f)) + sizeof(duk_uint8_t) * (n_ent) + \
 		                                 DUK_HOBJECT_E_FLAG_PADDING((n_ent))); \
 		(set_h) = (duk_uint32_t *) (void *) ((set_a) + (n_arr)); \
 	} while (0)
 #elif defined(DUK_USE_HOBJECT_LAYOUT_3)
 /* LAYOUT 3 */
-#define DUK_HOBJECT_E_GET_KEY_BASE(heap,h) \
-	((duk_hstring **) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue) + \
-			DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) \
-	))
-#define DUK_HOBJECT_E_GET_VALUE_BASE(heap,h) \
-	((duk_propvalue *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) \
-	))
-#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap,h) \
-	((duk_uint8_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_propvalue) + sizeof(duk_hstring *)) + \
-			DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) + \
-			DUK_HOBJECT_GET_HSIZE((h)) * sizeof(duk_uint32_t) \
-	))
-#define DUK_HOBJECT_A_GET_BASE(heap,h) \
-	((duk_tval *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue) \
-	))
-#define DUK_HOBJECT_H_GET_BASE(heap,h) \
-	((duk_uint32_t *) (void *) ( \
-		DUK_HOBJECT_GET_PROPS((heap), (h)) + \
-			DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_propvalue) + sizeof(duk_hstring *)) + \
-			DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) \
-	))
-#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent,n_arr,n_hash) \
-	( \
-		(n_ent) * (sizeof(duk_propvalue) + sizeof(duk_hstring *) + sizeof(duk_uint8_t)) + \
-		(n_arr) * sizeof(duk_tval) + \
-		(n_hash) * sizeof(duk_uint32_t) \
-	)
-#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base,set_e_k,set_e_pv,set_e_f,set_a,set_h,n_ent,n_arr,n_hash)  do { \
+#define DUK_HOBJECT_E_GET_KEY_BASE(heap, h) \
+	((duk_hstring **) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue) + \
+	                            DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval)))
+#define DUK_HOBJECT_E_GET_VALUE_BASE(heap, h) ((duk_propvalue *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h))))
+#define DUK_HOBJECT_E_GET_FLAGS_BASE(heap, h) \
+	((duk_uint8_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                           DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_propvalue) + sizeof(duk_hstring *)) + \
+	                           DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval) + \
+	                           DUK_HOBJECT_GET_HSIZE((h)) * sizeof(duk_uint32_t)))
+#define DUK_HOBJECT_A_GET_BASE(heap, h) \
+	((duk_tval *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + DUK_HOBJECT_GET_ESIZE((h)) * sizeof(duk_propvalue)))
+#define DUK_HOBJECT_H_GET_BASE(heap, h) \
+	((duk_uint32_t *) (void *) (DUK_HOBJECT_GET_PROPS((heap), (h)) + \
+	                            DUK_HOBJECT_GET_ESIZE((h)) * (sizeof(duk_propvalue) + sizeof(duk_hstring *)) + \
+	                            DUK_HOBJECT_GET_ASIZE((h)) * sizeof(duk_tval)))
+#define DUK_HOBJECT_P_COMPUTE_SIZE(n_ent, n_arr, n_hash) \
+	((n_ent) * (sizeof(duk_propvalue) + sizeof(duk_hstring *) + sizeof(duk_uint8_t)) + (n_arr) * sizeof(duk_tval) + \
+	 (n_hash) * sizeof(duk_uint32_t))
+#define DUK_HOBJECT_P_SET_REALLOC_PTRS(p_base, set_e_k, set_e_pv, set_e_f, set_a, set_h, n_ent, n_arr, n_hash) \
+	do { \
 		(set_e_pv) = (duk_propvalue *) (void *) (p_base); \
 		(set_a) = (duk_tval *) (void *) ((set_e_pv) + (n_ent)); \
 		(set_e_k) = (duk_hstring **) (void *) ((set_a) + (n_arr)); \
 		(set_h) = (duk_uint32_t *) (void *) ((set_e_k) + (n_ent)); \
 		(set_e_f) = (duk_uint8_t *) (void *) ((set_h) + (n_hash)); \
 	} while (0)
 #else
 #error invalid hobject layout defines
-#endif  /* hobject property layout */
+#endif /* hobject property layout */
 
 #define DUK_HOBJECT_P_ALLOC_SIZE(h) \
 	DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE((h)), DUK_HOBJECT_GET_ASIZE((h)), DUK_HOBJECT_GET_HSIZE((h)))
 
-#define DUK_HOBJECT_E_GET_KEY(heap,h,i)              (DUK_HOBJECT_E_GET_KEY_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_E_GET_KEY_PTR(heap,h,i)          (&DUK_HOBJECT_E_GET_KEY_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_E_GET_VALUE(heap,h,i)            (DUK_HOBJECT_E_GET_VALUE_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_E_GET_VALUE_PTR(heap,h,i)        (&DUK_HOBJECT_E_GET_VALUE_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_E_GET_VALUE_TVAL(heap,h,i)       (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).v)
-#define DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(heap,h,i)   (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).v)
-#define DUK_HOBJECT_E_GET_VALUE_GETTER(heap,h,i)     (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.get)
-#define DUK_HOBJECT_E_GET_VALUE_GETTER_PTR(heap,h,i) (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.get)
-#define DUK_HOBJECT_E_GET_VALUE_SETTER(heap,h,i)     (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.set)
-#define DUK_HOBJECT_E_GET_VALUE_SETTER_PTR(heap,h,i) (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.set)
-#define DUK_HOBJECT_E_GET_FLAGS(heap,h,i)            (DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_E_GET_FLAGS_PTR(heap,h,i)        (&DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_A_GET_VALUE(heap,h,i)            (DUK_HOBJECT_A_GET_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_A_GET_VALUE_PTR(heap,h,i)        (&DUK_HOBJECT_A_GET_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_H_GET_INDEX(heap,h,i)            (DUK_HOBJECT_H_GET_BASE((heap), (h))[(i)])
-#define DUK_HOBJECT_H_GET_INDEX_PTR(heap,h,i)        (&DUK_HOBJECT_H_GET_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_KEY(heap, h, i)              (DUK_HOBJECT_E_GET_KEY_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_KEY_PTR(heap, h, i)          (&DUK_HOBJECT_E_GET_KEY_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_VALUE(heap, h, i)            (DUK_HOBJECT_E_GET_VALUE_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_VALUE_PTR(heap, h, i)        (&DUK_HOBJECT_E_GET_VALUE_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_VALUE_TVAL(heap, h, i)       (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).v)
+#define DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(heap, h, i)   (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).v)
+#define DUK_HOBJECT_E_GET_VALUE_GETTER(heap, h, i)     (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.get)
+#define DUK_HOBJECT_E_GET_VALUE_GETTER_PTR(heap, h, i) (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.get)
+#define DUK_HOBJECT_E_GET_VALUE_SETTER(heap, h, i)     (DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.set)
+#define DUK_HOBJECT_E_GET_VALUE_SETTER_PTR(heap, h, i) (&DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.set)
+#define DUK_HOBJECT_E_GET_FLAGS(heap, h, i)            (DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_E_GET_FLAGS_PTR(heap, h, i)        (&DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_A_GET_VALUE(heap, h, i)            (DUK_HOBJECT_A_GET_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_A_GET_VALUE_PTR(heap, h, i)        (&DUK_HOBJECT_A_GET_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_H_GET_INDEX(heap, h, i)            (DUK_HOBJECT_H_GET_BASE((heap), (h))[(i)])
+#define DUK_HOBJECT_H_GET_INDEX_PTR(heap, h, i)        (&DUK_HOBJECT_H_GET_BASE((heap), (h))[(i)])
 
-#define DUK_HOBJECT_E_SET_KEY(heap,h,i,k)  do { \
+#define DUK_HOBJECT_E_SET_KEY(heap, h, i, k) \
+	do { \
 		DUK_HOBJECT_E_GET_KEY((heap), (h), (i)) = (k); \
 	} while (0)
-#define DUK_HOBJECT_E_SET_VALUE(heap,h,i,v)  do { \
+#define DUK_HOBJECT_E_SET_VALUE(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)) = (v); \
 	} while (0)
-#define DUK_HOBJECT_E_SET_VALUE_TVAL(heap,h,i,v)  do { \
+#define DUK_HOBJECT_E_SET_VALUE_TVAL(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).v = (v); \
 	} while (0)
-#define DUK_HOBJECT_E_SET_VALUE_GETTER(heap,h,i,v)  do { \
+#define DUK_HOBJECT_E_SET_VALUE_GETTER(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.get = (v); \
 	} while (0)
-#define DUK_HOBJECT_E_SET_VALUE_SETTER(heap,h,i,v)  do { \
+#define DUK_HOBJECT_E_SET_VALUE_SETTER(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_E_GET_VALUE((heap), (h), (i)).a.set = (v); \
 	} while (0)
-#define DUK_HOBJECT_E_SET_FLAGS(heap,h,i,f)  do { \
+#define DUK_HOBJECT_E_SET_FLAGS(heap, h, i, f) \
+	do { \
 		DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) = (duk_uint8_t) (f); \
 	} while (0)
-#define DUK_HOBJECT_A_SET_VALUE(heap,h,i,v)  do { \
+#define DUK_HOBJECT_A_SET_VALUE(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_A_GET_VALUE((heap), (h), (i)) = (v); \
 	} while (0)
-#define DUK_HOBJECT_A_SET_VALUE_TVAL(heap,h,i,v) \
-	DUK_HOBJECT_A_SET_VALUE((heap), (h), (i), (v))  /* alias for above */
-#define DUK_HOBJECT_H_SET_INDEX(heap,h,i,v)  do { \
+#define DUK_HOBJECT_A_SET_VALUE_TVAL(heap, h, i, v) DUK_HOBJECT_A_SET_VALUE((heap), (h), (i), (v)) /* alias for above */
+#define DUK_HOBJECT_H_SET_INDEX(heap, h, i, v) \
+	do { \
 		DUK_HOBJECT_H_GET_INDEX((heap), (h), (i)) = (v); \
 	} while (0)
 
-#define DUK_HOBJECT_E_SET_FLAG_BITS(heap,h,i,mask)  do { \
+#define DUK_HOBJECT_E_SET_FLAG_BITS(heap, h, i, mask) \
+	do { \
 		DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)] |= (mask); \
 	} while (0)
 
-#define DUK_HOBJECT_E_CLEAR_FLAG_BITS(heap,h,i,mask)  do { \
+#define DUK_HOBJECT_E_CLEAR_FLAG_BITS(heap, h, i, mask) \
+	do { \
 		DUK_HOBJECT_E_GET_FLAGS_BASE((heap), (h))[(i)] &= ~(mask); \
 	} while (0)
 
-#define DUK_HOBJECT_E_SLOT_IS_WRITABLE(heap,h,i)     ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_WRITABLE) != 0)
-#define DUK_HOBJECT_E_SLOT_IS_ENUMERABLE(heap,h,i)   ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_ENUMERABLE) != 0)
-#define DUK_HOBJECT_E_SLOT_IS_CONFIGURABLE(heap,h,i) ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_CONFIGURABLE) != 0)
-#define DUK_HOBJECT_E_SLOT_IS_ACCESSOR(heap,h,i)     ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_ACCESSOR) != 0)
-
-#define DUK_HOBJECT_E_SLOT_SET_WRITABLE(heap,h,i)        DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_WRITABLE)
-#define DUK_HOBJECT_E_SLOT_SET_ENUMERABLE(heap,h,i)      DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_ENUMERABLE)
-#define DUK_HOBJECT_E_SLOT_SET_CONFIGURABLE(heap,h,i)    DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_CONFIGURABLE)
-#define DUK_HOBJECT_E_SLOT_SET_ACCESSOR(heap,h,i)        DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_ACCESSOR)
-
-#define DUK_HOBJECT_E_SLOT_CLEAR_WRITABLE(heap,h,i)      DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_WRITABLE)
-#define DUK_HOBJECT_E_SLOT_CLEAR_ENUMERABLE(heap,h,i)    DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_ENUMERABLE)
-#define DUK_HOBJECT_E_SLOT_CLEAR_CONFIGURABLE(heap,h,i)  DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_CONFIGURABLE)
-#define DUK_HOBJECT_E_SLOT_CLEAR_ACCESSOR(heap,h,i)      DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i),DUK_PROPDESC_FLAG_ACCESSOR)
-
-#define DUK_PROPDESC_IS_WRITABLE(p)             (((p)->flags & DUK_PROPDESC_FLAG_WRITABLE) != 0)
-#define DUK_PROPDESC_IS_ENUMERABLE(p)           (((p)->flags & DUK_PROPDESC_FLAG_ENUMERABLE) != 0)
-#define DUK_PROPDESC_IS_CONFIGURABLE(p)         (((p)->flags & DUK_PROPDESC_FLAG_CONFIGURABLE) != 0)
-#define DUK_PROPDESC_IS_ACCESSOR(p)             (((p)->flags & DUK_PROPDESC_FLAG_ACCESSOR) != 0)
+#define DUK_HOBJECT_E_SLOT_IS_WRITABLE(heap, h, i) ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_WRITABLE) != 0)
+#define DUK_HOBJECT_E_SLOT_IS_ENUMERABLE(heap, h, i) \
+	((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_ENUMERABLE) != 0)
+#define DUK_HOBJECT_E_SLOT_IS_CONFIGURABLE(heap, h, i) \
+	((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_CONFIGURABLE) != 0)
+#define DUK_HOBJECT_E_SLOT_IS_ACCESSOR(heap, h, i) ((DUK_HOBJECT_E_GET_FLAGS((heap), (h), (i)) & DUK_PROPDESC_FLAG_ACCESSOR) != 0)
+
+#define DUK_HOBJECT_E_SLOT_SET_WRITABLE(heap, h, i)   DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_WRITABLE)
+#define DUK_HOBJECT_E_SLOT_SET_ENUMERABLE(heap, h, i) DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_ENUMERABLE)
+#define DUK_HOBJECT_E_SLOT_SET_CONFIGURABLE(heap, h, i) \
+	DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_HOBJECT_E_SLOT_SET_ACCESSOR(heap, h, i) DUK_HOBJECT_E_SET_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_ACCESSOR)
+
+#define DUK_HOBJECT_E_SLOT_CLEAR_WRITABLE(heap, h, i) DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_WRITABLE)
+#define DUK_HOBJECT_E_SLOT_CLEAR_ENUMERABLE(heap, h, i) \
+	DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_ENUMERABLE)
+#define DUK_HOBJECT_E_SLOT_CLEAR_CONFIGURABLE(heap, h, i) \
+	DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_CONFIGURABLE)
+#define DUK_HOBJECT_E_SLOT_CLEAR_ACCESSOR(heap, h, i) DUK_HOBJECT_E_CLEAR_FLAG_BITS((heap), (h), (i), DUK_PROPDESC_FLAG_ACCESSOR)
+
+#define DUK_PROPDESC_IS_WRITABLE(p)     (((p)->flags & DUK_PROPDESC_FLAG_WRITABLE) != 0)
+#define DUK_PROPDESC_IS_ENUMERABLE(p)   (((p)->flags & DUK_PROPDESC_FLAG_ENUMERABLE) != 0)
+#define DUK_PROPDESC_IS_CONFIGURABLE(p) (((p)->flags & DUK_PROPDESC_FLAG_CONFIGURABLE) != 0)
+#define DUK_PROPDESC_IS_ACCESSOR(p)     (((p)->flags & DUK_PROPDESC_FLAG_ACCESSOR) != 0)
 
-#define DUK_HOBJECT_HASHIDX_UNUSED              0xffffffffUL
-#define DUK_HOBJECT_HASHIDX_DELETED             0xfffffffeUL
+#define DUK_HOBJECT_HASHIDX_UNUSED  0xffffffffUL
+#define DUK_HOBJECT_HASHIDX_DELETED 0xfffffffeUL
 
 /*
  *  Macros for accessing size fields
  */
 
 #if defined(DUK_USE_OBJSIZES16)
 #define DUK_HOBJECT_GET_ESIZE(h) ((h)->e_size16)
-#define DUK_HOBJECT_SET_ESIZE(h,v) do { (h)->e_size16 = (v); } while (0)
+#define DUK_HOBJECT_SET_ESIZE(h, v) \
+	do { \
+		(h)->e_size16 = (v); \
+	} while (0)
 #define DUK_HOBJECT_GET_ENEXT(h) ((h)->e_next16)
-#define DUK_HOBJECT_SET_ENEXT(h,v) do { (h)->e_next16 = (v); } while (0)
+#define DUK_HOBJECT_SET_ENEXT(h, v) \
+	do { \
+		(h)->e_next16 = (v); \
+	} while (0)
 #define DUK_HOBJECT_POSTINC_ENEXT(h) ((h)->e_next16++)
-#define DUK_HOBJECT_GET_ASIZE(h) ((h)->a_size16)
-#define DUK_HOBJECT_SET_ASIZE(h,v) do { (h)->a_size16 = (v); } while (0)
+#define DUK_HOBJECT_GET_ASIZE(h)     ((h)->a_size16)
+#define DUK_HOBJECT_SET_ASIZE(h, v) \
+	do { \
+		(h)->a_size16 = (v); \
+	} while (0)
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 #define DUK_HOBJECT_GET_HSIZE(h) ((h)->h_size16)
-#define DUK_HOBJECT_SET_HSIZE(h,v) do { (h)->h_size16 = (v); } while (0)
+#define DUK_HOBJECT_SET_HSIZE(h, v) \
+	do { \
+		(h)->h_size16 = (v); \
+	} while (0)
 #else
 #define DUK_HOBJECT_GET_HSIZE(h) 0
-#define DUK_HOBJECT_SET_HSIZE(h,v) do { DUK_ASSERT((v) == 0); } while (0)
+#define DUK_HOBJECT_SET_HSIZE(h, v) \
+	do { \
+		DUK_ASSERT((v) == 0); \
+	} while (0)
 #endif
 #else
 #define DUK_HOBJECT_GET_ESIZE(h) ((h)->e_size)
-#define DUK_HOBJECT_SET_ESIZE(h,v) do { (h)->e_size = (v); } while (0)
+#define DUK_HOBJECT_SET_ESIZE(h, v) \
+	do { \
+		(h)->e_size = (v); \
+	} while (0)
 #define DUK_HOBJECT_GET_ENEXT(h) ((h)->e_next)
-#define DUK_HOBJECT_SET_ENEXT(h,v) do { (h)->e_next = (v); } while (0)
+#define DUK_HOBJECT_SET_ENEXT(h, v) \
+	do { \
+		(h)->e_next = (v); \
+	} while (0)
 #define DUK_HOBJECT_POSTINC_ENEXT(h) ((h)->e_next++)
-#define DUK_HOBJECT_GET_ASIZE(h) ((h)->a_size)
-#define DUK_HOBJECT_SET_ASIZE(h,v) do { (h)->a_size = (v); } while (0)
+#define DUK_HOBJECT_GET_ASIZE(h)     ((h)->a_size)
+#define DUK_HOBJECT_SET_ASIZE(h, v) \
+	do { \
+		(h)->a_size = (v); \
+	} while (0)
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 #define DUK_HOBJECT_GET_HSIZE(h) ((h)->h_size)
-#define DUK_HOBJECT_SET_HSIZE(h,v) do { (h)->h_size = (v); } while (0)
+#define DUK_HOBJECT_SET_HSIZE(h, v) \
+	do { \
+		(h)->h_size = (v); \
+	} while (0)
 #else
 #define DUK_HOBJECT_GET_HSIZE(h) 0
-#define DUK_HOBJECT_SET_HSIZE(h,v) do { DUK_ASSERT((v) == 0); } while (0)
+#define DUK_HOBJECT_SET_HSIZE(h, v) \
+	do { \
+		DUK_ASSERT((v) == 0); \
+	} while (0)
 #endif
 #endif
 
 /*
  *  Misc
  */
 
 /* Maximum prototype traversal depth.  Sanity limit which handles e.g.
  * prototype loops (even complex ones like 1->2->3->4->2->3->4->2->3->4).
  */
-#define DUK_HOBJECT_PROTOTYPE_CHAIN_SANITY      10000L
+#define DUK_HOBJECT_PROTOTYPE_CHAIN_SANITY 10000L
 
 /*
  *  ECMAScript [[Class]]
  */
 
 /* range check not necessary because all 4-bit values are mapped */
-#define DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(n)  duk_class_number_to_stridx[(n)]
+#define DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(n) duk_class_number_to_stridx[(n)]
 
-#define DUK_HOBJECT_GET_CLASS_STRING(heap,h)          \
-	DUK_HEAP_GET_STRING( \
-		(heap), \
-		DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(DUK_HOBJECT_GET_CLASS_NUMBER((h))) \
-	)
+#define DUK_HOBJECT_GET_CLASS_STRING(heap, h) \
+	DUK_HEAP_GET_STRING((heap), DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(DUK_HOBJECT_GET_CLASS_NUMBER((h))))
 
 /*
  *  Macros for property handling
  */
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HOBJECT_GET_PROTOTYPE(heap,h) \
-	((duk_hobject *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->prototype16))
-#define DUK_HOBJECT_SET_PROTOTYPE(heap,h,x) do { \
+#define DUK_HOBJECT_GET_PROTOTYPE(heap, h) ((duk_hobject *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->prototype16))
+#define DUK_HOBJECT_SET_PROTOTYPE(heap, h, x) \
+	do { \
 		(h)->prototype16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (x)); \
 	} while (0)
 #else
-#define DUK_HOBJECT_GET_PROTOTYPE(heap,h) \
-	((h)->prototype)
-#define DUK_HOBJECT_SET_PROTOTYPE(heap,h,x) do { \
+#define DUK_HOBJECT_GET_PROTOTYPE(heap, h) ((h)->prototype)
+#define DUK_HOBJECT_SET_PROTOTYPE(heap, h, x) \
+	do { \
 		(h)->prototype = (x); \
 	} while (0)
 #endif
 
 /* Set prototype, DECREF earlier value, INCREF new value (tolerating NULLs). */
-#define DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr,h,p)       duk_hobject_set_prototype_updref((thr), (h), (p))
+#define DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, h, p) duk_hobject_set_prototype_updref((thr), (h), (p))
 
 /* Set initial prototype, assume NULL previous prototype, INCREF new value,
  * tolerate NULL.
  */
-#define DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr,h,proto) do { \
+#define DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, h, proto) \
+	do { \
 		duk_hthread *duk__thr = (thr); \
 		duk_hobject *duk__obj = (h); \
 		duk_hobject *duk__proto = (proto); \
 		DUK_UNREF(duk__thr); \
 		DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(duk__thr->heap, duk__obj) == NULL); \
 		DUK_HOBJECT_SET_PROTOTYPE(duk__thr->heap, duk__obj, duk__proto); \
 		DUK_HOBJECT_INCREF_ALLOWNULL(duk__thr, duk__proto); \
 	} while (0)
 
 /*
  *  Finalizer check
  */
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HOBJECT_HAS_FINALIZER_FAST(heap,h) duk_hobject_has_finalizer_fast_raw((heap), (h))
+#define DUK_HOBJECT_HAS_FINALIZER_FAST(heap, h) duk_hobject_has_finalizer_fast_raw((heap), (h))
 #else
-#define DUK_HOBJECT_HAS_FINALIZER_FAST(heap,h) duk_hobject_has_finalizer_fast_raw((h))
+#define DUK_HOBJECT_HAS_FINALIZER_FAST(heap, h) duk_hobject_has_finalizer_fast_raw((h))
 #endif
 
 /*
  *  Resizing and hash behavior
  */
 
 /* Sanity limit on max number of properties (allocated, not necessarily used).
  * This is somewhat arbitrary, but if we're close to 2**32 properties some
  * algorithms will fail (e.g. hash size selection, next prime selection).
  * Also, we use negative array/entry table indices to indicate 'not found',
  * so anything above 0x80000000 will cause trouble now.
  */
 #if defined(DUK_USE_OBJSIZES16)
-#define DUK_HOBJECT_MAX_PROPERTIES       0x0000ffffUL
+#define DUK_HOBJECT_MAX_PROPERTIES 0x0000ffffUL
 #else
-#define DUK_HOBJECT_MAX_PROPERTIES       0x3fffffffUL   /* 2**30-1 ~= 1G properties */
+#define DUK_HOBJECT_MAX_PROPERTIES 0x3fffffffUL /* 2**30-1 ~= 1G properties */
 #endif
 
 /* internal align target for props allocation, must be 2*n for some n */
 #if (DUK_USE_ALIGN_BY == 4)
-#define DUK_HOBJECT_ALIGN_TARGET         4
+#define DUK_HOBJECT_ALIGN_TARGET 4
 #elif (DUK_USE_ALIGN_BY == 8)
-#define DUK_HOBJECT_ALIGN_TARGET         8
+#define DUK_HOBJECT_ALIGN_TARGET 8
 #elif (DUK_USE_ALIGN_BY == 1)
-#define DUK_HOBJECT_ALIGN_TARGET         1
+#define DUK_HOBJECT_ALIGN_TARGET 1
 #else
 #error invalid DUK_USE_ALIGN_BY
 #endif
 
 /*
  *  PC-to-line constants
  */
 
-#define DUK_PC2LINE_SKIP    64
+#define DUK_PC2LINE_SKIP 64
 
 /* maximum length for a SKIP-1 diffstream: 35 bits per entry, rounded up to bytes */
-#define DUK_PC2LINE_MAX_DIFF_LENGTH    (((DUK_PC2LINE_SKIP - 1) * 35 + 7) / 8)
+#define DUK_PC2LINE_MAX_DIFF_LENGTH (((DUK_PC2LINE_SKIP - 1) * 35 + 7) / 8)
 
 /*
  *  Struct defs
  */
 
 struct duk_propaccessor {
 	duk_hobject *get;
@@ -6877,17 +7298,17 @@
 struct duk_propdesc {
 	/* read-only values 'lifted' for ease of use */
 	duk_small_uint_t flags;
 	duk_hobject *get;
 	duk_hobject *set;
 
 	/* for updating (all are set to < 0 for virtual properties) */
-	duk_int_t e_idx;  /* prop index in 'entry part', < 0 if not there */
-	duk_int_t h_idx;  /* prop index in 'hash part', < 0 if not there */
-	duk_int_t a_idx;  /* prop index in 'array part', < 0 if not there */
+	duk_int_t e_idx; /* prop index in 'entry part', < 0 if not there */
+	duk_int_t h_idx; /* prop index in 'hash part', < 0 if not there */
+	duk_int_t a_idx; /* prop index in 'array part', < 0 if not there */
 };
 
 struct duk_hobject {
 	duk_heaphdr hdr;
 
 	/*
 	 *  'props' contains {key,value,flags} entries, optional array entries, and
@@ -6974,30 +7395,30 @@
 	duk_uint16_t e_size16;
 	duk_uint16_t e_next16;
 	duk_uint16_t a_size16;
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 	duk_uint16_t h_size16;
 #endif
 #else
-	duk_uint32_t e_size;  /* entry part size */
-	duk_uint32_t e_next;  /* index for next new key ([0,e_next[ are gc reachable) */
-	duk_uint32_t a_size;  /* array part size (entirely gc reachable) */
+	duk_uint32_t e_size; /* entry part size */
+	duk_uint32_t e_next; /* index for next new key ([0,e_next[ are gc reachable) */
+	duk_uint32_t a_size; /* array part size (entirely gc reachable) */
 #if defined(DUK_USE_HOBJECT_HASH_PART)
-	duk_uint32_t h_size;  /* hash part size or 0 if unused */
+	duk_uint32_t h_size; /* hash part size or 0 if unused */
 #endif
 #endif
 };
 
 /*
  *  Exposed data
  */
 
 #if !defined(DUK_SINGLE_FILE)
 DUK_INTERNAL_DECL duk_uint8_t duk_class_number_to_stridx[32];
-#endif  /* !DUK_SINGLE_FILE */
+#endif /* !DUK_SINGLE_FILE */
 
 /*
  *  Prototypes
  */
 
 /* alloc and init */
 DUK_INTERNAL_DECL duk_hobject *duk_hobject_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags);
@@ -7018,44 +7439,54 @@
 /* resize */
 DUK_INTERNAL_DECL void duk_hobject_realloc_props(duk_hthread *thr,
                                                  duk_hobject *obj,
                                                  duk_uint32_t new_e_size,
                                                  duk_uint32_t new_a_size,
                                                  duk_uint32_t new_h_size,
                                                  duk_bool_t abandon_array);
-DUK_INTERNAL_DECL void duk_hobject_resize_entrypart(duk_hthread *thr,
-                                                    duk_hobject *obj,
-                                                    duk_uint32_t new_e_size);
-#if 0  /*unused*/
+DUK_INTERNAL_DECL void duk_hobject_resize_entrypart(duk_hthread *thr, duk_hobject *obj, duk_uint32_t new_e_size);
+#if 0 /*unused*/
 DUK_INTERNAL_DECL void duk_hobject_resize_arraypart(duk_hthread *thr,
                                                     duk_hobject *obj,
                                                     duk_uint32_t new_a_size);
 #endif
 
 /* low-level property functions */
-DUK_INTERNAL_DECL duk_bool_t duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx);
+DUK_INTERNAL_DECL duk_bool_t
+duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx);
 DUK_INTERNAL_DECL duk_tval *duk_hobject_find_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key);
 DUK_INTERNAL_DECL duk_tval *duk_hobject_find_entry_tval_ptr_stridx(duk_heap *heap, duk_hobject *obj, duk_small_uint_t stridx);
-DUK_INTERNAL_DECL duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_uint_t *out_attrs);
+DUK_INTERNAL_DECL duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap,
+                                                                      duk_hobject *obj,
+                                                                      duk_hstring *key,
+                                                                      duk_uint_t *out_attrs);
 DUK_INTERNAL_DECL duk_tval *duk_hobject_find_array_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_uarridx_t i);
-DUK_INTERNAL_DECL duk_bool_t duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
+DUK_INTERNAL_DECL duk_bool_t
+duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
 
 /* core property functions */
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);
-DUK_INTERNAL_DECL duk_bool_t duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag);
+DUK_INTERNAL_DECL duk_bool_t
+duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag);
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_delprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_bool_t throw_flag);
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_hasprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);
 
 /* internal property functions */
-#define DUK_DELPROP_FLAG_THROW  (1U << 0)
-#define DUK_DELPROP_FLAG_FORCE  (1U << 1)
+#define DUK_DELPROP_FLAG_THROW (1U << 0)
+#define DUK_DELPROP_FLAG_FORCE (1U << 1)
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_delprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags);
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_hasprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key);
-DUK_INTERNAL_DECL void duk_hobject_define_property_internal(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags);
-DUK_INTERNAL_DECL void duk_hobject_define_property_internal_arridx(duk_hthread *thr, duk_hobject *obj, duk_uarridx_t arr_idx, duk_small_uint_t flags);
+DUK_INTERNAL_DECL void duk_hobject_define_property_internal(duk_hthread *thr,
+                                                            duk_hobject *obj,
+                                                            duk_hstring *key,
+                                                            duk_small_uint_t flags);
+DUK_INTERNAL_DECL void duk_hobject_define_property_internal_arridx(duk_hthread *thr,
+                                                                   duk_hobject *obj,
+                                                                   duk_uarridx_t arr_idx,
+                                                                   duk_small_uint_t flags);
 DUK_INTERNAL_DECL duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj);
 #if defined(DUK_USE_HEAPPTR16)
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_heap *heap, duk_hobject *obj);
 #else
 DUK_INTERNAL_DECL duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_hobject *obj);
 #endif
 
@@ -7107,25 +7538,28 @@
 /* pc2line */
 #if defined(DUK_USE_PC2LINE)
 DUK_INTERNAL_DECL void duk_hobject_pc2line_pack(duk_hthread *thr, duk_compiler_instr *instrs, duk_uint_fast32_t length);
 DUK_INTERNAL_DECL duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc);
 #endif
 
 /* misc */
-DUK_INTERNAL_DECL duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr, duk_hobject *h, duk_hobject *p, duk_bool_t ignore_loop);
+DUK_INTERNAL_DECL duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr,
+                                                                  duk_hobject *h,
+                                                                  duk_hobject *p,
+                                                                  duk_bool_t ignore_loop);
 
 #if !defined(DUK_USE_OBJECT_BUILTIN)
 /* These declarations are needed when related built-in is disabled and
  * genbuiltins.py won't automatically emit the declerations.
  */
 DUK_INTERNAL_DECL duk_ret_t duk_bi_object_prototype_to_string(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_ret_t duk_bi_function_prototype(duk_hthread *thr);
 #endif
 
-#endif  /* DUK_HOBJECT_H_INCLUDED */
+#endif /* DUK_HOBJECT_H_INCLUDED */
 /* #include duk_hcompfunc.h */
 #line 1 "duk_hcompfunc.h"
 /*
  *  Heap compiled function (ECMAScript function) representation.
  *
  *  There is a single data buffer containing the ECMAScript function's
  *  bytecode, constants, and inner functions.
@@ -7137,135 +7571,121 @@
 /*
  *  Field accessor macros
  */
 
 /* XXX: casts could be improved, especially for GET/SET DATA */
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HCOMPFUNC_GET_DATA(heap,h) \
-	((duk_hbuffer_fixed *) (void *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->data16))
-#define DUK_HCOMPFUNC_SET_DATA(heap,h,v) do { \
+#define DUK_HCOMPFUNC_GET_DATA(heap, h) ((duk_hbuffer_fixed *) (void *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->data16))
+#define DUK_HCOMPFUNC_SET_DATA(heap, h, v) \
+	do { \
 		(h)->data16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_FUNCS(heap,h)  \
-	((duk_hobject **) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->funcs16)))
-#define DUK_HCOMPFUNC_SET_FUNCS(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_FUNCS(heap, h) ((duk_hobject **) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->funcs16)))
+#define DUK_HCOMPFUNC_SET_FUNCS(heap, h, v) \
+	do { \
 		(h)->funcs16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_BYTECODE(heap,h)  \
-	((duk_instr_t *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->bytecode16)))
-#define DUK_HCOMPFUNC_SET_BYTECODE(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_BYTECODE(heap, h) ((duk_instr_t *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->bytecode16)))
+#define DUK_HCOMPFUNC_SET_BYTECODE(heap, h, v) \
+	do { \
 		(h)->bytecode16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_LEXENV(heap,h)  \
-	((duk_hobject *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->lex_env16)))
-#define DUK_HCOMPFUNC_SET_LEXENV(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_LEXENV(heap, h) ((duk_hobject *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->lex_env16)))
+#define DUK_HCOMPFUNC_SET_LEXENV(heap, h, v) \
+	do { \
 		(h)->lex_env16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_VARENV(heap,h)  \
-	((duk_hobject *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->var_env16)))
-#define DUK_HCOMPFUNC_SET_VARENV(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_VARENV(heap, h) ((duk_hobject *) (void *) (DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (h)->var_env16)))
+#define DUK_HCOMPFUNC_SET_VARENV(heap, h, v) \
+	do { \
 		(h)->var_env16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
 #else
-#define DUK_HCOMPFUNC_GET_DATA(heap,h)  ((duk_hbuffer_fixed *) (void *) (h)->data)
-#define DUK_HCOMPFUNC_SET_DATA(heap,h,v) do { \
+#define DUK_HCOMPFUNC_GET_DATA(heap, h) ((duk_hbuffer_fixed *) (void *) (h)->data)
+#define DUK_HCOMPFUNC_SET_DATA(heap, h, v) \
+	do { \
 		(h)->data = (duk_hbuffer *) (v); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_FUNCS(heap,h)  ((h)->funcs)
-#define DUK_HCOMPFUNC_SET_FUNCS(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_FUNCS(heap, h) ((h)->funcs)
+#define DUK_HCOMPFUNC_SET_FUNCS(heap, h, v) \
+	do { \
 		(h)->funcs = (v); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_BYTECODE(heap,h)  ((h)->bytecode)
-#define DUK_HCOMPFUNC_SET_BYTECODE(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_BYTECODE(heap, h) ((h)->bytecode)
+#define DUK_HCOMPFUNC_SET_BYTECODE(heap, h, v) \
+	do { \
 		(h)->bytecode = (v); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_LEXENV(heap,h)  ((h)->lex_env)
-#define DUK_HCOMPFUNC_SET_LEXENV(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_LEXENV(heap, h) ((h)->lex_env)
+#define DUK_HCOMPFUNC_SET_LEXENV(heap, h, v) \
+	do { \
 		(h)->lex_env = (v); \
 	} while (0)
-#define DUK_HCOMPFUNC_GET_VARENV(heap,h)  ((h)->var_env)
-#define DUK_HCOMPFUNC_SET_VARENV(heap,h,v)  do { \
+#define DUK_HCOMPFUNC_GET_VARENV(heap, h) ((h)->var_env)
+#define DUK_HCOMPFUNC_SET_VARENV(heap, h, v) \
+	do { \
 		(h)->var_env = (v); \
 	} while (0)
 #endif
 
 /*
  *  Accessor macros for function specific data areas
  */
 
 /* Note: assumes 'data' is always a fixed buffer */
-#define DUK_HCOMPFUNC_GET_BUFFER_BASE(heap,h)  \
-	DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), DUK_HCOMPFUNC_GET_DATA((heap), (h)))
+#define DUK_HCOMPFUNC_GET_BUFFER_BASE(heap, h) DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), DUK_HCOMPFUNC_GET_DATA((heap), (h)))
 
-#define DUK_HCOMPFUNC_GET_CONSTS_BASE(heap,h)  \
-	((duk_tval *) (void *) DUK_HCOMPFUNC_GET_BUFFER_BASE((heap), (h)))
+#define DUK_HCOMPFUNC_GET_CONSTS_BASE(heap, h) ((duk_tval *) (void *) DUK_HCOMPFUNC_GET_BUFFER_BASE((heap), (h)))
 
-#define DUK_HCOMPFUNC_GET_FUNCS_BASE(heap,h)  \
-	DUK_HCOMPFUNC_GET_FUNCS((heap), (h))
+#define DUK_HCOMPFUNC_GET_FUNCS_BASE(heap, h) DUK_HCOMPFUNC_GET_FUNCS((heap), (h))
 
-#define DUK_HCOMPFUNC_GET_CODE_BASE(heap,h)  \
-	DUK_HCOMPFUNC_GET_BYTECODE((heap), (h))
+#define DUK_HCOMPFUNC_GET_CODE_BASE(heap, h) DUK_HCOMPFUNC_GET_BYTECODE((heap), (h))
 
-#define DUK_HCOMPFUNC_GET_CONSTS_END(heap,h)  \
-	((duk_tval *) (void *) DUK_HCOMPFUNC_GET_FUNCS((heap), (h)))
+#define DUK_HCOMPFUNC_GET_CONSTS_END(heap, h) ((duk_tval *) (void *) DUK_HCOMPFUNC_GET_FUNCS((heap), (h)))
 
-#define DUK_HCOMPFUNC_GET_FUNCS_END(heap,h)  \
-	((duk_hobject **) (void *) DUK_HCOMPFUNC_GET_BYTECODE((heap), (h)))
+#define DUK_HCOMPFUNC_GET_FUNCS_END(heap, h) ((duk_hobject **) (void *) DUK_HCOMPFUNC_GET_BYTECODE((heap), (h)))
 
 /* XXX: double evaluation of DUK_HCOMPFUNC_GET_DATA() */
-#define DUK_HCOMPFUNC_GET_CODE_END(heap,h)  \
+#define DUK_HCOMPFUNC_GET_CODE_END(heap, h) \
 	((duk_instr_t *) (void *) (DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), DUK_HCOMPFUNC_GET_DATA((heap), (h))) + \
-	                DUK_HBUFFER_GET_SIZE((duk_hbuffer *) DUK_HCOMPFUNC_GET_DATA((heap), h))))
+	                           DUK_HBUFFER_GET_SIZE((duk_hbuffer *) DUK_HCOMPFUNC_GET_DATA((heap), h))))
+
+#define DUK_HCOMPFUNC_GET_CONSTS_SIZE(heap, h) \
+	((duk_size_t) (((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CONSTS_END((heap), (h))) - \
+	               ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CONSTS_BASE((heap), (h)))))
+
+#define DUK_HCOMPFUNC_GET_FUNCS_SIZE(heap, h) \
+	((duk_size_t) (((const duk_uint8_t *) DUK_HCOMPFUNC_GET_FUNCS_END((heap), (h))) - \
+	               ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_FUNCS_BASE((heap), (h)))))
 
-#define DUK_HCOMPFUNC_GET_CONSTS_SIZE(heap,h)  \
-	( \
-	 (duk_size_t) \
-	 ( \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CONSTS_END((heap), (h))) - \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CONSTS_BASE((heap), (h))) \
-	 ) \
-	)
-
-#define DUK_HCOMPFUNC_GET_FUNCS_SIZE(heap,h)  \
-	( \
-	 (duk_size_t) \
-	 ( \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_FUNCS_END((heap), (h))) - \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_FUNCS_BASE((heap), (h))) \
-	 ) \
-	)
-
-#define DUK_HCOMPFUNC_GET_CODE_SIZE(heap,h)  \
-	( \
-	 (duk_size_t) \
-	 ( \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CODE_END((heap),(h))) - \
-	   ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CODE_BASE((heap),(h))) \
-	 ) \
-	)
+#define DUK_HCOMPFUNC_GET_CODE_SIZE(heap, h) \
+	((duk_size_t) (((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CODE_END((heap), (h))) - \
+	               ((const duk_uint8_t *) DUK_HCOMPFUNC_GET_CODE_BASE((heap), (h)))))
 
-#define DUK_HCOMPFUNC_GET_CONSTS_COUNT(heap,h)  \
-	((duk_size_t) (DUK_HCOMPFUNC_GET_CONSTS_SIZE((heap), (h)) / sizeof(duk_tval)))
+#define DUK_HCOMPFUNC_GET_CONSTS_COUNT(heap, h) ((duk_size_t) (DUK_HCOMPFUNC_GET_CONSTS_SIZE((heap), (h)) / sizeof(duk_tval)))
 
-#define DUK_HCOMPFUNC_GET_FUNCS_COUNT(heap,h)  \
-	((duk_size_t) (DUK_HCOMPFUNC_GET_FUNCS_SIZE((heap), (h)) / sizeof(duk_hobject *)))
+#define DUK_HCOMPFUNC_GET_FUNCS_COUNT(heap, h) ((duk_size_t) (DUK_HCOMPFUNC_GET_FUNCS_SIZE((heap), (h)) / sizeof(duk_hobject *)))
 
-#define DUK_HCOMPFUNC_GET_CODE_COUNT(heap,h)  \
-	((duk_size_t) (DUK_HCOMPFUNC_GET_CODE_SIZE((heap), (h)) / sizeof(duk_instr_t)))
+#define DUK_HCOMPFUNC_GET_CODE_COUNT(heap, h) ((duk_size_t) (DUK_HCOMPFUNC_GET_CODE_SIZE((heap), (h)) / sizeof(duk_instr_t)))
 
 /*
  *  Validity assert
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hcompfunc_assert_valid(duk_hcompfunc *h);
-#define DUK_HCOMPFUNC_ASSERT_VALID(h)  do { duk_hcompfunc_assert_valid((h)); } while (0)
+#define DUK_HCOMPFUNC_ASSERT_VALID(h) \
+	do { \
+		duk_hcompfunc_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HCOMPFUNC_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HCOMPFUNC_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Main struct
  */
 
 struct duk_hcompfunc {
@@ -7344,16 +7764,16 @@
 	 *  When looking up variables by name, the '_Varmap' map is used.
 	 *  When an activation closes, registers mapped to arguments are
 	 *  copied into the environment record based on the same map.  The
 	 *  reverse map (from register to variable) is not currently needed
 	 *  at run time, except for debugging, so it is not maintained.
 	 */
 
-	duk_uint16_t nregs;                /* regs to allocate */
-	duk_uint16_t nargs;                /* number of arguments allocated to regs */
+	duk_uint16_t nregs; /* regs to allocate */
+	duk_uint16_t nargs; /* number of arguments allocated to regs */
 
 	/*
 	 *  Additional control information is placed into the object itself
 	 *  as internal properties to avoid unnecessary fields for the
 	 *  majority of functions.  The compiler tries to omit internal
 	 *  control fields when possible.
 	 *
@@ -7392,33 +7812,38 @@
 	 * determine active breakpoints.
 	 */
 	duk_uint32_t start_line;
 	duk_uint32_t end_line;
 #endif
 };
 
-#endif  /* DUK_HCOMPFUNC_H_INCLUDED */
+#endif /* DUK_HCOMPFUNC_H_INCLUDED */
 /* #include duk_hnatfunc.h */
 #line 1 "duk_hnatfunc.h"
 /*
  *  Heap native function representation.
  */
 
 #if !defined(DUK_HNATFUNC_H_INCLUDED)
 #define DUK_HNATFUNC_H_INCLUDED
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hnatfunc_assert_valid(duk_hnatfunc *h);
-#define DUK_HNATFUNC_ASSERT_VALID(h)  do { duk_hnatfunc_assert_valid((h)); } while (0)
+#define DUK_HNATFUNC_ASSERT_VALID(h) \
+	do { \
+		duk_hnatfunc_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HNATFUNC_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HNATFUNC_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
-#define DUK_HNATFUNC_NARGS_VARARGS  ((duk_int16_t) -1)
-#define DUK_HNATFUNC_NARGS_MAX      ((duk_int16_t) 0x7fff)
+#define DUK_HNATFUNC_NARGS_VARARGS ((duk_int16_t) -1)
+#define DUK_HNATFUNC_NARGS_MAX     ((duk_int16_t) 0x7fff)
 
 struct duk_hnatfunc {
 	/* shared object part */
 	duk_hobject obj;
 
 	duk_c_function func;
 	duk_int16_t nargs;
@@ -7433,15 +7858,15 @@
 	 * versa.
 	 *
 	 * Note: cannot place nargs/magic into the heaphdr flags, because
 	 * duk_hobject takes almost all flags already.
 	 */
 };
 
-#endif  /* DUK_HNATFUNC_H_INCLUDED */
+#endif /* DUK_HNATFUNC_H_INCLUDED */
 /* #include duk_hboundfunc.h */
 #line 1 "duk_hboundfunc.h"
 /*
  *  Bound function representation.
  */
 
 #if !defined(DUK_HBOUNDFUNC_H_INCLUDED)
@@ -7450,17 +7875,22 @@
 /* Artificial limit for args length.  Ensures arithmetic won't overflow
  * 32 bits when combining bound functions.
  */
 #define DUK_HBOUNDFUNC_MAX_ARGS 0x20000000UL
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hboundfunc_assert_valid(duk_hboundfunc *h);
-#define DUK_HBOUNDFUNC_ASSERT_VALID(h)  do { duk_hboundfunc_assert_valid((h)); } while (0)
+#define DUK_HBOUNDFUNC_ASSERT_VALID(h) \
+	do { \
+		duk_hboundfunc_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HBOUNDFUNC_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HBOUNDFUNC_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 struct duk_hboundfunc {
 	/* Shared object part. */
 	duk_hobject obj;
 
 	/* Final target function, stored as duk_tval so that lightfunc can be
@@ -7468,100 +7898,104 @@
 	 */
 	duk_tval target;
 
 	/* This binding. */
 	duk_tval this_binding;
 
 	/* Arguments to prepend. */
-	duk_tval *args;  /* Separate allocation. */
+	duk_tval *args; /* Separate allocation. */
 	duk_idx_t nargs;
 };
 
-#endif  /* DUK_HBOUNDFUNC_H_INCLUDED */
+#endif /* DUK_HBOUNDFUNC_H_INCLUDED */
 /* #include duk_hbufobj.h */
 #line 1 "duk_hbufobj.h"
 /*
  *  Heap Buffer object representation.  Used for all Buffer variants.
  */
 
 #if !defined(DUK_HBUFOBJ_H_INCLUDED)
 #define DUK_HBUFOBJ_H_INCLUDED
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 
 /* All element accessors are host endian now (driven by TypedArray spec). */
-#define DUK_HBUFOBJ_ELEM_UINT8           0
-#define DUK_HBUFOBJ_ELEM_UINT8CLAMPED    1
-#define DUK_HBUFOBJ_ELEM_INT8            2
-#define DUK_HBUFOBJ_ELEM_UINT16          3
-#define DUK_HBUFOBJ_ELEM_INT16           4
-#define DUK_HBUFOBJ_ELEM_UINT32          5
-#define DUK_HBUFOBJ_ELEM_INT32           6
-#define DUK_HBUFOBJ_ELEM_FLOAT32         7
-#define DUK_HBUFOBJ_ELEM_FLOAT64         8
-#define DUK_HBUFOBJ_ELEM_MAX             8
+#define DUK_HBUFOBJ_ELEM_UINT8        0
+#define DUK_HBUFOBJ_ELEM_UINT8CLAMPED 1
+#define DUK_HBUFOBJ_ELEM_INT8         2
+#define DUK_HBUFOBJ_ELEM_UINT16       3
+#define DUK_HBUFOBJ_ELEM_INT16        4
+#define DUK_HBUFOBJ_ELEM_UINT32       5
+#define DUK_HBUFOBJ_ELEM_INT32        6
+#define DUK_HBUFOBJ_ELEM_FLOAT32      7
+#define DUK_HBUFOBJ_ELEM_FLOAT64      8
+#define DUK_HBUFOBJ_ELEM_MAX          8
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hbufobj_assert_valid(duk_hbufobj *h);
-#define DUK_HBUFOBJ_ASSERT_VALID(h)  do { duk_hbufobj_assert_valid((h)); } while (0)
+#define DUK_HBUFOBJ_ASSERT_VALID(h) \
+	do { \
+		duk_hbufobj_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HBUFOBJ_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HBUFOBJ_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 /* Get the current data pointer (caller must ensure buf != NULL) as a
  * duk_uint8_t ptr.  Note that the result may be NULL if the underlying
  * buffer has zero size and is not a fixed buffer.
  */
-#define DUK_HBUFOBJ_GET_SLICE_BASE(heap,h) \
-	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), \
-	(((duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR((heap), (h)->buf)) + (h)->offset))
+#define DUK_HBUFOBJ_GET_SLICE_BASE(heap, h) \
+	(DUK_ASSERT_EXPR((h) != NULL), \
+	 DUK_ASSERT_EXPR((h)->buf != NULL), \
+	 (((duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR((heap), (h)->buf)) + (h)->offset))
 
 /* True if slice is full, i.e. offset is zero and length covers the entire
  * buffer.  This status may change independently of the duk_hbufobj if
  * the underlying buffer is dynamic and changes without the hbufobj
  * being changed.
  */
 #define DUK_HBUFOBJ_FULL_SLICE(h) \
-	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), \
-	((h)->offset == 0 && (h)->length == DUK_HBUFFER_GET_SIZE((h)->buf)))
+	(DUK_ASSERT_EXPR((h) != NULL), \
+	 DUK_ASSERT_EXPR((h)->buf != NULL), \
+	 ((h)->offset == 0 && (h)->length == DUK_HBUFFER_GET_SIZE((h)->buf)))
 
 /* Validate that the whole slice [0,length[ is contained in the underlying
  * buffer.  Caller must ensure 'buf' != NULL.
  */
 #define DUK_HBUFOBJ_VALID_SLICE(h) \
-	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), \
-	((h)->offset + (h)->length <= DUK_HBUFFER_GET_SIZE((h)->buf)))
+	(DUK_ASSERT_EXPR((h) != NULL), \
+	 DUK_ASSERT_EXPR((h)->buf != NULL), \
+	 ((h)->offset + (h)->length <= DUK_HBUFFER_GET_SIZE((h)->buf)))
 
 /* Validate byte read/write for virtual 'offset', i.e. check that the
  * offset, taking into account h->offset, is within the underlying
  * buffer size.  This is a safety check which is needed to ensure
  * that even a misconfigured duk_hbufobj never causes memory unsafe
  * behavior (e.g. if an underlying dynamic buffer changes after being
  * setup).  Caller must ensure 'buf' != NULL.
  */
-#define DUK_HBUFOBJ_VALID_BYTEOFFSET_INCL(h,off) \
-	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), \
-	((h)->offset + (off) < DUK_HBUFFER_GET_SIZE((h)->buf)))
-
-#define DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h,off) \
-	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), \
-	((h)->offset + (off) <= DUK_HBUFFER_GET_SIZE((h)->buf)))
+#define DUK_HBUFOBJ_VALID_BYTEOFFSET_INCL(h, off) \
+	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), ((h)->offset + (off) < DUK_HBUFFER_GET_SIZE((h)->buf)))
+
+#define DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h, off) \
+	(DUK_ASSERT_EXPR((h) != NULL), DUK_ASSERT_EXPR((h)->buf != NULL), ((h)->offset + (off) <= DUK_HBUFFER_GET_SIZE((h)->buf)))
 
 /* Clamp an input byte length (already assumed to be within the nominal
  * duk_hbufobj 'length') to the current dynamic buffer limits to yield
  * a byte length limit that's safe for memory accesses.  This value can
  * be invalidated by any side effect because it may trigger a user
  * callback that resizes the underlying buffer.
  */
-#define DUK_HBUFOBJ_CLAMP_BYTELENGTH(h,len) \
-	(DUK_ASSERT_EXPR((h) != NULL), \
-	duk_hbufobj_clamp_bytelength((h), (len)))
+#define DUK_HBUFOBJ_CLAMP_BYTELENGTH(h, len) (DUK_ASSERT_EXPR((h) != NULL), duk_hbufobj_clamp_bytelength((h), (len)))
 
 /* Typed arrays have virtual indices, ArrayBuffer and DataView do not. */
-#define DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h)  ((h)->is_typedarray)
+#define DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h) ((h)->is_typedarray)
 
 struct duk_hbufobj {
 	/* Shared object part. */
 	duk_hobject obj;
 
 	/* Underlying buffer (refcounted), may be NULL. */
 	duk_hbuffer *buf;
@@ -7578,38 +8012,44 @@
 	 * virtual 'length' doesn't need to be affected, reads can return
 	 * zero/NaN, and writes can be ignored.
 	 *
 	 * Note that a data pointer cannot be precomputed because 'buf' may
 	 * be dynamic and its pointer unstable.
 	 */
 
-	duk_uint_t offset;       /* byte offset to buf */
-	duk_uint_t length;       /* byte index limit for element access, exclusive */
-	duk_uint8_t shift;       /* element size shift:
-	                          *   0 = u8/i8
-	                          *   1 = u16/i16
-	                          *   2 = u32/i32/float
-	                          *   3 = double
-	                          */
-	duk_uint8_t elem_type;   /* element type */
+	duk_uint_t offset; /* byte offset to buf */
+	duk_uint_t length; /* byte index limit for element access, exclusive */
+	duk_uint8_t shift; /* element size shift:
+	                    *   0 = u8/i8
+	                    *   1 = u16/i16
+	                    *   2 = u32/i32/float
+	                    *   3 = double
+	                    */
+	duk_uint8_t elem_type; /* element type */
 	duk_uint8_t is_typedarray;
 };
 
 DUK_INTERNAL_DECL duk_uint_t duk_hbufobj_clamp_bytelength(duk_hbufobj *h_bufobj, duk_uint_t len);
 DUK_INTERNAL_DECL void duk_hbufobj_push_uint8array_from_plain(duk_hthread *thr, duk_hbuffer *h_buf);
-DUK_INTERNAL_DECL void duk_hbufobj_push_validated_read(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size);
-DUK_INTERNAL_DECL void duk_hbufobj_validated_write(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size);
+DUK_INTERNAL_DECL void duk_hbufobj_push_validated_read(duk_hthread *thr,
+                                                       duk_hbufobj *h_bufobj,
+                                                       duk_uint8_t *p,
+                                                       duk_small_uint_t elem_size);
+DUK_INTERNAL_DECL void duk_hbufobj_validated_write(duk_hthread *thr,
+                                                   duk_hbufobj *h_bufobj,
+                                                   duk_uint8_t *p,
+                                                   duk_small_uint_t elem_size);
 DUK_INTERNAL_DECL void duk_hbufobj_promote_plain(duk_hthread *thr, duk_idx_t idx);
 
-#else  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#else /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* nothing */
 
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
-#endif  /* DUK_HBUFOBJ_H_INCLUDED */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_HBUFOBJ_H_INCLUDED */
 /* #include duk_hthread.h */
 #line 1 "duk_hthread.h"
 /*
  *  Heap thread object representation.
  *
  *  duk_hthread is also the 'context' for public API functions via a
  *  different typedef.  Most API calls operate on the topmost frame
@@ -7620,207 +8060,220 @@
 #define DUK_HTHREAD_H_INCLUDED
 
 /*
  *  Stack constants
  */
 
 /* Initial valstack size, roughly 0.7kiB. */
-#define DUK_VALSTACK_INITIAL_SIZE       96U
+#define DUK_VALSTACK_INITIAL_SIZE 96U
 
 /* Internal extra elements assumed on function entry, always added to
  * user-defined 'extra' for e.g. the duk_check_stack() call.
  */
-#define DUK_VALSTACK_INTERNAL_EXTRA     32U
+#define DUK_VALSTACK_INTERNAL_EXTRA 32U
 
 /* Number of elements guaranteed to be user accessible (in addition to call
  * arguments) on Duktape/C function entry.  This is the major public API
  * commitment.
  */
-#define DUK_VALSTACK_API_ENTRY_MINIMUM  DUK_API_ENTRY_STACK
+#define DUK_VALSTACK_API_ENTRY_MINIMUM DUK_API_ENTRY_STACK
 
 /*
  *  Activation defines
  */
 
-#define DUK_ACT_FLAG_STRICT             (1U << 0)  /* function executes in strict mode */
-#define DUK_ACT_FLAG_TAILCALLED         (1U << 1)  /* activation has tail called one or more times */
-#define DUK_ACT_FLAG_CONSTRUCT          (1U << 2)  /* function executes as a constructor (called via "new") */
-#define DUK_ACT_FLAG_PREVENT_YIELD      (1U << 3)  /* activation prevents yield (native call or "new") */
-#define DUK_ACT_FLAG_DIRECT_EVAL        (1U << 4)  /* activation is a direct eval call */
-#define DUK_ACT_FLAG_CONSTRUCT_PROXY    (1U << 5)  /* activation is for Proxy 'construct' call, special return value handling */
-#define DUK_ACT_FLAG_BREAKPOINT_ACTIVE  (1U << 6)  /* activation has active breakpoint(s) */
+#define DUK_ACT_FLAG_STRICT            (1U << 0) /* function executes in strict mode */
+#define DUK_ACT_FLAG_TAILCALLED        (1U << 1) /* activation has tail called one or more times */
+#define DUK_ACT_FLAG_CONSTRUCT         (1U << 2) /* function executes as a constructor (called via "new") */
+#define DUK_ACT_FLAG_PREVENT_YIELD     (1U << 3) /* activation prevents yield (native call or "new") */
+#define DUK_ACT_FLAG_DIRECT_EVAL       (1U << 4) /* activation is a direct eval call */
+#define DUK_ACT_FLAG_CONSTRUCT_PROXY   (1U << 5) /* activation is for Proxy 'construct' call, special return value handling */
+#define DUK_ACT_FLAG_BREAKPOINT_ACTIVE (1U << 6) /* activation has active breakpoint(s) */
 
-#define DUK_ACT_GET_FUNC(act)           ((act)->func)
+#define DUK_ACT_GET_FUNC(act) ((act)->func)
 
 /*
  *  Flags for __FILE__ / __LINE__ registered into tracedata
  */
 
-#define DUK_TB_FLAG_NOBLAME_FILELINE    (1U << 0)  /* don't report __FILE__ / __LINE__ as fileName/lineNumber */
+#define DUK_TB_FLAG_NOBLAME_FILELINE (1U << 0) /* don't report __FILE__ / __LINE__ as fileName/lineNumber */
 
 /*
  *  Catcher defines
  */
 
 /* XXX: remove catcher type entirely */
 
 /* flags field: LLLLLLFT, L = label (24 bits), F = flags (4 bits), T = type (4 bits) */
-#define DUK_CAT_TYPE_MASK            0x0000000fUL
-#define DUK_CAT_TYPE_BITS            4
-#define DUK_CAT_LABEL_MASK           0xffffff00UL
-#define DUK_CAT_LABEL_BITS           24
-#define DUK_CAT_LABEL_SHIFT          8
-
-#define DUK_CAT_FLAG_CATCH_ENABLED          (1U << 4)   /* catch part will catch */
-#define DUK_CAT_FLAG_FINALLY_ENABLED        (1U << 5)   /* finally part will catch */
-#define DUK_CAT_FLAG_CATCH_BINDING_ENABLED  (1U << 6)   /* request to create catch binding */
-#define DUK_CAT_FLAG_LEXENV_ACTIVE          (1U << 7)   /* catch or with binding is currently active */
-
-#define DUK_CAT_TYPE_UNKNOWN         0
-#define DUK_CAT_TYPE_TCF             1
-#define DUK_CAT_TYPE_LABEL           2
-
-#define DUK_CAT_GET_TYPE(c)          ((c)->flags & DUK_CAT_TYPE_MASK)
-#define DUK_CAT_GET_LABEL(c)         (((c)->flags & DUK_CAT_LABEL_MASK) >> DUK_CAT_LABEL_SHIFT)
-
-#define DUK_CAT_HAS_CATCH_ENABLED(c)           ((c)->flags & DUK_CAT_FLAG_CATCH_ENABLED)
-#define DUK_CAT_HAS_FINALLY_ENABLED(c)         ((c)->flags & DUK_CAT_FLAG_FINALLY_ENABLED)
-#define DUK_CAT_HAS_CATCH_BINDING_ENABLED(c)   ((c)->flags & DUK_CAT_FLAG_CATCH_BINDING_ENABLED)
-#define DUK_CAT_HAS_LEXENV_ACTIVE(c)           ((c)->flags & DUK_CAT_FLAG_LEXENV_ACTIVE)
+#define DUK_CAT_TYPE_MASK   0x0000000fUL
+#define DUK_CAT_TYPE_BITS   4
+#define DUK_CAT_LABEL_MASK  0xffffff00UL
+#define DUK_CAT_LABEL_BITS  24
+#define DUK_CAT_LABEL_SHIFT 8
+
+#define DUK_CAT_FLAG_CATCH_ENABLED         (1U << 4) /* catch part will catch */
+#define DUK_CAT_FLAG_FINALLY_ENABLED       (1U << 5) /* finally part will catch */
+#define DUK_CAT_FLAG_CATCH_BINDING_ENABLED (1U << 6) /* request to create catch binding */
+#define DUK_CAT_FLAG_LEXENV_ACTIVE         (1U << 7) /* catch or with binding is currently active */
+
+#define DUK_CAT_TYPE_UNKNOWN 0
+#define DUK_CAT_TYPE_TCF     1
+#define DUK_CAT_TYPE_LABEL   2
+
+#define DUK_CAT_GET_TYPE(c)  ((c)->flags & DUK_CAT_TYPE_MASK)
+#define DUK_CAT_GET_LABEL(c) (((c)->flags & DUK_CAT_LABEL_MASK) >> DUK_CAT_LABEL_SHIFT)
+
+#define DUK_CAT_HAS_CATCH_ENABLED(c)         ((c)->flags & DUK_CAT_FLAG_CATCH_ENABLED)
+#define DUK_CAT_HAS_FINALLY_ENABLED(c)       ((c)->flags & DUK_CAT_FLAG_FINALLY_ENABLED)
+#define DUK_CAT_HAS_CATCH_BINDING_ENABLED(c) ((c)->flags & DUK_CAT_FLAG_CATCH_BINDING_ENABLED)
+#define DUK_CAT_HAS_LEXENV_ACTIVE(c)         ((c)->flags & DUK_CAT_FLAG_LEXENV_ACTIVE)
 
-#define DUK_CAT_SET_CATCH_ENABLED(c)    do { \
+#define DUK_CAT_SET_CATCH_ENABLED(c) \
+	do { \
 		(c)->flags |= DUK_CAT_FLAG_CATCH_ENABLED; \
 	} while (0)
-#define DUK_CAT_SET_FINALLY_ENABLED(c)  do { \
+#define DUK_CAT_SET_FINALLY_ENABLED(c) \
+	do { \
 		(c)->flags |= DUK_CAT_FLAG_FINALLY_ENABLED; \
 	} while (0)
-#define DUK_CAT_SET_CATCH_BINDING_ENABLED(c)    do { \
+#define DUK_CAT_SET_CATCH_BINDING_ENABLED(c) \
+	do { \
 		(c)->flags |= DUK_CAT_FLAG_CATCH_BINDING_ENABLED; \
 	} while (0)
-#define DUK_CAT_SET_LEXENV_ACTIVE(c)    do { \
+#define DUK_CAT_SET_LEXENV_ACTIVE(c) \
+	do { \
 		(c)->flags |= DUK_CAT_FLAG_LEXENV_ACTIVE; \
 	} while (0)
 
-#define DUK_CAT_CLEAR_CATCH_ENABLED(c)    do { \
+#define DUK_CAT_CLEAR_CATCH_ENABLED(c) \
+	do { \
 		(c)->flags &= ~DUK_CAT_FLAG_CATCH_ENABLED; \
 	} while (0)
-#define DUK_CAT_CLEAR_FINALLY_ENABLED(c)  do { \
+#define DUK_CAT_CLEAR_FINALLY_ENABLED(c) \
+	do { \
 		(c)->flags &= ~DUK_CAT_FLAG_FINALLY_ENABLED; \
 	} while (0)
-#define DUK_CAT_CLEAR_CATCH_BINDING_ENABLED(c)    do { \
+#define DUK_CAT_CLEAR_CATCH_BINDING_ENABLED(c) \
+	do { \
 		(c)->flags &= ~DUK_CAT_FLAG_CATCH_BINDING_ENABLED; \
 	} while (0)
-#define DUK_CAT_CLEAR_LEXENV_ACTIVE(c)    do { \
+#define DUK_CAT_CLEAR_LEXENV_ACTIVE(c) \
+	do { \
 		(c)->flags &= ~DUK_CAT_FLAG_LEXENV_ACTIVE; \
 	} while (0)
 
 /*
  *  Thread defines
  */
 
 #if defined(DUK_USE_ROM_STRINGS)
-#define DUK_HTHREAD_GET_STRING(thr,idx) \
-	((duk_hstring *) DUK_LOSE_CONST(duk_rom_strings_stridx[(idx)]))
-#else  /* DUK_USE_ROM_STRINGS */
+#define DUK_HTHREAD_GET_STRING(thr, idx) ((duk_hstring *) DUK_LOSE_CONST(duk_rom_strings_stridx[(idx)]))
+#else /* DUK_USE_ROM_STRINGS */
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HTHREAD_GET_STRING(thr,idx) \
-	((duk_hstring *) DUK_USE_HEAPPTR_DEC16((thr)->heap->heap_udata, (thr)->strs16[(idx)]))
+#define DUK_HTHREAD_GET_STRING(thr, idx) ((duk_hstring *) DUK_USE_HEAPPTR_DEC16((thr)->heap->heap_udata, (thr)->strs16[(idx)]))
 #else
-#define DUK_HTHREAD_GET_STRING(thr,idx) \
-	((thr)->strs[(idx)])
+#define DUK_HTHREAD_GET_STRING(thr, idx) ((thr)->strs[(idx)])
 #endif
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 /* values for the state field */
-#define DUK_HTHREAD_STATE_INACTIVE     1   /* thread not currently running */
-#define DUK_HTHREAD_STATE_RUNNING      2   /* thread currently running (only one at a time) */
-#define DUK_HTHREAD_STATE_RESUMED      3   /* thread resumed another thread (active but not running) */
-#define DUK_HTHREAD_STATE_YIELDED      4   /* thread has yielded */
-#define DUK_HTHREAD_STATE_TERMINATED   5   /* thread has terminated */
+#define DUK_HTHREAD_STATE_INACTIVE   1 /* thread not currently running */
+#define DUK_HTHREAD_STATE_RUNNING    2 /* thread currently running (only one at a time) */
+#define DUK_HTHREAD_STATE_RESUMED    3 /* thread resumed another thread (active but not running) */
+#define DUK_HTHREAD_STATE_YIELDED    4 /* thread has yielded */
+#define DUK_HTHREAD_STATE_TERMINATED 5 /* thread has terminated */
 
 /* Executor interrupt default interval when nothing else requires a
  * smaller value.  The default interval must be small enough to allow
  * for reasonable execution timeout checking but large enough to keep
  * impact on execution performance low.
  */
 #if defined(DUK_USE_INTERRUPT_COUNTER)
-#define DUK_HTHREAD_INTCTR_DEFAULT     (256L * 1024L)
+#define DUK_HTHREAD_INTCTR_DEFAULT (256L * 1024L)
 #endif
 
 /*
  *  Assert context is valid: non-NULL pointer, fields look sane.
  *
  *  This is used by public API call entrypoints to catch invalid 'ctx' pointers
  *  as early as possible; invalid 'ctx' pointers cause very odd and difficult to
  *  diagnose behavior so it's worth checking even when the check is not 100%.
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 /* Assertions for internals. */
 DUK_INTERNAL_DECL void duk_hthread_assert_valid(duk_hthread *thr);
-#define DUK_HTHREAD_ASSERT_VALID(thr)  do { duk_hthread_assert_valid((thr)); } while (0)
+#define DUK_HTHREAD_ASSERT_VALID(thr) \
+	do { \
+		duk_hthread_assert_valid((thr)); \
+	} while (0)
 
 /* Assertions for public API calls; a bit stronger. */
 DUK_INTERNAL_DECL void duk_ctx_assert_valid(duk_hthread *thr);
-#define DUK_CTX_ASSERT_VALID(thr)  do { duk_ctx_assert_valid((thr)); } while (0)
+#define DUK_CTX_ASSERT_VALID(thr) \
+	do { \
+		duk_ctx_assert_valid((thr)); \
+	} while (0)
 #else
-#define DUK_HTHREAD_ASSERT_VALID(thr)  do {} while (0)
-#define DUK_CTX_ASSERT_VALID(thr)  do {} while (0)
+#define DUK_HTHREAD_ASSERT_VALID(thr) \
+	do { \
+	} while (0)
+#define DUK_CTX_ASSERT_VALID(thr) \
+	do { \
+	} while (0)
 #endif
 
 /* Assertions for API call entry specifically.  Checks 'ctx' but also may
  * check internal state (e.g. not in a debugger transport callback).
  */
-#define DUK_ASSERT_API_ENTRY(thr) do { \
+#define DUK_ASSERT_API_ENTRY(thr) \
+	do { \
 		DUK_CTX_ASSERT_VALID((thr)); \
 		DUK_ASSERT((thr)->heap != NULL); \
 		DUK_ASSERT((thr)->heap->dbg_calling_transport == 0); \
 	} while (0)
 
 /*
  *  Assertion helpers.
  */
 
-#define DUK_ASSERT_STRIDX_VALID(val) \
-	DUK_ASSERT((duk_uint_t) (val) < DUK_HEAP_NUM_STRINGS)
+#define DUK_ASSERT_STRIDX_VALID(val) DUK_ASSERT((duk_uint_t) (val) < DUK_HEAP_NUM_STRINGS)
 
-#define DUK_ASSERT_BIDX_VALID(val) \
-	DUK_ASSERT((duk_uint_t) (val) < DUK_NUM_BUILTINS)
+#define DUK_ASSERT_BIDX_VALID(val) DUK_ASSERT((duk_uint_t) (val) < DUK_NUM_BUILTINS)
 
 /*
  *  Misc
  */
 
 /* Fast access to 'this' binding.  Assumes there's a call in progress. */
 #define DUK_HTHREAD_THIS_PTR(thr) \
-	(DUK_ASSERT_EXPR((thr) != NULL), \
-	 DUK_ASSERT_EXPR((thr)->valstack_bottom > (thr)->valstack), \
-	 (thr)->valstack_bottom - 1)
+	(DUK_ASSERT_EXPR((thr) != NULL), DUK_ASSERT_EXPR((thr)->valstack_bottom > (thr)->valstack), (thr)->valstack_bottom - 1)
 
 /*
  *  Struct defines
  */
 
 /* Fields are ordered for alignment/packing. */
 struct duk_activation {
-	duk_tval tv_func;       /* borrowed: full duk_tval for function being executed; for lightfuncs */
-	duk_hobject *func;      /* borrowed: function being executed; for bound function calls, this is the final, real function, NULL for lightfuncs */
+	duk_tval tv_func; /* borrowed: full duk_tval for function being executed; for lightfuncs */
+	duk_hobject *func; /* borrowed: function being executed; for bound function calls, this is the final, real function, NULL
+	                      for lightfuncs */
 	duk_activation *parent; /* previous (parent) activation (or NULL if none) */
-	duk_hobject *var_env;   /* current variable environment (may be NULL if delayed) */
-	duk_hobject *lex_env;   /* current lexical environment (may be NULL if delayed) */
-	duk_catcher *cat;       /* current catcher (or NULL) */
+	duk_hobject *var_env; /* current variable environment (may be NULL if delayed) */
+	duk_hobject *lex_env; /* current lexical environment (may be NULL if delayed) */
+	duk_catcher *cat; /* current catcher (or NULL) */
 
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 	/* Previous value of 'func' caller, restored when unwound.  Only in use
 	 * when 'func' is non-strict.
 	 */
 	duk_hobject *prev_caller;
 #endif
 
-	duk_instr_t *curr_pc;   /* next instruction to execute (points to 'func' bytecode, stable pointer), NULL for native calls */
+	duk_instr_t *curr_pc; /* next instruction to execute (points to 'func' bytecode, stable pointer), NULL for native calls */
 
 	/* bottom_byteoff and retval_byteoff are only used for book-keeping
 	 * of ECMAScript-initiated calls, to allow returning to an ECMAScript
 	 * function properly.
 	 */
 
 	/* Bottom of valstack for this activation, used to reset
@@ -7859,20 +8312,20 @@
 	duk_uint32_t prev_line; /* needed for stepping */
 #endif
 
 	duk_small_uint_t flags;
 };
 
 struct duk_catcher {
-	duk_catcher *parent;            /* previous (parent) catcher (or NULL if none) */
-	duk_hstring *h_varname;         /* borrowed reference to catch variable name (or NULL if none) */
-	                                /* (reference is valid as long activation exists) */
-	duk_instr_t *pc_base;           /* resume execution from pc_base or pc_base+1 (points to 'func' bytecode, stable pointer) */
-	duk_size_t idx_base;            /* idx_base and idx_base+1 get completion value and type */
-	duk_uint32_t flags;             /* type and control flags, label number */
+	duk_catcher *parent; /* previous (parent) catcher (or NULL if none) */
+	duk_hstring *h_varname; /* borrowed reference to catch variable name (or NULL if none) */
+	/* (reference is valid as long activation exists) */
+	duk_instr_t *pc_base; /* resume execution from pc_base or pc_base+1 (points to 'func' bytecode, stable pointer) */
+	duk_size_t idx_base; /* idx_base and idx_base+1 get completion value and type */
+	duk_uint32_t flags; /* type and control flags, label number */
 	/* XXX: could pack 'flags' and 'idx_base' to same value in practice,
 	 * on 32-bit targets this would make duk_catcher 16 bytes.
 	 */
 };
 
 struct duk_hthread {
 	/* Shared object part */
@@ -7922,43 +8375,43 @@
 	 * |             |             |          |              |
 	 * valstack      bottom        top        end            alloc_end
 	 *
 	 *     xxx = arbitrary values, below current frame
 	 *     yyy = arbitrary values, inside current frame
 	 *     uuu = outside active value stack, initialized to 'undefined'
 	 */
-	duk_tval *valstack;                     /* start of valstack allocation */
-	duk_tval *valstack_end;                 /* end of valstack reservation/guarantee (exclusive) */
-	duk_tval *valstack_alloc_end;           /* end of valstack allocation */
-	duk_tval *valstack_bottom;              /* bottom of current frame */
-	duk_tval *valstack_top;                 /* top of current frame (exclusive) */
+	duk_tval *valstack; /* start of valstack allocation */
+	duk_tval *valstack_end; /* end of valstack reservation/guarantee (exclusive) */
+	duk_tval *valstack_alloc_end; /* end of valstack allocation */
+	duk_tval *valstack_bottom; /* bottom of current frame */
+	duk_tval *valstack_top; /* top of current frame (exclusive) */
 
 	/* Call stack, represented as a linked list starting from the current
 	 * activation (or NULL if nothing is active).
 	 */
-	duk_activation *callstack_curr;         /* current activation (or NULL if none) */
-	duk_size_t callstack_top;               /* number of activation records in callstack (0 if none) */
-	duk_size_t callstack_preventcount;      /* number of activation records in callstack preventing a yield */
+	duk_activation *callstack_curr; /* current activation (or NULL if none) */
+	duk_size_t callstack_top; /* number of activation records in callstack (0 if none) */
+	duk_size_t callstack_preventcount; /* number of activation records in callstack preventing a yield */
 
 	/* Yield/resume book-keeping. */
-	duk_hthread *resumer;                   /* who resumed us (if any) */
+	duk_hthread *resumer; /* who resumed us (if any) */
 
 	/* Current compiler state (if any), used for augmenting SyntaxErrors. */
 	duk_compiler_ctx *compile_ctx;
 
 #if defined(DUK_USE_INTERRUPT_COUNTER)
 	/* Interrupt counter for triggering a slow path check for execution
 	 * timeout, debugger interaction such as breakpoints, etc.  The value
 	 * is valid for the current running thread, and both the init and
 	 * counter values are copied whenever a thread switch occurs.  It's
 	 * important for the counter to be conveniently accessible for the
 	 * bytecode executor inner loop for performance reasons.
 	 */
-	duk_int_t interrupt_counter;    /* countdown state */
-	duk_int_t interrupt_init;       /* start value for current countdown */
+	duk_int_t interrupt_counter; /* countdown state */
+	duk_int_t interrupt_init; /* start value for current countdown */
 #endif
 
 	/* Builtin-objects; may or may not be shared with other threads,
 	 * threads existing in different "compartments" will have different
 	 * built-ins.  Must be stored on a per-thread basis because there
 	 * is no intermediate structure for a thread group / compartment.
 	 * This takes quite a lot of space, currently 43x4 = 172 bytes on
@@ -8002,24 +8455,24 @@
 DUK_INTERNAL_DECL void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act);
 DUK_INTERNAL_DECL void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act);
 
 #if defined(DUK_USE_FINALIZER_TORTURE)
 DUK_INTERNAL_DECL void duk_hthread_valstack_torture_realloc(duk_hthread *thr);
 #endif
 
-DUK_INTERNAL_DECL void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud);  /* indirect allocs */
+DUK_INTERNAL_DECL void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud); /* indirect allocs */
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 DUK_INTERNAL_DECL duk_uint_fast32_t duk_hthread_get_act_curr_pc(duk_hthread *thr, duk_activation *act);
 #endif
 DUK_INTERNAL_DECL duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act);
 DUK_INTERNAL_DECL void duk_hthread_sync_currpc(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_hthread_sync_and_null_currpc(duk_hthread *thr);
 
-#endif  /* DUK_HTHREAD_H_INCLUDED */
+#endif /* DUK_HTHREAD_H_INCLUDED */
 /* #include duk_harray.h */
 #line 1 "duk_harray.h"
 /*
  *  Array object representation, used for actual Array instances.
  *
  *  All objects with the exotic array behavior (which must coincide with having
  *  internal class array) MUST be duk_harrays.  No other object can be a
@@ -8027,23 +8480,34 @@
  */
 
 #if !defined(DUK_HARRAY_H_INCLUDED)
 #define DUK_HARRAY_H_INCLUDED
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_harray_assert_valid(duk_harray *h);
-#define DUK_HARRAY_ASSERT_VALID(h)  do { duk_harray_assert_valid((h)); } while (0)
+#define DUK_HARRAY_ASSERT_VALID(h) \
+	do { \
+		duk_harray_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HARRAY_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HARRAY_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
-#define DUK_HARRAY_LENGTH_WRITABLE(h)         (!(h)->length_nonwritable)
-#define DUK_HARRAY_LENGTH_NONWRITABLE(h)      ((h)->length_nonwritable)
-#define DUK_HARRAY_SET_LENGTH_WRITABLE(h)     do { (h)->length_nonwritable = 0; } while (0)
-#define DUK_HARRAY_SET_LENGTH_NONWRITABLE(h)  do { (h)->length_nonwritable = 1; } while (0)
+#define DUK_HARRAY_LENGTH_WRITABLE(h)    (!(h)->length_nonwritable)
+#define DUK_HARRAY_LENGTH_NONWRITABLE(h) ((h)->length_nonwritable)
+#define DUK_HARRAY_SET_LENGTH_WRITABLE(h) \
+	do { \
+		(h)->length_nonwritable = 0; \
+	} while (0)
+#define DUK_HARRAY_SET_LENGTH_NONWRITABLE(h) \
+	do { \
+		(h)->length_nonwritable = 1; \
+	} while (0)
 
 struct duk_harray {
 	/* Shared object part. */
 	duk_hobject obj;
 
 	/* Array .length.
 	 *
@@ -8061,32 +8525,42 @@
 	 *
 	 * XXX: this field to be eliminated and moved into duk_hobject
 	 * flags field to save space.
 	 */
 	duk_bool_t length_nonwritable;
 };
 
-#endif  /* DUK_HARRAY_H_INCLUDED */
+#endif /* DUK_HARRAY_H_INCLUDED */
 /* #include duk_henv.h */
 #line 1 "duk_henv.h"
 /*
  *  Environment object representation.
  */
 
 #if !defined(DUK_HENV_H_INCLUDED)
 #define DUK_HENV_H_INCLUDED
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hdecenv_assert_valid(duk_hdecenv *h);
 DUK_INTERNAL_DECL void duk_hobjenv_assert_valid(duk_hobjenv *h);
-#define DUK_HDECENV_ASSERT_VALID(h)  do { duk_hdecenv_assert_valid((h)); } while (0)
-#define DUK_HOBJENV_ASSERT_VALID(h)  do { duk_hobjenv_assert_valid((h)); } while (0)
+#define DUK_HDECENV_ASSERT_VALID(h) \
+	do { \
+		duk_hdecenv_assert_valid((h)); \
+	} while (0)
+#define DUK_HOBJENV_ASSERT_VALID(h) \
+	do { \
+		duk_hobjenv_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HDECENV_ASSERT_VALID(h)  do {} while (0)
-#define DUK_HOBJENV_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HDECENV_ASSERT_VALID(h) \
+	do { \
+	} while (0)
+#define DUK_HOBJENV_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 struct duk_hdecenv {
 	/* Shared object part. */
 	duk_hobject obj;
 
 	/* These control variables provide enough information to access live
@@ -8108,15 +8582,15 @@
 	/* The 'target' object is used as a this binding in only some object
 	 * environments.  For example, the global environment does not provide
 	 * a this binding, but a with statement does.
 	 */
 	duk_bool_t has_this;
 };
 
-#endif  /* DUK_HENV_H_INCLUDED */
+#endif /* DUK_HENV_H_INCLUDED */
 /* #include duk_hbuffer.h */
 #line 1 "duk_hbuffer.h"
 /*
  *  Heap buffer representation.
  *
  *  Heap allocated user data buffer which is either:
  *
@@ -8133,162 +8607,173 @@
  *  Flags
  *
  *  Fixed buffer:     0
  *  Dynamic buffer:   DUK_HBUFFER_FLAG_DYNAMIC
  *  External buffer:  DUK_HBUFFER_FLAG_DYNAMIC | DUK_HBUFFER_FLAG_EXTERNAL
  */
 
-#define DUK_HBUFFER_FLAG_DYNAMIC                  DUK_HEAPHDR_USER_FLAG(0)    /* buffer is behind a pointer, dynamic or external */
-#define DUK_HBUFFER_FLAG_EXTERNAL                 DUK_HEAPHDR_USER_FLAG(1)    /* buffer pointer is to an externally allocated buffer */
+#define DUK_HBUFFER_FLAG_DYNAMIC  DUK_HEAPHDR_USER_FLAG(0) /* buffer is behind a pointer, dynamic or external */
+#define DUK_HBUFFER_FLAG_EXTERNAL DUK_HEAPHDR_USER_FLAG(1) /* buffer pointer is to an externally allocated buffer */
 
-#define DUK_HBUFFER_HAS_DYNAMIC(x)                DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
-#define DUK_HBUFFER_HAS_EXTERNAL(x)               DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
+#define DUK_HBUFFER_HAS_DYNAMIC(x)  DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
+#define DUK_HBUFFER_HAS_EXTERNAL(x) DUK_HEAPHDR_CHECK_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
 
-#define DUK_HBUFFER_SET_DYNAMIC(x)                DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
-#define DUK_HBUFFER_SET_EXTERNAL(x)               DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
+#define DUK_HBUFFER_SET_DYNAMIC(x)  DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
+#define DUK_HBUFFER_SET_EXTERNAL(x) DUK_HEAPHDR_SET_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
 
-#define DUK_HBUFFER_CLEAR_DYNAMIC(x)              DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
-#define DUK_HBUFFER_CLEAR_EXTERNAL(x)             DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
+#define DUK_HBUFFER_CLEAR_DYNAMIC(x)  DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_DYNAMIC)
+#define DUK_HBUFFER_CLEAR_EXTERNAL(x) DUK_HEAPHDR_CLEAR_FLAG_BITS(&(x)->hdr, DUK_HBUFFER_FLAG_EXTERNAL)
 
 /*
  *  Misc defines
  */
 
 /* Impose a maximum buffer length for now.  Restricted artificially to
  * ensure resize computations or adding a heap header length won't
  * overflow size_t and that a signed duk_int_t can hold a buffer
  * length.  The limit should be synchronized with DUK_HSTRING_MAX_BYTELEN.
  */
 
 #if defined(DUK_USE_BUFLEN16)
-#define DUK_HBUFFER_MAX_BYTELEN                   (0x0000ffffUL)
+#define DUK_HBUFFER_MAX_BYTELEN (0x0000ffffUL)
 #else
 /* Intentionally not 0x7fffffffUL; at least JSON code expects that
  * 2*len + 2 fits in 32 bits.
  */
-#define DUK_HBUFFER_MAX_BYTELEN                   (0x7ffffffeUL)
+#define DUK_HBUFFER_MAX_BYTELEN (0x7ffffffeUL)
 #endif
 
 /*
  *  Field access
  */
 
 #if defined(DUK_USE_BUFLEN16)
 /* size stored in duk_heaphdr unused flag bits */
-#define DUK_HBUFFER_GET_SIZE(x)     ((x)->hdr.h_flags >> 16)
-#define DUK_HBUFFER_SET_SIZE(x,v)   do { \
+#define DUK_HBUFFER_GET_SIZE(x) ((x)->hdr.h_flags >> 16)
+#define DUK_HBUFFER_SET_SIZE(x, v) \
+	do { \
 		duk_size_t duk__v; \
 		duk__v = (v); \
 		DUK_ASSERT(duk__v <= 0xffffUL); \
 		(x)->hdr.h_flags = ((x)->hdr.h_flags & 0x0000ffffUL) | (((duk_uint32_t) duk__v) << 16); \
 	} while (0)
-#define DUK_HBUFFER_ADD_SIZE(x,dv)  do { \
+#define DUK_HBUFFER_ADD_SIZE(x, dv) \
+	do { \
 		(x)->hdr.h_flags += ((dv) << 16); \
 	} while (0)
-#define DUK_HBUFFER_SUB_SIZE(x,dv)  do { \
+#define DUK_HBUFFER_SUB_SIZE(x, dv) \
+	do { \
 		(x)->hdr.h_flags -= ((dv) << 16); \
 	} while (0)
 #else
-#define DUK_HBUFFER_GET_SIZE(x)     (((duk_hbuffer *) (x))->size)
-#define DUK_HBUFFER_SET_SIZE(x,v)   do { \
+#define DUK_HBUFFER_GET_SIZE(x) (((duk_hbuffer *) (x))->size)
+#define DUK_HBUFFER_SET_SIZE(x, v) \
+	do { \
 		((duk_hbuffer *) (x))->size = (v); \
 	} while (0)
-#define DUK_HBUFFER_ADD_SIZE(x,dv)  do { \
+#define DUK_HBUFFER_ADD_SIZE(x, dv) \
+	do { \
 		(x)->size += (dv); \
 	} while (0)
-#define DUK_HBUFFER_SUB_SIZE(x,dv)  do { \
+#define DUK_HBUFFER_SUB_SIZE(x, dv) \
+	do { \
 		(x)->size -= (dv); \
 	} while (0)
 #endif
 
-#define DUK_HBUFFER_FIXED_GET_SIZE(x)       DUK_HBUFFER_GET_SIZE((duk_hbuffer *) (x))
-#define DUK_HBUFFER_FIXED_SET_SIZE(x,v)     DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x))
+#define DUK_HBUFFER_FIXED_GET_SIZE(x)    DUK_HBUFFER_GET_SIZE((duk_hbuffer *) (x))
+#define DUK_HBUFFER_FIXED_SET_SIZE(x, v) DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x))
 
 #define DUK_HBUFFER_DYNAMIC_GET_SIZE(x)     DUK_HBUFFER_GET_SIZE((duk_hbuffer *) (x))
-#define DUK_HBUFFER_DYNAMIC_SET_SIZE(x,v)   DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x), (v))
-#define DUK_HBUFFER_DYNAMIC_ADD_SIZE(x,dv)  DUK_HBUFFER_ADD_SIZE((duk_hbuffer *) (x), (dv))
-#define DUK_HBUFFER_DYNAMIC_SUB_SIZE(x,dv)  DUK_HBUFFER_SUB_SIZE((duk_hbuffer *) (x), (dv))
+#define DUK_HBUFFER_DYNAMIC_SET_SIZE(x, v)  DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x), (v))
+#define DUK_HBUFFER_DYNAMIC_ADD_SIZE(x, dv) DUK_HBUFFER_ADD_SIZE((duk_hbuffer *) (x), (dv))
+#define DUK_HBUFFER_DYNAMIC_SUB_SIZE(x, dv) DUK_HBUFFER_SUB_SIZE((duk_hbuffer *) (x), (dv))
 
 #define DUK_HBUFFER_EXTERNAL_GET_SIZE(x)    DUK_HBUFFER_GET_SIZE((duk_hbuffer *) (x))
-#define DUK_HBUFFER_EXTERNAL_SET_SIZE(x,v)  DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x), (v))
+#define DUK_HBUFFER_EXTERNAL_SET_SIZE(x, v) DUK_HBUFFER_SET_SIZE((duk_hbuffer *) (x), (v))
 
-#define DUK_HBUFFER_FIXED_GET_DATA_PTR(heap,x)    ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (x)) + 1))
+#define DUK_HBUFFER_FIXED_GET_DATA_PTR(heap, x) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (x)) + 1))
 
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(heap,x) \
+#define DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(heap, x) \
 	((void *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, ((duk_heaphdr *) (x))->h_extra16))
-#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR(heap,x,v)     do { \
+#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR(heap, x, v) \
+	do { \
 		((duk_heaphdr *) (x))->h_extra16 = DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (void *) (v)); \
 	} while (0)
-#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR_NULL(heap,x)  do { \
-		((duk_heaphdr *) (x))->h_extra16 = 0;  /* assume 0 <=> NULL */ \
+#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR_NULL(heap, x) \
+	do { \
+		((duk_heaphdr *) (x))->h_extra16 = 0; /* assume 0 <=> NULL */ \
 	} while (0)
 #else
-#define DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(heap,x)       ((x)->curr_alloc)
-#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR(heap,x,v)     do { \
+#define DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(heap, x) ((x)->curr_alloc)
+#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR(heap, x, v) \
+	do { \
 		(x)->curr_alloc = (void *) (v); \
 	} while (0)
-#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR_NULL(heap,x)  do { \
+#define DUK_HBUFFER_DYNAMIC_SET_DATA_PTR_NULL(heap, x) \
+	do { \
 		(x)->curr_alloc = (void *) NULL; \
 	} while (0)
 #endif
 
 /* No pointer compression because pointer is potentially outside of
  * Duktape heap.
  */
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(heap,x) \
-	((void *) (x)->curr_alloc)
-#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR(heap,x,v)     do { \
+#define DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(heap, x) ((void *) (x)->curr_alloc)
+#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR(heap, x, v) \
+	do { \
 		(x)->curr_alloc = (void *) (v); \
 	} while (0)
-#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR_NULL(heap,x)  do { \
+#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR_NULL(heap, x) \
+	do { \
 		(x)->curr_alloc = (void *) NULL; \
 	} while (0)
 #else
-#define DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(heap,x) \
-	((void *) (x)->curr_alloc)
-#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR(heap,x,v)     do { \
+#define DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(heap, x) ((void *) (x)->curr_alloc)
+#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR(heap, x, v) \
+	do { \
 		(x)->curr_alloc = (void *) (v); \
 	} while (0)
-#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR_NULL(heap,x)  do { \
+#define DUK_HBUFFER_EXTERNAL_SET_DATA_PTR_NULL(heap, x) \
+	do { \
 		(x)->curr_alloc = (void *) NULL; \
 	} while (0)
 #endif
 
 /* Get a pointer to the current buffer contents (matching current allocation
  * size).  May be NULL for zero size dynamic/external buffer.
  */
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HBUFFER_GET_DATA_PTR(heap,x)  ( \
-	DUK_HBUFFER_HAS_DYNAMIC((x)) ? \
-		( \
-			DUK_HBUFFER_HAS_EXTERNAL((x)) ? \
-				DUK_HBUFFER_EXTERNAL_GET_DATA_PTR((heap), (duk_hbuffer_external *) (x)) : \
-				DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((heap), (duk_hbuffer_dynamic *) (x)) \
-		) : \
-		DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), (duk_hbuffer_fixed *) (void *) (x)) \
-	)
+#define DUK_HBUFFER_GET_DATA_PTR(heap, x) \
+	(DUK_HBUFFER_HAS_DYNAMIC((x)) ? \
+             (DUK_HBUFFER_HAS_EXTERNAL((x)) ? DUK_HBUFFER_EXTERNAL_GET_DATA_PTR((heap), (duk_hbuffer_external *) (x)) : \
+                                              DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((heap), (duk_hbuffer_dynamic *) (x))) : \
+             DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), (duk_hbuffer_fixed *) (void *) (x)))
 #else
 /* Without heap pointer compression duk_hbuffer_dynamic and duk_hbuffer_external
  * have the same layout so checking for fixed vs. dynamic (or external) is enough.
  */
-#define DUK_HBUFFER_GET_DATA_PTR(heap,x)  ( \
-	DUK_HBUFFER_HAS_DYNAMIC((x)) ? \
-		DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((heap), (duk_hbuffer_dynamic *) (x)) : \
-		DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), (duk_hbuffer_fixed *) (void *) (x)) \
-	)
+#define DUK_HBUFFER_GET_DATA_PTR(heap, x) \
+	(DUK_HBUFFER_HAS_DYNAMIC((x)) ? DUK_HBUFFER_DYNAMIC_GET_DATA_PTR((heap), (duk_hbuffer_dynamic *) (x)) : \
+                                        DUK_HBUFFER_FIXED_GET_DATA_PTR((heap), (duk_hbuffer_fixed *) (void *) (x)))
 #endif
 
 /* Validity assert. */
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hbuffer_assert_valid(duk_hbuffer *h);
-#define DUK_HBUFFER_ASSERT_VALID(h)  do { duk_hbuffer_assert_valid((h)); } while (0)
+#define DUK_HBUFFER_ASSERT_VALID(h) \
+	do { \
+		duk_hbuffer_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HBUFFER_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HBUFFER_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Structs
  */
 
 /* Shared prefix for all buffer types. */
@@ -8378,17 +8863,17 @@
 	 *  by 8 is required, the struct size must be forced to be a multiple
 	 *  of 8 by some means.  Without it, some user code may break, and also
 	 *  Duktape itself breaks (e.g. the compiler stores duk_tvals in a
 	 *  dynamic buffer).
 	 */
 }
 #if (DUK_USE_ALIGN_BY == 8) && defined(DUK_USE_PACK_GCC_ATTR)
-__attribute__ ((aligned (8)))
+__attribute__((aligned(8)))
 #elif (DUK_USE_ALIGN_BY == 8) && defined(DUK_USE_PACK_CLANG_ATTR)
-__attribute__ ((aligned (8)))
+__attribute__((aligned(8)))
 #endif
 ;
 #if (DUK_USE_ALIGN_BY == 8) && defined(DUK_USE_PACK_MSVC_PRAGMA)
 #pragma pack(pop)
 #endif
 
 /* Dynamic buffer with 'curr_alloc' pointing to a dynamic area allocated using
@@ -8403,15 +8888,15 @@
 #else
 	duk_size_t size;
 #endif
 
 #if defined(DUK_USE_HEAPPTR16)
 	/* Stored in duk_heaphdr h_extra16. */
 #else
-	void *curr_alloc;  /* may be NULL if alloc_size == 0 */
+	void *curr_alloc; /* may be NULL if alloc_size == 0 */
 #endif
 
 	/*
 	 *  Allocation size for 'curr_alloc' is alloc_size.  There is no
 	 *  automatic NUL terminator for buffers (see above for rationale).
 	 *
 	 *  'curr_alloc' is explicitly allocated with heap allocation
@@ -8432,57 +8917,62 @@
 #else
 	duk_size_t size;
 #endif
 
 	/* Cannot be compressed as a heap pointer because may point to
 	 * an arbitrary address.
 	 */
-	void *curr_alloc;  /* may be NULL if alloc_size == 0 */
+	void *curr_alloc; /* may be NULL if alloc_size == 0 */
 };
 
 /*
  *  Prototypes
  */
 
 DUK_INTERNAL_DECL duk_hbuffer *duk_hbuffer_alloc(duk_heap *heap, duk_size_t size, duk_small_uint_t flags, void **out_bufdata);
-DUK_INTERNAL_DECL void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud);  /* indirect allocs */
+DUK_INTERNAL_DECL void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud); /* indirect allocs */
 
 /* dynamic buffer ops */
 DUK_INTERNAL_DECL void duk_hbuffer_resize(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t new_size);
 DUK_INTERNAL_DECL void duk_hbuffer_reset(duk_hthread *thr, duk_hbuffer_dynamic *buf);
 
-#endif  /* DUK_HBUFFER_H_INCLUDED */
+#endif /* DUK_HBUFFER_H_INCLUDED */
 /* #include duk_hproxy.h */
 #line 1 "duk_hproxy.h"
 /*
  *  Proxy object representation.
  */
 
 #if !defined(DUK_HPROXY_H_INCLUDED)
 #define DUK_HPROXY_H_INCLUDED
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_hproxy_assert_valid(duk_hproxy *h);
-#define DUK_HPROXY_ASSERT_VALID(h)  do { duk_hproxy_assert_valid((h)); } while (0)
+#define DUK_HPROXY_ASSERT_VALID(h) \
+	do { \
+		duk_hproxy_assert_valid((h)); \
+	} while (0)
 #else
-#define DUK_HPROXY_ASSERT_VALID(h)  do {} while (0)
+#define DUK_HPROXY_ASSERT_VALID(h) \
+	do { \
+	} while (0)
 #endif
 
 struct duk_hproxy {
 	/* Shared object part. */
 	duk_hobject obj;
 
 	/* Proxy target object. */
 	duk_hobject *target;
 
 	/* Proxy handlers (traps). */
 	duk_hobject *handler;
 };
 
-#endif  /* DUK_HPROXY_H_INCLUDED */
+#endif /* DUK_HPROXY_H_INCLUDED */
 /* #include duk_heap.h */
 #line 1 "duk_heap.h"
 /*
  *  Heap structure.
  *
  *  Heap contains allocated heap objects, interned strings, and built-in
  *  strings for one or more threads.
@@ -8493,106 +8983,114 @@
 
 /* alloc function typedefs in duktape.h */
 
 /*
  *  Heap flags
  */
 
-#define DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED            (1U << 0)  /* mark-and-sweep marking reached a recursion limit and must use multi-pass marking */
-#define DUK_HEAP_FLAG_INTERRUPT_RUNNING                        (1U << 1)  /* executor interrupt running (used to avoid nested interrupts) */
-#define DUK_HEAP_FLAG_FINALIZER_NORESCUE                       (1U << 2)  /* heap destruction ongoing, finalizer rescue no longer possible */
-#define DUK_HEAP_FLAG_DEBUGGER_PAUSED                          (1U << 3)  /* debugger is paused: talk with debug client until step/resume */
-
-#define DUK__HEAP_HAS_FLAGS(heap,bits)               ((heap)->flags & (bits))
-#define DUK__HEAP_SET_FLAGS(heap,bits)  do { \
+#define DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED \
+	(1U << 0) /* mark-and-sweep marking reached a recursion limit and must use multi-pass marking */
+#define DUK_HEAP_FLAG_INTERRUPT_RUNNING  (1U << 1) /* executor interrupt running (used to avoid nested interrupts) */
+#define DUK_HEAP_FLAG_FINALIZER_NORESCUE (1U << 2) /* heap destruction ongoing, finalizer rescue no longer possible */
+#define DUK_HEAP_FLAG_DEBUGGER_PAUSED    (1U << 3) /* debugger is paused: talk with debug client until step/resume */
+
+#define DUK__HEAP_HAS_FLAGS(heap, bits) ((heap)->flags & (bits))
+#define DUK__HEAP_SET_FLAGS(heap, bits) \
+	do { \
 		(heap)->flags |= (bits); \
 	} while (0)
-#define DUK__HEAP_CLEAR_FLAGS(heap,bits)  do { \
+#define DUK__HEAP_CLEAR_FLAGS(heap, bits) \
+	do { \
 		(heap)->flags &= ~(bits); \
 	} while (0)
 
-#define DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED(heap)   DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
-#define DUK_HEAP_HAS_INTERRUPT_RUNNING(heap)               DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
-#define DUK_HEAP_HAS_FINALIZER_NORESCUE(heap)              DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
-#define DUK_HEAP_HAS_DEBUGGER_PAUSED(heap)                 DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
-
-#define DUK_HEAP_SET_MARKANDSWEEP_RECLIMIT_REACHED(heap)   DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
-#define DUK_HEAP_SET_INTERRUPT_RUNNING(heap)               DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
-#define DUK_HEAP_SET_FINALIZER_NORESCUE(heap)              DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
-#define DUK_HEAP_SET_DEBUGGER_PAUSED(heap)                 DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
-
-#define DUK_HEAP_CLEAR_MARKANDSWEEP_RECLIMIT_REACHED(heap) DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
-#define DUK_HEAP_CLEAR_INTERRUPT_RUNNING(heap)             DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
-#define DUK_HEAP_CLEAR_FINALIZER_NORESCUE(heap)            DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
-#define DUK_HEAP_CLEAR_DEBUGGER_PAUSED(heap)               DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
+#define DUK_HEAP_HAS_MARKANDSWEEP_RECLIMIT_REACHED(heap) DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
+#define DUK_HEAP_HAS_INTERRUPT_RUNNING(heap)             DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
+#define DUK_HEAP_HAS_FINALIZER_NORESCUE(heap)            DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
+#define DUK_HEAP_HAS_DEBUGGER_PAUSED(heap)               DUK__HEAP_HAS_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
+
+#define DUK_HEAP_SET_MARKANDSWEEP_RECLIMIT_REACHED(heap) DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
+#define DUK_HEAP_SET_INTERRUPT_RUNNING(heap)             DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
+#define DUK_HEAP_SET_FINALIZER_NORESCUE(heap)            DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
+#define DUK_HEAP_SET_DEBUGGER_PAUSED(heap)               DUK__HEAP_SET_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
+
+#define DUK_HEAP_CLEAR_MARKANDSWEEP_RECLIMIT_REACHED(heap) \
+	DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_MARKANDSWEEP_RECLIMIT_REACHED)
+#define DUK_HEAP_CLEAR_INTERRUPT_RUNNING(heap)  DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_INTERRUPT_RUNNING)
+#define DUK_HEAP_CLEAR_FINALIZER_NORESCUE(heap) DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_FINALIZER_NORESCUE)
+#define DUK_HEAP_CLEAR_DEBUGGER_PAUSED(heap)    DUK__HEAP_CLEAR_FLAGS((heap), DUK_HEAP_FLAG_DEBUGGER_PAUSED)
 
 /*
  *  Longjmp types, also double as identifying continuation type for a rethrow (in 'finally')
  */
 
-#define DUK_LJ_TYPE_UNKNOWN      0    /* unused */
-#define DUK_LJ_TYPE_THROW        1    /* value1 -> error object */
-#define DUK_LJ_TYPE_YIELD        2    /* value1 -> yield value, iserror -> error / normal */
-#define DUK_LJ_TYPE_RESUME       3    /* value1 -> resume value, value2 -> resumee thread, iserror -> error/normal */
-#define DUK_LJ_TYPE_BREAK        4    /* value1 -> label number, pseudo-type to indicate a break continuation (for ENDFIN) */
-#define DUK_LJ_TYPE_CONTINUE     5    /* value1 -> label number, pseudo-type to indicate a continue continuation (for ENDFIN) */
-#define DUK_LJ_TYPE_RETURN       6    /* value1 -> return value, pseudo-type to indicate a return continuation (for ENDFIN) */
-#define DUK_LJ_TYPE_NORMAL       7    /* no value, pseudo-type to indicate a normal continuation (for ENDFIN) */
+#define DUK_LJ_TYPE_UNKNOWN  0 /* unused */
+#define DUK_LJ_TYPE_THROW    1 /* value1 -> error object */
+#define DUK_LJ_TYPE_YIELD    2 /* value1 -> yield value, iserror -> error / normal */
+#define DUK_LJ_TYPE_RESUME   3 /* value1 -> resume value, value2 -> resumee thread, iserror -> error/normal */
+#define DUK_LJ_TYPE_BREAK    4 /* value1 -> label number, pseudo-type to indicate a break continuation (for ENDFIN) */
+#define DUK_LJ_TYPE_CONTINUE 5 /* value1 -> label number, pseudo-type to indicate a continue continuation (for ENDFIN) */
+#define DUK_LJ_TYPE_RETURN   6 /* value1 -> return value, pseudo-type to indicate a return continuation (for ENDFIN) */
+#define DUK_LJ_TYPE_NORMAL   7 /* no value, pseudo-type to indicate a normal continuation (for ENDFIN) */
 
 /*
  *  Mark-and-sweep flags
  *
  *  These are separate from heap level flags now but could be merged.
  *  The heap structure only contains a 'base mark-and-sweep flags'
  *  field and the GC caller can impose further flags.
  */
 
 /* Emergency mark-and-sweep: try extra hard, even at the cost of
  * performance.
  */
-#define DUK_MS_FLAG_EMERGENCY                (1U << 0)
+#define DUK_MS_FLAG_EMERGENCY (1U << 0)
 
 /* Postpone rescue decisions for reachable objects with FINALIZED set.
  * Used during finalize_list processing to avoid incorrect rescue
  * decisions due to finalize_list being a reachability root.
  */
-#define DUK_MS_FLAG_POSTPONE_RESCUE          (1U << 1)
+#define DUK_MS_FLAG_POSTPONE_RESCUE (1U << 1)
 
 /* Don't compact objects; needed during object property table resize
  * to prevent a recursive resize.  It would suffice to protect only the
  * current object being resized, but this is not yet implemented.
  */
-#define DUK_MS_FLAG_NO_OBJECT_COMPACTION     (1U << 2)
+#define DUK_MS_FLAG_NO_OBJECT_COMPACTION (1U << 2)
 
 /*
  *  Thread switching
  *
  *  To switch heap->curr_thread, use the macro below so that interrupt counters
  *  get updated correctly.  The macro allows a NULL target thread because that
  *  happens e.g. in call handling.
  */
 
 #if defined(DUK_USE_INTERRUPT_COUNTER)
-#define DUK_HEAP_SWITCH_THREAD(heap,newthr)  duk_heap_switch_thread((heap), (newthr))
+#define DUK_HEAP_SWITCH_THREAD(heap, newthr) duk_heap_switch_thread((heap), (newthr))
 #else
-#define DUK_HEAP_SWITCH_THREAD(heap,newthr)  do { \
+#define DUK_HEAP_SWITCH_THREAD(heap, newthr) \
+	do { \
 		(heap)->curr_thread = (newthr); \
 	} while (0)
 #endif
 
 /*
  *  Stats
  */
 
 #if defined(DUK_USE_DEBUG)
-#define DUK_STATS_INC(heap,fieldname) do { \
+#define DUK_STATS_INC(heap, fieldname) \
+	do { \
 		(heap)->fieldname += 1; \
 	} while (0)
 #else
-#define DUK_STATS_INC(heap,fieldname) do {} while (0)
+#define DUK_STATS_INC(heap, fieldname) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Other heap related defines
  */
 
 /* Mark-and-sweep interval is relative to combined count of objects and
@@ -8602,76 +9100,75 @@
  * refzero processed object.
  *
  * 'SKIP' indicates how many (re)allocations to wait until a retry if
  * GC is skipped because there is no thread do it with yet (happens
  * only during init phases).
  */
 #if defined(DUK_USE_REFERENCE_COUNTING)
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT              12800L  /* 50x heap size */
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD               1024L
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_SKIP              256L
-#else
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT              256L    /* 1x heap size */
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD               1024L
-#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_SKIP              256L
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT 12800L /* 50x heap size */
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD  1024L
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_SKIP 256L
+#else
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT 256L /* 1x heap size */
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD  1024L
+#define DUK_HEAP_MARK_AND_SWEEP_TRIGGER_SKIP 256L
 #endif
 
 /* GC torture. */
 #if defined(DUK_USE_GC_TORTURE)
-#define DUK_GC_TORTURE(heap) do { duk_heap_mark_and_sweep((heap), 0); } while (0)
+#define DUK_GC_TORTURE(heap) \
+	do { \
+		duk_heap_mark_and_sweep((heap), 0); \
+	} while (0)
 #else
-#define DUK_GC_TORTURE(heap) do { } while (0)
+#define DUK_GC_TORTURE(heap) \
+	do { \
+	} while (0)
 #endif
 
 /* Stringcache is used for speeding up char-offset-to-byte-offset
  * translations for non-ASCII strings.
  */
-#define DUK_HEAP_STRCACHE_SIZE                            4
-#define DUK_HEAP_STRINGCACHE_NOCACHE_LIMIT                16  /* strings up to the this length are not cached */
+#define DUK_HEAP_STRCACHE_SIZE             4
+#define DUK_HEAP_STRINGCACHE_NOCACHE_LIMIT 16 /* strings up to the this length are not cached */
 
 /* Some list management macros. */
-#define DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap,hdr)     duk_heap_insert_into_heap_allocated((heap), (hdr))
+#define DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap, hdr) duk_heap_insert_into_heap_allocated((heap), (hdr))
 #if defined(DUK_USE_REFERENCE_COUNTING)
-#define DUK_HEAP_REMOVE_FROM_HEAP_ALLOCATED(heap,hdr)     duk_heap_remove_from_heap_allocated((heap), (hdr))
+#define DUK_HEAP_REMOVE_FROM_HEAP_ALLOCATED(heap, hdr) duk_heap_remove_from_heap_allocated((heap), (hdr))
 #endif
 #if defined(DUK_USE_FINALIZER_SUPPORT)
-#define DUK_HEAP_INSERT_INTO_FINALIZE_LIST(heap,hdr)      duk_heap_insert_into_finalize_list((heap), (hdr))
-#define DUK_HEAP_REMOVE_FROM_FINALIZE_LIST(heap,hdr)      duk_heap_remove_from_finalize_list((heap), (hdr))
+#define DUK_HEAP_INSERT_INTO_FINALIZE_LIST(heap, hdr) duk_heap_insert_into_finalize_list((heap), (hdr))
+#define DUK_HEAP_REMOVE_FROM_FINALIZE_LIST(heap, hdr) duk_heap_remove_from_finalize_list((heap), (hdr))
 #endif
 
 /*
  *  Built-in strings
  */
 
 /* heap string indices are autogenerated in duk_strings.h */
 #if defined(DUK_USE_ROM_STRINGS)
-#define DUK_HEAP_GET_STRING(heap,idx) \
-	((duk_hstring *) DUK_LOSE_CONST(duk_rom_strings_stridx[(idx)]))
-#else  /* DUK_USE_ROM_STRINGS */
+#define DUK_HEAP_GET_STRING(heap, idx) ((duk_hstring *) DUK_LOSE_CONST(duk_rom_strings_stridx[(idx)]))
+#else /* DUK_USE_ROM_STRINGS */
 #if defined(DUK_USE_HEAPPTR16)
-#define DUK_HEAP_GET_STRING(heap,idx) \
-	((duk_hstring *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (heap)->strs16[(idx)]))
+#define DUK_HEAP_GET_STRING(heap, idx) ((duk_hstring *) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (heap)->strs16[(idx)]))
 #else
-#define DUK_HEAP_GET_STRING(heap,idx) \
-	((heap)->strs[(idx)])
+#define DUK_HEAP_GET_STRING(heap, idx) ((heap)->strs[(idx)])
 #endif
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 /*
  *  Raw memory calls: relative to heap, but no GC interaction
  */
 
-#define DUK_ALLOC_RAW(heap,size) \
-	((heap)->alloc_func((heap)->heap_udata, (size)))
+#define DUK_ALLOC_RAW(heap, size) ((heap)->alloc_func((heap)->heap_udata, (size)))
 
-#define DUK_REALLOC_RAW(heap,ptr,newsize) \
-	((heap)->realloc_func((heap)->heap_udata, (void *) (ptr), (newsize)))
+#define DUK_REALLOC_RAW(heap, ptr, newsize) ((heap)->realloc_func((heap)->heap_udata, (void *) (ptr), (newsize)))
 
-#define DUK_FREE_RAW(heap,ptr) \
-	((heap)->free_func((heap)->heap_udata, (void *) (ptr)))
+#define DUK_FREE_RAW(heap, ptr) ((heap)->free_func((heap)->heap_udata, (void *) (ptr)))
 
 /*
  *  Memory calls: relative to heap, GC interaction, but no error throwing.
  *
  *  XXX: Currently a mark-and-sweep triggered by memory allocation will run
  *  using the heap->heap_thread.  This thread is also used for running
  *  mark-and-sweep finalization; this is not ideal because it breaks the
@@ -8696,73 +9193,75 @@
  *      pointer (void **) approach.  Note: the pointer in the storage
  *      location is read but is NOT updated; the caller must do that.
  */
 
 /* callback for indirect reallocs, request for current pointer */
 typedef void *(*duk_mem_getptr)(duk_heap *heap, void *ud);
 
-#define DUK_ALLOC(heap,size)                            duk_heap_mem_alloc((heap), (size))
-#define DUK_ALLOC_ZEROED(heap,size)                     duk_heap_mem_alloc_zeroed((heap), (size))
-#define DUK_REALLOC(heap,ptr,newsize)                   duk_heap_mem_realloc((heap), (ptr), (newsize))
-#define DUK_REALLOC_INDIRECT(heap,cb,ud,newsize)        duk_heap_mem_realloc_indirect((heap), (cb), (ud), (newsize))
-#define DUK_FREE(heap,ptr)                              duk_heap_mem_free((heap), (ptr))
+#define DUK_ALLOC(heap, size)                       duk_heap_mem_alloc((heap), (size))
+#define DUK_ALLOC_ZEROED(heap, size)                duk_heap_mem_alloc_zeroed((heap), (size))
+#define DUK_REALLOC(heap, ptr, newsize)             duk_heap_mem_realloc((heap), (ptr), (newsize))
+#define DUK_REALLOC_INDIRECT(heap, cb, ud, newsize) duk_heap_mem_realloc_indirect((heap), (cb), (ud), (newsize))
+#define DUK_FREE(heap, ptr)                         duk_heap_mem_free((heap), (ptr))
 
 /*
  *  Checked allocation, relative to a thread
  *
  *  DUK_FREE_CHECKED() doesn't actually throw, but accepts a 'thr' argument
  *  for convenience.
  */
 
-#define DUK_ALLOC_CHECKED(thr,size)                     duk_heap_mem_alloc_checked((thr), (size))
-#define DUK_ALLOC_CHECKED_ZEROED(thr,size)              duk_heap_mem_alloc_checked_zeroed((thr), (size))
-#define DUK_FREE_CHECKED(thr,ptr)                       duk_heap_mem_free((thr)->heap, (ptr))
+#define DUK_ALLOC_CHECKED(thr, size)        duk_heap_mem_alloc_checked((thr), (size))
+#define DUK_ALLOC_CHECKED_ZEROED(thr, size) duk_heap_mem_alloc_checked_zeroed((thr), (size))
+#define DUK_FREE_CHECKED(thr, ptr)          duk_heap_mem_free((thr)->heap, (ptr))
 
 /*
  *  Memory constants
  */
 
-#define DUK_HEAP_ALLOC_FAIL_MARKANDSWEEP_LIMIT           10  /* Retry allocation after mark-and-sweep for this
-                                                              * many times.  A single mark-and-sweep round is
-                                                              * not guaranteed to free all unreferenced memory
-                                                              * because of finalization (in fact, ANY number of
-                                                              * rounds is strictly not enough).
-                                                              */
-
-#define DUK_HEAP_ALLOC_FAIL_MARKANDSWEEP_EMERGENCY_LIMIT  3  /* Starting from this round, use emergency mode
-                                                              * for mark-and-sweep.
-                                                              */
+#define DUK_HEAP_ALLOC_FAIL_MARKANDSWEEP_LIMIT \
+	10 /* Retry allocation after mark-and-sweep for this \
+	    * many times.  A single mark-and-sweep round is \
+	    * not guaranteed to free all unreferenced memory \
+	    * because of finalization (in fact, ANY number of \
+	    * rounds is strictly not enough). \
+	    */
+
+#define DUK_HEAP_ALLOC_FAIL_MARKANDSWEEP_EMERGENCY_LIMIT \
+	3 /* Starting from this round, use emergency mode \
+	   * for mark-and-sweep. \
+	   */
 
 /*
  *  Debugger support
  */
 
 /* Maximum number of breakpoints.  Only breakpoints that are set are
  * consulted so increasing this has no performance impact.
  */
-#define DUK_HEAP_MAX_BREAKPOINTS          16
+#define DUK_HEAP_MAX_BREAKPOINTS 16
 
 /* Opcode interval for a Date-based status/peek rate limit check.  Only
  * relevant when debugger is attached.  Requesting a timestamp may be a
  * slow operation on some platforms so this shouldn't be too low.  On the
  * other hand a high value makes Duktape react to a pause request slowly.
  */
-#define DUK_HEAP_DBG_RATELIMIT_OPCODES    4000
+#define DUK_HEAP_DBG_RATELIMIT_OPCODES 4000
 
 /* Milliseconds between status notify and transport peeks. */
-#define DUK_HEAP_DBG_RATELIMIT_MILLISECS  200
+#define DUK_HEAP_DBG_RATELIMIT_MILLISECS 200
 
 /* Debugger pause flags. */
-#define DUK_PAUSE_FLAG_ONE_OPCODE        (1U << 0)   /* pause when a single opcode has been executed */
-#define DUK_PAUSE_FLAG_ONE_OPCODE_ACTIVE (1U << 1)   /* one opcode pause actually active; artifact of current implementation */
-#define DUK_PAUSE_FLAG_LINE_CHANGE       (1U << 2)   /* pause when current line number changes */
-#define DUK_PAUSE_FLAG_FUNC_ENTRY        (1U << 3)   /* pause when entering a function */
-#define DUK_PAUSE_FLAG_FUNC_EXIT         (1U << 4)   /* pause when exiting current function */
-#define DUK_PAUSE_FLAG_CAUGHT_ERROR      (1U << 5)   /* pause when about to throw an error that is caught */
-#define DUK_PAUSE_FLAG_UNCAUGHT_ERROR    (1U << 6)   /* pause when about to throw an error that won't be caught */
+#define DUK_PAUSE_FLAG_ONE_OPCODE        (1U << 0) /* pause when a single opcode has been executed */
+#define DUK_PAUSE_FLAG_ONE_OPCODE_ACTIVE (1U << 1) /* one opcode pause actually active; artifact of current implementation */
+#define DUK_PAUSE_FLAG_LINE_CHANGE       (1U << 2) /* pause when current line number changes */
+#define DUK_PAUSE_FLAG_FUNC_ENTRY        (1U << 3) /* pause when entering a function */
+#define DUK_PAUSE_FLAG_FUNC_EXIT         (1U << 4) /* pause when exiting current function */
+#define DUK_PAUSE_FLAG_CAUGHT_ERROR      (1U << 5) /* pause when about to throw an error that is caught */
+#define DUK_PAUSE_FLAG_UNCAUGHT_ERROR    (1U << 6) /* pause when about to throw an error that won't be caught */
 
 struct duk_breakpoint {
 	duk_hstring *filename;
 	duk_uint32_t line;
 };
 
 /*
@@ -8782,29 +9281,31 @@
 
 /*
  *  Longjmp state, contains the information needed to perform a longjmp.
  *  Longjmp related values are written to value1, value2, and iserror.
  */
 
 struct duk_ljstate {
-	duk_jmpbuf *jmpbuf_ptr;   /* current setjmp() catchpoint */
-	duk_small_uint_t type;    /* longjmp type */
-	duk_bool_t iserror;       /* isError flag for yield */
-	duk_tval value1;          /* 1st related value (type specific) */
-	duk_tval value2;          /* 2nd related value (type specific) */
+	duk_jmpbuf *jmpbuf_ptr; /* current setjmp() catchpoint */
+	duk_small_uint_t type; /* longjmp type */
+	duk_bool_t iserror; /* isError flag for yield */
+	duk_tval value1; /* 1st related value (type specific) */
+	duk_tval value2; /* 2nd related value (type specific) */
 };
 
-#define DUK_ASSERT_LJSTATE_UNSET(heap) do { \
+#define DUK_ASSERT_LJSTATE_UNSET(heap) \
+	do { \
 		DUK_ASSERT(heap != NULL); \
 		DUK_ASSERT(heap->lj.type == DUK_LJ_TYPE_UNKNOWN); \
 		DUK_ASSERT(heap->lj.iserror == 0); \
 		DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(&heap->lj.value1)); \
 		DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(&heap->lj.value2)); \
 	} while (0)
-#define DUK_ASSERT_LJSTATE_SET(heap) do { \
+#define DUK_ASSERT_LJSTATE_SET(heap) \
+	do { \
 		DUK_ASSERT(heap != NULL); \
 		DUK_ASSERT(heap->lj.type != DUK_LJ_TYPE_UNKNOWN); \
 	} while (0)
 
 /*
  *  Literal intern cache
  */
@@ -8816,17 +9317,22 @@
 
 /*
  *  Main heap structure
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL void duk_heap_assert_valid(duk_heap *heap);
-#define DUK_HEAP_ASSERT_VALID(heap)  do { duk_heap_assert_valid((heap)); } while (0)
+#define DUK_HEAP_ASSERT_VALID(heap) \
+	do { \
+		duk_heap_assert_valid((heap)); \
+	} while (0)
 #else
-#define DUK_HEAP_ASSERT_VALID(heap)  do {} while (0)
+#define DUK_HEAP_ASSERT_VALID(heap) \
+	do { \
+	} while (0)
 #endif
 
 struct duk_heap {
 	duk_small_uint_t flags;
 
 	/* Allocator functions. */
 	duk_alloc_function alloc_func;
@@ -8972,17 +9478,17 @@
 
 	/* Mix-in value for computing string hashes; should be reasonably unpredictable. */
 	duk_uint32_t hash_seed;
 
 	/* Random number state for duk_util_tinyrandom.c. */
 #if !defined(DUK_USE_GET_RANDOM_DOUBLE)
 #if defined(DUK_USE_PREFER_SIZE) || !defined(DUK_USE_64BIT_OPS)
-	duk_uint32_t rnd_state;  /* State for Shamir's three-op algorithm */
+	duk_uint32_t rnd_state; /* State for Shamir's three-op algorithm */
 #else
-	duk_uint64_t rnd_state[2];  /* State for xoroshiro128+ */
+	duk_uint64_t rnd_state[2]; /* State for xoroshiro128+ */
 #endif
 #endif
 
 	/* Counter for unique local symbol creation. */
 	/* XXX: When 64-bit types are available, it would be more efficient to
 	 * use a duk_uint64_t at least for incrementing but maybe also for
 	 * string formatting in the Symbol constructor.
@@ -8997,61 +9503,64 @@
 	duk_int_t inst_count_exec;
 	duk_int_t inst_count_interrupt;
 #endif
 
 	/* Debugger state. */
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	/* Callbacks and udata; dbg_read_cb != NULL is used to indicate attached state. */
-	duk_debug_read_function dbg_read_cb;                /* required, NULL implies detached */
-	duk_debug_write_function dbg_write_cb;              /* required */
+	duk_debug_read_function dbg_read_cb; /* required, NULL implies detached */
+	duk_debug_write_function dbg_write_cb; /* required */
 	duk_debug_peek_function dbg_peek_cb;
 	duk_debug_read_flush_function dbg_read_flush_cb;
 	duk_debug_write_flush_function dbg_write_flush_cb;
 	duk_debug_request_function dbg_request_cb;
 	duk_debug_detached_function dbg_detached_cb;
 	void *dbg_udata;
 
 	/* The following are only relevant when debugger is attached. */
-	duk_bool_t dbg_processing;              /* currently processing messages or breakpoints: don't enter message processing recursively (e.g. no breakpoints when processing debugger eval) */
-	duk_bool_t dbg_state_dirty;             /* resend state next time executor is about to run */
-	duk_bool_t dbg_force_restart;           /* force executor restart to recheck breakpoints; used to handle function returns (see GH-303) */
-	duk_bool_t dbg_detaching;               /* debugger detaching; used to avoid calling detach handler recursively */
-	duk_small_uint_t dbg_pause_flags;       /* flags for automatic pause behavior */
-	duk_activation *dbg_pause_act;          /* activation related to pause behavior (pause on line change, function entry/exit) */
-	duk_uint32_t dbg_pause_startline;       /* starting line number for line change related pause behavior */
-	duk_breakpoint dbg_breakpoints[DUK_HEAP_MAX_BREAKPOINTS];  /* breakpoints: [0,breakpoint_count[ gc reachable */
+	duk_bool_t dbg_processing; /* currently processing messages or breakpoints: don't enter message processing recursively (e.g.
+	                              no breakpoints when processing debugger eval) */
+	duk_bool_t dbg_state_dirty; /* resend state next time executor is about to run */
+	duk_bool_t
+	    dbg_force_restart; /* force executor restart to recheck breakpoints; used to handle function returns (see GH-303) */
+	duk_bool_t dbg_detaching; /* debugger detaching; used to avoid calling detach handler recursively */
+	duk_small_uint_t dbg_pause_flags; /* flags for automatic pause behavior */
+	duk_activation *dbg_pause_act; /* activation related to pause behavior (pause on line change, function entry/exit) */
+	duk_uint32_t dbg_pause_startline; /* starting line number for line change related pause behavior */
+	duk_breakpoint dbg_breakpoints[DUK_HEAP_MAX_BREAKPOINTS]; /* breakpoints: [0,breakpoint_count[ gc reachable */
 	duk_small_uint_t dbg_breakpoint_count;
-	duk_breakpoint *dbg_breakpoints_active[DUK_HEAP_MAX_BREAKPOINTS + 1];  /* currently active breakpoints: NULL term, borrowed pointers */
+	duk_breakpoint
+	    *dbg_breakpoints_active[DUK_HEAP_MAX_BREAKPOINTS + 1]; /* currently active breakpoints: NULL term, borrowed pointers */
 	/* XXX: make active breakpoints actual copies instead of pointers? */
 
 	/* These are for rate limiting Status notifications and transport peeking. */
-	duk_uint_t dbg_exec_counter;            /* cumulative opcode execution count (overflows are OK) */
-	duk_uint_t dbg_last_counter;            /* value of dbg_exec_counter when we last did a Date-based check */
-	duk_double_t dbg_last_time;             /* time when status/peek was last done (Date-based rate limit) */
+	duk_uint_t dbg_exec_counter; /* cumulative opcode execution count (overflows are OK) */
+	duk_uint_t dbg_last_counter; /* value of dbg_exec_counter when we last did a Date-based check */
+	duk_double_t dbg_last_time; /* time when status/peek was last done (Date-based rate limit) */
 
 	/* Used to support single-byte stream lookahead. */
 	duk_bool_t dbg_have_next_byte;
 	duk_uint8_t dbg_next_byte;
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 #if defined(DUK_USE_ASSERTIONS)
-	duk_bool_t dbg_calling_transport;       /* transport call in progress, calling into Duktape forbidden */
+	duk_bool_t dbg_calling_transport; /* transport call in progress, calling into Duktape forbidden */
 #endif
 
 	/* String intern table (weak refs). */
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	duk_uint16_t *strtable16;
 #else
 	duk_hstring **strtable;
 #endif
-	duk_uint32_t st_mask;    /* mask for lookup, st_size - 1 */
-	duk_uint32_t st_size;    /* stringtable size */
+	duk_uint32_t st_mask; /* mask for lookup, st_size - 1 */
+	duk_uint32_t st_size; /* stringtable size */
 #if (DUK_USE_STRTAB_MINSIZE != DUK_USE_STRTAB_MAXSIZE)
-	duk_uint32_t st_count;   /* string count for resize load factor checks */
+	duk_uint32_t st_count; /* string count for resize load factor checks */
 #endif
-	duk_bool_t st_resizing;  /* string table is being resized; avoid recursive resize */
+	duk_bool_t st_resizing; /* string table is being resized; avoid recursive resize */
 
 	/* String access cache (codepoint offset -> byte offset) for fast string
 	 * character looping; 'weak' reference which needs special handling in GC.
 	 */
 	duk_strcache_entry strcache[DUK_HEAP_STRCACHE_SIZE];
 
 #if defined(DUK_USE_LITCACHE_SIZE)
@@ -9157,30 +9666,34 @@
 #if defined(DUK_USE_INTERRUPT_COUNTER)
 DUK_INTERNAL_DECL void duk_heap_switch_thread(duk_heap *heap, duk_hthread *new_thr);
 #endif
 
 DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen);
 DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t len);
 #if defined(DUK_USE_LITCACHE_SIZE)
-DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen);
+DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr,
+                                                                        const duk_uint8_t *str,
+                                                                        duk_uint32_t blen);
 #endif
 DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern_u32(duk_heap *heap, duk_uint32_t val);
 DUK_INTERNAL_DECL duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val);
 #if defined(DUK_USE_REFERENCE_COUNTING)
 DUK_INTERNAL_DECL void duk_heap_strtable_unlink(duk_heap *heap, duk_hstring *h);
 #endif
 DUK_INTERNAL_DECL void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev);
 DUK_INTERNAL_DECL void duk_heap_strtable_force_resize(duk_heap *heap);
 DUK_INTERNAL void duk_heap_strtable_free(duk_heap *heap);
 #if defined(DUK_USE_DEBUG)
 DUK_INTERNAL void duk_heap_strtable_dump(duk_heap *heap);
 #endif
 
 DUK_INTERNAL_DECL void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h);
-DUK_INTERNAL_DECL duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr, duk_hstring *h, duk_uint_fast32_t char_offset);
+DUK_INTERNAL_DECL duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr,
+                                                                       duk_hstring *h,
+                                                                       duk_uint_fast32_t char_offset);
 
 #if defined(DUK_USE_PROVIDE_DEFAULT_ALLOC_FUNCTIONS)
 DUK_INTERNAL_DECL void *duk_default_alloc_function(void *udata, duk_size_t size);
 DUK_INTERNAL_DECL void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize);
 DUK_INTERNAL_DECL void duk_default_free_function(void *udata, void *ptr);
 #endif
 
@@ -9193,100 +9706,100 @@
 DUK_INTERNAL_DECL void duk_heap_mem_free(duk_heap *heap, void *ptr);
 
 DUK_INTERNAL_DECL void duk_heap_free_freelists(duk_heap *heap);
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_INTERNAL_DECL void duk_heap_run_finalizer(duk_heap *heap, duk_hobject *obj);
 DUK_INTERNAL_DECL void duk_heap_process_finalize_list(duk_heap *heap);
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 DUK_INTERNAL_DECL void duk_heap_mark_and_sweep(duk_heap *heap, duk_small_uint_t flags);
 
 DUK_INTERNAL_DECL duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len);
 
-#endif  /* DUK_HEAP_H_INCLUDED */
+#endif /* DUK_HEAP_H_INCLUDED */
 /* #include duk_debugger.h */
 #line 1 "duk_debugger.h"
 #if !defined(DUK_DEBUGGER_H_INCLUDED)
 #define DUK_DEBUGGER_H_INCLUDED
 
 /* Debugger protocol version is defined in the public API header. */
 
 /* Initial bytes for markers. */
-#define DUK_DBG_IB_EOM                   0x00
-#define DUK_DBG_IB_REQUEST               0x01
-#define DUK_DBG_IB_REPLY                 0x02
-#define DUK_DBG_IB_ERROR                 0x03
-#define DUK_DBG_IB_NOTIFY                0x04
+#define DUK_DBG_IB_EOM     0x00
+#define DUK_DBG_IB_REQUEST 0x01
+#define DUK_DBG_IB_REPLY   0x02
+#define DUK_DBG_IB_ERROR   0x03
+#define DUK_DBG_IB_NOTIFY  0x04
 
 /* Other initial bytes. */
-#define DUK_DBG_IB_INT4                  0x10
-#define DUK_DBG_IB_STR4                  0x11
-#define DUK_DBG_IB_STR2                  0x12
-#define DUK_DBG_IB_BUF4                  0x13
-#define DUK_DBG_IB_BUF2                  0x14
-#define DUK_DBG_IB_UNUSED                0x15
-#define DUK_DBG_IB_UNDEFINED             0x16
-#define DUK_DBG_IB_NULL                  0x17
-#define DUK_DBG_IB_TRUE                  0x18
-#define DUK_DBG_IB_FALSE                 0x19
-#define DUK_DBG_IB_NUMBER                0x1a
-#define DUK_DBG_IB_OBJECT                0x1b
-#define DUK_DBG_IB_POINTER               0x1c
-#define DUK_DBG_IB_LIGHTFUNC             0x1d
-#define DUK_DBG_IB_HEAPPTR               0x1e
+#define DUK_DBG_IB_INT4      0x10
+#define DUK_DBG_IB_STR4      0x11
+#define DUK_DBG_IB_STR2      0x12
+#define DUK_DBG_IB_BUF4      0x13
+#define DUK_DBG_IB_BUF2      0x14
+#define DUK_DBG_IB_UNUSED    0x15
+#define DUK_DBG_IB_UNDEFINED 0x16
+#define DUK_DBG_IB_NULL      0x17
+#define DUK_DBG_IB_TRUE      0x18
+#define DUK_DBG_IB_FALSE     0x19
+#define DUK_DBG_IB_NUMBER    0x1a
+#define DUK_DBG_IB_OBJECT    0x1b
+#define DUK_DBG_IB_POINTER   0x1c
+#define DUK_DBG_IB_LIGHTFUNC 0x1d
+#define DUK_DBG_IB_HEAPPTR   0x1e
 /* The short string/integer initial bytes starting from 0x60 don't have
  * defines now.
  */
 
 /* Error codes. */
-#define DUK_DBG_ERR_UNKNOWN              0x00
-#define DUK_DBG_ERR_UNSUPPORTED          0x01
-#define DUK_DBG_ERR_TOOMANY              0x02
-#define DUK_DBG_ERR_NOTFOUND             0x03
-#define DUK_DBG_ERR_APPLICATION          0x04
+#define DUK_DBG_ERR_UNKNOWN     0x00
+#define DUK_DBG_ERR_UNSUPPORTED 0x01
+#define DUK_DBG_ERR_TOOMANY     0x02
+#define DUK_DBG_ERR_NOTFOUND    0x03
+#define DUK_DBG_ERR_APPLICATION 0x04
 
 /* Commands and notifys initiated by Duktape. */
-#define DUK_DBG_CMD_STATUS               0x01
-#define DUK_DBG_CMD_UNUSED_2             0x02  /* Duktape 1.x: print notify */
-#define DUK_DBG_CMD_UNUSED_3             0x03  /* Duktape 1.x: alert notify */
-#define DUK_DBG_CMD_UNUSED_4             0x04  /* Duktape 1.x: log notify */
-#define DUK_DBG_CMD_THROW                0x05
-#define DUK_DBG_CMD_DETACHING            0x06
-#define DUK_DBG_CMD_APPNOTIFY            0x07
+#define DUK_DBG_CMD_STATUS    0x01
+#define DUK_DBG_CMD_UNUSED_2  0x02 /* Duktape 1.x: print notify */
+#define DUK_DBG_CMD_UNUSED_3  0x03 /* Duktape 1.x: alert notify */
+#define DUK_DBG_CMD_UNUSED_4  0x04 /* Duktape 1.x: log notify */
+#define DUK_DBG_CMD_THROW     0x05
+#define DUK_DBG_CMD_DETACHING 0x06
+#define DUK_DBG_CMD_APPNOTIFY 0x07
 
 /* Commands initiated by debug client. */
-#define DUK_DBG_CMD_BASICINFO            0x10
-#define DUK_DBG_CMD_TRIGGERSTATUS        0x11
-#define DUK_DBG_CMD_PAUSE                0x12
-#define DUK_DBG_CMD_RESUME               0x13
-#define DUK_DBG_CMD_STEPINTO             0x14
-#define DUK_DBG_CMD_STEPOVER             0x15
-#define DUK_DBG_CMD_STEPOUT              0x16
-#define DUK_DBG_CMD_LISTBREAK            0x17
-#define DUK_DBG_CMD_ADDBREAK             0x18
-#define DUK_DBG_CMD_DELBREAK             0x19
-#define DUK_DBG_CMD_GETVAR               0x1a
-#define DUK_DBG_CMD_PUTVAR               0x1b
-#define DUK_DBG_CMD_GETCALLSTACK         0x1c
-#define DUK_DBG_CMD_GETLOCALS            0x1d
-#define DUK_DBG_CMD_EVAL                 0x1e
-#define DUK_DBG_CMD_DETACH               0x1f
-#define DUK_DBG_CMD_DUMPHEAP             0x20
-#define DUK_DBG_CMD_GETBYTECODE          0x21
-#define DUK_DBG_CMD_APPREQUEST           0x22
-#define DUK_DBG_CMD_GETHEAPOBJINFO       0x23
-#define DUK_DBG_CMD_GETOBJPROPDESC       0x24
-#define DUK_DBG_CMD_GETOBJPROPDESCRANGE  0x25
+#define DUK_DBG_CMD_BASICINFO           0x10
+#define DUK_DBG_CMD_TRIGGERSTATUS       0x11
+#define DUK_DBG_CMD_PAUSE               0x12
+#define DUK_DBG_CMD_RESUME              0x13
+#define DUK_DBG_CMD_STEPINTO            0x14
+#define DUK_DBG_CMD_STEPOVER            0x15
+#define DUK_DBG_CMD_STEPOUT             0x16
+#define DUK_DBG_CMD_LISTBREAK           0x17
+#define DUK_DBG_CMD_ADDBREAK            0x18
+#define DUK_DBG_CMD_DELBREAK            0x19
+#define DUK_DBG_CMD_GETVAR              0x1a
+#define DUK_DBG_CMD_PUTVAR              0x1b
+#define DUK_DBG_CMD_GETCALLSTACK        0x1c
+#define DUK_DBG_CMD_GETLOCALS           0x1d
+#define DUK_DBG_CMD_EVAL                0x1e
+#define DUK_DBG_CMD_DETACH              0x1f
+#define DUK_DBG_CMD_DUMPHEAP            0x20
+#define DUK_DBG_CMD_GETBYTECODE         0x21
+#define DUK_DBG_CMD_APPREQUEST          0x22
+#define DUK_DBG_CMD_GETHEAPOBJINFO      0x23
+#define DUK_DBG_CMD_GETOBJPROPDESC      0x24
+#define DUK_DBG_CMD_GETOBJPROPDESCRANGE 0x25
 
 /* The low 8 bits map directly to duk_hobject.h DUK_PROPDESC_FLAG_xxx.
  * The remaining flags are specific to the debugger.
  */
-#define DUK_DBG_PROPFLAG_SYMBOL          (1U << 8)
-#define DUK_DBG_PROPFLAG_HIDDEN          (1U << 9)
+#define DUK_DBG_PROPFLAG_SYMBOL (1U << 8)
+#define DUK_DBG_PROPFLAG_HIDDEN (1U << 9)
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 DUK_INTERNAL_DECL void duk_debug_do_detach(duk_heap *heap);
 
 DUK_INTERNAL_DECL duk_bool_t duk_debug_read_peek(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_debug_write_flush(duk_hthread *thr);
 
@@ -9325,15 +9838,15 @@
 DUK_INTERNAL_DECL void duk_debug_write_hbuffer(duk_hthread *thr, duk_hbuffer *h);
 DUK_INTERNAL_DECL void duk_debug_write_pointer(duk_hthread *thr, void *ptr);
 #if defined(DUK_USE_DEBUGGER_DUMPHEAP) || defined(DUK_USE_DEBUGGER_INSPECT)
 DUK_INTERNAL_DECL void duk_debug_write_heapptr(duk_hthread *thr, duk_heaphdr *h);
 #endif
 DUK_INTERNAL_DECL void duk_debug_write_hobject(duk_hthread *thr, duk_hobject *obj);
 DUK_INTERNAL_DECL void duk_debug_write_tval(duk_hthread *thr, duk_tval *tv);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_INTERNAL_DECL void duk_debug_write_request(duk_hthread *thr, duk_small_uint_t command);
 #endif
 DUK_INTERNAL_DECL void duk_debug_write_reply(duk_hthread *thr);
 DUK_INTERNAL_DECL void duk_debug_write_error_eom(duk_hthread *thr, duk_small_uint_t err_code, const char *msg);
 DUK_INTERNAL_DECL void duk_debug_write_notify(duk_hthread *thr, duk_small_uint_t command);
 DUK_INTERNAL_DECL void duk_debug_write_eom(duk_hthread *thr);
 
@@ -9350,17 +9863,17 @@
 DUK_INTERNAL_DECL duk_bool_t duk_debug_remove_breakpoint(duk_hthread *thr, duk_small_uint_t breakpoint_index);
 
 DUK_INTERNAL_DECL duk_bool_t duk_debug_is_attached(duk_heap *heap);
 DUK_INTERNAL_DECL duk_bool_t duk_debug_is_paused(duk_heap *heap);
 DUK_INTERNAL_DECL void duk_debug_set_paused(duk_heap *heap);
 DUK_INTERNAL_DECL void duk_debug_clear_paused(duk_heap *heap);
 DUK_INTERNAL_DECL void duk_debug_clear_pause_state(duk_heap *heap);
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
-#endif  /* DUK_DEBUGGER_H_INCLUDED */
+#endif /* DUK_DEBUGGER_H_INCLUDED */
 /* #include duk_debug.h */
 #line 1 "duk_debug.h"
 /*
  *  Debugging macros, DUK_DPRINT() and its variants in particular.
  *
  *  DUK_DPRINT() allows formatted debug prints, and supports standard
  *  and Duktape specific formatters.  See duk_debug_vsnprintf.c for details.
@@ -9385,119 +9898,131 @@
 #define DUK_DEBUG_H_INCLUDED
 
 #if defined(DUK_USE_DEBUG)
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 0)
 #define DUK_D(x) x
 #else
-#define DUK_D(x) do { } while (0) /* omit */
+#define DUK_D(x) \
+	do { \
+	} while (0) /* omit */
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 1)
 #define DUK_DD(x) x
 #else
-#define DUK_DD(x) do { } while (0) /* omit */
+#define DUK_DD(x) \
+	do { \
+	} while (0) /* omit */
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
 #define DUK_DDD(x) x
 #else
-#define DUK_DDD(x) do { } while (0) /* omit */
+#define DUK_DDD(x) \
+	do { \
+	} while (0) /* omit */
 #endif
 
 /*
  *  Exposed debug macros: debugging enabled
  */
 
 #if defined(DUK_USE_VARIADIC_MACROS)
 
 /* Note: combining __FILE__, __LINE__, and __func__ into fmt would be
  * possible compile time, but waste some space with shared function names.
  */
-#define DUK__DEBUG_LOG(lev,...)  duk_debug_log((duk_int_t) (lev), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, DUK_FUNC_MACRO, __VA_ARGS__);
+#define DUK__DEBUG_LOG(lev, ...) \
+	duk_debug_log((duk_int_t) (lev), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, DUK_FUNC_MACRO, __VA_ARGS__);
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 0)
-#define DUK_DPRINT(...)          DUK__DEBUG_LOG(DUK_LEVEL_DEBUG, __VA_ARGS__)
+#define DUK_DPRINT(...) DUK__DEBUG_LOG(DUK_LEVEL_DEBUG, __VA_ARGS__)
 #else
 #define DUK_DPRINT(...)
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 1)
-#define DUK_DDPRINT(...)         DUK__DEBUG_LOG(DUK_LEVEL_DDEBUG, __VA_ARGS__)
+#define DUK_DDPRINT(...) DUK__DEBUG_LOG(DUK_LEVEL_DDEBUG, __VA_ARGS__)
 #else
 #define DUK_DDPRINT(...)
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
-#define DUK_DDDPRINT(...)        DUK__DEBUG_LOG(DUK_LEVEL_DDDEBUG, __VA_ARGS__)
+#define DUK_DDDPRINT(...) DUK__DEBUG_LOG(DUK_LEVEL_DDDEBUG, __VA_ARGS__)
 #else
 #define DUK_DDDPRINT(...)
 #endif
 
-#else  /* DUK_USE_VARIADIC_MACROS */
+#else /* DUK_USE_VARIADIC_MACROS */
 
-#define DUK__DEBUG_STASH(lev)    \
+#define DUK__DEBUG_STASH(lev) \
 	(void) DUK_SNPRINTF(duk_debug_file_stash, DUK_DEBUG_STASH_SIZE, "%s", (const char *) DUK_FILE_MACRO), \
-	(void) (duk_debug_file_stash[DUK_DEBUG_STASH_SIZE - 1] = (char) 0), \
-	(void) (duk_debug_line_stash = (duk_int_t) DUK_LINE_MACRO), \
-	(void) DUK_SNPRINTF(duk_debug_func_stash, DUK_DEBUG_STASH_SIZE, "%s", (const char *) DUK_FUNC_MACRO), \
-	(void) (duk_debug_func_stash[DUK_DEBUG_STASH_SIZE - 1] = (char) 0), \
-	(void) (duk_debug_level_stash = (lev))
+	    (void) (duk_debug_file_stash[DUK_DEBUG_STASH_SIZE - 1] = (char) 0), \
+	    (void) (duk_debug_line_stash = (duk_int_t) DUK_LINE_MACRO), \
+	    (void) DUK_SNPRINTF(duk_debug_func_stash, DUK_DEBUG_STASH_SIZE, "%s", (const char *) DUK_FUNC_MACRO), \
+	    (void) (duk_debug_func_stash[DUK_DEBUG_STASH_SIZE - 1] = (char) 0), (void) (duk_debug_level_stash = (lev))
 
 /* Without variadic macros resort to comma expression trickery to handle debug
  * prints.  This generates a lot of harmless warnings.  These hacks are not
  * needed normally because DUK_D() and friends will hide the entire debug log
  * statement from the compiler.
  */
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 0)
-#define DUK_DPRINT  DUK__DEBUG_STASH(DUK_LEVEL_DEBUG), (void) duk_debug_log  /* args go here in parens */
+#define DUK_DPRINT DUK__DEBUG_STASH(DUK_LEVEL_DEBUG), (void) duk_debug_log /* args go here in parens */
 #else
-#define DUK_DPRINT  0 && /* args go here as a comma expression in parens */
+#define DUK_DPRINT 0 && /* args go here as a comma expression in parens */
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 1)
-#define DUK_DDPRINT  DUK__DEBUG_STASH(DUK_LEVEL_DDEBUG), (void) duk_debug_log  /* args go here in parens */
+#define DUK_DDPRINT DUK__DEBUG_STASH(DUK_LEVEL_DDEBUG), (void) duk_debug_log /* args go here in parens */
 #else
-#define DUK_DDPRINT  0 && /* args */
+#define DUK_DDPRINT 0 && /* args */
 #endif
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
-#define DUK_DDDPRINT  DUK__DEBUG_STASH(DUK_LEVEL_DDDEBUG), (void) duk_debug_log  /* args go here in parens */
+#define DUK_DDDPRINT DUK__DEBUG_STASH(DUK_LEVEL_DDDEBUG), (void) duk_debug_log /* args go here in parens */
 #else
-#define DUK_DDDPRINT  0 && /* args */
+#define DUK_DDDPRINT 0 && /* args */
 #endif
 
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
-#else  /* DUK_USE_DEBUG */
+#else /* DUK_USE_DEBUG */
 
 /*
  *  Exposed debug macros: debugging disabled
  */
 
-#define DUK_D(x) do { } while (0) /* omit */
-#define DUK_DD(x) do { } while (0) /* omit */
-#define DUK_DDD(x) do { } while (0) /* omit */
+#define DUK_D(x) \
+	do { \
+	} while (0) /* omit */
+#define DUK_DD(x) \
+	do { \
+	} while (0) /* omit */
+#define DUK_DDD(x) \
+	do { \
+	} while (0) /* omit */
 
 #if defined(DUK_USE_VARIADIC_MACROS)
 
 #define DUK_DPRINT(...)
 #define DUK_DDPRINT(...)
 #define DUK_DDDPRINT(...)
 
-#else  /* DUK_USE_VARIADIC_MACROS */
+#else /* DUK_USE_VARIADIC_MACROS */
 
-#define DUK_DPRINT    0 && /* args go here as a comma expression in parens */
-#define DUK_DDPRINT   0 && /* args */
-#define DUK_DDDPRINT  0 && /* args */
+#define DUK_DPRINT   0 && /* args go here as a comma expression in parens */
+#define DUK_DDPRINT  0 && /* args */
+#define DUK_DDDPRINT 0 && /* args */
 
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 /*
  *  Structs
  */
 
 #if defined(DUK_USE_DEBUG)
 struct duk_fixedbuffer {
@@ -9510,43 +10035,43 @@
 
 /*
  *  Prototypes
  */
 
 #if defined(DUK_USE_DEBUG)
 DUK_INTERNAL_DECL duk_int_t duk_debug_vsnprintf(char *str, duk_size_t size, const char *format, va_list ap);
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL_DECL duk_int_t duk_debug_snprintf(char *str, duk_size_t size, const char *format, ...);
 #endif
 DUK_INTERNAL_DECL void duk_debug_format_funcptr(char *buf, duk_size_t buf_size, duk_uint8_t *fptr, duk_size_t fptr_size);
 
 #if defined(DUK_USE_VARIADIC_MACROS)
 DUK_INTERNAL_DECL void duk_debug_log(duk_int_t level, const char *file, duk_int_t line, const char *func, const char *fmt, ...);
-#else  /* DUK_USE_VARIADIC_MACROS */
+#else /* DUK_USE_VARIADIC_MACROS */
 /* parameter passing, not thread safe */
-#define DUK_DEBUG_STASH_SIZE  128
+#define DUK_DEBUG_STASH_SIZE 128
 #if !defined(DUK_SINGLE_FILE)
 DUK_INTERNAL_DECL char duk_debug_file_stash[DUK_DEBUG_STASH_SIZE];
 DUK_INTERNAL_DECL duk_int_t duk_debug_line_stash;
 DUK_INTERNAL_DECL char duk_debug_func_stash[DUK_DEBUG_STASH_SIZE];
 DUK_INTERNAL_DECL duk_int_t duk_debug_level_stash;
 #endif
 DUK_INTERNAL_DECL void duk_debug_log(const char *fmt, ...);
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
 DUK_INTERNAL_DECL void duk_fb_put_bytes(duk_fixedbuffer *fb, const duk_uint8_t *buffer, duk_size_t length);
 DUK_INTERNAL_DECL void duk_fb_put_byte(duk_fixedbuffer *fb, duk_uint8_t x);
 DUK_INTERNAL_DECL void duk_fb_put_cstring(duk_fixedbuffer *fb, const char *x);
 DUK_INTERNAL_DECL void duk_fb_sprintf(duk_fixedbuffer *fb, const char *fmt, ...);
 DUK_INTERNAL_DECL void duk_fb_put_funcptr(duk_fixedbuffer *fb, duk_uint8_t *fptr, duk_size_t fptr_size);
 DUK_INTERNAL_DECL duk_bool_t duk_fb_is_full(duk_fixedbuffer *fb);
 
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
-#endif  /* DUK_DEBUG_H_INCLUDED */
+#endif /* DUK_DEBUG_H_INCLUDED */
 /* #include duk_error.h */
 #line 1 "duk_error.h"
 /*
  *  Error handling macros, assertion macro, error codes.
  *
  *  There are three types of 'errors':
  *
@@ -9596,96 +10121,169 @@
  */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 
 /* Because there are quite many call sites, pack error code (require at most
  * 8-bit) into a single argument.
  */
-#define DUK_ERROR(thr,err,msg) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+#define DUK_ERROR(thr, err, msg) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
 		duk_err_handle_error((thr), DUK_FILE_MACRO, (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (msg)); \
 	} while (0)
-#define DUK_ERROR_RAW(thr,file,line,err,msg) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) (line); \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+#define DUK_ERROR_RAW(thr, file, line, err, msg) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) (line); \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
 		duk_err_handle_error((thr), (file), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (msg)); \
 	} while (0)
 
-#define DUK_ERROR_FMT1(thr,err,fmt,arg1) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), DUK_FILE_MACRO, (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1)); \
-	} while (0)
-#define DUK_ERROR_RAW_FMT1(thr,file,line,err,fmt,arg1) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) (line); \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), (file), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1)); \
-	} while (0)
-
-#define DUK_ERROR_FMT2(thr,err,fmt,arg1,arg2) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), DUK_FILE_MACRO, (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2)); \
-	} while (0)
-#define DUK_ERROR_RAW_FMT2(thr,file,line,err,fmt,arg1,arg2) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) (line); \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), (file), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2)); \
-	} while (0)
-
-#define DUK_ERROR_FMT3(thr,err,fmt,arg1,arg2,arg3) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), DUK_FILE_MACRO, (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2), (arg3)); \
-	} while (0)
-#define DUK_ERROR_RAW_FMT3(thr,file,line,err,fmt,arg1,arg2,arg3) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) (line); \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), (file), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2), (arg3)); \
-	} while (0)
-
-#define DUK_ERROR_FMT4(thr,err,fmt,arg1,arg2,arg3,arg4) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), DUK_FILE_MACRO, (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2), (arg3), (arg4)); \
-	} while (0)
-#define DUK_ERROR_RAW_FMT4(thr,file,line,err,fmt,arg1,arg2,arg3,arg4) do { \
-		duk_errcode_t duk__err = (err); duk_int_t duk__line = (duk_int_t) (line); \
-		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
-		duk_err_handle_error_fmt((thr), (file), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (fmt), (arg1), (arg2), (arg3), (arg4)); \
-	} while (0)
-
-#else  /* DUK_USE_VERBOSE_ERRORS */
-
-#define DUK_ERROR(thr,err,msg)                    duk_err_handle_error((thr), (err))
-#define DUK_ERROR_RAW(thr,file,line,err,msg)      duk_err_handle_error((thr), (err))
+#define DUK_ERROR_FMT1(thr, err, fmt, arg1) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         DUK_FILE_MACRO, \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1)); \
+	} while (0)
+#define DUK_ERROR_RAW_FMT1(thr, file, line, err, fmt, arg1) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) (line); \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         (file), \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1)); \
+	} while (0)
+
+#define DUK_ERROR_FMT2(thr, err, fmt, arg1, arg2) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         DUK_FILE_MACRO, \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2)); \
+	} while (0)
+#define DUK_ERROR_RAW_FMT2(thr, file, line, err, fmt, arg1, arg2) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) (line); \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         (file), \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2)); \
+	} while (0)
+
+#define DUK_ERROR_FMT3(thr, err, fmt, arg1, arg2, arg3) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         DUK_FILE_MACRO, \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2), \
+		                         (arg3)); \
+	} while (0)
+#define DUK_ERROR_RAW_FMT3(thr, file, line, err, fmt, arg1, arg2, arg3) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) (line); \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         (file), \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2), \
+		                         (arg3)); \
+	} while (0)
+
+#define DUK_ERROR_FMT4(thr, err, fmt, arg1, arg2, arg3, arg4) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) DUK_LINE_MACRO; \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         DUK_FILE_MACRO, \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2), \
+		                         (arg3), \
+		                         (arg4)); \
+	} while (0)
+#define DUK_ERROR_RAW_FMT4(thr, file, line, err, fmt, arg1, arg2, arg3, arg4) \
+	do { \
+		duk_errcode_t duk__err = (err); \
+		duk_int_t duk__line = (duk_int_t) (line); \
+		DUK_ASSERT(duk__err >= 0 && duk__err <= 0xff); \
+		DUK_ASSERT(duk__line >= 0 && duk__line <= 0x00ffffffL); \
+		duk_err_handle_error_fmt((thr), \
+		                         (file), \
+		                         (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), \
+		                         (fmt), \
+		                         (arg1), \
+		                         (arg2), \
+		                         (arg3), \
+		                         (arg4)); \
+	} while (0)
+
+#else /* DUK_USE_VERBOSE_ERRORS */
+
+#define DUK_ERROR(thr, err, msg)                 duk_err_handle_error((thr), (err))
+#define DUK_ERROR_RAW(thr, file, line, err, msg) duk_err_handle_error((thr), (err))
+
+#define DUK_ERROR_FMT1(thr, err, fmt, arg1)                 DUK_ERROR((thr), (err), (fmt))
+#define DUK_ERROR_RAW_FMT1(thr, file, line, err, fmt, arg1) DUK_ERROR_RAW((thr), (file), (line), (err), (fmt))
+
+#define DUK_ERROR_FMT2(thr, err, fmt, arg1, arg2)                 DUK_ERROR((thr), (err), (fmt))
+#define DUK_ERROR_RAW_FMT2(thr, file, line, err, fmt, arg1, arg2) DUK_ERROR_RAW((thr), (file), (line), (err), (fmt))
 
-#define DUK_ERROR_FMT1(thr,err,fmt,arg1) DUK_ERROR((thr),(err),(fmt))
-#define DUK_ERROR_RAW_FMT1(thr,file,line,err,fmt,arg1) DUK_ERROR_RAW((thr),(file),(line),(err),(fmt))
+#define DUK_ERROR_FMT3(thr, err, fmt, arg1, arg2, arg3)                 DUK_ERROR((thr), (err), (fmt))
+#define DUK_ERROR_RAW_FMT3(thr, file, line, err, fmt, arg1, arg2, arg3) DUK_ERROR_RAW((thr), (file), (line), (err), (fmt))
 
-#define DUK_ERROR_FMT2(thr,err,fmt,arg1,arg2) DUK_ERROR((thr),(err),(fmt))
-#define DUK_ERROR_RAW_FMT2(thr,file,line,err,fmt,arg1,arg2) DUK_ERROR_RAW((thr),(file),(line),(err),(fmt))
+#define DUK_ERROR_FMT4(thr, err, fmt, arg1, arg2, arg3, arg4)                 DUK_ERROR((thr), (err), (fmt))
+#define DUK_ERROR_RAW_FMT4(thr, file, line, err, fmt, arg1, arg2, arg3, arg4) DUK_ERROR_RAW((thr), (file), (line), (err), (fmt))
 
-#define DUK_ERROR_FMT3(thr,err,fmt,arg1,arg2,arg3) DUK_ERROR((thr),(err),(fmt))
-#define DUK_ERROR_RAW_FMT3(thr,file,line,err,fmt,arg1,arg2,arg3) DUK_ERROR_RAW((thr),(file),(line),(err),(fmt))
-
-#define DUK_ERROR_FMT4(thr,err,fmt,arg1,arg2,arg3,arg4) DUK_ERROR((thr),(err),(fmt))
-#define DUK_ERROR_RAW_FMT4(thr,file,line,err,fmt,arg1,arg2,arg3,arg4) DUK_ERROR_RAW((thr),(file),(line),(err),(fmt))
-
-#endif  /* DUK_USE_VERBOSE_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS */
 
 /*
  *  Fatal error without context
  *
  *  The macro is an expression to make it compatible with DUK_ASSERT_EXPR().
  */
 
-#define DUK_FATAL_WITHOUT_CONTEXT(msg) \
-	duk_default_fatal_handler(NULL, (msg))
+#define DUK_FATAL_WITHOUT_CONTEXT(msg) duk_default_fatal_handler(NULL, (msg))
 
 /*
  *  Error throwing helpers
  *
  *  The goal is to provide verbose and configurable error messages.  Call
  *  sites should be clean in source code and compile to a small footprint.
  *  Small footprint is also useful for performance because small cold paths
@@ -9702,204 +10300,260 @@
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 /* Verbose errors with key/value summaries (non-paranoid) or without key/value
  * summaries (paranoid, for some security sensitive environments), the paranoid
  * vs. non-paranoid distinction affects only a few specific errors.
  */
 #if defined(DUK_USE_PARANOID_ERRORS)
-#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr,idx,expectname,lowmemstr) do { \
+#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, expectname, lowmemstr) \
+	do { \
 		duk_err_require_type_index((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, (idx), (expectname)); \
 	} while (0)
-#else  /* DUK_USE_PARANOID_ERRORS */
-#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr,idx,expectname,lowmemstr) do { \
+#else /* DUK_USE_PARANOID_ERRORS */
+#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, expectname, lowmemstr) \
+	do { \
 		duk_err_require_type_index((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, (idx), (expectname)); \
 	} while (0)
-#endif  /* DUK_USE_PARANOID_ERRORS */
+#endif /* DUK_USE_PARANOID_ERRORS */
 
-#define DUK_ERROR_INTERNAL(thr) do { \
+#define DUK_ERROR_INTERNAL(thr) \
+	do { \
 		duk_err_error_internal((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_DCERROR_INTERNAL(thr) do { \
+#define DUK_DCERROR_INTERNAL(thr) \
+	do { \
 		DUK_ERROR_INTERNAL((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_ALLOC_FAILED(thr) do { \
+#define DUK_ERROR_ALLOC_FAILED(thr) \
+	do { \
 		duk_err_error_alloc_failed((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_ERROR_UNSUPPORTED(thr) do { \
+#define DUK_ERROR_UNSUPPORTED(thr) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_ERROR, DUK_STR_UNSUPPORTED); \
 	} while (0)
-#define DUK_DCERROR_UNSUPPORTED(thr) do { \
+#define DUK_DCERROR_UNSUPPORTED(thr) \
+	do { \
 		DUK_ERROR_UNSUPPORTED((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_ERROR(thr,msg) do { \
+#define DUK_ERROR_ERROR(thr, msg) \
+	do { \
 		duk_err_error((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, (msg)); \
 	} while (0)
-#define DUK_ERROR_RANGE_INDEX(thr,idx) do { \
+#define DUK_ERROR_RANGE_INDEX(thr, idx) \
+	do { \
 		duk_err_range_index((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, (idx)); \
 	} while (0)
-#define DUK_ERROR_RANGE_PUSH_BEYOND(thr) do { \
+#define DUK_ERROR_RANGE_PUSH_BEYOND(thr) \
+	do { \
 		duk_err_range_push_beyond((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_ARGS(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_ARGS(thr) \
+	do { \
 		DUK_ERROR_RANGE((thr), DUK_STR_INVALID_ARGS); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_ARGS(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_ARGS(thr) \
+	do { \
 		DUK_ERROR_RANGE_INVALID_ARGS((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_COUNT(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_COUNT(thr) \
+	do { \
 		DUK_ERROR_RANGE((thr), DUK_STR_INVALID_COUNT); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_COUNT(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_COUNT(thr) \
+	do { \
 		DUK_ERROR_RANGE_INVALID_COUNT((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_LENGTH(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_LENGTH(thr) \
+	do { \
 		DUK_ERROR_RANGE((thr), DUK_STR_INVALID_LENGTH); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_LENGTH(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_LENGTH(thr) \
+	do { \
 		DUK_ERROR_RANGE_INVALID_LENGTH((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_RANGE(thr,msg) do { \
+#define DUK_ERROR_RANGE(thr, msg) \
+	do { \
 		duk_err_range((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO, (msg)); \
 	} while (0)
-#define DUK_ERROR_EVAL(thr,msg) do { \
+#define DUK_ERROR_EVAL(thr, msg) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_EVAL_ERROR, (msg)); \
 	} while (0)
-#define DUK_ERROR_REFERENCE(thr,msg) do { \
+#define DUK_ERROR_REFERENCE(thr, msg) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_REFERENCE_ERROR, (msg)); \
 	} while (0)
-#define DUK_ERROR_SYNTAX(thr,msg) do { \
+#define DUK_ERROR_SYNTAX(thr, msg) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_SYNTAX_ERROR, (msg)); \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_ARGS(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_ARGS(thr) \
+	do { \
 		duk_err_type_invalid_args((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_ARGS(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_ARGS(thr) \
+	do { \
 		DUK_ERROR_TYPE_INVALID_ARGS((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_STATE(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_STATE(thr) \
+	do { \
 		duk_err_type_invalid_state((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_STATE(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_STATE(thr) \
+	do { \
 		DUK_ERROR_TYPE_INVALID_STATE((thr)); \
 		return 0; \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) \
+	do { \
 		duk_err_type_invalid_trap_result((thr), DUK_FILE_MACRO, (duk_int_t) DUK_LINE_MACRO); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_TRAP_RESULT(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_TRAP_RESULT(thr) \
+	do { \
 		DUK_ERROR_TYPE((thr), DUK_STR_INVALID_TRAP_RESULT); \
 	} while (0)
-#define DUK_ERROR_TYPE(thr,msg) do { \
+#define DUK_ERROR_TYPE(thr, msg) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_TYPE_ERROR, (msg)); \
 	} while (0)
-#define DUK_ERROR_URI(thr,msg) do { \
+#define DUK_ERROR_URI(thr, msg) \
+	do { \
 		DUK_ERROR((thr), DUK_ERR_URI_ERROR, (msg)); \
 	} while (0)
-#else  /* DUK_USE_VERBOSE_ERRORS */
+#else /* DUK_USE_VERBOSE_ERRORS */
 /* Non-verbose errors for low memory targets: no file, line, or message. */
 
-#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr,idx,expectname,lowmemstr) do { \
+#define DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, expectname, lowmemstr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
 
-#define DUK_ERROR_INTERNAL(thr) do { \
+#define DUK_ERROR_INTERNAL(thr) \
+	do { \
 		duk_err_error((thr)); \
 	} while (0)
-#define DUK_DCERROR_INTERNAL(thr) do { \
+#define DUK_DCERROR_INTERNAL(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_ERROR; \
 	} while (0)
-#define DUK_ERROR_ALLOC_FAILED(thr) do { \
+#define DUK_ERROR_ALLOC_FAILED(thr) \
+	do { \
 		duk_err_error((thr)); \
 	} while (0)
-#define DUK_ERROR_UNSUPPORTED(thr) do { \
+#define DUK_ERROR_UNSUPPORTED(thr) \
+	do { \
 		duk_err_error((thr)); \
 	} while (0)
-#define DUK_DCERROR_UNSUPPORTED(thr) do { \
+#define DUK_DCERROR_UNSUPPORTED(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_ERROR; \
 	} while (0)
-#define DUK_ERROR_ERROR(thr,msg) do { \
+#define DUK_ERROR_ERROR(thr, msg) \
+	do { \
 		duk_err_error((thr)); \
 	} while (0)
-#define DUK_ERROR_RANGE_INDEX(thr,idx) do { \
+#define DUK_ERROR_RANGE_INDEX(thr, idx) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_ERROR_RANGE_PUSH_BEYOND(thr) do { \
+#define DUK_ERROR_RANGE_PUSH_BEYOND(thr) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_ARGS(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_ARGS(thr) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_ARGS(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_ARGS(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_RANGE_ERROR; \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_COUNT(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_COUNT(thr) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_COUNT(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_COUNT(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_RANGE_ERROR; \
 	} while (0)
-#define DUK_ERROR_RANGE_INVALID_LENGTH(thr) do { \
+#define DUK_ERROR_RANGE_INVALID_LENGTH(thr) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_DCERROR_RANGE_INVALID_LENGTH(thr) do { \
+#define DUK_DCERROR_RANGE_INVALID_LENGTH(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_RANGE_ERROR; \
 	} while (0)
-#define DUK_ERROR_RANGE(thr,msg) do { \
+#define DUK_ERROR_RANGE(thr, msg) \
+	do { \
 		duk_err_range((thr)); \
 	} while (0)
-#define DUK_ERROR_EVAL(thr,msg) do { \
+#define DUK_ERROR_EVAL(thr, msg) \
+	do { \
 		duk_err_eval((thr)); \
 	} while (0)
-#define DUK_ERROR_REFERENCE(thr,msg) do { \
+#define DUK_ERROR_REFERENCE(thr, msg) \
+	do { \
 		duk_err_reference((thr)); \
 	} while (0)
-#define DUK_ERROR_SYNTAX(thr,msg) do { \
+#define DUK_ERROR_SYNTAX(thr, msg) \
+	do { \
 		duk_err_syntax((thr)); \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_ARGS(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_ARGS(thr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_ARGS(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_ARGS(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_TYPE_ERROR; \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_STATE(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_STATE(thr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_STATE(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_STATE(thr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_DCERROR_TYPE_INVALID_TRAP_RESULT(thr) do { \
+#define DUK_DCERROR_TYPE_INVALID_TRAP_RESULT(thr) \
+	do { \
 		DUK_UNREF((thr)); \
 		return DUK_RET_TYPE_ERROR; \
 	} while (0)
-#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) do { \
+#define DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_ERROR_TYPE(thr,msg) do { \
+#define DUK_ERROR_TYPE(thr, msg) \
+	do { \
 		duk_err_type((thr)); \
 	} while (0)
-#define DUK_ERROR_URI(thr,msg) do { \
+#define DUK_ERROR_URI(thr, msg) \
+	do { \
 		duk_err_uri((thr)); \
 	} while (0)
-#endif  /* DUK_USE_VERBOSE_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS */
 
 /*
  *  Assert macro: failure causes a fatal error.
  *
  *  NOTE: since the assert macro doesn't take a heap/context argument, there's
  *  no way to look up a heap/context specific fatal error handler which may have
  *  been given by the application.  Instead, assertion failures always use the
@@ -9909,150 +10563,185 @@
 
 #if defined(DUK_USE_ASSERTIONS)
 
 /* The message should be a compile time constant without formatting (less risk);
  * we don't care about assertion text size because they're not used in production
  * builds.
  */
-#define DUK_ASSERT(x)  do { \
-	if (!(x)) { \
-		DUK_FATAL_WITHOUT_CONTEXT("assertion failed: " #x \
-			" (" DUK_FILE_MACRO ":" DUK_MACRO_STRINGIFY(DUK_LINE_MACRO) ")"); \
-	} \
+#define DUK_ASSERT(x) \
+	do { \
+		if (!(x)) { \
+			DUK_FATAL_WITHOUT_CONTEXT("assertion failed: " #x " (" DUK_FILE_MACRO \
+			                          ":" DUK_MACRO_STRINGIFY(DUK_LINE_MACRO) ")"); \
+		} \
 	} while (0)
 
 /* Assertion compatible inside a comma expression, evaluates to void. */
 #define DUK_ASSERT_EXPR(x) \
-	((void) ((x) ? 0 : (DUK_FATAL_WITHOUT_CONTEXT("assertion failed: " #x \
-				" (" DUK_FILE_MACRO ":" DUK_MACRO_STRINGIFY(DUK_LINE_MACRO) ")"), 0)))
+	((void) ((x) ? 0 : \
+                       (DUK_FATAL_WITHOUT_CONTEXT("assertion failed: " #x " (" DUK_FILE_MACRO \
+	                                          ":" DUK_MACRO_STRINGIFY(DUK_LINE_MACRO) ")"), \
+	                0)))
 
-#else  /* DUK_USE_ASSERTIONS */
+#else /* DUK_USE_ASSERTIONS */
 
-#define DUK_ASSERT(x)  do { /* assertion omitted */ } while (0)
+#define DUK_ASSERT(x) \
+	do { /* assertion omitted */ \
+	} while (0)
 
-#define DUK_ASSERT_EXPR(x)  ((void) 0)
+#define DUK_ASSERT_EXPR(x) ((void) 0)
 
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
 /* this variant is used when an assert would generate a compile warning by
  * being always true (e.g. >= 0 comparison for an unsigned value
  */
-#define DUK_ASSERT_DISABLE(x)  do { /* assertion disabled */ } while (0)
+#define DUK_ASSERT_DISABLE(x) \
+	do { /* assertion disabled */ \
+	} while (0)
 
 /*
  *  Assertion helpers
  */
 
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_REFERENCE_COUNTING)
-#define DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(h)  do { \
+#define DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(h) \
+	do { \
 		DUK_ASSERT((h) == NULL || DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) (h)) > 0); \
 	} while (0)
-#define DUK_ASSERT_REFCOUNT_NONZERO_TVAL(tv)  do { \
+#define DUK_ASSERT_REFCOUNT_NONZERO_TVAL(tv) \
+	do { \
 		if ((tv) != NULL && DUK_TVAL_IS_HEAP_ALLOCATED((tv))) { \
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(DUK_TVAL_GET_HEAPHDR((tv))) > 0); \
 		} \
 	} while (0)
 #else
-#define DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(h)  /* no refcount check */
-#define DUK_ASSERT_REFCOUNT_NONZERO_TVAL(tv)    /* no refcount check */
+#define DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(h) /* no refcount check */
+#define DUK_ASSERT_REFCOUNT_NONZERO_TVAL(tv)   /* no refcount check */
 #endif
 
-#define DUK_ASSERT_TOP(ctx,n)  DUK_ASSERT((duk_idx_t) duk_get_top((ctx)) == (duk_idx_t) (n))
+#define DUK_ASSERT_TOP(ctx, n) DUK_ASSERT((duk_idx_t) duk_get_top((ctx)) == (duk_idx_t) (n))
 
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_PACKED_TVAL)
-#define DUK_ASSERT_DOUBLE_IS_NORMALIZED(dval)  do { \
+#define DUK_ASSERT_DOUBLE_IS_NORMALIZED(dval) \
+	do { \
 		duk_double_union duk__assert_tmp_du; \
 		duk__assert_tmp_du.d = (dval); \
 		DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&duk__assert_tmp_du)); \
 	} while (0)
 #else
-#define DUK_ASSERT_DOUBLE_IS_NORMALIZED(dval)  /* nop */
+#define DUK_ASSERT_DOUBLE_IS_NORMALIZED(dval) /* nop */
 #endif
 
-#define DUK_ASSERT_VS_SPACE(thr) \
-	DUK_ASSERT(thr->valstack_top < thr->valstack_end)
+#define DUK_ASSERT_VS_SPACE(thr) DUK_ASSERT(thr->valstack_top < thr->valstack_end)
 
 /*
  *  Helper to initialize a memory area (e.g. struct) with garbage when
  *  assertions enabled.
  */
 
 #if defined(DUK_USE_ASSERTIONS)
-#define DUK_ASSERT_SET_GARBAGE(ptr,size) do { \
+#define DUK_ASSERT_SET_GARBAGE(ptr, size) \
+	do { \
 		duk_memset_unsafe((void *) (ptr), 0x5a, size); \
 	} while (0)
 #else
-#define DUK_ASSERT_SET_GARBAGE(ptr,size) do {} while (0)
+#define DUK_ASSERT_SET_GARBAGE(ptr, size) \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Helper for valstack space
  *
  *  Caller of DUK_ASSERT_VALSTACK_SPACE() estimates the number of free stack entries
  *  required for its own use, and any child calls which are not (a) Duktape API calls
  *  or (b) Duktape calls which involve extending the valstack (e.g. getter call).
  */
 
-#define DUK_VALSTACK_ASSERT_EXTRA  5  /* this is added to checks to allow for Duktape
-                                       * API calls in addition to function's own use
-                                       */
+#define DUK_VALSTACK_ASSERT_EXTRA \
+	5 /* this is added to checks to allow for Duktape \
+	   * API calls in addition to function's own use \
+	   */
 #if defined(DUK_USE_ASSERTIONS)
-#define DUK_ASSERT_VALSTACK_SPACE(thr,n)   do { \
+#define DUK_ASSERT_VALSTACK_SPACE(thr, n) \
+	do { \
 		DUK_ASSERT((thr) != NULL); \
 		DUK_ASSERT((thr)->valstack_end - (thr)->valstack_top >= (n) + DUK_VALSTACK_ASSERT_EXTRA); \
 	} while (0)
 #else
-#define DUK_ASSERT_VALSTACK_SPACE(thr,n)   /* no valstack space check */
+#define DUK_ASSERT_VALSTACK_SPACE(thr, n) /* no valstack space check */
 #endif
 
 /*
  *  Prototypes
  */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg));
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...));
-#else  /* DUK_USE_VERBOSE_ERRORS */
+DUK_NORETURN(
+    DUK_INTERNAL_DECL void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg));
+DUK_NORETURN(DUK_INTERNAL_DECL void
+                 duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...));
+#else /* DUK_USE_VERBOSE_ERRORS */
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_handle_error(duk_hthread *thr, duk_errcode_t code));
-#endif  /* DUK_USE_VERBOSE_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code, const char *msg, const char *filename, duk_int_t line));
+DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_create_and_throw(duk_hthread *thr,
+                                                             duk_errcode_t code,
+                                                             const char *msg,
+                                                             const char *filename,
+                                                             duk_int_t line));
 #else
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code));
 #endif
 
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_error_throw_from_negative_rc(duk_hthread *thr, duk_ret_t rc));
 
-#define DUK_AUGMENT_FLAG_NOBLAME_FILELINE  (1U << 0)  /* if set, don't blame C file/line for .fileName and .lineNumber */
-#define DUK_AUGMENT_FLAG_SKIP_ONE          (1U << 1)  /* if set, skip topmost activation in traceback construction */
+#define DUK_AUGMENT_FLAG_NOBLAME_FILELINE (1U << 0) /* if set, don't blame C file/line for .fileName and .lineNumber */
+#define DUK_AUGMENT_FLAG_SKIP_ONE         (1U << 1) /* if set, skip topmost activation in traceback construction */
 
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
-DUK_INTERNAL_DECL void duk_err_augment_error_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *filename, duk_int_t line, duk_small_uint_t flags);
+DUK_INTERNAL_DECL void duk_err_augment_error_create(duk_hthread *thr,
+                                                    duk_hthread *thr_callstack,
+                                                    const char *filename,
+                                                    duk_int_t line,
+                                                    duk_small_uint_t flags);
 #endif
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
 DUK_INTERNAL_DECL void duk_err_augment_error_throw(duk_hthread *thr);
 #endif
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 #if defined(DUK_USE_PARANOID_ERRORS)
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name));
-#else
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name));
+DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_require_type_index(duk_hthread *thr,
+                                                               const char *filename,
+                                                               duk_int_t linenumber,
+                                                               duk_idx_t idx,
+                                                               const char *expect_name));
+#else
+DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_require_type_index(duk_hthread *thr,
+                                                               const char *filename,
+                                                               duk_int_t linenumber,
+                                                               duk_idx_t idx,
+                                                               const char *expect_name));
 #endif
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber));
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message));
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx));
+DUK_NORETURN(
+    DUK_INTERNAL_DECL void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message));
+DUK_NORETURN(
+    DUK_INTERNAL_DECL void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_range_push_beyond(duk_hthread *thr, const char *filename, duk_int_t linenumber));
-DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message));
+DUK_NORETURN(
+    DUK_INTERNAL_DECL void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_type_invalid_args(duk_hthread *thr, const char *filename, duk_int_t linenumber));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_type_invalid_state(duk_hthread *thr, const char *filename, duk_int_t linenumber));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_type_invalid_trap_result(duk_hthread *thr, const char *filename, duk_int_t linenumber));
-#else  /* DUK_VERBOSE_ERRORS */
+#else /* DUK_VERBOSE_ERRORS */
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_error(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_range(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_eval(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_reference(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_syntax(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_type(duk_hthread *thr));
 DUK_NORETURN(DUK_INTERNAL_DECL void duk_err_uri(duk_hthread *thr));
@@ -10065,192 +10754,194 @@
 DUK_INTERNAL_DECL void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val);
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 DUK_INTERNAL_DECL void duk_err_check_debugger_integration(duk_hthread *thr);
 #endif
 
 DUK_INTERNAL_DECL duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t err_code);
 
-#endif  /* DUK_ERROR_H_INCLUDED */
+#endif /* DUK_ERROR_H_INCLUDED */
 /* #include duk_unicode.h */
 #line 1 "duk_unicode.h"
 /*
  *  Unicode helpers
  */
 
 #if !defined(DUK_UNICODE_H_INCLUDED)
 #define DUK_UNICODE_H_INCLUDED
 
 /*
  *  UTF-8 / XUTF-8 / CESU-8 constants
  */
 
-#define DUK_UNICODE_MAX_XUTF8_LENGTH      7   /* up to 36 bit codepoints */
-#define DUK_UNICODE_MAX_XUTF8_BMP_LENGTH  3   /* all codepoints up to U+FFFF */
-#define DUK_UNICODE_MAX_CESU8_LENGTH      6   /* all codepoints up to U+10FFFF */
-#define DUK_UNICODE_MAX_CESU8_BMP_LENGTH  3   /* all codepoints up to U+FFFF */
+#define DUK_UNICODE_MAX_XUTF8_LENGTH     7 /* up to 36 bit codepoints */
+#define DUK_UNICODE_MAX_XUTF8_BMP_LENGTH 3 /* all codepoints up to U+FFFF */
+#define DUK_UNICODE_MAX_CESU8_LENGTH     6 /* all codepoints up to U+10FFFF */
+#define DUK_UNICODE_MAX_CESU8_BMP_LENGTH 3 /* all codepoints up to U+FFFF */
 
 /*
  *  Useful Unicode codepoints
  *
  *  Integer constants must be signed to avoid unexpected coercions
  *  in comparisons.
  */
 
-#define DUK_UNICODE_CP_ZWNJ                   0x200cL  /* zero-width non-joiner */
-#define DUK_UNICODE_CP_ZWJ                    0x200dL  /* zero-width joiner */
-#define DUK_UNICODE_CP_REPLACEMENT_CHARACTER  0xfffdL  /* http://en.wikipedia.org/wiki/Replacement_character#Replacement_character */
+#define DUK_UNICODE_CP_ZWNJ 0x200cL /* zero-width non-joiner */
+#define DUK_UNICODE_CP_ZWJ  0x200dL /* zero-width joiner */
+#define DUK_UNICODE_CP_REPLACEMENT_CHARACTER \
+	0xfffdL /* http://en.wikipedia.org/wiki/Replacement_character#Replacement_character \
+	         */
 
 /*
  *  ASCII character constants
  *
  *  C character literals like 'x' have a platform specific value and do
  *  not match ASCII (UTF-8) values on e.g. EBCDIC platforms.  So, use
  *  these (admittedly awkward) constants instead.  These constants must
  *  also have signed values to avoid unexpected coercions in comparisons.
  *
  *  http://en.wikipedia.org/wiki/ASCII
  */
 
-#define DUK_ASC_NUL              0x00
-#define DUK_ASC_SOH              0x01
-#define DUK_ASC_STX              0x02
-#define DUK_ASC_ETX              0x03
-#define DUK_ASC_EOT              0x04
-#define DUK_ASC_ENQ              0x05
-#define DUK_ASC_ACK              0x06
-#define DUK_ASC_BEL              0x07
-#define DUK_ASC_BS               0x08
-#define DUK_ASC_HT               0x09
-#define DUK_ASC_LF               0x0a
-#define DUK_ASC_VT               0x0b
-#define DUK_ASC_FF               0x0c
-#define DUK_ASC_CR               0x0d
-#define DUK_ASC_SO               0x0e
-#define DUK_ASC_SI               0x0f
-#define DUK_ASC_DLE              0x10
-#define DUK_ASC_DC1              0x11
-#define DUK_ASC_DC2              0x12
-#define DUK_ASC_DC3              0x13
-#define DUK_ASC_DC4              0x14
-#define DUK_ASC_NAK              0x15
-#define DUK_ASC_SYN              0x16
-#define DUK_ASC_ETB              0x17
-#define DUK_ASC_CAN              0x18
-#define DUK_ASC_EM               0x19
-#define DUK_ASC_SUB              0x1a
-#define DUK_ASC_ESC              0x1b
-#define DUK_ASC_FS               0x1c
-#define DUK_ASC_GS               0x1d
-#define DUK_ASC_RS               0x1e
-#define DUK_ASC_US               0x1f
-#define DUK_ASC_SPACE            0x20
-#define DUK_ASC_EXCLAMATION      0x21
-#define DUK_ASC_DOUBLEQUOTE      0x22
-#define DUK_ASC_HASH             0x23
-#define DUK_ASC_DOLLAR           0x24
-#define DUK_ASC_PERCENT          0x25
-#define DUK_ASC_AMP              0x26
-#define DUK_ASC_SINGLEQUOTE      0x27
-#define DUK_ASC_LPAREN           0x28
-#define DUK_ASC_RPAREN           0x29
-#define DUK_ASC_STAR             0x2a
-#define DUK_ASC_PLUS             0x2b
-#define DUK_ASC_COMMA            0x2c
-#define DUK_ASC_MINUS            0x2d
-#define DUK_ASC_PERIOD           0x2e
-#define DUK_ASC_SLASH            0x2f
-#define DUK_ASC_0                0x30
-#define DUK_ASC_1                0x31
-#define DUK_ASC_2                0x32
-#define DUK_ASC_3                0x33
-#define DUK_ASC_4                0x34
-#define DUK_ASC_5                0x35
-#define DUK_ASC_6                0x36
-#define DUK_ASC_7                0x37
-#define DUK_ASC_8                0x38
-#define DUK_ASC_9                0x39
-#define DUK_ASC_COLON            0x3a
-#define DUK_ASC_SEMICOLON        0x3b
-#define DUK_ASC_LANGLE           0x3c
-#define DUK_ASC_EQUALS           0x3d
-#define DUK_ASC_RANGLE           0x3e
-#define DUK_ASC_QUESTION         0x3f
-#define DUK_ASC_ATSIGN           0x40
-#define DUK_ASC_UC_A             0x41
-#define DUK_ASC_UC_B             0x42
-#define DUK_ASC_UC_C             0x43
-#define DUK_ASC_UC_D             0x44
-#define DUK_ASC_UC_E             0x45
-#define DUK_ASC_UC_F             0x46
-#define DUK_ASC_UC_G             0x47
-#define DUK_ASC_UC_H             0x48
-#define DUK_ASC_UC_I             0x49
-#define DUK_ASC_UC_J             0x4a
-#define DUK_ASC_UC_K             0x4b
-#define DUK_ASC_UC_L             0x4c
-#define DUK_ASC_UC_M             0x4d
-#define DUK_ASC_UC_N             0x4e
-#define DUK_ASC_UC_O             0x4f
-#define DUK_ASC_UC_P             0x50
-#define DUK_ASC_UC_Q             0x51
-#define DUK_ASC_UC_R             0x52
-#define DUK_ASC_UC_S             0x53
-#define DUK_ASC_UC_T             0x54
-#define DUK_ASC_UC_U             0x55
-#define DUK_ASC_UC_V             0x56
-#define DUK_ASC_UC_W             0x57
-#define DUK_ASC_UC_X             0x58
-#define DUK_ASC_UC_Y             0x59
-#define DUK_ASC_UC_Z             0x5a
-#define DUK_ASC_LBRACKET         0x5b
-#define DUK_ASC_BACKSLASH        0x5c
-#define DUK_ASC_RBRACKET         0x5d
-#define DUK_ASC_CARET            0x5e
-#define DUK_ASC_UNDERSCORE       0x5f
-#define DUK_ASC_GRAVE            0x60
-#define DUK_ASC_LC_A             0x61
-#define DUK_ASC_LC_B             0x62
-#define DUK_ASC_LC_C             0x63
-#define DUK_ASC_LC_D             0x64
-#define DUK_ASC_LC_E             0x65
-#define DUK_ASC_LC_F             0x66
-#define DUK_ASC_LC_G             0x67
-#define DUK_ASC_LC_H             0x68
-#define DUK_ASC_LC_I             0x69
-#define DUK_ASC_LC_J             0x6a
-#define DUK_ASC_LC_K             0x6b
-#define DUK_ASC_LC_L             0x6c
-#define DUK_ASC_LC_M             0x6d
-#define DUK_ASC_LC_N             0x6e
-#define DUK_ASC_LC_O             0x6f
-#define DUK_ASC_LC_P             0x70
-#define DUK_ASC_LC_Q             0x71
-#define DUK_ASC_LC_R             0x72
-#define DUK_ASC_LC_S             0x73
-#define DUK_ASC_LC_T             0x74
-#define DUK_ASC_LC_U             0x75
-#define DUK_ASC_LC_V             0x76
-#define DUK_ASC_LC_W             0x77
-#define DUK_ASC_LC_X             0x78
-#define DUK_ASC_LC_Y             0x79
-#define DUK_ASC_LC_Z             0x7a
-#define DUK_ASC_LCURLY           0x7b
-#define DUK_ASC_PIPE             0x7c
-#define DUK_ASC_RCURLY           0x7d
-#define DUK_ASC_TILDE            0x7e
-#define DUK_ASC_DEL              0x7f
+#define DUK_ASC_NUL         0x00
+#define DUK_ASC_SOH         0x01
+#define DUK_ASC_STX         0x02
+#define DUK_ASC_ETX         0x03
+#define DUK_ASC_EOT         0x04
+#define DUK_ASC_ENQ         0x05
+#define DUK_ASC_ACK         0x06
+#define DUK_ASC_BEL         0x07
+#define DUK_ASC_BS          0x08
+#define DUK_ASC_HT          0x09
+#define DUK_ASC_LF          0x0a
+#define DUK_ASC_VT          0x0b
+#define DUK_ASC_FF          0x0c
+#define DUK_ASC_CR          0x0d
+#define DUK_ASC_SO          0x0e
+#define DUK_ASC_SI          0x0f
+#define DUK_ASC_DLE         0x10
+#define DUK_ASC_DC1         0x11
+#define DUK_ASC_DC2         0x12
+#define DUK_ASC_DC3         0x13
+#define DUK_ASC_DC4         0x14
+#define DUK_ASC_NAK         0x15
+#define DUK_ASC_SYN         0x16
+#define DUK_ASC_ETB         0x17
+#define DUK_ASC_CAN         0x18
+#define DUK_ASC_EM          0x19
+#define DUK_ASC_SUB         0x1a
+#define DUK_ASC_ESC         0x1b
+#define DUK_ASC_FS          0x1c
+#define DUK_ASC_GS          0x1d
+#define DUK_ASC_RS          0x1e
+#define DUK_ASC_US          0x1f
+#define DUK_ASC_SPACE       0x20
+#define DUK_ASC_EXCLAMATION 0x21
+#define DUK_ASC_DOUBLEQUOTE 0x22
+#define DUK_ASC_HASH        0x23
+#define DUK_ASC_DOLLAR      0x24
+#define DUK_ASC_PERCENT     0x25
+#define DUK_ASC_AMP         0x26
+#define DUK_ASC_SINGLEQUOTE 0x27
+#define DUK_ASC_LPAREN      0x28
+#define DUK_ASC_RPAREN      0x29
+#define DUK_ASC_STAR        0x2a
+#define DUK_ASC_PLUS        0x2b
+#define DUK_ASC_COMMA       0x2c
+#define DUK_ASC_MINUS       0x2d
+#define DUK_ASC_PERIOD      0x2e
+#define DUK_ASC_SLASH       0x2f
+#define DUK_ASC_0           0x30
+#define DUK_ASC_1           0x31
+#define DUK_ASC_2           0x32
+#define DUK_ASC_3           0x33
+#define DUK_ASC_4           0x34
+#define DUK_ASC_5           0x35
+#define DUK_ASC_6           0x36
+#define DUK_ASC_7           0x37
+#define DUK_ASC_8           0x38
+#define DUK_ASC_9           0x39
+#define DUK_ASC_COLON       0x3a
+#define DUK_ASC_SEMICOLON   0x3b
+#define DUK_ASC_LANGLE      0x3c
+#define DUK_ASC_EQUALS      0x3d
+#define DUK_ASC_RANGLE      0x3e
+#define DUK_ASC_QUESTION    0x3f
+#define DUK_ASC_ATSIGN      0x40
+#define DUK_ASC_UC_A        0x41
+#define DUK_ASC_UC_B        0x42
+#define DUK_ASC_UC_C        0x43
+#define DUK_ASC_UC_D        0x44
+#define DUK_ASC_UC_E        0x45
+#define DUK_ASC_UC_F        0x46
+#define DUK_ASC_UC_G        0x47
+#define DUK_ASC_UC_H        0x48
+#define DUK_ASC_UC_I        0x49
+#define DUK_ASC_UC_J        0x4a
+#define DUK_ASC_UC_K        0x4b
+#define DUK_ASC_UC_L        0x4c
+#define DUK_ASC_UC_M        0x4d
+#define DUK_ASC_UC_N        0x4e
+#define DUK_ASC_UC_O        0x4f
+#define DUK_ASC_UC_P        0x50
+#define DUK_ASC_UC_Q        0x51
+#define DUK_ASC_UC_R        0x52
+#define DUK_ASC_UC_S        0x53
+#define DUK_ASC_UC_T        0x54
+#define DUK_ASC_UC_U        0x55
+#define DUK_ASC_UC_V        0x56
+#define DUK_ASC_UC_W        0x57
+#define DUK_ASC_UC_X        0x58
+#define DUK_ASC_UC_Y        0x59
+#define DUK_ASC_UC_Z        0x5a
+#define DUK_ASC_LBRACKET    0x5b
+#define DUK_ASC_BACKSLASH   0x5c
+#define DUK_ASC_RBRACKET    0x5d
+#define DUK_ASC_CARET       0x5e
+#define DUK_ASC_UNDERSCORE  0x5f
+#define DUK_ASC_GRAVE       0x60
+#define DUK_ASC_LC_A        0x61
+#define DUK_ASC_LC_B        0x62
+#define DUK_ASC_LC_C        0x63
+#define DUK_ASC_LC_D        0x64
+#define DUK_ASC_LC_E        0x65
+#define DUK_ASC_LC_F        0x66
+#define DUK_ASC_LC_G        0x67
+#define DUK_ASC_LC_H        0x68
+#define DUK_ASC_LC_I        0x69
+#define DUK_ASC_LC_J        0x6a
+#define DUK_ASC_LC_K        0x6b
+#define DUK_ASC_LC_L        0x6c
+#define DUK_ASC_LC_M        0x6d
+#define DUK_ASC_LC_N        0x6e
+#define DUK_ASC_LC_O        0x6f
+#define DUK_ASC_LC_P        0x70
+#define DUK_ASC_LC_Q        0x71
+#define DUK_ASC_LC_R        0x72
+#define DUK_ASC_LC_S        0x73
+#define DUK_ASC_LC_T        0x74
+#define DUK_ASC_LC_U        0x75
+#define DUK_ASC_LC_V        0x76
+#define DUK_ASC_LC_W        0x77
+#define DUK_ASC_LC_X        0x78
+#define DUK_ASC_LC_Y        0x79
+#define DUK_ASC_LC_Z        0x7a
+#define DUK_ASC_LCURLY      0x7b
+#define DUK_ASC_PIPE        0x7c
+#define DUK_ASC_RCURLY      0x7d
+#define DUK_ASC_TILDE       0x7e
+#define DUK_ASC_DEL         0x7f
 
 /*
  *  Miscellaneous
  */
 
 /* Uppercase A is 0x41, lowercase a is 0x61; OR 0x20 to convert uppercase
  * to lowercase.
  */
-#define DUK_LOWERCASE_CHAR_ASCII(x)  ((x) | 0x20)
+#define DUK_LOWERCASE_CHAR_ASCII(x) ((x) | 0x20)
 
 /*
  *  Unicode tables
  */
 
 #if defined(DUK_USE_SOURCE_NONBMP)
 /*
@@ -10330,93 +11021,100 @@
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_digit[2];
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_white[22];
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_wordchar[8];
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_not_digit[4];
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_not_white[24];
 DUK_INTERNAL_DECL const duk_uint16_t duk_unicode_re_ranges_not_wordchar[10];
 DUK_INTERNAL_DECL const duk_int8_t duk_is_idchar_tab[128];
-#endif  /* !DUK_SINGLE_FILE */
+#endif /* !DUK_SINGLE_FILE */
 
 /*
  *  Prototypes
  */
 
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_get_xutf8_length(duk_ucodepoint_t cp);
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_get_cesu8_length(duk_ucodepoint_t cp);
 #endif
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_encode_cesu8(duk_ucodepoint_t cp, duk_uint8_t *out);
-DUK_INTERNAL_DECL duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_ucodepoint_t *out_cp);
-DUK_INTERNAL_DECL duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end);
+DUK_INTERNAL_DECL duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr,
+                                                           const duk_uint8_t **ptr,
+                                                           const duk_uint8_t *ptr_start,
+                                                           const duk_uint8_t *ptr_end,
+                                                           duk_ucodepoint_t *out_cp);
+DUK_INTERNAL_DECL duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr,
+                                                                    const duk_uint8_t **ptr,
+                                                                    const duk_uint8_t *ptr_start,
+                                                                    const duk_uint8_t *ptr_end);
 DUK_INTERNAL_DECL duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen);
 DUK_INTERNAL_DECL duk_bool_t duk_unicode_is_utf8_compatible(const duk_uint8_t *buf, duk_size_t len);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_is_whitespace(duk_codepoint_t cp);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_is_line_terminator(duk_codepoint_t cp);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_is_identifier_start(duk_codepoint_t cp);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_is_identifier_part(duk_codepoint_t cp);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_is_letter(duk_codepoint_t cp);
 DUK_INTERNAL_DECL void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase);
 #if defined(DUK_USE_REGEXP_SUPPORT)
 DUK_INTERNAL_DECL duk_codepoint_t duk_unicode_re_canonicalize_char(duk_hthread *thr, duk_codepoint_t cp);
 DUK_INTERNAL_DECL duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t cp);
 #endif
 
-#endif  /* DUK_UNICODE_H_INCLUDED */
+#endif /* DUK_UNICODE_H_INCLUDED */
 /* #include duk_json.h */
 #line 1 "duk_json.h"
 /*
  *  Defines for JSON, especially duk_bi_json.c.
  */
 
 #if !defined(DUK_JSON_H_INCLUDED)
 #define DUK_JSON_H_INCLUDED
 
 /* Encoding/decoding flags */
-#define DUK_JSON_FLAG_ASCII_ONLY              (1U << 0)  /* escape any non-ASCII characters */
-#define DUK_JSON_FLAG_AVOID_KEY_QUOTES        (1U << 1)  /* avoid key quotes when key is an ASCII Identifier */
-#define DUK_JSON_FLAG_EXT_CUSTOM              (1U << 2)  /* extended types: custom encoding */
-#define DUK_JSON_FLAG_EXT_COMPATIBLE          (1U << 3)  /* extended types: compatible encoding */
+#define DUK_JSON_FLAG_ASCII_ONLY       (1U << 0) /* escape any non-ASCII characters */
+#define DUK_JSON_FLAG_AVOID_KEY_QUOTES (1U << 1) /* avoid key quotes when key is an ASCII Identifier */
+#define DUK_JSON_FLAG_EXT_CUSTOM       (1U << 2) /* extended types: custom encoding */
+#define DUK_JSON_FLAG_EXT_COMPATIBLE   (1U << 3) /* extended types: compatible encoding */
 
 /* How much stack to require on entry to object/array encode */
-#define DUK_JSON_ENC_REQSTACK                 32
+#define DUK_JSON_ENC_REQSTACK 32
 
 /* How much stack to require on entry to object/array decode */
-#define DUK_JSON_DEC_REQSTACK                 32
+#define DUK_JSON_DEC_REQSTACK 32
 
 /* How large a loop detection stack to use */
-#define DUK_JSON_ENC_LOOPARRAY                64
+#define DUK_JSON_ENC_LOOPARRAY 64
 
 /* Encoding state.  Heap object references are all borrowed. */
 typedef struct {
 	duk_hthread *thr;
-	duk_bufwriter_ctx bw;        /* output bufwriter */
-	duk_hobject *h_replacer;     /* replacer function */
-	duk_hstring *h_gap;          /* gap (if empty string, NULL) */
-	duk_idx_t idx_proplist;      /* explicit PropertyList */
-	duk_idx_t idx_loop;          /* valstack index of loop detection object */
+	duk_bufwriter_ctx bw; /* output bufwriter */
+	duk_hobject *h_replacer; /* replacer function */
+	duk_hstring *h_gap; /* gap (if empty string, NULL) */
+	duk_idx_t idx_proplist; /* explicit PropertyList */
+	duk_idx_t idx_loop; /* valstack index of loop detection object */
 	duk_small_uint_t flags;
 	duk_small_uint_t flag_ascii_only;
 	duk_small_uint_t flag_avoid_key_quotes;
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 	duk_small_uint_t flag_ext_custom;
 	duk_small_uint_t flag_ext_compatible;
 	duk_small_uint_t flag_ext_custom_or_compatible;
 #endif
 	duk_uint_t recursion_depth;
 	duk_uint_t recursion_limit;
-	duk_uint_t mask_for_undefined;      /* type bit mask: types which certainly produce 'undefined' */
+	duk_uint_t mask_for_undefined; /* type bit mask: types which certainly produce 'undefined' */
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 	duk_small_uint_t stridx_custom_undefined;
 	duk_small_uint_t stridx_custom_nan;
 	duk_small_uint_t stridx_custom_neginf;
 	duk_small_uint_t stridx_custom_posinf;
 	duk_small_uint_t stridx_custom_function;
 #endif
-	duk_hobject *visiting[DUK_JSON_ENC_LOOPARRAY];  /* indexed by recursion_depth */
+	duk_hobject *visiting[DUK_JSON_ENC_LOOPARRAY]; /* indexed by recursion_depth */
 } duk_json_enc_ctx;
 
 typedef struct {
 	duk_hthread *thr;
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_start;
 	const duk_uint8_t *p_end;
@@ -10427,40 +11125,41 @@
 	duk_small_uint_t flag_ext_compatible;
 	duk_small_uint_t flag_ext_custom_or_compatible;
 #endif
 	duk_int_t recursion_depth;
 	duk_int_t recursion_limit;
 } duk_json_dec_ctx;
 
-#endif  /* DUK_JSON_H_INCLUDED */
+#endif /* DUK_JSON_H_INCLUDED */
 /* #include duk_js.h */
 #line 1 "duk_js.h"
 /*
  *  ECMAScript execution, support primitives.
  */
 
 #if !defined(DUK_JS_H_INCLUDED)
 #define DUK_JS_H_INCLUDED
 
 /* Flags for call handling.  Lowest flags must match bytecode DUK_BC_CALL_FLAG_xxx 1:1. */
-#define DUK_CALL_FLAG_TAILCALL                 (1U << 0)  /* setup for a tail call */
-#define DUK_CALL_FLAG_CONSTRUCT                (1U << 1)  /* constructor call (i.e. called as 'new Foo()') */
-#define DUK_CALL_FLAG_CALLED_AS_EVAL           (1U << 2)  /* call was made using the identifier 'eval' */
-#define DUK_CALL_FLAG_ALLOW_ECMATOECMA         (1U << 3)  /* ecma-to-ecma call with executor reuse is possible */
-#define DUK_CALL_FLAG_DIRECT_EVAL              (1U << 4)  /* call is a direct eval call */
-#define DUK_CALL_FLAG_CONSTRUCT_PROXY          (1U << 5)  /* handled via 'construct' proxy trap, check return value invariant(s) */
-#define DUK_CALL_FLAG_DEFAULT_INSTANCE_UPDATED (1U << 6)  /* prototype of 'default instance' updated, temporary flag in call handling */
+#define DUK_CALL_FLAG_TAILCALL         (1U << 0) /* setup for a tail call */
+#define DUK_CALL_FLAG_CONSTRUCT        (1U << 1) /* constructor call (i.e. called as 'new Foo()') */
+#define DUK_CALL_FLAG_CALLED_AS_EVAL   (1U << 2) /* call was made using the identifier 'eval' */
+#define DUK_CALL_FLAG_ALLOW_ECMATOECMA (1U << 3) /* ecma-to-ecma call with executor reuse is possible */
+#define DUK_CALL_FLAG_DIRECT_EVAL      (1U << 4) /* call is a direct eval call */
+#define DUK_CALL_FLAG_CONSTRUCT_PROXY  (1U << 5) /* handled via 'construct' proxy trap, check return value invariant(s) */
+#define DUK_CALL_FLAG_DEFAULT_INSTANCE_UPDATED \
+	(1U << 6) /* prototype of 'default instance' updated, temporary flag in call handling */
 
 /* Flags for duk_js_equals_helper(). */
-#define DUK_EQUALS_FLAG_SAMEVALUE            (1U << 0)  /* use SameValue instead of non-strict equality */
-#define DUK_EQUALS_FLAG_STRICT               (1U << 1)  /* use strict equality instead of non-strict equality */
+#define DUK_EQUALS_FLAG_SAMEVALUE (1U << 0) /* use SameValue instead of non-strict equality */
+#define DUK_EQUALS_FLAG_STRICT    (1U << 1) /* use strict equality instead of non-strict equality */
 
 /* Flags for duk_js_compare_helper(). */
-#define DUK_COMPARE_FLAG_NEGATE              (1U << 0)  /* negate result */
-#define DUK_COMPARE_FLAG_EVAL_LEFT_FIRST     (1U << 1)  /* eval left argument first */
+#define DUK_COMPARE_FLAG_NEGATE          (1U << 0) /* negate result */
+#define DUK_COMPARE_FLAG_EVAL_LEFT_FIRST (1U << 1) /* eval left argument first */
 
 /* conversions, coercions, comparison, etc */
 DUK_INTERNAL_DECL duk_bool_t duk_js_toboolean(duk_tval *tv);
 DUK_INTERNAL_DECL duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL duk_double_t duk_js_tointeger_number(duk_double_t x);
 DUK_INTERNAL_DECL duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv);
@@ -10468,17 +11167,20 @@
 DUK_INTERNAL_DECL duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv);
 DUK_INTERNAL_DECL duk_uarridx_t duk_js_to_arrayindex_string(const duk_uint8_t *str, duk_uint32_t blen);
 #if !defined(DUK_USE_HSTRING_ARRIDX)
 DUK_INTERNAL_DECL duk_uarridx_t duk_js_to_arrayindex_hstring_fast_known(duk_hstring *h);
 DUK_INTERNAL_DECL duk_uarridx_t duk_js_to_arrayindex_hstring_fast(duk_hstring *h);
 #endif
 DUK_INTERNAL_DECL duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
-DUK_INTERNAL_DECL duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1, const duk_uint8_t *buf2, duk_size_t len1, duk_size_t len2);
+DUK_INTERNAL_DECL duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1,
+                                                      const duk_uint8_t *buf2,
+                                                      duk_size_t len1,
+                                                      duk_size_t len2);
 DUK_INTERNAL_DECL duk_small_int_t duk_js_string_compare(duk_hstring *h1, duk_hstring *h2);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_INTERNAL_DECL duk_small_int_t duk_js_buffer_compare(duk_heap *heap, duk_hbuffer *h1, duk_hbuffer *h2);
 #endif
 DUK_INTERNAL_DECL duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
 DUK_INTERNAL_DECL duk_bool_t duk_js_instanceof(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);
 #if defined(DUK_USE_SYMBOL_BUILTIN)
 DUK_INTERNAL_DECL duk_bool_t duk_js_instanceof_ordinary(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);
 #endif
@@ -10487,179 +11189,195 @@
 DUK_INTERNAL_DECL duk_bool_t duk_js_isarray_hobject(duk_hobject *h);
 DUK_INTERNAL_DECL duk_bool_t duk_js_isarray(duk_tval *tv);
 
 /* arithmetic */
 DUK_INTERNAL_DECL double duk_js_arith_pow(double x, double y);
 DUK_INTERNAL_DECL double duk_js_arith_mod(double x, double y);
 
-#define duk_js_equals(thr,tv_x,tv_y) \
-	duk_js_equals_helper((thr), (tv_x), (tv_y), 0)
-#define duk_js_strict_equals(tv_x,tv_y) \
-	duk_js_equals_helper(NULL, (tv_x), (tv_y), DUK_EQUALS_FLAG_STRICT)
-#define duk_js_samevalue(tv_x,tv_y) \
-	duk_js_equals_helper(NULL, (tv_x), (tv_y), DUK_EQUALS_FLAG_SAMEVALUE)
+#define duk_js_equals(thr, tv_x, tv_y)   duk_js_equals_helper((thr), (tv_x), (tv_y), 0)
+#define duk_js_strict_equals(tv_x, tv_y) duk_js_equals_helper(NULL, (tv_x), (tv_y), DUK_EQUALS_FLAG_STRICT)
+#define duk_js_samevalue(tv_x, tv_y)     duk_js_equals_helper(NULL, (tv_x), (tv_y), DUK_EQUALS_FLAG_SAMEVALUE)
 
 /* E5 Sections 11.8.1, 11.8.5; x < y */
-#define duk_js_lessthan(thr,tv_x,tv_y) \
-	duk_js_compare_helper((thr), (tv_x), (tv_Y), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST)
+#define duk_js_lessthan(thr, tv_x, tv_y) duk_js_compare_helper((thr), (tv_x), (tv_Y), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST)
 
 /* E5 Sections 11.8.2, 11.8.5; x > y  -->  y < x */
-#define duk_js_greaterthan(thr,tv_x,tv_y) \
-	duk_js_compare_helper((thr), (tv_y), (tv_x), 0)
+#define duk_js_greaterthan(thr, tv_x, tv_y) duk_js_compare_helper((thr), (tv_y), (tv_x), 0)
 
 /* E5 Sections 11.8.3, 11.8.5; x <= y  -->  not (x > y)  -->  not (y < x) */
-#define duk_js_lessthanorequal(thr,tv_x,tv_y) \
-	duk_js_compare_helper((thr), (tv_y), (tv_x), DUK_COMPARE_FLAG_NEGATE)
+#define duk_js_lessthanorequal(thr, tv_x, tv_y) duk_js_compare_helper((thr), (tv_y), (tv_x), DUK_COMPARE_FLAG_NEGATE)
 
 /* E5 Sections 11.8.4, 11.8.5; x >= y  -->  not (x < y) */
-#define duk_js_greaterthanorequal(thr,tv_x,tv_y) \
+#define duk_js_greaterthanorequal(thr, tv_x, tv_y) \
 	duk_js_compare_helper((thr), (tv_x), (tv_y), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST | DUK_COMPARE_FLAG_NEGATE)
 
 /* identifiers and environment handling */
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL duk_bool_t duk_js_hasvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name);
 #endif
 DUK_INTERNAL_DECL duk_bool_t duk_js_getvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_bool_t throw_flag);
-DUK_INTERNAL_DECL duk_bool_t duk_js_getvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag);
-DUK_INTERNAL_DECL void duk_js_putvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_tval *val, duk_bool_t strict);
-DUK_INTERNAL_DECL void duk_js_putvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_bool_t strict);
-#if 0  /*unused*/
+DUK_INTERNAL_DECL duk_bool_t duk_js_getvar_activation(duk_hthread *thr,
+                                                      duk_activation *act,
+                                                      duk_hstring *name,
+                                                      duk_bool_t throw_flag);
+DUK_INTERNAL_DECL void duk_js_putvar_envrec(duk_hthread *thr,
+                                            duk_hobject *env,
+                                            duk_hstring *name,
+                                            duk_tval *val,
+                                            duk_bool_t strict);
+DUK_INTERNAL_DECL void duk_js_putvar_activation(duk_hthread *thr,
+                                                duk_activation *act,
+                                                duk_hstring *name,
+                                                duk_tval *val,
+                                                duk_bool_t strict);
+#if 0 /*unused*/
 DUK_INTERNAL_DECL duk_bool_t duk_js_delvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name);
 #endif
 DUK_INTERNAL_DECL duk_bool_t duk_js_delvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name);
-DUK_INTERNAL_DECL duk_bool_t duk_js_declvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_small_uint_t prop_flags, duk_bool_t is_func_decl);
+DUK_INTERNAL_DECL duk_bool_t duk_js_declvar_activation(duk_hthread *thr,
+                                                       duk_activation *act,
+                                                       duk_hstring *name,
+                                                       duk_tval *val,
+                                                       duk_small_uint_t prop_flags,
+                                                       duk_bool_t is_func_decl);
 DUK_INTERNAL_DECL void duk_js_init_activation_environment_records_delayed(duk_hthread *thr, duk_activation *act);
 DUK_INTERNAL_DECL void duk_js_close_environment_record(duk_hthread *thr, duk_hobject *env);
-DUK_INTERNAL_DECL duk_hobject *duk_create_activation_environment_record(duk_hthread *thr, duk_hobject *func, duk_size_t bottom_byteoff);
+DUK_INTERNAL_DECL duk_hobject *duk_create_activation_environment_record(duk_hthread *thr,
+                                                                        duk_hobject *func,
+                                                                        duk_size_t bottom_byteoff);
 DUK_INTERNAL_DECL void duk_js_push_closure(duk_hthread *thr,
                                            duk_hcompfunc *fun_temp,
                                            duk_hobject *outer_var_env,
                                            duk_hobject *outer_lex_env,
                                            duk_bool_t add_auto_proto);
 
 /* call handling */
 DUK_INTERNAL_DECL void duk_native_stack_check(duk_hthread *thr);
 DUK_INTERNAL_DECL duk_int_t duk_handle_call_unprotected(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags);
 DUK_INTERNAL_DECL duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags);
-DUK_INTERNAL_DECL duk_int_t duk_handle_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t num_stack_args, duk_idx_t num_stack_res);
+DUK_INTERNAL_DECL duk_int_t
+duk_handle_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t num_stack_args, duk_idx_t num_stack_res);
 DUK_INTERNAL_DECL void duk_call_construct_postprocess(duk_hthread *thr, duk_small_uint_t proxy_invariant);
 #if defined(DUK_USE_VERBOSE_ERRORS)
 DUK_INTERNAL_DECL void duk_call_setup_propcall_error(duk_hthread *thr, duk_tval *tv_base, duk_tval *tv_key);
 #endif
 
 /* bytecode execution */
 DUK_INTERNAL_DECL void duk_js_execute_bytecode(duk_hthread *exec_thr);
 
-#endif  /* DUK_JS_H_INCLUDED */
+#endif /* DUK_JS_H_INCLUDED */
 /* #include duk_numconv.h */
 #line 1 "duk_numconv.h"
 /*
  *  Number-to-string conversion.  The semantics of these is very tightly
  *  bound with the ECMAScript semantics required for call sites.
  */
 
 #if !defined(DUK_NUMCONV_H_INCLUDED)
 #define DUK_NUMCONV_H_INCLUDED
 
 /* Output a specified number of digits instead of using the shortest
  * form.  Used for toPrecision() and toFixed().
  */
-#define DUK_N2S_FLAG_FIXED_FORMAT         (1U << 0)
+#define DUK_N2S_FLAG_FIXED_FORMAT (1U << 0)
 
 /* Force exponential format.  Used for toExponential(). */
-#define DUK_N2S_FLAG_FORCE_EXP            (1U << 1)
+#define DUK_N2S_FLAG_FORCE_EXP (1U << 1)
 
 /* If number would need zero padding (for whole number part), use
  * exponential format instead.  E.g. if input number is 12300, 3
  * digits are generated ("123"), output "1.23e+4" instead of "12300".
  * Used for toPrecision().
  */
-#define DUK_N2S_FLAG_NO_ZERO_PAD          (1U << 2)
+#define DUK_N2S_FLAG_NO_ZERO_PAD (1U << 2)
 
 /* Digit count indicates number of fractions (i.e. an absolute
  * digit index instead of a relative one).  Used together with
  * DUK_N2S_FLAG_FIXED_FORMAT for toFixed().
  */
-#define DUK_N2S_FLAG_FRACTION_DIGITS      (1U << 3)
+#define DUK_N2S_FLAG_FRACTION_DIGITS (1U << 3)
 
 /*
  *  String-to-number conversion
  */
 
 /* Maximum exponent value when parsing numbers.  This is not strictly
  * compliant as there should be no upper limit, but as we parse the
  * exponent without a bigint, impose some limit.  The limit should be
  * small enough that multiplying it (or limit-1 to be precise) won't
  * overflow signed 32-bit integer range.  Exponent is only parsed with
  * radix 10, but with maximum radix (36) a safe limit is:
  * (10000000*36).toString(16) -> '15752a00'
  */
-#define DUK_S2N_MAX_EXPONENT              10000000L
+#define DUK_S2N_MAX_EXPONENT 10000000L
 
 /* Trim white space (= allow leading and trailing whitespace) */
-#define DUK_S2N_FLAG_TRIM_WHITE           (1U << 0)
+#define DUK_S2N_FLAG_TRIM_WHITE (1U << 0)
 
 /* Allow exponent */
-#define DUK_S2N_FLAG_ALLOW_EXP            (1U << 1)
+#define DUK_S2N_FLAG_ALLOW_EXP (1U << 1)
 
 /* Allow trailing garbage (e.g. treat "123foo" as "123) */
-#define DUK_S2N_FLAG_ALLOW_GARBAGE        (1U << 2)
+#define DUK_S2N_FLAG_ALLOW_GARBAGE (1U << 2)
 
 /* Allow leading plus sign */
-#define DUK_S2N_FLAG_ALLOW_PLUS           (1U << 3)
+#define DUK_S2N_FLAG_ALLOW_PLUS (1U << 3)
 
 /* Allow leading minus sign */
-#define DUK_S2N_FLAG_ALLOW_MINUS          (1U << 4)
+#define DUK_S2N_FLAG_ALLOW_MINUS (1U << 4)
 
 /* Allow 'Infinity' */
-#define DUK_S2N_FLAG_ALLOW_INF            (1U << 5)
+#define DUK_S2N_FLAG_ALLOW_INF (1U << 5)
 
 /* Allow fraction part */
-#define DUK_S2N_FLAG_ALLOW_FRAC           (1U << 6)
+#define DUK_S2N_FLAG_ALLOW_FRAC (1U << 6)
 
 /* Allow naked fraction (e.g. ".123") */
-#define DUK_S2N_FLAG_ALLOW_NAKED_FRAC     (1U << 7)
+#define DUK_S2N_FLAG_ALLOW_NAKED_FRAC (1U << 7)
 
 /* Allow empty fraction (e.g. "123.") */
-#define DUK_S2N_FLAG_ALLOW_EMPTY_FRAC     (1U << 8)
+#define DUK_S2N_FLAG_ALLOW_EMPTY_FRAC (1U << 8)
 
 /* Allow empty string to be interpreted as 0 */
-#define DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO  (1U << 9)
+#define DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO (1U << 9)
 
 /* Allow leading zeroes (e.g. "0123" -> "123") */
-#define DUK_S2N_FLAG_ALLOW_LEADING_ZERO   (1U << 10)
+#define DUK_S2N_FLAG_ALLOW_LEADING_ZERO (1U << 10)
 
 /* Allow automatic detection of hex base ("0x" or "0X" prefix),
  * overrides radix argument and forces integer mode.
  */
-#define DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT   (1U << 11)
+#define DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT (1U << 11)
 
 /* Allow automatic detection of legacy octal base ("0n"),
  * overrides radix argument and forces integer mode.
  */
-#define DUK_S2N_FLAG_ALLOW_AUTO_LEGACY_OCT_INT   (1U << 12)
+#define DUK_S2N_FLAG_ALLOW_AUTO_LEGACY_OCT_INT (1U << 12)
 
 /* Allow automatic detection of ES2015 octal base ("0o123"),
  * overrides radix argument and forces integer mode.
  */
-#define DUK_S2N_FLAG_ALLOW_AUTO_OCT_INT   (1U << 13)
+#define DUK_S2N_FLAG_ALLOW_AUTO_OCT_INT (1U << 13)
 
 /* Allow automatic detection of ES2015 binary base ("0b10001"),
  * overrides radix argument and forces integer mode.
  */
-#define DUK_S2N_FLAG_ALLOW_AUTO_BIN_INT   (1U << 14)
+#define DUK_S2N_FLAG_ALLOW_AUTO_BIN_INT (1U << 14)
 
 /*
  *  Prototypes
  */
 
-DUK_INTERNAL_DECL void duk_numconv_stringify(duk_hthread *thr, duk_small_int_t radix, duk_small_int_t digits, duk_small_uint_t flags);
+DUK_INTERNAL_DECL void duk_numconv_stringify(duk_hthread *thr,
+                                             duk_small_int_t radix,
+                                             duk_small_int_t digits,
+                                             duk_small_uint_t flags);
 DUK_INTERNAL_DECL void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags);
 
-#endif  /* DUK_NUMCONV_H_INCLUDED */
+#endif /* DUK_NUMCONV_H_INCLUDED */
 /* #include duk_bi_protos.h */
 #line 1 "duk_bi_protos.h"
 /*
  *  Prototypes for built-in functions not automatically covered by the
  *  header declarations emitted by genbuiltins.py.
  */
 
@@ -10668,15 +11386,15 @@
 
 /* Buffer size needed for ISO 8601 formatting.
  * Accurate value is 32 + 1 for NUL termination:
  *   >>> len('+123456-01-23T12:34:56.123+12:34')
  *   32
  * Include additional space to be safe.
  */
-#define  DUK_BI_DATE_ISO8601_BUFSIZE  40
+#define DUK_BI_DATE_ISO8601_BUFSIZE 40
 
 /* Helpers exposed for internal use */
 DUK_INTERNAL_DECL void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags);
 DUK_INTERNAL_DECL duk_double_t duk_bi_date_get_timeval_from_dparts(duk_double_t *dparts, duk_small_uint_t flags);
 DUK_INTERNAL_DECL duk_bool_t duk_bi_date_is_leap_year(duk_int_t year);
 DUK_INTERNAL_DECL duk_bool_t duk_bi_date_timeval_in_valid_range(duk_double_t x);
 DUK_INTERNAL_DECL duk_bool_t duk_bi_date_year_in_valid_range(duk_double_t year);
@@ -10706,43 +11424,43 @@
 #if defined(DUK_USE_DATE_PRS_STRPTIME)
 DUK_INTERNAL_DECL duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str);
 #endif
 #if defined(DUK_USE_DATE_PRS_GETDATE)
 DUK_INTERNAL_DECL duk_bool_t duk_bi_date_parse_string_getdate(duk_hthread *thr, const char *str);
 #endif
 #if defined(DUK_USE_DATE_FMT_STRFTIME)
-DUK_INTERNAL_DECL duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr, duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags);
+DUK_INTERNAL_DECL duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr,
+                                                               duk_int_t *parts,
+                                                               duk_int_t tzoffset,
+                                                               duk_small_uint_t flags);
 #endif
 
 #if defined(DUK_USE_GET_MONOTONIC_TIME_CLOCK_GETTIME)
 DUK_INTERNAL_DECL duk_double_t duk_bi_date_get_monotonic_time_clock_gettime(void);
 #endif
 #if defined(DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC)
 DUK_INTERNAL_DECL duk_double_t duk_bi_date_get_monotonic_time_windows_qpc(void);
 #endif
 
 DUK_INTERNAL_DECL
-void duk_bi_json_parse_helper(duk_hthread *thr,
-                              duk_idx_t idx_value,
-                              duk_idx_t idx_reviver,
-                              duk_small_uint_t flags);
+void duk_bi_json_parse_helper(duk_hthread *thr, duk_idx_t idx_value, duk_idx_t idx_reviver, duk_small_uint_t flags);
 DUK_INTERNAL_DECL
 void duk_bi_json_stringify_helper(duk_hthread *thr,
                                   duk_idx_t idx_value,
                                   duk_idx_t idx_replacer,
                                   duk_idx_t idx_space,
                                   duk_small_uint_t flags);
 
 DUK_INTERNAL_DECL duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr);
 
 #if defined(DUK_USE_ES6_PROXY)
 DUK_INTERNAL_DECL void duk_proxy_ownkeys_postprocess(duk_hthread *thr, duk_hobject *h_proxy_target, duk_uint_t flags);
 #endif
 
-#endif  /* DUK_BUILTIN_PROTOS_H_INCLUDED */
+#endif /* DUK_BUILTIN_PROTOS_H_INCLUDED */
 /* #include duk_selftest.h */
 #line 1 "duk_selftest.h"
 /*
  *  Selftest code
  */
 
 #if !defined(DUK_SELFTEST_H_INCLUDED)
@@ -10751,18 +11469,18 @@
 #if defined(DUK_USE_SELF_TESTS)
 DUK_INTERNAL_DECL duk_uint_t duk_selftest_run_tests(duk_alloc_function alloc_func,
                                                     duk_realloc_function realloc_func,
                                                     duk_free_function free_func,
                                                     void *udata);
 #endif
 
-#endif  /* DUK_SELFTEST_H_INCLUDED */
+#endif /* DUK_SELFTEST_H_INCLUDED */
 #line 76 "duk_internal.h"
 
-#endif  /* DUK_INTERNAL_H_INCLUDED */
+#endif /* DUK_INTERNAL_H_INCLUDED */
 #line 10 "duk_replacements.c"
 
 #if defined(DUK_USE_COMPUTED_NAN)
 DUK_INTERNAL double duk_computed_nan;
 #endif
 
 #if defined(DUK_USE_COMPUTED_INFINITY)
@@ -10850,15 +11568,15 @@
 #include <stdlib.h>
 #include <stdarg.h>
 
 #if !defined(DUK_USE_DEBUG_WRITE)
 #error debugging enabled (DUK_USE_DEBUG) but DUK_USE_DEBUG_WRITE not defined
 #endif
 
-#define DUK__DEBUG_BUFSIZE  DUK_USE_DEBUG_BUFSIZE
+#define DUK__DEBUG_BUFSIZE DUK_USE_DEBUG_BUFSIZE
 
 #if defined(DUK_USE_VARIADIC_MACROS)
 
 DUK_INTERNAL void duk_debug_log(duk_int_t level, const char *file, duk_int_t line, const char *func, const char *fmt, ...) {
 	va_list ap;
 	long arg_level;
 	const char *arg_file;
@@ -10878,15 +11596,15 @@
 	arg_func = (const char *) func;
 	arg_msg = (const char *) buf;
 	DUK_USE_DEBUG_WRITE(arg_level, arg_file, arg_line, arg_func, arg_msg);
 
 	va_end(ap);
 }
 
-#else  /* DUK_USE_VARIADIC_MACROS */
+#else /* DUK_USE_VARIADIC_MACROS */
 
 DUK_INTERNAL char duk_debug_file_stash[DUK_DEBUG_STASH_SIZE];
 DUK_INTERNAL duk_int_t duk_debug_line_stash;
 DUK_INTERNAL char duk_debug_func_stash[DUK_DEBUG_STASH_SIZE];
 DUK_INTERNAL duk_int_t duk_debug_level_stash;
 
 DUK_INTERNAL void duk_debug_log(const char *fmt, ...) {
@@ -10909,23 +11627,23 @@
 	arg_func = (const char *) duk_debug_func_stash;
 	arg_msg = (const char *) buf;
 	DUK_USE_DEBUG_WRITE(arg_level, arg_file, arg_line, arg_func, arg_msg);
 
 	va_end(ap);
 }
 
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
-#else  /* DUK_USE_DEBUG */
+#else /* DUK_USE_DEBUG */
 
 /*
  *  Debugging disabled
  */
 
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 /* automatic undefs */
 #undef DUK__DEBUG_BUFSIZE
 #line 1 "duk_builtins.c"
 /*
  *  Automatically generated by genbuiltins.py, do not edit!
  */
@@ -11287,15 +12005,15 @@
 82,1,38,73,79,208,67,95,233,1,6,128,14,79,129,186,40,249,18,149,182,207,
 144,200,155,188,248,204,105,184,207,142,199,137,175,201,0,159,72,10,5,21,
 221,10,120,74,129,124,36,98,232,228,74,81,62,160,20,10,107,186,21,114,32,
 105,137,194,70,46,142,68,165,19,235,1,64,170,187,161,119,34,66,146,36,104,
 137,194,70,46,142,68,165,19,236,1,64,174,187,161,95,37,134,204,23,225,35,
 23,71,34,82,137,246,128,160,89,93,208,167,147,195,201,194,70,46,142,68,165,
 19,238,1,64,182,187,161,71,105,20,19,177,139,163,145,41,68,16,7,6,15,82,70,
-72,115,96,0,0,0,0,0,15,106,32,91,60,165,195,201,194,8,134,149,216,162,0,
+72,115,96,0,0,0,0,0,27,234,32,91,60,165,195,201,194,8,134,149,216,162,0,
 192,41,225,8,2,48,177,36,1,149,13,196,15,0,200,209,97,199,128,99,32,176,
 195,192,113,57,143,0,167,133,32,230,80,28,202,139,175,238,2,48,189,192,20,
 1,119,80,87,193,186,129,89,56,72,197,209,200,193,185,35,23,71,109,13,219,
 36,98,232,237,156,13,26,208,211,14,102,19,87,137,91,95,128,0,10,96,24,92,0,
 0,83,2,53,56,0,0,165,3,28,204,160,160,226,100,226,200,211,76,241,240,0,1,
 102,8,22,75,64,137,73,20,230,105,133,7,19,39,22,70,154,103,143,128,0,11,48,
 20,28,76,156,113,75,34,78,62,0,0,45,3,103,31,0,0,22,65,44,57,137,62,33,179,
@@ -11487,15 +12205,15 @@
 82,1,38,73,79,208,67,95,233,1,6,128,14,79,129,186,40,249,18,149,182,207,
 144,200,155,188,248,204,105,184,207,142,199,137,175,201,0,159,72,10,5,21,
 221,10,120,74,129,124,36,98,232,228,74,81,62,160,20,10,107,186,21,114,32,
 105,137,194,70,46,142,68,165,19,235,1,64,170,187,161,119,34,66,146,36,104,
 137,194,70,46,142,68,165,19,236,1,64,174,187,161,95,37,134,204,23,225,35,
 23,71,34,82,137,246,128,160,89,93,208,167,147,195,201,194,70,46,142,68,165,
 19,238,1,64,182,187,161,71,105,20,19,177,139,163,145,41,68,16,7,6,15,82,70,
-72,115,96,32,106,15,0,0,0,0,0,91,60,165,195,201,194,8,134,149,216,162,0,
+72,115,96,32,106,27,128,0,0,0,0,91,60,165,195,201,194,8,134,149,216,162,0,
 192,41,225,8,2,48,177,36,1,149,13,196,15,0,200,209,97,199,128,99,32,176,
 195,192,113,57,143,0,167,133,32,230,80,28,202,139,175,238,2,48,189,192,20,
 1,119,80,87,193,186,129,89,56,72,197,209,200,193,185,35,23,71,109,13,219,
 36,98,232,237,156,13,26,208,211,14,102,19,87,137,91,95,128,0,10,96,24,92,0,
 0,83,2,53,56,0,0,165,3,28,204,160,160,226,100,226,200,211,76,241,240,0,1,
 102,8,22,75,64,137,73,20,230,105,133,7,19,39,22,70,154,103,143,128,0,11,48,
 20,28,76,156,113,75,34,78,62,0,0,45,3,103,31,0,0,22,65,44,57,137,62,33,179,
@@ -11687,15 +12405,15 @@
 82,1,38,73,79,208,67,95,233,1,6,128,14,79,129,186,40,249,18,149,182,207,
 144,200,155,188,248,204,105,184,207,142,199,137,175,201,0,159,72,10,5,21,
 221,10,120,74,129,124,36,98,232,228,74,81,62,160,20,10,107,186,21,114,32,
 105,137,194,70,46,142,68,165,19,235,1,64,170,187,161,119,34,66,146,36,104,
 137,194,70,46,142,68,165,19,236,1,64,174,187,161,95,37,134,204,23,225,35,
 23,71,34,82,137,246,128,160,89,93,208,167,147,195,201,194,70,46,142,68,165,
 19,238,1,64,182,187,161,71,105,20,19,177,139,163,145,41,68,16,7,6,15,82,70,
-72,115,96,0,15,106,32,0,0,0,0,91,60,165,195,201,194,8,134,149,216,162,0,
+72,115,96,0,27,234,32,0,0,0,0,91,60,165,195,201,194,8,134,149,216,162,0,
 192,41,225,8,2,48,177,36,1,149,13,196,15,0,200,209,97,199,128,99,32,176,
 195,192,113,57,143,0,167,133,32,230,80,28,202,139,175,238,2,48,189,192,20,
 1,119,80,87,193,186,129,89,56,72,197,209,200,193,185,35,23,71,109,13,219,
 36,98,232,237,156,13,26,208,211,14,102,19,87,137,91,95,128,0,10,96,24,92,0,
 0,83,2,53,56,0,0,165,3,28,204,160,160,226,100,226,200,211,76,241,240,0,1,
 102,8,22,75,64,137,73,20,230,105,133,7,19,39,22,70,154,103,143,128,0,11,48,
 20,28,76,156,113,75,34,78,62,0,0,45,3,103,31,0,0,22,65,44,57,137,62,33,179,
@@ -11793,54 +12511,86 @@
 #line 1 "duk_error_macros.c"
 /*
  *  Error and fatal handling.
  */
 
 /* #include duk_internal.h -> already included */
 
-#define DUK__ERRFMT_BUFSIZE  256  /* size for formatting buffers */
+#define DUK__ERRFMT_BUFSIZE 256 /* size for formatting buffers */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 
-DUK_INTERNAL DUK_COLD void duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...) {
+DUK_INTERNAL DUK_COLD void duk_err_handle_error_fmt(duk_hthread *thr,
+                                                    const char *filename,
+                                                    duk_uint_t line_and_code,
+                                                    const char *fmt,
+                                                    ...) {
 	va_list ap;
 	char msg[DUK__ERRFMT_BUFSIZE];
 	va_start(ap, fmt);
 	(void) DUK_VSNPRINTF(msg, sizeof(msg), fmt, ap);
 	msg[sizeof(msg) - 1] = (char) 0;
-	duk_err_create_and_throw(thr, (duk_errcode_t) (line_and_code >> 24), msg, filename, (duk_int_t) (line_and_code & 0x00ffffffL));
-	va_end(ap);  /* dead code, but ensures portability (see Linux man page notes) */
+	duk_err_create_and_throw(thr,
+	                         (duk_errcode_t) (line_and_code >> 24),
+	                         msg,
+	                         filename,
+	                         (duk_int_t) (line_and_code & 0x00ffffffL));
+	va_end(ap); /* dead code, but ensures portability (see Linux man page notes) */
 }
 
 DUK_INTERNAL DUK_COLD void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg) {
-	duk_err_create_and_throw(thr, (duk_errcode_t) (line_and_code >> 24), msg, filename, (duk_int_t) (line_and_code & 0x00ffffffL));
+	duk_err_create_and_throw(thr,
+	                         (duk_errcode_t) (line_and_code >> 24),
+	                         msg,
+	                         filename,
+	                         (duk_int_t) (line_and_code & 0x00ffffffL));
 }
 
-#else  /* DUK_USE_VERBOSE_ERRORS */
+#else /* DUK_USE_VERBOSE_ERRORS */
 
 DUK_INTERNAL DUK_COLD void duk_err_handle_error(duk_hthread *thr, duk_errcode_t code) {
 	duk_err_create_and_throw(thr, code);
 }
 
-#endif  /* DUK_USE_VERBOSE_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS */
 
 /*
  *  Error throwing helpers
  */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 #if defined(DUK_USE_PARANOID_ERRORS)
-DUK_INTERNAL DUK_COLD void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name) {
-	DUK_ERROR_RAW_FMT3(thr, filename, linenumber, DUK_ERR_TYPE_ERROR, "%s required, found %s (stack index %ld)",
-	                   expect_name, duk_get_type_name(thr, idx), (long) idx);
-}
-#else
-DUK_INTERNAL DUK_COLD void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name) {
-	DUK_ERROR_RAW_FMT3(thr, filename, linenumber, DUK_ERR_TYPE_ERROR, "%s required, found %s (stack index %ld)",
-	                   expect_name, duk_push_string_readable(thr, idx), (long) idx);
+DUK_INTERNAL DUK_COLD void duk_err_require_type_index(duk_hthread *thr,
+                                                      const char *filename,
+                                                      duk_int_t linenumber,
+                                                      duk_idx_t idx,
+                                                      const char *expect_name) {
+	DUK_ERROR_RAW_FMT3(thr,
+	                   filename,
+	                   linenumber,
+	                   DUK_ERR_TYPE_ERROR,
+	                   "%s required, found %s (stack index %ld)",
+	                   expect_name,
+	                   duk_get_type_name(thr, idx),
+	                   (long) idx);
+}
+#else
+DUK_INTERNAL DUK_COLD void duk_err_require_type_index(duk_hthread *thr,
+                                                      const char *filename,
+                                                      duk_int_t linenumber,
+                                                      duk_idx_t idx,
+                                                      const char *expect_name) {
+	DUK_ERROR_RAW_FMT3(thr,
+	                   filename,
+	                   linenumber,
+	                   DUK_ERR_TYPE_ERROR,
+	                   "%s required, found %s (stack index %ld)",
+	                   expect_name,
+	                   duk_push_string_readable(thr, idx),
+	                   (long) idx);
 }
 #endif
 DUK_INTERNAL DUK_COLD void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 	DUK_ERROR_RAW(thr, filename, linenumber, DUK_ERR_ERROR, DUK_STR_INTERNAL_ERROR);
 }
 DUK_INTERNAL DUK_COLD void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 	DUK_ERROR_RAW(thr, filename, linenumber, DUK_ERR_ERROR, DUK_STR_ALLOC_FAILED);
@@ -11960,22 +12710,22 @@
 
 #if defined(DUK_USE_IDCHAR_FASTPATH)
 DUK_INTERNAL const duk_int8_t duk_is_idchar_tab[128] = {
 	/* 0: not IdentifierStart or IdentifierPart
 	 * 1: IdentifierStart and IdentifierPart
 	 * -1: IdentifierPart only
 	 */
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   /* 0x00...0x0f */
-	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   /* 0x10...0x1f */
-	0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   /* 0x20...0x2f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0,  0,  0,  0,  0,  0,   /* 0x30...0x3f */
-	0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,   /* 0x40...0x4f */
-	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  1,   /* 0x50...0x5f */
-	0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,   /* 0x60...0x6f */
-	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0    /* 0x70...0x7f */
+	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, /* 0x00...0x0f */
+	0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, /* 0x10...0x1f */
+	0,  0,  0,  0,  1,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, /* 0x20...0x2f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, /* 0x30...0x3f */
+	0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 1, 1, 1, 1, 1, /* 0x40...0x4f */
+	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 0, 0, 0, 0, 1, /* 0x50...0x5f */
+	0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 1, 1, 1, 1, 1, /* 0x60...0x6f */
+	1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 0, 0, 0, 0, 0 /* 0x70...0x7f */
 };
 #endif
 
 /*
  *  XUTF-8 and CESU-8 encoding/decoding
  */
 
@@ -12017,38 +12767,36 @@
 	} else if (x < 0x10000UL) {
 		/* 16 bits */
 		return 3;
 	} else {
 		/* Encoded as surrogate pair, each encoding to 3 bytes for
 		 * 6 bytes total.  Codepoints above U+10FFFF encode as 6 bytes
 		 * too, see duk_unicode_encode_cesu8().
-		  */
+		 */
 		return 3 + 3;
 	}
 }
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
-DUK_INTERNAL const duk_uint8_t duk_unicode_xutf8_markers[7] = {
-	0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
-};
+DUK_INTERNAL const duk_uint8_t duk_unicode_xutf8_markers[7] = { 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };
 
 /* Encode to extended UTF-8; 'out' must have space for at least
  * DUK_UNICODE_MAX_XUTF8_LENGTH bytes.  Allows encoding of any
  * 32-bit (unsigned) codepoint.
  */
 DUK_INTERNAL duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out) {
 	duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 	duk_small_int_t len;
 	duk_uint8_t marker;
 	duk_small_int_t i;
 
 	len = duk_unicode_get_xutf8_length(cp);
 	DUK_ASSERT(len > 0);
 
-	marker = duk_unicode_xutf8_markers[len - 1];  /* 64-bit OK because always >= 0 */
+	marker = duk_unicode_xutf8_markers[len - 1]; /* 64-bit OK because always >= 0 */
 
 	i = len;
 	DUK_ASSERT(i > 0);
 	do {
 		i--;
 		if (i > 0) {
 			out[i] = (duk_uint8_t) (0x80 + (x & 0x3f));
@@ -12125,15 +12873,19 @@
 		len = 6;
 	}
 
 	return len;
 }
 
 /* Decode helper.  Return zero on error. */
-DUK_INTERNAL duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_ucodepoint_t *out_cp) {
+DUK_INTERNAL duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr,
+                                                      const duk_uint8_t **ptr,
+                                                      const duk_uint8_t *ptr_start,
+                                                      const duk_uint8_t *ptr_end,
+                                                      duk_ucodepoint_t *out_cp) {
 	const duk_uint8_t *p;
 	duk_uint32_t res;
 	duk_uint_fast8_t ch;
 	duk_small_int_t n;
 
 	DUK_UNREF(thr);
 
@@ -12187,15 +12939,15 @@
 		 * leading one bits and would not allow 0xFF to be used as an
 		 * "invalid xutf-8" marker for internal keys.  Further, 8-byte
 		 * encodings (up to 41 bit code points) are not currently needed.
 		 */
 		goto fail;
 	}
 
-	DUK_ASSERT(p >= ptr_start);  /* verified at beginning */
+	DUK_ASSERT(p >= ptr_start); /* verified at beginning */
 	if (p + n > ptr_end) {
 		/* check pointer at end */
 		goto fail;
 	}
 
 	while (n > 0) {
 		DUK_ASSERT(p >= ptr_start && p < ptr_end);
@@ -12213,20 +12965,23 @@
 		n--;
 	}
 
 	*ptr = p;
 	*out_cp = res;
 	return 1;
 
- fail:
+fail:
 	return 0;
 }
 
 /* used by e.g. duk_regexp_executor.c, string built-ins */
-DUK_INTERNAL duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end) {
+DUK_INTERNAL duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr,
+                                                               const duk_uint8_t **ptr,
+                                                               const duk_uint8_t *ptr_start,
+                                                               const duk_uint8_t *ptr_end) {
 	duk_ucodepoint_t cp;
 
 	if (duk_unicode_decode_xutf8(thr, ptr, ptr_start, ptr_end, &cp)) {
 		return cp;
 	}
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return 0;);
@@ -12265,27 +13020,27 @@
 	}
 
 	DUK_ASSERT(ncont <= blen);
 	clen = blen - ncont;
 	DUK_ASSERT(clen <= blen);
 	return clen;
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 /* This seems like a good overall approach.  Fast path for ASCII in 4 byte
  * blocks.
  */
 DUK_INTERNAL duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen) {
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_end;
 	const duk_uint32_t *p32_end;
 	const duk_uint32_t *p32;
 	duk_size_t ncont;
 	duk_size_t clen;
 
-	ncont = 0;  /* number of continuation (non-initial) bytes in [0x80,0xbf] */
+	ncont = 0; /* number of continuation (non-initial) bytes in [0x80,0xbf] */
 	p = data;
 	p_end = data + blen;
 	if (blen < 16) {
 		goto skip_fastpath;
 	}
 
 	/* Align 'p' to 4; the input data may have arbitrary alignment.
@@ -12302,15 +13057,15 @@
 	/* Full, aligned 4-byte reads. */
 	p32_end = (const duk_uint32_t *) (const void *) (p + ((duk_size_t) (p_end - p) & (duk_size_t) (~0x03)));
 	p32 = (const duk_uint32_t *) (const void *) p;
 	while (p32 != (const duk_uint32_t *) p32_end) {
 		duk_uint32_t x;
 		x = *p32++;
 		if (DUK_LIKELY((x & 0x80808080UL) == 0)) {
-			;  /* ASCII fast path */
+			; /* ASCII fast path */
 		} else {
 			/* Flip highest bit of each byte which changes
 			 * the bit pattern 10xxxxxx into 00xxxxxx which
 			 * allows an easy bit mask test.
 			 */
 			x ^= 0x80808080UL;
 			if (DUK_UNLIKELY(!(x & 0xc0000000UL))) {
@@ -12326,29 +13081,29 @@
 				ncont++;
 			}
 		}
 	}
 	p = (const duk_uint8_t *) p32;
 	/* Fall through to handle the rest. */
 
- skip_fastpath:
+skip_fastpath:
 	while (p != p_end) {
 		duk_uint8_t x;
 		x = *p++;
 		if (DUK_UNLIKELY(x >= 0x80 && x <= 0xbf)) {
 			ncont++;
 		}
 	}
 
 	DUK_ASSERT(ncont <= blen);
 	clen = blen - ncont;
 	DUK_ASSERT(clen <= blen);
 	return clen;
 }
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 /* Check whether a string is UTF-8 compatible or not. */
 DUK_INTERNAL duk_bool_t duk_unicode_is_utf8_compatible(const duk_uint8_t *buf, duk_size_t len) {
 	duk_size_t i = 0;
 #if !defined(DUK_USE_PREFER_SIZE)
 	duk_size_t len_safe;
 #endif
@@ -12389,38 +13144,38 @@
 		 *
 		 * 10xx xxxx          -> continuation byte
 		 * 110x xxxx + 1*CONT -> [0x80, 0x7ff]
 		 * 1110 xxxx + 2*CONT -> [0x800, 0xffff], must reject [0xd800,0xdfff]
 		 * 1111 0xxx + 3*CONT -> [0x10000, 0x10ffff]
 		 */
 		left = len - i;
-		if (t <= 0xdfU) {  /* 1101 1111 = 0xdf */
-			if (t <= 0xbfU) {  /* 1011 1111 = 0xbf */
+		if (t <= 0xdfU) { /* 1101 1111 = 0xdf */
+			if (t <= 0xbfU) { /* 1011 1111 = 0xbf */
 				return 0;
 			}
 			ncont = 1;
 			mincp = 0x80UL;
 			cp = t & 0x1fU;
-		} else if (t <= 0xefU) {  /* 1110 1111 = 0xef */
+		} else if (t <= 0xefU) { /* 1110 1111 = 0xef */
 			ncont = 2;
 			mincp = 0x800UL;
 			cp = t & 0x0fU;
-		} else if (t <= 0xf7U) {  /* 1111 0111 = 0xf7 */
+		} else if (t <= 0xf7U) { /* 1111 0111 = 0xf7 */
 			ncont = 3;
 			mincp = 0x10000UL;
 			cp = t & 0x07U;
 		} else {
 			return 0;
 		}
 		if (left < ncont) {
 			return 0;
 		}
 		while (ncont > 0U) {
 			t = buf[i++];
-			if ((t & 0xc0U) != 0x80U) {  /* 10xx xxxx */
+			if ((t & 0xc0U) != 0x80U) { /* 10xx xxxx */
 				return 0;
 			}
 			cp = (cp << 6) + (t & 0x3fU);
 			ncont--;
 		}
 		if (cp < mincp || cp > 0x10ffffUL || (cp >= 0xd800UL && cp <= 0xdfffUL)) {
 			return 0;
@@ -12478,15 +13233,17 @@
 		r1 = prev_re + r1;
 		r2 = r1 + r2;
 		prev_re = r2;
 
 		/* [r1,r2] is the range */
 
 		DUK_DDD(DUK_DDDPRINT("duk__uni_range_match: cp=%06lx range=[0x%06lx,0x%06lx]",
-		                     (unsigned long) cp, (unsigned long) r1, (unsigned long) r2));
+		                     (unsigned long) cp,
+		                     (unsigned long) r1,
+		                     (unsigned long) r2));
 		if (cp >= r1 && cp <= r2) {
 			return 1;
 		}
 	}
 
 	return 0;
 }
@@ -12548,27 +13305,25 @@
 
 	duk_uint_fast8_t lo;
 	duk_uint_fast32_t hi;
 
 	/* cp == -1 (EOF) never matches and causes return value 0 */
 
 	lo = (duk_uint_fast8_t) (cp & 0xff);
-	hi = (duk_uint_fast32_t) (cp >> 8);  /* does not fit into an uchar */
+	hi = (duk_uint_fast32_t) (cp >> 8); /* does not fit into an uchar */
 
 	if (hi == 0x0000UL) {
-		if (lo == 0x09U || lo == 0x0bU || lo == 0x0cU ||
-		    lo == 0x20U || lo == 0xa0U) {
+		if (lo == 0x09U || lo == 0x0bU || lo == 0x0cU || lo == 0x20U || lo == 0xa0U) {
 			return 1;
 		}
 	} else if (hi == 0x0020UL) {
 		if (lo <= 0x0aU || lo == 0x2fU || lo == 0x5fU) {
 			return 1;
 		}
-	} else if (cp == 0x1680L || cp == 0x180eL || cp == 0x3000L ||
-	           cp == 0xfeffL) {
+	} else if (cp == 0x1680L || cp == 0x180eL || cp == 0x3000L || cp == 0xfeffL) {
 		return 1;
 	}
 
 	return 0;
 }
 
 /*
@@ -12579,16 +13334,15 @@
 	/*
 	 *  E5 Section 7.3
 	 *
 	 *  A LineTerminatorSequence essentially merges <CR> <LF> sequences
 	 *  into a single line terminator.  This must be handled by the caller.
 	 */
 
-	if (cp == 0x000aL || cp == 0x000dL || cp == 0x2028L ||
-	    cp == 0x2029L) {
+	if (cp == 0x000aL || cp == 0x000dL || cp == 0x2028L || cp == 0x2029L) {
 		return 1;
 	}
 
 	return 0;
 }
 
 /*
@@ -12631,37 +13385,31 @@
 	 */
 
 	/* ASCII (and EOF) fast path -- quick accept and reject */
 	if (cp <= 0x7fL) {
 #if defined(DUK_USE_IDCHAR_FASTPATH)
 		return (cp >= 0) && (duk_is_idchar_tab[cp] > 0);
 #else
-		if ((cp >= 'a' && cp <= 'z') ||
-		    (cp >= 'A' && cp <= 'Z') ||
-		    cp == '_' || cp == '$') {
+		if ((cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z') || cp == '_' || cp == '$') {
 			return 1;
 		}
 		return 0;
 #endif
 	}
 
 	/* Non-ASCII slow path (range-by-range linear comparison), very slow */
 
 #if defined(DUK_USE_SOURCE_NONBMP)
-	if (duk__uni_range_match(duk_unicode_ids_noa,
-	                         (duk_size_t) sizeof(duk_unicode_ids_noa),
-	                         (duk_codepoint_t) cp)) {
+	if (duk__uni_range_match(duk_unicode_ids_noa, (duk_size_t) sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp)) {
 		return 1;
 	}
 	return 0;
 #else
 	if (cp < 0x10000L) {
-		if (duk__uni_range_match(duk_unicode_ids_noabmp,
-		                         sizeof(duk_unicode_ids_noabmp),
-		                         (duk_codepoint_t) cp)) {
+		if (duk__uni_range_match(duk_unicode_ids_noabmp, sizeof(duk_unicode_ids_noabmp), (duk_codepoint_t) cp)) {
 			return 1;
 		}
 		return 0;
 	} else {
 		/* without explicit non-BMP support, assume non-BMP characters
 		 * are always accepted as identifier characters.
 		 */
@@ -12720,41 +13468,32 @@
 	 */
 
 	/* ASCII (and EOF) fast path -- quick accept and reject */
 	if (cp <= 0x7fL) {
 #if defined(DUK_USE_IDCHAR_FASTPATH)
 		return (cp >= 0) && (duk_is_idchar_tab[cp] != 0);
 #else
-		if ((cp >= 'a' && cp <= 'z') ||
-		    (cp >= 'A' && cp <= 'Z') ||
-		    (cp >= '0' && cp <= '9') ||
-		    cp == '_' || cp == '$') {
+		if ((cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z') || (cp >= '0' && cp <= '9') || cp == '_' || cp == '$') {
 			return 1;
 		}
 		return 0;
 #endif
 	}
 
 	/* Non-ASCII slow path (range-by-range linear comparison), very slow */
 
 #if defined(DUK_USE_SOURCE_NONBMP)
-	if (duk__uni_range_match(duk_unicode_ids_noa,
-	                         sizeof(duk_unicode_ids_noa),
-	                         (duk_codepoint_t) cp) ||
-	    duk__uni_range_match(duk_unicode_idp_m_ids_noa,
-	                         sizeof(duk_unicode_idp_m_ids_noa),
-	                         (duk_codepoint_t) cp)) {
+	if (duk__uni_range_match(duk_unicode_ids_noa, sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp) ||
+	    duk__uni_range_match(duk_unicode_idp_m_ids_noa, sizeof(duk_unicode_idp_m_ids_noa), (duk_codepoint_t) cp)) {
 		return 1;
 	}
 	return 0;
 #else
 	if (cp < 0x10000L) {
-		if (duk__uni_range_match(duk_unicode_ids_noabmp,
-		                         sizeof(duk_unicode_ids_noabmp),
-		                         (duk_codepoint_t) cp) ||
+		if (duk__uni_range_match(duk_unicode_ids_noabmp, sizeof(duk_unicode_ids_noabmp), (duk_codepoint_t) cp) ||
 		    duk__uni_range_match(duk_unicode_idp_m_ids_noabmp,
 		                         sizeof(duk_unicode_idp_m_ids_noabmp),
 		                         (duk_codepoint_t) cp)) {
 			return 1;
 		}
 		return 0;
 	} else {
@@ -12782,38 +13521,31 @@
 	 *
 	 *    0x0041 ... 0x005a     ['A' ... 'Z']
 	 *    0x0061 ... 0x007a     ['a' ... 'z']
 	 */
 
 	/* ASCII (and EOF) fast path -- quick accept and reject */
 	if (cp <= 0x7fL) {
-		if ((cp >= 'a' && cp <= 'z') ||
-		    (cp >= 'A' && cp <= 'Z')) {
+		if ((cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z')) {
 			return 1;
 		}
 		return 0;
 	}
 
 	/* Non-ASCII slow path (range-by-range linear comparison), very slow */
 
 #if defined(DUK_USE_SOURCE_NONBMP)
-	if (duk__uni_range_match(duk_unicode_ids_noa,
-	                         sizeof(duk_unicode_ids_noa),
-	                         (duk_codepoint_t) cp) &&
-	    !duk__uni_range_match(duk_unicode_ids_m_let_noa,
-	                          sizeof(duk_unicode_ids_m_let_noa),
-	                          (duk_codepoint_t) cp)) {
+	if (duk__uni_range_match(duk_unicode_ids_noa, sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp) &&
+	    !duk__uni_range_match(duk_unicode_ids_m_let_noa, sizeof(duk_unicode_ids_m_let_noa), (duk_codepoint_t) cp)) {
 		return 1;
 	}
 	return 0;
 #else
 	if (cp < 0x10000L) {
-		if (duk__uni_range_match(duk_unicode_ids_noabmp,
-		                         sizeof(duk_unicode_ids_noabmp),
-		                         (duk_codepoint_t) cp) &&
+		if (duk__uni_range_match(duk_unicode_ids_noabmp, sizeof(duk_unicode_ids_noabmp), (duk_codepoint_t) cp) &&
 		    !duk__uni_range_match(duk_unicode_ids_m_let_noabmp,
 		                          sizeof(duk_unicode_ids_m_let_noabmp),
 		                          (duk_codepoint_t) cp)) {
 			return 1;
 		}
 		return 0;
 	} else {
@@ -12842,18 +13574,15 @@
  *  appended to the hbuffer.
  *
  *  Context and locale specific rules must be checked before consulting
  *  this function.
  */
 
 DUK_LOCAL
-duk_codepoint_t duk__slow_case_conversion(duk_hthread *thr,
-                                          duk_bufwriter_ctx *bw,
-                                          duk_codepoint_t cp,
-                                          duk_bitdecoder_ctx *bd_ctx) {
+duk_codepoint_t duk__slow_case_conversion(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_codepoint_t cp, duk_bitdecoder_ctx *bd_ctx) {
 	duk_small_int_t skip = 0;
 	duk_small_int_t n;
 	duk_small_int_t t;
 	duk_small_int_t count;
 	duk_codepoint_t tmp_cp;
 	duk_codepoint_t start_i;
 	duk_codepoint_t start_o;
@@ -12875,18 +13604,21 @@
 		DUK_DDD(DUK_DDDPRINT("skip=%ld, n=%ld", (long) skip, (long) n));
 
 		while (n--) {
 			start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
 			start_o = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
 			count = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
 			DUK_DDD(DUK_DDDPRINT("range: start_i=%ld, start_o=%ld, count=%ld, skip=%ld",
-			                     (long) start_i, (long) start_o, (long) count, (long) skip));
+			                     (long) start_i,
+			                     (long) start_o,
+			                     (long) count,
+			                     (long) skip));
 
 			if (cp >= start_i) {
-				tmp_cp = cp - start_i;  /* always >= 0 */
+				tmp_cp = cp - start_i; /* always >= 0 */
 				if (tmp_cp < (duk_codepoint_t) count * (duk_codepoint_t) skip &&
 				    (tmp_cp % (duk_codepoint_t) skip) == 0) {
 					DUK_DDD(DUK_DDDPRINT("range matches input codepoint"));
 					cp = start_o + tmp_cp;
 					goto single;
 				}
 			}
@@ -12930,15 +13662,15 @@
 		}
 	}
 
 	/* default: no change */
 	DUK_DDD(DUK_DDDPRINT("no rule matches, output is same as input"));
 	/* fall through */
 
- single:
+single:
 	if (bw != NULL) {
 		DUK_BW_WRITE_RAW_XUTF8(thr, bw, (duk_ucodepoint_t) cp);
 	}
 	return cp;
 }
 
 /*
@@ -12992,17 +13724,17 @@
 	} else {
 		/*
 		 *  Final sigma context specific rule.  This is a rather tricky
 		 *  rule and this handling is probably not 100% correct now.
 		 *  The rule is not locale/language specific so it is supported.
 		 */
 
-		if (cp == 0x03a3L &&    /* U+03A3 = GREEK CAPITAL LETTER SIGMA */
-		    duk_unicode_is_letter(prev) &&        /* prev exists and is not a letter */
-		    !duk_unicode_is_letter(next)) {       /* next does not exist or next is not a letter */
+		if (cp == 0x03a3L && /* U+03A3 = GREEK CAPITAL LETTER SIGMA */
+		    duk_unicode_is_letter(prev) && /* prev exists and is not a letter */
+		    !duk_unicode_is_letter(next)) { /* next does not exist or next is not a letter */
 			/* Capital sigma occurred at "end of word", lowercase to
 			 * U+03C2 = GREEK SMALL LETTER FINAL SIGMA.  Otherwise
 			 * fall through and let the normal rules lowercase it to
 			 * U+03C3 = GREEK SMALL LETTER SIGMA.
 			 */
 			cp = 0x03c2L;
 			goto singlechar;
@@ -13020,21 +13752,21 @@
 		bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_uc);
 	} else {
 		bd_ctx.data = (const duk_uint8_t *) duk_unicode_caseconv_lc;
 		bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_lc);
 	}
 	return duk__slow_case_conversion(thr, bw, cp, &bd_ctx);
 
- singlechar:
+singlechar:
 	if (bw != NULL) {
 		DUK_BW_WRITE_RAW_XUTF8(thr, bw, (duk_ucodepoint_t) cp);
 	}
 	return cp;
 
- /* unused now, not needed until Turkish/Azeri */
+	/* unused now, not needed until Turkish/Azeri */
 #if 0
  nochar:
 	return -1;
 #endif
 }
 
 /*
@@ -13044,27 +13776,28 @@
 DUK_INTERNAL void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase) {
 	duk_hstring *h_input;
 	duk_bufwriter_ctx bw_alloc;
 	duk_bufwriter_ctx *bw;
 	const duk_uint8_t *p, *p_start, *p_end;
 	duk_codepoint_t prev, curr, next;
 
-	h_input = duk_require_hstring(thr, -1);  /* Accept symbols. */
+	h_input = duk_require_hstring(thr, -1); /* Accept symbols. */
 	DUK_ASSERT(h_input != NULL);
 
 	bw = &bw_alloc;
 	DUK_BW_INIT_PUSHBUF(thr, bw, DUK_HSTRING_GET_BYTELEN(h_input));
 
 	/* [ ... input buffer ] */
 
 	p_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_input);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_input);
 	p = p_start;
 
-	prev = -1; DUK_UNREF(prev);
+	prev = -1;
+	DUK_UNREF(prev);
 	curr = -1;
 	next = -1;
 	for (;;) {
 		prev = curr;
 		curr = next;
 		next = -1;
 		if (p < p_end) {
@@ -13081,25 +13814,20 @@
 			/* XXX: could add a fast path to process chunks of input codepoints,
 			 * but relative benefit would be quite small.
 			 */
 
 			/* Ensure space for maximum multi-character result; estimate is overkill. */
 			DUK_BW_ENSURE(thr, bw, 8 * DUK_UNICODE_MAX_XUTF8_LENGTH);
 
-			duk__case_transform_helper(thr,
-			                           bw,
-			                           (duk_codepoint_t) curr,
-			                           prev,
-			                           next,
-			                           uppercase);
+			duk__case_transform_helper(thr, bw, (duk_codepoint_t) curr, prev, next, uppercase);
 		}
 	}
 
 	DUK_BW_COMPACT(thr, bw);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe, output is encoded. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe, output is encoded. */
 	/* invalidates h_buf pointer */
 	duk_remove_m2(thr);
 }
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 
 /*
@@ -13114,108 +13842,90 @@
 	/* Fast canonicalization lookup at the cost of 128kB footprint. */
 	DUK_ASSERT(cp >= 0);
 	DUK_UNREF(thr);
 	if (DUK_LIKELY(cp < 0x10000L)) {
 		return (duk_codepoint_t) duk_unicode_re_canon_lookup[cp];
 	}
 	return cp;
-#else  /* DUK_USE_REGEXP_CANON_WORKAROUND */
+#else /* DUK_USE_REGEXP_CANON_WORKAROUND */
 	duk_codepoint_t y;
 
 	y = duk__case_transform_helper(thr,
-	                               NULL,    /* NULL is allowed, no output */
-	                               cp,      /* curr char */
-	                               -1,      /* prev char */
-	                               -1,      /* next char */
-	                               1);      /* uppercase */
+	                               NULL, /* NULL is allowed, no output */
+	                               cp, /* curr char */
+	                               -1, /* prev char */
+	                               -1, /* next char */
+	                               1); /* uppercase */
 
 	if ((y < 0) || (cp >= 0x80 && y < 0x80)) {
 		/* multiple codepoint conversion or non-ASCII mapped to ASCII
 		 * --> leave as is.
 		 */
 		return cp;
 	}
 
 	return y;
-#endif  /* DUK_USE_REGEXP_CANON_WORKAROUND */
+#endif /* DUK_USE_REGEXP_CANON_WORKAROUND */
 }
 
 /*
  *  E5 Section 15.10.2.6 "IsWordChar" abstract operation.  Assume
  *  x < 0 for characters read outside the string.
  */
 
 DUK_INTERNAL duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t x) {
 	/*
 	 *  Note: the description in E5 Section 15.10.2.6 has a typo, it
 	 *  contains 'A' twice and lacks 'a'; the intent is [0-9a-zA-Z_].
 	 */
-	if ((x >= '0' && x <= '9') ||
-	    (x >= 'a' && x <= 'z') ||
-	    (x >= 'A' && x <= 'Z') ||
-	    (x == '_')) {
+	if ((x >= '0' && x <= '9') || (x >= 'a' && x <= 'z') || (x >= 'A' && x <= 'Z') || (x == '_')) {
 		return 1;
 	}
 	return 0;
 }
 
 /*
  *  Regexp range tables
  */
 
 /* exposed because lexer needs these too */
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_digit[2] = {
-	(duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL,
+	(duk_uint16_t) 0x0030UL,
+	(duk_uint16_t) 0x0039UL,
 };
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_white[22] = {
-	(duk_uint16_t) 0x0009UL, (duk_uint16_t) 0x000DUL,
-	(duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x0020UL,
-	(duk_uint16_t) 0x00A0UL, (duk_uint16_t) 0x00A0UL,
-	(duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x1680UL,
-	(duk_uint16_t) 0x180EUL, (duk_uint16_t) 0x180EUL,
-	(duk_uint16_t) 0x2000UL, (duk_uint16_t) 0x200AUL,
-	(duk_uint16_t) 0x2028UL, (duk_uint16_t) 0x2029UL,
-	(duk_uint16_t) 0x202FUL, (duk_uint16_t) 0x202FUL,
-	(duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x205FUL,
-	(duk_uint16_t) 0x3000UL, (duk_uint16_t) 0x3000UL,
+	(duk_uint16_t) 0x0009UL, (duk_uint16_t) 0x000DUL, (duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x00A0UL,
+	(duk_uint16_t) 0x00A0UL, (duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x180EUL, (duk_uint16_t) 0x180EUL,
+	(duk_uint16_t) 0x2000UL, (duk_uint16_t) 0x200AUL, (duk_uint16_t) 0x2028UL, (duk_uint16_t) 0x2029UL, (duk_uint16_t) 0x202FUL,
+	(duk_uint16_t) 0x202FUL, (duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x3000UL, (duk_uint16_t) 0x3000UL,
 	(duk_uint16_t) 0xFEFFUL, (duk_uint16_t) 0xFEFFUL,
 };
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_wordchar[8] = {
-	(duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL,
-	(duk_uint16_t) 0x0041UL, (duk_uint16_t) 0x005AUL,
-	(duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x005FUL,
-	(duk_uint16_t) 0x0061UL, (duk_uint16_t) 0x007AUL,
+	(duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL, (duk_uint16_t) 0x0041UL, (duk_uint16_t) 0x005AUL,
+	(duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x0061UL, (duk_uint16_t) 0x007AUL,
 };
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_not_digit[4] = {
-	(duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL,
-	(duk_uint16_t) 0x003AUL, (duk_uint16_t) 0xFFFFUL,
+	(duk_uint16_t) 0x0000UL,
+	(duk_uint16_t) 0x002FUL,
+	(duk_uint16_t) 0x003AUL,
+	(duk_uint16_t) 0xFFFFUL,
 };
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_not_white[24] = {
-	(duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x0008UL,
-	(duk_uint16_t) 0x000EUL, (duk_uint16_t) 0x001FUL,
-	(duk_uint16_t) 0x0021UL, (duk_uint16_t) 0x009FUL,
-	(duk_uint16_t) 0x00A1UL, (duk_uint16_t) 0x167FUL,
-	(duk_uint16_t) 0x1681UL, (duk_uint16_t) 0x180DUL,
-	(duk_uint16_t) 0x180FUL, (duk_uint16_t) 0x1FFFUL,
-	(duk_uint16_t) 0x200BUL, (duk_uint16_t) 0x2027UL,
-	(duk_uint16_t) 0x202AUL, (duk_uint16_t) 0x202EUL,
-	(duk_uint16_t) 0x2030UL, (duk_uint16_t) 0x205EUL,
-	(duk_uint16_t) 0x2060UL, (duk_uint16_t) 0x2FFFUL,
-	(duk_uint16_t) 0x3001UL, (duk_uint16_t) 0xFEFEUL,
-	(duk_uint16_t) 0xFF00UL, (duk_uint16_t) 0xFFFFUL,
+	(duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x0008UL, (duk_uint16_t) 0x000EUL, (duk_uint16_t) 0x001FUL, (duk_uint16_t) 0x0021UL,
+	(duk_uint16_t) 0x009FUL, (duk_uint16_t) 0x00A1UL, (duk_uint16_t) 0x167FUL, (duk_uint16_t) 0x1681UL, (duk_uint16_t) 0x180DUL,
+	(duk_uint16_t) 0x180FUL, (duk_uint16_t) 0x1FFFUL, (duk_uint16_t) 0x200BUL, (duk_uint16_t) 0x2027UL, (duk_uint16_t) 0x202AUL,
+	(duk_uint16_t) 0x202EUL, (duk_uint16_t) 0x2030UL, (duk_uint16_t) 0x205EUL, (duk_uint16_t) 0x2060UL, (duk_uint16_t) 0x2FFFUL,
+	(duk_uint16_t) 0x3001UL, (duk_uint16_t) 0xFEFEUL, (duk_uint16_t) 0xFF00UL, (duk_uint16_t) 0xFFFFUL,
 };
 DUK_INTERNAL const duk_uint16_t duk_unicode_re_ranges_not_wordchar[10] = {
-	(duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL,
-	(duk_uint16_t) 0x003AUL, (duk_uint16_t) 0x0040UL,
-	(duk_uint16_t) 0x005BUL, (duk_uint16_t) 0x005EUL,
-	(duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x0060UL,
-	(duk_uint16_t) 0x007BUL, (duk_uint16_t) 0xFFFFUL,
+	(duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL, (duk_uint16_t) 0x003AUL, (duk_uint16_t) 0x0040UL, (duk_uint16_t) 0x005BUL,
+	(duk_uint16_t) 0x005EUL, (duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x007BUL, (duk_uint16_t) 0xFFFFUL,
 };
 
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 #line 1 "duk_util_memrw.c"
 /*
  *  Macro support functions for reading/writing raw data.
  *
  *  These are done using memcpy to ensure they're valid even for unaligned
  *  reads/writes on platforms where alignment counts.  On x86 at least gcc
  *  is able to compile these into a bswap+mov.  "Always inline" is used to
@@ -13370,75 +14080,69 @@
 
 /*
  *  Lowercase digits for radix values 2 to 36.  Also doubles as lowercase
  *  hex nybble table.
  */
 
 DUK_INTERNAL const duk_uint8_t duk_lc_digits[36] = {
-	DUK_ASC_0, DUK_ASC_1, DUK_ASC_2, DUK_ASC_3,
-	DUK_ASC_4, DUK_ASC_5, DUK_ASC_6, DUK_ASC_7,
-	DUK_ASC_8, DUK_ASC_9, DUK_ASC_LC_A, DUK_ASC_LC_B,
-	DUK_ASC_LC_C, DUK_ASC_LC_D, DUK_ASC_LC_E, DUK_ASC_LC_F,
-	DUK_ASC_LC_G, DUK_ASC_LC_H, DUK_ASC_LC_I, DUK_ASC_LC_J,
-	DUK_ASC_LC_K, DUK_ASC_LC_L, DUK_ASC_LC_M, DUK_ASC_LC_N,
-	DUK_ASC_LC_O, DUK_ASC_LC_P, DUK_ASC_LC_Q, DUK_ASC_LC_R,
-	DUK_ASC_LC_S, DUK_ASC_LC_T, DUK_ASC_LC_U, DUK_ASC_LC_V,
+	DUK_ASC_0,    DUK_ASC_1,    DUK_ASC_2,    DUK_ASC_3,    DUK_ASC_4,    DUK_ASC_5,    DUK_ASC_6,    DUK_ASC_7,
+	DUK_ASC_8,    DUK_ASC_9,    DUK_ASC_LC_A, DUK_ASC_LC_B, DUK_ASC_LC_C, DUK_ASC_LC_D, DUK_ASC_LC_E, DUK_ASC_LC_F,
+	DUK_ASC_LC_G, DUK_ASC_LC_H, DUK_ASC_LC_I, DUK_ASC_LC_J, DUK_ASC_LC_K, DUK_ASC_LC_L, DUK_ASC_LC_M, DUK_ASC_LC_N,
+	DUK_ASC_LC_O, DUK_ASC_LC_P, DUK_ASC_LC_Q, DUK_ASC_LC_R, DUK_ASC_LC_S, DUK_ASC_LC_T, DUK_ASC_LC_U, DUK_ASC_LC_V,
 	DUK_ASC_LC_W, DUK_ASC_LC_X, DUK_ASC_LC_Y, DUK_ASC_LC_Z
 };
 
-DUK_INTERNAL const duk_uint8_t duk_uc_nybbles[16] = {
-	DUK_ASC_0, DUK_ASC_1, DUK_ASC_2, DUK_ASC_3,
-	DUK_ASC_4, DUK_ASC_5, DUK_ASC_6, DUK_ASC_7,
-	DUK_ASC_8, DUK_ASC_9, DUK_ASC_UC_A, DUK_ASC_UC_B,
-	DUK_ASC_UC_C, DUK_ASC_UC_D, DUK_ASC_UC_E, DUK_ASC_UC_F
-};
+DUK_INTERNAL const duk_uint8_t duk_uc_nybbles[16] = { DUK_ASC_0,    DUK_ASC_1,    DUK_ASC_2,    DUK_ASC_3,
+	                                              DUK_ASC_4,    DUK_ASC_5,    DUK_ASC_6,    DUK_ASC_7,
+	                                              DUK_ASC_8,    DUK_ASC_9,    DUK_ASC_UC_A, DUK_ASC_UC_B,
+	                                              DUK_ASC_UC_C, DUK_ASC_UC_D, DUK_ASC_UC_E, DUK_ASC_UC_F };
 
 /*
  *  Table for hex decoding ASCII hex digits
  */
 
 DUK_INTERNAL const duk_int8_t duk_hex_dectab[256] = {
 	/* -1 if invalid */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x00-0x0f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x10-0x1f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x20-0x2f */
-	 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,  /* 0x30-0x3f */
-	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x40-0x4f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x50-0x5f */
-	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x60-0x6f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x70-0x7f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x80-0x8f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0x90-0x9f */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0xa0-0xaf */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0xb0-0xbf */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0xc0-0xcf */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0xd0-0xdf */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  /* 0xe0-0xef */
-	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1   /* 0xf0-0xff */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x00-0x0f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x10-0x1f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x20-0x2f */
+	0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  -1, -1, -1, -1, -1, -1, /* 0x30-0x3f */
+	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x40-0x4f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x50-0x5f */
+	-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x60-0x6f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x70-0x7f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x80-0x8f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0x90-0x9f */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xa0-0xaf */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xb0-0xbf */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xc0-0xcf */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xd0-0xdf */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, /* 0xe0-0xef */
+	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 /* 0xf0-0xff */
 };
 
 #if defined(DUK_USE_HEX_FASTPATH)
 /* Preshifted << 4.  Must use 16-bit entry to allow negative value signaling. */
 DUK_INTERNAL const duk_int16_t duk_hex_dectab_shift4[256] = {
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x00-0x0f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x10-0x1f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x20-0x2f */
-	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x30-0x3f */
-	  -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x40-0x4f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x50-0x5f */
-	  -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x60-0x6f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x70-0x7f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x80-0x8f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0x90-0x9f */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0xa0-0xaf */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0xb0-0xbf */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0xc0-0xcf */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0xd0-0xdf */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  /* 0xe0-0xef */
-	  -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1   /* 0xf0-0xff */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x00-0x0f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x10-0x1f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x20-0x2f */
+	0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, -1, -1, -1, -1, -1, -1, /* 0x30-0x3f */
+	-1,   0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x40-0x4f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x50-0x5f */
+	-1,   0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x60-0x6f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x70-0x7f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x80-0x8f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0x90-0x9f */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0xa0-0xaf */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0xb0-0xbf */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0xc0-0xcf */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0xd0-0xdf */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1, /* 0xe0-0xef */
+	-1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1, -1, -1, -1, -1, -1 /* 0xf0-0xff */
 };
 #endif
 
 /*
  *  Table for hex encoding bytes
  */
 
@@ -13449,106 +14153,94 @@
  *       for i in xrange(256):
  *           t = chr(i).encode('hex')
  *           if bswap:
  *               t = t[1] + t[0]
  *           print('0x' + t.encode('hex') + 'U')
  *   print('big endian'); genhextab(False)
  *   print('little endian'); genhextab(True)
-*/
+ */
 DUK_INTERNAL const duk_uint16_t duk_hex_enctab[256] = {
 #if defined(DUK_USE_INTEGER_BE)
-	0x3030U, 0x3031U, 0x3032U, 0x3033U, 0x3034U, 0x3035U, 0x3036U, 0x3037U,
-	0x3038U, 0x3039U, 0x3061U, 0x3062U, 0x3063U, 0x3064U, 0x3065U, 0x3066U,
-	0x3130U, 0x3131U, 0x3132U, 0x3133U, 0x3134U, 0x3135U, 0x3136U, 0x3137U,
-	0x3138U, 0x3139U, 0x3161U, 0x3162U, 0x3163U, 0x3164U, 0x3165U, 0x3166U,
-	0x3230U, 0x3231U, 0x3232U, 0x3233U, 0x3234U, 0x3235U, 0x3236U, 0x3237U,
-	0x3238U, 0x3239U, 0x3261U, 0x3262U, 0x3263U, 0x3264U, 0x3265U, 0x3266U,
-	0x3330U, 0x3331U, 0x3332U, 0x3333U, 0x3334U, 0x3335U, 0x3336U, 0x3337U,
-	0x3338U, 0x3339U, 0x3361U, 0x3362U, 0x3363U, 0x3364U, 0x3365U, 0x3366U,
-	0x3430U, 0x3431U, 0x3432U, 0x3433U, 0x3434U, 0x3435U, 0x3436U, 0x3437U,
-	0x3438U, 0x3439U, 0x3461U, 0x3462U, 0x3463U, 0x3464U, 0x3465U, 0x3466U,
-	0x3530U, 0x3531U, 0x3532U, 0x3533U, 0x3534U, 0x3535U, 0x3536U, 0x3537U,
-	0x3538U, 0x3539U, 0x3561U, 0x3562U, 0x3563U, 0x3564U, 0x3565U, 0x3566U,
-	0x3630U, 0x3631U, 0x3632U, 0x3633U, 0x3634U, 0x3635U, 0x3636U, 0x3637U,
-	0x3638U, 0x3639U, 0x3661U, 0x3662U, 0x3663U, 0x3664U, 0x3665U, 0x3666U,
-	0x3730U, 0x3731U, 0x3732U, 0x3733U, 0x3734U, 0x3735U, 0x3736U, 0x3737U,
-	0x3738U, 0x3739U, 0x3761U, 0x3762U, 0x3763U, 0x3764U, 0x3765U, 0x3766U,
-	0x3830U, 0x3831U, 0x3832U, 0x3833U, 0x3834U, 0x3835U, 0x3836U, 0x3837U,
-	0x3838U, 0x3839U, 0x3861U, 0x3862U, 0x3863U, 0x3864U, 0x3865U, 0x3866U,
-	0x3930U, 0x3931U, 0x3932U, 0x3933U, 0x3934U, 0x3935U, 0x3936U, 0x3937U,
-	0x3938U, 0x3939U, 0x3961U, 0x3962U, 0x3963U, 0x3964U, 0x3965U, 0x3966U,
-	0x6130U, 0x6131U, 0x6132U, 0x6133U, 0x6134U, 0x6135U, 0x6136U, 0x6137U,
-	0x6138U, 0x6139U, 0x6161U, 0x6162U, 0x6163U, 0x6164U, 0x6165U, 0x6166U,
-	0x6230U, 0x6231U, 0x6232U, 0x6233U, 0x6234U, 0x6235U, 0x6236U, 0x6237U,
-	0x6238U, 0x6239U, 0x6261U, 0x6262U, 0x6263U, 0x6264U, 0x6265U, 0x6266U,
-	0x6330U, 0x6331U, 0x6332U, 0x6333U, 0x6334U, 0x6335U, 0x6336U, 0x6337U,
-	0x6338U, 0x6339U, 0x6361U, 0x6362U, 0x6363U, 0x6364U, 0x6365U, 0x6366U,
-	0x6430U, 0x6431U, 0x6432U, 0x6433U, 0x6434U, 0x6435U, 0x6436U, 0x6437U,
-	0x6438U, 0x6439U, 0x6461U, 0x6462U, 0x6463U, 0x6464U, 0x6465U, 0x6466U,
-	0x6530U, 0x6531U, 0x6532U, 0x6533U, 0x6534U, 0x6535U, 0x6536U, 0x6537U,
-	0x6538U, 0x6539U, 0x6561U, 0x6562U, 0x6563U, 0x6564U, 0x6565U, 0x6566U,
-	0x6630U, 0x6631U, 0x6632U, 0x6633U, 0x6634U, 0x6635U, 0x6636U, 0x6637U,
-	0x6638U, 0x6639U, 0x6661U, 0x6662U, 0x6663U, 0x6664U, 0x6665U, 0x6666U
-#else  /* DUK_USE_INTEGER_BE */
-	0x3030U, 0x3130U, 0x3230U, 0x3330U, 0x3430U, 0x3530U, 0x3630U, 0x3730U,
-	0x3830U, 0x3930U, 0x6130U, 0x6230U, 0x6330U, 0x6430U, 0x6530U, 0x6630U,
-	0x3031U, 0x3131U, 0x3231U, 0x3331U, 0x3431U, 0x3531U, 0x3631U, 0x3731U,
-	0x3831U, 0x3931U, 0x6131U, 0x6231U, 0x6331U, 0x6431U, 0x6531U, 0x6631U,
-	0x3032U, 0x3132U, 0x3232U, 0x3332U, 0x3432U, 0x3532U, 0x3632U, 0x3732U,
-	0x3832U, 0x3932U, 0x6132U, 0x6232U, 0x6332U, 0x6432U, 0x6532U, 0x6632U,
-	0x3033U, 0x3133U, 0x3233U, 0x3333U, 0x3433U, 0x3533U, 0x3633U, 0x3733U,
-	0x3833U, 0x3933U, 0x6133U, 0x6233U, 0x6333U, 0x6433U, 0x6533U, 0x6633U,
-	0x3034U, 0x3134U, 0x3234U, 0x3334U, 0x3434U, 0x3534U, 0x3634U, 0x3734U,
-	0x3834U, 0x3934U, 0x6134U, 0x6234U, 0x6334U, 0x6434U, 0x6534U, 0x6634U,
-	0x3035U, 0x3135U, 0x3235U, 0x3335U, 0x3435U, 0x3535U, 0x3635U, 0x3735U,
-	0x3835U, 0x3935U, 0x6135U, 0x6235U, 0x6335U, 0x6435U, 0x6535U, 0x6635U,
-	0x3036U, 0x3136U, 0x3236U, 0x3336U, 0x3436U, 0x3536U, 0x3636U, 0x3736U,
-	0x3836U, 0x3936U, 0x6136U, 0x6236U, 0x6336U, 0x6436U, 0x6536U, 0x6636U,
-	0x3037U, 0x3137U, 0x3237U, 0x3337U, 0x3437U, 0x3537U, 0x3637U, 0x3737U,
-	0x3837U, 0x3937U, 0x6137U, 0x6237U, 0x6337U, 0x6437U, 0x6537U, 0x6637U,
-	0x3038U, 0x3138U, 0x3238U, 0x3338U, 0x3438U, 0x3538U, 0x3638U, 0x3738U,
-	0x3838U, 0x3938U, 0x6138U, 0x6238U, 0x6338U, 0x6438U, 0x6538U, 0x6638U,
-	0x3039U, 0x3139U, 0x3239U, 0x3339U, 0x3439U, 0x3539U, 0x3639U, 0x3739U,
-	0x3839U, 0x3939U, 0x6139U, 0x6239U, 0x6339U, 0x6439U, 0x6539U, 0x6639U,
-	0x3061U, 0x3161U, 0x3261U, 0x3361U, 0x3461U, 0x3561U, 0x3661U, 0x3761U,
-	0x3861U, 0x3961U, 0x6161U, 0x6261U, 0x6361U, 0x6461U, 0x6561U, 0x6661U,
-	0x3062U, 0x3162U, 0x3262U, 0x3362U, 0x3462U, 0x3562U, 0x3662U, 0x3762U,
-	0x3862U, 0x3962U, 0x6162U, 0x6262U, 0x6362U, 0x6462U, 0x6562U, 0x6662U,
-	0x3063U, 0x3163U, 0x3263U, 0x3363U, 0x3463U, 0x3563U, 0x3663U, 0x3763U,
-	0x3863U, 0x3963U, 0x6163U, 0x6263U, 0x6363U, 0x6463U, 0x6563U, 0x6663U,
-	0x3064U, 0x3164U, 0x3264U, 0x3364U, 0x3464U, 0x3564U, 0x3664U, 0x3764U,
-	0x3864U, 0x3964U, 0x6164U, 0x6264U, 0x6364U, 0x6464U, 0x6564U, 0x6664U,
-	0x3065U, 0x3165U, 0x3265U, 0x3365U, 0x3465U, 0x3565U, 0x3665U, 0x3765U,
-	0x3865U, 0x3965U, 0x6165U, 0x6265U, 0x6365U, 0x6465U, 0x6565U, 0x6665U,
-	0x3066U, 0x3166U, 0x3266U, 0x3366U, 0x3466U, 0x3566U, 0x3666U, 0x3766U,
-	0x3866U, 0x3966U, 0x6166U, 0x6266U, 0x6366U, 0x6466U, 0x6566U, 0x6666U
-#endif  /* DUK_USE_INTEGER_BE */
+	0x3030U, 0x3031U, 0x3032U, 0x3033U, 0x3034U, 0x3035U, 0x3036U, 0x3037U, 0x3038U, 0x3039U, 0x3061U, 0x3062U, 0x3063U,
+	0x3064U, 0x3065U, 0x3066U, 0x3130U, 0x3131U, 0x3132U, 0x3133U, 0x3134U, 0x3135U, 0x3136U, 0x3137U, 0x3138U, 0x3139U,
+	0x3161U, 0x3162U, 0x3163U, 0x3164U, 0x3165U, 0x3166U, 0x3230U, 0x3231U, 0x3232U, 0x3233U, 0x3234U, 0x3235U, 0x3236U,
+	0x3237U, 0x3238U, 0x3239U, 0x3261U, 0x3262U, 0x3263U, 0x3264U, 0x3265U, 0x3266U, 0x3330U, 0x3331U, 0x3332U, 0x3333U,
+	0x3334U, 0x3335U, 0x3336U, 0x3337U, 0x3338U, 0x3339U, 0x3361U, 0x3362U, 0x3363U, 0x3364U, 0x3365U, 0x3366U, 0x3430U,
+	0x3431U, 0x3432U, 0x3433U, 0x3434U, 0x3435U, 0x3436U, 0x3437U, 0x3438U, 0x3439U, 0x3461U, 0x3462U, 0x3463U, 0x3464U,
+	0x3465U, 0x3466U, 0x3530U, 0x3531U, 0x3532U, 0x3533U, 0x3534U, 0x3535U, 0x3536U, 0x3537U, 0x3538U, 0x3539U, 0x3561U,
+	0x3562U, 0x3563U, 0x3564U, 0x3565U, 0x3566U, 0x3630U, 0x3631U, 0x3632U, 0x3633U, 0x3634U, 0x3635U, 0x3636U, 0x3637U,
+	0x3638U, 0x3639U, 0x3661U, 0x3662U, 0x3663U, 0x3664U, 0x3665U, 0x3666U, 0x3730U, 0x3731U, 0x3732U, 0x3733U, 0x3734U,
+	0x3735U, 0x3736U, 0x3737U, 0x3738U, 0x3739U, 0x3761U, 0x3762U, 0x3763U, 0x3764U, 0x3765U, 0x3766U, 0x3830U, 0x3831U,
+	0x3832U, 0x3833U, 0x3834U, 0x3835U, 0x3836U, 0x3837U, 0x3838U, 0x3839U, 0x3861U, 0x3862U, 0x3863U, 0x3864U, 0x3865U,
+	0x3866U, 0x3930U, 0x3931U, 0x3932U, 0x3933U, 0x3934U, 0x3935U, 0x3936U, 0x3937U, 0x3938U, 0x3939U, 0x3961U, 0x3962U,
+	0x3963U, 0x3964U, 0x3965U, 0x3966U, 0x6130U, 0x6131U, 0x6132U, 0x6133U, 0x6134U, 0x6135U, 0x6136U, 0x6137U, 0x6138U,
+	0x6139U, 0x6161U, 0x6162U, 0x6163U, 0x6164U, 0x6165U, 0x6166U, 0x6230U, 0x6231U, 0x6232U, 0x6233U, 0x6234U, 0x6235U,
+	0x6236U, 0x6237U, 0x6238U, 0x6239U, 0x6261U, 0x6262U, 0x6263U, 0x6264U, 0x6265U, 0x6266U, 0x6330U, 0x6331U, 0x6332U,
+	0x6333U, 0x6334U, 0x6335U, 0x6336U, 0x6337U, 0x6338U, 0x6339U, 0x6361U, 0x6362U, 0x6363U, 0x6364U, 0x6365U, 0x6366U,
+	0x6430U, 0x6431U, 0x6432U, 0x6433U, 0x6434U, 0x6435U, 0x6436U, 0x6437U, 0x6438U, 0x6439U, 0x6461U, 0x6462U, 0x6463U,
+	0x6464U, 0x6465U, 0x6466U, 0x6530U, 0x6531U, 0x6532U, 0x6533U, 0x6534U, 0x6535U, 0x6536U, 0x6537U, 0x6538U, 0x6539U,
+	0x6561U, 0x6562U, 0x6563U, 0x6564U, 0x6565U, 0x6566U, 0x6630U, 0x6631U, 0x6632U, 0x6633U, 0x6634U, 0x6635U, 0x6636U,
+	0x6637U, 0x6638U, 0x6639U, 0x6661U, 0x6662U, 0x6663U, 0x6664U, 0x6665U, 0x6666U
+#else /* DUK_USE_INTEGER_BE */
+	0x3030U, 0x3130U, 0x3230U, 0x3330U, 0x3430U, 0x3530U, 0x3630U, 0x3730U, 0x3830U, 0x3930U, 0x6130U, 0x6230U, 0x6330U,
+	0x6430U, 0x6530U, 0x6630U, 0x3031U, 0x3131U, 0x3231U, 0x3331U, 0x3431U, 0x3531U, 0x3631U, 0x3731U, 0x3831U, 0x3931U,
+	0x6131U, 0x6231U, 0x6331U, 0x6431U, 0x6531U, 0x6631U, 0x3032U, 0x3132U, 0x3232U, 0x3332U, 0x3432U, 0x3532U, 0x3632U,
+	0x3732U, 0x3832U, 0x3932U, 0x6132U, 0x6232U, 0x6332U, 0x6432U, 0x6532U, 0x6632U, 0x3033U, 0x3133U, 0x3233U, 0x3333U,
+	0x3433U, 0x3533U, 0x3633U, 0x3733U, 0x3833U, 0x3933U, 0x6133U, 0x6233U, 0x6333U, 0x6433U, 0x6533U, 0x6633U, 0x3034U,
+	0x3134U, 0x3234U, 0x3334U, 0x3434U, 0x3534U, 0x3634U, 0x3734U, 0x3834U, 0x3934U, 0x6134U, 0x6234U, 0x6334U, 0x6434U,
+	0x6534U, 0x6634U, 0x3035U, 0x3135U, 0x3235U, 0x3335U, 0x3435U, 0x3535U, 0x3635U, 0x3735U, 0x3835U, 0x3935U, 0x6135U,
+	0x6235U, 0x6335U, 0x6435U, 0x6535U, 0x6635U, 0x3036U, 0x3136U, 0x3236U, 0x3336U, 0x3436U, 0x3536U, 0x3636U, 0x3736U,
+	0x3836U, 0x3936U, 0x6136U, 0x6236U, 0x6336U, 0x6436U, 0x6536U, 0x6636U, 0x3037U, 0x3137U, 0x3237U, 0x3337U, 0x3437U,
+	0x3537U, 0x3637U, 0x3737U, 0x3837U, 0x3937U, 0x6137U, 0x6237U, 0x6337U, 0x6437U, 0x6537U, 0x6637U, 0x3038U, 0x3138U,
+	0x3238U, 0x3338U, 0x3438U, 0x3538U, 0x3638U, 0x3738U, 0x3838U, 0x3938U, 0x6138U, 0x6238U, 0x6338U, 0x6438U, 0x6538U,
+	0x6638U, 0x3039U, 0x3139U, 0x3239U, 0x3339U, 0x3439U, 0x3539U, 0x3639U, 0x3739U, 0x3839U, 0x3939U, 0x6139U, 0x6239U,
+	0x6339U, 0x6439U, 0x6539U, 0x6639U, 0x3061U, 0x3161U, 0x3261U, 0x3361U, 0x3461U, 0x3561U, 0x3661U, 0x3761U, 0x3861U,
+	0x3961U, 0x6161U, 0x6261U, 0x6361U, 0x6461U, 0x6561U, 0x6661U, 0x3062U, 0x3162U, 0x3262U, 0x3362U, 0x3462U, 0x3562U,
+	0x3662U, 0x3762U, 0x3862U, 0x3962U, 0x6162U, 0x6262U, 0x6362U, 0x6462U, 0x6562U, 0x6662U, 0x3063U, 0x3163U, 0x3263U,
+	0x3363U, 0x3463U, 0x3563U, 0x3663U, 0x3763U, 0x3863U, 0x3963U, 0x6163U, 0x6263U, 0x6363U, 0x6463U, 0x6563U, 0x6663U,
+	0x3064U, 0x3164U, 0x3264U, 0x3364U, 0x3464U, 0x3564U, 0x3664U, 0x3764U, 0x3864U, 0x3964U, 0x6164U, 0x6264U, 0x6364U,
+	0x6464U, 0x6564U, 0x6664U, 0x3065U, 0x3165U, 0x3265U, 0x3365U, 0x3465U, 0x3565U, 0x3665U, 0x3765U, 0x3865U, 0x3965U,
+	0x6165U, 0x6265U, 0x6365U, 0x6465U, 0x6565U, 0x6665U, 0x3066U, 0x3166U, 0x3266U, 0x3366U, 0x3466U, 0x3566U, 0x3666U,
+	0x3766U, 0x3866U, 0x3966U, 0x6166U, 0x6266U, 0x6366U, 0x6466U, 0x6566U, 0x6666U
+#endif /* DUK_USE_INTEGER_BE */
 };
-#endif  /* DUK_USE_HEX_FASTPATH */
+#endif /* DUK_USE_HEX_FASTPATH */
 
 /*
  *  Arbitrary byteswap for potentially unaligned values
  *
  *  Used to byteswap pointers e.g. in debugger code.
  */
 
-#if defined(DUK_USE_DEBUGGER_SUPPORT)  /* For now only needed by the debugger. */
+#if defined(DUK_USE_DEBUGGER_SUPPORT) /* For now only needed by the debugger. */
 DUK_INTERNAL void duk_byteswap_bytes(duk_uint8_t *p, duk_small_uint_t len) {
 	duk_uint8_t tmp;
 	duk_uint8_t *q = p + len - 1;
 
 	while (p - q < 0) {
 		tmp = *p;
 		*p = *q;
 		*q = tmp;
 		p++;
 		q--;
 	}
 }
 #endif
+
+/*
+ *  Random
+ */
+
+DUK_INTERNAL duk_double_t duk_util_get_random_double(duk_hthread *thr) {
+#if defined(DUK_USE_GET_RANDOM_DOUBLE)
+	return DUK_USE_GET_RANDOM_DOUBLE(thr->heap->heap_udata);
+#else
+	return duk_util_tinyrandom_get_double(thr);
+#endif
+}
 #line 1 "duk_hobject_class.c"
 /*
  *  Hobject ECMAScript [[Class]].
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -13638,15 +14330,15 @@
 #endif
 #if (DUK_STRIDX_EMPTY_STRING > 255)
 #error constant too large
 #endif
 
 /* Note: assumes that these string indexes are 8-bit, genstrings.py must ensure that */
 DUK_INTERNAL duk_uint8_t duk_class_number_to_stridx[32] = {
-	DUK_STRIDX_EMPTY_STRING,  /* NONE, intentionally empty */
+	DUK_STRIDX_EMPTY_STRING, /* NONE, intentionally empty */
 	DUK_STRIDX_UC_OBJECT,
 	DUK_STRIDX_UC_ARRAY,
 	DUK_STRIDX_UC_FUNCTION,
 	DUK_STRIDX_UC_ARGUMENTS,
 	DUK_STRIDX_UC_BOOLEAN,
 	DUK_STRIDX_UC_DATE,
 	DUK_STRIDX_UC_ERROR,
@@ -13668,16 +14360,16 @@
 	DUK_STRIDX_UINT8_CLAMPED_ARRAY,
 	DUK_STRIDX_INT16_ARRAY,
 	DUK_STRIDX_UINT16_ARRAY,
 	DUK_STRIDX_INT32_ARRAY,
 	DUK_STRIDX_UINT32_ARRAY,
 	DUK_STRIDX_FLOAT32_ARRAY,
 	DUK_STRIDX_FLOAT64_ARRAY,
-	DUK_STRIDX_EMPTY_STRING,  /* UNUSED, intentionally empty */
-	DUK_STRIDX_EMPTY_STRING,  /* UNUSED, intentionally empty */
+	DUK_STRIDX_EMPTY_STRING, /* UNUSED, intentionally empty */
+	DUK_STRIDX_EMPTY_STRING, /* UNUSED, intentionally empty */
 };
 #line 1 "duk_alloc_default.c"
 /*
  *  Default allocation functions.
  *
  *  Assumes behavior such as malloc allowing zero size, yielding
  *  a NULL or a unique pointer which is a no-op for free.
@@ -13686,34 +14378,32 @@
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_PROVIDE_DEFAULT_ALLOC_FUNCTIONS)
 DUK_INTERNAL void *duk_default_alloc_function(void *udata, duk_size_t size) {
 	void *res;
 	DUK_UNREF(udata);
 	res = DUK_ANSI_MALLOC(size);
-	DUK_DDD(DUK_DDDPRINT("default alloc function: %lu -> %p",
-	                     (unsigned long) size, (void *) res));
+	DUK_DDD(DUK_DDDPRINT("default alloc function: %lu -> %p", (unsigned long) size, (void *) res));
 	return res;
 }
 
 DUK_INTERNAL void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize) {
 	void *res;
 	DUK_UNREF(udata);
 	res = DUK_ANSI_REALLOC(ptr, newsize);
-	DUK_DDD(DUK_DDDPRINT("default realloc function: %p %lu -> %p",
-	                     (void *) ptr, (unsigned long) newsize, (void *) res));
+	DUK_DDD(DUK_DDDPRINT("default realloc function: %p %lu -> %p", (void *) ptr, (unsigned long) newsize, (void *) res));
 	return res;
 }
 
 DUK_INTERNAL void duk_default_free_function(void *udata, void *ptr) {
 	DUK_DDD(DUK_DDDPRINT("default free function: %p", (void *) ptr));
 	DUK_UNREF(udata);
 	DUK_ANSI_FREE(ptr);
 }
-#endif  /* DUK_USE_PROVIDE_DEFAULT_ALLOC_FUNCTIONS */
+#endif /* DUK_USE_PROVIDE_DEFAULT_ALLOC_FUNCTIONS */
 #line 1 "duk_api_buffer.c"
 /*
  *  Buffer
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -13797,19 +14487,19 @@
  *  validated which is not easy to do with indirect register references etc.
  */
 
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_BYTECODE_DUMP_SUPPORT)
 
-#define DUK__SER_MARKER  0xbf
-#define DUK__SER_STRING  0x00
-#define DUK__SER_NUMBER  0x01
+#define DUK__SER_MARKER             0xbf
+#define DUK__SER_STRING             0x00
+#define DUK__SER_NUMBER             0x01
 #define DUK__BYTECODE_INITIAL_ALLOC 256
-#define DUK__NO_FORMALS  0xffffffffUL
+#define DUK__NO_FORMALS             0xffffffffUL
 
 /*
  *  Dump/load helpers, xxx_raw() helpers do no buffer checks
  */
 
 DUK_LOCAL const duk_uint8_t *duk__load_string_raw(duk_hthread *thr, const duk_uint8_t *p) {
 	duk_uint32_t len;
@@ -13835,81 +14525,90 @@
 DUK_LOCAL duk_uint8_t *duk__dump_hstring_raw(duk_uint8_t *p, duk_hstring *h) {
 	duk_size_t len;
 	duk_uint32_t tmp32;
 
 	DUK_ASSERT(h != NULL);
 
 	len = DUK_HSTRING_GET_BYTELEN(h);
-	DUK_ASSERT(len <= 0xffffffffUL);  /* string limits */
+	DUK_ASSERT(len <= 0xffffffffUL); /* string limits */
 	tmp32 = (duk_uint32_t) len;
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
-	duk_memcpy((void *) p,
-	           (const void *) DUK_HSTRING_GET_DATA(h),
-	           len);
+	duk_memcpy((void *) p, (const void *) DUK_HSTRING_GET_DATA(h), len);
 	p += len;
 	return p;
 }
 
 DUK_LOCAL duk_uint8_t *duk__dump_hbuffer_raw(duk_hthread *thr, duk_uint8_t *p, duk_hbuffer *h) {
 	duk_size_t len;
 	duk_uint32_t tmp32;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(h != NULL);
 	DUK_UNREF(thr);
 
 	len = DUK_HBUFFER_GET_SIZE(h);
-	DUK_ASSERT(len <= 0xffffffffUL);  /* buffer limits */
+	DUK_ASSERT(len <= 0xffffffffUL); /* buffer limits */
 	tmp32 = (duk_uint32_t) len;
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 	/* When len == 0, buffer data pointer may be NULL. */
-	duk_memcpy_unsafe((void *) p,
-	                  (const void *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h),
-	                  len);
+	duk_memcpy_unsafe((void *) p, (const void *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h), len);
 	p += len;
 	return p;
 }
 
-DUK_LOCAL duk_uint8_t *duk__dump_string_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx) {
+DUK_LOCAL duk_uint8_t *duk__dump_string_prop(duk_hthread *thr,
+                                             duk_uint8_t *p,
+                                             duk_bufwriter_ctx *bw_ctx,
+                                             duk_hobject *func,
+                                             duk_small_uint_t stridx) {
 	duk_hstring *h_str;
 	duk_tval *tv;
 
 	tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 	if (tv != NULL && DUK_TVAL_IS_STRING(tv)) {
 		h_str = DUK_TVAL_GET_STRING(tv);
 		DUK_ASSERT(h_str != NULL);
 	} else {
 		h_str = DUK_HTHREAD_STRING_EMPTY_STRING(thr);
 		DUK_ASSERT(h_str != NULL);
 	}
-	DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL);  /* ensures no overflow */
+	DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL); /* ensures no overflow */
 	p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U + DUK_HSTRING_GET_BYTELEN(h_str), p);
 	p = duk__dump_hstring_raw(p, h_str);
 	return p;
 }
 
-DUK_LOCAL duk_uint8_t *duk__dump_buffer_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx) {
+DUK_LOCAL duk_uint8_t *duk__dump_buffer_prop(duk_hthread *thr,
+                                             duk_uint8_t *p,
+                                             duk_bufwriter_ctx *bw_ctx,
+                                             duk_hobject *func,
+                                             duk_small_uint_t stridx) {
 	duk_tval *tv;
 
 	tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 	if (tv != NULL && DUK_TVAL_IS_BUFFER(tv)) {
 		duk_hbuffer *h_buf;
 		h_buf = DUK_TVAL_GET_BUFFER(tv);
 		DUK_ASSERT(h_buf != NULL);
-		DUK_ASSERT(DUK_HBUFFER_MAX_BYTELEN <= 0x7fffffffUL);  /* ensures no overflow */
+		DUK_ASSERT(DUK_HBUFFER_MAX_BYTELEN <= 0x7fffffffUL); /* ensures no overflow */
 		p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U + DUK_HBUFFER_GET_SIZE(h_buf), p);
 		p = duk__dump_hbuffer_raw(thr, p, h_buf);
 	} else {
 		p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U, p);
 		DUK_RAW_WRITEINC_U32_BE(p, 0);
 	}
 	return p;
 }
 
-DUK_LOCAL duk_uint8_t *duk__dump_uint32_prop(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func, duk_small_uint_t stridx, duk_uint32_t def_value) {
+DUK_LOCAL duk_uint8_t *duk__dump_uint32_prop(duk_hthread *thr,
+                                             duk_uint8_t *p,
+                                             duk_bufwriter_ctx *bw_ctx,
+                                             duk_hobject *func,
+                                             duk_small_uint_t stridx,
+                                             duk_uint32_t def_value) {
 	duk_tval *tv;
 	duk_uint32_t val;
 
 	tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 	if (tv != NULL && DUK_TVAL_IS_NUMBER(tv)) {
 		val = (duk_uint32_t) DUK_TVAL_GET_NUMBER(tv);
 	} else {
@@ -13934,35 +14633,36 @@
 		 */
 		for (i = 0; i < (duk_uint_fast32_t) DUK_HOBJECT_GET_ENEXT(h); i++) {
 			duk_hstring *key;
 			duk_tval *tv_val;
 			duk_uint32_t val;
 
 			key = DUK_HOBJECT_E_GET_KEY(thr->heap, h, i);
-			DUK_ASSERT(key != NULL);  /* _Varmap is dense */
+			DUK_ASSERT(key != NULL); /* _Varmap is dense */
 			DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, h, i));
 			tv_val = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, h, i);
 			DUK_ASSERT(tv_val != NULL);
-			DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv_val));  /* known to be number; in fact an integer */
+			DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv_val)); /* known to be number; in fact an integer */
 #if defined(DUK_USE_FASTINT)
 			DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv_val));
-			DUK_ASSERT(DUK_TVAL_GET_FASTINT(tv_val) == (duk_int64_t) DUK_TVAL_GET_FASTINT_U32(tv_val));  /* known to be 32-bit */
+			DUK_ASSERT(DUK_TVAL_GET_FASTINT(tv_val) ==
+			           (duk_int64_t) DUK_TVAL_GET_FASTINT_U32(tv_val)); /* known to be 32-bit */
 			val = DUK_TVAL_GET_FASTINT_U32(tv_val);
 #else
 			val = (duk_uint32_t) DUK_TVAL_GET_NUMBER(tv_val);
 #endif
 
-			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL);  /* ensures no overflow */
+			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL); /* ensures no overflow */
 			p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U + DUK_HSTRING_GET_BYTELEN(key) + 4U, p);
 			p = duk__dump_hstring_raw(p, key);
 			DUK_RAW_WRITEINC_U32_BE(p, val);
 		}
 	}
 	p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U, p);
-	DUK_RAW_WRITEINC_U32_BE(p, 0);  /* end of _Varmap */
+	DUK_RAW_WRITEINC_U32_BE(p, 0); /* end of _Varmap */
 	return p;
 }
 
 DUK_LOCAL duk_uint8_t *duk__dump_formals(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func) {
 	duk_harray *h;
 
 	h = duk_hobject_get_formals(thr, (duk_hobject *) func);
@@ -13972,37 +14672,37 @@
 		/* Here we rely on _Formals being a dense array containing
 		 * strings.  This should be the case unless _Formals has been
 		 * tweaked by the application (which we don't support right
 		 * now).
 		 */
 
 		p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U, p);
-		DUK_ASSERT(h->length != DUK__NO_FORMALS);  /* limits */
+		DUK_ASSERT(h->length != DUK__NO_FORMALS); /* limits */
 		DUK_RAW_WRITEINC_U32_BE(p, h->length);
 
 		for (i = 0; i < h->length; i++) {
 			duk_tval *tv_val;
 			duk_hstring *varname;
 
 			tv_val = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, (duk_hobject *) h, i);
 			DUK_ASSERT(tv_val != NULL);
 			DUK_ASSERT(DUK_TVAL_IS_STRING(tv_val));
 
 			varname = DUK_TVAL_GET_STRING(tv_val);
 			DUK_ASSERT(varname != NULL);
 			DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(varname) >= 1);
 
-			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL);  /* ensures no overflow */
+			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL); /* ensures no overflow */
 			p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U + DUK_HSTRING_GET_BYTELEN(varname), p);
 			p = duk__dump_hstring_raw(p, varname);
 		}
 	} else {
 		DUK_DD(DUK_DDPRINT("dumping function without _Formals, emit marker to indicate missing _Formals"));
 		p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 4U, p);
-		DUK_RAW_WRITEINC_U32_BE(p, DUK__NO_FORMALS);  /* marker: no formals */
+		DUK_RAW_WRITEINC_U32_BE(p, DUK__NO_FORMALS); /* marker: no formals */
 	}
 	return p;
 }
 
 static duk_uint8_t *duk__dump_func(duk_hthread *thr, duk_hcompfunc *func, duk_bufwriter_ctx *bw_ctx, duk_uint8_t *p) {
 	duk_tval *tv, *tv_end;
 	duk_instr_t *ins, *ins_end;
@@ -14028,15 +14728,15 @@
 	                   (long) DUK_HCOMPFUNC_GET_FUNCS_SIZE(thr->heap, func),
 	                   (long) DUK_HCOMPFUNC_GET_FUNCS_COUNT(thr->heap, func),
 	                   (void *) DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, func),
 	                   (void *) DUK_HCOMPFUNC_GET_CODE_END(thr->heap, func),
 	                   (long) DUK_HCOMPFUNC_GET_CODE_SIZE(thr->heap, func),
 	                   (long) DUK_HCOMPFUNC_GET_CODE_COUNT(thr->heap, func)));
 
-	DUK_ASSERT(DUK_USE_ESBC_MAX_BYTES <= 0x7fffffffUL);  /* ensures no overflow */
+	DUK_ASSERT(DUK_USE_ESBC_MAX_BYTES <= 0x7fffffffUL); /* ensures no overflow */
 	count_instr = (duk_uint32_t) DUK_HCOMPFUNC_GET_CODE_COUNT(thr->heap, func);
 	p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 3U * 4U + 2U * 2U + 3U * 4U + count_instr * 4U, p);
 
 	/* Fixed header info. */
 	tmp32 = count_instr;
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 	tmp32 = (duk_uint32_t) DUK_HCOMPFUNC_GET_CONSTS_COUNT(thr->heap, func);
@@ -14052,47 +14752,47 @@
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 	tmp32 = func->end_line;
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 #else
 	DUK_RAW_WRITEINC_U32_BE(p, 0);
 	DUK_RAW_WRITEINC_U32_BE(p, 0);
 #endif
-	tmp32 = DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) func);  /* masks flags, only duk_hobject flags */
-	tmp32 &= ~(DUK_HOBJECT_FLAG_HAVE_FINALIZER);  /* finalizer flag is lost */
+	tmp32 = DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) func); /* masks flags, only duk_hobject flags */
+	tmp32 &= ~(DUK_HOBJECT_FLAG_HAVE_FINALIZER); /* finalizer flag is lost */
 	DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 
 	/* Bytecode instructions: endian conversion needed unless
 	 * platform is big endian.
 	 */
 	ins = DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, func);
 	ins_end = DUK_HCOMPFUNC_GET_CODE_END(thr->heap, func);
 	DUK_ASSERT((duk_size_t) (ins_end - ins) == (duk_size_t) count_instr);
 #if defined(DUK_USE_INTEGER_BE)
-	duk_memcpy_unsafe((void *) p, (const void *) ins, (size_t) (ins_end - ins));
-	p += (size_t) (ins_end - ins);
+	duk_memcpy_unsafe((void *) p, (const void *) ins, count_instr * sizeof(duk_instr_t));
+	p += count_instr * sizeof(duk_instr_t);
+	DUK_UNREF(ins_end);
 #else
 	while (ins != ins_end) {
 		tmp32 = (duk_uint32_t) (*ins);
 		DUK_RAW_WRITEINC_U32_BE(p, tmp32);
 		ins++;
 	}
 #endif
 
 	/* Constants: variable size encoding. */
 	tv = DUK_HCOMPFUNC_GET_CONSTS_BASE(thr->heap, func);
 	tv_end = DUK_HCOMPFUNC_GET_CONSTS_END(thr->heap, func);
 	while (tv != tv_end) {
 		/* constants are strings or numbers now */
-		DUK_ASSERT(DUK_TVAL_IS_STRING(tv) ||
-		           DUK_TVAL_IS_NUMBER(tv));
+		DUK_ASSERT(DUK_TVAL_IS_STRING(tv) || DUK_TVAL_IS_NUMBER(tv));
 
 		if (DUK_TVAL_IS_STRING(tv)) {
 			h_str = DUK_TVAL_GET_STRING(tv);
 			DUK_ASSERT(h_str != NULL);
-			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL);  /* ensures no overflow */
+			DUK_ASSERT(DUK_HSTRING_MAX_BYTELEN <= 0x7fffffffUL); /* ensures no overflow */
 			p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 1U + 4U + DUK_HSTRING_GET_BYTELEN(h_str), p);
 			*p++ = DUK__SER_STRING;
 			p = duk__dump_hstring_raw(p, h_str);
 		} else {
 			DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
 			p = DUK_BW_ENSURE_RAW(thr, bw_ctx, 1U + 8U, p);
 			*p++ = DUK__SER_NUMBER;
@@ -14150,15 +14850,16 @@
  *
  * NOTE: there are intentionally no input buffer length / bound checks.
  * Adding them would be easy but wouldn't ensure memory safety as untrusted
  * or broken bytecode is unsafe during execution unless the opcodes themselves
  * are validated (which is quite complex, especially for indirect opcodes).
  */
 
-#define DUK__ASSERT_LEFT(n) do { \
+#define DUK__ASSERT_LEFT(n) \
+	do { \
 		DUK_ASSERT((duk_size_t) (p_end - p) >= (duk_size_t) (n)); \
 	} while (0)
 
 static const duk_uint8_t *duk__load_func(duk_hthread *thr, const duk_uint8_t *p, const duk_uint8_t *p_end) {
 	duk_hcompfunc *h_fun;
 	duk_hbuffer *h_data;
 	duk_size_t data_size;
@@ -14185,21 +14886,21 @@
 	DUK_DD(DUK_DDPRINT("loading function, p=%p, p_end=%p", (const void *) p, (const void *) p_end));
 
 	DUK__ASSERT_LEFT(3 * 4);
 	count_instr = DUK_RAW_READINC_U32_BE(p);
 	count_const = DUK_RAW_READINC_U32_BE(p);
 	count_funcs = DUK_RAW_READINC_U32_BE(p);
 
-	data_size = sizeof(duk_tval) * count_const +
-	            sizeof(duk_hobject *) * count_funcs +
-	            sizeof(duk_instr_t) * count_instr;
+	data_size = sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs + sizeof(duk_instr_t) * count_instr;
 
 	DUK_DD(DUK_DDPRINT("instr=%ld, const=%ld, funcs=%ld, data_size=%ld",
-	                   (long) count_instr, (long) count_const,
-	                   (long) count_const, (long) data_size));
+	                   (long) count_instr,
+	                   (long) count_const,
+	                   (long) count_const,
+	                   (long) data_size));
 
 	/* Value stack is used to ensure reachability of constants and
 	 * inner functions being loaded.  Require enough space to handle
 	 * large functions correctly.
 	 */
 	duk_require_stack(thr, (duk_idx_t) (2 + count_const + count_funcs));
 	idx_base = duk_get_top(thr);
@@ -14217,20 +14918,20 @@
 
 	h_fun->nregs = DUK_RAW_READINC_U16_BE(p);
 	h_fun->nargs = DUK_RAW_READINC_U16_BE(p);
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	h_fun->start_line = DUK_RAW_READINC_U32_BE(p);
 	h_fun->end_line = DUK_RAW_READINC_U32_BE(p);
 #else
-	p += 8;  /* skip line info */
+	p += 8; /* skip line info */
 #endif
 
 	/* duk_hcompfunc flags; quite version specific */
 	tmp32 = DUK_RAW_READINC_U32_BE(p);
-	DUK_HEAPHDR_SET_FLAGS((duk_heaphdr *) h_fun, tmp32);  /* masks flags to only change duk_hobject flags */
+	DUK_HEAPHDR_SET_FLAGS((duk_heaphdr *) h_fun, tmp32); /* masks flags to only change duk_hobject flags */
 
 	/* standard prototype (no need to set here, already set) */
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) h_fun) == thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE]);
 #if 0
 	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, &h_fun->obj, thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE]);
 #endif
 
@@ -14250,17 +14951,15 @@
 	DUK_ASSERT(fun_data != NULL);
 
 	/* Load bytecode instructions. */
 	DUK_ASSERT(sizeof(duk_instr_t) == 4);
 	DUK__ASSERT_LEFT(count_instr * sizeof(duk_instr_t));
 #if defined(DUK_USE_INTEGER_BE)
 	q = fun_data + sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs;
-	duk_memcpy((void *) q,
-	           (const void *) p,
-	           sizeof(duk_instr_t) * count_instr);
+	duk_memcpy((void *) q, (const void *) p, sizeof(duk_instr_t) * count_instr);
 	p += sizeof(duk_instr_t) * count_instr;
 #else
 	q = fun_data + sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs;
 	for (n = count_instr; n > 0; n--) {
 		*((duk_instr_t *) (void *) q) = DUK_RAW_READINC_U32_BE(p);
 		q += sizeof(duk_instr_t);
 	}
@@ -14311,21 +15010,21 @@
 	 */
 
 	h_data = (duk_hbuffer *) duk_known_hbuffer(thr, idx_base + 1);
 	DUK_ASSERT(!DUK_HBUFFER_HAS_DYNAMIC(h_data));
 	DUK_HCOMPFUNC_SET_DATA(thr->heap, h_fun, h_data);
 	DUK_HBUFFER_INCREF(thr, h_data);
 
-	tv1 = duk_get_tval(thr, idx_base + 2);  /* may be NULL if no constants or inner funcs */
+	tv1 = duk_get_tval(thr, idx_base + 2); /* may be NULL if no constants or inner funcs */
 	DUK_ASSERT((count_const == 0 && count_funcs == 0) || tv1 != NULL);
 
 	q = fun_data;
 	duk_memcpy_unsafe((void *) q, (const void *) tv1, sizeof(duk_tval) * count_const);
 	for (n = count_const; n > 0; n--) {
-		DUK_TVAL_INCREF_FAST(thr, (duk_tval *) (void *) q);  /* no side effects */
+		DUK_TVAL_INCREF_FAST(thr, (duk_tval *) (void *) q); /* no side effects */
 		q += sizeof(duk_tval);
 	}
 	tv1 += count_const;
 
 	DUK_HCOMPFUNC_SET_FUNCS(thr->heap, h_fun, (duk_hobject **) (void *) q);
 	for (n = count_funcs; n > 0; n--) {
 		duk_hobject *h_obj;
@@ -14350,82 +15049,84 @@
 
 	/* Setup function properties. */
 	tmp32 = DUK_RAW_READINC_U32_BE(p);
 	duk_push_u32(thr, tmp32);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_C);
 
 #if defined(DUK_USE_FUNC_NAME_PROPERTY)
-	p = duk__load_string_raw(thr, p);  /* -> [ func funcname ] */
+	p = duk__load_string_raw(thr, p); /* -> [ func funcname ] */
 	func_env = thr->builtins[DUK_BIDX_GLOBAL_ENV];
 	DUK_ASSERT(func_env != NULL);
 	need_pop = 0;
 	if (DUK_HOBJECT_HAS_NAMEBINDING((duk_hobject *) h_fun)) {
 		/* Original function instance/template had NAMEBINDING.
 		 * Must create a lexical environment on loading to allow
 		 * recursive functions like 'function foo() { foo(); }'.
 		 */
 		duk_hdecenv *new_env;
 
-		new_env = duk_hdecenv_alloc(thr,
-		                            DUK_HOBJECT_FLAG_EXTENSIBLE |
-		                            DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
+		new_env =
+		    duk_hdecenv_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
 		DUK_ASSERT(new_env != NULL);
-		DUK_ASSERT(new_env->thread == NULL);  /* Closed. */
+		DUK_ASSERT(new_env->thread == NULL); /* Closed. */
 		DUK_ASSERT(new_env->varmap == NULL);
 		DUK_ASSERT(new_env->regbase_byteoff == 0);
 		DUK_HDECENV_ASSERT_VALID(new_env);
 		DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) new_env) == NULL);
 		DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) new_env, func_env);
 		DUK_HOBJECT_INCREF(thr, func_env);
 
 		func_env = (duk_hobject *) new_env;
 
 		duk_push_hobject(thr, (duk_hobject *) new_env);
 
-		duk_dup_m2(thr);                                  /* -> [ func funcname env funcname ] */
-		duk_dup(thr, idx_base);                           /* -> [ func funcname env funcname func ] */
-		duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_NONE);  /* -> [ func funcname env ] */
+		duk_dup_m2(thr); /* -> [ func funcname env funcname ] */
+		duk_dup(thr, idx_base); /* -> [ func funcname env funcname func ] */
+		duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_NONE); /* -> [ func funcname env ] */
 
-		need_pop = 1;  /* Need to pop env, but -after- updating h_fun and increfs. */
+		need_pop = 1; /* Need to pop env, but -after- updating h_fun and increfs. */
 	}
 	DUK_ASSERT(func_env != NULL);
 	DUK_HCOMPFUNC_SET_LEXENV(thr->heap, h_fun, func_env);
 	DUK_HCOMPFUNC_SET_VARENV(thr->heap, h_fun, func_env);
 	DUK_HOBJECT_INCREF(thr, func_env);
 	DUK_HOBJECT_INCREF(thr, func_env);
 	if (need_pop) {
 		duk_pop(thr);
 	}
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_C);
-#endif  /* DUK_USE_FUNC_NAME_PROPERTY */
+#endif /* DUK_USE_FUNC_NAME_PROPERTY */
 
 #if defined(DUK_USE_FUNC_FILENAME_PROPERTY)
 	p = duk__load_string_raw(thr, p);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_FILE_NAME, DUK_PROPDESC_FLAGS_C);
-#endif  /* DUK_USE_FUNC_FILENAME_PROPERTY */
+#endif /* DUK_USE_FUNC_FILENAME_PROPERTY */
 
 	if (DUK_HOBJECT_HAS_CONSTRUCTABLE((duk_hobject *) h_fun)) {
 		/* Restore empty external .prototype only for constructable
 		 * functions.  The prototype object should inherit from
 		 * Object.prototype.
 		 */
 		duk_push_object(thr);
 		DUK_ASSERT(!duk_is_bare_object(thr, -1));
 		duk_dup_m2(thr);
-		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_CONSTRUCTOR, DUK_PROPDESC_FLAGS_WC);  /* func.prototype.constructor = func */
+		duk_xdef_prop_stridx_short(thr,
+		                           -2,
+		                           DUK_STRIDX_CONSTRUCTOR,
+		                           DUK_PROPDESC_FLAGS_WC); /* func.prototype.constructor = func */
 		duk_compact_m1(thr);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_PROTOTYPE, DUK_PROPDESC_FLAGS_W);
 	}
 
 #if defined(DUK_USE_PC2LINE)
 	p = duk__load_buffer_raw(thr, p);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_PC2LINE, DUK_PROPDESC_FLAGS_WC);
-#endif  /* DUK_USE_PC2LINE */
+#endif /* DUK_USE_PC2LINE */
 
-	duk_push_bare_object(thr);  /* _Varmap */
+	duk_push_bare_object(thr); /* _Varmap */
 	for (;;) {
 		/* XXX: awkward */
 		p = duk__load_string_raw(thr, p);
 		if (duk_get_length(thr, -1) == 0) {
 			duk_pop(thr);
 			break;
 		}
@@ -14437,15 +15138,15 @@
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VARMAP, DUK_PROPDESC_FLAGS_NONE);
 
 	/* _Formals may have been missing in the original function, which is
 	 * handled using a marker length.
 	 */
 	arr_limit = DUK_RAW_READINC_U32_BE(p);
 	if (arr_limit != DUK__NO_FORMALS) {
-		duk_push_bare_array(thr);  /* _Formals */
+		duk_push_bare_array(thr); /* _Formals */
 		for (arr_idx = 0; arr_idx < arr_limit; arr_idx++) {
 			p = duk__load_string_raw(thr, p);
 			duk_put_prop_index(thr, -2, arr_idx);
 		}
 		duk_compact_m1(thr);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_FORMALS, DUK_PROPDESC_FLAGS_NONE);
 	} else {
@@ -14453,15 +15154,15 @@
 	}
 
 	/* Return with final function pushed on stack top. */
 	DUK_DD(DUK_DDPRINT("final loaded function: %!iT", duk_get_tval(thr, -1)));
 	DUK_ASSERT_TOP(thr, idx_base + 1);
 	return p;
 
- format_error:
+format_error:
 	return NULL;
 }
 
 DUK_EXTERNAL void duk_dump_function(duk_hthread *thr) {
 	duk_hcompfunc *func;
 	duk_bufwriter_ctx bw_ctx_alloc;
 	duk_bufwriter_ctx *bw_ctx = &bw_ctx_alloc;
@@ -14485,15 +15186,15 @@
 	*p++ = DUK__SER_MARKER;
 	p = duk__dump_func(thr, func, bw_ctx, p);
 	DUK_BW_SET_PTR(thr, bw_ctx, p);
 	DUK_BW_COMPACT(thr, bw_ctx);
 
 	DUK_DD(DUK_DDPRINT("serialized result: %!T", duk_get_tval(thr, -1)));
 
-	duk_remove_m2(thr);  /* [ ... func buf ] -> [ ... buf ] */
+	duk_remove_m2(thr); /* [ ... func buf ] -> [ ... buf ] */
 }
 
 DUK_EXTERNAL void duk_load_function(duk_hthread *thr) {
 	const duk_uint8_t *p_buf, *p, *p_end;
 	duk_size_t sz;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -14518,37 +15219,37 @@
 	p++;
 
 	p = duk__load_func(thr, p, p_end);
 	if (p == NULL) {
 		goto format_error;
 	}
 
-	duk_remove_m2(thr);  /* [ ... buf func ] -> [ ... func ] */
+	duk_remove_m2(thr); /* [ ... buf func ] -> [ ... func ] */
 	return;
 
- format_error:
+format_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_BYTECODE);
 	DUK_WO_NORETURN(return;);
 }
 
-#else  /* DUK_USE_BYTECODE_DUMP_SUPPORT */
+#else /* DUK_USE_BYTECODE_DUMP_SUPPORT */
 
 DUK_EXTERNAL void duk_dump_function(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_load_function(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
 
-#endif  /* DUK_USE_BYTECODE_DUMP_SUPPORT */
+#endif /* DUK_USE_BYTECODE_DUMP_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__ASSERT_LEFT
 #undef DUK__BYTECODE_INITIAL_ALLOC
 #undef DUK__NO_FORMALS
 #undef DUK__SER_MARKER
 #undef DUK__SER_NUMBER
@@ -14603,15 +15304,15 @@
 	duk_idx_t idx_func;
 
 	/* XXX: byte arithmetic? */
 
 	DUK_ASSERT(other >= 0);
 
 	idx_func = duk_get_top(thr) - nargs - other;
-	if (DUK_UNLIKELY((idx_func | nargs) < 0)) {  /* idx_func < 0 || nargs < 0; OR sign bits */
+	if (DUK_UNLIKELY((idx_func | nargs) < 0)) { /* idx_func < 0 || nargs < 0; OR sign bits */
 		DUK_ERROR_TYPE_INVALID_ARGS(thr);
 		DUK_WO_NORETURN(return 0;);
 	}
 	DUK_ASSERT(duk_is_valid_index(thr, idx_func));
 	return idx_func;
 }
 
@@ -14637,20 +15338,22 @@
  * May currently throw an error e.g. when getting the property.
  */
 DUK_LOCAL void duk__call_prop_prep_stack(duk_hthread *thr, duk_idx_t normalized_obj_idx, duk_idx_t nargs) {
 	DUK_CTX_ASSERT_VALID(thr);
 	DUK_ASSERT(nargs >= 0);
 
 	DUK_DDD(DUK_DDDPRINT("duk__call_prop_prep_stack, normalized_obj_idx=%ld, nargs=%ld, stacktop=%ld",
-	                     (long) normalized_obj_idx, (long) nargs, (long) duk_get_top(thr)));
+	                     (long) normalized_obj_idx,
+	                     (long) nargs,
+	                     (long) duk_get_top(thr)));
 
 	/* [... key arg1 ... argN] */
 
 	/* duplicate key */
-	duk_dup(thr, -nargs - 1);  /* Note: -nargs alone would fail for nargs == 0, this is OK */
+	duk_dup(thr, -nargs - 1); /* Note: -nargs alone would fail for nargs == 0, this is OK */
 	(void) duk_get_prop(thr, normalized_obj_idx);
 
 	DUK_DDD(DUK_DDDPRINT("func: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 	if (DUK_UNLIKELY(!duk_is_callable(thr, -1))) {
 		duk_tval *tv_base;
@@ -14685,42 +15388,42 @@
 	DUK_ASSERT_API_ENTRY(thr);
 
 	idx_func = duk__call_get_idx_func(thr, nargs, 1);
 	DUK_ASSERT(duk_is_valid_index(thr, idx_func));
 
 	duk_insert_undefined(thr, idx_func + 1);
 
-	call_flags = 0;  /* not protected, respect reclimit, not constructor */
+	call_flags = 0; /* not protected, respect reclimit, not constructor */
 	duk_handle_call_unprotected(thr, idx_func, call_flags);
 }
 
 DUK_EXTERNAL void duk_call_method(duk_hthread *thr, duk_idx_t nargs) {
 	duk_small_uint_t call_flags;
 	duk_idx_t idx_func;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	idx_func = duk__call_get_idx_func(thr, nargs, 2);
 	DUK_ASSERT(duk_is_valid_index(thr, idx_func));
 
-	call_flags = 0;  /* not protected, respect reclimit, not constructor */
+	call_flags = 0; /* not protected, respect reclimit, not constructor */
 	duk_handle_call_unprotected(thr, idx_func, call_flags);
 }
 
 DUK_EXTERNAL void duk_call_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t nargs) {
 	/*
 	 *  XXX: if duk_handle_call() took values through indices, this could be
 	 *  made much more sensible.  However, duk_handle_call() needs to fudge
 	 *  the 'this' and 'func' values to handle bound functions, which is now
 	 *  done "in-place", so this is not a trivial change.
 	 */
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	obj_idx = duk_require_normalize_index(thr, obj_idx);  /* make absolute */
+	obj_idx = duk_require_normalize_index(thr, obj_idx); /* make absolute */
 	if (DUK_UNLIKELY(nargs < 0)) {
 		DUK_ERROR_TYPE_INVALID_ARGS(thr);
 		DUK_WO_NORETURN(return;);
 	}
 
 	duk__call_prop_prep_stack(thr, obj_idx, nargs);
 
@@ -14810,15 +15513,15 @@
 	duk_int_t ret;
 
 	DUK_CTX_ASSERT_VALID(thr);
 	DUK_ASSERT(udata != NULL);
 
 	args = (duk__pcall_prop_args *) udata;
 
-	obj_idx = duk_require_normalize_index(thr, args->obj_idx);  /* make absolute */
+	obj_idx = duk_require_normalize_index(thr, args->obj_idx); /* make absolute */
 	duk__call_prop_prep_stack(thr, obj_idx, args->nargs);
 
 	ret = duk_handle_call_unprotected_nargs(thr, args->nargs, args->call_flags);
 	DUK_ASSERT(ret == 0);
 	DUK_UNREF(ret);
 	return 1;
 }
@@ -14848,51 +15551,51 @@
 	 *                      <=>  top < bottom + nargs
 	 * nrets condition; fail if: end - (top - nargs) < nrets
 	 *                      <=>  end - top + nargs < nrets
 	 *                      <=>  end + nargs < top + nrets
 	 */
 	/* XXX: check for any reserve? */
 
-	if (DUK_UNLIKELY((nargs | nrets) < 0 ||  /* nargs < 0 || nrets < 0; OR sign bits */
-	                 thr->valstack_top < thr->valstack_bottom + nargs ||        /* nargs too large compared to top */
-	                 thr->valstack_end + nargs < thr->valstack_top + nrets)) {  /* nrets too large compared to reserve */
+	if (DUK_UNLIKELY((nargs | nrets) < 0 || /* nargs < 0 || nrets < 0; OR sign bits */
+	                 thr->valstack_top < thr->valstack_bottom + nargs || /* nargs too large compared to top */
+	                 thr->valstack_end + nargs < thr->valstack_top + nrets)) { /* nrets too large compared to reserve */
 		DUK_D(DUK_DPRINT("not enough stack reserve for safe call or invalid arguments: "
 		                 "nargs=%ld < 0 (?), nrets=%ld < 0 (?), top=%ld < bottom=%ld + nargs=%ld (?), "
 		                 "end=%ld + nargs=%ld < top=%ld + nrets=%ld (?)",
-		                  (long) nargs,
-		                  (long) nrets,
-		                  (long) (thr->valstack_top - thr->valstack),
-		                  (long) (thr->valstack_bottom - thr->valstack),
-		                  (long) nargs,
-		                  (long) (thr->valstack_end - thr->valstack),
-		                  (long) nargs,
-		                  (long) (thr->valstack_top - thr->valstack),
-		                  (long) nrets));
+		                 (long) nargs,
+		                 (long) nrets,
+		                 (long) (thr->valstack_top - thr->valstack),
+		                 (long) (thr->valstack_bottom - thr->valstack),
+		                 (long) nargs,
+		                 (long) (thr->valstack_end - thr->valstack),
+		                 (long) nargs,
+		                 (long) (thr->valstack_top - thr->valstack),
+		                 (long) nrets));
 		DUK_ERROR_TYPE_INVALID_ARGS(thr);
 		DUK_WO_NORETURN(return DUK_EXEC_ERROR;);
 	}
 
-	rc = duk_handle_safe_call(thr,           /* thread */
-	                          func,          /* func */
-	                          udata,         /* udata */
-	                          nargs,         /* num_stack_args */
-	                          nrets);        /* num_stack_res */
+	rc = duk_handle_safe_call(thr, /* thread */
+	                          func, /* func */
+	                          udata, /* udata */
+	                          nargs, /* num_stack_args */
+	                          nrets); /* num_stack_res */
 
 	return rc;
 }
 
 DUK_EXTERNAL void duk_new(duk_hthread *thr, duk_idx_t nargs) {
 	duk_idx_t idx_func;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	idx_func = duk__call_get_idx_func(thr, nargs, 1);
 	DUK_ASSERT(duk_is_valid_index(thr, idx_func));
 
-	duk_push_object(thr);  /* default instance; internal proto updated by call handling */
+	duk_push_object(thr); /* default instance; internal proto updated by call handling */
 	duk_insert(thr, idx_func + 1);
 
 	duk_handle_call_unprotected(thr, idx_func, DUK_CALL_FLAG_CONSTRUCT);
 }
 
 DUK_LOCAL duk_ret_t duk__pnew_helper(duk_hthread *thr, void *udata) {
 	duk_idx_t nargs;
@@ -15012,15 +15715,15 @@
 		return (duk_int_t) ((duk_hnatfunc *) h)->magic;
 	} else if (DUK_TVAL_IS_LIGHTFUNC(tv)) {
 		duk_small_uint_t lf_flags = DUK_TVAL_GET_LIGHTFUNC_FLAGS(tv);
 		return (duk_int_t) DUK_LFUNC_FLAGS_GET_MAGIC(lf_flags);
 	}
 
 	/* fall through */
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_UNEXPECTED_TYPE);
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_EXTERNAL void duk_set_magic(duk_hthread *thr, duk_idx_t idx, duk_int_t magic) {
 	duk_hnatfunc *nf;
 
@@ -15087,23 +15790,24 @@
 
 /* Shared handling for encode/decode argument.  Fast path handling for
  * buffer and string values because they're the most common.  In particular,
  * avoid creating a temporary string or buffer when possible.  Return value
  * is guaranteed to be non-NULL, even for zero length input.
  */
 DUK_LOCAL const duk_uint8_t *duk__prep_codec_arg(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
-	const void *def_ptr = (const void *) out_len;  /* Any non-NULL pointer will do. */
+	const void *def_ptr = (const void *) out_len; /* Any non-NULL pointer will do. */
 	const void *ptr;
 	duk_bool_t isbuffer;
 
 	DUK_ASSERT(out_len != NULL);
 	DUK_ASSERT(def_ptr != NULL);
-	DUK_ASSERT(duk_is_valid_index(thr, idx));  /* checked by caller */
+	DUK_ASSERT(duk_is_valid_index(thr, idx)); /* checked by caller */
 
-	ptr = (const void *) duk_get_buffer_data_raw(thr, idx, out_len, NULL /*def_ptr*/, 0 /*def_size*/, 0 /*throw_flag*/, &isbuffer);
+	ptr = (const void *)
+	    duk_get_buffer_data_raw(thr, idx, out_len, NULL /*def_ptr*/, 0 /*def_size*/, 0 /*throw_flag*/, &isbuffer);
 	if (isbuffer) {
 		DUK_ASSERT(ptr != NULL || *out_len == 0U);
 		if (DUK_UNLIKELY(ptr == NULL)) {
 			ptr = def_ptr;
 		}
 		DUK_ASSERT(ptr != NULL);
 	} else {
@@ -15120,56 +15824,56 @@
 /*
  *  Base64
  */
 
 #if defined(DUK_USE_BASE64_SUPPORT)
 /* Bytes emitted for number of padding characters in range [0,4]. */
 DUK_LOCAL const duk_int8_t duk__base64_decode_nequal_step[5] = {
-	3,   /* #### -> 24 bits, emit 3 bytes */
-	2,   /* ###= -> 18 bits, emit 2 bytes */
-	1,   /* ##== -> 12 bits, emit 1 byte */
-	-1,  /* #=== -> 6 bits, error */
-	0,   /* ==== -> 0 bits, emit 0 bytes */
+	3, /* #### -> 24 bits, emit 3 bytes */
+	2, /* ###= -> 18 bits, emit 2 bytes */
+	1, /* ##== -> 12 bits, emit 1 byte */
+	-1, /* #=== -> 6 bits, error */
+	0, /* ==== -> 0 bits, emit 0 bytes */
 };
 
 #if defined(DUK_USE_BASE64_FASTPATH)
 DUK_LOCAL const duk_uint8_t duk__base64_enctab_fast[64] = {
-	0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4aU, 0x4bU, 0x4cU, 0x4dU, 0x4eU, 0x4fU, 0x50U,  /* A...P */
-	0x51U, 0x52U, 0x53U, 0x54U, 0x55U, 0x56U, 0x57U, 0x58U, 0x59U, 0x5aU, 0x61U, 0x62U, 0x63U, 0x64U, 0x65U, 0x66U,  /* Q...f */
-	0x67U, 0x68U, 0x69U, 0x6aU, 0x6bU, 0x6cU, 0x6dU, 0x6eU, 0x6fU, 0x70U, 0x71U, 0x72U, 0x73U, 0x74U, 0x75U, 0x76U,  /* g...v */
-	0x77U, 0x78U, 0x79U, 0x7aU, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x2bU, 0x2fU   /* w.../ */
+	0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4aU, 0x4bU, 0x4cU, 0x4dU, 0x4eU, 0x4fU, 0x50U, /* A...P */
+	0x51U, 0x52U, 0x53U, 0x54U, 0x55U, 0x56U, 0x57U, 0x58U, 0x59U, 0x5aU, 0x61U, 0x62U, 0x63U, 0x64U, 0x65U, 0x66U, /* Q...f */
+	0x67U, 0x68U, 0x69U, 0x6aU, 0x6bU, 0x6cU, 0x6dU, 0x6eU, 0x6fU, 0x70U, 0x71U, 0x72U, 0x73U, 0x74U, 0x75U, 0x76U, /* g...v */
+	0x77U, 0x78U, 0x79U, 0x7aU, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x2bU, 0x2fU /* w.../ */
 };
-#endif  /* DUK_USE_BASE64_FASTPATH */
+#endif /* DUK_USE_BASE64_FASTPATH */
 
 #if defined(DUK_USE_BASE64_FASTPATH)
 /* Decode table for one byte of input:
  *   -1 = allowed whitespace
  *   -2 = padding
  *   -3 = error
  *    0...63 decoded bytes
  */
 DUK_LOCAL const duk_int8_t duk__base64_dectab_fast[256] = {
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -1, -1, -3, -3, -1, -3, -3,  /* 0x00...0x0f */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0x10...0x1f */
-	-1, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 62, -3, -3, -3, 63,  /* 0x20...0x2f */
-	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -3, -3, -3, -2, -3, -3,  /* 0x30...0x3f */
-	-3,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,  /* 0x40...0x4f */
-	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -3, -3, -3, -3, -3,  /* 0x50...0x5f */
-	-3, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,  /* 0x60...0x6f */
-	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -3, -3, -3, -3, -3,  /* 0x70...0x7f */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0x80...0x8f */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0x90...0x9f */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0xa0...0xaf */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0xb0...0xbf */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0xc0...0xcf */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0xd0...0xdf */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,  /* 0xe0...0xef */
-	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3   /* 0xf0...0xff */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -1, -1, -3, -3, -1, -3, -3, /* 0x00...0x0f */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0x10...0x1f */
+	-1, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 62, -3, -3, -3, 63, /* 0x20...0x2f */
+	52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -3, -3, -3, -2, -3, -3, /* 0x30...0x3f */
+	-3, 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, /* 0x40...0x4f */
+	15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -3, -3, -3, -3, -3, /* 0x50...0x5f */
+	-3, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, /* 0x60...0x6f */
+	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -3, -3, -3, -3, -3, /* 0x70...0x7f */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0x80...0x8f */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0x90...0x9f */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0xa0...0xaf */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0xb0...0xbf */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0xc0...0xcf */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0xd0...0xdf */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, /* 0xe0...0xef */
+	-3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3 /* 0xf0...0xff */
 };
-#endif  /* DUK_USE_BASE64_FASTPATH */
+#endif /* DUK_USE_BASE64_FASTPATH */
 
 #if defined(DUK_USE_BASE64_FASTPATH)
 DUK_LOCAL DUK_ALWAYS_INLINE void duk__base64_encode_fast_3(const duk_uint8_t *src, duk_uint8_t *dst) {
 	duk_uint_t t;
 
 	t = (duk_uint_t) src[0];
 	t = (t << 8) + (duk_uint_t) src[1];
@@ -15193,26 +15897,26 @@
 }
 
 DUK_LOCAL DUK_ALWAYS_INLINE void duk__base64_encode_fast_2(const duk_uint8_t *src, duk_uint8_t *dst) {
 	duk_uint_t t;
 
 	t = (duk_uint_t) src[0];
 	t = (t << 8) + (duk_uint_t) src[1];
-	dst[0] = duk__base64_enctab_fast[t >> 10];           /* XXXXXX-- -------- */
-	dst[1] = duk__base64_enctab_fast[(t >> 4) & 0x3fU];  /* ------XX XXXX---- */
-	dst[2] = duk__base64_enctab_fast[(t << 2) & 0x3fU];  /* -------- ----XXXX */
+	dst[0] = duk__base64_enctab_fast[t >> 10]; /* XXXXXX-- -------- */
+	dst[1] = duk__base64_enctab_fast[(t >> 4) & 0x3fU]; /* ------XX XXXX---- */
+	dst[2] = duk__base64_enctab_fast[(t << 2) & 0x3fU]; /* -------- ----XXXX */
 	dst[3] = DUK_ASC_EQUALS;
 }
 
 DUK_LOCAL DUK_ALWAYS_INLINE void duk__base64_encode_fast_1(const duk_uint8_t *src, duk_uint8_t *dst) {
 	duk_uint_t t;
 
 	t = (duk_uint_t) src[0];
-	dst[0] = duk__base64_enctab_fast[t >> 2];            /* XXXXXX-- */
-	dst[1] = duk__base64_enctab_fast[(t << 4) & 0x3fU];  /* ------XX */
+	dst[0] = duk__base64_enctab_fast[t >> 2]; /* XXXXXX-- */
+	dst[1] = duk__base64_enctab_fast[(t << 4) & 0x3fU]; /* ------XX */
 	dst[2] = DUK_ASC_EQUALS;
 	dst[3] = DUK_ASC_EQUALS;
 }
 
 DUK_LOCAL void duk__base64_encode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst) {
 	duk_size_t n;
 	const duk_uint8_t *p;
@@ -15252,32 +15956,32 @@
 		p += 3;
 		q += 4;
 		n -= 3U;
 	}
 	DUK_ASSERT(n == 0U || n == 1U || n == 2U);
 	if (n == 1U) {
 		duk__base64_encode_fast_1(p, q);
-#if 0  /* Unnecessary. */
+#if 0 /* Unnecessary. */
 		p += 1;
 		q += 4;
 		n -= 1U;
 #endif
 	} else if (n == 2U) {
 		duk__base64_encode_fast_2(p, q);
-#if 0  /* Unnecessary. */
+#if 0 /* Unnecessary. */
 		p += 2;
 		q += 4;
 		n -= 2U;
 #endif
 	} else {
-		DUK_ASSERT(n == 0U);  /* nothing to do */
+		DUK_ASSERT(n == 0U); /* nothing to do */
 		;
 	}
 }
-#else  /* DUK_USE_BASE64_FASTPATH */
+#else /* DUK_USE_BASE64_FASTPATH */
 DUK_LOCAL void duk__base64_encode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst) {
 	duk_small_uint_t i, npad;
 	duk_uint_t t, x, y;
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_end;
 	duk_uint8_t *q;
 
@@ -15341,32 +16045,35 @@
 	 */
 	DUK_ASSERT(npad <= 2U);
 	while (npad > 0U) {
 		*(q - npad) = DUK_ASC_EQUALS;
 		npad--;
 	}
 }
-#endif  /* DUK_USE_BASE64_FASTPATH */
+#endif /* DUK_USE_BASE64_FASTPATH */
 
 #if defined(DUK_USE_BASE64_FASTPATH)
-DUK_LOCAL duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst, duk_uint8_t **out_dst_final) {
+DUK_LOCAL duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src,
+                                               duk_size_t srclen,
+                                               duk_uint8_t *dst,
+                                               duk_uint8_t **out_dst_final) {
 	duk_int_t x;
 	duk_uint_t t;
 	duk_small_uint_t n_equal;
 	duk_int8_t step;
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_end;
 	const duk_uint8_t *p_end_safe;
 	duk_uint8_t *q;
 
-	DUK_ASSERT(src != NULL);  /* Required by pointer arithmetic below, which fails for NULL. */
+	DUK_ASSERT(src != NULL); /* Required by pointer arithmetic below, which fails for NULL. */
 
 	p = src;
 	p_end = src + srclen;
-	p_end_safe = p_end - 8;  /* If 'src <= src_end_safe', safe to read 8 bytes. */
+	p_end_safe = p_end - 8; /* If 'src <= src_end_safe', safe to read 8 bytes. */
 	q = dst;
 
 	/* Alternate between a fast path which processes clean groups with no
 	 * padding or whitespace, and a slow path which processes one arbitrary
 	 * group and then re-enters the fast path.  This handles e.g. base64
 	 * with newlines reasonably well because the majority of a line is in
 	 * the fast path.
@@ -15388,15 +16095,17 @@
 			 * bit of the accumulator will be set at the end and
 			 * we don't need to check every byte.
 			 *
 			 * Read all input bytes first before writing output
 			 * bytes to minimize aliasing.
 			 */
 			DUK_DDD(DUK_DDDPRINT("fast loop: p=%p, p_end_safe=%p, p_end=%p",
-			                     (const void *) p, (const void *) p_end_safe, (const void *) p_end));
+			                     (const void *) p,
+			                     (const void *) p_end_safe,
+			                     (const void *) p_end));
 
 			t1 = (duk_int_t) duk__base64_dectab_fast[p[0]];
 			t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[1]];
 			t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[2]];
 			t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[3]];
 
 			t2 = (duk_int_t) duk__base64_dectab_fast[p[4]];
@@ -15413,62 +16122,66 @@
 			q[5] = (duk_uint8_t) ((duk_uint_t) t2 & 0xffU);
 
 			/* Optimistic check using one branch. */
 			if (DUK_LIKELY((t1 | t2) >= 0)) {
 				p += 8;
 				q += 6;
 			} else if (t1 >= 0) {
-				DUK_DDD(DUK_DDDPRINT("fast loop first group was clean, second was not, process one slow path group"));
+				DUK_DDD(
+				    DUK_DDDPRINT("fast loop first group was clean, second was not, process one slow path group"));
 				DUK_ASSERT(t2 < 0);
 				p += 4;
 				q += 3;
 				break;
 			} else {
-				DUK_DDD(DUK_DDDPRINT("fast loop first group was not clean, second does not matter, process one slow path group"));
+				DUK_DDD(DUK_DDDPRINT(
+				    "fast loop first group was not clean, second does not matter, process one slow path group"));
 				DUK_ASSERT(t1 < 0);
 				break;
 			}
-		}  /* fast path */
+		} /* fast path */
 
 		/* Slow path step 1: try to scan a 4-character encoded group,
 		 * end-of-input, or start-of-padding.  We exit with:
 		 *   1. n_chars == 4: full group, no padding, no end-of-input.
 		 *   2. n_chars < 4: partial group (may also be 0), encountered
 		 *      padding or end of input.
 		 *
 		 * The accumulator is initialized to 1; this allows us to detect
 		 * a full group by comparing >= 0x1000000 without an extra
 		 * counter variable.
 		 */
 		t = 1UL;
 		for (;;) {
 			DUK_DDD(DUK_DDDPRINT("slow loop: p=%p, p_end=%p, t=%lu",
-			                     (const void *) p, (const void *) p_end, (unsigned long) t));
+			                     (const void *) p,
+			                     (const void *) p_end,
+			                     (unsigned long) t));
 
 			if (DUK_LIKELY(p < p_end)) {
 				x = duk__base64_dectab_fast[*p++];
 				if (DUK_LIKELY(x >= 0)) {
 					DUK_ASSERT(x >= 0 && x <= 63);
 					t = (t << 6) + (duk_uint_t) x;
 					if (t >= 0x1000000UL) {
 						break;
 					}
 				} else if (x == -1) {
-					continue;  /* allowed ascii whitespace */
+					continue; /* allowed ascii whitespace */
 				} else if (x == -2) {
 					p--;
-					break;  /* start of padding */
+					break; /* start of padding */
 				} else {
 					DUK_ASSERT(x == -3);
 					goto decode_error;
 				}
 			} else {
-				break;  /* end of input */
+				break; /* end of input */
 			}
-		}  /* slow path step 1 */
+		} /* slow path step 1 */
 
 		/* Complete the padding by simulating pad characters,
 		 * regardless of actual input padding chars.
 		 */
 		n_equal = 0;
 		while (t < 0x1000000UL) {
 			t = (t << 6) + 0U;
@@ -15519,36 +16232,38 @@
 
 		for (;;) {
 			if (DUK_UNLIKELY(p >= p_end)) {
 				goto done;
 			}
 			x = duk__base64_dectab_fast[*p++];
 			if (x == -1 || x == -2) {
-				;  /* padding or whitespace, keep eating */
+				; /* padding or whitespace, keep eating */
 			} else {
 				p--;
-				break;  /* backtrack and go back to fast path, even for -1 */
+				break; /* backtrack and go back to fast path, even for -1 */
 			}
-		}  /* slow path step 3 */
-	}  /* outer fast+slow path loop */
+		} /* slow path step 3 */
+	} /* outer fast+slow path loop */
 
- done:
-	DUK_DDD(DUK_DDDPRINT("done; p=%p, p_end=%p",
-	                     (const void *) p, (const void *) p_end));
+done:
+	DUK_DDD(DUK_DDDPRINT("done; p=%p, p_end=%p", (const void *) p, (const void *) p_end));
 
 	DUK_ASSERT(p == p_end);
 
 	*out_dst_final = q;
 	return 1;
 
- decode_error:
+decode_error:
 	return 0;
 }
-#else  /* DUK_USE_BASE64_FASTPATH */
-DUK_LOCAL duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst, duk_uint8_t **out_dst_final) {
+#else /* DUK_USE_BASE64_FASTPATH */
+DUK_LOCAL duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src,
+                                               duk_size_t srclen,
+                                               duk_uint8_t *dst,
+                                               duk_uint8_t **out_dst_final) {
 	duk_uint_t t, x;
 	duk_int_t y;
 	duk_int8_t step;
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_end;
 	duk_uint8_t *q;
 	/* 0x09, 0x0a, or 0x0d */
@@ -15626,15 +16341,15 @@
 				continue;
 			} else {
 				goto decode_error;
 			}
 		} else {
 			/* Valid: whitespace. */
 			duk_uint32_t m;
-			DUK_ASSERT(x < 0x20U);  /* 0x00 to 0x1f */
+			DUK_ASSERT(x < 0x20U); /* 0x00 to 0x1f */
 			m = (1U << x);
 			if (mask_white & m) {
 				/* Allow basic ASCII whitespace. */
 				continue;
 			} else {
 				goto decode_error;
 			}
@@ -15643,15 +16358,15 @@
 		DUK_ASSERT(y >= 0 && y <= 63);
 		t = (t << 6) + (duk_uint_t) y;
 		if (t < 0x1000000UL) {
 			continue;
 		}
 		/* fall through; no padding will be added */
 
-	 simulate_padding:
+	simulate_padding:
 		n_equal = 0;
 		while (t < 0x1000000UL) {
 			t = (t << 6) + 0U;
 			n_equal++;
 		}
 
 		/* Output 3 bytes from 't' and advance as needed. */
@@ -15675,18 +16390,18 @@
 		t = 1U;
 	}
 	DUK_ASSERT(t == 1UL);
 
 	*out_dst_final = q;
 	return 1;
 
- decode_error:
+decode_error:
 	return 0;
 }
-#endif  /* DUK_USE_BASE64_FASTPATH */
+#endif /* DUK_USE_BASE64_FASTPATH */
 
 DUK_EXTERNAL const char *duk_base64_encode(duk_hthread *thr, duk_idx_t idx) {
 	const duk_uint8_t *src;
 	duk_size_t srclen;
 	duk_size_t dstlen;
 	duk_uint8_t *dst;
 	const char *ret;
@@ -15707,19 +16422,19 @@
 		goto type_error;
 	}
 	dstlen = (srclen + 2U) / 3U * 4U;
 	dst = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, dstlen);
 
 	duk__base64_encode_helper((const duk_uint8_t *) src, srclen, dst);
 
-	ret = duk_buffer_to_string(thr, -1);  /* Safe, result is ASCII. */
+	ret = duk_buffer_to_string(thr, -1); /* Safe, result is ASCII. */
 	duk_replace(thr, idx);
 	return ret;
 
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_BASE64_ENCODE_FAILED);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 DUK_EXTERNAL void duk_base64_decode(duk_hthread *thr, duk_idx_t idx) {
 	const duk_uint8_t *src;
 	duk_size_t srclen;
@@ -15736,44 +16451,44 @@
 	/* Round up and add safety margin.  Avoid addition before division to
 	 * avoid possibility of wrapping.  Margin includes +3 for rounding up,
 	 * and +3 for one extra group: the decoder may emit and then backtrack
 	 * a full group (3 bytes) from zero-sized input for technical reasons.
 	 * Similarly, 'xx' may ecause 1+3 = bytes to be emitted and then
 	 * backtracked.
 	 */
-	dstlen = (srclen / 4) * 3 + 6;  /* upper limit, assuming no whitespace etc */
+	dstlen = (srclen / 4) * 3 + 6; /* upper limit, assuming no whitespace etc */
 	dst = (duk_uint8_t *) duk_push_dynamic_buffer(thr, dstlen);
 	/* Note: for dstlen=0, dst may be NULL */
 
 	if (!duk__base64_decode_helper((const duk_uint8_t *) src, srclen, dst, &dst_final)) {
 		goto type_error;
 	}
 
 	/* XXX: convert to fixed buffer? */
 	(void) duk_resize_buffer(thr, -1, (duk_size_t) (dst_final - dst));
 	duk_replace(thr, idx);
 	return;
 
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_BASE64_DECODE_FAILED);
 	DUK_WO_NORETURN(return;);
 }
-#else  /* DUK_USE_BASE64_SUPPORT */
+#else /* DUK_USE_BASE64_SUPPORT */
 DUK_EXTERNAL const char *duk_base64_encode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 DUK_EXTERNAL void duk_base64_decode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_BASE64_SUPPORT */
+#endif /* DUK_USE_BASE64_SUPPORT */
 
 /*
  *  Hex
  */
 
 #if defined(DUK_USE_HEX_SUPPORT)
 DUK_EXTERNAL const char *duk_hex_encode(duk_hthread *thr, duk_idx_t idx) {
@@ -15794,44 +16509,44 @@
 	DUK_ASSERT(inp != NULL);
 
 	/* Fixed buffer, no zeroing because we'll fill all the data. */
 	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len * 2);
 	DUK_ASSERT(buf != NULL);
 
 #if defined(DUK_USE_HEX_FASTPATH)
-	DUK_ASSERT((((duk_size_t) buf) & 0x01U) == 0);   /* pointer is aligned, guaranteed for fixed buffer */
+	DUK_ASSERT((((duk_size_t) buf) & 0x01U) == 0); /* pointer is aligned, guaranteed for fixed buffer */
 	p16 = (duk_uint16_t *) (void *) buf;
 	len_safe = len & ~0x03U;
 	for (i = 0; i < len_safe; i += 4) {
 		p16[0] = duk_hex_enctab[inp[i]];
 		p16[1] = duk_hex_enctab[inp[i + 1]];
 		p16[2] = duk_hex_enctab[inp[i + 2]];
 		p16[3] = duk_hex_enctab[inp[i + 3]];
 		p16 += 4;
 	}
 	for (; i < len; i++) {
 		*p16++ = duk_hex_enctab[inp[i]];
 	}
-#else  /* DUK_USE_HEX_FASTPATH */
+#else /* DUK_USE_HEX_FASTPATH */
 	for (i = 0; i < len; i++) {
 		duk_small_uint_t t;
 		t = (duk_small_uint_t) inp[i];
-		buf[i*2 + 0] = duk_lc_digits[t >> 4];
-		buf[i*2 + 1] = duk_lc_digits[t & 0x0f];
+		buf[i * 2 + 0] = duk_lc_digits[t >> 4];
+		buf[i * 2 + 1] = duk_lc_digits[t & 0x0f];
 	}
-#endif  /* DUK_USE_HEX_FASTPATH */
+#endif /* DUK_USE_HEX_FASTPATH */
 
 	/* XXX: Using a string return value forces a string intern which is
 	 * not always necessary.  As a rough performance measure, hex encode
 	 * time for tests/perf/test-hex-encode.js dropped from ~35s to ~15s
 	 * without string coercion.  Change to returning a buffer and let the
 	 * caller coerce to string if necessary?
 	 */
 
-	ret = duk_buffer_to_string(thr, -1);  /* Safe, result is ASCII. */
+	ret = duk_buffer_to_string(thr, -1); /* Safe, result is ASCII. */
 	duk_replace(thr, idx);
 	return ret;
 }
 
 DUK_EXTERNAL void duk_hex_decode(duk_hthread *thr, duk_idx_t idx) {
 	const duk_uint8_t *inp;
 	duk_size_t len;
@@ -15858,28 +16573,24 @@
 	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len / 2);
 	DUK_ASSERT(buf != NULL);
 
 #if defined(DUK_USE_HEX_FASTPATH)
 	p = buf;
 	len_safe = len & ~0x07U;
 	for (i = 0; i < len_safe; i += 8) {
-		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i]]) |
-		    ((duk_int_t) duk_hex_dectab[inp[i + 1]]);
+		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i]]) | ((duk_int_t) duk_hex_dectab[inp[i + 1]]);
 		chk = t;
 		p[0] = (duk_uint8_t) t;
-		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 2]]) |
-		    ((duk_int_t) duk_hex_dectab[inp[i + 3]]);
+		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 2]]) | ((duk_int_t) duk_hex_dectab[inp[i + 3]]);
 		chk |= t;
 		p[1] = (duk_uint8_t) t;
-		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 4]]) |
-		    ((duk_int_t) duk_hex_dectab[inp[i + 5]]);
+		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 4]]) | ((duk_int_t) duk_hex_dectab[inp[i + 5]]);
 		chk |= t;
 		p[2] = (duk_uint8_t) t;
-		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 6]]) |
-		    ((duk_int_t) duk_hex_dectab[inp[i + 7]]);
+		t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 6]]) | ((duk_int_t) duk_hex_dectab[inp[i + 7]]);
 		chk |= t;
 		p[3] = (duk_uint8_t) t;
 		p += 4;
 
 		/* Check if any lookup above had a negative result. */
 		if (DUK_UNLIKELY(chk < 0)) {
 			goto type_error;
@@ -15893,48 +16604,48 @@
 		t = (duk_int_t) ((((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i]]) << 4U) |
 		                 ((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i + 1]]));
 		if (DUK_UNLIKELY(t < 0)) {
 			goto type_error;
 		}
 		*p++ = (duk_uint8_t) t;
 	}
-#else  /* DUK_USE_HEX_FASTPATH */
+#else /* DUK_USE_HEX_FASTPATH */
 	for (i = 0; i < len; i += 2) {
 		/* For invalid characters the value -1 gets extended to
 		 * at least 16 bits.  If either nybble is invalid, the
 		 * resulting 't' will be < 0.
 		 */
 		t = (duk_int_t) ((((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i]]) << 4U) |
 		                 ((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i + 1]]));
 		if (DUK_UNLIKELY(t < 0)) {
 			goto type_error;
 		}
 		buf[i >> 1] = (duk_uint8_t) t;
 	}
-#endif  /* DUK_USE_HEX_FASTPATH */
+#endif /* DUK_USE_HEX_FASTPATH */
 
 	duk_replace(thr, idx);
 	return;
 
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_HEX_DECODE_FAILED);
 	DUK_WO_NORETURN(return;);
 }
-#else  /* DUK_USE_HEX_SUPPORT */
+#else /* DUK_USE_HEX_SUPPORT */
 DUK_EXTERNAL const char *duk_hex_encode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 DUK_EXTERNAL void duk_hex_decode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_HEX_SUPPORT */
+#endif /* DUK_USE_HEX_SUPPORT */
 
 /*
  *  JSON
  */
 
 #if defined(DUK_USE_JSON_SUPPORT)
 DUK_EXTERNAL const char *duk_json_encode(duk_hthread *thr, duk_idx_t idx) {
@@ -15970,47 +16681,44 @@
 
 	DUK_ASSERT_API_ENTRY(thr);
 #if defined(DUK_USE_ASSERTIONS)
 	top_at_entry = duk_get_top(thr);
 #endif
 
 	idx = duk_require_normalize_index(thr, idx);
-	duk_bi_json_parse_helper(thr,
-	                         idx /*idx_value*/,
-	                         DUK_INVALID_INDEX /*idx_reviver*/,
-	                         0 /*flags*/);
+	duk_bi_json_parse_helper(thr, idx /*idx_value*/, DUK_INVALID_INDEX /*idx_reviver*/, 0 /*flags*/);
 	duk_replace(thr, idx);
 
 	DUK_ASSERT(duk_get_top(thr) == top_at_entry);
 }
-#else  /* DUK_USE_JSON_SUPPORT */
+#else /* DUK_USE_JSON_SUPPORT */
 DUK_EXTERNAL const char *duk_json_encode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 DUK_EXTERNAL void duk_json_decode(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_JSON_SUPPORT */
+#endif /* DUK_USE_JSON_SUPPORT */
 #line 1 "duk_api_compile.c"
 /*
  *  Compilation and evaluation
  */
 
 /* #include duk_internal.h -> already included */
 
 typedef struct duk__compile_raw_args duk__compile_raw_args;
 struct duk__compile_raw_args {
-	duk_size_t src_length;  /* should be first on 64-bit platforms */
+	duk_size_t src_length; /* should be first on 64-bit platforms */
 	const duk_uint8_t *src_buffer;
 	duk_uint_t flags;
 };
 
 /* Eval is just a wrapper now. */
 DUK_EXTERNAL duk_int_t duk_eval_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
 	duk_int_t rc;
@@ -16022,35 +16730,38 @@
 	 * depends on whether we're running inside a Duktape/C activation
 	 * (= strict mode) or outside of any activation (= non-strict mode).
 	 * See tests/api/test-eval-strictness.c for more discussion.
 	 */
 
 	/* [ ... source? filename? ] (depends on flags) */
 
-	rc = duk_compile_raw(thr, src_buffer, src_length, flags | DUK_COMPILE_EVAL);  /* may be safe, or non-safe depending on flags */
+	rc = duk_compile_raw(thr,
+	                     src_buffer,
+	                     src_length,
+	                     flags | DUK_COMPILE_EVAL); /* may be safe, or non-safe depending on flags */
 
 	/* [ ... closure/error ] */
 
 	if (rc != DUK_EXEC_SUCCESS) {
 		rc = DUK_EXEC_ERROR;
 		goto got_rc;
 	}
 
-	duk_push_global_object(thr);  /* explicit 'this' binding, see GH-164 */
+	duk_push_global_object(thr); /* explicit 'this' binding, see GH-164 */
 
 	if (flags & DUK_COMPILE_SAFE) {
 		rc = duk_pcall_method(thr, 0);
 	} else {
 		duk_call_method(thr, 0);
 		rc = DUK_EXEC_SUCCESS;
 	}
 
 	/* [ ... result/error ] */
 
- got_rc:
+got_rc:
 	if (flags & DUK_COMPILE_NORESULT) {
 		duk_pop(thr);
 	}
 
 	return rc;
 }
 
@@ -16082,16 +16793,16 @@
 
 	/* [ ... source? filename ] */
 
 	if (!comp_args->src_buffer) {
 		duk_hstring *h_sourcecode;
 
 		h_sourcecode = duk_get_hstring(thr, -2);
-		if ((flags & DUK_COMPILE_NOSOURCE) ||  /* args incorrect */
-		    (h_sourcecode == NULL)) {          /* e.g. duk_push_string_file_raw() pushed undefined */
+		if ((flags & DUK_COMPILE_NOSOURCE) || /* args incorrect */
+		    (h_sourcecode == NULL)) { /* e.g. duk_push_string_file_raw() pushed undefined */
 			DUK_ERROR_TYPE(thr, DUK_STR_NO_SOURCECODE);
 			DUK_WO_NORETURN(return 0;);
 		}
 		DUK_ASSERT(h_sourcecode != NULL);
 		comp_args->src_buffer = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_sourcecode);
 		comp_args->src_length = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h_sourcecode);
 	}
@@ -16113,19 +16824,19 @@
 		duk_remove_m2(thr);
 	}
 
 	/* [ ... func_template ] */
 
 	h_templ = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 	duk_js_push_closure(thr,
-	                   h_templ,
-	                   thr->builtins[DUK_BIDX_GLOBAL_ENV],
-	                   thr->builtins[DUK_BIDX_GLOBAL_ENV],
-	                   1 /*add_auto_proto*/);
-	duk_remove_m2(thr);   /* -> [ ... closure ] */
+	                    h_templ,
+	                    thr->builtins[DUK_BIDX_GLOBAL_ENV],
+	                    thr->builtins[DUK_BIDX_GLOBAL_ENV],
+	                    1 /*add_auto_proto*/);
+	duk_remove_m2(thr); /* -> [ ... closure ] */
 
 	/* [ ... closure ] */
 
 	return 1;
 }
 
 DUK_EXTERNAL duk_int_t duk_compile_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
@@ -16153,16 +16864,15 @@
 		duk_int_t nrets = 1;
 
 		/* Arguments can be: [ source? filename? &comp_args] so that
 		 * nargs is 1 to 3.  Call site encodes the correct nargs count
 		 * directly into flags.
 		 */
 		nargs = flags & 0x07;
-		DUK_ASSERT(nargs == ((flags & DUK_COMPILE_NOSOURCE) ? 0 : 1) +
-		                    ((flags & DUK_COMPILE_NOFILENAME) ? 0 : 1));
+		DUK_ASSERT(nargs == ((flags & DUK_COMPILE_NOSOURCE) ? 0 : 1) + ((flags & DUK_COMPILE_NOFILENAME) ? 0 : 1));
 		rc = duk_safe_call(thr, duk__do_compile, (void *) comp_args, nargs, nrets);
 
 		/* [ ... closure ] */
 		return rc;
 	}
 
 	(void) duk__do_compile(thr, (void *) comp_args);
@@ -16195,33 +16905,32 @@
 		duk_put_prop_index(thr, -2, (duk_uarridx_t) idx);
 	}
 
 	/* XXX: conversion errors should not propagate outwards.
 	 * Perhaps values need to be coerced individually?
 	 */
 	duk_bi_json_stringify_helper(thr,
-	                             duk_get_top_index(thr),  /*idx_value*/
-	                             DUK_INVALID_INDEX,  /*idx_replacer*/
-	                             DUK_INVALID_INDEX,  /*idx_space*/
-	                             DUK_JSON_FLAG_EXT_CUSTOM |
-	                             DUK_JSON_FLAG_ASCII_ONLY |
-	                             DUK_JSON_FLAG_AVOID_KEY_QUOTES /*flags*/);
+	                             duk_get_top_index(thr), /*idx_value*/
+	                             DUK_INVALID_INDEX, /*idx_replacer*/
+	                             DUK_INVALID_INDEX, /*idx_space*/
+	                             DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_ASCII_ONLY |
+	                                 DUK_JSON_FLAG_AVOID_KEY_QUOTES /*flags*/);
 
 	duk_push_sprintf(thr, "ctx: top=%ld, stack=%s", (long) top, (const char *) duk_safe_to_string(thr, -1));
-	duk_replace(thr, -3);  /* [ ... arr jsonx(arr) res ] -> [ ... res jsonx(arr) ] */
+	duk_replace(thr, -3); /* [ ... arr jsonx(arr) res ] -> [ ... res jsonx(arr) ] */
 	duk_pop(thr);
 	DUK_ASSERT(duk_is_string(thr, -1));
 }
-#else  /* DUK_USE_JSON_SUPPORT */
+#else /* DUK_USE_JSON_SUPPORT */
 DUK_EXTERNAL void duk_push_context_dump(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_JSON_SUPPORT */
+#endif /* DUK_USE_JSON_SUPPORT */
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 
 DUK_EXTERNAL void duk_debugger_attach(duk_hthread *thr,
                                       duk_debug_read_function read_cb,
                                       duk_debug_write_function write_cb,
                                       duk_debug_peek_function peek_cb,
@@ -16262,20 +16971,21 @@
 	heap->dbg_force_restart = 0;
 	heap->dbg_pause_flags = 0;
 	heap->dbg_pause_act = NULL;
 	heap->dbg_pause_startline = 0;
 	heap->dbg_exec_counter = 0;
 	heap->dbg_last_counter = 0;
 	heap->dbg_last_time = 0.0;
-	duk_debug_set_paused(heap);  /* XXX: overlap with fields above */
+	duk_debug_set_paused(heap); /* XXX: overlap with fields above */
 
 	/* Send version identification and flush right afterwards.  Note that
 	 * we must write raw, unframed bytes here.
 	 */
-	duk_push_sprintf(thr, "%ld %ld %s %s\n",
+	duk_push_sprintf(thr,
+	                 "%ld %ld %s %s\n",
 	                 (long) DUK_DEBUG_PROTOCOL_VERSION,
 	                 (long) DUK_VERSION,
 	                 (const char *) DUK_GIT_DESCRIBE,
 	                 (const char *) DUK_USE_TARGET_INFO);
 	str = duk_get_lstring(thr, -1, &len);
 	DUK_ASSERT(str != NULL);
 	duk_debug_write_bytes(thr, (const duk_uint8_t *) str, len);
@@ -16369,15 +17079,15 @@
 			 */
 			thr->interrupt_init = 1;
 			thr->interrupt_counter = 0;
 		}
 	}
 }
 
-#else  /* DUK_USE_DEBUGGER_SUPPORT */
+#else /* DUK_USE_DEBUGGER_SUPPORT */
 
 DUK_EXTERNAL void duk_debugger_attach(duk_hthread *thr,
                                       duk_debug_read_function read_cb,
                                       duk_debug_write_function write_cb,
                                       duk_debug_peek_function peek_cb,
                                       duk_debug_read_flush_function read_flush_cb,
                                       duk_debug_write_flush_function write_flush_cb,
@@ -16427,15 +17137,15 @@
 
 DUK_EXTERNAL void duk_debugger_pause(duk_hthread *thr) {
 	/* Treat like debugger statement: nop */
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(thr);
 }
 
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 #line 1 "duk_api_heap.c"
 /*
  *  Heap creation and destruction
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -16516,15 +17226,15 @@
 DUK_EXTERNAL void duk_suspend(duk_hthread *thr, duk_thread_state *state) {
 	duk_internal_thread_state *snapshot = (duk_internal_thread_state *) (void *) state;
 	duk_heap *heap;
 	duk_ljstate *lj;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->heap != NULL);
-	DUK_ASSERT(state != NULL);  /* unvalidated */
+	DUK_ASSERT(state != NULL); /* unvalidated */
 
 	/* Currently not supported when called from within a finalizer.
 	 * If that is done, the finalizer will remain running indefinitely,
 	 * preventing other finalizers from executing.  The assert is a bit
 	 * wider, checking that it would be OK to run pending finalizers.
 	 */
 	DUK_ASSERT(thr->heap->pf_prevent_count == 0);
@@ -16560,15 +17270,15 @@
 
 DUK_EXTERNAL void duk_resume(duk_hthread *thr, const duk_thread_state *state) {
 	const duk_internal_thread_state *snapshot = (const duk_internal_thread_state *) (const void *) state;
 	duk_heap *heap;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->heap != NULL);
-	DUK_ASSERT(state != NULL);  /* unvalidated */
+	DUK_ASSERT(state != NULL); /* unvalidated */
 
 	/* Shouldn't be necessary if duk_suspend() is called before
 	 * duk_resume(), but assert in case API sequence is incorrect.
 	 */
 	DUK_ASSERT(thr->heap->pf_prevent_count == 0);
 	DUK_ASSERT(thr->heap->creating_error == 0);
 
@@ -16602,44 +17312,42 @@
 	 *  Replace global object.
 	 */
 
 	h_prev_glob = thr->builtins[DUK_BIDX_GLOBAL];
 	DUK_UNREF(h_prev_glob);
 	thr->builtins[DUK_BIDX_GLOBAL] = h_glob;
 	DUK_HOBJECT_INCREF(thr, h_glob);
-	DUK_HOBJECT_DECREF_ALLOWNULL(thr, h_prev_glob);  /* side effects, in theory (referenced by global env) */
+	DUK_HOBJECT_DECREF_ALLOWNULL(thr, h_prev_glob); /* side effects, in theory (referenced by global env) */
 
 	/*
 	 *  Replace lexical environment for global scope
 	 *
 	 *  Create a new object environment for the global lexical scope.
 	 *  We can't just reset the _Target property of the current one,
 	 *  because the lexical scope is shared by other threads with the
 	 *  same (initial) built-ins.
 	 */
 
-	h_env = duk_hobjenv_alloc(thr,
-	                          DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                          DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
+	h_env = duk_hobjenv_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
 	DUK_ASSERT(h_env != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) h_env) == NULL);
 
 	DUK_ASSERT(h_env->target == NULL);
 	DUK_ASSERT(h_glob != NULL);
 	h_env->target = h_glob;
 	DUK_HOBJECT_INCREF(thr, h_glob);
 	DUK_ASSERT(h_env->has_this == 0);
 
 	/* [ ... new_glob ] */
 
 	h_prev_env = thr->builtins[DUK_BIDX_GLOBAL_ENV];
 	thr->builtins[DUK_BIDX_GLOBAL_ENV] = (duk_hobject *) h_env;
 	DUK_HOBJECT_INCREF(thr, (duk_hobject *) h_env);
-	DUK_HOBJECT_DECREF_ALLOWNULL(thr, h_prev_env);  /* side effects */
-	DUK_UNREF(h_env);  /* without refcounts */
+	DUK_HOBJECT_DECREF_ALLOWNULL(thr, h_prev_env); /* side effects */
+	DUK_UNREF(h_env); /* without refcounts */
 	DUK_UNREF(h_prev_env);
 
 	/* [ ... new_glob ] */
 
 	duk_pop(thr);
 
 	/* [ ... ] */
@@ -16682,51 +17390,51 @@
  * The return value is an object with properties that are version specific.
  * The properties must not expose anything that would lead to security
  * issues (e.g. exposing compiled function 'data' buffer might be an issue).
  * Currently only counts and sizes and such are given so there shouldn't
  * be security implications.
  */
 
-#define DUK__IDX_TYPE     0
-#define DUK__IDX_ITAG     1
-#define DUK__IDX_REFC     2
-#define DUK__IDX_HBYTES   3
-#define DUK__IDX_CLASS    4
-#define DUK__IDX_PBYTES   5
-#define DUK__IDX_ESIZE    6
-#define DUK__IDX_ENEXT    7
-#define DUK__IDX_ASIZE    8
-#define DUK__IDX_HSIZE    9
-#define DUK__IDX_BCBYTES  10
-#define DUK__IDX_DBYTES   11
-#define DUK__IDX_TSTATE   12
-#define DUK__IDX_VARIANT  13
+#define DUK__IDX_TYPE    0
+#define DUK__IDX_ITAG    1
+#define DUK__IDX_REFC    2
+#define DUK__IDX_HBYTES  3
+#define DUK__IDX_CLASS   4
+#define DUK__IDX_PBYTES  5
+#define DUK__IDX_ESIZE   6
+#define DUK__IDX_ENEXT   7
+#define DUK__IDX_ASIZE   8
+#define DUK__IDX_HSIZE   9
+#define DUK__IDX_BCBYTES 10
+#define DUK__IDX_DBYTES  11
+#define DUK__IDX_TSTATE  12
+#define DUK__IDX_VARIANT 13
 
 DUK_EXTERNAL void duk_inspect_value(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 	duk_heaphdr *h;
 	/* The temporary values should be in an array rather than individual
 	 * variables which (in practice) ensures that the compiler won't map
 	 * them to registers and emit a lot of unnecessary shuffling code.
 	 */
 	duk_int_t vals[14];
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	/* Assume two's complement and set everything to -1. */
 	duk_memset((void *) &vals, (int) 0xff, sizeof(vals));
-	DUK_ASSERT(vals[DUK__IDX_TYPE] == -1);  /* spot check one */
+	DUK_ASSERT(vals[DUK__IDX_TYPE] == -1); /* spot check one */
 
 	tv = duk_get_tval_or_unused(thr, idx);
 	h = (DUK_TVAL_IS_HEAP_ALLOCATED(tv) ? DUK_TVAL_GET_HEAPHDR(tv) : NULL);
 
 	vals[DUK__IDX_TYPE] = duk_get_type_tval(tv);
 	vals[DUK__IDX_ITAG] = (duk_int_t) DUK_TVAL_GET_TAG(tv);
 
-	duk_push_bare_object(thr);  /* Invalidates 'tv'. */
+	duk_push_bare_object(thr); /* Invalidates 'tv'. */
 	tv = NULL;
 
 	if (h == NULL) {
 		goto finish;
 	}
 	duk_push_pointer(thr, (void *) h);
 	duk_put_prop_literal(thr, -2, "hptr");
@@ -16800,38 +17508,64 @@
 		break;
 	}
 	case DUK_HTYPE_BUFFER: {
 		duk_hbuffer *h_buf = (duk_hbuffer *) h;
 
 		if (DUK_HBUFFER_HAS_DYNAMIC(h_buf)) {
 			if (DUK_HBUFFER_HAS_EXTERNAL(h_buf)) {
-				vals[DUK__IDX_VARIANT] = 2;  /* buffer variant 2: external */
+				vals[DUK__IDX_VARIANT] = 2; /* buffer variant 2: external */
 				vals[DUK__IDX_HBYTES] = (duk_uint_t) (sizeof(duk_hbuffer_external));
 			} else {
 				/* When alloc_size == 0 the second allocation may not
 				 * actually exist.
 				 */
-				vals[DUK__IDX_VARIANT] = 1;  /* buffer variant 1: dynamic */
+				vals[DUK__IDX_VARIANT] = 1; /* buffer variant 1: dynamic */
 				vals[DUK__IDX_HBYTES] = (duk_uint_t) (sizeof(duk_hbuffer_dynamic));
 			}
 			vals[DUK__IDX_DBYTES] = (duk_int_t) (DUK_HBUFFER_GET_SIZE(h_buf));
 		} else {
-			DUK_ASSERT(vals[DUK__IDX_VARIANT] == 0);  /* buffer variant 0: fixed */
+			DUK_ASSERT(vals[DUK__IDX_VARIANT] == 0); /* buffer variant 0: fixed */
 			vals[DUK__IDX_HBYTES] = (duk_int_t) (sizeof(duk_hbuffer_fixed) + DUK_HBUFFER_GET_SIZE(h_buf));
 		}
 		break;
 	}
 	}
 
- finish:
+finish:
 	duk__inspect_multiple_uint(thr,
-	    "type" "\x00" "itag" "\x00" "refc" "\x00" "hbytes" "\x00" "class" "\x00"
-	    "pbytes" "\x00" "esize" "\x00" "enext" "\x00" "asize" "\x00" "hsize" "\x00"
-	    "bcbytes" "\x00" "dbytes" "\x00" "tstate" "\x00" "variant" "\x00" "\x00",
-	    (duk_int_t *) &vals);
+	                           "type"
+	                           "\x00"
+	                           "itag"
+	                           "\x00"
+	                           "refc"
+	                           "\x00"
+	                           "hbytes"
+	                           "\x00"
+	                           "class"
+	                           "\x00"
+	                           "pbytes"
+	                           "\x00"
+	                           "esize"
+	                           "\x00"
+	                           "enext"
+	                           "\x00"
+	                           "asize"
+	                           "\x00"
+	                           "hsize"
+	                           "\x00"
+	                           "bcbytes"
+	                           "\x00"
+	                           "dbytes"
+	                           "\x00"
+	                           "tstate"
+	                           "\x00"
+	                           "variant"
+	                           "\x00"
+	                           "\x00",
+	                           (duk_int_t *) &vals);
 }
 
 DUK_EXTERNAL void duk_inspect_callstack_entry(duk_hthread *thr, duk_int_t level) {
 	duk_activation *act;
 	duk_uint_fast32_t pc;
 	duk_uint_fast32_t line;
 
@@ -16963,15 +17697,15 @@
 	duk_small_uint_t ms_flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	heap = thr->heap;
 	DUK_ASSERT(heap != NULL);
 
 	DUK_D(DUK_DPRINT("mark-and-sweep requested by application"));
-	DUK_ASSERT(DUK_GC_COMPACT == DUK_MS_FLAG_EMERGENCY);  /* Compact flag is 1:1 with emergency flag which forces compaction. */
+	DUK_ASSERT(DUK_GC_COMPACT == DUK_MS_FLAG_EMERGENCY); /* Compact flag is 1:1 with emergency flag which forces compaction. */
 	ms_flags = (duk_small_uint_t) flags;
 	duk_heap_mark_and_sweep(heap, ms_flags);
 }
 #line 1 "duk_api_object.c"
 /*
  *  Object handling: property access and other support functions.
  */
@@ -17000,17 +17734,17 @@
 	tv_obj = duk_require_tval(thr, obj_idx);
 	tv_key = duk_require_tval(thr, -1);
 
 	rc = duk_hobject_getprop(thr, tv_obj, tv_key);
 	DUK_ASSERT(rc == 0 || rc == 1);
 	/* a value is left on stack regardless of rc */
 
-	duk_remove_m2(thr);  /* remove key */
+	duk_remove_m2(thr); /* remove key */
 	DUK_ASSERT(duk_is_undefined(thr, -1) || rc == 1);
-	return rc;  /* 1 if property found, 0 otherwise */
+	return rc; /* 1 if property found, 0 otherwise */
 }
 
 DUK_EXTERNAL duk_bool_t duk_get_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(key != NULL);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
@@ -17047,33 +17781,35 @@
 	return duk_get_prop(thr, obj_idx);
 }
 
 DUK_EXTERNAL duk_bool_t duk_get_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
-	(void) duk_push_heapptr(thr, ptr);  /* NULL -> 'undefined' */
+	(void) duk_push_heapptr(thr, ptr); /* NULL -> 'undefined' */
 	return duk_get_prop(thr, obj_idx);
 }
 
 DUK_INTERNAL duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
 	(void) duk_push_hstring(thr, DUK_HTHREAD_GET_STRING(thr, stridx));
 	return duk_get_prop(thr, obj_idx);
 }
 
 DUK_INTERNAL duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
-	return duk_get_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16),
-	                                (duk_small_uint_t) (packed_args & 0xffffUL));
+	return duk_get_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16), (duk_small_uint_t) (packed_args & 0xffffUL));
 }
 
-DUK_INTERNAL duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_bool_t *out_has_prop) {
+DUK_INTERNAL duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr,
+                                                    duk_idx_t obj_idx,
+                                                    duk_small_uint_t stridx,
+                                                    duk_bool_t *out_has_prop) {
 	duk_bool_t rc;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
 	rc = duk_get_prop_stridx(thr, obj_idx, stridx);
 	if (out_has_prop) {
@@ -17110,30 +17846,31 @@
 
 	tv_val = duk_hobject_find_entry_tval_ptr(thr->heap, h_obj, h_key);
 	if (tv_val == NULL) {
 		return 0;
 	}
 
 	duk_push_tval(thr, tv_val);
-	duk_remove_m2(thr);  /* remove key */
+	duk_remove_m2(thr); /* remove key */
 
 	return 1;
 }
 
 DUK_INTERNAL duk_bool_t duk_xget_owndataprop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
 	(void) duk_push_hstring(thr, DUK_HTHREAD_GET_STRING(thr, stridx));
 	return duk_xget_owndataprop(thr, obj_idx);
 }
 
 DUK_INTERNAL duk_bool_t duk_xget_owndataprop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
-	return duk_xget_owndataprop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16),
+	return duk_xget_owndataprop_stridx(thr,
+	                                   (duk_idx_t) (duk_int16_t) (packed_args >> 16),
 	                                   (duk_small_uint_t) (packed_args & 0xffffUL));
 }
 
 DUK_LOCAL duk_bool_t duk__put_prop_shared(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t idx_key) {
 	duk_tval *tv_obj;
 	duk_tval *tv_key;
 	duk_tval *tv_val;
@@ -17144,27 +17881,26 @@
 	 * resize is not necessary for a property put right now (putprop protects
 	 * against it internally).
 	 */
 
 	/* Key and value indices are either (-2, -1) or (-1, -2).  Given idx_key,
 	 * idx_val is always (idx_key ^ 0x01).
 	 */
-	DUK_ASSERT((idx_key == -2 && (idx_key ^ 1) == -1) ||
-	           (idx_key == -1 && (idx_key ^ 1) == -2));
+	DUK_ASSERT((idx_key == -2 && (idx_key ^ 1) == -1) || (idx_key == -1 && (idx_key ^ 1) == -2));
 	/* XXX: Direct access; faster validation. */
 	tv_obj = duk_require_tval(thr, obj_idx);
 	tv_key = duk_require_tval(thr, idx_key);
 	tv_val = duk_require_tval(thr, idx_key ^ 1);
 	throw_flag = duk_is_strict_call(thr);
 
 	rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, throw_flag);
 	DUK_ASSERT(rc == 0 || rc == 1);
 
-	duk_pop_2(thr);  /* remove key and value */
-	return rc;  /* 1 if property found, 0 otherwise */
+	duk_pop_2(thr); /* remove key and value */
+	return rc; /* 1 if property found, 0 otherwise */
 }
 
 DUK_EXTERNAL duk_bool_t duk_put_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk__put_prop_shared(thr, obj_idx, -2);
 }
 
@@ -17210,31 +17946,29 @@
 	return duk__put_prop_shared(thr, obj_idx, -1);
 }
 
 DUK_EXTERNAL duk_bool_t duk_put_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
-	(void) duk_push_heapptr(thr, ptr);  /* NULL -> 'undefined' */
+	(void) duk_push_heapptr(thr, ptr); /* NULL -> 'undefined' */
 	return duk__put_prop_shared(thr, obj_idx, -1);
 }
 
-
 DUK_INTERNAL duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
 	duk_push_hstring(thr, DUK_HTHREAD_GET_STRING(thr, stridx));
 	return duk__put_prop_shared(thr, obj_idx, -1);
 }
 
 DUK_INTERNAL duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
-	return duk_put_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16),
-	                                (duk_small_uint_t) (packed_args & 0xffffUL));
+	return duk_put_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16), (duk_small_uint_t) (packed_args & 0xffffUL));
 }
 
 DUK_EXTERNAL duk_bool_t duk_del_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 	duk_tval *tv_obj;
 	duk_tval *tv_key;
 	duk_bool_t throw_flag;
 	duk_bool_t rc;
@@ -17248,15 +17982,15 @@
 	tv_obj = duk_require_tval(thr, obj_idx);
 	tv_key = duk_require_tval(thr, -1);
 	throw_flag = duk_is_strict_call(thr);
 
 	rc = duk_hobject_delprop(thr, tv_obj, tv_key, throw_flag);
 	DUK_ASSERT(rc == 0 || rc == 1);
 
-	duk_pop(thr);  /* remove key */
+	duk_pop(thr); /* remove key */
 	return rc;
 }
 
 DUK_EXTERNAL duk_bool_t duk_del_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(key != NULL);
 
@@ -17294,15 +18028,15 @@
 	return duk_del_prop(thr, obj_idx);
 }
 
 DUK_EXTERNAL duk_bool_t duk_del_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
-	(void) duk_push_heapptr(thr, ptr);  /* NULL -> 'undefined' */
+	(void) duk_push_heapptr(thr, ptr); /* NULL -> 'undefined' */
 	return duk_del_prop(thr, obj_idx);
 }
 
 DUK_INTERNAL duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
@@ -17331,16 +18065,16 @@
 
 	tv_obj = duk_require_tval(thr, obj_idx);
 	tv_key = duk_require_tval(thr, -1);
 
 	rc = duk_hobject_hasprop(thr, tv_obj, tv_key);
 	DUK_ASSERT(rc == 0 || rc == 1);
 
-	duk_pop(thr);  /* remove key */
-	return rc;  /* 1 if property found, 0 otherwise */
+	duk_pop(thr); /* remove key */
+	return rc; /* 1 if property found, 0 otherwise */
 }
 
 DUK_EXTERNAL duk_bool_t duk_has_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(key != NULL);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
@@ -17377,15 +18111,15 @@
 	return duk_has_prop(thr, obj_idx);
 }
 
 DUK_EXTERNAL duk_bool_t duk_has_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
-	(void) duk_push_heapptr(thr, ptr);  /* NULL -> 'undefined' */
+	(void) duk_push_heapptr(thr, ptr); /* NULL -> 'undefined' */
 	return duk_has_prop(thr, obj_idx);
 }
 
 DUK_INTERNAL duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 
@@ -17416,15 +18150,15 @@
 	DUK_ASSERT(obj != NULL);
 	key = duk_to_property_key_hstring(thr, -2);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(duk_require_tval(thr, -1) != NULL);
 
 	duk_hobject_define_property_internal(thr, obj, key, desc_flags);
 
-	duk_pop(thr);  /* pop key */
+	duk_pop(thr); /* pop key */
 }
 
 DUK_INTERNAL void duk_xdef_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx, duk_small_uint_t desc_flags) {
 	duk_hobject *obj;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -17449,20 +18183,21 @@
 	DUK_ASSERT(duk_require_tval(thr, -1) != NULL);
 
 	duk_hobject_define_property_internal(thr, obj, key, desc_flags);
 	/* value popped by call */
 }
 
 DUK_INTERNAL void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
-	duk_xdef_prop_stridx(thr, (duk_idx_t) (duk_int8_t) (packed_args >> 24),
-	                          (duk_small_uint_t) (packed_args >> 8) & 0xffffUL,
-	                          (duk_small_uint_t) (packed_args & 0xffL));
+	duk_xdef_prop_stridx(thr,
+	                     (duk_idx_t) (duk_int8_t) (packed_args >> 24),
+	                     (duk_small_uint_t) (packed_args >> 8) & 0xffffUL,
+	                     (duk_small_uint_t) (packed_args & 0xffL));
 }
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL void duk_xdef_prop_stridx_builtin(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_int_t builtin_idx, duk_small_uint_t desc_flags) {
 	duk_hobject *obj;
 	duk_hstring *key;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT_STRIDX_VALID(stridx);
 	DUK_ASSERT_BIDX_VALID(builtin_idx);
@@ -17486,23 +18221,23 @@
 DUK_INTERNAL void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
 	duk_push_hstring_stridx(thr, stridx);
 	duk_push_hobject_bidx(thr, DUK_BIDX_TYPE_ERROR_THROWER);
 	duk_dup_top(thr);
-	duk_def_prop(thr, obj_idx, DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_FORCE);  /* attributes always 0 */
+	duk_def_prop(thr, obj_idx, DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_FORCE); /* attributes always 0 */
 }
 
 /* Object.getOwnPropertyDescriptor() equivalent C binding. */
 DUK_EXTERNAL void duk_get_prop_desc(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_UNREF(flags);  /* no flags defined yet */
+	DUK_UNREF(flags); /* no flags defined yet */
 
-	duk_hobject_object_get_own_property_descriptor(thr, obj_idx);  /* [ ... key ] -> [ ... desc ] */
+	duk_hobject_object_get_own_property_descriptor(thr, obj_idx); /* [ ... key ] -> [ ... desc ] */
 }
 
 /* Object.defineProperty() equivalent C binding. */
 DUK_EXTERNAL void duk_def_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 	duk_idx_t idx_base;
 	duk_hobject *obj;
 	duk_hstring *key;
@@ -17524,29 +18259,25 @@
 		 * time.
 		 */
 		goto fail_invalid_desc;
 	}
 
 	idx_base = duk_get_top_index(thr);
 	if (flags & DUK_DEFPROP_HAVE_SETTER) {
-		duk_require_type_mask(thr, idx_base, DUK_TYPE_MASK_UNDEFINED |
-		                                     DUK_TYPE_MASK_OBJECT |
-		                                     DUK_TYPE_MASK_LIGHTFUNC);
+		duk_require_type_mask(thr, idx_base, DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC);
 		set = duk_get_hobject_promote_lfunc(thr, idx_base);
 		if (set != NULL && !DUK_HOBJECT_IS_CALLABLE(set)) {
 			goto fail_not_callable;
 		}
 		idx_base--;
 	} else {
 		set = NULL;
 	}
 	if (flags & DUK_DEFPROP_HAVE_GETTER) {
-		duk_require_type_mask(thr, idx_base, DUK_TYPE_MASK_UNDEFINED |
-		                                     DUK_TYPE_MASK_OBJECT |
-		                                     DUK_TYPE_MASK_LIGHTFUNC);
+		duk_require_type_mask(thr, idx_base, DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC);
 		get = duk_get_hobject_promote_lfunc(thr, idx_base);
 		if (get != NULL && !DUK_HOBJECT_IS_CALLABLE(get)) {
 			goto fail_not_callable;
 		}
 		idx_base--;
 	} else {
 		get = NULL;
@@ -17558,36 +18289,29 @@
 		idx_value = (duk_idx_t) -1;
 	}
 	key = duk_to_property_key_hstring(thr, idx_base);
 	DUK_ASSERT(key != NULL);
 
 	duk_require_valid_index(thr, idx_base);
 
-	duk_hobject_define_property_helper(thr,
-	                                   flags /*defprop_flags*/,
-	                                   obj,
-	                                   key,
-	                                   idx_value,
-	                                   get,
-	                                   set,
-	                                   1 /*throw_flag*/);
+	duk_hobject_define_property_helper(thr, flags /*defprop_flags*/, obj, key, idx_value, get, set, 1 /*throw_flag*/);
 
 	/* Clean up stack */
 
 	duk_set_top(thr, idx_base);
 
 	/* [ ... obj ... ] */
 
 	return;
 
- fail_invalid_desc:
+fail_invalid_desc:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_DESCRIPTOR);
 	DUK_WO_NORETURN(return;);
 
- fail_not_callable:
+fail_not_callable:
 	DUK_ERROR_TYPE(thr, DUK_STR_NOT_CALLABLE);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Object related
  */
@@ -17613,15 +18337,15 @@
 /* XXX: the duk_hobject_enum.c stack APIs should be reworked */
 
 DUK_EXTERNAL void duk_enum(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t enum_flags) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_dup(thr, obj_idx);
 	duk_require_hobject_promote_mask(thr, -1, DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER);
-	duk_hobject_enumerator_create(thr, enum_flags);   /* [target] -> [enum] */
+	duk_hobject_enumerator_create(thr, enum_flags); /* [target] -> [enum] */
 }
 
 DUK_EXTERNAL duk_bool_t duk_next(duk_hthread *thr, duk_idx_t enum_index, duk_bool_t get_value) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_require_hobject(thr, enum_index);
 	duk_dup(thr, enum_index);
@@ -17674,16 +18398,16 @@
 		break;
 	default:
 		/* ES2015 Sections 19.1.2.5, 19.1.2.17 */
 		break;
 	}
 	return;
 
- fail_cannot_freeze:
-	DUK_ERROR_TYPE_INVALID_ARGS(thr);  /* XXX: proper error message */
+fail_cannot_freeze:
+	DUK_ERROR_TYPE_INVALID_ARGS(thr); /* XXX: proper error message */
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_seal(duk_hthread *thr, duk_idx_t obj_idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_seal_freeze_raw(thr, obj_idx, 0 /*is_freeze*/);
@@ -17720,16 +18444,16 @@
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj_idx = duk_require_normalize_index(thr, obj_idx);
 	if (ent != NULL) {
 		while (ent->key != NULL) {
 			tv = thr->valstack_top++;
-			DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv));  /* value stack init policy */
-			DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, ent->value);  /* no need for decref/incref */
+			DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv)); /* value stack init policy */
+			DUK_TVAL_SET_NUMBER_CHKFAST_SLOW(tv, ent->value); /* no need for decref/incref */
 			duk_put_prop_string(thr, obj_idx, ent->key);
 			ent++;
 		}
 	}
 }
 
 /*
@@ -17791,41 +18515,40 @@
 
 	duk_push_hobject(thr, thr->builtins[DUK_BIDX_GLOBAL]);
 	ret = duk_get_prop_heapptr(thr, -1, ptr);
 	duk_remove_m2(thr);
 	return ret;
 }
 
-
 DUK_EXTERNAL duk_bool_t duk_put_global_string(duk_hthread *thr, const char *key) {
 	duk_bool_t ret;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
 
 	/* XXX: direct implementation */
 
 	duk_push_hobject(thr, thr->builtins[DUK_BIDX_GLOBAL]);
 	duk_insert(thr, -2);
-	ret = duk_put_prop_string(thr, -2, key);  /* [ ... global val ] -> [ ... global ] */
+	ret = duk_put_prop_string(thr, -2, key); /* [ ... global val ] -> [ ... global ] */
 	duk_pop(thr);
 	return ret;
 }
 
 DUK_EXTERNAL duk_bool_t duk_put_global_lstring(duk_hthread *thr, const char *key, duk_size_t key_len) {
 	duk_bool_t ret;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
 
 	/* XXX: direct implementation */
 
 	duk_push_hobject(thr, thr->builtins[DUK_BIDX_GLOBAL]);
 	duk_insert(thr, -2);
-	ret = duk_put_prop_lstring(thr, -2, key, key_len);  /* [ ... global val ] -> [ ... global ] */
+	ret = duk_put_prop_lstring(thr, -2, key, key_len); /* [ ... global val ] -> [ ... global ] */
 	duk_pop(thr);
 	return ret;
 }
 
 #if !defined(DUK_USE_PREFER_SIZE)
 DUK_EXTERNAL duk_bool_t duk_put_global_literal_raw(duk_hthread *thr, const char *key, duk_size_t key_len) {
 	duk_bool_t ret;
@@ -17834,15 +18557,15 @@
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
 	DUK_ASSERT(key[key_len] == (char) 0);
 
 	/* XXX: direct implementation */
 
 	duk_push_hobject(thr, thr->builtins[DUK_BIDX_GLOBAL]);
 	duk_insert(thr, -2);
-	ret = duk_put_prop_literal_raw(thr, -2, key, key_len);  /* [ ... global val ] -> [ ... global ] */
+	ret = duk_put_prop_literal_raw(thr, -2, key, key_len); /* [ ... global val ] -> [ ... global ] */
 	duk_pop(thr);
 	return ret;
 }
 #endif
 
 DUK_EXTERNAL duk_bool_t duk_put_global_heapptr(duk_hthread *thr, void *ptr) {
 	duk_bool_t ret;
@@ -17850,15 +18573,15 @@
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
 
 	/* XXX: direct implementation */
 
 	duk_push_hobject(thr, thr->builtins[DUK_BIDX_GLOBAL]);
 	duk_insert(thr, -2);
-	ret = duk_put_prop_heapptr(thr, -2, ptr);  /* [ ... global val ] -> [ ... global ] */
+	ret = duk_put_prop_heapptr(thr, -2, ptr); /* [ ... global val ] -> [ ... global ] */
 	duk_pop(thr);
 	return ret;
 }
 
 /*
  *  ES2015 GetMethod()
  */
@@ -17902,22 +18625,21 @@
 	duk_hobject *obj;
 	duk_hobject *proto;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj = duk_require_hobject(thr, idx);
 	DUK_ASSERT(obj != NULL);
-	duk_require_type_mask(thr, -1, DUK_TYPE_MASK_UNDEFINED |
-	                               DUK_TYPE_MASK_OBJECT);
+	duk_require_type_mask(thr, -1, DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_OBJECT);
 	proto = duk_get_hobject(thr, -1);
 	/* proto can also be NULL here (allowed explicitly) */
 
 #if defined(DUK_USE_ROM_OBJECTS)
 	if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj)) {
-		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);  /* XXX: "read only object"? */
+		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE); /* XXX: "read only object"? */
 		DUK_WO_NORETURN(return;);
 	}
 #endif
 
 	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, obj, proto);
 
 	duk_pop(thr);
@@ -17929,15 +18651,15 @@
 	DUK_ASSERT_API_ENTRY(thr);
 
 	obj = duk_require_hobject(thr, idx);
 	DUK_ASSERT(obj != NULL);
 
 #if defined(DUK_USE_ROM_OBJECTS)
 	if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj)) {
-		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);  /* XXX: "read only object"? */
+		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE); /* XXX: "read only object"? */
 		DUK_WO_NORETURN(return;);
 	}
 #endif
 
 	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, obj, NULL);
 }
 
@@ -17976,15 +18698,15 @@
 
 DUK_EXTERNAL void duk_set_finalizer(duk_hthread *thr, duk_idx_t idx) {
 	duk_hobject *h;
 	duk_bool_t callable;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	h = duk_require_hobject(thr, idx);  /* Get before 'put' so that 'idx' is correct. */
+	h = duk_require_hobject(thr, idx); /* Get before 'put' so that 'idx' is correct. */
 	callable = duk_is_callable(thr, -1);
 
 	/* At present finalizer is stored as a hidden Symbol, with normal
 	 * inheritance and access control.  As a result, finalizer cannot
 	 * currently be set on a non-extensible (sealed or frozen) object.
 	 * It might be useful to allow it.
 	 */
@@ -18003,38 +18725,38 @@
 	 */
 	if (callable) {
 		DUK_HOBJECT_SET_HAVE_FINALIZER(h);
 	} else {
 		DUK_HOBJECT_CLEAR_HAVE_FINALIZER(h);
 	}
 }
-#else  /* DUK_USE_FINALIZER_SUPPORT */
+#else /* DUK_USE_FINALIZER_SUPPORT */
 DUK_EXTERNAL void duk_get_finalizer(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_set_finalizer(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(idx);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 #line 1 "duk_api_random.c"
 /*
  *  Random numbers
  */
 
 /* #include duk_internal.h -> already included */
 
 DUK_EXTERNAL duk_double_t duk_random(duk_hthread *thr) {
-	return (duk_double_t) DUK_UTIL_GET_RANDOM_DOUBLE(thr);
+	return (duk_double_t) duk_util_get_random_double(thr);
 }
 #line 1 "duk_api_stack.c"
 /*
  *  API calls related to general value stack manipulation: resizing the value
  *  stack, pushing and popping values, type checking and reading values,
  *  coercing values, etc.
  *
@@ -18047,86 +18769,71 @@
 
 /* #include duk_internal.h -> already included */
 
 /*
  *  Forward declarations
  */
 
-DUK_LOCAL_DECL duk_idx_t duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx);
+DUK_LOCAL_DECL duk_idx_t
+duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx);
 
 /*
  *  Global state for working around missing variadic macros
  */
 
 #if !defined(DUK_USE_VARIADIC_MACROS)
 DUK_EXTERNAL const char *duk_api_global_filename = NULL;
 DUK_EXTERNAL duk_int_t duk_api_global_line = 0;
 #endif
 
 /*
  *  Misc helpers
  */
 
-DUK_LOCAL const char * const duk__symbol_type_strings[4] = {
-	"hidden", "global", "local", "wellknown"
-};
+DUK_LOCAL const char * const duk__symbol_type_strings[4] = { "hidden", "global", "local", "wellknown" };
 
 #if !defined(DUK_USE_PACKED_TVAL)
 DUK_LOCAL const duk_uint_t duk__type_from_tag[] = {
-	DUK_TYPE_NUMBER,
-	DUK_TYPE_NUMBER,  /* fastint */
-	DUK_TYPE_UNDEFINED,
-	DUK_TYPE_NULL,
-	DUK_TYPE_BOOLEAN,
-	DUK_TYPE_POINTER,
-	DUK_TYPE_LIGHTFUNC,
-	DUK_TYPE_NONE,
-	DUK_TYPE_STRING,
-	DUK_TYPE_OBJECT,
-	DUK_TYPE_BUFFER,
+	DUK_TYPE_NUMBER,    DUK_TYPE_NUMBER, /* fastint */
+	DUK_TYPE_UNDEFINED, DUK_TYPE_NULL,   DUK_TYPE_BOOLEAN, DUK_TYPE_POINTER, DUK_TYPE_LIGHTFUNC,
+	DUK_TYPE_NONE,      DUK_TYPE_STRING, DUK_TYPE_OBJECT,  DUK_TYPE_BUFFER,
 };
 DUK_LOCAL const duk_uint_t duk__type_mask_from_tag[] = {
-	DUK_TYPE_MASK_NUMBER,
-	DUK_TYPE_MASK_NUMBER,  /* fastint */
-	DUK_TYPE_MASK_UNDEFINED,
-	DUK_TYPE_MASK_NULL,
-	DUK_TYPE_MASK_BOOLEAN,
-	DUK_TYPE_MASK_POINTER,
-	DUK_TYPE_MASK_LIGHTFUNC,
-	DUK_TYPE_MASK_NONE,
-	DUK_TYPE_MASK_STRING,
-	DUK_TYPE_MASK_OBJECT,
-	DUK_TYPE_MASK_BUFFER,
+	DUK_TYPE_MASK_NUMBER,    DUK_TYPE_MASK_NUMBER, /* fastint */
+	DUK_TYPE_MASK_UNDEFINED, DUK_TYPE_MASK_NULL,   DUK_TYPE_MASK_BOOLEAN, DUK_TYPE_MASK_POINTER, DUK_TYPE_MASK_LIGHTFUNC,
+	DUK_TYPE_MASK_NONE,      DUK_TYPE_MASK_STRING, DUK_TYPE_MASK_OBJECT,  DUK_TYPE_MASK_BUFFER,
 };
-#endif  /* !DUK_USE_PACKED_TVAL */
+#endif /* !DUK_USE_PACKED_TVAL */
 
 /* Assert that there's room for one value. */
-#define DUK__ASSERT_SPACE() do { \
+#define DUK__ASSERT_SPACE() \
+	do { \
 		DUK_ASSERT(!(thr->valstack_top >= thr->valstack_end)); \
 	} while (0)
 
 /* Check that there's room to push one value. */
 #if defined(DUK_USE_VALSTACK_UNSAFE)
 /* Faster but value stack overruns are memory unsafe. */
 #define DUK__CHECK_SPACE() DUK__ASSERT_SPACE()
 #else
-#define DUK__CHECK_SPACE() do { \
+#define DUK__CHECK_SPACE() \
+	do { \
 		if (DUK_UNLIKELY(thr->valstack_top >= thr->valstack_end)) { \
 			DUK_ERROR_RANGE_PUSH_BEYOND(thr); \
 		} \
 	} while (0)
 #endif
 
 DUK_LOCAL duk_small_uint_t duk__get_symbol_type(duk_hstring *h) {
 	const duk_uint8_t *data;
 	duk_size_t len;
 
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(DUK_HSTRING_HAS_SYMBOL(h));
-	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(h) >= 1);  /* always true, symbol prefix */
+	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(h) >= 1); /* always true, symbol prefix */
 
 	data = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h);
 	len = DUK_HSTRING_GET_BYTELEN(h);
 	DUK_ASSERT(len >= 1);
 
 	/* XXX: differentiate between 0x82 and 0xff (hidden vs. internal?)? */
 
@@ -18285,15 +18992,15 @@
 	 * duk_tval the index 0x20000000UL would wrap the memory space
 	 * once.
 	 */
 
 	/* Assume value stack sizes (in elements) fits into duk_idx_t. */
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
-	DUK_ASSERT_DISABLE(vs_size >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(vs_size >= 0); /* unsigned */
 
 	if (idx < 0) {
 		uidx = vs_size + (duk_uidx_t) idx;
 	} else {
 		/* since index non-negative */
 		DUK_ASSERT(idx != DUK_INVALID_INDEX);
 		uidx = (duk_uidx_t) idx;
@@ -18313,15 +19020,15 @@
 	duk_uidx_t uidx;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(DUK_INVALID_INDEX < 0);
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
-	DUK_ASSERT_DISABLE(vs_size >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(vs_size >= 0); /* unsigned */
 
 	if (idx < 0) {
 		uidx = vs_size + (duk_uidx_t) idx;
 	} else {
 		DUK_ASSERT(idx != DUK_INVALID_INDEX);
 		uidx = (duk_uidx_t) idx;
 	}
@@ -18341,15 +19048,15 @@
 	duk_uidx_t uidx;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(DUK_INVALID_INDEX < 0);
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
-	DUK_ASSERT_DISABLE(vs_size >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(vs_size >= 0); /* unsigned */
 
 	if (idx < 0) {
 		uidx = vs_size + (duk_uidx_t) idx;
 	} else {
 		DUK_ASSERT(idx != DUK_INVALID_INDEX);
 		uidx = (duk_uidx_t) idx;
 	}
@@ -18388,15 +19095,15 @@
 	duk_uidx_t uidx;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(DUK_INVALID_INDEX < 0);
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
-	DUK_ASSERT_DISABLE(vs_size >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(vs_size >= 0); /* unsigned */
 
 	/* Use unsigned arithmetic to optimize comparison. */
 	if (idx < 0) {
 		uidx = vs_size + (duk_uidx_t) idx;
 	} else {
 		DUK_ASSERT(idx != DUK_INVALID_INDEX);
 		uidx = (duk_uidx_t) idx;
@@ -18527,47 +19234,47 @@
 		duk_uidx_t count;
 		duk_tval *tv_end;
 
 		count = vs_size - uidx;
 		DUK_ASSERT(count > 0);
 		tv = thr->valstack_top;
 		tv_end = tv - count;
-		DUK_ASSERT(tv > tv_end);  /* Because count > 0. */
+		DUK_ASSERT(tv > tv_end); /* Because count > 0. */
 		do {
 			tv--;
 			DUK_ASSERT(tv >= thr->valstack_bottom);
 			DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ(thr, tv);
 		} while (tv != tv_end);
 		thr->valstack_top = tv_end;
 		DUK_REFZERO_CHECK_FAST(thr);
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 		duk_uidx_t count;
 		duk_tval *tv_end;
 
 		count = vs_size - uidx;
 		tv = thr->valstack_top;
 		tv_end = tv - count;
 		DUK_ASSERT(tv > tv_end);
 		do {
 			tv--;
 			DUK_TVAL_SET_UNDEFINED(tv);
 		} while (tv != tv_end);
 		thr->valstack_top = tv_end;
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 	}
 }
 
 /* Internal variant with a non-negative index and no runtime size checks. */
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_INTERNAL void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_set_top(thr, idx);
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_INTERNAL void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx) {
 	duk_uidx_t uidx;
 	duk_uidx_t vs_size;
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
@@ -18598,39 +19305,39 @@
 		duk_uidx_t count;
 		duk_tval *tv_end;
 
 		count = vs_size - uidx;
 		DUK_ASSERT(count > 0);
 		tv = thr->valstack_top;
 		tv_end = tv - count;
-		DUK_ASSERT(tv > tv_end);  /* Because count > 0. */
+		DUK_ASSERT(tv > tv_end); /* Because count > 0. */
 		do {
 			tv--;
 			DUK_ASSERT(tv >= thr->valstack_bottom);
 			DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ(thr, tv);
 		} while (tv != tv_end);
 		thr->valstack_top = tv_end;
 		DUK_REFZERO_CHECK_FAST(thr);
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 		duk_uidx_t count;
 		duk_tval *tv_end;
 
 		count = vs_size - uidx;
 		tv = thr->valstack_top;
 		tv_end = tv - count;
 		DUK_ASSERT(tv > tv_end);
 		do {
 			tv--;
 			DUK_TVAL_SET_UNDEFINED(tv);
 		} while (tv != tv_end);
 		thr->valstack_top = tv_end;
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 	}
 }
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 /* Internal helper: set top to 'top', and set [idx_wipe_start,top[ to
  * 'undefined' (doing nothing if idx_wipe_start == top).  Indices are
  * positive and within value stack reserve.  This is used by call handling.
  */
 DUK_INTERNAL void duk_set_top_and_wipe(duk_hthread *thr, duk_idx_t top, duk_idx_t idx_wipe_start) {
 	DUK_ASSERT_API_ENTRY(thr);
@@ -18722,17 +19429,17 @@
 	duk_tval *p;
 
 	DUK_HTHREAD_ASSERT_VALID(thr);
 	DUK_ASSERT(thr->valstack_bottom >= thr->valstack);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_end >= thr->valstack_top);
 	DUK_ASSERT(thr->valstack_alloc_end >= thr->valstack_end);
-	DUK_ASSERT((duk_size_t) (thr->valstack_top - thr->valstack) <= new_size);  /* can't resize below 'top' */
-	DUK_ASSERT(new_size <= DUK_USE_VALSTACK_LIMIT);  /* valstack limit caller has check, prevents wrapping */
-	DUK_ASSERT(new_size <= DUK_SIZE_MAX / sizeof(duk_tval));  /* specific assert for wrapping */
+	DUK_ASSERT((duk_size_t) (thr->valstack_top - thr->valstack) <= new_size); /* can't resize below 'top' */
+	DUK_ASSERT(new_size <= DUK_USE_VALSTACK_LIMIT); /* valstack limit caller has check, prevents wrapping */
+	DUK_ASSERT(new_size <= DUK_SIZE_MAX / sizeof(duk_tval)); /* specific assert for wrapping */
 
 	/* Pre-realloc pointer copies for asserts and debug logs. */
 	pre_valstack = thr->valstack;
 	pre_bottom = thr->valstack_bottom;
 	pre_top = thr->valstack_top;
 	pre_end = thr->valstack_end;
 	pre_alloc_end = thr->valstack_alloc_end;
@@ -18759,42 +19466,48 @@
 	new_valstack = (duk_tval *) DUK_REALLOC_INDIRECT(thr->heap, duk_hthread_get_valstack_ptr, (void *) thr, new_alloc_size);
 	if (DUK_UNLIKELY(new_valstack == NULL)) {
 		/* Because new_size != 0, if condition doesn't need to be
 		 * (new_valstack != NULL || new_size == 0).
 		 */
 		DUK_ASSERT(new_size != 0);
 		DUK_D(DUK_DPRINT("failed to resize valstack to %lu entries (%lu bytes)",
-		                 (unsigned long) new_size, (unsigned long) new_alloc_size));
+		                 (unsigned long) new_size,
+		                 (unsigned long) new_alloc_size));
 		return 0;
 	}
 
 	/* Debug log any changes in pointer(s) by side effects.  These don't
 	 * necessarily imply any incorrect behavior, but should be rare in
 	 * practice.
 	 */
 #if defined(DUK_USE_DEBUG)
 	if (thr->valstack != pre_valstack) {
 		DUK_D(DUK_DPRINT("valstack base pointer changed during valstack resize: %p -> %p",
-		                 (void *) pre_valstack, (void *) thr->valstack));
+		                 (void *) pre_valstack,
+		                 (void *) thr->valstack));
 	}
 	if (thr->valstack_bottom != pre_bottom) {
 		DUK_D(DUK_DPRINT("valstack bottom pointer changed during valstack resize: %p -> %p",
-		                 (void *) pre_bottom, (void *) thr->valstack_bottom));
+		                 (void *) pre_bottom,
+		                 (void *) thr->valstack_bottom));
 	}
 	if (thr->valstack_top != pre_top) {
 		DUK_D(DUK_DPRINT("valstack top pointer changed during valstack resize: %p -> %p",
-		                 (void *) pre_top, (void *) thr->valstack_top));
+		                 (void *) pre_top,
+		                 (void *) thr->valstack_top));
 	}
 	if (thr->valstack_end != pre_end) {
 		DUK_D(DUK_DPRINT("valstack end pointer changed during valstack resize: %p -> %p",
-		                 (void *) pre_end, (void *) thr->valstack_end));
+		                 (void *) pre_end,
+		                 (void *) thr->valstack_end));
 	}
 	if (thr->valstack_alloc_end != pre_alloc_end) {
 		DUK_D(DUK_DPRINT("valstack alloc_end pointer changed during valstack resize: %p -> %p",
-		                 (void *) pre_alloc_end, (void *) thr->valstack_alloc_end));
+		                 (void *) pre_alloc_end,
+		                 (void *) thr->valstack_alloc_end));
 	}
 #endif
 
 	/* Assertions: offsets for bottom, top, and end (reserve) must not
 	 * have changed even with side effects because they are always
 	 * restored in unwind.  For alloc_end there's no guarantee: it may
 	 * have grown or shrunk (but remain above 'end').
@@ -18825,20 +19538,30 @@
 	                 "base=%p -> %p, bottom=%p -> %p (%ld), top=%p -> %p (%ld), "
 	                 "end=%p -> %p (%ld), alloc_end=%p -> %p (%ld);"
 	                 " tv_prev_alloc_end=%p (-> %ld inits; <0 means shrink)",
 	                 (unsigned long) (pre_alloc_end - pre_valstack),
 	                 (unsigned long) new_size,
 	                 (unsigned long) ((duk_uint8_t *) pre_alloc_end - (duk_uint8_t *) pre_valstack),
 	                 (unsigned long) new_alloc_size,
-	                 (void *) pre_valstack, (void *) thr->valstack,
-	                 (void *) pre_bottom, (void *) thr->valstack_bottom, (long) (thr->valstack_bottom - thr->valstack),
-	                 (void *) pre_top, (void *) thr->valstack_top, (long) (thr->valstack_top - thr->valstack),
-	                 (void *) pre_end, (void *) thr->valstack_end, (long) (thr->valstack_end - thr->valstack),
-	                 (void *) pre_alloc_end, (void *) thr->valstack_alloc_end, (long) (thr->valstack_alloc_end - thr->valstack),
-	                 (void *) tv_prev_alloc_end, (long) (thr->valstack_alloc_end - tv_prev_alloc_end)));
+	                 (void *) pre_valstack,
+	                 (void *) thr->valstack,
+	                 (void *) pre_bottom,
+	                 (void *) thr->valstack_bottom,
+	                 (long) (thr->valstack_bottom - thr->valstack),
+	                 (void *) pre_top,
+	                 (void *) thr->valstack_top,
+	                 (long) (thr->valstack_top - thr->valstack),
+	                 (void *) pre_end,
+	                 (void *) thr->valstack_end,
+	                 (long) (thr->valstack_end - thr->valstack),
+	                 (void *) pre_alloc_end,
+	                 (void *) thr->valstack_alloc_end,
+	                 (long) (thr->valstack_alloc_end - thr->valstack),
+	                 (void *) tv_prev_alloc_end,
+	                 (long) (thr->valstack_alloc_end - tv_prev_alloc_end)));
 
 	/* If allocation grew, init any new slots to 'undefined'. */
 	p = tv_prev_alloc_end;
 	while (p < thr->valstack_alloc_end) {
 		/* Never executed if new size is smaller. */
 		DUK_TVAL_SET_UNDEFINED(p);
 		p++;
@@ -18857,15 +19580,15 @@
 }
 
 DUK_LOCAL DUK_COLD DUK_NOINLINE duk_bool_t duk__valstack_grow(duk_hthread *thr, duk_size_t min_bytes, duk_bool_t throw_on_error) {
 	duk_size_t min_size;
 	duk_size_t new_size;
 
 	DUK_ASSERT(min_bytes / sizeof(duk_tval) * sizeof(duk_tval) == min_bytes);
-	min_size = min_bytes / sizeof(duk_tval);  /* from bytes to slots */
+	min_size = min_bytes / sizeof(duk_tval); /* from bytes to slots */
 
 #if defined(DUK_USE_VALSTACK_GROW_SHIFT)
 	/* New size is minimum size plus a proportional slack, e.g. shift of
 	 * 2 means a 25% slack.
 	 */
 	new_size = min_size + (min_size >> DUK_USE_VALSTACK_GROW_SHIFT);
 #else
@@ -18974,25 +19697,26 @@
 		 */
 #if defined(DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT)
 		DUK_ASSERT(DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT > DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT);
 		slack = alloc_bytes >> DUK_USE_VALSTACK_SHRINK_SLACK_SHIFT;
 #else
 		slack = 0;
 #endif
-		shrink_bytes = reserve_bytes +
-		               slack / sizeof(duk_tval) * sizeof(duk_tval);  /* multiple of duk_tval */
+		shrink_bytes = reserve_bytes + slack / sizeof(duk_tval) * sizeof(duk_tval); /* multiple of duk_tval */
 	}
-#else  /* DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT */
+#else /* DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT */
 	/* Always snug, useful in some low memory environments. */
 	DUK_UNREF(snug);
 	shrink_bytes = reserve_bytes;
-#endif  /* DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT */
+#endif /* DUK_USE_VALSTACK_SHRINK_CHECK_SHIFT */
 
 	DUK_D(DUK_DPRINT("valstack shrink check: alloc_bytes=%ld, reserve_bytes=%ld, shrink_bytes=%ld (unvalidated)",
-	                 (long) alloc_bytes, (long) reserve_bytes, (long) shrink_bytes));
+	                 (long) alloc_bytes,
+	                 (long) reserve_bytes,
+	                 (long) shrink_bytes));
 	DUK_ASSERT(shrink_bytes >= reserve_bytes);
 	if (shrink_bytes >= alloc_bytes) {
 		/* Skip if shrink target is same as current one (or higher,
 		 * though that shouldn't happen in practice).
 		 */
 		return;
 	}
@@ -19131,15 +19855,15 @@
 	DUK__CHECK_SPACE();
 
 	tv_from = duk_require_tval(thr, from_idx);
 	tv_to = thr->valstack_top++;
 	DUK_ASSERT(tv_from != NULL);
 	DUK_ASSERT(tv_to != NULL);
 	DUK_TVAL_SET_TVAL(tv_to, tv_from);
-	DUK_TVAL_INCREF(thr, tv_to);  /* no side effects */
+	DUK_TVAL_INCREF(thr, tv_to); /* no side effects */
 }
 
 DUK_EXTERNAL void duk_dup_top(duk_hthread *thr) {
 #if defined(DUK_USE_PREFER_SIZE)
 	duk_dup(thr, -1);
 #else
 	duk_tval *tv_from;
@@ -19153,15 +19877,15 @@
 		DUK_WO_NORETURN(return;);
 	}
 	tv_from = thr->valstack_top - 1;
 	tv_to = thr->valstack_top++;
 	DUK_ASSERT(tv_from != NULL);
 	DUK_ASSERT(tv_to != NULL);
 	DUK_TVAL_SET_TVAL(tv_to, tv_from);
-	DUK_TVAL_INCREF(thr, tv_to);  /* no side effects */
+	DUK_TVAL_INCREF(thr, tv_to); /* no side effects */
 #endif
 }
 
 DUK_INTERNAL void duk_dup_0(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_dup(thr, 0);
 }
@@ -19206,37 +19930,40 @@
 	 *    [ ... | p | x | x | q ]
 	 * => [ ... | q | p | x | x ]
 	 */
 
 	nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));
 
 	DUK_DDD(DUK_DDDPRINT("duk_insert: to_idx=%ld, p=%p, q=%p, nbytes=%lu",
-	                     (long) to_idx, (void *) p, (void *) q, (unsigned long) nbytes));
+	                     (long) to_idx,
+	                     (void *) p,
+	                     (void *) q,
+	                     (unsigned long) nbytes));
 
 	/* No net refcount changes.  No need to special case nbytes == 0
 	 * (p == q).
 	 */
 	DUK_TVAL_SET_TVAL(&tv_tmp, q);
 	duk_memmove((void *) (p + 1), (const void *) p, (size_t) nbytes);
 	DUK_TVAL_SET_TVAL(p, &tv_tmp);
 }
 
 DUK_INTERNAL void duk_insert_undefined(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(idx >= 0);  /* Doesn't support negative indices. */
+	DUK_ASSERT(idx >= 0); /* Doesn't support negative indices. */
 
 	duk_push_undefined(thr);
 	duk_insert(thr, idx);
 }
 
 DUK_INTERNAL void duk_insert_undefined_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 	duk_tval *tv, *tv_end;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(idx >= 0);  /* Doesn't support negative indices or count. */
+	DUK_ASSERT(idx >= 0); /* Doesn't support negative indices or count. */
 	DUK_ASSERT(count >= 0);
 
 	tv = duk_reserve_gap(thr, idx, count);
 	tv_end = tv + count;
 	while (tv != tv_end) {
 		DUK_TVAL_SET_UNDEFINED(tv);
 		tv++;
@@ -19263,15 +19990,18 @@
 	DUK_ASSERT(q != NULL);
 
 	DUK_ASSERT(q >= p);
 
 	nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));
 
 	DUK_DDD(DUK_DDDPRINT("duk_pull: from_idx=%ld, p=%p, q=%p, nbytes=%lu",
-	                     (long) from_idx, (void *) p, (void *) q, (unsigned long) nbytes));
+	                     (long) from_idx,
+	                     (void *) p,
+	                     (void *) q,
+	                     (unsigned long) nbytes));
 
 	/* No net refcount changes.  No need to special case nbytes == 0
 	 * (p == q).
 	 */
 	DUK_TVAL_SET_TVAL(&tv_tmp, p);
 	duk_memmove((void *) p, (const void *) (p + 1), (size_t) nbytes);
 	DUK_TVAL_SET_TVAL(q, &tv_tmp);
@@ -19292,30 +20022,30 @@
 	/* For tv1 == tv2, both pointing to stack top, the end result
 	 * is same as duk_pop(thr).
 	 */
 	DUK_TVAL_SET_TVAL(&tv_tmp, tv2);
 	DUK_TVAL_SET_TVAL(tv2, tv1);
 	DUK_TVAL_SET_UNDEFINED(tv1);
 	thr->valstack_top--;
-	DUK_TVAL_DECREF(thr, &tv_tmp);  /* side effects */
+	DUK_TVAL_DECREF(thr, &tv_tmp); /* side effects */
 }
 
 DUK_EXTERNAL void duk_copy(duk_hthread *thr, duk_idx_t from_idx, duk_idx_t to_idx) {
 	duk_tval *tv1;
 	duk_tval *tv2;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv1 = duk_require_tval(thr, from_idx);
 	DUK_ASSERT(tv1 != NULL);
 	tv2 = duk_require_tval(thr, to_idx);
 	DUK_ASSERT(tv2 != NULL);
 
 	/* For tv1 == tv2, this is a no-op (no explicit check needed). */
-	DUK_TVAL_SET_TVAL_UPDREF(thr, tv2, tv1);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, tv2, tv1); /* side effects */
 }
 
 DUK_EXTERNAL void duk_remove(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *p;
 	duk_tval *q;
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	duk_tval tv_tmp;
@@ -19338,29 +20068,29 @@
 	 */
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	/* use a temp: decref only when valstack reachable values are correct */
 	DUK_TVAL_SET_TVAL(&tv_tmp, p);
 #endif
 
-	nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));  /* Note: 'q' is top-1 */
+	nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p)); /* Note: 'q' is top-1 */
 	duk_memmove((void *) p, (const void *) (p + 1), (size_t) nbytes);
 
 	DUK_TVAL_SET_UNDEFINED(q);
 	thr->valstack_top--;
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_TVAL_DECREF(thr, &tv_tmp);  /* side effects */
+	DUK_TVAL_DECREF(thr, &tv_tmp); /* side effects */
 #endif
 }
 
 DUK_INTERNAL void duk_remove_unsafe(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
-	duk_remove(thr, idx);  /* XXX: no optimization for now */
+	duk_remove(thr, idx); /* XXX: no optimization for now */
 }
 
 DUK_INTERNAL void duk_remove_m2(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_remove(thr, -2);
 }
@@ -19371,15 +20101,15 @@
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(count >= 0);
 	DUK_ASSERT(idx >= 0);
 
 	while (count-- > 0) {
 		duk_remove(thr, idx);
 	}
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	duk_tval *tv_src;
 	duk_tval *tv_dst;
 	duk_tval *tv_newtop;
 	duk_tval *tv;
 	duk_size_t bytes;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -19403,21 +20133,21 @@
 		DUK_TVAL_SET_UNDEFINED(tv);
 	}
 	thr->valstack_top = tv_newtop;
 
 	/* When not preferring size, only NORZ macros are used; caller
 	 * is expected to DUK_REFZERO_CHECK().
 	 */
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 }
 
 DUK_INTERNAL void duk_remove_n_unsafe(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 
-	duk_remove_n(thr, idx, count);  /* XXX: no optimization for now */
+	duk_remove_n(thr, idx, count); /* XXX: no optimization for now */
 }
 
 /*
  *  Stack slice primitives
  */
 
 DUK_EXTERNAL void duk_xcopymove_raw(duk_hthread *to_thr, duk_hthread *from_thr, duk_idx_t count, duk_bool_t is_copy) {
@@ -19470,15 +20200,15 @@
 	p = to_thr->valstack_top;
 	to_thr->valstack_top = (duk_tval *) (void *) (((duk_uint8_t *) p) + nbytes);
 
 	if (is_copy) {
 		/* Incref copies, keep originals. */
 		q = to_thr->valstack_top;
 		while (p < q) {
-			DUK_TVAL_INCREF(to_thr, p);  /* no side effects */
+			DUK_TVAL_INCREF(to_thr, p); /* no side effects */
 			p++;
 		}
 	} else {
 		/* No net refcount change. */
 		p = from_thr->valstack_top;
 		q = (duk_tval *) (void *) (((duk_uint8_t *) p) - nbytes);
 		from_thr->valstack_top = q;
@@ -19570,15 +20300,15 @@
 
 	return ret;
 }
 
 DUK_EXTERNAL duk_bool_t duk_get_boolean(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
-	return duk__get_boolean_raw(thr, idx, 0);  /* default: false */
+	return duk__get_boolean_raw(thr, idx, 0); /* default: false */
 }
 
 DUK_EXTERNAL duk_bool_t duk_get_boolean_default(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	return duk__get_boolean_raw(thr, idx, def_value);
 }
@@ -19616,19 +20346,18 @@
 
 	DUK_CTX_ASSERT_VALID(thr);
 
 	tv = duk_get_tval_or_unused(thr, idx);
 	DUK_ASSERT(tv != NULL);
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv)) {
-		ret.d = (duk_double_t) DUK_TVAL_GET_FASTINT(tv);  /* XXX: cast trick */
-	}
-	else
+		ret.d = (duk_double_t) DUK_TVAL_GET_FASTINT(tv); /* XXX: cast trick */
+	} else
 #endif
-	if (DUK_TVAL_IS_DOUBLE(tv)) {
+	    if (DUK_TVAL_IS_DOUBLE(tv)) {
 		/* When using packed duk_tval, number must be in NaN-normalized form
 		 * for it to be a duk_tval, so no need to normalize.  NOP for unpacked
 		 * duk_tval.
 		 */
 		ret.d = DUK_TVAL_GET_DOUBLE(tv);
 		DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&ret));
 	} else {
@@ -19637,15 +20366,15 @@
 	}
 
 	return ret.d;
 }
 
 DUK_EXTERNAL duk_double_t duk_get_number(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
-	return duk__get_number_raw(thr, idx, DUK_DOUBLE_NAN);  /* default: NaN */
+	return duk__get_number_raw(thr, idx, DUK_DOUBLE_NAN); /* default: NaN */
 }
 
 DUK_EXTERNAL duk_double_t duk_get_number_default(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk__get_number_raw(thr, idx, def_value);
 }
 
@@ -19793,15 +20522,19 @@
 	if (h != NULL) {
 		return (const char *) DUK_HSTRING_GET_DATA(h);
 	} else {
 		return NULL;
 	}
 }
 
-DUK_EXTERNAL const char *duk_opt_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len) {
+DUK_EXTERNAL const char *duk_opt_lstring(duk_hthread *thr,
+                                         duk_idx_t idx,
+                                         duk_size_t *out_len,
+                                         const char *def_ptr,
+                                         duk_size_t def_len) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	if (duk_check_type_mask(thr, idx, DUK_TYPE_MASK_NONE | DUK_TYPE_MASK_UNDEFINED)) {
 		if (out_len != NULL) {
 			*out_len = def_len;
 		}
 		return def_ptr;
@@ -19814,15 +20547,19 @@
 
 	if (duk_check_type_mask(thr, idx, DUK_TYPE_MASK_NONE | DUK_TYPE_MASK_UNDEFINED)) {
 		return def_ptr;
 	}
 	return duk_require_string(thr, idx);
 }
 
-DUK_EXTERNAL const char *duk_get_lstring_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len) {
+DUK_EXTERNAL const char *duk_get_lstring_default(duk_hthread *thr,
+                                                 duk_idx_t idx,
+                                                 duk_size_t *out_len,
+                                                 const char *def_ptr,
+                                                 duk_size_t def_len) {
 	duk_hstring *h;
 	const char *ret;
 	duk_size_t len;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	h = duk_get_hstring(thr, idx);
@@ -19903,15 +20640,15 @@
 
 	tv = duk_get_tval_or_unused(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	if (!DUK_TVAL_IS_POINTER(tv)) {
 		return def_value;
 	}
 
-	p = DUK_TVAL_GET_POINTER(tv);  /* may be NULL */
+	p = DUK_TVAL_GET_POINTER(tv); /* may be NULL */
 	return p;
 }
 
 DUK_EXTERNAL void *duk_get_pointer(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk__get_pointer_raw(thr, idx, NULL /*def_value*/);
 }
@@ -19941,19 +20678,19 @@
 	 */
 	tv = duk_get_tval_or_unused(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	if (DUK_UNLIKELY(!DUK_TVAL_IS_POINTER(tv))) {
 		DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, "pointer", DUK_STR_NOT_POINTER);
 		DUK_WO_NORETURN(return NULL;);
 	}
-	p = DUK_TVAL_GET_POINTER(tv);  /* may be NULL */
+	p = DUK_TVAL_GET_POINTER(tv); /* may be NULL */
 	return p;
 }
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL void *duk_get_voidptr(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 	duk_heaphdr *h;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv = duk_get_tval_or_unused(thr, idx);
@@ -19964,15 +20701,20 @@
 
 	h = DUK_TVAL_GET_HEAPHDR(tv);
 	DUK_ASSERT(h != NULL);
 	return (void *) h;
 }
 #endif
 
-DUK_LOCAL void *duk__get_buffer_helper(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size, duk_bool_t throw_flag) {
+DUK_LOCAL void *duk__get_buffer_helper(duk_hthread *thr,
+                                       duk_idx_t idx,
+                                       duk_size_t *out_size,
+                                       void *def_ptr,
+                                       duk_size_t def_size,
+                                       duk_bool_t throw_flag) {
 	duk_hbuffer *h;
 	void *ret;
 	duk_size_t len;
 	duk_tval *tv;
 
 	DUK_CTX_ASSERT_VALID(thr);
 
@@ -20017,15 +20759,19 @@
 			*out_size = def_size;
 		}
 		return def_ptr;
 	}
 	return duk_require_buffer(thr, idx, out_size);
 }
 
-DUK_EXTERNAL void *duk_get_buffer_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len) {
+DUK_EXTERNAL void *duk_get_buffer_default(duk_hthread *thr,
+                                          duk_idx_t idx,
+                                          duk_size_t *out_size,
+                                          void *def_ptr,
+                                          duk_size_t def_len) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	return duk__get_buffer_helper(thr, idx, out_size, def_ptr, def_len, 0 /*throw_flag*/);
 }
 
 DUK_EXTERNAL void *duk_require_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 	DUK_ASSERT_API_ENTRY(thr);
@@ -20034,15 +20780,21 @@
 }
 
 /* Get the active buffer data area for a plain buffer or a buffer object.
  * Return NULL if the the value is not a buffer.  Note that a buffer may
  * have a NULL data pointer when its size is zero, the optional 'out_isbuffer'
  * argument allows caller to detect this reliably.
  */
-DUK_INTERNAL void *duk_get_buffer_data_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size, duk_bool_t throw_flag, duk_bool_t *out_isbuffer) {
+DUK_INTERNAL void *duk_get_buffer_data_raw(duk_hthread *thr,
+                                           duk_idx_t idx,
+                                           duk_size_t *out_size,
+                                           void *def_ptr,
+                                           duk_size_t def_size,
+                                           duk_bool_t throw_flag,
+                                           duk_bool_t *out_isbuffer) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	if (out_isbuffer != NULL) {
 		*out_isbuffer = 0;
 	}
@@ -20058,58 +20810,61 @@
 		DUK_ASSERT(h != NULL);
 		if (out_size != NULL) {
 			*out_size = DUK_HBUFFER_GET_SIZE(h);
 		}
 		if (out_isbuffer != NULL) {
 			*out_isbuffer = 1;
 		}
-		return (void *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h);  /* may be NULL (but only if size is 0) */
+		return (void *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h); /* may be NULL (but only if size is 0) */
 	}
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	else if (DUK_TVAL_IS_OBJECT(tv)) {
 		duk_hobject *h = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h != NULL);
 		if (DUK_HOBJECT_IS_BUFOBJ(h)) {
 			/* XXX: this is probably a useful shared helper: for a
 			 * duk_hbufobj, get a validated buffer pointer/length.
 			 */
 			duk_hbufobj *h_bufobj = (duk_hbufobj *) h;
 			DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 
-			if (h_bufobj->buf != NULL &&
-			    DUK_HBUFOBJ_VALID_SLICE(h_bufobj)) {
+			if (h_bufobj->buf != NULL && DUK_HBUFOBJ_VALID_SLICE(h_bufobj)) {
 				duk_uint8_t *p;
 
 				p = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf);
 				if (out_size != NULL) {
 					*out_size = (duk_size_t) h_bufobj->length;
 				}
 				if (out_isbuffer != NULL) {
 					*out_isbuffer = 1;
 				}
 				return (void *) (p + h_bufobj->offset);
 			}
 			/* if slice not fully valid, treat as error */
 		}
 	}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 	if (throw_flag) {
 		DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, "buffer", DUK_STR_NOT_BUFFER);
 		DUK_WO_NORETURN(return NULL;);
 	}
 	return def_ptr;
 }
 
 DUK_EXTERNAL void *duk_get_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk_get_buffer_data_raw(thr, idx, out_size, NULL /*def_ptr*/, 0 /*def_size*/, 0 /*throw_flag*/, NULL);
 }
 
-DUK_EXTERNAL void *duk_get_buffer_data_default(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
+DUK_EXTERNAL void *duk_get_buffer_data_default(duk_hthread *thr,
+                                               duk_idx_t idx,
+                                               duk_size_t *out_size,
+                                               void *def_ptr,
+                                               duk_size_t def_size) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk_get_buffer_data_raw(thr, idx, out_size, def_ptr, def_size, 0 /*throw_flag*/, NULL);
 }
 
 DUK_EXTERNAL void *duk_opt_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -20141,17 +20896,16 @@
 	tv = duk_get_tval_or_unused(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	if (DUK_TVAL_GET_TAG(tv) != tag) {
 		return (duk_heaphdr *) NULL;
 	}
 
 	ret = DUK_TVAL_GET_HEAPHDR(tv);
-	DUK_ASSERT(ret != NULL);  /* tagged null pointers should never occur */
+	DUK_ASSERT(ret != NULL); /* tagged null pointers should never occur */
 	return ret;
-
 }
 
 DUK_INTERNAL duk_hstring *duk_get_hstring(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, DUK_TAG_STRING);
 }
 
@@ -20478,28 +21232,28 @@
 /* Internal helper for getting/requiring a duk_hobject with possible promotion. */
 DUK_LOCAL duk_hobject *duk__get_hobject_promote_mask_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 	duk_uint_t val_mask;
 	duk_hobject *res;
 
 	DUK_CTX_ASSERT_VALID(thr);
 
-	res = duk_get_hobject(thr, idx);  /* common case, not promoted */
+	res = duk_get_hobject(thr, idx); /* common case, not promoted */
 	if (DUK_LIKELY(res != NULL)) {
 		DUK_ASSERT(res != NULL);
 		return res;
 	}
 
 	val_mask = duk_get_type_mask(thr, idx);
 	if (val_mask & type_mask) {
 		if (type_mask & DUK_TYPE_MASK_PROMOTE) {
 			res = duk_to_hobject(thr, idx);
 			DUK_ASSERT(res != NULL);
 			return res;
 		} else {
-			return NULL;  /* accept without promoting */
+			return NULL; /* accept without promoting */
 		}
 	}
 
 	if (type_mask & DUK_TYPE_MASK_THROW) {
 		DUK_ERROR_REQUIRE_TYPE_INDEX(thr, idx, "object", DUK_STR_NOT_OBJECT);
 		DUK_WO_NORETURN(return NULL;);
 	}
@@ -20534,29 +21288,29 @@
 	return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | DUK_TYPE_MASK_THROW);
 }
 
 DUK_INTERNAL duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 	duk_hobject *h;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT_DISABLE(classnum >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(classnum >= 0); /* unsigned */
 	DUK_ASSERT(classnum <= DUK_HOBJECT_CLASS_MAX);
 
 	h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, DUK_TAG_OBJECT);
 	if (DUK_UNLIKELY(h != NULL && DUK_HOBJECT_GET_CLASS_NUMBER(h) != classnum)) {
 		h = NULL;
 	}
 	return h;
 }
 
 DUK_INTERNAL duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 	duk_hobject *h;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT_DISABLE(classnum >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(classnum >= 0); /* unsigned */
 	DUK_ASSERT(classnum <= DUK_HOBJECT_CLASS_MAX);
 
 	h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, DUK_TAG_OBJECT);
 	if (DUK_UNLIKELY(!(h != NULL && DUK_HOBJECT_GET_CLASS_NUMBER(h) == classnum))) {
 		duk_hstring *h_class;
 		h_class = DUK_HTHREAD_GET_STRING(thr, DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(classnum));
 		DUK_UNREF(h_class);
@@ -20594,15 +21348,15 @@
 	case DUK_TAG_LIGHTFUNC: {
 		duk_size_t ret;
 		duk_get_prop_stridx(thr, idx, DUK_STRIDX_LENGTH);
 		ret = (duk_size_t) duk_to_number_m1(thr);
 		duk_pop_unsafe(thr);
 		return ret;
 	}
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	case DUK_TAG_STRING: {
 		duk_hstring *h = DUK_TVAL_GET_STRING(tv);
 		DUK_ASSERT(h != NULL);
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h))) {
 			return 0;
 		}
 		return (duk_size_t) DUK_HSTRING_GET_CHARLEN(h);
@@ -20620,15 +21374,15 @@
 		 */
 		duk_size_t ret;
 		duk_get_prop_stridx(thr, idx, DUK_STRIDX_LENGTH);
 		ret = (duk_size_t) duk_to_number_m1(thr);
 		duk_pop_unsafe(thr);
 		return ret;
 	}
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 	case DUK_TAG_OBJECT: {
 		duk_hobject *h = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h != NULL);
 		return (duk_size_t) duk_hobject_get_length(thr, h);
 	}
 #if defined(DUK_USE_FASTINT)
 	case DUK_TAG_FASTINT:
@@ -20717,79 +21471,73 @@
 
 /* E5 Section 8.12.8 */
 
 DUK_LOCAL duk_bool_t duk__defaultvalue_coerce_attempt(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t func_stridx) {
 	if (duk_get_prop_stridx(thr, idx, func_stridx)) {
 		/* [ ... func ] */
 		if (duk_is_callable(thr, -1)) {
-			duk_dup(thr, idx);         /* -> [ ... func this ] */
-			duk_call_method(thr, 0);     /* -> [ ... retval ] */
+			duk_dup(thr, idx); /* -> [ ... func this ] */
+			duk_call_method(thr, 0); /* -> [ ... retval ] */
 			if (duk_is_primitive(thr, -1)) {
 				duk_replace(thr, idx);
 				return 1;
 			}
 			/* [ ... retval ]; popped below */
 		}
 	}
-	duk_pop_unsafe(thr);  /* [ ... func/retval ] -> [ ... ] */
+	duk_pop_unsafe(thr); /* [ ... func/retval ] -> [ ... ] */
 	return 0;
 }
 
 DUK_EXTERNAL void duk_to_undefined(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv);  /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv); /* side effects */
 }
 
 DUK_EXTERNAL void duk_to_null(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
-	DUK_TVAL_SET_NULL_UPDREF(thr, tv);  /* side effects */
+	DUK_TVAL_SET_NULL_UPDREF(thr, tv); /* side effects */
 }
 
 /* E5 Section 9.1 */
-DUK_LOCAL const char * const duk__toprim_hint_strings[3] = {
-	"default", "string", "number"
-};
+DUK_LOCAL const char * const duk__toprim_hint_strings[3] = { "default", "string", "number" };
 DUK_LOCAL void duk__to_primitive_helper(duk_hthread *thr, duk_idx_t idx, duk_int_t hint, duk_bool_t check_symbol) {
 	/* Inline initializer for coercers[] is not allowed by old compilers like BCC. */
 	duk_small_uint_t coercers[2];
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(hint == DUK_HINT_NONE || hint == DUK_HINT_NUMBER || hint == DUK_HINT_STRING);
 
 	idx = duk_require_normalize_index(thr, idx);
 
 	/* If already primitive, return as is. */
-	if (!duk_check_type_mask(thr, idx, DUK_TYPE_MASK_OBJECT |
-	                                   DUK_TYPE_MASK_LIGHTFUNC |
-	                                   DUK_TYPE_MASK_BUFFER)) {
-		DUK_ASSERT(!duk_is_buffer(thr, idx));  /* duk_to_string() relies on this behavior */
+	if (!duk_check_type_mask(thr, idx, DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER)) {
+		DUK_ASSERT(!duk_is_buffer(thr, idx)); /* duk_to_string() relies on this behavior */
 		return;
 	}
 
 	/* @@toPrimitive lookup.  Also do for plain buffers and lightfuncs
 	 * which mimic objects.
 	 */
 	if (check_symbol && duk_get_method_stridx(thr, idx, DUK_STRIDX_WELLKNOWN_SYMBOL_TO_PRIMITIVE)) {
 		DUK_ASSERT(hint >= 0 && (duk_size_t) hint < sizeof(duk__toprim_hint_strings) / sizeof(const char *));
 		duk_dup(thr, idx);
 		duk_push_string(thr, duk__toprim_hint_strings[hint]);
-		duk_call_method(thr, 1);  /* [ ... method value hint ] -> [ ... res] */
-		if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT |
-	                                         DUK_TYPE_MASK_LIGHTFUNC |
-		                                 DUK_TYPE_MASK_BUFFER)) {
+		duk_call_method(thr, 1); /* [ ... method value hint ] -> [ ... res] */
+		if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER)) {
 			goto fail;
 		}
 		duk_replace(thr, idx);
 		return;
 	}
 
 	/* Objects are coerced based on E5 specification.
@@ -20803,45 +21551,45 @@
 	 * Date.prototype[@@toPrimitive].  However, it is needed if
 	 * symbol support is not enabled.
 	 */
 #if defined(DUK_USE_SYMBOL_BUILTIN)
 	if (hint == DUK_HINT_NONE) {
 		hint = DUK_HINT_NUMBER;
 	}
-#else  /* DUK_USE_SYMBOL_BUILTIN */
+#else /* DUK_USE_SYMBOL_BUILTIN */
 	if (hint == DUK_HINT_NONE) {
 		duk_small_uint_t class_number;
 
 		class_number = duk_get_class_number(thr, idx);
 		if (class_number == DUK_HOBJECT_CLASS_DATE) {
 			hint = DUK_HINT_STRING;
 		} else {
 			hint = DUK_HINT_NUMBER;
 		}
 	}
-#endif  /* DUK_USE_SYMBOL_BUILTIN */
+#endif /* DUK_USE_SYMBOL_BUILTIN */
 
 	coercers[0] = DUK_STRIDX_VALUE_OF;
 	coercers[1] = DUK_STRIDX_TO_STRING;
 	if (hint == DUK_HINT_STRING) {
 		coercers[0] = DUK_STRIDX_TO_STRING;
 		coercers[1] = DUK_STRIDX_VALUE_OF;
 	}
 
 	if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[0])) {
-		DUK_ASSERT(!duk_is_buffer(thr, idx));  /* duk_to_string() relies on this behavior */
+		DUK_ASSERT(!duk_is_buffer(thr, idx)); /* duk_to_string() relies on this behavior */
 		return;
 	}
 
 	if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[1])) {
-		DUK_ASSERT(!duk_is_buffer(thr, idx));  /* duk_to_string() relies on this behavior */
+		DUK_ASSERT(!duk_is_buffer(thr, idx)); /* duk_to_string() relies on this behavior */
 		return;
 	}
 
- fail:
+fail:
 	DUK_ERROR_TYPE(thr, DUK_STR_TOPRIMITIVE_FAILED);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_to_primitive(duk_hthread *thr, duk_idx_t idx, duk_int_t hint) {
 	duk__to_primitive_helper(thr, idx, hint, 1 /*check_symbol*/);
 }
@@ -20864,15 +21612,15 @@
 	DUK_ASSERT(tv != NULL);
 
 	val = duk_js_toboolean(tv);
 	DUK_ASSERT(val == 0 || val == 1);
 
 	/* Note: no need to re-lookup tv, conversion is side effect free. */
 	DUK_ASSERT(tv != NULL);
-	DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv, val);  /* side effects */
+	DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv, val); /* side effects */
 	return val;
 }
 
 DUK_INTERNAL duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr) {
 	duk_tval *tv;
 	duk_bool_t val;
 
@@ -20896,19 +21644,19 @@
 
 	/* XXX: No need to normalize; the whole operation could be inlined here to
 	 * avoid 'tv' re-lookup.
 	 */
 	idx = duk_require_normalize_index(thr, idx);
 	tv = DUK_GET_TVAL_POSIDX(thr, idx);
 	DUK_ASSERT(tv != NULL);
-	d = duk_js_tonumber(thr, tv);  /* XXX: fastint coercion? now result will always be a non-fastint */
+	d = duk_js_tonumber(thr, tv); /* XXX: fastint coercion? now result will always be a non-fastint */
 
 	/* ToNumber() may have side effects so must relookup 'tv'. */
 	tv = DUK_GET_TVAL_POSIDX(thr, idx);
-	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv, d);  /* side effects */
+	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv, d); /* side effects */
 	return d;
 }
 
 DUK_INTERNAL duk_double_t duk_to_number_m1(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk_to_number(thr, -1);
 }
@@ -20932,21 +21680,21 @@
 	duk_tval *tv_dst;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__ASSERT_SPACE();
 
 	tv_dst = thr->valstack_top++;
 	DUK_TVAL_SET_TVAL(tv_dst, tv);
-	DUK_TVAL_INCREF(thr, tv_dst);  /* decref not necessary */
-	res = duk_to_number_m1(thr);  /* invalidates tv_dst */
+	DUK_TVAL_INCREF(thr, tv_dst); /* decref not necessary */
+	res = duk_to_number_m1(thr); /* invalidates tv_dst */
 
 	tv_dst = --thr->valstack_top;
 	DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv_dst));
-	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv_dst));  /* plain number */
-	DUK_TVAL_SET_UNDEFINED(tv_dst);  /* valstack init policy */
+	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv_dst)); /* plain number */
+	DUK_TVAL_SET_UNDEFINED(tv_dst); /* valstack init policy */
 
 	return res;
 #endif
 }
 
 /* XXX: combine all the integer conversions: they share everything
  * but the helper function for coercion.
@@ -20974,15 +21722,15 @@
 #endif
 	d = coerce_func(thr, tv);
 
 	/* XXX: fastint? */
 
 	/* Relookup in case coerce_func() has side effects, e.g. ends up coercing an object */
 	tv = duk_require_tval(thr, idx);
-	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv, d);  /* side effects */
+	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv, d); /* side effects */
 	return d;
 }
 
 DUK_EXTERNAL duk_int_t duk_to_int(duk_hthread *thr, duk_idx_t idx) {
 	/* Value coercion (in stack): ToInteger(), E5 Section 9.4,
 	 * API return value coercion: custom.
 	 */
@@ -21008,15 +21756,15 @@
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	ret = duk_js_toint32(thr, tv);
 
 	/* Relookup in case coerce_func() has side effects, e.g. ends up coercing an object */
 	tv = duk_require_tval(thr, idx);
-	DUK_TVAL_SET_I32_UPDREF(thr, tv, ret);  /* side effects */
+	DUK_TVAL_SET_I32_UPDREF(thr, tv, ret); /* side effects */
 	return ret;
 }
 
 DUK_EXTERNAL duk_uint32_t duk_to_uint32(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 	duk_uint32_t ret;
 
@@ -21024,15 +21772,15 @@
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	ret = duk_js_touint32(thr, tv);
 
 	/* Relookup in case coerce_func() has side effects, e.g. ends up coercing an object */
 	tv = duk_require_tval(thr, idx);
-	DUK_TVAL_SET_U32_UPDREF(thr, tv, ret);  /* side effects */
+	DUK_TVAL_SET_U32_UPDREF(thr, tv, ret); /* side effects */
 	return ret;
 }
 
 DUK_EXTERNAL duk_uint16_t duk_to_uint16(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 	duk_uint16_t ret;
 
@@ -21040,15 +21788,15 @@
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
 	ret = duk_js_touint16(thr, tv);
 
 	/* Relookup in case coerce_func() has side effects, e.g. ends up coercing an object */
 	tv = duk_require_tval(thr, idx);
-	DUK_TVAL_SET_U32_UPDREF(thr, tv, ret);  /* side effects */
+	DUK_TVAL_SET_U32_UPDREF(thr, tv, ret); /* side effects */
 	return ret;
 }
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 /* Special coercion for Uint8ClampedArray. */
 DUK_INTERNAL duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx) {
 	duk_double_t d;
@@ -21072,24 +21820,24 @@
 		return 0;
 	}
 
 	t = d - DUK_FLOOR(d);
 	if (duk_double_equals(t, 0.5)) {
 		/* Exact halfway, round to even. */
 		ret = (duk_uint8_t) d;
-		ret = (ret + 1) & 0xfe;  /* Example: d=3.5, t=0.5 -> ret = (3 + 1) & 0xfe = 4 & 0xfe = 4
-		                          * Example: d=4.5, t=0.5 -> ret = (4 + 1) & 0xfe = 5 & 0xfe = 4
-		                          */
+		ret = (ret + 1) & 0xfe; /* Example: d=3.5, t=0.5 -> ret = (3 + 1) & 0xfe = 4 & 0xfe = 4
+		                         * Example: d=4.5, t=0.5 -> ret = (4 + 1) & 0xfe = 5 & 0xfe = 4
+		                         */
 	} else {
 		/* Not halfway, round to nearest. */
 		ret = (duk_uint8_t) (d + 0.5);
 	}
 	return ret;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 DUK_EXTERNAL const char *duk_to_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	(void) duk_to_string(thr, idx);
 	DUK_ASSERT(duk_is_string(thr, idx));
 	return duk_require_lstring(thr, idx, out_len);
@@ -21191,29 +21939,29 @@
 }
 
 DUK_INTERNAL duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx) {
 	duk_hstring *h;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	duk_to_primitive(thr, idx, DUK_HINT_STRING);  /* needed for e.g. Symbol objects */
+	duk_to_primitive(thr, idx, DUK_HINT_STRING); /* needed for e.g. Symbol objects */
 	h = duk_get_hstring(thr, idx);
 	if (h == NULL) {
 		/* The "is string?" check may seem unnecessary, but as things
 		 * are duk_to_hstring() invokes ToString() which fails for
 		 * symbols.  But since symbols are already strings for Duktape
 		 * C API, we check for that before doing the coercion.
 		 */
 		h = duk_to_hstring(thr, idx);
 	}
 	DUK_ASSERT(h != NULL);
 	return h;
 }
 
-#if defined(DUK_USE_DEBUGGER_SUPPORT)  /* only needed by debugger for now */
+#if defined(DUK_USE_DEBUGGER_SUPPORT) /* only needed by debugger for now */
 DUK_INTERNAL duk_hstring *duk_safe_to_hstring(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	(void) duk_safe_to_string(thr, idx);
 	DUK_ASSERT(duk_is_string(thr, idx));
 	DUK_ASSERT(duk_get_hstring(thr, idx) != NULL);
 	return duk_known_hstring(thr, idx);
@@ -21247,30 +21995,30 @@
 	 * For now, do an actual object coercion.  This could be avoided by
 	 * doing a side effect free lookup to see if a getter would be invoked.
 	 * If not, the value can be read directly and the object coercion could
 	 * be avoided.  This may not be worth it in practice, because
 	 * Object.prototype.toString() is usually not performance critical.
 	 */
 
-	duk_push_literal(thr, "[object ");  /* -> [ ... "[object" ] */
+	duk_push_literal(thr, "[object "); /* -> [ ... "[object" ] */
 
 	switch (DUK_TVAL_GET_TAG(tv)) {
-	case DUK_TAG_UNUSED:  /* Treat like 'undefined', shouldn't happen. */
+	case DUK_TAG_UNUSED: /* Treat like 'undefined', shouldn't happen. */
 	case DUK_TAG_UNDEFINED: {
 		duk_push_hstring_stridx(thr, DUK_STRIDX_UC_UNDEFINED);
 		goto finish;
 	}
 	case DUK_TAG_NULL: {
 		duk_push_hstring_stridx(thr, DUK_STRIDX_UC_NULL);
 		goto finish;
 	}
 	}
 
 	duk_push_tval(thr, tv);
-	tv = NULL;  /* Invalidated by ToObject(). */
+	tv = NULL; /* Invalidated by ToObject(). */
 	h_obj = duk_to_hobject(thr, -1);
 	DUK_ASSERT(h_obj != NULL);
 	if (duk_js_isarray_hobject(h_obj)) {
 		stridx = DUK_STRIDX_UC_ARRAY;
 	} else {
 		/* [ ... "[object" obj ] */
 
@@ -21293,33 +22041,34 @@
 
 		classnum = DUK_HOBJECT_GET_CLASS_NUMBER(h_obj);
 		stridx = DUK_HOBJECT_CLASS_NUMBER_TO_STRIDX(classnum);
 	}
 	duk_pop_unsafe(thr);
 	duk_push_hstring_stridx(thr, stridx);
 
- finish:
+finish:
 	/* [ ... "[object" tag ] */
 	duk_push_literal(thr, "]");
-	duk_concat(thr, 3);  /* [ ... "[object" tag "]" ] -> [ ... res ] */
+	duk_concat(thr, 3); /* [ ... "[object" tag "]" ] -> [ ... res ] */
 }
 
 /* XXX: other variants like uint, u32 etc */
-DUK_INTERNAL duk_int_t duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped) {
+DUK_INTERNAL duk_int_t
+duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped) {
 	duk_tval *tv;
 	duk_tval tv_tmp;
 	duk_double_t d, dmin, dmax;
 	duk_int_t res;
 	duk_bool_t clamped = 0;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv = duk_require_tval(thr, idx);
 	DUK_ASSERT(tv != NULL);
-	d = duk_js_tointeger(thr, tv);  /* E5 Section 9.4, ToInteger() */
+	d = duk_js_tointeger(thr, tv); /* E5 Section 9.4, ToInteger() */
 
 	dmin = (duk_double_t) minval;
 	dmax = (duk_double_t) maxval;
 
 	if (d < dmin) {
 		clamped = 1;
 		res = minval;
@@ -21327,36 +22076,36 @@
 	} else if (d > dmax) {
 		clamped = 1;
 		res = maxval;
 		d = dmax;
 	} else {
 		res = (duk_int_t) d;
 	}
-	DUK_UNREF(d);  /* SCANBUILD: with suitable dmin/dmax limits 'd' is unused */
+	DUK_UNREF(d); /* SCANBUILD: with suitable dmin/dmax limits 'd' is unused */
 	/* 'd' and 'res' agree here */
 
 	/* Relookup in case duk_js_tointeger() ends up e.g. coercing an object. */
 	tv = duk_get_tval(thr, idx);
-	DUK_ASSERT(tv != NULL);  /* not popped by side effect */
+	DUK_ASSERT(tv != NULL); /* not popped by side effect */
 	DUK_TVAL_SET_TVAL(&tv_tmp, tv);
 #if defined(DUK_USE_FASTINT)
 #if (DUK_INT_MAX <= 0x7fffffffL)
 	DUK_TVAL_SET_I32(tv, res);
 #else
 	/* Clamping needed if duk_int_t is 64 bits. */
 	if (res >= DUK_FASTINT_MIN && res <= DUK_FASTINT_MAX) {
 		DUK_TVAL_SET_FASTINT(tv, res);
 	} else {
 		DUK_TVAL_SET_NUMBER(tv, d);
 	}
 #endif
 #else
-	DUK_TVAL_SET_NUMBER(tv, d);  /* no need to incref */
+	DUK_TVAL_SET_NUMBER(tv, d); /* no need to incref */
 #endif
-	DUK_TVAL_DECREF(thr, &tv_tmp);  /* side effects */
+	DUK_TVAL_DECREF(thr, &tv_tmp); /* side effects */
 
 	if (out_clamped) {
 		*out_clamped = clamped;
 	} else {
 		/* coerced value is updated to value stack even when RangeError thrown */
 		if (clamped) {
 			DUK_ERROR_RANGE(thr, DUK_STR_NUMBER_OUTSIDE_RANGE);
@@ -21373,15 +22122,15 @@
 	DUK_ASSERT_API_ENTRY(thr);
 
 	return duk_to_int_clamped_raw(thr, idx, minval, maxval, &dummy);
 }
 
 DUK_INTERNAL duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval) {
 	DUK_ASSERT_API_ENTRY(thr);
-	return duk_to_int_clamped_raw(thr, idx, minval, maxval, NULL);  /* out_clamped==NULL -> RangeError if outside range */
+	return duk_to_int_clamped_raw(thr, idx, minval, maxval, NULL); /* out_clamped==NULL -> RangeError if outside range */
 }
 
 DUK_EXTERNAL const char *duk_to_string(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -21432,17 +22181,17 @@
 		/* Plain buffers: go through ArrayBuffer.prototype.toString()
 		 * for coercion.
 		 *
 		 * Symbol objects: duk_to_primitive() results in a plain symbol
 		 * value, and duk_to_string() then causes a TypeError.
 		 */
 		duk_to_primitive(thr, idx, DUK_HINT_STRING);
-		DUK_ASSERT(!duk_is_buffer(thr, idx));  /* ToPrimitive() must guarantee */
+		DUK_ASSERT(!duk_is_buffer(thr, idx)); /* ToPrimitive() must guarantee */
 		DUK_ASSERT(!duk_is_object(thr, idx));
-		return duk_to_string(thr, idx);  /* Note: recursive call */
+		return duk_to_string(thr, idx); /* Note: recursive call */
 	}
 	case DUK_TAG_POINTER: {
 		void *ptr = DUK_TVAL_GET_POINTER(tv);
 		if (ptr != NULL) {
 			duk_push_sprintf(thr, DUK_STR_FMT_PTR, (void *) ptr);
 		} else {
 			/* Represent a null pointer as 'null' to be consistent with
@@ -21462,25 +22211,22 @@
 	case DUK_TAG_FASTINT:
 #endif
 	default: {
 		/* number */
 		DUK_ASSERT(!DUK_TVAL_IS_UNUSED(tv));
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
 		duk_push_tval(thr, tv);
-		duk_numconv_stringify(thr,
-		                      10 /*radix*/,
-		                      0 /*precision:shortest*/,
-		                      0 /*force_exponential*/);
+		duk_numconv_stringify(thr, 10 /*radix*/, 0 /*precision:shortest*/, 0 /*force_exponential*/);
 		break;
 	}
 	}
 
 	duk_replace(thr, idx);
 
- skip_replace:
+skip_replace:
 	DUK_ASSERT(duk_is_string(thr, idx));
 	return duk_require_string(thr, idx);
 }
 
 DUK_INTERNAL duk_hstring *duk_to_hstring(duk_hthread *thr, duk_idx_t idx) {
 	duk_hstring *ret;
 
@@ -21554,16 +22300,15 @@
 		duk_uint8_t *tmp_ptr;
 
 		tmp_ptr = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_buf);
 		src_data = (const duk_uint8_t *) tmp_ptr;
 		src_size = DUK_HBUFFER_GET_SIZE(h_buf);
 
 		tmp = (DUK_HBUFFER_HAS_DYNAMIC(h_buf) ? DUK_BUF_MODE_DYNAMIC : DUK_BUF_MODE_FIXED);
-		if ((tmp == mode && !DUK_HBUFFER_HAS_EXTERNAL(h_buf)) ||
-		    mode == DUK_BUF_MODE_DONTCARE) {
+		if ((tmp == mode && !DUK_HBUFFER_HAS_EXTERNAL(h_buf)) || mode == DUK_BUF_MODE_DONTCARE) {
 			/* Note: src_data may be NULL if input is a zero-size
 			 * dynamic buffer.
 			 */
 			dst_data = tmp_ptr;
 			goto skip_copy;
 		}
 	} else {
@@ -21576,15 +22321,15 @@
 	}
 
 	dst_data = (duk_uint8_t *) duk_push_buffer(thr, src_size, (mode == DUK_BUF_MODE_DYNAMIC) /*dynamic*/);
 	/* dst_data may be NULL if size is zero. */
 	duk_memcpy_unsafe((void *) dst_data, (const void *) src_data, (size_t) src_size);
 
 	duk_replace(thr, idx);
- skip_copy:
+skip_copy:
 
 	if (out_size) {
 		*out_size = src_size;
 	}
 	return dst_data;
 }
 
@@ -21636,32 +22381,26 @@
 	duk_push_pointer(thr, res);
 	duk_replace(thr, idx);
 	return res;
 }
 
 DUK_LOCAL void duk__push_func_from_lightfunc(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags) {
 	duk_idx_t nargs;
-	duk_uint_t flags = 0;   /* shared flags for a subset of types */
+	duk_uint_t flags = 0; /* shared flags for a subset of types */
 	duk_small_uint_t lf_len;
 	duk_hnatfunc *nf;
 
 	nargs = (duk_idx_t) DUK_LFUNC_FLAGS_GET_NARGS(lf_flags);
 	if (nargs == DUK_LFUNC_NARGS_VARARGS) {
 		nargs = (duk_idx_t) DUK_VARARGS;
 	}
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_CONSTRUCTABLE |
-	        DUK_HOBJECT_FLAG_CALLABLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_NATFUNC |
-	        DUK_HOBJECT_FLAG_NEWENV |
-	        DUK_HOBJECT_FLAG_STRICT |
-	        DUK_HOBJECT_FLAG_NOTAIL |
-	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_CONSTRUCTABLE | DUK_HOBJECT_FLAG_CALLABLE |
+	        DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_NATFUNC | DUK_HOBJECT_FLAG_NEWENV | DUK_HOBJECT_FLAG_STRICT |
+	        DUK_HOBJECT_FLAG_NOTAIL | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
 	(void) duk__push_c_function_raw(thr, func, nargs, flags, DUK_BIDX_NATIVE_FUNCTION_PROTOTYPE);
 
 	lf_len = DUK_LFUNC_FLAGS_GET_LENGTH(lf_flags);
 	if ((duk_idx_t) lf_len != nargs) {
 		/* Explicit length is only needed if it differs from 'nargs'. */
 		duk_push_int(thr, (duk_int_t) lf_len);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_NONE);
@@ -21674,53 +22413,49 @@
 
 	nf = duk_known_hnatfunc(thr, -1);
 	nf->magic = (duk_int16_t) DUK_LFUNC_FLAGS_GET_MAGIC(lf_flags);
 }
 
 DUK_EXTERNAL void duk_to_object(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
-	duk_uint_t flags = 0;   /* shared flags for a subset of types */
+	duk_uint_t flags = 0; /* shared flags for a subset of types */
 	duk_small_int_t proto = 0;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	idx = duk_require_normalize_index(thr, idx);
 	tv = DUK_GET_TVAL_POSIDX(thr, idx);
 	DUK_ASSERT(tv != NULL);
 
 	switch (DUK_TVAL_GET_TAG(tv)) {
 #if !defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-	case DUK_TAG_BUFFER:  /* With no bufferobject support, don't object coerce. */
+	case DUK_TAG_BUFFER: /* With no bufferobject support, don't object coerce. */
 #endif
 	case DUK_TAG_UNDEFINED:
 	case DUK_TAG_NULL: {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_OBJECT_COERCIBLE);
 		DUK_WO_NORETURN(return;);
 		break;
 	}
 	case DUK_TAG_BOOLEAN: {
-		flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-		        DUK_HOBJECT_FLAG_FASTREFS |
-		        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_BOOLEAN);
+		flags =
+		    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_BOOLEAN);
 		proto = DUK_BIDX_BOOLEAN_PROTOTYPE;
 		goto create_object;
 	}
 	case DUK_TAG_STRING: {
 		duk_hstring *h;
 		h = DUK_TVAL_GET_STRING(tv);
 		DUK_ASSERT(h != NULL);
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h))) {
-			flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-			        DUK_HOBJECT_FLAG_FASTREFS |
+			flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
 			        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_SYMBOL);
 			proto = DUK_BIDX_SYMBOL_PROTOTYPE;
 		} else {
-			flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-			        DUK_HOBJECT_FLAG_FASTREFS |
-			        DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ |
+			flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ |
 			        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_STRING);
 			proto = DUK_BIDX_STRING_PROTOTYPE;
 		}
 		goto create_object;
 	}
 	case DUK_TAG_OBJECT: {
 		/* nop */
@@ -21738,19 +22473,18 @@
 		duk_hbuffer *h_buf;
 
 		h_buf = DUK_TVAL_GET_BUFFER(tv);
 		DUK_ASSERT(h_buf != NULL);
 		duk_hbufobj_push_uint8array_from_plain(thr, h_buf);
 		goto replace_value;
 	}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 	case DUK_TAG_POINTER: {
-		flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-		        DUK_HOBJECT_FLAG_FASTREFS |
-		        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_POINTER);
+		flags =
+		    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_POINTER);
 		proto = DUK_BIDX_POINTER_PROTOTYPE;
 		goto create_object;
 	}
 	case DUK_TAG_LIGHTFUNC: {
 		/* Lightfunc coerces to a Function instance with concrete
 		 * properties.  Since 'length' is virtual for Duktape/C
 		 * functions, don't need to define that.  The result is made
@@ -21769,38 +22503,37 @@
 	}
 #if defined(DUK_USE_FASTINT)
 	case DUK_TAG_FASTINT:
 #endif
 	default: {
 		DUK_ASSERT(!DUK_TVAL_IS_UNUSED(tv));
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
-		flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-		        DUK_HOBJECT_FLAG_FASTREFS |
-		        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_NUMBER);
+		flags =
+		    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_NUMBER);
 		proto = DUK_BIDX_NUMBER_PROTOTYPE;
 		goto create_object;
 	}
 	}
 	DUK_ASSERT(duk_is_object(thr, idx));
 	return;
 
- create_object:
+create_object:
 	(void) duk_push_object_helper(thr, flags, proto);
 
 	/* Note: Boolean prototype's internal value property is not writable,
 	 * but duk_xdef_prop_stridx() disregards the write protection.  Boolean
 	 * instances are immutable.
 	 *
 	 * String and buffer special behaviors are already enabled which is not
 	 * ideal, but a write to the internal value is not affected by them.
 	 */
 	duk_dup(thr, idx);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE);
 
- replace_value:
+replace_value:
 	duk_replace(thr, idx);
 	DUK_ASSERT(duk_is_object(thr, idx));
 }
 
 DUK_INTERNAL duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx) {
 	duk_hobject *ret;
 
@@ -21863,58 +22596,48 @@
 #endif
 	default:
 		/* Note: number has no explicit tag (in 8-byte representation) */
 		DUK_ASSERT(!DUK_TVAL_IS_UNUSED(tv));
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
 		return DUK_TYPE_NUMBER;
 	}
-#else  /* DUK_USE_PACKED_TVAL */
+#else /* DUK_USE_PACKED_TVAL */
 	DUK_ASSERT(DUK_TVAL_IS_VALID_TAG(tv));
 	DUK_ASSERT(sizeof(duk__type_from_tag) / sizeof(duk_uint_t) == DUK_TAG_MAX - DUK_TAG_MIN + 1);
 	return (duk_int_t) duk__type_from_tag[DUK_TVAL_GET_TAG(tv) - DUK_TAG_MIN];
-#endif  /* DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_PACKED_TVAL */
 }
 
 DUK_EXTERNAL duk_int_t duk_get_type(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	tv = duk_get_tval_or_unused(thr, idx);
 	DUK_ASSERT(tv != NULL);
 
 	return duk_get_type_tval(tv);
 }
 
 #if defined(DUK_USE_VERBOSE_ERRORS) && defined(DUK_USE_PARANOID_ERRORS)
-DUK_LOCAL const char * const duk__type_names[] = {
-	"none",
-	"undefined",
-	"null",
-	"boolean",
-	"number",
-	"string",
-	"object",
-	"buffer",
-	"pointer",
-	"lightfunc"
-};
+DUK_LOCAL const char * const duk__type_names[] = { "none",   "undefined", "null",   "boolean", "number",
+	                                           "string", "object",    "buffer", "pointer", "lightfunc" };
 
 DUK_INTERNAL const char *duk_get_type_name(duk_hthread *thr, duk_idx_t idx) {
 	duk_int_t type_tag;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	type_tag = duk_get_type(thr, idx);
 	DUK_ASSERT(type_tag >= DUK_TYPE_MIN && type_tag <= DUK_TYPE_MAX);
 	DUK_ASSERT(DUK_TYPE_MIN == 0 && sizeof(duk__type_names) / sizeof(const char *) == DUK_TYPE_MAX + 1);
 
 	return duk__type_names[type_tag];
 }
-#endif  /* DUK_USE_VERBOSE_ERRORS && DUK_USE_PARANOID_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS && DUK_USE_PARANOID_ERRORS */
 
 DUK_INTERNAL duk_small_uint_t duk_get_class_number(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 	duk_hobject *obj;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -21972,19 +22695,19 @@
 #endif
 	default:
 		/* Note: number has no explicit tag (in 8-byte representation) */
 		DUK_ASSERT(!DUK_TVAL_IS_UNUSED(tv));
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
 		return DUK_TYPE_MASK_NUMBER;
 	}
-#else  /* DUK_USE_PACKED_TVAL */
+#else /* DUK_USE_PACKED_TVAL */
 	DUK_ASSERT(DUK_TVAL_IS_VALID_TAG(tv));
 	DUK_ASSERT(sizeof(duk__type_mask_from_tag) / sizeof(duk_uint_t) == DUK_TAG_MAX - DUK_TAG_MIN + 1);
 	return duk__type_mask_from_tag[DUK_TVAL_GET_TAG(tv) - DUK_TAG_MIN];
-#endif  /* DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_PACKED_TVAL */
 }
 
 DUK_EXTERNAL duk_uint_t duk_get_type_mask(duk_hthread *thr, duk_idx_t idx) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -22095,22 +22818,22 @@
 		DUK_ASSERT(h != NULL);
 		if (DUK_HOBJECT_IS_BUFOBJ(h)) {
 			return 1;
 		}
 	}
 	return 0;
 }
-#else  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#else /* DUK_USE_BUFFEROBJECT_SUPPORT */
 DUK_EXTERNAL duk_bool_t duk_is_buffer_data(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	return duk_is_buffer(thr, idx);
 }
 
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 DUK_EXTERNAL duk_bool_t duk_is_pointer(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
 	return duk__tag_check(thr, idx, DUK_TAG_POINTER);
 }
 
 DUK_EXTERNAL duk_bool_t duk_is_lightfunc(duk_hthread *thr, duk_idx_t idx) {
@@ -22196,31 +22919,25 @@
 		return 1;
 	}
 	return 0;
 }
 
 DUK_EXTERNAL duk_bool_t duk_is_c_function(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
-	return duk__obj_flag_any_default_false(thr,
-	                                       idx,
-	                                       DUK_HOBJECT_FLAG_NATFUNC);
+	return duk__obj_flag_any_default_false(thr, idx, DUK_HOBJECT_FLAG_NATFUNC);
 }
 
 DUK_EXTERNAL duk_bool_t duk_is_ecmascript_function(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
-	return duk__obj_flag_any_default_false(thr,
-	                                       idx,
-	                                       DUK_HOBJECT_FLAG_COMPFUNC);
+	return duk__obj_flag_any_default_false(thr, idx, DUK_HOBJECT_FLAG_COMPFUNC);
 }
 
 DUK_EXTERNAL duk_bool_t duk_is_bound_function(duk_hthread *thr, duk_idx_t idx) {
 	DUK_ASSERT_API_ENTRY(thr);
-	return duk__obj_flag_any_default_false(thr,
-	                                       idx,
-	                                       DUK_HOBJECT_FLAG_BOUNDFUNC);
+	return duk__obj_flag_any_default_false(thr, idx, DUK_HOBJECT_FLAG_BOUNDFUNC);
 }
 
 DUK_EXTERNAL duk_bool_t duk_is_thread(duk_hthread *thr, duk_idx_t idx) {
 	duk_hobject *obj;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -22329,15 +23046,15 @@
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(tv != NULL);
 
 	DUK__CHECK_SPACE();
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_TVAL(tv_slot, tv);
-	DUK_TVAL_INCREF(thr, tv);  /* no side effects */
+	DUK_TVAL_INCREF(thr, tv); /* no side effects */
 }
 
 DUK_EXTERNAL void duk_push_undefined(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	DUK__CHECK_SPACE();
 
@@ -22359,15 +23076,15 @@
 
 DUK_EXTERNAL void duk_push_boolean(duk_hthread *thr, duk_bool_t val) {
 	duk_tval *tv_slot;
 	duk_small_int_t b;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__CHECK_SPACE();
-	b = (val ? 1 : 0);  /* ensure value is 1 or 0 (not other non-zero) */
+	b = (val ? 1 : 0); /* ensure value is 1 or 0 (not other non-zero) */
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_BOOLEAN(tv_slot, b);
 }
 
 DUK_EXTERNAL void duk_push_true(duk_hthread *thr) {
 	duk_tval *tv_slot;
 
@@ -22412,54 +23129,54 @@
 	if (val >= DUK_FASTINT_MIN && val <= DUK_FASTINT_MAX) {
 		DUK_TVAL_SET_FASTINT(tv_slot, (duk_int64_t) val);
 	} else {
 		duk_double_t = (duk_double_t) val;
 		DUK_TVAL_SET_NUMBER(tv_slot, d);
 	}
 #endif
-#else  /* DUK_USE_FASTINT */
+#else /* DUK_USE_FASTINT */
 	duk_tval *tv_slot;
 	duk_double_t d;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__CHECK_SPACE();
 	d = (duk_double_t) val;
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_NUMBER(tv_slot, d);
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 }
 
 DUK_EXTERNAL void duk_push_uint(duk_hthread *thr, duk_uint_t val) {
 #if defined(DUK_USE_FASTINT)
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__CHECK_SPACE();
 	tv_slot = thr->valstack_top++;
 #if DUK_UINT_MAX <= 0xffffffffUL
 	DUK_TVAL_SET_U32(tv_slot, (duk_uint32_t) val);
 #else
-	if (val <= DUK_FASTINT_MAX) {  /* val is unsigned so >= 0 */
+	if (val <= DUK_FASTINT_MAX) { /* val is unsigned so >= 0 */
 		/* XXX: take advantage of val being unsigned, no need to mask */
 		DUK_TVAL_SET_FASTINT(tv_slot, (duk_int64_t) val);
 	} else {
 		duk_double_t = (duk_double_t) val;
 		DUK_TVAL_SET_NUMBER(tv_slot, d);
 	}
 #endif
-#else  /* DUK_USE_FASTINT */
+#else /* DUK_USE_FASTINT */
 	duk_tval *tv_slot;
 	duk_double_t d;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__CHECK_SPACE();
 	d = (duk_double_t) val;
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_NUMBER(tv_slot, d);
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 }
 
 DUK_EXTERNAL void duk_push_nan(duk_hthread *thr) {
 	duk_tval *tv_slot;
 	duk_double_union du;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -22495,15 +23212,15 @@
 	}
 
 	h = duk_heap_strtable_intern_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 	DUK_ASSERT(h != NULL);
 
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_STRING(tv_slot, h);
-	DUK_HSTRING_INCREF(thr, h);  /* no side effects */
+	DUK_HSTRING_INCREF(thr, h); /* no side effects */
 
 	return (const char *) DUK_HSTRING_GET_DATA(h);
 }
 
 DUK_EXTERNAL const char *duk_push_string(duk_hthread *thr, const char *str) {
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -22532,28 +23249,28 @@
 	}
 
 	h = duk_heap_strtable_intern_literal_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 	DUK_ASSERT(h != NULL);
 
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_STRING(tv_slot, h);
-	DUK_HSTRING_INCREF(thr, h);  /* no side effects */
+	DUK_HSTRING_INCREF(thr, h); /* no side effects */
 
 	return (const char *) DUK_HSTRING_GET_DATA(h);
 }
-#else  /* DUK_USE_LITCACHE_SIZE */
+#else /* DUK_USE_LITCACHE_SIZE */
 DUK_EXTERNAL const char *duk_push_literal_raw(duk_hthread *thr, const char *str, duk_size_t len) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(str != NULL);
 	DUK_ASSERT(str[len] == (char) 0);
 
 	return duk_push_lstring(thr, str, len);
 }
-#endif  /* DUK_USE_LITCACHE_SIZE */
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_LITCACHE_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 DUK_EXTERNAL void duk_push_pointer(duk_hthread *thr, void *val) {
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__CHECK_SPACE();
 	tv_slot = thr->valstack_top++;
@@ -22573,40 +23290,39 @@
 }
 
 DUK_LOCAL void duk__push_this_helper(duk_hthread *thr, duk_small_uint_t check_object_coercible) {
 	duk_tval *tv_slot;
 
 	DUK__CHECK_SPACE();
 
-	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));  /* because of valstack init policy */
+	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top)); /* because of valstack init policy */
 	tv_slot = thr->valstack_top++;
 
 	if (DUK_UNLIKELY(thr->callstack_curr == NULL)) {
 		if (check_object_coercible) {
 			goto type_error;
 		}
 		/* 'undefined' already on stack top */
 	} else {
 		duk_tval *tv;
 
 		/* 'this' binding is just before current activation's bottom */
 		DUK_ASSERT(thr->valstack_bottom > thr->valstack);
 		tv = thr->valstack_bottom - 1;
-		if (check_object_coercible &&
-		    (DUK_TVAL_IS_UNDEFINED(tv) || DUK_TVAL_IS_NULL(tv))) {
+		if (check_object_coercible && (DUK_TVAL_IS_UNDEFINED(tv) || DUK_TVAL_IS_NULL(tv))) {
 			/* XXX: better macro for DUK_TVAL_IS_UNDEFINED_OR_NULL(tv) */
 			goto type_error;
 		}
 
 		DUK_TVAL_SET_TVAL(tv_slot, tv);
 		DUK_TVAL_INCREF(thr, tv);
 	}
 	return;
 
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_NOT_OBJECT_COERCIBLE);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_push_this(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -22630,24 +23346,24 @@
 	return h;
 }
 
 DUK_INTERNAL duk_hstring *duk_push_this_coercible_to_string(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk__push_this_helper(thr, 1 /*check_object_coercible*/);
-	return duk_to_hstring_m1(thr);  /* This will reject all Symbol values; accepts Symbol objects. */
+	return duk_to_hstring_m1(thr); /* This will reject all Symbol values; accepts Symbol objects. */
 }
 
 DUK_INTERNAL duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
-	DUK_ASSERT(thr->callstack_top > 0);  /* caller required to know */
-	DUK_ASSERT(thr->callstack_curr != NULL);  /* caller required to know */
-	DUK_ASSERT(thr->valstack_bottom > thr->valstack);  /* consequence of above */
-	DUK_ASSERT(thr->valstack_bottom - 1 >= thr->valstack);  /* 'this' binding exists */
+	DUK_ASSERT(thr->callstack_top > 0); /* caller required to know */
+	DUK_ASSERT(thr->callstack_curr != NULL); /* caller required to know */
+	DUK_ASSERT(thr->valstack_bottom > thr->valstack); /* consequence of above */
+	DUK_ASSERT(thr->valstack_bottom - 1 >= thr->valstack); /* 'this' binding exists */
 
 	return thr->valstack_bottom - 1;
 }
 
 DUK_EXTERNAL void duk_push_new_target(duk_hthread *thr) {
 	duk_activation *act;
 
@@ -22720,15 +23436,18 @@
 /* XXX: size optimize */
 DUK_LOCAL void duk__push_stash(duk_hthread *thr) {
 	if (!duk_xget_owndataprop_stridx_short(thr, -1, DUK_STRIDX_INT_VALUE)) {
 		DUK_DDD(DUK_DDDPRINT("creating heap/global/thread stash on first use"));
 		duk_pop_unsafe(thr);
 		duk_push_bare_object(thr);
 		duk_dup_top(thr);
-		duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_C);  /* [ ... parent stash stash ] -> [ ... parent stash ] */
+		duk_xdef_prop_stridx_short(thr,
+		                           -3,
+		                           DUK_STRIDX_INT_VALUE,
+		                           DUK_PROPDESC_FLAGS_C); /* [ ... parent stash stash ] -> [ ... parent stash ] */
 	}
 	duk_remove_m2(thr);
 }
 
 DUK_EXTERNAL void duk_push_heap_stash(duk_hthread *thr) {
 	duk_heap *heap;
 	DUK_ASSERT_API_ENTRY(thr);
@@ -22773,39 +23492,39 @@
 }
 
 DUK_EXTERNAL const char *duk_push_vsprintf(duk_hthread *thr, const char *fmt, va_list ap) {
 	duk_uint8_t stack_buf[DUK_PUSH_SPRINTF_INITIAL_SIZE];
 	duk_size_t sz = DUK_PUSH_SPRINTF_INITIAL_SIZE;
 	duk_bool_t pushed_buf = 0;
 	void *buf;
-	duk_int_t len;  /* XXX: duk_ssize_t */
+	duk_int_t len; /* XXX: duk_ssize_t */
 	const char *res;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	/* special handling of fmt==NULL */
 	if (!fmt) {
 		duk_hstring *h_str;
 		duk_push_hstring_empty(thr);
 		h_str = duk_known_hstring(thr, -1);
 		return (const char *) DUK_HSTRING_GET_DATA(h_str);
 	}
 
 	/* initial estimate based on format string */
-	sz = DUK_STRLEN(fmt) + 16;  /* format plus something to avoid just missing */
+	sz = DUK_STRLEN(fmt) + 16; /* format plus something to avoid just missing */
 	if (sz < DUK_PUSH_SPRINTF_INITIAL_SIZE) {
 		sz = DUK_PUSH_SPRINTF_INITIAL_SIZE;
 	}
 	DUK_ASSERT(sz > 0);
 
 	/* Try to make do with a stack buffer to avoid allocating a temporary buffer.
 	 * This works 99% of the time which is quite nice.
 	 */
 	for (;;) {
-		va_list ap_copy;  /* copied so that 'ap' can be reused */
+		va_list ap_copy; /* copied so that 'ap' can be reused */
 
 		if (sz <= sizeof(stack_buf)) {
 			buf = stack_buf;
 		} else if (!pushed_buf) {
 			pushed_buf = 1;
 			buf = duk_push_dynamic_buffer(thr, sz);
 		} else {
@@ -22827,15 +23546,15 @@
 			DUK_WO_NORETURN(return NULL;);
 		}
 	}
 
 	/* Cannot use duk_buffer_to_string() on the buffer because it is
 	 * usually larger than 'len'; 'buf' is also usually a stack buffer.
 	 */
-	res = duk_push_lstring(thr, (const char *) buf, (duk_size_t) len);  /* [ buf? res ] */
+	res = duk_push_lstring(thr, (const char *) buf, (duk_size_t) len); /* [ buf? res ] */
 	if (pushed_buf) {
 		duk_remove_m2(thr);
 	}
 	return res;
 }
 
 DUK_EXTERNAL const char *duk_push_sprintf(duk_hthread *thr, const char *fmt, ...) {
@@ -22848,32 +23567,33 @@
 	va_start(ap, fmt);
 	ret = duk_push_vsprintf(thr, fmt, ap);
 	va_end(ap);
 
 	return ret;
 }
 
-DUK_INTERNAL duk_hobject *duk_push_object_helper(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx) {
+DUK_INTERNAL duk_hobject *duk_push_object_helper(duk_hthread *thr,
+                                                 duk_uint_t hobject_flags_and_class,
+                                                 duk_small_int_t prototype_bidx) {
 	duk_tval *tv_slot;
 	duk_hobject *h;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(prototype_bidx == -1 ||
-	           (prototype_bidx >= 0 && prototype_bidx < DUK_NUM_BUILTINS));
+	DUK_ASSERT(prototype_bidx == -1 || (prototype_bidx >= 0 && prototype_bidx < DUK_NUM_BUILTINS));
 
 	DUK__CHECK_SPACE();
 
 	h = duk_hobject_alloc(thr, hobject_flags_and_class);
 	DUK_ASSERT(h != NULL);
 
 	DUK_DDD(DUK_DDDPRINT("created object with flags: 0x%08lx", (unsigned long) h->hdr.h_flags));
 
 	tv_slot = thr->valstack_top;
 	DUK_TVAL_SET_OBJECT(tv_slot, h);
-	DUK_HOBJECT_INCREF(thr, h);  /* no side effects */
+	DUK_HOBJECT_INCREF(thr, h); /* no side effects */
 	thr->valstack_top++;
 
 	/* object is now reachable */
 
 	if (prototype_bidx >= 0) {
 		DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, h, thr->builtins[prototype_bidx]);
 	} else {
@@ -22895,74 +23615,67 @@
 	return h;
 }
 
 DUK_EXTERNAL duk_idx_t duk_push_object(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
 	                              DUK_BIDX_OBJECT_PROTOTYPE);
 	return duk_get_top_index_unsafe(thr);
 }
 
 DUK_EXTERNAL duk_idx_t duk_push_array(duk_hthread *thr) {
 	duk_uint_t flags;
 	duk_harray *obj;
 	duk_idx_t ret;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_ARRAY_PART |
-	        DUK_HOBJECT_FLAG_EXOTIC_ARRAY |
-	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAY);
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_ARRAY_PART |
+	        DUK_HOBJECT_FLAG_EXOTIC_ARRAY | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAY);
 
 	obj = duk_harray_alloc(thr, flags);
 	DUK_ASSERT(obj != NULL);
 
 	DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, (duk_hobject *) obj, thr->builtins[DUK_BIDX_ARRAY_PROTOTYPE]);
 
 	tv_slot = thr->valstack_top;
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) obj);
-	DUK_HOBJECT_INCREF(thr, obj);  /* XXX: could preallocate with refcount = 1 */
+	DUK_HOBJECT_INCREF(thr, obj); /* XXX: could preallocate with refcount = 1 */
 	ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 	thr->valstack_top++;
 
-	DUK_ASSERT(obj->length == 0);  /* Array .length starts at zero. */
+	DUK_ASSERT(obj->length == 0); /* Array .length starts at zero. */
 	return ret;
 }
 
 DUK_EXTERNAL duk_idx_t duk_push_bare_array(duk_hthread *thr) {
 	duk_uint_t flags;
 	duk_harray *obj;
 	duk_idx_t ret;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_ARRAY_PART |
-	        DUK_HOBJECT_FLAG_EXOTIC_ARRAY |
-	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAY);
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_ARRAY_PART |
+	        DUK_HOBJECT_FLAG_EXOTIC_ARRAY | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAY);
 
 	obj = duk_harray_alloc(thr, flags);
 	DUK_ASSERT(obj != NULL);
 
 	tv_slot = thr->valstack_top;
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) obj);
-	DUK_HOBJECT_INCREF(thr, obj);  /* XXX: could preallocate with refcount = 1 */
+	DUK_HOBJECT_INCREF(thr, obj); /* XXX: could preallocate with refcount = 1 */
 	ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 	thr->valstack_top++;
 
-	DUK_ASSERT(obj->length == 0);  /* Array .length starts at zero. */
+	DUK_ASSERT(obj->length == 0); /* Array .length starts at zero. */
 	return ret;
 }
 
 DUK_INTERNAL duk_harray *duk_push_harray(duk_hthread *thr) {
 	/* XXX: API call could do this directly, cast to void in API macro. */
 	duk_harray *a;
 
@@ -22981,20 +23694,15 @@
 DUK_INTERNAL duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size) {
 	duk_harray *a;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	a = duk_push_harray(thr);
 
-	duk_hobject_realloc_props(thr,
-	                          (duk_hobject *) a,
-	                          0,
-	                          size,
-	                          0,
-	                          0);
+	duk_hobject_realloc_props(thr, (duk_hobject *) a, 0, size, 0, 0);
 	a->length = size;
 	return a;
 }
 
 DUK_INTERNAL duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size) {
 	duk_harray *a;
 
@@ -23010,17 +23718,15 @@
 	duk_idx_t ret;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	DUK__CHECK_SPACE();
 
-	obj = duk_hthread_alloc(thr,
-	                        DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_THREAD));
+	obj = duk_hthread_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_THREAD));
 	DUK_ASSERT(obj != NULL);
 	obj->state = DUK_HTHREAD_STATE_INACTIVE;
 #if defined(DUK_USE_ROM_STRINGS)
 	/* Nothing to initialize, strs[] is in ROM. */
 #else
 #if defined(DUK_USE_HEAPPTR16)
 	obj->strs16 = thr->strs16;
@@ -23052,16 +23758,15 @@
 
 	/* default prototype */
 	DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, (duk_hobject *) obj, obj->builtins[DUK_BIDX_THREAD_PROTOTYPE]);
 
 	/* Initial stack size satisfies the stack slack constraints so there
 	 * is no need to require stack here.
 	 */
-	DUK_ASSERT(DUK_VALSTACK_INITIAL_SIZE >=
-	           DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
+	DUK_ASSERT(DUK_VALSTACK_INITIAL_SIZE >= DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
 
 	return ret;
 }
 
 DUK_INTERNAL duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr) {
 	duk_hcompfunc *obj;
 	duk_tval *tv_slot;
@@ -23072,18 +23777,16 @@
 
 	/* Template functions are not strictly constructable (they don't
 	 * have a "prototype" property for instance), so leave the
 	 * DUK_HOBJECT_FLAG_CONSRUCTABLE flag cleared here.
 	 */
 
 	obj = duk_hcompfunc_alloc(thr,
-	                          DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                          DUK_HOBJECT_FLAG_CALLABLE |
-	                          DUK_HOBJECT_FLAG_COMPFUNC |
-	                          DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION));
+	                          DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_CALLABLE | DUK_HOBJECT_FLAG_COMPFUNC |
+	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION));
 	if (DUK_UNLIKELY(obj == NULL)) {
 		DUK_ERROR_ALLOC_FAILED(thr);
 		DUK_WO_NORETURN(return NULL;);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("created compiled function object with flags: 0x%08lx", (unsigned long) obj->obj.hdr.h_flags));
 
@@ -23103,19 +23806,16 @@
 	duk_hboundfunc *obj;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	DUK__CHECK_SPACE();
 	obj = duk_hboundfunc_alloc(thr->heap,
-	                           DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                           DUK_HOBJECT_FLAG_BOUNDFUNC |
-	                           DUK_HOBJECT_FLAG_CONSTRUCTABLE |
-	                           DUK_HOBJECT_FLAG_CALLABLE |
-	                           DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION));
+	                           DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BOUNDFUNC | DUK_HOBJECT_FLAG_CONSTRUCTABLE |
+	                               DUK_HOBJECT_FLAG_CALLABLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION));
 	if (!obj) {
 		DUK_ERROR_ALLOC_FAILED(thr);
 		DUK_WO_NORETURN(return NULL;);
 	}
 
 	tv_slot = thr->valstack_top++;
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) obj);
@@ -23125,15 +23825,16 @@
 	 * it depends on the target function).
 	 */
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) obj) == NULL);
 
 	return obj;
 }
 
-DUK_LOCAL duk_idx_t duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx) {
+DUK_LOCAL duk_idx_t
+duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx) {
 	duk_hnatfunc *obj;
 	duk_idx_t ret;
 	duk_tval *tv_slot;
 	duk_int16_t func_nargs;
 
 	DUK_CTX_ASSERT_VALID(thr);
 
@@ -23153,90 +23854,75 @@
 	obj = duk_hnatfunc_alloc(thr, flags);
 	DUK_ASSERT(obj != NULL);
 
 	obj->func = func;
 	obj->nargs = func_nargs;
 
 	DUK_DDD(DUK_DDDPRINT("created native function object with flags: 0x%08lx, nargs=%ld",
-	                     (unsigned long) obj->obj.hdr.h_flags, (long) obj->nargs));
+	                     (unsigned long) obj->obj.hdr.h_flags,
+	                     (long) obj->nargs));
 
 	tv_slot = thr->valstack_top;
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) obj);
 	DUK_HOBJECT_INCREF(thr, obj);
 	ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 	thr->valstack_top++;
 
 	DUK_ASSERT_BIDX_VALID(proto_bidx);
 	DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, (duk_hobject *) obj, thr->builtins[proto_bidx]);
 	return ret;
 
- api_error:
+api_error:
 	DUK_ERROR_TYPE_INVALID_ARGS(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_EXTERNAL duk_idx_t duk_push_c_function(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 	duk_uint_t flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_CONSTRUCTABLE |
-	        DUK_HOBJECT_FLAG_CALLABLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_NATFUNC |
-	        DUK_HOBJECT_FLAG_NEWENV |
-	        DUK_HOBJECT_FLAG_STRICT |
-	        DUK_HOBJECT_FLAG_NOTAIL |
-	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_CONSTRUCTABLE | DUK_HOBJECT_FLAG_CALLABLE |
+	        DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_NATFUNC | DUK_HOBJECT_FLAG_NEWENV | DUK_HOBJECT_FLAG_STRICT |
+	        DUK_HOBJECT_FLAG_NOTAIL | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
 
 	/* Default prototype is a Duktape specific %NativeFunctionPrototype%
 	 * which provides .length and .name getters.
 	 */
 	return duk__push_c_function_raw(thr, func, nargs, flags, DUK_BIDX_NATIVE_FUNCTION_PROTOTYPE);
 }
 
 DUK_INTERNAL void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 	duk_uint_t flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_CONSTRUCTABLE |
-	        DUK_HOBJECT_FLAG_CALLABLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_NATFUNC |
-	        DUK_HOBJECT_FLAG_NEWENV |
-	        DUK_HOBJECT_FLAG_STRICT |
-	        DUK_HOBJECT_FLAG_NOTAIL |
-	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_CONSTRUCTABLE | DUK_HOBJECT_FLAG_CALLABLE |
+	        DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_NATFUNC | DUK_HOBJECT_FLAG_NEWENV | DUK_HOBJECT_FLAG_STRICT |
+	        DUK_HOBJECT_FLAG_NOTAIL | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
 
 	/* Must use Function.prototype for standard built-in functions. */
 	(void) duk__push_c_function_raw(thr, func, nargs, flags, DUK_BIDX_FUNCTION_PROTOTYPE);
 }
 
 DUK_INTERNAL void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 	duk_uint_t flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	        DUK_HOBJECT_FLAG_CALLABLE |
-	        DUK_HOBJECT_FLAG_FASTREFS |
-	        DUK_HOBJECT_FLAG_NATFUNC |
-	        DUK_HOBJECT_FLAG_NEWENV |
-	        DUK_HOBJECT_FLAG_STRICT |
-	        DUK_HOBJECT_FLAG_NOTAIL |
+	flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_CALLABLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_NATFUNC |
+	        DUK_HOBJECT_FLAG_NEWENV | DUK_HOBJECT_FLAG_STRICT | DUK_HOBJECT_FLAG_NOTAIL |
 	        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION);
 
 	/* Must use Function.prototype for standard built-in functions. */
 	(void) duk__push_c_function_raw(thr, func, nargs, flags, DUK_BIDX_FUNCTION_PROTOTYPE);
 }
 
-DUK_EXTERNAL duk_idx_t duk_push_c_lightfunc(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic) {
+DUK_EXTERNAL duk_idx_t
+duk_push_c_lightfunc(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic) {
 	duk_small_uint_t lf_flags;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	DUK__CHECK_SPACE();
 
@@ -23257,21 +23943,23 @@
 	lf_flags = DUK_LFUNC_FLAGS_PACK((duk_small_int_t) magic, (duk_small_uint_t) length, (duk_small_uint_t) nargs);
 	tv_slot = thr->valstack_top++;
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv_slot));
 	DUK_TVAL_SET_LIGHTFUNC(tv_slot, func, lf_flags);
 	DUK_ASSERT(tv_slot >= thr->valstack_bottom);
 	return (duk_idx_t) (tv_slot - thr->valstack_bottom);
 
- api_error:
+api_error:
 	DUK_ERROR_TYPE_INVALID_ARGS(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-DUK_INTERNAL duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_small_int_t prototype_bidx) {
+DUK_INTERNAL duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr,
+                                              duk_uint_t hobject_flags_and_class,
+                                              duk_small_int_t prototype_bidx) {
 	duk_hbufobj *obj;
 	duk_tval *tv_slot;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(prototype_bidx >= 0);
 
 	DUK__CHECK_SPACE();
@@ -23285,42 +23973,94 @@
 	tv_slot = thr->valstack_top;
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) obj);
 	DUK_HOBJECT_INCREF(thr, obj);
 	thr->valstack_top++;
 
 	return obj;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* XXX: There's quite a bit of overlap with buffer creation handling in
  * duk_bi_buffer.c.  Look for overlap and refactor.
  */
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-#define DUK__PACK_ARGS(classnum,protobidx,elemtype,elemshift,istypedarray) \
+#define DUK__PACK_ARGS(classnum, protobidx, elemtype, elemshift, istypedarray) \
 	(((classnum) << 24) | ((protobidx) << 16) | ((elemtype) << 8) | ((elemshift) << 4) | (istypedarray))
 
 static const duk_uint32_t duk__bufobj_flags_lookup[] = {
 	/* Node.js Buffers are Uint8Array instances which inherit from Buffer.prototype. */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_ARRAYBUFFER,       DUK_BIDX_ARRAYBUFFER_PROTOTYPE,       DUK_HBUFOBJ_ELEM_UINT8,        0, 0),  /* DUK_BUFOBJ_ARRAYBUFFER */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8ARRAY,        DUK_BIDX_NODEJS_BUFFER_PROTOTYPE,     DUK_HBUFOBJ_ELEM_UINT8,        0, 1),  /* DUK_BUFOBJ_NODEJS_BUFFER */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_DATAVIEW,          DUK_BIDX_DATAVIEW_PROTOTYPE,          DUK_HBUFOBJ_ELEM_UINT8,        0, 0),  /* DUK_BUFOBJ_DATAVIEW */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT8ARRAY,         DUK_BIDX_INT8ARRAY_PROTOTYPE,         DUK_HBUFOBJ_ELEM_INT8,         0, 1),  /* DUK_BUFOBJ_INT8ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8ARRAY,        DUK_BIDX_UINT8ARRAY_PROTOTYPE,        DUK_HBUFOBJ_ELEM_UINT8,        0, 1),  /* DUK_BUFOBJ_UINT8ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY, DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE, DUK_HBUFOBJ_ELEM_UINT8CLAMPED, 0, 1),  /* DUK_BUFOBJ_UINT8CLAMPEDARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT16ARRAY,        DUK_BIDX_INT16ARRAY_PROTOTYPE,        DUK_HBUFOBJ_ELEM_INT16,        1, 1),  /* DUK_BUFOBJ_INT16ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT16ARRAY,       DUK_BIDX_UINT16ARRAY_PROTOTYPE,       DUK_HBUFOBJ_ELEM_UINT16,       1, 1),  /* DUK_BUFOBJ_UINT16ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT32ARRAY,        DUK_BIDX_INT32ARRAY_PROTOTYPE,        DUK_HBUFOBJ_ELEM_INT32,        2, 1),  /* DUK_BUFOBJ_INT32ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT32ARRAY,       DUK_BIDX_UINT32ARRAY_PROTOTYPE,       DUK_HBUFOBJ_ELEM_UINT32,       2, 1),  /* DUK_BUFOBJ_UINT32ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_FLOAT32ARRAY,      DUK_BIDX_FLOAT32ARRAY_PROTOTYPE,      DUK_HBUFOBJ_ELEM_FLOAT32,      2, 1),  /* DUK_BUFOBJ_FLOAT32ARRAY */
-	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_FLOAT64ARRAY,      DUK_BIDX_FLOAT64ARRAY_PROTOTYPE,      DUK_HBUFOBJ_ELEM_FLOAT64,      3, 1)   /* DUK_BUFOBJ_FLOAT64ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_ARRAYBUFFER,
+	               DUK_BIDX_ARRAYBUFFER_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT8,
+	               0,
+	               0), /* DUK_BUFOBJ_ARRAYBUFFER */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8ARRAY,
+	               DUK_BIDX_NODEJS_BUFFER_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT8,
+	               0,
+	               1), /* DUK_BUFOBJ_NODEJS_BUFFER */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_DATAVIEW,
+	               DUK_BIDX_DATAVIEW_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT8,
+	               0,
+	               0), /* DUK_BUFOBJ_DATAVIEW */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT8ARRAY,
+	               DUK_BIDX_INT8ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_INT8,
+	               0,
+	               1), /* DUK_BUFOBJ_INT8ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8ARRAY,
+	               DUK_BIDX_UINT8ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT8,
+	               0,
+	               1), /* DUK_BUFOBJ_UINT8ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY,
+	               DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT8CLAMPED,
+	               0,
+	               1), /* DUK_BUFOBJ_UINT8CLAMPEDARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT16ARRAY,
+	               DUK_BIDX_INT16ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_INT16,
+	               1,
+	               1), /* DUK_BUFOBJ_INT16ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT16ARRAY,
+	               DUK_BIDX_UINT16ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT16,
+	               1,
+	               1), /* DUK_BUFOBJ_UINT16ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_INT32ARRAY,
+	               DUK_BIDX_INT32ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_INT32,
+	               2,
+	               1), /* DUK_BUFOBJ_INT32ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_UINT32ARRAY,
+	               DUK_BIDX_UINT32ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_UINT32,
+	               2,
+	               1), /* DUK_BUFOBJ_UINT32ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_FLOAT32ARRAY,
+	               DUK_BIDX_FLOAT32ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_FLOAT32,
+	               2,
+	               1), /* DUK_BUFOBJ_FLOAT32ARRAY */
+	DUK__PACK_ARGS(DUK_HOBJECT_CLASS_FLOAT64ARRAY,
+	               DUK_BIDX_FLOAT64ARRAY_PROTOTYPE,
+	               DUK_HBUFOBJ_ELEM_FLOAT64,
+	               3,
+	               1) /* DUK_BUFOBJ_FLOAT64ARRAY */
 };
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
-DUK_EXTERNAL void duk_push_buffer_object(duk_hthread *thr, duk_idx_t idx_buffer, duk_size_t byte_offset, duk_size_t byte_length, duk_uint_t flags) {
+DUK_EXTERNAL void duk_push_buffer_object(duk_hthread *thr,
+                                         duk_idx_t idx_buffer,
+                                         duk_size_t byte_offset,
+                                         duk_size_t byte_length,
+                                         duk_uint_t flags) {
 	duk_hbufobj *h_bufobj;
 	duk_hbuffer *h_val;
 	duk_hobject *h_arraybuf;
 	duk_uint32_t tmp;
 	duk_uint_t classnum;
 	duk_uint_t protobidx;
 	duk_uint_t lookupidx;
@@ -23335,27 +24075,27 @@
 	uint_length = (duk_uint_t) byte_length;
 	if (sizeof(duk_size_t) != sizeof(duk_uint_t)) {
 		if (DUK_UNLIKELY((duk_size_t) uint_offset != byte_offset || (duk_size_t) uint_length != byte_length)) {
 			goto range_error;
 		}
 	}
 
-	DUK_ASSERT_DISABLE(flags >= 0);  /* flags is unsigned */
+	DUK_ASSERT_DISABLE(flags >= 0); /* flags is unsigned */
 	lookupidx = flags;
 	if (DUK_UNLIKELY(lookupidx >= sizeof(duk__bufobj_flags_lookup) / sizeof(duk_uint32_t))) {
 		goto arg_error;
 	}
 	tmp = duk__bufobj_flags_lookup[lookupidx];
 	classnum = tmp >> 24;
 	protobidx = (tmp >> 16) & 0xff;
 
 	h_arraybuf = duk_get_hobject(thr, idx_buffer);
-	if (h_arraybuf != NULL &&  /* argument is an object */
-	    flags != DUK_BUFOBJ_ARRAYBUFFER &&  /* creating a view */
-	    DUK_HOBJECT_GET_CLASS_NUMBER(h_arraybuf) == DUK_HOBJECT_CLASS_ARRAYBUFFER  /* argument is ArrayBuffer */) {
+	if (h_arraybuf != NULL && /* argument is an object */
+	    flags != DUK_BUFOBJ_ARRAYBUFFER && /* creating a view */
+	    DUK_HOBJECT_GET_CLASS_NUMBER(h_arraybuf) == DUK_HOBJECT_CLASS_ARRAYBUFFER /* argument is ArrayBuffer */) {
 		duk_uint_t tmp_offset;
 
 		DUK_HBUFOBJ_ASSERT_VALID((duk_hbufobj *) h_arraybuf);
 		h_val = ((duk_hbufobj *) h_arraybuf)->buf;
 		if (DUK_UNLIKELY(h_val == NULL)) {
 			goto arg_error;
 		}
@@ -23384,17 +24124,15 @@
 		goto range_error;
 	}
 	DUK_ASSERT(uint_added >= uint_offset && uint_added >= uint_length);
 
 	DUK_ASSERT(h_val != NULL);
 
 	h_bufobj = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(classnum),
+	                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ | DUK_HOBJECT_CLASS_AS_FLAGS(classnum),
 	                               (duk_small_int_t) protobidx);
 	DUK_ASSERT(h_bufobj != NULL);
 
 	h_bufobj->buf = h_val;
 	DUK_HBUFFER_INCREF(thr, h_val);
 	h_bufobj->buf_prop = h_arraybuf;
 	DUK_HOBJECT_INCREF_ALLOWNULL(thr, h_arraybuf);
@@ -23409,35 +24147,44 @@
 	 * provided as .buffer property of the view.  The ArrayBuffer is
 	 * referenced via duk_hbufobj->buf_prop and an inherited .buffer
 	 * accessor returns it.  The ArrayBuffer is created lazily on first
 	 * access if necessary so we don't need to do anything more here.
 	 */
 	return;
 
- range_error:
+range_error:
 	DUK_ERROR_RANGE(thr, DUK_STR_INVALID_ARGS);
 	DUK_WO_NORETURN(return;);
 
- arg_error:
+arg_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_ARGS);
 	DUK_WO_NORETURN(return;);
 }
-#else  /* DUK_USE_BUFFEROBJECT_SUPPORT */
-DUK_EXTERNAL void duk_push_buffer_object(duk_hthread *thr, duk_idx_t idx_buffer, duk_size_t byte_offset, duk_size_t byte_length, duk_uint_t flags) {
+#else /* DUK_USE_BUFFEROBJECT_SUPPORT */
+DUK_EXTERNAL void duk_push_buffer_object(duk_hthread *thr,
+                                         duk_idx_t idx_buffer,
+                                         duk_size_t byte_offset,
+                                         duk_size_t byte_length,
+                                         duk_uint_t flags) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(idx_buffer);
 	DUK_UNREF(byte_offset);
 	DUK_UNREF(byte_length);
 	DUK_UNREF(flags);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
-DUK_EXTERNAL duk_idx_t duk_push_error_object_va_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap) {
+DUK_EXTERNAL duk_idx_t duk_push_error_object_va_raw(duk_hthread *thr,
+                                                    duk_errcode_t err_code,
+                                                    const char *filename,
+                                                    duk_int_t line,
+                                                    const char *fmt,
+                                                    va_list ap) {
 	duk_hobject *proto;
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
 	duk_small_uint_t augment_flags;
 #endif
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr != NULL);
@@ -23452,17 +24199,16 @@
 	}
 #endif
 	err_code = err_code & (~DUK_ERRCODE_FLAG_NOBLAME_FILELINE);
 
 	/* error gets its 'name' from the prototype */
 	proto = duk_error_prototype_from_code(thr, err_code);
 	(void) duk_push_object_helper_proto(thr,
-	                                    DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                    DUK_HOBJECT_FLAG_FASTREFS |
-	                                    DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ERROR),
+	                                    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ERROR),
 	                                    proto);
 
 	/* ... and its 'message' from an instance property */
 	if (fmt) {
 		duk_push_vsprintf(thr, fmt, ap);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_MESSAGE, DUK_PROPDESC_FLAGS_WC);
 	} else {
@@ -23477,21 +24223,22 @@
 	}
 
 	/* XXX: .code = err_code disabled, not sure if useful */
 
 	/* Creation time error augmentation */
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
 	/* filename may be NULL in which case file/line is not recorded */
-	duk_err_augment_error_create(thr, thr, filename, line, augment_flags);  /* may throw an error */
+	duk_err_augment_error_create(thr, thr, filename, line, augment_flags); /* may throw an error */
 #endif
 
 	return duk_get_top_index_unsafe(thr);
 }
 
-DUK_EXTERNAL duk_idx_t duk_push_error_object_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
+DUK_EXTERNAL duk_idx_t
+duk_push_error_object_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
 	va_list ap;
 	duk_idx_t ret;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	va_start(ap, fmt);
 	ret = duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
@@ -23511,15 +24258,15 @@
 	duk_api_global_filename = NULL;
 	duk_api_global_line = 0;
 	va_start(ap, fmt);
 	ret = duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 	va_end(ap);
 	return ret;
 }
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
 DUK_EXTERNAL void *duk_push_buffer_raw(duk_hthread *thr, duk_size_t size, duk_small_uint_t flags) {
 	duk_tval *tv_slot;
 	duk_hbuffer *h;
 	void *buf_data;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -23614,21 +24361,18 @@
 	/* XXX: Proxy object currently has no prototype, so ToPrimitive()
 	 * coercion fails which is a bit confusing.
 	 */
 
 	/* CALLABLE and CONSTRUCTABLE flags are copied from the (initial)
 	 * target, see ES2015 Sections 9.5.15 and 9.5.13.
 	 */
-	flags = DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) h_target) &
-	        (DUK_HOBJECT_FLAG_CALLABLE | DUK_HOBJECT_FLAG_CONSTRUCTABLE);
-	flags |= DUK_HOBJECT_FLAG_EXTENSIBLE |
-	         DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ;
+	flags = DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) h_target) & (DUK_HOBJECT_FLAG_CALLABLE | DUK_HOBJECT_FLAG_CONSTRUCTABLE);
+	flags |= DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ;
 	if (flags & DUK_HOBJECT_FLAG_CALLABLE) {
-		flags |= DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION) |
-		         DUK_HOBJECT_FLAG_SPECIAL_CALL;
+		flags |= DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_FUNCTION) | DUK_HOBJECT_FLAG_SPECIAL_CALL;
 	} else {
 		flags |= DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT);
 	}
 
 	h_proxy = duk_hproxy_alloc(thr, flags);
 	DUK_ASSERT(h_proxy != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) h_proxy) == NULL);
@@ -23646,33 +24390,33 @@
 	DUK_ASSERT(duk_get_hobject(thr, -2) == h_target);
 	DUK_ASSERT(duk_get_hobject(thr, -1) == h_handler);
 	tv_slot = thr->valstack_top - 2;
 	DUK_ASSERT(tv_slot >= thr->valstack_bottom);
 	DUK_TVAL_SET_OBJECT(tv_slot, (duk_hobject *) h_proxy);
 	DUK_HOBJECT_INCREF(thr, (duk_hobject *) h_proxy);
 	tv_slot++;
-	DUK_TVAL_SET_UNDEFINED(tv_slot);  /* [ ... target handler ] -> [ ... proxy undefined ] */
-	thr->valstack_top = tv_slot;      /* -> [ ... proxy ] */
+	DUK_TVAL_SET_UNDEFINED(tv_slot); /* [ ... target handler ] -> [ ... proxy undefined ] */
+	thr->valstack_top = tv_slot; /* -> [ ... proxy ] */
 
 	DUK_DD(DUK_DDPRINT("created Proxy: %!iT", duk_get_tval(thr, -1)));
 
 	return (duk_idx_t) (thr->valstack_top - thr->valstack_bottom - 1);
 
- fail_args:
+fail_args:
 	DUK_ERROR_TYPE_INVALID_ARGS(thr);
 	DUK_WO_NORETURN(return 0;);
 }
-#else  /* DUK_USE_ES6_PROXY */
+#else /* DUK_USE_ES6_PROXY */
 DUK_EXTERNAL duk_idx_t duk_push_proxy(duk_hthread *thr, duk_uint_t proxy_flags) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(proxy_flags);
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return 0;);
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_LOCAL void duk__validate_push_heapptr(duk_hthread *thr, void *ptr) {
 	duk_heaphdr *h;
 	duk_heaphdr *curr;
 	duk_bool_t found = 0;
 
@@ -23691,40 +24435,38 @@
 	 * Corner case: we're running in a finalizer for object X, and
 	 * user code calls duk_push_heapptr() for X itself.  In this
 	 * case X will be in finalize_list, and we can detect the case
 	 * by seeing that X's FINALIZED flag is set (which is done before
 	 * the finalizer starts executing).
 	 */
 #if defined(DUK_USE_FINALIZER_SUPPORT)
-	for (curr = thr->heap->finalize_list;
-	     curr != NULL;
-	     curr = DUK_HEAPHDR_GET_NEXT(thr->heap, curr)) {
+	for (curr = thr->heap->finalize_list; curr != NULL; curr = DUK_HEAPHDR_GET_NEXT(thr->heap, curr)) {
 		/* FINALIZABLE is set for all objects on finalize_list
 		 * except for an object being finalized right now.  So
 		 * can't assert here.
 		 */
 #if 0
 		DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZABLE(curr));
 #endif
 
 		if (curr == h) {
 			if (DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) h)) {
 				/* Object is currently being finalized. */
-				DUK_ASSERT(found == 0);  /* Would indicate corrupted lists. */
+				DUK_ASSERT(found == 0); /* Would indicate corrupted lists. */
 				found = 1;
 			} else {
 				/* Not being finalized but on finalize_list,
 				 * allowed since Duktape 2.1.
 				 */
-				DUK_ASSERT(found == 0);  /* Would indicate corrupted lists. */
+				DUK_ASSERT(found == 0); /* Would indicate corrupted lists. */
 				found = 1;
 			}
 		}
 	}
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	/* Because refzero_list is now processed to completion inline with
 	 * no side effects, it's always empty here.
 	 */
 	DUK_ASSERT(thr->heap->refzero_list == NULL);
 #endif
@@ -23742,35 +24484,33 @@
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 			str = DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, heap->strtable16[i]);
 #else
 			str = heap->strtable[i];
 #endif
 			while (str != NULL) {
 				if (str == (duk_hstring *) h) {
-					DUK_ASSERT(found == 0);  /* Would indicate corrupted lists. */
+					DUK_ASSERT(found == 0); /* Would indicate corrupted lists. */
 					found = 1;
 					break;
 				}
 				str = str->hdr.h_next;
 			}
 		}
 		DUK_ASSERT(found != 0);
 	} else {
-		for (curr = thr->heap->heap_allocated;
-		     curr != NULL;
-		     curr = DUK_HEAPHDR_GET_NEXT(thr->heap, curr)) {
+		for (curr = thr->heap->heap_allocated; curr != NULL; curr = DUK_HEAPHDR_GET_NEXT(thr->heap, curr)) {
 			if (curr == h) {
-				DUK_ASSERT(found == 0);  /* Would indicate corrupted lists. */
+				DUK_ASSERT(found == 0); /* Would indicate corrupted lists. */
 				found = 1;
 			}
 		}
 		DUK_ASSERT(found != 0);
 	}
 }
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
 DUK_EXTERNAL duk_idx_t duk_push_heapptr(duk_hthread *thr, void *ptr) {
 	duk_idx_t ret;
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -23828,15 +24568,15 @@
 		 */
 		DUK_HEAPHDR_CLEAR_FINALIZED(curr);
 
 		/* Dequeue object from finalize_list and queue it back to
 		 * heap_allocated.
 		 */
 #if defined(DUK_USE_REFERENCE_COUNTING)
-		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(curr) >= 1);  /* Preincremented on finalize_list insert. */
+		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(curr) >= 1); /* Preincremented on finalize_list insert. */
 		DUK_HEAPHDR_PREDEC_REFCOUNT(curr);
 #endif
 		DUK_HEAP_REMOVE_FROM_FINALIZE_LIST(thr->heap, curr);
 		DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(thr->heap, curr);
 
 		/* Continue with the rest. */
 	}
@@ -23860,18 +24600,17 @@
 }
 
 /* Push object with no prototype, i.e. a "bare" object. */
 DUK_EXTERNAL duk_idx_t duk_push_bare_object(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
-	                              -1);  /* no prototype */
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                              -1); /* no prototype */
 	return duk_get_top_index_unsafe(thr);
 }
 
 DUK_INTERNAL void duk_push_hstring(duk_hthread *thr, duk_hstring *h) {
 	duk_tval tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -23972,20 +24711,20 @@
 }
 
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_INTERNAL void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n(thr, count);
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_INTERNAL void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk__pop_n_unsafe_raw(thr, count);
 }
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 /* Pop N elements without DECREF (in effect "stealing" any actual refcounts). */
 #if defined(DUK_USE_REFERENCE_COUNTING)
 DUK_INTERNAL void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
@@ -24000,20 +24739,20 @@
 		DUK_ASSERT(tv >= thr->valstack_bottom);
 		DUK_TVAL_SET_UNDEFINED(tv);
 	}
 	thr->valstack_top = tv;
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 DUK_INTERNAL void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n_unsafe(thr, count);
 }
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /* Popping one element is called so often that when footprint is not an issue,
  * compile a specialized function for it.
  */
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_EXTERNAL void duk_pop(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
@@ -24023,27 +24762,27 @@
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n_unsafe(thr, 1);
 }
 DUK_INTERNAL void duk_pop_nodecref_unsafe(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n_nodecref_unsafe(thr, 1);
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_LOCAL DUK_ALWAYS_INLINE void duk__pop_unsafe_raw(duk_hthread *thr) {
 	duk_tval *tv;
 
 	DUK_CTX_ASSERT_VALID(thr);
 	DUK_ASSERT(thr->valstack_top != thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT((duk_size_t) (thr->valstack_top - thr->valstack_bottom) >= (duk_size_t) 1);
 
 	tv = --thr->valstack_top;
 	DUK_ASSERT(tv >= thr->valstack_bottom);
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv);  /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv); /* side effects */
 #else
 	DUK_TVAL_SET_UNDEFINED(tv);
 #endif
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
 DUK_EXTERNAL void duk_pop(duk_hthread *thr) {
@@ -24071,34 +24810,34 @@
 
 	tv = --thr->valstack_top;
 	DUK_ASSERT(tv >= thr->valstack_bottom);
 	DUK_TVAL_SET_UNDEFINED(tv);
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_INTERNAL void duk_pop_undefined(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_nodecref_unsafe(thr);
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_INTERNAL void duk_pop_undefined(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(thr->valstack_top != thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT((duk_size_t) (thr->valstack_top - thr->valstack_bottom) >= (duk_size_t) 1);
 
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top - 1));
 	thr->valstack_top--;
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_EXTERNAL void duk_pop_2(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n(thr, 2);
 }
 DUK_INTERNAL void duk_pop_2_unsafe(duk_hthread *thr) {
@@ -24117,22 +24856,22 @@
 	DUK_ASSERT(thr->valstack_top != thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT((duk_size_t) (thr->valstack_top - thr->valstack_bottom) >= (duk_size_t) 2);
 
 	tv = --thr->valstack_top;
 	DUK_ASSERT(tv >= thr->valstack_bottom);
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv);  /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv); /* side effects */
 #else
 	DUK_TVAL_SET_UNDEFINED(tv);
 #endif
 	tv = --thr->valstack_top;
 	DUK_ASSERT(tv >= thr->valstack_bottom);
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv);  /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv); /* side effects */
 #else
 	DUK_TVAL_SET_UNDEFINED(tv);
 #endif
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
 DUK_EXTERNAL void duk_pop_2(duk_hthread *thr) {
@@ -24158,15 +24897,15 @@
 
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top - 1));
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top - 2));
 	thr->valstack_top -= 2;
 
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 }
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 DUK_EXTERNAL void duk_pop_3(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_pop_n(thr, 3);
 }
 
 DUK_INTERNAL void duk_pop_3_unsafe(duk_hthread *thr) {
@@ -24205,31 +24944,31 @@
 	DUK_ASSERT(count >= 0);
 
 	/* Wrapping is controlled by the check above: value stack top can be
 	 * at most DUK_USE_VALSTACK_LIMIT which is low enough so that
 	 * multiplying with sizeof(duk_tval) won't wrap.
 	 */
 	DUK_ASSERT(count >= 0 && count <= (duk_idx_t) DUK_USE_VALSTACK_LIMIT);
-	DUK_ASSERT((duk_size_t) count <= DUK_SIZE_MAX / sizeof(duk_tval));  /* no wrapping */
+	DUK_ASSERT((duk_size_t) count <= DUK_SIZE_MAX / sizeof(duk_tval)); /* no wrapping */
 
-	tv_dst = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count);  /* XXX: uninitialized would be OK */
+	tv_dst = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count); /* XXX: uninitialized would be OK */
 	DUK_ASSERT(count == 0 || tv_dst != NULL);
 	DUK_ASSERT(!duk_is_bare_object(thr, -1));
 
 	/* Copy value stack values directly to the array part without
 	 * any refcount updates: net refcount changes are zero.
 	 */
 	tv_src = thr->valstack_top - count - 1;
 	duk_memcpy_unsafe((void *) tv_dst, (const void *) tv_src, (size_t) count * sizeof(duk_tval));
 
 	/* Overwrite result array to final value stack location and wipe
 	 * the rest; no refcount operations needed.
 	 */
 
-	tv_dst = tv_src;  /* when count == 0, same as tv_src (OK) */
+	tv_dst = tv_src; /* when count == 0, same as tv_src (OK) */
 	tv_src = thr->valstack_top - 1;
 	DUK_TVAL_SET_TVAL(tv_dst, tv_src);
 
 	/* XXX: internal helper to wipe a value stack segment? */
 	tv_curr = tv_dst + 1;
 	tv_limit = thr->valstack_top;
 	while (tv_curr != tv_limit) {
@@ -24251,17 +24990,16 @@
 		duk_uint32_t len;
 		duk_uint32_t i;
 
 		h = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h != NULL);
 		DUK_UNREF(h);
 
-#if defined(DUK_USE_ARRAY_FASTPATH)  /* close enough */
-		if (DUK_LIKELY(DUK_HOBJECT_IS_ARRAY(h) &&
-		               ((duk_harray *) h)->length <= DUK_HOBJECT_GET_ASIZE(h))) {
+#if defined(DUK_USE_ARRAY_FASTPATH) /* close enough */
+		if (DUK_LIKELY(DUK_HOBJECT_IS_ARRAY(h) && ((duk_harray *) h)->length <= DUK_HOBJECT_GET_ASIZE(h))) {
 			duk_harray *h_arr;
 			duk_tval *tv_src;
 			duk_tval *tv_dst;
 
 			h_arr = (duk_harray *) h;
 			len = h_arr->length;
 			if (DUK_UNLIKELY(len >= 0x80000000UL)) {
@@ -24274,16 +25012,15 @@
 			 * e.g. becomes sparse.  So, we need to recheck that the
 			 * array didn't change size and that there's still a
 			 * valid backing array part.
 			 *
 			 * XXX: alternatively, could prevent finalizers for the
 			 * duration.
 			 */
-			if (DUK_UNLIKELY(len != h_arr->length ||
-			                 h_arr->length > DUK_HOBJECT_GET_ASIZE((duk_hobject *) h_arr))) {
+			if (DUK_UNLIKELY(len != h_arr->length || h_arr->length > DUK_HOBJECT_GET_ASIZE((duk_hobject *) h_arr))) {
 				goto skip_fast;
 			}
 
 			/* Main fast path: arguments array is almost always
 			 * an actual array (though it might also be an arguments
 			 * object).
 			 */
@@ -24294,37 +25031,37 @@
 			while (len-- > 0) {
 				DUK_ASSERT(tv_dst < thr->valstack_end);
 				if (DUK_UNLIKELY(DUK_TVAL_IS_UNUSED(tv_src))) {
 					/* Gaps are very unlikely.  Skip over them,
 					 * without an ancestor lookup (technically
 					 * not compliant).
 					 */
-					DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv_dst));  /* valstack policy */
+					DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv_dst)); /* valstack policy */
 				} else {
 					DUK_TVAL_SET_TVAL(tv_dst, tv_src);
 					DUK_TVAL_INCREF(thr, tv_dst);
 				}
 				tv_src++;
 				tv_dst++;
 			}
 			DUK_ASSERT(tv_dst <= thr->valstack_end);
 			thr->valstack_top = tv_dst;
 			return (duk_idx_t) h_arr->length;
 		}
-	 skip_fast:
-#endif  /* DUK_USE_ARRAY_FASTPATH */
+	skip_fast:
+#endif /* DUK_USE_ARRAY_FASTPATH */
 
 		/* Slow path: actual lookups.  The initial 'length' lookup
 		 * decides the output length, regardless of side effects that
 		 * may resize or change the argArray while we read the
 		 * indices.
 		 */
 		idx = duk_normalize_index(thr, idx);
 		duk_get_prop_stridx(thr, idx, DUK_STRIDX_LENGTH);
-		len = duk_to_uint32(thr, -1);  /* ToUint32() coercion required */
+		len = duk_to_uint32(thr, -1); /* ToUint32() coercion required */
 		if (DUK_UNLIKELY(len >= 0x80000000UL)) {
 			goto fail_over_2g;
 		}
 		duk_pop_unsafe(thr);
 		DUK_DDD(DUK_DDDPRINT("slow path for %ld elements", (long) len));
 
 		duk_require_stack(thr, (duk_idx_t) len);
@@ -24335,15 +25072,15 @@
 	} else if (DUK_TVAL_IS_UNDEFINED(tv) || DUK_TVAL_IS_NULL(tv)) {
 		return 0;
 	}
 
 	DUK_ERROR_TYPE_INVALID_ARGS(thr);
 	DUK_WO_NORETURN(return 0;);
 
- fail_over_2g:
+fail_over_2g:
 	DUK_ERROR_RANGE_INVALID_LENGTH(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 /*
  *  Error throwing
  */
@@ -24420,23 +25157,33 @@
 	 */
 	DUK_D(DUK_DPRINT("fatal error handler returned, all bets are off!"));
 	for (;;) {
 		/* loop forever, don't return (function marked noreturn) */
 	}
 }
 
-DUK_EXTERNAL void duk_error_va_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap) {
+DUK_EXTERNAL void duk_error_va_raw(duk_hthread *thr,
+                                   duk_errcode_t err_code,
+                                   const char *filename,
+                                   duk_int_t line,
+                                   const char *fmt,
+                                   va_list ap) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 	(void) duk_throw(thr);
 	DUK_WO_NORETURN(return;);
 }
 
-DUK_EXTERNAL void duk_error_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
+DUK_EXTERNAL void duk_error_raw(duk_hthread *thr,
+                                duk_errcode_t err_code,
+                                const char *filename,
+                                duk_int_t line,
+                                const char *fmt,
+                                ...) {
 	va_list ap;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	va_start(ap, fmt);
 	duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 	va_end(ap);
@@ -24447,15 +25194,16 @@
 #if defined(DUK_USE_GCC_PRAGMAS)
 #pragma GCC diagnostic pop
 #elif defined(DUK_USE_CLANG_PRAGMAS)
 #pragma clang diagnostic pop
 #endif
 
 #if !defined(DUK_USE_VARIADIC_MACROS)
-DUK_NORETURN(DUK_LOCAL_DECL void duk__throw_error_from_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, va_list ap));
+DUK_NORETURN(
+    DUK_LOCAL_DECL void duk__throw_error_from_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, va_list ap));
 
 DUK_LOCAL void duk__throw_error_from_stash(duk_hthread *thr, duk_errcode_t err_code, const char *fmt, va_list ap) {
 	const char *filename;
 	duk_int_t line;
 
 	DUK_CTX_ASSERT_VALID(thr);
 
@@ -24465,15 +25213,16 @@
 	duk_api_global_line = 0;
 
 	duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 	(void) duk_throw(thr);
 	DUK_WO_NORETURN(return;);
 }
 
-#define DUK__ERROR_STASH_SHARED(code) do { \
+#define DUK__ERROR_STASH_SHARED(code) \
+	do { \
 		va_list ap; \
 		va_start(ap, fmt); \
 		duk__throw_error_from_stash(thr, (code), fmt, ap); \
 		va_end(ap); \
 		DUK_WO_NORETURN(return 0;); \
 	} while (0)
 
@@ -24505,15 +25254,15 @@
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__ERROR_STASH_SHARED(DUK_ERR_TYPE_ERROR);
 }
 DUK_EXTERNAL duk_ret_t duk_uri_error_stash(duk_hthread *thr, const char *fmt, ...) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK__ERROR_STASH_SHARED(DUK_ERR_URI_ERROR);
 }
-#endif  /* DUK_USE_VARIADIC_MACROS */
+#endif /* DUK_USE_VARIADIC_MACROS */
 
 /*
  *  Comparison
  */
 
 DUK_EXTERNAL duk_bool_t duk_equals(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 	duk_tval *tv1, *tv2;
@@ -24624,15 +25373,15 @@
 DUK_INTERNAL void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv) {
 	duk_c_function func;
 	duk_small_uint_t lf_flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv));
 
-	DUK_TVAL_GET_LIGHTFUNC(tv, func, lf_flags);  /* read before 'tv' potentially invalidated */
+	DUK_TVAL_GET_LIGHTFUNC(tv, func, lf_flags); /* read before 'tv' potentially invalidated */
 	duk_push_literal(thr, "function ");
 	duk_push_lightfunc_name_raw(thr, func, lf_flags);
 	duk_push_literal(thr, "() { [lightfunc code] }");
 	duk_concat(thr, 3);
 }
 
 /*
@@ -24645,15 +25394,15 @@
 DUK_INTERNAL void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz) {
 	duk_uint8_t buf[32 * 2];
 	duk_uint8_t *p, *q;
 	duk_small_uint_t i;
 	duk_small_uint_t t;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(sz <= 32);  /* sanity limit for function pointer size */
+	DUK_ASSERT(sz <= 32); /* sanity limit for function pointer size */
 
 	p = buf;
 #if defined(DUK_USE_INTEGER_LE)
 	q = ptr + sz;
 #else
 	q = ptr;
 #endif
@@ -24674,27 +25423,26 @@
  *  Push readable string summarizing duk_tval.  The operation is side effect
  *  free and will only throw from internal errors (e.g. out of memory).
  *  This is used by e.g. property access code to summarize a key/base safely,
  *  and is not intended to be fast (but small and safe).
  */
 
 /* String limits for summary strings. */
-#define DUK__READABLE_SUMMARY_MAXCHARS 96  /* maximum supported by helper */
-#define DUK__READABLE_STRING_MAXCHARS  32  /* for strings/symbols */
-#define DUK__READABLE_ERRMSG_MAXCHARS  96  /* for error messages */
+#define DUK__READABLE_SUMMARY_MAXCHARS 96 /* maximum supported by helper */
+#define DUK__READABLE_STRING_MAXCHARS  32 /* for strings/symbols */
+#define DUK__READABLE_ERRMSG_MAXCHARS  96 /* for error messages */
 
 /* String sanitizer which escapes ASCII control characters and a few other
  * ASCII characters, passes Unicode as is, and replaces invalid UTF-8 with
  * question marks.  No errors are thrown for any input string, except in out
  * of memory situations.
  */
 DUK_LOCAL void duk__push_hstring_readable_unicode(duk_hthread *thr, duk_hstring *h_input, duk_small_uint_t maxchars) {
 	const duk_uint8_t *p, *p_start, *p_end;
-	duk_uint8_t buf[DUK_UNICODE_MAX_XUTF8_LENGTH * DUK__READABLE_SUMMARY_MAXCHARS +
-	                2 /*quotes*/ + 3 /*periods*/];
+	duk_uint8_t buf[DUK_UNICODE_MAX_XUTF8_LENGTH * DUK__READABLE_SUMMARY_MAXCHARS + 2 /*quotes*/ + 3 /*periods*/];
 	duk_uint8_t *q;
 	duk_ucodepoint_t cp;
 	duk_small_uint_t nchars;
 
 	DUK_CTX_ASSERT_VALID(thr);
 	DUK_ASSERT(h_input != NULL);
 	DUK_ASSERT(maxchars <= DUK__READABLE_SUMMARY_MAXCHARS);
@@ -24714,25 +25462,25 @@
 			*q++ = (duk_uint8_t) DUK_ASC_PERIOD;
 			*q++ = (duk_uint8_t) DUK_ASC_PERIOD;
 			*q++ = (duk_uint8_t) DUK_ASC_PERIOD;
 			break;
 		}
 		if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp)) {
 			if (cp < 0x20 || cp == 0x7f || cp == DUK_ASC_SINGLEQUOTE || cp == DUK_ASC_BACKSLASH) {
-				DUK_ASSERT(DUK_UNICODE_MAX_XUTF8_LENGTH >= 4);  /* estimate is valid */
+				DUK_ASSERT(DUK_UNICODE_MAX_XUTF8_LENGTH >= 4); /* estimate is valid */
 				DUK_ASSERT((cp >> 4) <= 0x0f);
 				*q++ = (duk_uint8_t) DUK_ASC_BACKSLASH;
 				*q++ = (duk_uint8_t) DUK_ASC_LC_X;
 				*q++ = (duk_uint8_t) duk_lc_digits[cp >> 4];
 				*q++ = (duk_uint8_t) duk_lc_digits[cp & 0x0f];
 			} else {
 				q += duk_unicode_encode_xutf8(cp, q);
 			}
 		} else {
-			p++;  /* advance manually */
+			p++; /* advance manually */
 			*q++ = (duk_uint8_t) DUK_ASC_QUESTION;
 		}
 		nchars++;
 	}
 	*q++ = (duk_uint8_t) DUK_ASC_SINGLEQUOTE;
 
 	duk_push_lstring(thr, (const char *) buf, (duk_size_t) (q - buf));
@@ -24763,30 +25511,34 @@
 			duk__push_hstring_readable_unicode(thr, h, DUK__READABLE_STRING_MAXCHARS);
 			break;
 		}
 		case DUK_TAG_OBJECT: {
 			duk_hobject *h = DUK_TVAL_GET_OBJECT(tv);
 			DUK_ASSERT(h != NULL);
 
-			if (error_aware &&
-			    duk_hobject_prototype_chain_contains(thr, h, thr->builtins[DUK_BIDX_ERROR_PROTOTYPE], 1 /*ignore_loop*/)) {
+			if (error_aware && duk_hobject_prototype_chain_contains(thr,
+			                                                        h,
+			                                                        thr->builtins[DUK_BIDX_ERROR_PROTOTYPE],
+			                                                        1 /*ignore_loop*/)) {
 				/* Get error message in a side effect free way if
 				 * possible; if not, summarize as a generic object.
 				 * Error message currently gets quoted.
 				 */
 				/* XXX: better internal getprop call; get without side effects
 				 * but traverse inheritance chain.
 				 */
 				duk_tval *tv_msg;
 				tv_msg = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, h, DUK_STRIDX_MESSAGE);
 				if (tv_msg != NULL && DUK_TVAL_IS_STRING(tv_msg)) {
 					/* It's critical to avoid recursion so
 					 * only summarize a string .message.
 					 */
-					duk__push_hstring_readable_unicode(thr, DUK_TVAL_GET_STRING(tv_msg), DUK__READABLE_ERRMSG_MAXCHARS);
+					duk__push_hstring_readable_unicode(thr,
+					                                   DUK_TVAL_GET_STRING(tv_msg),
+					                                   DUK__READABLE_ERRMSG_MAXCHARS);
 					break;
 				}
 			}
 			duk_push_class_string_tval(thr, tv, 1 /*avoid_side_effects*/);
 			break;
 		}
 		case DUK_TAG_BUFFER: {
@@ -24861,15 +25613,15 @@
 	duk_concat(thr, 3);
 }
 
 /*
  *  Functions
  */
 
-#if 0  /* not used yet */
+#if 0 /* not used yet */
 DUK_INTERNAL void duk_push_hnatfunc_name(duk_hthread *thr, duk_hnatfunc *h) {
 	duk_c_function func;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(DUK_HOBJECT_IS_NATFUNC((duk_hobject *) h));
 
@@ -24888,15 +25640,15 @@
  */
 
 DUK_INTERNAL void duk_copy_tvals_incref(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_size_t count) {
 	duk_tval *tv;
 
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(thr);
-	DUK_ASSERT(count * sizeof(duk_tval) >= count);  /* no wrap */
+	DUK_ASSERT(count * sizeof(duk_tval) >= count); /* no wrap */
 
 	duk_memcpy_unsafe((void *) tv_dst, (const void *) tv_src, count * sizeof(duk_tval));
 
 	tv = tv_dst;
 	while (count-- > 0) {
 		DUK_TVAL_INCREF(thr, tv);
 		tv++;
@@ -24961,66 +25713,65 @@
 		duk_size_t new_len;
 		h = duk_to_hstring(thr, -((duk_idx_t) i));
 		new_len = len + (duk_size_t) DUK_HSTRING_GET_BYTELEN(h);
 
 		/* Impose a string maximum length, need to handle overflow
 		 * correctly.
 		 */
-		if (new_len < len ||  /* wrapped */
+		if (new_len < len || /* wrapped */
 		    new_len > (duk_size_t) DUK_HSTRING_MAX_BYTELEN) {
 			goto error_overflow;
 		}
 		len = new_len;
 	}
 
-	DUK_DDD(DUK_DDDPRINT("join/concat %lu strings, total length %lu bytes",
-	                     (unsigned long) count, (unsigned long) len));
+	DUK_DDD(DUK_DDDPRINT("join/concat %lu strings, total length %lu bytes", (unsigned long) count, (unsigned long) len));
 
 	/* Use stack allocated buffer to ensure reachability in errors
 	 * (e.g. intern error).
 	 */
 	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 	DUK_ASSERT(buf != NULL);
 
 	/* [ ... (sep) str1 str2 ... strN buf ] */
 
 	idx = 0;
 	for (i = count; i >= 1; i--) {
 		if (is_join && i != count) {
-			h = duk_require_hstring(thr, -((duk_idx_t) count) - 2);  /* extra -1 for buffer */
+			h = duk_require_hstring(thr, -((duk_idx_t) count) - 2); /* extra -1 for buffer */
 			duk_memcpy(buf + idx, DUK_HSTRING_GET_DATA(h), DUK_HSTRING_GET_BYTELEN(h));
 			idx += DUK_HSTRING_GET_BYTELEN(h);
 		}
-		h = duk_require_hstring(thr, -((duk_idx_t) i) - 1);  /* extra -1 for buffer */
+		h = duk_require_hstring(thr, -((duk_idx_t) i) - 1); /* extra -1 for buffer */
 		duk_memcpy(buf + idx, DUK_HSTRING_GET_DATA(h), DUK_HSTRING_GET_BYTELEN(h));
 		idx += DUK_HSTRING_GET_BYTELEN(h);
 	}
 
 	DUK_ASSERT(idx == len);
 
 	/* [ ... (sep) str1 str2 ... strN buf ] */
 
 	/* Get rid of the strings early to minimize memory use before intern. */
 
 	if (is_join) {
-		duk_replace(thr, -((duk_idx_t) count) - 2);  /* overwrite sep */
+		duk_replace(thr, -((duk_idx_t) count) - 2); /* overwrite sep */
 		duk_pop_n(thr, (duk_idx_t) count);
 	} else {
-		duk_replace(thr, -((duk_idx_t) count) - 1);  /* overwrite str1 */
+		duk_replace(thr, -((duk_idx_t) count) - 1); /* overwrite str1 */
 		duk_pop_n(thr, (duk_idx_t) (count - 1));
 	}
 
 	/* [ ... buf ] */
 
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if inputs are safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if inputs are safe. */
 
 	/* [ ... res ] */
 	return;
 
- error_overflow:
+error_overflow:
 	DUK_ERROR_RANGE(thr, DUK_STR_RESULT_TOO_LONG);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_EXTERNAL void duk_concat(duk_hthread *thr, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 
@@ -25028,53 +25779,53 @@
 }
 
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_INTERNAL void duk_concat_2(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	duk_concat(thr, 2);
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_INTERNAL void duk_concat_2(duk_hthread *thr) {
 	duk_hstring *h1;
 	duk_hstring *h2;
 	duk_uint8_t *buf;
 	duk_size_t len1;
 	duk_size_t len2;
 	duk_size_t len;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(duk_get_top(thr) >= 2);  /* Trusted caller. */
+	DUK_ASSERT(duk_get_top(thr) >= 2); /* Trusted caller. */
 
 	h1 = duk_to_hstring(thr, -2);
 	h2 = duk_to_hstring(thr, -1);
 	len1 = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h1);
 	len2 = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h2);
 	len = len1 + len2;
-	if (DUK_UNLIKELY(len < len1 ||  /* wrapped */
+	if (DUK_UNLIKELY(len < len1 || /* wrapped */
 	                 len > (duk_size_t) DUK_HSTRING_MAX_BYTELEN)) {
 		goto error_overflow;
 	}
 	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 	DUK_ASSERT(buf != NULL);
 
 	duk_memcpy((void *) buf, (const void *) DUK_HSTRING_GET_DATA(h1), (size_t) len1);
 	duk_memcpy((void *) (buf + len1), (const void *) DUK_HSTRING_GET_DATA(h2), (size_t) len2);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if inputs are safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if inputs are safe. */
 
 	/* [ ... str1 str2 buf ] */
 
 	duk_replace(thr, -3);
 	duk_pop_unsafe(thr);
 	return;
 
- error_overflow:
+error_overflow:
 	DUK_ERROR_RANGE(thr, DUK_STR_RESULT_TOO_LONG);
 	DUK_WO_NORETURN(return;);
 }
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 DUK_EXTERNAL void duk_join(duk_hthread *thr, duk_idx_t count) {
 	DUK_ASSERT_API_ENTRY(thr);
 
 	duk__concat_and_join_helper(thr, count, 1 /*is_join*/);
 }
 
@@ -25085,15 +25836,15 @@
 DUK_EXTERNAL void duk_decode_string(duk_hthread *thr, duk_idx_t idx, duk_decode_char_function callback, void *udata) {
 	duk_hstring *h_input;
 	const duk_uint8_t *p, *p_start, *p_end;
 	duk_codepoint_t cp;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	h_input = duk_require_hstring(thr, idx);  /* Accept symbols. */
+	h_input = duk_require_hstring(thr, idx); /* Accept symbols. */
 	DUK_ASSERT(h_input != NULL);
 
 	p_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_input);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_input);
 	p = p_start;
 
 	for (;;) {
@@ -25112,19 +25863,19 @@
 	const duk_uint8_t *p, *p_start, *p_end;
 	duk_codepoint_t cp;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	idx = duk_normalize_index(thr, idx);
 
-	h_input = duk_require_hstring(thr, idx);  /* Accept symbols. */
+	h_input = duk_require_hstring(thr, idx); /* Accept symbols. */
 	DUK_ASSERT(h_input != NULL);
 
 	bw = &bw_alloc;
-	DUK_BW_INIT_PUSHBUF(thr, bw, DUK_HSTRING_GET_BYTELEN(h_input));  /* Reasonable output estimate. */
+	DUK_BW_INIT_PUSHBUF(thr, bw, DUK_HSTRING_GET_BYTELEN(h_input)); /* Reasonable output estimate. */
 
 	p_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_input);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_input);
 	p = p_start;
 
 	for (;;) {
 		/* XXX: could write output in chunks with fewer ensure calls,
@@ -25137,28 +25888,28 @@
 		cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
 		cp = callback(udata, cp);
 
 		DUK_BW_WRITE_ENSURE_XUTF8(thr, bw, cp);
 	}
 
 	DUK_BW_COMPACT(thr, bw);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe, extended UTF-8 encoded. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe, extended UTF-8 encoded. */
 	duk_replace(thr, idx);
 }
 
 DUK_EXTERNAL void duk_substring(duk_hthread *thr, duk_idx_t idx, duk_size_t start_offset, duk_size_t end_offset) {
 	duk_hstring *h;
 	duk_hstring *res;
 	duk_size_t start_byte_offset;
 	duk_size_t end_byte_offset;
 	duk_size_t charlen;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	idx = duk_require_normalize_index(thr, idx);  /* Accept symbols. */
+	idx = duk_require_normalize_index(thr, idx); /* Accept symbols. */
 	h = duk_require_hstring(thr, idx);
 	DUK_ASSERT(h != NULL);
 
 	charlen = DUK_HSTRING_GET_CHARLEN(h);
 	if (end_offset >= charlen) {
 		end_offset = charlen;
 	}
@@ -25175,15 +25926,15 @@
 	DUK_ASSERT(start_offset <= DUK_UINT32_MAX);
 	DUK_ASSERT(end_offset <= DUK_UINT32_MAX);
 
 	start_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) start_offset);
 	end_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) end_offset);
 
 	DUK_ASSERT(end_byte_offset >= start_byte_offset);
-	DUK_ASSERT(end_byte_offset - start_byte_offset <= DUK_UINT32_MAX);  /* Guaranteed by string limits. */
+	DUK_ASSERT(end_byte_offset - start_byte_offset <= DUK_UINT32_MAX); /* Guaranteed by string limits. */
 
 	/* No size check is necessary. */
 	res = duk_heap_strtable_intern_checked(thr,
 	                                       DUK_HSTRING_GET_DATA(h) + start_byte_offset,
 	                                       (duk_uint32_t) (end_byte_offset - start_byte_offset));
 
 	duk_push_hstring(thr, res);
@@ -25191,21 +25942,21 @@
 }
 
 /* XXX: this is quite clunky.  Add Unicode helpers to scan backwards and
  * forwards with a callback to process codepoints?
  */
 DUK_EXTERNAL void duk_trim(duk_hthread *thr, duk_idx_t idx) {
 	duk_hstring *h;
-	const duk_uint8_t *p, *p_start, *p_end, *p_tmp1, *p_tmp2;  /* pointers for scanning */
-	const duk_uint8_t *q_start, *q_end;  /* start (incl) and end (excl) of trimmed part */
+	const duk_uint8_t *p, *p_start, *p_end, *p_tmp1, *p_tmp2; /* pointers for scanning */
+	const duk_uint8_t *q_start, *q_end; /* start (incl) and end (excl) of trimmed part */
 	duk_codepoint_t cp;
 
 	DUK_ASSERT_API_ENTRY(thr);
 
-	idx = duk_require_normalize_index(thr, idx);  /* Accept symbols. */
+	idx = duk_require_normalize_index(thr, idx); /* Accept symbols. */
 	h = duk_require_hstring(thr, idx);
 	DUK_ASSERT(h != NULL);
 
 	p_start = DUK_HSTRING_GET_DATA(h);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h);
 
 	p = p_start;
@@ -25239,29 +25990,31 @@
 		if (!(duk_unicode_is_whitespace(cp) || duk_unicode_is_line_terminator(cp))) {
 			p = p_tmp1;
 			break;
 		}
 	}
 	q_end = p;
 
- scan_done:
+scan_done:
 	/* This may happen when forward and backward scanning disagree
 	 * (possible for non-extended-UTF-8 strings).
 	 */
 	if (q_end < q_start) {
 		q_end = q_start;
 	}
 
 	DUK_ASSERT(q_start >= p_start && q_start <= p_end);
 	DUK_ASSERT(q_end >= p_start && q_end <= p_end);
 	DUK_ASSERT(q_end >= q_start);
 
 	DUK_DDD(DUK_DDDPRINT("trim: p_start=%p, p_end=%p, q_start=%p, q_end=%p",
-	                     (const void *) p_start, (const void *) p_end,
-	                     (const void *) q_start, (const void *) q_end));
+	                     (const void *) p_start,
+	                     (const void *) p_end,
+	                     (const void *) q_start,
+	                     (const void *) q_end));
 
 	if (q_start == p_start && q_end == p_end) {
 		DUK_DDD(DUK_DDDPRINT("nothing was trimmed: avoid interning (hashing etc)"));
 		return;
 	}
 
 	duk_push_lstring(thr, (const char *) q_start, (duk_size_t) (q_end - q_start));
@@ -25274,23 +26027,23 @@
 
 	DUK_ASSERT_API_ENTRY(thr);
 
 	/* XXX: Share code with String.prototype.charCodeAt?  Main difference
 	 * is handling of clamped offsets.
 	 */
 
-	h = duk_require_hstring(thr, idx);  /* Accept symbols. */
+	h = duk_require_hstring(thr, idx); /* Accept symbols. */
 	DUK_ASSERT(h != NULL);
 
-	DUK_ASSERT_DISABLE(char_offset >= 0);  /* Always true, arg is unsigned. */
+	DUK_ASSERT_DISABLE(char_offset >= 0); /* Always true, arg is unsigned. */
 	if (char_offset >= DUK_HSTRING_GET_CHARLEN(h)) {
 		return 0;
 	}
 
-	DUK_ASSERT(char_offset <= DUK_UINT_MAX);  /* Guaranteed by string limits. */
+	DUK_ASSERT(char_offset <= DUK_UINT_MAX); /* Guaranteed by string limits. */
 	cp = duk_hstring_char_code_at_raw(thr, h, (duk_uint_t) char_offset, 0 /*surrogate_aware*/);
 	return (duk_codepoint_t) cp;
 }
 #line 1 "duk_api_time.c"
 /*
  *  Date/time.
  */
@@ -25326,30 +26079,30 @@
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(thr);
 
 	/* This API intentionally allows millisecond fractions. */
 	return duk_time_get_ecmascript_time(thr);
 }
 
-#if 0  /* XXX: worth exposing? */
+#if 0 /* XXX: worth exposing? */
 DUK_EXTERNAL duk_double_t duk_get_monotonic_time(duk_hthread *thr) {
 	DUK_ASSERT_API_ENTRY(thr);
 	DUK_UNREF(thr);
 
 	return duk_time_get_monotonic_time(thr);
 }
 #endif
 
 DUK_EXTERNAL void duk_time_to_components(duk_hthread *thr, duk_double_t timeval, duk_time_components *comp) {
 	duk_int_t parts[DUK_DATE_IDX_NUM_PARTS];
 	duk_double_t dparts[DUK_DATE_IDX_NUM_PARTS];
 	duk_uint_t flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(comp != NULL);  /* XXX: or check? */
+	DUK_ASSERT(comp != NULL); /* XXX: or check? */
 	DUK_UNREF(thr);
 
 	/* Convert as one-based, but change month to zero-based to match the
 	 * ECMAScript Date built-in behavior 1:1.
 	 */
 	flags = DUK_DATE_FLAG_ONEBASED | DUK_DATE_FLAG_NAN_TO_ZERO;
 
@@ -25370,15 +26123,15 @@
 
 DUK_EXTERNAL duk_double_t duk_components_to_time(duk_hthread *thr, duk_time_components *comp) {
 	duk_double_t d;
 	duk_double_t dparts[DUK_DATE_IDX_NUM_PARTS];
 	duk_uint_t flags;
 
 	DUK_ASSERT_API_ENTRY(thr);
-	DUK_ASSERT(comp != NULL);  /* XXX: or check? */
+	DUK_ASSERT(comp != NULL); /* XXX: or check? */
 	DUK_UNREF(thr);
 
 	/* Match Date constructor behavior (with UTC time).  Month is given
 	 * as zero-based.  Day-of-month is given as one-based so normalize
 	 * it to zero-based as the internal conversion helpers expects all
 	 * components to be zero-based.
 	 */
@@ -25391,15 +26144,15 @@
 	dparts[DUK_DATE_IDX_YEAR] = comp->year;
 	dparts[DUK_DATE_IDX_MONTH] = comp->month;
 	dparts[DUK_DATE_IDX_DAY] = comp->day - 1.0;
 	dparts[DUK_DATE_IDX_HOUR] = comp->hours;
 	dparts[DUK_DATE_IDX_MINUTE] = comp->minutes;
 	dparts[DUK_DATE_IDX_SECOND] = comp->seconds;
 	dparts[DUK_DATE_IDX_MILLISECOND] = comp->milliseconds;
-	dparts[DUK_DATE_IDX_WEEKDAY] = 0;  /* ignored */
+	dparts[DUK_DATE_IDX_WEEKDAY] = 0; /* ignored */
 
 	d = duk_bi_date_get_timeval_from_dparts(dparts, flags);
 
 	return d;
 }
 #line 1 "duk_bi_array.c"
 /*
@@ -25443,15 +26196,15 @@
  */
 
 /* #include duk_internal.h -> already included */
 
 /* Perform an intermediate join when this many elements have been pushed
  * on the value stack.
  */
-#define  DUK__ARRAY_MID_JOIN_LIMIT  4096
+#define DUK__ARRAY_MID_JOIN_LIMIT 4096
 
 #if defined(DUK_USE_ARRAY_BUILTIN)
 
 /*
  *  Shared helpers.
  */
 
@@ -25494,31 +26247,28 @@
  * pointer when all fast path criteria are met, NULL otherwise.
  */
 DUK_LOCAL duk_harray *duk__arraypart_fastpath_this(duk_hthread *thr) {
 	duk_tval *tv;
 	duk_hobject *h;
 	duk_uint_t flags_mask, flags_bits, flags_value;
 
-	DUK_ASSERT(thr->valstack_bottom > thr->valstack);  /* because call in progress */
+	DUK_ASSERT(thr->valstack_bottom > thr->valstack); /* because call in progress */
 	tv = DUK_GET_THIS_TVAL_PTR(thr);
 
 	/* Fast path requires that 'this' is a duk_harray.  Read only arrays
 	 * (ROM backed) are also rejected for simplicity.
 	 */
 	if (!DUK_TVAL_IS_OBJECT(tv)) {
 		DUK_DD(DUK_DDPRINT("reject array fast path: not an object"));
 		return NULL;
 	}
 	h = DUK_TVAL_GET_OBJECT(tv);
 	DUK_ASSERT(h != NULL);
-	flags_mask = DUK_HOBJECT_FLAG_ARRAY_PART | \
-	             DUK_HOBJECT_FLAG_EXOTIC_ARRAY | \
-	             DUK_HEAPHDR_FLAG_READONLY;
-	flags_bits = DUK_HOBJECT_FLAG_ARRAY_PART | \
-	             DUK_HOBJECT_FLAG_EXOTIC_ARRAY;
+	flags_mask = DUK_HOBJECT_FLAG_ARRAY_PART | DUK_HOBJECT_FLAG_EXOTIC_ARRAY | DUK_HEAPHDR_FLAG_READONLY;
+	flags_bits = DUK_HOBJECT_FLAG_ARRAY_PART | DUK_HOBJECT_FLAG_EXOTIC_ARRAY;
 	flags_value = DUK_HEAPHDR_GET_FLAGS_RAW((duk_heaphdr *) h);
 	if ((flags_value & flags_mask) != flags_bits) {
 		DUK_DD(DUK_DDPRINT("reject array fast path: object flag check failed"));
 		return NULL;
 	}
 
 	/* In some cases a duk_harray's 'length' may be larger than the
@@ -25536,15 +26286,15 @@
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_ASIZE(h) == 0 || DUK_HOBJECT_A_GET_BASE(thr->heap, h) != NULL);
 	DUK_ASSERT(((duk_harray *) h)->length <= DUK_HOBJECT_GET_ASIZE(h));
 
 	DUK_DD(DUK_DDPRINT("array fast path allowed for: %!O", (duk_heaphdr *) h));
 	return (duk_harray *) h;
 }
-#endif  /* DUK_USE_ARRAY_FASTPATH */
+#endif /* DUK_USE_ARRAY_FASTPATH */
 
 /*
  *  Constructor
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_constructor(duk_hthread *thr) {
 	duk_idx_t nargs;
@@ -25606,26 +26356,25 @@
 		 */
 
 		/* XXX: 'this' will be ToObject() coerced twice, which is incorrect
 		 * but should have no visible side effects.
 		 */
 		DUK_DDD(DUK_DDDPRINT("this.join is not callable, fall back to (original) Object.toString"));
 		duk_set_top(thr, 0);
-		return duk_bi_object_prototype_to_string(thr);  /* has access to 'this' binding */
+		return duk_bi_object_prototype_to_string(thr); /* has access to 'this' binding */
 	}
 
 	/* [ ... this func ] */
 
 	duk_insert(thr, -2);
 
 	/* [ ... func this ] */
 
-	DUK_DDD(DUK_DDDPRINT("calling: func=%!iT, this=%!iT",
-	                     (duk_tval *) duk_get_tval(thr, -2),
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(
+	    DUK_DDDPRINT("calling: func=%!iT, this=%!iT", (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
 	duk_call_method(thr, 0);
 
 	return 1;
 }
 
 /*
  *  concat()
@@ -25647,15 +26396,15 @@
 	 * It could also be special cased in the outermost for loop quite easily
 	 * (as the element is dup()'d anyway).
 	 */
 
 	(void) duk_push_this_coercible_to_object(thr);
 	duk_insert(thr, 0);
 	n = duk_get_top(thr);
-	duk_push_array(thr);  /* -> [ ToObject(this) item1 ... itemN arr ] */
+	duk_push_array(thr); /* -> [ ToObject(this) item1 ... itemN arr ] */
 
 	/* NOTE: The Array special behaviors are NOT invoked by duk_xdef_prop_index()
 	 * (which differs from the official algorithm).  If no error is thrown, this
 	 * doesn't matter as the length is updated at the end.  However, if an error
 	 * is thrown, the length will be unset.  That shouldn't matter because the
 	 * caller won't get a reference to the intermediate value.
 	 */
@@ -25698,15 +26447,15 @@
 				 */
 				goto fail_wrap;
 			}
 			continue;
 		}
 
 		DUK_ASSERT(duk_is_object(thr, i));
-		need_has_check = (DUK_HOBJECT_IS_PROXY(h) != 0);  /* Always 0 w/o Proxy support. */
+		need_has_check = (DUK_HOBJECT_IS_PROXY(h) != 0); /* Always 0 w/o Proxy support. */
 
 		/* [ ToObject(this) item1 ... itemN arr ] */
 
 		tmp_len = duk_get_length(thr, i);
 		len = (duk_uint32_t) tmp_len;
 		if (DUK_UNLIKELY(tmp_len != (duk_size_t) len)) {
 			goto fail_wrap;
@@ -25730,30 +26479,30 @@
 				if (duk_get_prop_index(thr, i, j)) {
 					duk_xdef_prop_index_wec(thr, -2, idx);
 				} else {
 					duk_pop_undefined(thr);
 				}
 			}
 			idx++;
-			DUK_ASSERT(idx != 0U);  /* Wrap check above. */
+			DUK_ASSERT(idx != 0U); /* Wrap check above. */
 		}
 	}
 
 	/* ES5.1 has a specification "bug" in that nonexistent trailing
 	 * elements don't affect the result .length.  Test262 and other
 	 * engines disagree, and the specification bug was fixed in ES2015
 	 * (see NOTE 1 in https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat).
 	 */
 	duk_push_uarridx(thr, idx);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_W);
 
 	DUK_ASSERT_TOP(thr, n + 1);
 	return 1;
 
- fail_wrap:
+fail_wrap:
 	DUK_ERROR_RANGE_INVALID_LENGTH(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 /*
  *  join(), toLocaleString()
  *
@@ -25791,34 +26540,32 @@
 
 	DUK_DDD(DUK_DDDPRINT("sep=%!T, this=%!T, len=%lu",
 	                     (duk_tval *) duk_get_tval(thr, 0),
 	                     (duk_tval *) duk_get_tval(thr, 1),
 	                     (unsigned long) len));
 
 	/* The extra (+4) is tight. */
-	valstack_required = (duk_idx_t) ((len >= DUK__ARRAY_MID_JOIN_LIMIT ?
-	                                  DUK__ARRAY_MID_JOIN_LIMIT : len) + 4);
+	valstack_required = (duk_idx_t) ((len >= DUK__ARRAY_MID_JOIN_LIMIT ? DUK__ARRAY_MID_JOIN_LIMIT : len) + 4);
 	duk_require_stack(thr, valstack_required);
 
 	duk_dup_0(thr);
 
 	/* [ sep ToObject(this) len sep ] */
 
 	count = 0;
 	idx = 0;
 	for (;;) {
 		DUK_DDD(DUK_DDDPRINT("join idx=%ld", (long) idx));
-		if (count >= DUK__ARRAY_MID_JOIN_LIMIT ||   /* intermediate join to avoid valstack overflow */
+		if (count >= DUK__ARRAY_MID_JOIN_LIMIT || /* intermediate join to avoid valstack overflow */
 		    idx >= len) { /* end of loop (careful with len==0) */
 			/* [ sep ToObject(this) len sep str0 ... str(count-1) ] */
-			DUK_DDD(DUK_DDDPRINT("mid/final join, count=%ld, idx=%ld, len=%ld",
-			                     (long) count, (long) idx, (long) len));
-			duk_join(thr, (duk_idx_t) count);  /* -> [ sep ToObject(this) len str ] */
-			duk_dup_0(thr);                    /* -> [ sep ToObject(this) len str sep ] */
-			duk_insert(thr, -2);               /* -> [ sep ToObject(this) len sep str ] */
+			DUK_DDD(DUK_DDDPRINT("mid/final join, count=%ld, idx=%ld, len=%ld", (long) count, (long) idx, (long) len));
+			duk_join(thr, (duk_idx_t) count); /* -> [ sep ToObject(this) len str ] */
+			duk_dup_0(thr); /* -> [ sep ToObject(this) len str sep ] */
+			duk_insert(thr, -2); /* -> [ sep ToObject(this) len sep str ] */
 			count = 1;
 		}
 		if (idx >= len) {
 			/* if true, the stack already contains the final result */
 			break;
 		}
 
@@ -25826,15 +26573,15 @@
 		if (duk_is_null_or_undefined(thr, -1)) {
 			duk_pop_nodecref_unsafe(thr);
 			duk_push_hstring_empty(thr);
 		} else {
 			if (to_locale_string) {
 				duk_to_object(thr, -1);
 				duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_TO_LOCALE_STRING);
-				duk_insert(thr, -2);  /* -> [ ... toLocaleString ToObject(val) ] */
+				duk_insert(thr, -2); /* -> [ ... toLocaleString ToObject(val) ] */
 				duk_call_method(thr, 0);
 			}
 			duk_to_string(thr, -1);
 		}
 
 		count++;
 		idx++;
@@ -25884,15 +26631,15 @@
 	}
 	thr->valstack_top++;
 
 	/* XXX: there's no shrink check in the fast path now */
 
 	return 1;
 }
-#endif  /* DUK_USE_ARRAY_FASTPATH */
+#endif /* DUK_USE_ARRAY_FASTPATH */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_prototype_pop(duk_hthread *thr) {
 	duk_uint32_t len;
 	duk_uint32_t idx;
 #if defined(DUK_USE_ARRAY_FASTPATH)
 	duk_harray *h_arr;
 #endif
@@ -25935,15 +26682,15 @@
 	tv_arraypart = DUK_HOBJECT_A_GET_BASE(thr->heap, (duk_hobject *) h_arr);
 
 	n = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 	DUK_ASSERT(n >= 0);
 	DUK_ASSERT((duk_uint32_t) n <= DUK_UINT32_MAX);
 	if (DUK_UNLIKELY(len + (duk_uint32_t) n < len)) {
 		DUK_D(DUK_DPRINT("Array.prototype.push() would go beyond 32-bit length, throw"));
-		DUK_DCERROR_RANGE_INVALID_LENGTH(thr);  /* != 0 return value returned as is by caller */
+		DUK_DCERROR_RANGE_INVALID_LENGTH(thr); /* != 0 return value returned as is by caller */
 	}
 	if (len + (duk_uint32_t) n > DUK_HOBJECT_GET_ASIZE((duk_hobject *) h_arr)) {
 		/* Array part would need to be extended.  Rely on slow path
 		 * for now.
 		 *
 		 * XXX: Rework hobject code a bit and add extend support.
 		 */
@@ -25965,15 +26712,15 @@
 	len += (duk_uint32_t) n;
 	h_arr->length = len;
 
 	DUK_ASSERT((duk_uint_t) len == len);
 	duk_push_uint(thr, (duk_uint_t) len);
 	return 1;
 }
-#endif  /* DUK_USE_ARRAY_FASTPATH */
+#endif /* DUK_USE_ARRAY_FASTPATH */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_prototype_push(duk_hthread *thr) {
 	/* Note: 'this' is not necessarily an Array object.  The push()
 	 * algorithm is supposed to work for other kinds of objects too,
 	 * so the algorithm has e.g. an explicit update for the 'length'
 	 * property which is normally "magical" in arrays.
 	 */
@@ -26040,15 +26787,15 @@
  *  may use a negative offset.
  */
 
 DUK_LOCAL duk_small_int_t duk__array_sort_compare(duk_hthread *thr, duk_int_t idx1, duk_int_t idx2) {
 	duk_bool_t have1, have2;
 	duk_bool_t undef1, undef2;
 	duk_small_int_t ret;
-	duk_idx_t idx_obj = 1;  /* fixed offsets in valstack */
+	duk_idx_t idx_obj = 1; /* fixed offsets in valstack */
 	duk_idx_t idx_fn = 0;
 	duk_hstring *h1, *h2;
 
 	/* Fast exit if indices are identical.  This is valid for a non-existent property,
 	 * for an undefined value, and almost always for ToString() coerced comparison of
 	 * arbitrary values (corner cases where this is not the case include e.g. a an
 	 * object with varying ToString() coercion).
@@ -26061,24 +26808,29 @@
 	 * have an effect on the final result.  The specification does not require any
 	 * specific behavior for inconsistent compare functions, so again, this fast path
 	 * is OK.
 	 */
 
 	if (idx1 == idx2) {
 		DUK_DDD(DUK_DDDPRINT("duk__array_sort_compare: idx1=%ld, idx2=%ld -> indices identical, quick exit",
-		                     (long) idx1, (long) idx2));
+		                     (long) idx1,
+		                     (long) idx2));
 		return 0;
 	}
 
 	have1 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx1);
 	have2 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx2);
 
 	DUK_DDD(DUK_DDDPRINT("duk__array_sort_compare: idx1=%ld, idx2=%ld, have1=%ld, have2=%ld, val1=%!T, val2=%!T",
-	                     (long) idx1, (long) idx2, (long) have1, (long) have2,
-	                     (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
+	                     (long) idx1,
+	                     (long) idx2,
+	                     (long) have1,
+	                     (long) have2,
+	                     (duk_tval *) duk_get_tval(thr, -2),
+	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	if (have1) {
 		if (have2) {
 			;
 		} else {
 			ret = -1;
 			goto pop_ret;
@@ -26112,17 +26864,17 @@
 		}
 	}
 
 	if (!duk_is_undefined(thr, idx_fn)) {
 		duk_double_t d;
 
 		/* No need to check callable; duk_call() will do that. */
-		duk_dup(thr, idx_fn);    /* -> [ ... x y fn ] */
-		duk_insert(thr, -3);     /* -> [ ... fn x y ] */
-		duk_call(thr, 2);        /* -> [ ... res ] */
+		duk_dup(thr, idx_fn); /* -> [ ... x y fn ] */
+		duk_insert(thr, -3); /* -> [ ... fn x y ] */
+		duk_call(thr, 2); /* -> [ ... res ] */
 
 		/* ES5 is a bit vague about what to do if the return value is
 		 * not a number.  ES2015 provides a concrete description:
 		 * http://www.ecma-international.org/ecma-262/6.0/#sec-sortcompare.
 		 */
 
 		d = duk_to_number_m1(thr);
@@ -26146,26 +26898,26 @@
 
 	/* XXX: any special handling for plain array; causes repeated coercion now? */
 	h1 = duk_to_hstring(thr, -2);
 	h2 = duk_to_hstring_m1(thr);
 	DUK_ASSERT(h1 != NULL);
 	DUK_ASSERT(h2 != NULL);
 
-	ret = duk_js_string_compare(h1, h2);  /* retval is directly usable */
+	ret = duk_js_string_compare(h1, h2); /* retval is directly usable */
 	goto pop_ret;
 
- pop_ret:
+pop_ret:
 	duk_pop_2_unsafe(thr);
 	DUK_DDD(DUK_DDDPRINT("-> result %ld", (long) ret));
 	return ret;
 }
 
 DUK_LOCAL void duk__array_sort_swap(duk_hthread *thr, duk_int_t l, duk_int_t r) {
 	duk_bool_t have_l, have_r;
-	duk_idx_t idx_obj = 1;  /* fixed offset in valstack */
+	duk_idx_t idx_obj = 1; /* fixed offset in valstack */
 
 	if (l == r) {
 		return;
 	}
 
 	/* swap elements; deal with non-existent elements correctly */
 	have_l = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) l);
@@ -26210,26 +26962,24 @@
 		} else {
 			*ptr++ = ' ';
 		}
 	}
 	*ptr++ = ']';
 	*ptr++ = '\0';
 
-	DUK_DDD(DUK_DDDPRINT("%s   (lo=%ld, hi=%ld, pivot=%ld)",
-	                     (const char *) buf, (long) lo, (long) hi, (long) pivot));
+	DUK_DDD(DUK_DDDPRINT("%s   (lo=%ld, hi=%ld, pivot=%ld)", (const char *) buf, (long) lo, (long) hi, (long) pivot));
 }
 #endif
 
 DUK_LOCAL void duk__array_qsort(duk_hthread *thr, duk_int_t lo, duk_int_t hi) {
 	duk_int_t p, l, r;
 
 	/* The lo/hi indices may be crossed and hi < 0 is possible at entry. */
 
-	DUK_DDD(DUK_DDDPRINT("duk__array_qsort: lo=%ld, hi=%ld, obj=%!T",
-	                     (long) lo, (long) hi, (duk_tval *) duk_get_tval(thr, 1)));
+	DUK_DDD(DUK_DDDPRINT("duk__array_qsort: lo=%ld, hi=%ld, obj=%!T", (long) lo, (long) hi, (duk_tval *) duk_get_tval(thr, 1)));
 
 	DUK_ASSERT_TOP(thr, 3);
 
 	/* In some cases it may be that lo > hi, or hi < 0; these
 	 * degenerate cases happen e.g. for empty arrays, and in
 	 * recursion leaves.
 	 */
@@ -26239,45 +26989,43 @@
 		DUK_DDD(DUK_DDDPRINT("degenerate case, return immediately"));
 		return;
 	}
 	DUK_ASSERT(hi > lo);
 	DUK_ASSERT(hi - lo + 1 >= 2);
 
 	/* randomized pivot selection */
-	p = lo + (duk_int_t) (DUK_UTIL_GET_RANDOM_DOUBLE(thr) * (duk_double_t) (hi - lo + 1));
+	p = lo + (duk_int_t) (duk_util_get_random_double(thr) * (duk_double_t) (hi - lo + 1));
 	DUK_ASSERT(p >= lo && p <= hi);
 	DUK_DDD(DUK_DDDPRINT("lo=%ld, hi=%ld, chose pivot p=%ld", (long) lo, (long) hi, (long) p));
 
 	/* move pivot out of the way */
 	duk__array_sort_swap(thr, p, lo);
 	p = lo;
 	DUK_DDD(DUK_DDDPRINT("pivot moved out of the way: %!T", (duk_tval *) duk_get_tval(thr, 1)));
 
 	l = lo + 1;
 	r = hi;
 	for (;;) {
 		/* find elements to swap */
 		for (;;) {
-			DUK_DDD(DUK_DDDPRINT("left scan: l=%ld, r=%ld, p=%ld",
-			                     (long) l, (long) r, (long) p));
+			DUK_DDD(DUK_DDDPRINT("left scan: l=%ld, r=%ld, p=%ld", (long) l, (long) r, (long) p));
 			if (l >= hi) {
 				break;
 			}
-			if (duk__array_sort_compare(thr, l, p) >= 0) {  /* !(l < p) */
+			if (duk__array_sort_compare(thr, l, p) >= 0) { /* !(l < p) */
 				break;
 			}
 			l++;
 		}
 		for (;;) {
-			DUK_DDD(DUK_DDDPRINT("right scan: l=%ld, r=%ld, p=%ld",
-			                     (long) l, (long) r, (long) p));
+			DUK_DDD(DUK_DDDPRINT("right scan: l=%ld, r=%ld, p=%ld", (long) l, (long) r, (long) p));
 			if (r <= lo) {
 				break;
 			}
-			if (duk__array_sort_compare(thr, p, r) >= 0) {  /* !(p < r) */
+			if (duk__array_sort_compare(thr, p, r) >= 0) { /* !(p < r) */
 				break;
 			}
 			r--;
 		}
 		if (l >= r) {
 			goto done;
 		}
@@ -26287,15 +27035,15 @@
 
 		duk__array_sort_swap(thr, l, r);
 
 		DUK_DDD(DUK_DDDPRINT("after swap: %!T", (duk_tval *) duk_get_tval(thr, 1)));
 		l++;
 		r--;
 	}
- done:
+done:
 	/* Note that 'l' and 'r' may cross, i.e. r < l */
 	DUK_ASSERT(l >= lo && l <= hi);
 	DUK_ASSERT(r >= lo && r <= hi);
 
 	/* XXX: there's no explicit recursion bound here now.  For the average
 	 * qsort recursion depth O(log n) that's not really necessary: e.g. for
 	 * 2**32 recursion depth would be about 32 which is OK.  However, qsort
@@ -26331,15 +27079,15 @@
 	if (len > 0) {
 		/* avoid degenerate cases, so that (len - 1) won't underflow */
 		duk__array_qsort(thr, (duk_int_t) 0, (duk_int_t) (len - 1));
 	}
 
 	DUK_ASSERT_TOP(thr, 3);
 	duk_pop_nodecref_unsafe(thr);
-	return 1;  /* return ToObject(this) */
+	return 1; /* return ToObject(this) */
 }
 
 /*
  *  splice()
  */
 
 /* XXX: this compiles to over 500 bytes now, even without special handling
@@ -26424,15 +27172,15 @@
 
 	DUK_ASSERT_TOP(thr, nargs + 3);
 
 	/* Step 9: copy elements-to-be-deleted into the result array */
 
 	for (i = 0; i < del_count; i++) {
 		if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (act_start + i))) {
-			duk_xdef_prop_index_wec(thr, -2, (duk_uarridx_t) i);  /* throw flag irrelevant (false in std alg) */
+			duk_xdef_prop_index_wec(thr, -2, (duk_uarridx_t) i); /* throw flag irrelevant (false in std alg) */
 		} else {
 			duk_pop_undefined(thr);
 		}
 	}
 	duk_push_u32(thr, (duk_uint32_t) del_count);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_W);
 
@@ -26494,15 +27242,15 @@
 		 */
 	}
 	DUK_ASSERT_TOP(thr, nargs + 3);
 
 	/* Step 15: insert itemCount elements into the hole made above */
 
 	for (i = 0; i < item_count; i++) {
-		duk_dup(thr, i + 2);  /* args start at index 2 */
+		duk_dup(thr, i + 2); /* args start at index 2 */
 		duk_put_prop_index(thr, -4, (duk_uarridx_t) (act_start + i));
 	}
 
 	/* Step 16: update length; note that the final length may be above 32 bit range
 	 * (but we checked above that this isn't the case here)
 	 */
 
@@ -26557,15 +27305,15 @@
 			duk_pop_undefined(thr);
 		}
 
 		DUK_ASSERT_TOP(thr, 2);
 	}
 
 	DUK_ASSERT_TOP(thr, 2);
-	duk_pop_unsafe(thr);  /* -> [ ToObject(this) ] */
+	duk_pop_unsafe(thr); /* -> [ ToObject(this) ] */
 	return 1;
 }
 
 /*
  *  slice()
  */
 
@@ -26707,47 +27455,53 @@
 		DUK_ASSERT_TOP(thr, nargs + 2);
 		i--;
 		/* k+argCount-1; note that may be above 32-bit range */
 
 		if (duk_get_prop_index(thr, -2, (duk_uarridx_t) i)) {
 			/* fromPresent = true */
 			/* [ ... ToObject(this) ToUint32(length) val ] */
-			duk_put_prop_index(thr, -3, (duk_uarridx_t) (i + (duk_uint32_t) nargs));  /* -> [ ... ToObject(this) ToUint32(length) ] */
+			duk_put_prop_index(
+			    thr,
+			    -3,
+			    (duk_uarridx_t) (i + (duk_uint32_t) nargs)); /* -> [ ... ToObject(this) ToUint32(length) ] */
 		} else {
 			/* fromPresent = false */
 			/* [ ... ToObject(this) ToUint32(length) val ] */
 			duk_pop_undefined(thr);
-			duk_del_prop_index(thr, -2, (duk_uarridx_t) (i + (duk_uint32_t) nargs));  /* -> [ ... ToObject(this) ToUint32(length) ] */
+			duk_del_prop_index(
+			    thr,
+			    -2,
+			    (duk_uarridx_t) (i + (duk_uint32_t) nargs)); /* -> [ ... ToObject(this) ToUint32(length) ] */
 		}
 		DUK_ASSERT_TOP(thr, nargs + 2);
 	}
 
 	for (i = 0; i < (duk_uint32_t) nargs; i++) {
 		DUK_ASSERT_TOP(thr, nargs + 2);
-		duk_dup(thr, (duk_idx_t) i);  /* -> [ ... ToObject(this) ToUint32(length) arg[i] ] */
+		duk_dup(thr, (duk_idx_t) i); /* -> [ ... ToObject(this) ToUint32(length) arg[i] ] */
 		duk_put_prop_index(thr, -3, (duk_uarridx_t) i);
 		DUK_ASSERT_TOP(thr, nargs + 2);
 	}
 
 	DUK_ASSERT_TOP(thr, nargs + 2);
 	duk_push_u32(thr, len + (duk_uint32_t) nargs);
-	duk_dup_top(thr);  /* -> [ ... ToObject(this) ToUint32(length) final_len final_len ] */
+	duk_dup_top(thr); /* -> [ ... ToObject(this) ToUint32(length) final_len final_len ] */
 	duk_put_prop_stridx_short(thr, -4, DUK_STRIDX_LENGTH);
 	return 1;
 }
 
 /*
  *  indexOf(), lastIndexOf()
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_prototype_indexof_shared(duk_hthread *thr) {
 	duk_idx_t nargs;
 	duk_int_t i, len;
 	duk_int_t from_idx;
-	duk_small_int_t idx_step = duk_get_current_magic(thr);  /* idx_step is +1 for indexOf, -1 for lastIndexOf */
+	duk_small_int_t idx_step = duk_get_current_magic(thr); /* idx_step is +1 for indexOf, -1 for lastIndexOf */
 
 	/* lastIndexOf() needs to be a vararg function because we must distinguish
 	 * between an undefined fromIndex and a "not given" fromIndex; indexOf() is
 	 * made vararg for symmetry although it doesn't strictly need to be.
 	 */
 
 	nargs = duk_get_top(thr);
@@ -26777,18 +27531,15 @@
 	if (nargs >= 2) {
 		/* indexOf: clamp fromIndex to [-len, len]
 		 * (if fromIndex == len, for-loop terminates directly)
 		 *
 		 * lastIndexOf: clamp fromIndex to [-len - 1, len - 1]
 		 * (if clamped to -len-1 -> fromIndex becomes -1, terminates for-loop directly)
 		 */
-		from_idx = duk_to_int_clamped(thr,
-		                              1,
-		                              (idx_step > 0 ? -len : -len - 1),
-		                              (idx_step > 0 ? len : len - 1));
+		from_idx = duk_to_int_clamped(thr, 1, (idx_step > 0 ? -len : -len - 1), (idx_step > 0 ? len : len - 1));
 		if (from_idx < 0) {
 			/* for lastIndexOf, result may be -1 (mark immediate termination) */
 			from_idx = len + from_idx;
 		}
 	} else {
 		/* for indexOf, ToInteger(undefined) would be 0, i.e. correct, but
 		 * handle both indexOf and lastIndexOf specially here.
@@ -26816,28 +27567,28 @@
 				return 1;
 			}
 		}
 
 		duk_pop_unsafe(thr);
 	}
 
- not_found:
+not_found:
 	duk_push_int(thr, -1);
 	return 1;
 }
 
 /*
  *  every(), some(), forEach(), map(), filter()
  */
 
-#define DUK__ITER_EVERY    0
-#define DUK__ITER_SOME     1
-#define DUK__ITER_FOREACH  2
-#define DUK__ITER_MAP      3
-#define DUK__ITER_FILTER   4
+#define DUK__ITER_EVERY   0
+#define DUK__ITER_SOME    1
+#define DUK__ITER_FOREACH 2
+#define DUK__ITER_MAP     3
+#define DUK__ITER_FILTER  4
 
 /* XXX: This helper is a bit awkward because the handling for the different iteration
  * callers is quite different.  This now compiles to a bit less than 500 bytes, so with
  * 5 callers the net result is about 100 bytes / caller.
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_prototype_iter_shared(duk_hthread *thr) {
@@ -26864,15 +27615,15 @@
 	/* stack[0] = callback
 	 * stack[1] = thisArg
 	 * stack[2] = object
 	 * stack[3] = ToUint32(length)  (unused, but avoid unnecessary pop)
 	 * stack[4] = result array (or undefined)
 	 */
 
-	k = 0;  /* result index for filter() */
+	k = 0; /* result index for filter() */
 	for (i = 0; i < len; i++) {
 		DUK_ASSERT_TOP(thr, 5);
 
 		if (!duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {
 			/* For 'map' trailing missing elements don't invoke the
 			 * callback but count towards the result length.
 			 */
@@ -26888,15 +27639,15 @@
 		 * effects.
 		 */
 
 		duk_dup_0(thr);
 		duk_dup_1(thr);
 		duk_dup_m3(thr);
 		duk_push_u32(thr, i);
-		duk_dup_2(thr);  /* [ ... val callback thisArg val i obj ] */
+		duk_dup_2(thr); /* [ ... val callback thisArg val i obj ] */
 		duk_call_method(thr, 3); /* -> [ ... val retval ] */
 
 		switch (iter_type) {
 		case DUK__ITER_EVERY:
 			bval = duk_to_boolean(thr, -1);
 			if (!bval) {
 				/* stack top contains 'false' */
@@ -26911,21 +27662,21 @@
 			}
 			break;
 		case DUK__ITER_FOREACH:
 			/* nop */
 			break;
 		case DUK__ITER_MAP:
 			duk_dup_top(thr);
-			duk_xdef_prop_index_wec(thr, 4, (duk_uarridx_t) i);  /* retval to result[i] */
+			duk_xdef_prop_index_wec(thr, 4, (duk_uarridx_t) i); /* retval to result[i] */
 			res_length = i + 1;
 			break;
 		case DUK__ITER_FILTER:
 			bval = duk_to_boolean(thr, -1);
 			if (bval) {
-				duk_dup_m2(thr);  /* orig value */
+				duk_dup_m2(thr); /* orig value */
 				duk_xdef_prop_index_wec(thr, 4, (duk_uarridx_t) k);
 				k++;
 				res_length = k;
 			}
 			break;
 		default:
 			DUK_UNREACHABLE();
@@ -26945,15 +27696,15 @@
 		break;
 	case DUK__ITER_FOREACH:
 		duk_push_undefined(thr);
 		break;
 	case DUK__ITER_MAP:
 	case DUK__ITER_FILTER:
 		DUK_ASSERT_TOP(thr, 5);
-		DUK_ASSERT(duk_is_array(thr, -1));  /* topmost element is the result array already */
+		DUK_ASSERT(duk_is_array(thr, -1)); /* topmost element is the result array already */
 		duk_push_u32(thr, res_length);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_W);
 		break;
 	default:
 		DUK_UNREACHABLE();
 		break;
 	}
@@ -26965,15 +27716,15 @@
  *  reduce(), reduceRight()
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_array_prototype_reduce_shared(duk_hthread *thr) {
 	duk_idx_t nargs;
 	duk_bool_t have_acc;
 	duk_uint32_t i, len;
-	duk_small_int_t idx_step = duk_get_current_magic(thr);  /* idx_step is +1 for reduce, -1 for reduceRight */
+	duk_small_int_t idx_step = duk_get_current_magic(thr); /* idx_step is +1 for reduce, -1 for reduceRight */
 
 	/* We're a varargs function because we need to detect whether
 	 * initialValue was given or not.
 	 */
 	nargs = duk_get_top(thr);
 	DUK_DDD(DUK_DDDPRINT("nargs=%ld", (long) nargs));
 
@@ -26989,33 +27740,32 @@
 	 */
 
 	have_acc = 0;
 	if (nargs >= 2) {
 		duk_dup_1(thr);
 		have_acc = 1;
 	}
-	DUK_DDD(DUK_DDDPRINT("have_acc=%ld, acc=%!T",
-	                     (long) have_acc, (duk_tval *) duk_get_tval(thr, 3)));
+	DUK_DDD(DUK_DDDPRINT("have_acc=%ld, acc=%!T", (long) have_acc, (duk_tval *) duk_get_tval(thr, 3)));
 
 	/* For len == 0, i is initialized to len - 1 which underflows.
 	 * The condition (i < len) will then exit the for-loop on the
 	 * first round which is correct.  Similarly, loop termination
 	 * happens by i underflowing.
 	 */
 
-	for (i = (idx_step >= 0 ? 0 : len - 1);
-	     i < len;  /* i >= 0 would always be true */
+	for (i = (idx_step >= 0 ? 0 : len - 1); i < len; /* i >= 0 would always be true */
 	     i += (duk_uint32_t) idx_step) {
 		DUK_DDD(DUK_DDDPRINT("i=%ld, len=%ld, have_acc=%ld, top=%ld, acc=%!T",
-		                     (long) i, (long) len, (long) have_acc,
+		                     (long) i,
+		                     (long) len,
+		                     (long) have_acc,
 		                     (long) duk_get_top(thr),
 		                     (duk_tval *) duk_get_tval(thr, 4)));
 
-		DUK_ASSERT((have_acc && duk_get_top(thr) == 5) ||
-		           (!have_acc && duk_get_top(thr) == 4));
+		DUK_ASSERT((have_acc && duk_get_top(thr) == 5) || (!have_acc && duk_get_top(thr) == 4));
 
 		if (!duk_has_prop_index(thr, 2, (duk_uarridx_t) i)) {
 			continue;
 		}
 
 		if (!have_acc) {
 			DUK_ASSERT_TOP(thr, 4);
@@ -27026,16 +27776,18 @@
 			DUK_ASSERT_TOP(thr, 5);
 			duk_dup_0(thr);
 			duk_dup(thr, 4);
 			duk_get_prop_index(thr, 2, (duk_uarridx_t) i);
 			duk_push_u32(thr, i);
 			duk_dup_2(thr);
 			DUK_DDD(DUK_DDDPRINT("calling reduce function: func=%!T, prev=%!T, curr=%!T, idx=%!T, obj=%!T",
-			                     (duk_tval *) duk_get_tval(thr, -5), (duk_tval *) duk_get_tval(thr, -4),
-			                     (duk_tval *) duk_get_tval(thr, -3), (duk_tval *) duk_get_tval(thr, -2),
+			                     (duk_tval *) duk_get_tval(thr, -5),
+			                     (duk_tval *) duk_get_tval(thr, -4),
+			                     (duk_tval *) duk_get_tval(thr, -3),
+			                     (duk_tval *) duk_get_tval(thr, -2),
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			duk_call(thr, 4);
 			DUK_DDD(DUK_DDDPRINT("-> result: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 			duk_replace(thr, 4);
 			DUK_ASSERT_TOP(thr, 5);
 		}
 	}
@@ -27044,15 +27796,15 @@
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 
 	DUK_ASSERT_TOP(thr, 5);
 	return 1;
 }
 
-#endif  /* DUK_USE_ARRAY_BUILTIN */
+#endif /* DUK_USE_ARRAY_BUILTIN */
 
 /* automatic undefs */
 #undef DUK__ARRAY_MID_JOIN_LIMIT
 #undef DUK__ITER_EVERY
 #undef DUK__ITER_FILTER
 #undef DUK__ITER_FOREACH
 #undef DUK__ITER_MAP
@@ -27095,15 +27847,15 @@
 			goto type_ok;
 		}
 	}
 
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	/* never here */
 
- type_ok:
+type_ok:
 	if (coerce_tostring) {
 		duk_to_string(thr, -1);
 	}
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_boolean_constructor(duk_hthread *thr) {
@@ -27115,22 +27867,22 @@
 		/* XXX: helper; rely on Boolean.prototype as being non-writable, non-configurable */
 		duk_push_this(thr);
 		h_this = duk_known_hobject(thr, -1);
 		DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h_this) == thr->builtins[DUK_BIDX_BOOLEAN_PROTOTYPE]);
 
 		DUK_HOBJECT_SET_CLASS_NUMBER(h_this, DUK_HOBJECT_CLASS_BOOLEAN);
 
-		duk_dup_0(thr);  /* -> [ val obj val ] */
-		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE);  /* XXX: proper flags? */
-	}  /* unbalanced stack */
+		duk_dup_0(thr); /* -> [ val obj val ] */
+		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE); /* XXX: proper flags? */
+	} /* unbalanced stack */
 
 	return 1;
 }
 
-#endif  /* DUK_USE_BOOLEAN_BUILTIN */
+#endif /* DUK_USE_BOOLEAN_BUILTIN */
 #line 1 "duk_bi_buffer.c"
 /*
  *  ES2015 TypedArray and Node.js Buffer built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -27139,114 +27891,86 @@
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 /* Map class number (minus DUK_HOBJECT_CLASS_BUFOBJ_MIN) to a bidx for the
  * default internal prototype.
  */
 static const duk_uint8_t duk__buffer_proto_from_classnum[] = {
-	DUK_BIDX_ARRAYBUFFER_PROTOTYPE,
-	DUK_BIDX_DATAVIEW_PROTOTYPE,
-	DUK_BIDX_INT8ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT8ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE,
-	DUK_BIDX_INT16ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT16ARRAY_PROTOTYPE,
-	DUK_BIDX_INT32ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT32ARRAY_PROTOTYPE,
-	DUK_BIDX_FLOAT32ARRAY_PROTOTYPE,
-	DUK_BIDX_FLOAT64ARRAY_PROTOTYPE
+	DUK_BIDX_ARRAYBUFFER_PROTOTYPE,  DUK_BIDX_DATAVIEW_PROTOTYPE,          DUK_BIDX_INT8ARRAY_PROTOTYPE,
+	DUK_BIDX_UINT8ARRAY_PROTOTYPE,   DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE, DUK_BIDX_INT16ARRAY_PROTOTYPE,
+	DUK_BIDX_UINT16ARRAY_PROTOTYPE,  DUK_BIDX_INT32ARRAY_PROTOTYPE,        DUK_BIDX_UINT32ARRAY_PROTOTYPE,
+	DUK_BIDX_FLOAT32ARRAY_PROTOTYPE, DUK_BIDX_FLOAT64ARRAY_PROTOTYPE
 };
 
 /* Map DUK_HBUFOBJ_ELEM_xxx to duk_hobject class number.
  * Sync with duk_hbufobj.h and duk_hobject.h.
  */
-static const duk_uint8_t duk__buffer_class_from_elemtype[9] = {
-	DUK_HOBJECT_CLASS_UINT8ARRAY,
-	DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY,
-	DUK_HOBJECT_CLASS_INT8ARRAY,
-	DUK_HOBJECT_CLASS_UINT16ARRAY,
-	DUK_HOBJECT_CLASS_INT16ARRAY,
-	DUK_HOBJECT_CLASS_UINT32ARRAY,
-	DUK_HOBJECT_CLASS_INT32ARRAY,
-	DUK_HOBJECT_CLASS_FLOAT32ARRAY,
-	DUK_HOBJECT_CLASS_FLOAT64ARRAY
-};
+static const duk_uint8_t duk__buffer_class_from_elemtype[9] = { DUK_HOBJECT_CLASS_UINT8ARRAY,  DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY,
+	                                                        DUK_HOBJECT_CLASS_INT8ARRAY,   DUK_HOBJECT_CLASS_UINT16ARRAY,
+	                                                        DUK_HOBJECT_CLASS_INT16ARRAY,  DUK_HOBJECT_CLASS_UINT32ARRAY,
+	                                                        DUK_HOBJECT_CLASS_INT32ARRAY,  DUK_HOBJECT_CLASS_FLOAT32ARRAY,
+	                                                        DUK_HOBJECT_CLASS_FLOAT64ARRAY };
 
 /* Map DUK_HBUFOBJ_ELEM_xxx to prototype object built-in index.
  * Sync with duk_hbufobj.h.
  */
 static const duk_uint8_t duk__buffer_proto_from_elemtype[9] = {
-	DUK_BIDX_UINT8ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE,
-	DUK_BIDX_INT8ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT16ARRAY_PROTOTYPE,
-	DUK_BIDX_INT16ARRAY_PROTOTYPE,
-	DUK_BIDX_UINT32ARRAY_PROTOTYPE,
-	DUK_BIDX_INT32ARRAY_PROTOTYPE,
-	DUK_BIDX_FLOAT32ARRAY_PROTOTYPE,
-	DUK_BIDX_FLOAT64ARRAY_PROTOTYPE
+	DUK_BIDX_UINT8ARRAY_PROTOTYPE,  DUK_BIDX_UINT8CLAMPEDARRAY_PROTOTYPE, DUK_BIDX_INT8ARRAY_PROTOTYPE,
+	DUK_BIDX_UINT16ARRAY_PROTOTYPE, DUK_BIDX_INT16ARRAY_PROTOTYPE,        DUK_BIDX_UINT32ARRAY_PROTOTYPE,
+	DUK_BIDX_INT32ARRAY_PROTOTYPE,  DUK_BIDX_FLOAT32ARRAY_PROTOTYPE,      DUK_BIDX_FLOAT64ARRAY_PROTOTYPE
 };
 
 /* Map DUK__FLD_xxx to byte size. */
 static const duk_uint8_t duk__buffer_nbytes_from_fldtype[6] = {
-	1,  /* DUK__FLD_8BIT */
-	2,  /* DUK__FLD_16BIT */
-	4,  /* DUK__FLD_32BIT */
-	4,  /* DUK__FLD_FLOAT */
-	8,  /* DUK__FLD_DOUBLE */
-	0   /* DUK__FLD_VARINT; not relevant here */
+	1, /* DUK__FLD_8BIT */
+	2, /* DUK__FLD_16BIT */
+	4, /* DUK__FLD_32BIT */
+	4, /* DUK__FLD_FLOAT */
+	8, /* DUK__FLD_DOUBLE */
+	0 /* DUK__FLD_VARINT; not relevant here */
 };
 
 /* Bitfield for each DUK_HBUFOBJ_ELEM_xxx indicating which element types
  * are compatible with a blind byte copy for the TypedArray set() method (also
  * used for TypedArray constructor).  Array index is target buffer elem type,
  * bitfield indicates compatible source types.  The types must have same byte
  * size and they must be coercion compatible.
  */
 #if !defined(DUK_USE_PREFER_SIZE)
 static duk_uint16_t duk__buffer_elemtype_copy_compatible[9] = {
 	/* xxx -> DUK_HBUFOBJ_ELEM_UINT8 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT8) |
-		(1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED) |
-		(1U << DUK_HBUFOBJ_ELEM_INT8),
+	(1U << DUK_HBUFOBJ_ELEM_UINT8) | (1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED) | (1U << DUK_HBUFOBJ_ELEM_INT8),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_UINT8CLAMPED
 	 * Note: INT8 is -not- copy compatible, e.g. -1 would coerce to 0x00.
 	 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT8) |
-		(1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED),
+	(1U << DUK_HBUFOBJ_ELEM_UINT8) | (1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_INT8 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT8) |
-		(1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED) |
-		(1U << DUK_HBUFOBJ_ELEM_INT8),
+	(1U << DUK_HBUFOBJ_ELEM_UINT8) | (1U << DUK_HBUFOBJ_ELEM_UINT8CLAMPED) | (1U << DUK_HBUFOBJ_ELEM_INT8),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_UINT16 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT16) |
-		(1U << DUK_HBUFOBJ_ELEM_INT16),
+	(1U << DUK_HBUFOBJ_ELEM_UINT16) | (1U << DUK_HBUFOBJ_ELEM_INT16),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_INT16 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT16) |
-		(1U << DUK_HBUFOBJ_ELEM_INT16),
+	(1U << DUK_HBUFOBJ_ELEM_UINT16) | (1U << DUK_HBUFOBJ_ELEM_INT16),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_UINT32 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT32) |
-		(1U << DUK_HBUFOBJ_ELEM_INT32),
+	(1U << DUK_HBUFOBJ_ELEM_UINT32) | (1U << DUK_HBUFOBJ_ELEM_INT32),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_INT32 */
-	(1U << DUK_HBUFOBJ_ELEM_UINT32) |
-		(1U << DUK_HBUFOBJ_ELEM_INT32),
+	(1U << DUK_HBUFOBJ_ELEM_UINT32) | (1U << DUK_HBUFOBJ_ELEM_INT32),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_FLOAT32 */
 	(1U << DUK_HBUFOBJ_ELEM_FLOAT32),
 
 	/* xxx -> DUK_HBUFOBJ_ELEM_FLOAT64 */
 	(1U << DUK_HBUFOBJ_ELEM_FLOAT64)
 };
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 DUK_LOCAL duk_hbufobj *duk__hbufobj_promote_this(duk_hthread *thr) {
 	duk_tval *tv_dst;
 	duk_hbufobj *res;
 
 	duk_push_this(thr);
 	DUK_ASSERT(duk_is_buffer(thr, -1));
@@ -27257,16 +27981,16 @@
 	tv_dst = duk_get_borrowed_this_tval(thr);
 	DUK_TVAL_SET_OBJECT_UPDREF(thr, tv_dst, (duk_hobject *) res);
 	duk_pop(thr);
 
 	return res;
 }
 
-#define DUK__BUFOBJ_FLAG_THROW    (1 << 0)
-#define DUK__BUFOBJ_FLAG_PROMOTE  (1 << 1)
+#define DUK__BUFOBJ_FLAG_THROW   (1 << 0)
+#define DUK__BUFOBJ_FLAG_PROMOTE (1 << 1)
 
 /* Shared helper.  When DUK__BUFOBJ_FLAG_PROMOTE is given, the return value is
  * always a duk_hbufobj *.  Without the flag the return value can also be a
  * plain buffer, and the caller must check for it using DUK_HEAPHDR_IS_BUFFER().
  */
 DUK_LOCAL duk_heaphdr *duk__getrequire_bufobj_this(duk_hthread *thr, duk_small_uint_t flags) {
 	duk_tval *tv;
@@ -27349,15 +28073,15 @@
 	DUK_ERROR_TYPE(thr, DUK_STR_NOT_BUFFER);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 DUK_LOCAL void duk__set_bufobj_buffer(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_hbuffer *h_val) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(h_bufobj != NULL);
-	DUK_ASSERT(h_bufobj->buf == NULL);  /* no need to decref */
+	DUK_ASSERT(h_bufobj->buf == NULL); /* no need to decref */
 	DUK_ASSERT(h_val != NULL);
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 	DUK_UNREF(thr);
 
 	h_bufobj->buf = h_val;
 	DUK_HBUFFER_INCREF(thr, h_val);
 	h_bufobj->length = (duk_uint_t) DUK_HBUFFER_GET_SIZE(h_val);
@@ -27385,20 +28109,20 @@
 	if (offset_signed < 0) {
 		goto fail_range;
 	}
 	offset = (duk_uint_t) offset_signed;
 	if (offset > h_bufarg->length) {
 		goto fail_range;
 	}
-	DUK_ASSERT_DISABLE(offset >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(offset >= 0); /* unsigned */
 	DUK_ASSERT(offset <= h_bufarg->length);
 
 	if (duk_is_undefined(thr, idx_length)) {
 		DUK_ASSERT(h_bufarg->length >= offset);
-		length = h_bufarg->length - offset;  /* >= 0 */
+		length = h_bufarg->length - offset; /* >= 0 */
 	} else {
 		length_signed = duk_to_int(thr, idx_length);
 		if (length_signed < 0) {
 			goto fail_range;
 		}
 		length = (duk_uint_t) length_signed;
 		DUK_ASSERT(h_bufarg->length >= offset);
@@ -27409,22 +28133,22 @@
 			if (throw_flag) {
 				goto fail_range;
 			} else {
 				length = h_bufarg->length - offset;
 			}
 		}
 	}
-	DUK_ASSERT_DISABLE(length >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(length >= 0); /* unsigned */
 	DUK_ASSERT(offset + length <= h_bufarg->length);
 
 	*out_offset = offset;
 	*out_length = length;
 	return;
 
- fail_range:
+fail_range:
 	DUK_ERROR_RANGE(thr, DUK_STR_INVALID_ARGS);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Shared lenient buffer length clamping helper.  No negative indices, no
  * element/byte shifting.
  */
@@ -27474,15 +28198,15 @@
                                                   duk_int_t *out_end_offset) {
 	duk_int_t start_offset;
 	duk_int_t end_offset;
 
 	DUK_ASSERT(out_start_offset != NULL);
 	DUK_ASSERT(out_end_offset != NULL);
 
-	buffer_length >>= buffer_shift;  /* as (full) elements */
+	buffer_length >>= buffer_shift; /* as (full) elements */
 
 	/* Resolve start/end offset as element indices first; arguments
 	 * at idx_start/idx_end are element offsets.  Working with element
 	 * indices first also avoids potential for wrapping.
 	 */
 
 	start_offset = duk_to_int(thr, idx_start);
@@ -27566,15 +28290,18 @@
 	DUK_ASSERT(h_arrbuf != NULL);
 	DUK_HBUFOBJ_INCREF(thr, h_arrbuf);
 	duk_pop(thr);
 #endif
 }
 
 /* Indexed read helper for buffer objects, also called from outside this file. */
-DUK_INTERNAL void duk_hbufobj_push_validated_read(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size) {
+DUK_INTERNAL void duk_hbufobj_push_validated_read(duk_hthread *thr,
+                                                  duk_hbufobj *h_bufobj,
+                                                  duk_uint8_t *p,
+                                                  duk_small_uint_t elem_size) {
 	duk_double_union du;
 
 	DUK_ASSERT(elem_size > 0);
 	duk_memcpy((void *) du.uc, (const void *) p, (size_t) elem_size);
 
 	switch (h_bufobj->elem_type) {
 	case DUK_HBUFOBJ_ELEM_UINT8:
@@ -27714,34 +28441,34 @@
 		break;
 	}
 	default:
 		DUK_ERROR_TYPE_INVALID_ARGS(thr);
 		DUK_WO_NORETURN(return NULL;);
 	}
 
- done:
+done:
 	DUK_ASSERT(duk_is_buffer(thr, -1));
 	return duk_known_hbuffer(thr, -1);
 
- slow_copy:
+slow_copy:
 	/* XXX: fast path for typed arrays and other buffer objects? */
 
 	(void) duk_get_prop_stridx_short(thr, 0, DUK_STRIDX_LENGTH);
 	len = duk_to_int_clamped(thr, -1, 0, DUK_INT_MAX);
 	duk_pop(thr);
-	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len);  /* no zeroing, all indices get initialized */
+	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len); /* no zeroing, all indices get initialized */
 	for (i = 0; i < len; i++) {
 		/* XXX: fast path for array or buffer arguments? */
 		duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
 		buf[i] = (duk_uint8_t) (duk_to_uint32(thr, -1) & 0xffU);
 		duk_pop(thr);
 	}
 	goto done;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer constructor
  *
  *  Node.js Buffers are just Uint8Arrays with internal prototype set to
  *  Buffer.prototype so they're handled otherwise the same as Uint8Array.
  *  However, the constructor arguments are very different so a separate
@@ -27750,27 +28477,23 @@
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_constructor(duk_hthread *thr) {
 	duk_hbuffer *h_buf;
 
 	h_buf = duk__hbufobj_fixed_from_argvalue(thr);
 	DUK_ASSERT(h_buf != NULL);
 
-	duk_push_buffer_object(thr,
-	                       -1,
-	                       0,
-	                       DUK_HBUFFER_FIXED_GET_SIZE((duk_hbuffer_fixed *) (void *) h_buf),
-	                       DUK_BUFOBJ_UINT8ARRAY);
+	duk_push_buffer_object(thr, -1, 0, DUK_HBUFFER_FIXED_GET_SIZE((duk_hbuffer_fixed *) (void *) h_buf), DUK_BUFOBJ_UINT8ARRAY);
 	duk_push_hobject_bidx(thr, DUK_BIDX_NODEJS_BUFFER_PROTOTYPE);
 	duk_set_prototype(thr, -2);
 
 	/* XXX: a more direct implementation */
 
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  ArrayBuffer, DataView, and TypedArray constructors
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_arraybuffer_constructor(duk_hthread *thr) {
@@ -27786,30 +28509,28 @@
 	if (len < 0) {
 		goto fail_length;
 	}
 	(void) duk_push_fixed_buffer_zero(thr, (duk_size_t) len);
 	h_val = (duk_hbuffer *) duk_known_hbuffer(thr, -1);
 
 	h_bufobj = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAYBUFFER),
+	                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ |
+	                                   DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAYBUFFER),
 	                               DUK_BIDX_ARRAYBUFFER_PROTOTYPE);
 	DUK_ASSERT(h_bufobj != NULL);
 
 	duk__set_bufobj_buffer(thr, h_bufobj, h_val);
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 
 	return 1;
 
- fail_length:
+fail_length:
 	DUK_DCERROR_RANGE_INVALID_LENGTH(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
-
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* Format of magic, bits:
  *   0...1: elem size shift (0-3)
  *   2...5: elem type (DUK_HBUFOBJ_ELEM_xxx)
  *
  * XXX: add prototype bidx explicitly to magic instead of using a mapping?
  */
@@ -27841,42 +28562,46 @@
 
 	/* We could fit built-in index into magic but that'd make the magic
 	 * number dependent on built-in numbering (genbuiltins.py doesn't
 	 * handle that yet).  So map both class and prototype from the
 	 * element type.
 	 */
 	magic = (duk_small_uint_t) duk_get_current_magic(thr);
-	shift = magic & 0x03U;               /* bits 0...1: shift */
-	elem_type = (magic >> 2) & 0x0fU;    /* bits 2...5: type */
+	shift = magic & 0x03U; /* bits 0...1: shift */
+	elem_type = (magic >> 2) & 0x0fU; /* bits 2...5: type */
 	elem_size = 1U << shift;
 	align_mask = elem_size - 1;
 	DUK_ASSERT(elem_type < sizeof(duk__buffer_proto_from_elemtype) / sizeof(duk_uint8_t));
 	proto_bidx = duk__buffer_proto_from_elemtype[elem_type];
 	DUK_ASSERT(proto_bidx < DUK_NUM_BUILTINS);
 	DUK_ASSERT(elem_type < sizeof(duk__buffer_class_from_elemtype) / sizeof(duk_uint8_t));
 	class_num = duk__buffer_class_from_elemtype[elem_type];
 
 	DUK_DD(DUK_DDPRINT("typedarray constructor, magic=%d, shift=%d, elem_type=%d, "
 	                   "elem_size=%d, proto_bidx=%d, class_num=%d",
-	                   (int) magic, (int) shift, (int) elem_type, (int) elem_size,
-	                   (int) proto_bidx, (int) class_num));
+	                   (int) magic,
+	                   (int) shift,
+	                   (int) elem_type,
+	                   (int) elem_size,
+	                   (int) proto_bidx,
+	                   (int) class_num));
 
 	/* Argument variants.  When the argument is an ArrayBuffer a view to
 	 * the same buffer is created; otherwise a new ArrayBuffer is always
 	 * created.
 	 */
 
 	/* XXX: initial iteration to treat a plain buffer like an ArrayBuffer:
 	 * coerce to an ArrayBuffer object and use that as .buffer.  The underlying
 	 * buffer will be the same but result .buffer !== inputPlainBuffer.
 	 */
 	duk_hbufobj_promote_plain(thr, 0);
 
 	tv = duk_get_tval(thr, 0);
-	DUK_ASSERT(tv != NULL);  /* arg count */
+	DUK_ASSERT(tv != NULL); /* arg count */
 	if (DUK_TVAL_IS_OBJECT(tv)) {
 		h_obj = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h_obj != NULL);
 
 		if (DUK_HOBJECT_GET_CLASS_NUMBER(h_obj) == DUK_HOBJECT_CLASS_ARRAYBUFFER) {
 			/* ArrayBuffer: unlike any other argument variant, create
 			 * a view into the existing buffer.
@@ -27888,16 +28613,15 @@
 			h_bufarg = (duk_hbufobj *) h_obj;
 
 			byte_offset_signed = duk_to_int(thr, 1);
 			if (byte_offset_signed < 0) {
 				goto fail_arguments;
 			}
 			byte_offset = (duk_uint_t) byte_offset_signed;
-			if (byte_offset > h_bufarg->length ||
-			    (byte_offset & align_mask) != 0) {
+			if (byte_offset > h_bufarg->length || (byte_offset & align_mask) != 0) {
 				/* Must be >= 0 and multiple of element size. */
 				goto fail_arguments;
 			}
 			if (duk_is_undefined(thr, 2)) {
 				DUK_ASSERT(h_bufarg->length >= byte_offset);
 				byte_length = h_bufarg->length - byte_offset;
 				if ((byte_length & align_mask) != 0) {
@@ -27929,17 +28653,16 @@
 			DUK_ASSERT_DISABLE(byte_offset >= 0);
 			DUK_ASSERT(byte_offset <= h_bufarg->length);
 			DUK_ASSERT_DISABLE(byte_length >= 0);
 			DUK_ASSERT(byte_offset + byte_length <= h_bufarg->length);
 			DUK_ASSERT((elem_length << shift) == byte_length);
 
 			h_bufobj = duk_push_bufobj_raw(thr,
-			                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-			                               DUK_HOBJECT_FLAG_BUFOBJ |
-			                               DUK_HOBJECT_CLASS_AS_FLAGS(class_num),
+			                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ |
+			                                   DUK_HOBJECT_CLASS_AS_FLAGS(class_num),
 			                               (duk_small_int_t) proto_bidx);
 			h_val = h_bufarg->buf;
 			if (h_val == NULL) {
 				DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 			}
 			h_bufobj->buf = h_val;
 			DUK_HBUFFER_INCREF(thr, h_val);
@@ -27974,35 +28697,37 @@
 			 * buffer.
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("selecting copy mode for bufobj arg, "
 			                     "src byte_length=%ld, src shift=%d, "
 			                     "src/dst elem_length=%ld; "
 			                     "dst shift=%d -> dst byte_length=%ld",
-			                     (long) h_bufarg->length, (int) h_bufarg->shift,
-			                     (long) elem_length_signed, (int) shift,
+			                     (long) h_bufarg->length,
+			                     (int) h_bufarg->shift,
+			                     (long) elem_length_signed,
+			                     (int) shift,
 			                     (long) (elem_length_signed << shift)));
 
-			copy_mode = 2;  /* default is explicit index read/write copy */
+			copy_mode = 2; /* default is explicit index read/write copy */
 #if !defined(DUK_USE_PREFER_SIZE)
 			/* With a size optimized build copy_mode 2 is enough.
 			 * Modes 0 and 1 are faster but conceptually the same.
 			 */
 			DUK_ASSERT(elem_type < sizeof(duk__buffer_elemtype_copy_compatible) / sizeof(duk_uint16_t));
 			if (DUK_HBUFOBJ_VALID_SLICE(h_bufarg)) {
 				if ((duk__buffer_elemtype_copy_compatible[elem_type] & (1 << h_bufarg->elem_type)) != 0) {
 					DUK_DDD(DUK_DDDPRINT("source/target are copy compatible, memcpy"));
-					DUK_ASSERT(shift == h_bufarg->shift);  /* byte sizes will match */
+					DUK_ASSERT(shift == h_bufarg->shift); /* byte sizes will match */
 					copy_mode = 0;
 				} else {
 					DUK_DDD(DUK_DDDPRINT("source/target not copy compatible but valid, fast copy"));
 					copy_mode = 1;
 				}
 			}
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 		} else {
 			/* Array or Array-like */
 			elem_length_signed = (duk_int_t) duk_get_length(thr, 0);
 			copy_mode = 2;
 		}
 	} else {
 		/* Non-object argument is simply int coerced, matches
@@ -28019,35 +28744,33 @@
 	byte_length = (duk_uint_t) (elem_length << shift);
 	if ((byte_length >> shift) != elem_length) {
 		/* Byte length would overflow. */
 		/* XXX: easier check with less code? */
 		goto fail_arguments;
 	}
 
-	DUK_DDD(DUK_DDDPRINT("elem_length=%ld, byte_length=%ld",
-	                     (long) elem_length, (long) byte_length));
+	DUK_DDD(DUK_DDDPRINT("elem_length=%ld, byte_length=%ld", (long) elem_length, (long) byte_length));
 
 	/* ArrayBuffer argument is handled specially above; the rest of the
 	 * argument variants are handled by shared code below.
 	 *
 	 * ArrayBuffer in h_bufobj->buf_prop is intentionally left unset.
 	 * It will be automatically created by the .buffer accessor on
 	 * first access.
 	 */
 
 	/* Push the resulting view object on top of a plain fixed buffer. */
 	(void) duk_push_fixed_buffer(thr, byte_length);
 	h_val = duk_known_hbuffer(thr, -1);
 	DUK_ASSERT(h_val != NULL);
 
-	h_bufobj = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(class_num),
-	                               (duk_small_int_t) proto_bidx);
+	h_bufobj =
+	    duk_push_bufobj_raw(thr,
+	                        DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ | DUK_HOBJECT_CLASS_AS_FLAGS(class_num),
+	                        (duk_small_int_t) proto_bidx);
 
 	h_bufobj->buf = h_val;
 	DUK_HBUFFER_INCREF(thr, h_val);
 	DUK_ASSERT(h_bufobj->offset == 0);
 	h_bufobj->length = byte_length;
 	h_bufobj->shift = (duk_uint8_t) shift;
 	h_bufobj->elem_type = (duk_uint8_t) elem_type;
@@ -28079,15 +28802,17 @@
 		DUK_ASSERT(h_bufarg->buf != NULL);
 		DUK_ASSERT(DUK_HBUFOBJ_VALID_SLICE(h_bufarg));
 
 		p_dst = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufobj);
 		p_src = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufarg);
 
 		DUK_DDD(DUK_DDDPRINT("using memcpy: p_src=%p, p_dst=%p, byte_length=%ld",
-		                     (void *) p_src, (void *) p_dst, (long) byte_length));
+		                     (void *) p_src,
+		                     (void *) p_dst,
+		                     (long) byte_length));
 
 		duk_memcpy_unsafe((void *) p_dst, (const void *) p_src, (size_t) byte_length);
 		break;
 	}
 	case 1: {
 		/* Copy values through direct validated reads and writes. */
 
@@ -28109,33 +28834,38 @@
 
 		p_src = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufarg);
 		p_dst = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufobj);
 		p_src_end = p_src + h_bufarg->length;
 
 		DUK_DDD(DUK_DDDPRINT("using fast copy: p_src=%p, p_src_end=%p, p_dst=%p, "
 		                     "src_elem_size=%d, dst_elem_size=%d",
-		                     (void *) p_src, (void *) p_src_end, (void *) p_dst,
-		                     (int) src_elem_size, (int) dst_elem_size));
+		                     (void *) p_src,
+		                     (void *) p_src_end,
+		                     (void *) p_dst,
+		                     (int) src_elem_size,
+		                     (int) dst_elem_size));
 
 		while (p_src != p_src_end) {
 			DUK_DDD(DUK_DDDPRINT("fast path per element copy loop: "
 			                     "p_src=%p, p_src_end=%p, p_dst=%p",
-			                     (void *) p_src, (void *) p_src_end, (void *) p_dst));
+			                     (void *) p_src,
+			                     (void *) p_src_end,
+			                     (void *) p_dst));
 			/* A validated read() is always a number, so it's write coercion
 			 * is always side effect free an won't invalidate pointers etc.
 			 */
 			duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
 			duk_hbufobj_validated_write(thr, h_bufobj, p_dst, dst_elem_size);
 			duk_pop(thr);
 			p_src += src_elem_size;
 			p_dst += dst_elem_size;
 		}
 		break;
 	}
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 	case 2: {
 		/* Copy values by index reads and writes.  Let virtual
 		 * property handling take care of coercion.
 		 */
 		duk_uint_t i;
 
 		DUK_DDD(DUK_DDDPRINT("using slow copy"));
@@ -28156,18 +28886,18 @@
 		DUK_DDD(DUK_DDDPRINT("using no copy"));
 		break;
 	}
 	}
 
 	return 1;
 
- fail_arguments:
+fail_arguments:
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#else  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#else /* DUK_USE_BUFFEROBJECT_SUPPORT */
 /* When bufferobject support is disabled, new Uint8Array() could still be
  * supported to create a plain fixed buffer.  Disabled for now.
  */
 #if 0
 DUK_INTERNAL duk_ret_t duk_bi_typedarray_constructor(duk_hthread *thr) {
 	duk_int_t elem_length_signed;
 	duk_uint_t byte_length;
@@ -28186,16 +28916,16 @@
 
 	(void) duk_push_fixed_buffer_zero(thr, (duk_size_t) byte_length);
 	return 1;
 
  fail_arguments:
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* 0 */
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* 0 */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_dataview_constructor(duk_hthread *thr) {
 	duk_hbufobj *h_bufarg;
 	duk_hbufobj *h_bufobj;
 	duk_hbuffer *h_val;
 	duk_uint_t offset;
@@ -28210,17 +28940,16 @@
 	}
 
 	duk__resolve_offset_opt_length(thr, h_bufarg, 1, 2, &offset, &length, 1 /*throw_flag*/);
 	DUK_ASSERT(offset <= h_bufarg->length);
 	DUK_ASSERT(offset + length <= h_bufarg->length);
 
 	h_bufobj = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DATAVIEW),
+	                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ |
+	                                   DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DATAVIEW),
 	                               DUK_BIDX_DATAVIEW_PROTOTYPE);
 
 	h_val = h_bufarg->buf;
 	if (h_val == NULL) {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 	h_bufobj->buf = h_val;
@@ -28235,15 +28964,15 @@
 	h_bufobj->buf_prop = (duk_hobject *) h_bufarg;
 	DUK_ASSERT(h_bufarg != NULL);
 	DUK_HBUFOBJ_INCREF(thr, h_bufarg);
 
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  ArrayBuffer.isView()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_arraybuffer_isview(duk_hthread *thr) {
@@ -28261,26 +28990,26 @@
 			ret = ((duk_hbufobj *) h_obj)->is_typedarray ||
 			      (DUK_HOBJECT_GET_CLASS_NUMBER(h_obj) == DUK_HOBJECT_CLASS_DATAVIEW);
 		}
 	}
 	duk_push_boolean(thr, ret);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Uint8Array.allocPlain()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_uint8array_allocplain(duk_hthread *thr) {
 	duk__hbufobj_fixed_from_argvalue(thr);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Uint8Array.plainOf()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_uint8array_plainof(duk_hthread *thr) {
@@ -28301,15 +29030,15 @@
 	if (h_bufobj->buf == NULL) {
 		duk_push_undefined(thr);
 	} else {
 		duk_push_hbuffer(thr, h_bufobj->buf);
 	}
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer: toString([encoding], [start], [end])
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_tostring(duk_hthread *thr) {
@@ -28332,20 +29061,19 @@
 	                                     (duk_int_t) h_this->length,
 	                                     1 /*idx_start*/,
 	                                     2 /*idx_end*/,
 	                                     &start_offset,
 	                                     &end_offset);
 
 	slice_length = (duk_size_t) (end_offset - start_offset);
-	buf_slice = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, slice_length);  /* all bytes initialized below */
+	buf_slice = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, slice_length); /* all bytes initialized below */
 	DUK_ASSERT(buf_slice != NULL);
 
 	/* Neutered or uncovered, TypeError. */
-	if (h_this->buf == NULL ||
-	    !DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_this, (duk_size_t) start_offset + slice_length)) {
+	if (h_this->buf == NULL || !DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_this, (duk_size_t) start_offset + slice_length)) {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 
 	/* XXX: ideally we wouldn't make a copy but a view into the buffer for the
 	 * decoding process.  Or the decoding helper could be changed to accept
 	 * the slice info (a buffer pointer is NOT a good approach because guaranteeing
 	 * its stability is difficult).
@@ -28360,15 +29088,15 @@
 	 * string.  Result will be valid UTF-8; non-CESU-8 inputs are currently
 	 * interpreted loosely.  Value stack convention is a bit odd for now.
 	 */
 	duk_replace(thr, 0);
 	duk_set_top(thr, 1);
 	return duk_textdecoder_decode_utf8_nodejs(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype: toJSON()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_tojson(duk_hthread *thr) {
@@ -28390,27 +29118,27 @@
 
 	duk_push_object(thr);
 	duk_push_hstring_stridx(thr, DUK_STRIDX_UC_BUFFER);
 	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_TYPE);
 
 	/* XXX: uninitialized would be OK */
 	DUK_ASSERT_DISABLE((duk_size_t) h_this->length <= (duk_size_t) DUK_UINT32_MAX);
-	tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) h_this->length);  /* XXX: needs revision with >4G buffers */
+	tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) h_this->length); /* XXX: needs revision with >4G buffers */
 	DUK_ASSERT(!duk_is_bare_object(thr, -1));
 
 	DUK_ASSERT(h_this->buf != NULL);
 	buf = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this);
 	for (i = 0, n = h_this->length; i < n; i++) {
-		DUK_TVAL_SET_U32(tv + i, (duk_uint32_t) buf[i]);  /* no need for decref or incref */
+		DUK_TVAL_SET_U32(tv + i, (duk_uint32_t) buf[i]); /* no need for decref or incref */
 	}
 	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_DATA);
 
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype.equals()
  *  Node.js Buffer.prototype.compare()
  *  Node.js Buffer.compare()
  */
 
@@ -28437,35 +29165,35 @@
 
 	/* We want to compare the slice/view areas of the arguments.
 	 * If either slice/view is invalid (underlying buffer is shorter)
 	 * ensure equals() is false, but otherwise the only thing that
 	 * matters is to be memory safe.
 	 */
 
-	if (DUK_HBUFOBJ_VALID_SLICE(h_bufarg1) &&
-	    DUK_HBUFOBJ_VALID_SLICE(h_bufarg2)) {
-		comp_res = duk_js_data_compare((const duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufarg1->buf) + h_bufarg1->offset,
-		                               (const duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufarg2->buf) + h_bufarg2->offset,
-		                               (duk_size_t) h_bufarg1->length,
-		                               (duk_size_t) h_bufarg2->length);
+	if (DUK_HBUFOBJ_VALID_SLICE(h_bufarg1) && DUK_HBUFOBJ_VALID_SLICE(h_bufarg2)) {
+		comp_res = duk_js_data_compare(
+		    (const duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufarg1->buf) + h_bufarg1->offset,
+		    (const duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufarg2->buf) + h_bufarg2->offset,
+		    (duk_size_t) h_bufarg1->length,
+		    (duk_size_t) h_bufarg2->length);
 	} else {
-		comp_res = -1;  /* either nonzero value is ok */
+		comp_res = -1; /* either nonzero value is ok */
 	}
 
 	if (magic & 0x01U) {
 		/* compare: similar to string comparison but for buffer data. */
 		duk_push_int(thr, comp_res);
 	} else {
 		/* equals */
 		duk_push_boolean(thr, (comp_res == 0));
 	}
 
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype.fill()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_fill(duk_hthread *thr) {
@@ -28502,15 +29230,18 @@
 	                                     (duk_int_t) h_this->length,
 	                                     1 /*idx_start*/,
 	                                     2 /*idx_end*/,
 	                                     &fill_offset,
 	                                     &fill_end);
 
 	DUK_DDD(DUK_DDDPRINT("fill: fill_value=%02x, fill_offset=%ld, fill_end=%ld, view length=%ld",
-	                     (unsigned int) fill_value, (long) fill_offset, (long) fill_end, (long) h_this->length));
+	                     (unsigned int) fill_value,
+	                     (long) fill_offset,
+	                     (long) fill_end,
+	                     (long) h_this->length));
 
 	DUK_ASSERT(fill_end - fill_offset >= 0);
 	DUK_ASSERT(h_this->buf != NULL);
 
 	p = (DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this) + fill_offset);
 	fill_length = (duk_size_t) (fill_end - fill_offset);
 	if (fill_str_len == 1) {
@@ -28531,15 +29262,15 @@
 		DUK_DDD(DUK_DDDPRINT("zero size fill pattern, ignore silently"));
 	}
 
 	/* Return the Buffer to allow chaining: b.fill(0x11).fill(0x22, 3, 5).toString() */
 	duk_push_this(thr);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype.write(string, [offset], [length], [encoding])
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_write(duk_hthread *thr) {
@@ -28574,15 +29305,15 @@
 	} else {
 		DUK_DDD(DUK_DDDPRINT("write() target buffer is not covered, silent ignore"));
 	}
 
 	duk_push_uint(thr, length);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype.copy()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_copy(duk_hthread *thr) {
@@ -28609,29 +29340,32 @@
 		source_end = source_length;
 	} else {
 		source_end = duk_to_int(thr, 3);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("checking copy args: target_start=%ld, target_length=%ld, "
 	                     "source_start=%ld, source_end=%ld, source_length=%ld",
-	                     (long) target_start, (long) h_bufarg->length,
-	                     (long) source_start, (long) source_end, (long) source_length));
+	                     (long) target_start,
+	                     (long) h_bufarg->length,
+	                     (long) source_start,
+	                     (long) source_end,
+	                     (long) source_length));
 
 	/* This behavior mostly mimics Node.js now. */
 
 	if (source_start < 0 || source_end < 0 || target_start < 0) {
 		/* Negative offsets cause a RangeError. */
 		goto fail_bounds;
 	}
 	source_ustart = (duk_uint_t) source_start;
 	source_uend = (duk_uint_t) source_end;
 	target_ustart = (duk_uint_t) target_start;
-	if (source_ustart >= source_uend ||  /* crossed offsets or zero size */
-	    source_ustart >= (duk_uint_t) source_length ||  /* source out-of-bounds (but positive) */
-	    target_ustart >= (duk_uint_t) target_length) {  /* target out-of-bounds (but positive) */
+	if (source_ustart >= source_uend || /* crossed offsets or zero size */
+	    source_ustart >= (duk_uint_t) source_length || /* source out-of-bounds (but positive) */
+	    target_ustart >= (duk_uint_t) target_length) { /* target out-of-bounds (but positive) */
 		goto silent_ignore;
 	}
 	if (source_uend >= (duk_uint_t) source_length) {
 		/* Source end clamped silently to available length. */
 		source_uend = (duk_uint_t) source_length;
 	}
 	copy_size = source_uend - source_ustart;
@@ -28639,56 +29373,57 @@
 		/* Clamp to target's end if too long.
 		 *
 		 * NOTE: there's no overflow possibility in the comparison;
 		 * both target_ustart and copy_size are >= 0 and based on
 		 * values in duk_int_t range.  Adding them as duk_uint_t
 		 * values is then guaranteed not to overflow.
 		 */
-		DUK_ASSERT(target_ustart + copy_size >= target_ustart);  /* no overflow */
-		DUK_ASSERT(target_ustart + copy_size >= copy_size);  /* no overflow */
+		DUK_ASSERT(target_ustart + copy_size >= target_ustart); /* no overflow */
+		DUK_ASSERT(target_ustart + copy_size >= copy_size); /* no overflow */
 		copy_size = (duk_uint_t) target_length - target_ustart;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("making copy: target_ustart=%lu source_ustart=%lu copy_size=%lu",
-	                     (unsigned long) target_ustart, (unsigned long) source_ustart,
+	                     (unsigned long) target_ustart,
+	                     (unsigned long) source_ustart,
 	                     (unsigned long) copy_size));
 
 	DUK_ASSERT(copy_size >= 1);
 	DUK_ASSERT(source_ustart <= (duk_uint_t) source_length);
 	DUK_ASSERT(source_ustart + copy_size <= (duk_uint_t) source_length);
 	DUK_ASSERT(target_ustart <= (duk_uint_t) target_length);
 	DUK_ASSERT(target_ustart + copy_size <= (duk_uint_t) target_length);
 
 	/* Ensure copy is covered by underlying buffers. */
-	DUK_ASSERT(h_bufarg->buf != NULL);  /* length check */
-	DUK_ASSERT(h_this->buf != NULL);    /* length check */
+	DUK_ASSERT(h_bufarg->buf != NULL); /* length check */
+	DUK_ASSERT(h_this->buf != NULL); /* length check */
 	if (DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufarg, target_ustart + copy_size) &&
 	    DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_this, source_ustart + copy_size)) {
 		/* Must use memmove() because copy area may overlap (source and target
 		 * buffer may be the same, or from different slices.
 		 */
 		duk_memmove_unsafe((void *) (DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufarg) + target_ustart),
 		                   (const void *) (DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this) + source_ustart),
 		                   (size_t) copy_size);
 	} else {
 		DUK_DDD(DUK_DDDPRINT("buffer copy not covered by underlying buffer(s), ignoring"));
 	}
 
- silent_ignore:
+silent_ignore:
 	/* Return value is like write(), number of bytes written.
 	 * The return value matters because of code like:
 	 * "off += buf.copy(...)".
-         */
+	 */
 	duk_push_uint(thr, copy_size);
 	return 1;
 
- fail_bounds:
+fail_bounds:
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  TypedArray.prototype.set()
  *
  *  TypedArray set() is pretty interesting to implement because:
  *
  *    - The source argument may be a plain array or a typedarray.  If the
@@ -28792,24 +29527,23 @@
 
 		if (h_bufarg->buf == NULL) {
 			DUK_DDD(DUK_DDDPRINT("target neutered, skip copy"));
 			return 0;
 		}
 
 		/* Nominal size check. */
-		src_length = h_bufarg->length;  /* bytes in source */
-		dst_length_elems = (src_length >> h_bufarg->shift);  /* elems in source and dest */
-		dst_length = dst_length_elems << h_this->shift;  /* bytes in dest */
+		src_length = h_bufarg->length; /* bytes in source */
+		dst_length_elems = (src_length >> h_bufarg->shift); /* elems in source and dest */
+		dst_length = dst_length_elems << h_this->shift; /* bytes in dest */
 		if ((dst_length >> h_this->shift) != dst_length_elems) {
 			/* Byte length would overflow. */
 			/* XXX: easier check with less code? */
 			goto fail_args;
 		}
-		DUK_DDD(DUK_DDDPRINT("nominal size check: src_length=%ld, dst_length=%ld",
-		                     (long) src_length, (long) dst_length));
+		DUK_DDD(DUK_DDDPRINT("nominal size check: src_length=%ld, dst_length=%ld", (long) src_length, (long) dst_length));
 		DUK_ASSERT(offset_bytes <= h_this->length);
 		if (dst_length > h_this->length - offset_bytes) {
 			/* Overflow not an issue because subtraction is used on the right
 			 * side and guaranteed to be >= 0.
 			 */
 			DUK_DDD(DUK_DDDPRINT("copy exceeds target buffer nominal length"));
 			goto fail_args;
@@ -28822,16 +29556,15 @@
 		p_src_base = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufarg);
 		p_dst_base = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this) + offset_bytes;
 
 		/* Check actual underlying buffers for validity and that they
 		 * cover the copy.  No side effects are allowed after the check
 		 * so that the validity status doesn't change.
 		 */
-		if (!DUK_HBUFOBJ_VALID_SLICE(h_this) ||
-		    !DUK_HBUFOBJ_VALID_SLICE(h_bufarg)) {
+		if (!DUK_HBUFOBJ_VALID_SLICE(h_this) || !DUK_HBUFOBJ_VALID_SLICE(h_bufarg)) {
 			/* The condition could be more narrow and check for the
 			 * copy area only, but there's no need for fine grained
 			 * behavior when the underlying buffer is misconfigured.
 			 */
 			DUK_DDD(DUK_DDDPRINT("source and/or target not covered by underlying buffer, skip copy"));
 			return 0;
 		}
@@ -28854,15 +29587,15 @@
 			DUK_ASSERT(src_length == dst_length);
 
 			DUK_DDD(DUK_DDDPRINT("fast path: able to use memmove() because views are compatible"));
 			duk_memmove_unsafe((void *) p_dst_base, (const void *) p_src_base, (size_t) dst_length);
 			return 0;
 		}
 		DUK_DDD(DUK_DDDPRINT("fast path: views are not compatible with a byte copy, copy by item"));
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 
 		/* We want to avoid making a copy to process set() but that's
 		 * not always possible: the source and the target may overlap
 		 * and because element sizes are different, the overlap cannot
 		 * always be handled with a memmove() or choosing the copy
 		 * direction in a certain way.  For example, if source type is
 		 * uint8 and target type is uint32, the target area may exceed
@@ -28874,19 +29607,21 @@
 		 *
 		 * NOTE: careful with side effects: any side effect may cause
 		 * a buffer resize (or external buffer pointer/length update)!
 		 */
 
 		DUK_DDD(DUK_DDDPRINT("overlap check: p_src_base=%p, src_length=%ld, "
 		                     "p_dst_base=%p, dst_length=%ld",
-		                     (void *) p_src_base, (long) src_length,
-		                     (void *) p_dst_base, (long) dst_length));
+		                     (void *) p_src_base,
+		                     (long) src_length,
+		                     (void *) p_dst_base,
+		                     (long) dst_length));
 
-		if (p_src_base >= p_dst_base + dst_length ||  /* source starts after dest ends */
-		    p_src_base + src_length <= p_dst_base) {   /* source ends before dest starts */
+		if (p_src_base >= p_dst_base + dst_length || /* source starts after dest ends */
+		    p_src_base + src_length <= p_dst_base) { /* source ends before dest starts */
 			no_overlap = 1;
 		}
 
 		if (!no_overlap) {
 			/* There's overlap: the desired end result is that
 			 * conceptually a copy is made to avoid "trampling"
 			 * of source data by destination writes.  We make
@@ -28895,22 +29630,24 @@
 			duk_uint8_t *p_src_copy;
 
 			DUK_DDD(DUK_DDDPRINT("there is overlap, make a copy of the source"));
 			p_src_copy = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_length);
 			DUK_ASSERT(p_src_copy != NULL);
 			duk_memcpy_unsafe((void *) p_src_copy, (const void *) p_src_base, (size_t) src_length);
 
-			p_src_base = p_src_copy;  /* use p_src_base from now on */
+			p_src_base = p_src_copy; /* use p_src_base from now on */
 		}
 		/* Value stack intentionally mixed size here. */
 
 		DUK_DDD(DUK_DDDPRINT("after overlap check: p_src_base=%p, src_length=%ld, "
 		                     "p_dst_base=%p, dst_length=%ld, valstack top=%ld",
-		                     (void *) p_src_base, (long) src_length,
-		                     (void *) p_dst_base, (long) dst_length,
+		                     (void *) p_src_base,
+		                     (long) src_length,
+		                     (void *) p_dst_base,
+		                     (long) dst_length,
 		                     (long) duk_get_top(thr)));
 
 		/* Ready to make the copy.  We must proceed element by element
 		 * and must avoid any side effects that might cause the buffer
 		 * validity check above to become invalid.
 		 *
 		 * Although we work through the value stack here, only plain
@@ -28922,15 +29659,17 @@
 		p_src = p_src_base;
 		p_dst = p_dst_base;
 		p_src_end = p_src_base + src_length;
 
 		while (p_src != p_src_end) {
 			DUK_DDD(DUK_DDDPRINT("fast path per element copy loop: "
 			                     "p_src=%p, p_src_end=%p, p_dst=%p",
-			                     (void *) p_src, (void *) p_src_end, (void *) p_dst));
+			                     (void *) p_src,
+			                     (void *) p_src_end,
+			                     (void *) p_dst));
 			/* A validated read() is always a number, so it's write coercion
 			 * is always side effect free an won't invalidate pointers etc.
 			 */
 			duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
 			duk_hbufobj_validated_write(thr, h_this, p_dst, dst_elem_size);
 			duk_pop(thr);
 			p_src += src_elem_size;
@@ -28972,18 +29711,18 @@
 			duk_get_prop_index(thr, 0, i);
 			duk_put_prop_index(thr, 2, offset_elems + i);
 		}
 	}
 
 	return 0;
 
- fail_args:
+fail_args:
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.prototype.slice([start], [end])
  *  ArrayBuffer.prototype.slice(begin, [end])
  *  TypedArray.prototype.subarray(begin, [end])
  *
  *  The API calls are almost identical; negative indices are counted from end
@@ -29070,15 +29809,15 @@
 			 * buffer (handled automatically by duk__require_bufobj_this()).
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("slice() doesn't handle view into plain buffer, coerce 'this' to ArrayBuffer object"));
 			/* fall through */
 		}
 	}
-	tv = NULL;  /* No longer valid nor needed. */
+	tv = NULL; /* No longer valid nor needed. */
 
 	h_this = duk__require_bufobj_this(thr);
 
 	/* Slice offsets are element (not byte) offsets, which only matters
 	 * for TypedArray views, Node.js Buffer and ArrayBuffer have shift
 	 * zero so byte and element offsets are the same.  Negative indices
 	 * are counted from end of slice, crossed indices are allowed (and
@@ -29108,44 +29847,45 @@
 	 * did that).
 	 *
 	 * Node.js Buffers have special handling: they're Uint8Arrays as far
 	 * as the internal class is concerned, so the new Buffer should also
 	 * be an Uint8Array but inherit from Buffer.prototype.
 	 */
 	res_class_num = DUK_HOBJECT_GET_CLASS_NUMBER((duk_hobject *) h_this);
-	DUK_ASSERT(res_class_num >= DUK_HOBJECT_CLASS_BUFOBJ_MIN);  /* type check guarantees */
+	DUK_ASSERT(res_class_num >= DUK_HOBJECT_CLASS_BUFOBJ_MIN); /* type check guarantees */
 	DUK_ASSERT(res_class_num <= DUK_HOBJECT_CLASS_BUFOBJ_MAX);
 	res_proto_bidx = duk__buffer_proto_from_classnum[res_class_num - DUK_HOBJECT_CLASS_BUFOBJ_MIN];
 	if (magic & 0x04) {
 		res_proto_bidx = DUK_BIDX_NODEJS_BUFFER_PROTOTYPE;
 	}
-	h_bufobj = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(res_class_num),
-	                               res_proto_bidx);
+	h_bufobj =
+	    duk_push_bufobj_raw(thr,
+	                        DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ | DUK_HOBJECT_CLASS_AS_FLAGS(res_class_num),
+	                        res_proto_bidx);
 	DUK_ASSERT(h_bufobj != NULL);
 
 	DUK_ASSERT(h_bufobj->length == 0);
-	h_bufobj->shift = h_this->shift;  /* inherit */
-	h_bufobj->elem_type = h_this->elem_type;  /* inherit */
+	h_bufobj->shift = h_this->shift; /* inherit */
+	h_bufobj->elem_type = h_this->elem_type; /* inherit */
 	h_bufobj->is_typedarray = magic & 0x01;
 	DUK_ASSERT(h_bufobj->is_typedarray == 0 || h_bufobj->is_typedarray == 1);
 
 	h_val = h_this->buf;
 	if (h_val == NULL) {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 
 	if (magic & 0x02) {
 		/* non-zero: make copy */
 		duk_uint8_t *p_copy;
 		duk_size_t copy_length;
 
-		p_copy = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr, (duk_size_t) slice_length);  /* must be zeroed, not all bytes always copied */
+		p_copy = (duk_uint8_t *) duk_push_fixed_buffer_zero(
+		    thr,
+		    (duk_size_t) slice_length); /* must be zeroed, not all bytes always copied */
 		DUK_ASSERT(p_copy != NULL);
 
 		/* Copy slice, respecting underlying buffer limits; remainder
 		 * is left as zero.
 		 */
 		copy_length = DUK_HBUFOBJ_CLAMP_BYTELENGTH(h_this, slice_length);
 		duk_memcpy_unsafe((void *) p_copy,
@@ -29155,80 +29895,80 @@
 		h_val = duk_known_hbuffer(thr, -1);
 
 		h_bufobj->buf = h_val;
 		DUK_HBUFFER_INCREF(thr, h_val);
 		h_bufobj->length = slice_length;
 		DUK_ASSERT(h_bufobj->offset == 0);
 
-		duk_pop(thr);  /* reachable so pop OK */
+		duk_pop(thr); /* reachable so pop OK */
 	} else {
 		h_bufobj->buf = h_val;
 		DUK_HBUFFER_INCREF(thr, h_val);
 		h_bufobj->length = slice_length;
 		h_bufobj->offset = h_this->offset + (duk_uint_t) start_offset;
 
 		/* Copy the .buffer property, needed for TypedArray.prototype.subarray().
 		 *
 		 * XXX: limit copy only for TypedArray classes specifically?
 		 */
 
 		DUK_ASSERT(h_bufobj->buf_prop == NULL);
-		h_bufobj->buf_prop = h_this->buf_prop;  /* may be NULL */
+		h_bufobj->buf_prop = h_this->buf_prop; /* may be NULL */
 		DUK_HOBJECT_INCREF_ALLOWNULL(thr, (duk_hobject *) h_bufobj->buf_prop);
 	}
 	/* unbalanced stack on purpose */
 
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.isEncoding()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_is_encoding(duk_hthread *thr) {
 	const char *encoding;
 
 	/* only accept lowercase 'utf8' now. */
 
 	encoding = duk_to_string(thr, 0);
-	DUK_ASSERT(duk_is_string(thr, 0));  /* guaranteed by duk_to_string() */
+	DUK_ASSERT(duk_is_string(thr, 0)); /* guaranteed by duk_to_string() */
 	duk_push_boolean(thr, DUK_STRCMP(encoding, "utf8") == 0);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.isBuffer()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_is_buffer(duk_hthread *thr) {
 	duk_hobject *h;
 	duk_hobject *h_proto;
 	duk_bool_t ret = 0;
 
-	DUK_ASSERT(duk_get_top(thr) >= 1);  /* nargs */
+	DUK_ASSERT(duk_get_top(thr) >= 1); /* nargs */
 	h = duk_get_hobject(thr, 0);
 	if (h != NULL) {
 		h_proto = thr->builtins[DUK_BIDX_NODEJS_BUFFER_PROTOTYPE];
 		DUK_ASSERT(h_proto != NULL);
 
 		h = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h);
 		if (h != NULL) {
 			ret = duk_hobject_prototype_chain_contains(thr, h, h_proto, 0 /*ignore_loop*/);
 		}
 	}
 
 	duk_push_boolean(thr, ret);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.byteLength()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_byte_length(duk_hthread *thr) {
@@ -29251,15 +29991,15 @@
 	 */
 
 	str = duk_to_lstring(thr, 0, &len);
 	DUK_UNREF(str);
 	duk_push_size_t(thr, len);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Node.js Buffer.concat()
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_nodejs_buffer_concat(duk_hthread *thr) {
@@ -29282,21 +30022,21 @@
 	/* Compute result length and validate argument buffers. */
 	n = (duk_uint_t) duk_get_length(thr, 0);
 	total_length = 0;
 	for (i = 0; i < n; i++) {
 		/* Neutered checks not necessary here: neutered buffers have
 		 * zero 'length' so we'll effectively skip them.
 		 */
-		DUK_ASSERT_TOP(thr, 2);  /* [ array totalLength ] */
-		duk_get_prop_index(thr, 0, (duk_uarridx_t) i);  /* -> [ array totalLength buf ] */
+		DUK_ASSERT_TOP(thr, 2); /* [ array totalLength ] */
+		duk_get_prop_index(thr, 0, (duk_uarridx_t) i); /* -> [ array totalLength buf ] */
 		h_bufobj = duk__require_bufobj_value(thr, 2);
 		DUK_ASSERT(h_bufobj != NULL);
 		total_length += h_bufobj->length;
 		if (DUK_UNLIKELY(total_length < h_bufobj->length)) {
-			DUK_DCERROR_RANGE_INVALID_ARGS(thr);  /* Wrapped. */
+			DUK_DCERROR_RANGE_INVALID_ARGS(thr); /* Wrapped. */
 		}
 		duk_pop(thr);
 	}
 	/* In Node.js v0.12.1 a 1-element array is special and won't create a
 	 * copy, this was fixed later so an explicit check no longer needed.
 	 */
 
@@ -29314,41 +30054,38 @@
 		if (total_length_signed < 0) {
 			DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 		}
 		total_length = (duk_uint_t) total_length_signed;
 	}
 
 	h_bufres = duk_push_bufobj_raw(thr,
-	                               DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                               DUK_HOBJECT_FLAG_BUFOBJ |
-	                               DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_UINT8ARRAY),
+	                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ |
+	                                   DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_UINT8ARRAY),
 	                               DUK_BIDX_NODEJS_BUFFER_PROTOTYPE);
 	DUK_ASSERT(h_bufres != NULL);
 
-	p = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr, total_length);  /* must be zeroed, all bytes not necessarily written over */
+	p = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr,
+	                                               total_length); /* must be zeroed, all bytes not necessarily written over */
 	DUK_ASSERT(p != NULL);
 	space_left = (duk_size_t) total_length;
 
 	for (i = 0; i < n; i++) {
-		DUK_ASSERT_TOP(thr, 4);  /* [ array totalLength bufres buf ] */
+		DUK_ASSERT_TOP(thr, 4); /* [ array totalLength bufres buf ] */
 
 		duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
 		h_bufobj = duk__require_bufobj_value(thr, 4);
 		DUK_ASSERT(h_bufobj != NULL);
 
 		copy_size = h_bufobj->length;
 		if (copy_size > space_left) {
 			copy_size = space_left;
 		}
 
-		if (h_bufobj->buf != NULL &&
-		    DUK_HBUFOBJ_VALID_SLICE(h_bufobj)) {
-			duk_memcpy_unsafe((void *) p,
-			                  (const void *) DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufobj),
-			                  copy_size);
+		if (h_bufobj->buf != NULL && DUK_HBUFOBJ_VALID_SLICE(h_bufobj)) {
+			duk_memcpy_unsafe((void *) p, (const void *) DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_bufobj), copy_size);
 		} else {
 			/* Just skip, leaving zeroes in the result. */
 			;
 		}
 		p += copy_size;
 		space_left -= copy_size;
 
@@ -29357,19 +30094,19 @@
 
 	h_val = duk_known_hbuffer(thr, -1);
 
 	duk__set_bufobj_buffer(thr, h_bufres, h_val);
 	h_bufres->is_typedarray = 1;
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufres);
 
-	duk_pop(thr);  /* pop plain buffer, now reachable through h_bufres */
+	duk_pop(thr); /* pop plain buffer, now reachable through h_bufres */
 
-	return 1;  /* return h_bufres */
+	return 1; /* return h_bufres */
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Shared readfield and writefield methods
  *
  *  The readfield/writefield methods need support for endianness and field
  *  types.  All offsets are byte based so no offset shifting is needed.
  */
@@ -29377,23 +30114,23 @@
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 /* Format of magic, bits:
  *   0...1: field type; 0=uint8, 1=uint16, 2=uint32, 3=float, 4=double, 5=unused, 6=unused, 7=unused
  *       3: endianness: 0=little, 1=big
  *       4: signed: 1=yes, 0=no
  *       5: typedarray: 1=yes, 0=no
  */
-#define  DUK__FLD_8BIT         0
-#define  DUK__FLD_16BIT        1
-#define  DUK__FLD_32BIT        2
-#define  DUK__FLD_FLOAT        3
-#define  DUK__FLD_DOUBLE       4
-#define  DUK__FLD_VARINT       5
-#define  DUK__FLD_BIGENDIAN    (1 << 3)
-#define  DUK__FLD_SIGNED       (1 << 4)
-#define  DUK__FLD_TYPEDARRAY   (1 << 5)
+#define DUK__FLD_8BIT       0
+#define DUK__FLD_16BIT      1
+#define DUK__FLD_32BIT      2
+#define DUK__FLD_FLOAT      3
+#define DUK__FLD_DOUBLE     4
+#define DUK__FLD_VARINT     5
+#define DUK__FLD_BIGENDIAN  (1 << 3)
+#define DUK__FLD_SIGNED     (1 << 4)
+#define DUK__FLD_TYPEDARRAY (1 << 5)
 
 /* XXX: split into separate functions for each field type? */
 DUK_INTERNAL duk_ret_t duk_bi_buffer_readfield(duk_hthread *thr) {
 	duk_small_uint_t magic = (duk_small_uint_t) duk_get_current_magic(thr);
 	duk_small_uint_t magic_ftype;
 	duk_small_uint_t magic_bigendian;
 	duk_small_uint_t magic_signed;
@@ -29409,29 +30146,29 @@
 	duk_double_union du;
 
 	magic_ftype = magic & 0x0007U;
 	magic_bigendian = magic & 0x0008U;
 	magic_signed = magic & 0x0010U;
 	magic_typedarray = magic & 0x0020U;
 
-	h_this = duk__require_bufobj_this(thr);  /* XXX: very inefficient for plain buffers */
+	h_this = duk__require_bufobj_this(thr); /* XXX: very inefficient for plain buffers */
 	DUK_ASSERT(h_this != NULL);
 	buffer_length = h_this->length;
 
 	/* [ offset noAssert                 ], when ftype != DUK__FLD_VARINT */
 	/* [ offset fieldByteLength noAssert ], when ftype == DUK__FLD_VARINT */
 	/* [ offset littleEndian             ], when DUK__FLD_TYPEDARRAY (regardless of ftype) */
 
 	/* Handle TypedArray vs. Node.js Buffer arg differences */
 	if (magic_typedarray) {
 		no_assert = 0;
 #if defined(DUK_USE_INTEGER_LE)
-		endswap = !duk_to_boolean(thr, 1);  /* 1=little endian */
+		endswap = !duk_to_boolean(thr, 1); /* 1=little endian */
 #else
-		endswap = duk_to_boolean(thr, 1);  /* 1=little endian */
+		endswap = duk_to_boolean(thr, 1); /* 1=little endian */
 #endif
 	} else {
 		no_assert = duk_to_boolean(thr, (magic_ftype == DUK__FLD_VARINT) ? 2 : 1);
 #if defined(DUK_USE_INTEGER_LE)
 		endswap = magic_bigendian;
 #else
 		endswap = !magic_bigendian;
@@ -29447,25 +30184,29 @@
 	if (offset_signed < 0) {
 		goto fail_bounds;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("readfield, buffer_length=%ld, offset=%ld, no_assert=%d, "
 	                     "magic=%04x, magic_fieldtype=%d, magic_bigendian=%d, magic_signed=%d, "
 	                     "endswap=%u",
-	                     (long) buffer_length, (long) offset, (int) no_assert,
-	                     (unsigned int) magic, (int) magic_ftype, (int) (magic_bigendian >> 3),
-	                     (int) (magic_signed >> 4), (int) endswap));
+	                     (long) buffer_length,
+	                     (long) offset,
+	                     (int) no_assert,
+	                     (unsigned int) magic,
+	                     (int) magic_ftype,
+	                     (int) (magic_bigendian >> 3),
+	                     (int) (magic_signed >> 4),
+	                     (int) endswap));
 
 	/* Update 'buffer_length' to be the effective, safe limit which
 	 * takes into account the underlying buffer.  This value will be
 	 * potentially invalidated by any side effect.
 	 */
 	check_length = DUK_HBUFOBJ_CLAMP_BYTELENGTH(h_this, buffer_length);
-	DUK_DDD(DUK_DDDPRINT("buffer_length=%ld, check_length=%ld",
-	                     (long) buffer_length, (long) check_length));
+	DUK_DDD(DUK_DDDPRINT("buffer_length=%ld, check_length=%ld", (long) buffer_length, (long) check_length));
 
 	if (h_this->buf) {
 		buf = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this);
 	} else {
 		/* Neutered.  We could go into the switch-case safely with
 		 * buf == NULL because check_length == 0.  To avoid scanbuild
 		 * warnings, fail directly instead.
@@ -29559,15 +30300,15 @@
 		duk_small_uint_t shift_tmp;
 #else
 		duk_double_t tmp;
 		duk_small_int_t highbyte;
 #endif
 		const duk_uint8_t *p;
 
-		field_bytelen = duk_get_int(thr, 1);  /* avoid side effects! */
+		field_bytelen = duk_get_int(thr, 1); /* avoid side effects! */
 		if (field_bytelen < 1 || field_bytelen > 6) {
 			goto fail_field_length;
 		}
 		if (offset + (duk_uint_t) field_bytelen > check_length) {
 			goto fail_bounds;
 		}
 		p = (const duk_uint8_t *) (buf + offset);
@@ -29577,20 +30318,20 @@
 		 * of negative numbers is a bit non-obvious in both cases.
 		 */
 
 		if (magic_bigendian) {
 			/* Gather in big endian */
 			i = 0;
 			i_step = 1;
-			i_end = field_bytelen;  /* one i_step over */
+			i_end = field_bytelen; /* one i_step over */
 		} else {
 			/* Gather in little endian */
 			i = field_bytelen - 1;
 			i_step = -1;
-			i_end = -1;  /* one i_step over */
+			i_end = -1; /* one i_step over */
 		}
 
 #if defined(DUK_USE_64BIT_OPS)
 		tmp = 0;
 		do {
 			DUK_ASSERT(i >= 0 && i < field_bytelen);
 			tmp = (tmp << 8) + (duk_int64_t) p[i];
@@ -29624,34 +30365,34 @@
 			tmp = (tmp * 256.0) + (duk_double_t) p[i];
 		}
 
 		duk_push_number(thr, tmp);
 #endif
 		break;
 	}
-	default: {  /* should never happen but default here */
+	default: { /* should never happen but default here */
 		goto fail_bounds;
 	}
 	}
 
 	return 1;
 
- fail_neutered:
- fail_field_length:
- fail_bounds:
+fail_neutered:
+fail_field_length:
+fail_bounds:
 	if (no_assert) {
 		/* Node.js return value for noAssert out-of-bounds reads is
 		 * usually (but not always) NaN.  Return NaN consistently.
 		 */
 		duk_push_nan(thr);
 		return 1;
 	}
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 /* XXX: split into separate functions for each field type? */
 DUK_INTERNAL duk_ret_t duk_bi_buffer_writefield(duk_hthread *thr) {
 	duk_small_uint_t magic = (duk_small_uint_t) duk_get_current_magic(thr);
 	duk_small_uint_t magic_ftype;
 	duk_small_uint_t magic_bigendian;
@@ -29670,31 +30411,31 @@
 
 	magic_ftype = magic & 0x0007U;
 	magic_bigendian = magic & 0x0008U;
 	magic_signed = magic & 0x0010U;
 	magic_typedarray = magic & 0x0020U;
 	DUK_UNREF(magic_signed);
 
-	h_this = duk__require_bufobj_this(thr);  /* XXX: very inefficient for plain buffers */
+	h_this = duk__require_bufobj_this(thr); /* XXX: very inefficient for plain buffers */
 	DUK_ASSERT(h_this != NULL);
 	buffer_length = h_this->length;
 
 	/* [ value  offset noAssert                 ], when ftype != DUK__FLD_VARINT */
 	/* [ value  offset fieldByteLength noAssert ], when ftype == DUK__FLD_VARINT */
 	/* [ offset value  littleEndian             ], when DUK__FLD_TYPEDARRAY (regardless of ftype) */
 
 	/* Handle TypedArray vs. Node.js Buffer arg differences */
 	if (magic_typedarray) {
 		no_assert = 0;
 #if defined(DUK_USE_INTEGER_LE)
-		endswap = !duk_to_boolean(thr, 2);  /* 1=little endian */
+		endswap = !duk_to_boolean(thr, 2); /* 1=little endian */
 #else
-		endswap = duk_to_boolean(thr, 2);  /* 1=little endian */
+		endswap = duk_to_boolean(thr, 2); /* 1=little endian */
 #endif
-		duk_swap(thr, 0, 1);  /* offset/value order different from Node.js */
+		duk_swap(thr, 0, 1); /* offset/value order different from Node.js */
 	} else {
 		no_assert = duk_to_boolean(thr, (magic_ftype == DUK__FLD_VARINT) ? 3 : 2);
 #if defined(DUK_USE_INTEGER_LE)
 		endswap = magic_bigendian;
 #else
 		endswap = !magic_bigendian;
 #endif
@@ -29725,31 +30466,36 @@
 	if (offset_signed < 0) {
 		goto fail_bounds;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("writefield, value=%!T, buffer_length=%ld, offset=%ld, no_assert=%d, "
 	                     "magic=%04x, magic_fieldtype=%d, magic_bigendian=%d, magic_signed=%d, "
 	                     "endswap=%u",
-	                     duk_get_tval(thr, 0), (long) buffer_length, (long) offset, (int) no_assert,
-	                     (unsigned int) magic, (int) magic_ftype, (int) (magic_bigendian >> 3),
-	                     (int) (magic_signed >> 4), (int) endswap));
+	                     duk_get_tval(thr, 0),
+	                     (long) buffer_length,
+	                     (long) offset,
+	                     (int) no_assert,
+	                     (unsigned int) magic,
+	                     (int) magic_ftype,
+	                     (int) (magic_bigendian >> 3),
+	                     (int) (magic_signed >> 4),
+	                     (int) endswap));
 
 	/* Coerce value to a number before computing check_length, so that
 	 * the field type specific coercion below can't have side effects
 	 * that would invalidate check_length.
 	 */
 	duk_to_number(thr, 0);
 
 	/* Update 'buffer_length' to be the effective, safe limit which
 	 * takes into account the underlying buffer.  This value will be
 	 * potentially invalidated by any side effect.
 	 */
 	check_length = DUK_HBUFOBJ_CLAMP_BYTELENGTH(h_this, buffer_length);
-	DUK_DDD(DUK_DDDPRINT("buffer_length=%ld, check_length=%ld",
-	                     (long) buffer_length, (long) check_length));
+	DUK_DDD(DUK_DDDPRINT("buffer_length=%ld, check_length=%ld", (long) buffer_length, (long) check_length));
 
 	if (h_this->buf) {
 		buf = DUK_HBUFOBJ_GET_SLICE_BASE(thr->heap, h_this);
 	} else {
 		/* Neutered.  We could go into the switch-case safely with
 		 * buf == NULL because check_length == 0.  To avoid scanbuild
 		 * warnings, fail directly instead.
@@ -29844,20 +30590,20 @@
 		/* Slow writing of value using either 64-bit arithmetic
 		 * or IEEE doubles if 64-bit types not available.  There's
 		 * no special sign handling when writing varints.
 		 */
 
 		if (magic_bigendian) {
 			/* Write in big endian */
-			i = field_bytelen;  /* one i_step added at top of loop */
+			i = field_bytelen; /* one i_step added at top of loop */
 			i_step = -1;
 			i_end = 0;
 		} else {
 			/* Write in little endian */
-			i = -1;  /* one i_step added at top of loop */
+			i = -1; /* one i_step added at top of loop */
 			i_step = 1;
 			i_end = field_bytelen - 1;
 		}
 
 		/* XXX: The duk_to_number() cast followed by integer coercion
 		 * is platform specific so NaN, +/- Infinity, and out-of-bounds
 		 * values result in platform specific output now.
@@ -29867,30 +30613,30 @@
 #if defined(DUK_USE_64BIT_OPS)
 		tmp = (duk_int64_t) duk_to_number(thr, 0);
 		p = (duk_uint8_t *) (buf + offset);
 		do {
 			i += i_step;
 			DUK_ASSERT(i >= 0 && i < field_bytelen);
 			p[i] = (duk_uint8_t) (tmp & 0xff);
-			tmp = tmp >> 8;  /* unnecessary shift for last byte */
+			tmp = tmp >> 8; /* unnecessary shift for last byte */
 		} while (i != i_end);
 #else
 		tmp = duk_to_number(thr, 0);
 		p = (duk_uint8_t *) (buf + offset);
 		do {
 			i += i_step;
 			tmp = DUK_FLOOR(tmp);
 			DUK_ASSERT(i >= 0 && i < field_bytelen);
 			p[i] = (duk_uint8_t) (DUK_FMOD(tmp, 256.0));
-			tmp = tmp / 256.0;  /* unnecessary div for last byte */
+			tmp = tmp / 256.0; /* unnecessary div for last byte */
 		} while (i != i_end);
 #endif
 		break;
 	}
-	default: {  /* should never happen but default here */
+	default: { /* should never happen but default here */
 		goto fail_bounds;
 	}
 	}
 
 	/* Node.js Buffer: return offset + #bytes written (i.e. next
 	 * write offset).
 	 */
@@ -29899,17 +30645,17 @@
 		 * by ES2015 (matches V8).
 		 */
 		return 0;
 	}
 	duk_push_uint(thr, offset + (duk_uint_t) nbytes);
 	return 1;
 
- fail_neutered:
- fail_field_length:
- fail_bounds:
+fail_neutered:
+fail_field_length:
+fail_bounds:
 	if (no_assert) {
 		/* Node.js return value for failed writes is offset + #bytes
 		 * that would have been written.
 		 */
 		/* XXX: for negative input offsets, 'offset' will be a large
 		 * positive value so the result here is confusing.
 		 */
@@ -29917,28 +30663,27 @@
 			return 0;
 		}
 		duk_push_uint(thr, offset + (duk_uint_t) nbytes);
 		return 1;
 	}
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  Accessors for .buffer, .byteLength, .byteOffset
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_LOCAL duk_hbufobj *duk__autospawn_arraybuffer(duk_hthread *thr, duk_hbuffer *h_buf) {
 	duk_hbufobj *h_res;
 
 	h_res = duk_push_bufobj_raw(thr,
-	                            DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                            DUK_HOBJECT_FLAG_BUFOBJ |
-	                            DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAYBUFFER),
+	                            DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_BUFOBJ |
+	                                DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARRAYBUFFER),
 	                            DUK_BIDX_ARRAYBUFFER_PROTOTYPE);
 	DUK_ASSERT(h_res != NULL);
 	DUK_UNREF(h_res);
 
 	duk__set_bufobj_buffer(thr, h_res, h_buf);
 	DUK_HBUFOBJ_ASSERT_VALID(h_res);
 	DUK_ASSERT(h_res->buf_prop == NULL);
@@ -29970,21 +30715,21 @@
 				 */
 
 				/* Set ArrayBuffer's .byteOffset and .byteLength based
 				 * on the view so that Arraybuffer[view.byteOffset]
 				 * matches view[0].
 				 */
 				h_arrbuf->offset = 0;
-				DUK_ASSERT(h_bufobj->offset + h_bufobj->length >= h_bufobj->offset);  /* Wrap check on creation. */
+				DUK_ASSERT(h_bufobj->offset + h_bufobj->length >= h_bufobj->offset); /* Wrap check on creation. */
 				h_arrbuf->length = h_bufobj->offset + h_bufobj->length;
 				DUK_ASSERT(h_arrbuf->buf_prop == NULL);
 
 				DUK_ASSERT(h_bufobj->buf_prop == NULL);
 				h_bufobj->buf_prop = (duk_hobject *) h_arrbuf;
-				DUK_HBUFOBJ_INCREF(thr, h_arrbuf);  /* Now reachable and accounted for. */
+				DUK_HBUFOBJ_INCREF(thr, h_arrbuf); /* Now reachable and accounted for. */
 			}
 
 			/* Left on stack; pushed for the second time below (OK). */
 		}
 		if (h_bufobj->buf_prop) {
 			duk_push_hobject(thr, h_bufobj->buf_prop);
 			return 1;
@@ -30014,25 +30759,25 @@
 
 	h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, DUK__BUFOBJ_FLAG_THROW /*flags*/);
 	DUK_ASSERT(h_bufobj != NULL);
 	if (DUK_HEAPHDR_IS_BUFFER((duk_heaphdr *) h_bufobj)) {
 		duk_hbuffer *h_buf;
 
 		h_buf = (duk_hbuffer *) h_bufobj;
-		DUK_ASSERT(DUK_HBUFFER_GET_SIZE(h_buf) <= DUK_UINT_MAX);  /* Buffer limits. */
+		DUK_ASSERT(DUK_HBUFFER_GET_SIZE(h_buf) <= DUK_UINT_MAX); /* Buffer limits. */
 		duk_push_uint(thr, (duk_uint_t) DUK_HBUFFER_GET_SIZE(h_buf));
 	} else {
 		/* If neutered must return 0; length is zeroed during
 		 * neutering.
 		 */
 		duk_push_uint(thr, h_bufobj->length);
 	}
 	return 1;
 }
-#else  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#else /* DUK_USE_BUFFEROBJECT_SUPPORT */
 /* No .buffer getter without ArrayBuffer support. */
 #if 0
 DUK_INTERNAL duk_ret_t duk_bi_typedarray_buffer_getter(duk_hthread *thr) {
 	return 0;
 }
 #endif
 
@@ -30046,15 +30791,15 @@
 
 	/* XXX: helper? */
 	duk_push_this(thr);
 	h_buf = duk_require_hbuffer(thr, -1);
 	duk_push_uint(thr, DUK_HBUFFER_GET_SIZE(h_buf));
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__BUFOBJ_FLAG_PROMOTE
 #undef DUK__BUFOBJ_FLAG_THROW
 #undef DUK__FLD_16BIT
 #undef DUK__FLD_32BIT
 #undef DUK__FLD_8BIT
@@ -30257,15 +31002,15 @@
 
 	p = enc_ctx->ptr;
 	*p++ = 0xfbU;
 	DUK_RAW_WRITEINC_DOUBLE_BE(p, d);
 	p += 8;
 	enc_ctx->ptr = p;
 }
-#else  /* DUK_CBOR_DOUBLE_AS_IS */
+#else /* DUK_CBOR_DOUBLE_AS_IS */
 DUK_LOCAL void duk__cbor_encode_double_fp(duk_cbor_encode_context *enc_ctx, double d) {
 	duk_double_union u;
 	duk_uint16_t u16;
 	duk_int16_t expt;
 	duk_uint8_t *p;
 
 	DUK_ASSERT(DUK_FPCLASSIFY(d) != DUK_FP_ZERO);
@@ -30292,16 +31037,15 @@
 		 *          7        6        5        4        3        2        1        0  (LE index)
 		 * double: seeeeeee eeeemmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm mmmmmmmm
 		 * half:         seeeee mmmm mmmmmm00 00000000 00000000 00000000 00000000 00000000
 		 */
 		duk_bool_t use_half_float;
 
 		use_half_float =
-		    (u.uc[0] == 0 && u.uc[1] == 0 && u.uc[2] == 0 && u.uc[3] == 0 &&
-		     u.uc[4] == 0 && (u.uc[5] & 0x03U) == 0);
+		    (u.uc[0] == 0 && u.uc[1] == 0 && u.uc[2] == 0 && u.uc[3] == 0 && u.uc[4] == 0 && (u.uc[5] & 0x03U) == 0);
 
 		if (use_half_float) {
 			duk_uint32_t t;
 
 			expt += 15;
 			t = (duk_uint32_t) (u.uc[7] & 0x80U) << 8;
 			t += (duk_uint32_t) expt << 10;
@@ -30445,17 +31189,17 @@
 
 	/* Caller must ensure space. */
 	DUK_ASSERT(duk__cbor_get_reserve(enc_ctx) >= 1 + 8);
 
 	/* Most important path is integers.  The floor() test will be true
 	 * for Inf too (but not NaN).
 	 */
-	d_floor = DUK_FLOOR(d);  /* identity if d is +/- 0.0, NaN, or +/- Infinity */
+	d_floor = DUK_FLOOR(d); /* identity if d is +/- 0.0, NaN, or +/- Infinity */
 	if (DUK_LIKELY(duk_double_equals(d_floor, d) != 0)) {
-		DUK_ASSERT(!DUK_ISNAN(d));  /* NaN == NaN compares false. */
+		DUK_ASSERT(!DUK_ISNAN(d)); /* NaN == NaN compares false. */
 		if (DUK_SIGNBIT(d)) {
 			if (d >= -4294967296.0) {
 				d = -1.0 - d;
 				if (d >= 0.0) {
 					DUK_ASSERT(d >= 0.0);
 					duk__cbor_encode_uint32(enc_ctx, duk__cbor_double_to_uint32(d), 0x20U);
 					return;
@@ -30486,15 +31230,15 @@
 	 * 64-bit uint/sint representation vs. IEEE double or
 	 * float.
 	 */
 
 	DUK_ASSERT(DUK_FPCLASSIFY(d) != DUK_FP_ZERO);
 	duk__cbor_encode_double_fp(enc_ctx, d);
 }
-#endif  /* DUK_CBOR_DOUBLE_AS_IS */
+#endif /* DUK_CBOR_DOUBLE_AS_IS */
 
 DUK_LOCAL void duk__cbor_encode_string_top(duk_cbor_encode_context *enc_ctx) {
 	const duk_uint8_t *str;
 	duk_size_t len;
 	duk_uint8_t *p;
 
 	/* CBOR differentiates between UTF-8 text strings and byte strings.
@@ -30537,15 +31281,16 @@
 
 	duk__cbor_encode_sizet_uint32_check(enc_ctx, len);
 #if defined(DUK_CBOR_TEXT_STRINGS)
 	duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len, 0x60U);
 #elif defined(DUK_CBOR_BYTE_STRINGS)
 	duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len, 0x40U);
 #else
-	duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len,
+	duk__cbor_encode_uint32(enc_ctx,
+	                        (duk_uint32_t) len,
 	                        (DUK_LIKELY(duk_unicode_is_utf8_compatible(str, len) != 0) ? 0x60U : 0x40U));
 #endif
 	duk__cbor_encode_ensure(enc_ctx, len);
 	p = enc_ctx->ptr;
 	duk_memcpy((void *) p, (const void *) str, len);
 	p += len;
 	enc_ctx->ptr = p;
@@ -30597,37 +31342,37 @@
 		 * objects without indefinite length.  Emit an
 		 * indefinite length byte initially, and if the final
 		 * property count is small enough to also fit in one
 		 * byte, backpatch it later.  Otherwise keep the
 		 * indefinite length.  This works well up to 23
 		 * properties which is practical and good enough.
 		 */
-		off_ib = (duk_size_t) (enc_ctx->ptr - enc_ctx->buf);  /* XXX: get_offset? */
+		off_ib = (duk_size_t) (enc_ctx->ptr - enc_ctx->buf); /* XXX: get_offset? */
 		count = 0U;
 		p = enc_ctx->ptr;
-		*p++ = 0xa0U + 0x1fU;  /* indefinite length */
+		*p++ = 0xa0U + 0x1fU; /* indefinite length */
 		enc_ctx->ptr = p;
 		duk_enum(enc_ctx->thr, -1, DUK_ENUM_OWN_PROPERTIES_ONLY);
 		while (duk_next(enc_ctx->thr, -1, 1 /*get_value*/)) {
-			duk_insert(enc_ctx->thr, -2);  /* [ ... key value ] -> [ ... value key ] */
+			duk_insert(enc_ctx->thr, -2); /* [ ... key value ] -> [ ... value key ] */
 			duk__cbor_encode_value(enc_ctx);
 			duk__cbor_encode_value(enc_ctx);
 			count++;
 			if (count == 0U) {
 				duk__cbor_encode_error(enc_ctx);
 			}
 		}
 		duk_pop(enc_ctx->thr);
 		if (count <= 0x17U) {
 			DUK_ASSERT(off_ib < enc_ctx->len);
 			enc_ctx->buf[off_ib] = 0xa0U + (duk_uint8_t) count;
 		} else {
 			duk__cbor_encode_ensure(enc_ctx, 1);
 			p = enc_ctx->ptr;
-			*p++ = 0xffU;  /* break */
+			*p++ = 0xffU; /* break */
 			enc_ctx->ptr = p;
 		}
 	}
 
 	duk__cbor_encode_objarr_exit(enc_ctx);
 }
 
@@ -30747,15 +31492,15 @@
 	default:
 		goto fail;
 	}
 
 	duk_pop(enc_ctx->thr);
 	return;
 
- fail:
+fail:
 	duk__cbor_encode_error(enc_ctx);
 }
 
 /*
  *  Decoding
  */
 
@@ -30824,15 +31569,15 @@
 	if (DUK_UNLIKELY(dec_ctx->off >= dec_ctx->len)) {
 		duk__cbor_decode_error(dec_ctx);
 	}
 	return dec_ctx->buf[dec_ctx->off];
 }
 
 DUK_LOCAL void duk__cbor_decode_rewind(duk_cbor_decode_context *dec_ctx, duk_size_t len) {
-	DUK_ASSERT(len <= dec_ctx->off);  /* Caller must ensure. */
+	DUK_ASSERT(len <= dec_ctx->off); /* Caller must ensure. */
 	dec_ctx->off -= len;
 }
 
 #if 0
 DUK_LOCAL void duk__cbor_decode_ensure(duk_cbor_decode_context *dec_ctx, duk_size_t len) {
 	if (dec_ctx->off + len > dec_ctx->len) {
 		duk__cbor_decode_error(dec_ctx);
@@ -30844,15 +31589,15 @@
 	DUK_ASSERT(dec_ctx->off <= dec_ctx->len);
 	if (DUK_LIKELY(dec_ctx->len - dec_ctx->off >= len)) {
 		const duk_uint8_t *res = dec_ctx->buf + dec_ctx->off;
 		dec_ctx->off += len;
 		return res;
 	}
 
-	duk__cbor_decode_error(dec_ctx);  /* Not enough input. */
+	duk__cbor_decode_error(dec_ctx); /* Not enough input. */
 	return NULL;
 }
 
 DUK_LOCAL int duk__cbor_decode_checkbreak(duk_cbor_decode_context *dec_ctx) {
 	if (duk__cbor_decode_peekbyte(dec_ctx) == 0xffU) {
 		DUK_ASSERT(dec_ctx->off < dec_ctx->len);
 		dec_ctx->off++;
@@ -30876,24 +31621,24 @@
 	ai = ib & 0x1fU;
 	if (ai <= 0x17U) {
 		t = ai;
 		goto shared_exit;
 	}
 
 	switch (ai) {
-	case 0x18U:  /* 1 byte */
+	case 0x18U: /* 1 byte */
 		t = (duk_uint32_t) duk__cbor_decode_readbyte(dec_ctx);
 		goto shared_exit;
-	case 0x19U:  /* 2 byte */
+	case 0x19U: /* 2 byte */
 		t = (duk_uint32_t) duk__cbor_decode_read_u16(dec_ctx);
 		goto shared_exit;
-	case 0x1aU:  /* 4 byte */
+	case 0x1aU: /* 4 byte */
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
 		goto shared_exit;
-	case 0x1bU:  /* 8 byte */
+	case 0x1bU: /* 8 byte */
 		/* For uint64 it's important to handle the -1.0 part before
 		 * casting to double: otherwise the adjustment might be lost
 		 * in the cast.  Uses: -1.0 - d <=> -(d + 1.0).
 		 */
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
 		t2 = t;
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
@@ -30942,15 +31687,15 @@
 #if 1
 		/* Use two double parts, avoids dependency on 64-bit type.
 		 * Avoid precision loss carefully, especially when dealing
 		 * with the required +1 for negative values.
 		 *
 		 * No fastint check for this path at present.
 		 */
-		d1 = (duk_double_t) t1;  /* XXX: cast helpers */
+		d1 = (duk_double_t) t1; /* XXX: cast helpers */
 		d2 = (duk_double_t) t2 * 4294967296.0;
 		if (negative) {
 			d1 += 1.0;
 		}
 		d = d2 + d1;
 		if (negative) {
 			d = -d;
@@ -30960,32 +31705,30 @@
 		duk_push_number(dec_ctx->thr, d);
 		return;
 	}
 
 	duk__cbor_decode_error(dec_ctx);
 	return;
 
- shared_exit:
+shared_exit:
 	if (negative) {
 		/* XXX: a push and check for fastint API would be nice */
-		if ((duk_uint_t) t <= (duk_uint_t) -(DUK_INT_MIN + 1)) {
+		if ((duk_uint_t) t <= (duk_uint_t) - (DUK_INT_MIN + 1)) {
 			duk_push_int(dec_ctx->thr, -1 - ((duk_int_t) t));
 		} else {
 			duk_push_number(dec_ctx->thr, -1.0 - (duk_double_t) t);
 		}
 	} else {
 		duk_push_uint(dec_ctx->thr, (duk_uint_t) t);
 	}
 }
 
 DUK_LOCAL void duk__cbor_decode_skip_aival_int(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib) {
-	const duk_int8_t skips[32] = {
-		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-		0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 4, 8, -1, -1, -1, -1
-	};
+	const duk_int8_t skips[32] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0,  0,  0,
+		                       0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 4, 8, -1, -1, -1, -1 };
 	duk_uint8_t ai;
 	duk_int8_t skip;
 
 	ai = ib & 0x1fU;
 	skip = skips[ai];
 	if (DUK_UNLIKELY(skip < 0)) {
 		duk__cbor_decode_error(dec_ctx);
@@ -31000,24 +31743,24 @@
 
 	ai = ib & 0x1fU;
 	if (ai <= 0x17U) {
 		return (duk_uint32_t) ai;
 	}
 
 	switch (ai) {
-	case 0x18U:  /* 1 byte */
+	case 0x18U: /* 1 byte */
 		t = (duk_uint32_t) duk__cbor_decode_readbyte(dec_ctx);
 		return t;
-	case 0x19U:  /* 2 byte */
+	case 0x19U: /* 2 byte */
 		t = (duk_uint32_t) duk__cbor_decode_read_u16(dec_ctx);
 		return t;
-	case 0x1aU:  /* 4 byte */
+	case 0x1aU: /* 4 byte */
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
 		return t;
-	case 0x1bU:  /* 8 byte */
+	case 0x1bU: /* 8 byte */
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
 		if (t != 0U) {
 			break;
 		}
 		t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
 		return t;
 	}
@@ -31043,15 +31786,15 @@
 	buf = (duk_uint8_t *) duk_push_fixed_buffer(dec_ctx->thr, (duk_size_t) len);
 	duk_memcpy((void *) buf, (const void *) inp, (size_t) len);
 }
 
 DUK_LOCAL void duk__cbor_decode_join_buffers(duk_cbor_decode_context *dec_ctx, duk_idx_t count) {
 	duk_size_t total_size = 0;
 	duk_idx_t top = duk_get_top(dec_ctx->thr);
-	duk_idx_t base = top - count;  /* count is >= 1 */
+	duk_idx_t base = top - count; /* count is >= 1 */
 	duk_idx_t idx;
 	duk_uint8_t *p = NULL;
 
 	DUK_ASSERT(count >= 1);
 	DUK_ASSERT(top >= count);
 
 	for (;;) {
@@ -31064,15 +31807,15 @@
 
 			buf_data = (duk_uint8_t *) duk_require_buffer(dec_ctx->thr, idx, &buf_size);
 			if (p != NULL) {
 				duk_memcpy_unsafe((void *) p, (const void *) buf_data, buf_size);
 				p += buf_size;
 			} else {
 				total_size += buf_size;
-				if (DUK_UNLIKELY(total_size < buf_size)) {  /* Wrap check. */
+				if (DUK_UNLIKELY(total_size < buf_size)) { /* Wrap check. */
 					duk__cbor_decode_error(dec_ctx);
 				}
 			}
 		}
 
 		if (p != NULL) {
 			break;
@@ -31091,15 +31834,15 @@
 	for (;;) {
 		if (duk__cbor_decode_checkbreak(dec_ctx)) {
 			break;
 		}
 		duk_require_stack(dec_ctx->thr, 1);
 		duk__cbor_decode_buffer(dec_ctx, expected_base);
 		count++;
-		if (DUK_UNLIKELY(count <= 0)) {  /* Wrap check. */
+		if (DUK_UNLIKELY(count <= 0)) { /* Wrap check. */
 			duk__cbor_decode_error(dec_ctx);
 		}
 	}
 	if (count == 0) {
 		(void) duk_push_fixed_buffer(dec_ctx->thr, 0);
 	} else if (count > 1) {
 		duk__cbor_decode_join_buffers(dec_ctx, count);
@@ -31139,18 +31882,18 @@
 			 *    1.mmmmmmmmmm 0.... * 2^-14
 			 *   -1.0000000000 0.... * 2^-14
 			 *
 			 * Double exponent: -14 + 1023 = 0x3f1
 			 */
 			u.uc[7] = 0x3fU;
 			u.uc[6] = 0x10U + (duk_uint8_t) ((u16 >> 6) & 0x0fU);
-			u.uc[5] = (duk_uint8_t) ((u16 << 2) & 0xffU);  /* Mask is really 0xfcU */
+			u.uc[5] = (duk_uint8_t) ((u16 << 2) & 0xffU); /* Mask is really 0xfcU */
 
 			duk_dblunion_little_to_host(&u);
-			res = u.d - 0.00006103515625;  /* 2^(-14) */
+			res = u.d - 0.00006103515625; /* 2^(-14) */
 			if (u16 & 0x8000U) {
 				res = -res;
 			}
 			return res;
 		}
 	} else if (expt == 16) {
 		/* +/- Inf or NaN. */
@@ -31241,39 +31984,39 @@
 		if (len == 0xffffffffUL) {
 			goto failure;
 		}
 	}
 
 	/* XXX: use bare array? */
 	duk_push_array(dec_ctx->thr);
-	for (idx = 0U; ;) {
+	for (idx = 0U;;) {
 		if (len == 0xffffffffUL && duk__cbor_decode_checkbreak(dec_ctx)) {
 			break;
 		}
 		if (idx == len) {
 			if (ai == 0x1fU) {
 				goto failure;
 			}
 			break;
 		}
 		duk__cbor_decode_value(dec_ctx);
 		duk_put_prop_index(dec_ctx->thr, -2, (duk_uarridx_t) idx);
 		idx++;
 		if (idx == 0U) {
-			goto failure;  /* wrapped */
+			goto failure; /* wrapped */
 		}
 	}
 
 #if 0
  success:
 #endif
 	duk__cbor_decode_objarr_exit(dec_ctx);
 	return 1;
 
- failure:
+failure:
 	/* No need to unwind recursion checks, caller will throw. */
 	return 0;
 }
 
 DUK_LOCAL duk_bool_t duk__cbor_decode_map(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib, duk_uint8_t ai) {
 	duk_uint32_t count;
 
@@ -31317,15 +32060,15 @@
 
 #if 0
  success:
 #endif
 	duk__cbor_decode_objarr_exit(dec_ctx);
 	return 1;
 
- failure:
+failure:
 	/* No need to unwind recursion checks, caller will throw. */
 	return 0;
 }
 
 DUK_LOCAL duk_double_t duk__cbor_decode_float(duk_cbor_decode_context *dec_ctx) {
 	duk_float_union u;
 	const duk_uint8_t *inp;
@@ -31341,134 +32084,319 @@
 	inp = duk__cbor_decode_consume(dec_ctx, 8);
 	duk_memcpy((void *) u.uc, (const void *) inp, 8);
 	duk_dblunion_big_to_host(&u);
 	return u.d;
 }
 
 #if defined(DUK_CBOR_DECODE_FASTPATH)
-#define DUK__CBOR_AI  (ib & 0x1fU)
+#define DUK__CBOR_AI (ib & 0x1fU)
 
 DUK_LOCAL void duk__cbor_decode_value(duk_cbor_decode_context *dec_ctx) {
 	duk_uint8_t ib;
 
 	/* Any paths potentially recursing back to duk__cbor_decode_value()
 	 * must perform a Duktape value stack growth check.  Avoid the check
 	 * here for simple paths like primitive values.
 	 */
 
- reread_initial_byte:
+reread_initial_byte:
 	DUK_DDD(DUK_DDDPRINT("cbor decode off=%ld len=%ld", (long) dec_ctx->off, (long) dec_ctx->len));
 
 	ib = duk__cbor_decode_readbyte(dec_ctx);
 
 	/* Full initial byte switch, footprint cost over baseline is ~+1kB. */
 	/* XXX: Force full switch with no range check. */
 
 	switch (ib) {
-	case 0x00U: case 0x01U: case 0x02U: case 0x03U: case 0x04U: case 0x05U: case 0x06U: case 0x07U:
-	case 0x08U: case 0x09U: case 0x0aU: case 0x0bU: case 0x0cU: case 0x0dU: case 0x0eU: case 0x0fU:
-	case 0x10U: case 0x11U: case 0x12U: case 0x13U: case 0x14U: case 0x15U: case 0x16U: case 0x17U:
+	case 0x00U:
+	case 0x01U:
+	case 0x02U:
+	case 0x03U:
+	case 0x04U:
+	case 0x05U:
+	case 0x06U:
+	case 0x07U:
+	case 0x08U:
+	case 0x09U:
+	case 0x0aU:
+	case 0x0bU:
+	case 0x0cU:
+	case 0x0dU:
+	case 0x0eU:
+	case 0x0fU:
+	case 0x10U:
+	case 0x11U:
+	case 0x12U:
+	case 0x13U:
+	case 0x14U:
+	case 0x15U:
+	case 0x16U:
+	case 0x17U:
 		duk_push_uint(dec_ctx->thr, ib);
 		break;
-	case 0x18U: case 0x19U: case 0x1aU: case 0x1bU:
+	case 0x18U:
+	case 0x19U:
+	case 0x1aU:
+	case 0x1bU:
 		duk__cbor_decode_push_aival_int(dec_ctx, ib, 0 /*negative*/);
 		break;
-	case 0x1cU: case 0x1dU: case 0x1eU: case 0x1fU:
+	case 0x1cU:
+	case 0x1dU:
+	case 0x1eU:
+	case 0x1fU:
 		goto format_error;
-	case 0x20U: case 0x21U: case 0x22U: case 0x23U: case 0x24U: case 0x25U: case 0x26U: case 0x27U:
-	case 0x28U: case 0x29U: case 0x2aU: case 0x2bU: case 0x2cU: case 0x2dU: case 0x2eU: case 0x2fU:
-	case 0x30U: case 0x31U: case 0x32U: case 0x33U: case 0x34U: case 0x35U: case 0x36U: case 0x37U:
+	case 0x20U:
+	case 0x21U:
+	case 0x22U:
+	case 0x23U:
+	case 0x24U:
+	case 0x25U:
+	case 0x26U:
+	case 0x27U:
+	case 0x28U:
+	case 0x29U:
+	case 0x2aU:
+	case 0x2bU:
+	case 0x2cU:
+	case 0x2dU:
+	case 0x2eU:
+	case 0x2fU:
+	case 0x30U:
+	case 0x31U:
+	case 0x32U:
+	case 0x33U:
+	case 0x34U:
+	case 0x35U:
+	case 0x36U:
+	case 0x37U:
 		duk_push_int(dec_ctx->thr, -((duk_int_t) ((ib - 0x20U) + 1U)));
 		break;
-	case 0x38U: case 0x39U: case 0x3aU: case 0x3bU:
+	case 0x38U:
+	case 0x39U:
+	case 0x3aU:
+	case 0x3bU:
 		duk__cbor_decode_push_aival_int(dec_ctx, ib, 1 /*negative*/);
 		break;
-	case 0x3cU: case 0x3dU: case 0x3eU: case 0x3fU:
+	case 0x3cU:
+	case 0x3dU:
+	case 0x3eU:
+	case 0x3fU:
 		goto format_error;
-	case 0x40U: case 0x41U: case 0x42U: case 0x43U: case 0x44U: case 0x45U: case 0x46U: case 0x47U:
-	case 0x48U: case 0x49U: case 0x4aU: case 0x4bU: case 0x4cU: case 0x4dU: case 0x4eU: case 0x4fU:
-	case 0x50U: case 0x51U: case 0x52U: case 0x53U: case 0x54U: case 0x55U: case 0x56U: case 0x57U:
+	case 0x40U:
+	case 0x41U:
+	case 0x42U:
+	case 0x43U:
+	case 0x44U:
+	case 0x45U:
+	case 0x46U:
+	case 0x47U:
+	case 0x48U:
+	case 0x49U:
+	case 0x4aU:
+	case 0x4bU:
+	case 0x4cU:
+	case 0x4dU:
+	case 0x4eU:
+	case 0x4fU:
+	case 0x50U:
+	case 0x51U:
+	case 0x52U:
+	case 0x53U:
+	case 0x54U:
+	case 0x55U:
+	case 0x56U:
+	case 0x57U:
 		/* XXX: Avoid rewind, we know the length already. */
 		DUK_ASSERT(dec_ctx->off > 0U);
 		dec_ctx->off--;
 		duk__cbor_decode_buffer(dec_ctx, 0x40U);
 		break;
-	case 0x58U: case 0x59U: case 0x5aU: case 0x5bU:
+	case 0x58U:
+	case 0x59U:
+	case 0x5aU:
+	case 0x5bU:
 		/* XXX: Avoid rewind, decode length inline. */
 		DUK_ASSERT(dec_ctx->off > 0U);
 		dec_ctx->off--;
 		duk__cbor_decode_buffer(dec_ctx, 0x40U);
 		break;
-	case 0x5cU: case 0x5dU: case 0x5eU:
+	case 0x5cU:
+	case 0x5dU:
+	case 0x5eU:
 		goto format_error;
 	case 0x5fU:
 		duk__cbor_decode_and_join_strbuf(dec_ctx, 0x40U);
 		break;
-	case 0x60U: case 0x61U: case 0x62U: case 0x63U: case 0x64U: case 0x65U: case 0x66U: case 0x67U:
-	case 0x68U: case 0x69U: case 0x6aU: case 0x6bU: case 0x6cU: case 0x6dU: case 0x6eU: case 0x6fU:
-	case 0x70U: case 0x71U: case 0x72U: case 0x73U: case 0x74U: case 0x75U: case 0x76U: case 0x77U:
+	case 0x60U:
+	case 0x61U:
+	case 0x62U:
+	case 0x63U:
+	case 0x64U:
+	case 0x65U:
+	case 0x66U:
+	case 0x67U:
+	case 0x68U:
+	case 0x69U:
+	case 0x6aU:
+	case 0x6bU:
+	case 0x6cU:
+	case 0x6dU:
+	case 0x6eU:
+	case 0x6fU:
+	case 0x70U:
+	case 0x71U:
+	case 0x72U:
+	case 0x73U:
+	case 0x74U:
+	case 0x75U:
+	case 0x76U:
+	case 0x77U:
 		/* XXX: Avoid double decode of length. */
 		duk__cbor_decode_string(dec_ctx, ib, DUK__CBOR_AI);
 		break;
-	case 0x78U: case 0x79U: case 0x7aU: case 0x7bU:
+	case 0x78U:
+	case 0x79U:
+	case 0x7aU:
+	case 0x7bU:
 		/* XXX: Avoid double decode of length. */
 		duk__cbor_decode_string(dec_ctx, ib, DUK__CBOR_AI);
 		break;
-	case 0x7cU: case 0x7dU: case 0x7eU:
+	case 0x7cU:
+	case 0x7dU:
+	case 0x7eU:
 		goto format_error;
 	case 0x7fU:
 		duk__cbor_decode_string(dec_ctx, ib, DUK__CBOR_AI);
 		break;
-	case 0x80U: case 0x81U: case 0x82U: case 0x83U: case 0x84U: case 0x85U: case 0x86U: case 0x87U:
-	case 0x88U: case 0x89U: case 0x8aU: case 0x8bU: case 0x8cU: case 0x8dU: case 0x8eU: case 0x8fU:
-	case 0x90U: case 0x91U: case 0x92U: case 0x93U: case 0x94U: case 0x95U: case 0x96U: case 0x97U:
+	case 0x80U:
+	case 0x81U:
+	case 0x82U:
+	case 0x83U:
+	case 0x84U:
+	case 0x85U:
+	case 0x86U:
+	case 0x87U:
+	case 0x88U:
+	case 0x89U:
+	case 0x8aU:
+	case 0x8bU:
+	case 0x8cU:
+	case 0x8dU:
+	case 0x8eU:
+	case 0x8fU:
+	case 0x90U:
+	case 0x91U:
+	case 0x92U:
+	case 0x93U:
+	case 0x94U:
+	case 0x95U:
+	case 0x96U:
+	case 0x97U:
 		if (DUK_UNLIKELY(duk__cbor_decode_array(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0x98U: case 0x99U: case 0x9aU: case 0x9bU:
+	case 0x98U:
+	case 0x99U:
+	case 0x9aU:
+	case 0x9bU:
 		if (DUK_UNLIKELY(duk__cbor_decode_array(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0x9cU: case 0x9dU: case 0x9eU:
+	case 0x9cU:
+	case 0x9dU:
+	case 0x9eU:
 		goto format_error;
 	case 0x9fU:
 		if (DUK_UNLIKELY(duk__cbor_decode_array(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0xa0U: case 0xa1U: case 0xa2U: case 0xa3U: case 0xa4U: case 0xa5U: case 0xa6U: case 0xa7U:
-	case 0xa8U: case 0xa9U: case 0xaaU: case 0xabU: case 0xacU: case 0xadU: case 0xaeU: case 0xafU:
-	case 0xb0U: case 0xb1U: case 0xb2U: case 0xb3U: case 0xb4U: case 0xb5U: case 0xb6U: case 0xb7U:
+	case 0xa0U:
+	case 0xa1U:
+	case 0xa2U:
+	case 0xa3U:
+	case 0xa4U:
+	case 0xa5U:
+	case 0xa6U:
+	case 0xa7U:
+	case 0xa8U:
+	case 0xa9U:
+	case 0xaaU:
+	case 0xabU:
+	case 0xacU:
+	case 0xadU:
+	case 0xaeU:
+	case 0xafU:
+	case 0xb0U:
+	case 0xb1U:
+	case 0xb2U:
+	case 0xb3U:
+	case 0xb4U:
+	case 0xb5U:
+	case 0xb6U:
+	case 0xb7U:
 		if (DUK_UNLIKELY(duk__cbor_decode_map(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0xb8U: case 0xb9U: case 0xbaU: case 0xbbU:
+	case 0xb8U:
+	case 0xb9U:
+	case 0xbaU:
+	case 0xbbU:
 		if (DUK_UNLIKELY(duk__cbor_decode_map(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0xbcU: case 0xbdU: case 0xbeU:
+	case 0xbcU:
+	case 0xbdU:
+	case 0xbeU:
 		goto format_error;
 	case 0xbfU:
 		if (DUK_UNLIKELY(duk__cbor_decode_map(dec_ctx, ib, DUK__CBOR_AI) == 0)) {
 			goto format_error;
 		}
 		break;
-	case 0xc0U: case 0xc1U: case 0xc2U: case 0xc3U: case 0xc4U: case 0xc5U: case 0xc6U: case 0xc7U:
-	case 0xc8U: case 0xc9U: case 0xcaU: case 0xcbU: case 0xccU: case 0xcdU: case 0xceU: case 0xcfU:
-	case 0xd0U: case 0xd1U: case 0xd2U: case 0xd3U: case 0xd4U: case 0xd5U: case 0xd6U: case 0xd7U:
+	case 0xc0U:
+	case 0xc1U:
+	case 0xc2U:
+	case 0xc3U:
+	case 0xc4U:
+	case 0xc5U:
+	case 0xc6U:
+	case 0xc7U:
+	case 0xc8U:
+	case 0xc9U:
+	case 0xcaU:
+	case 0xcbU:
+	case 0xccU:
+	case 0xcdU:
+	case 0xceU:
+	case 0xcfU:
+	case 0xd0U:
+	case 0xd1U:
+	case 0xd2U:
+	case 0xd3U:
+	case 0xd4U:
+	case 0xd5U:
+	case 0xd6U:
+	case 0xd7U:
 		/* Tag 0-23: drop. */
 		goto reread_initial_byte;
-	case 0xd8U: case 0xd9U: case 0xdaU: case 0xdbU:
+	case 0xd8U:
+	case 0xd9U:
+	case 0xdaU:
+	case 0xdbU:
 		duk__cbor_decode_skip_aival_int(dec_ctx, ib);
 		goto reread_initial_byte;
-	case 0xdcU: case 0xddU: case 0xdeU: case 0xdfU:
+	case 0xdcU:
+	case 0xddU:
+	case 0xdeU:
+	case 0xdfU:
 		goto format_error;
 	case 0xe0U:
 		goto format_error;
 	case 0xe1U:
 		goto format_error;
 	case 0xe2U:
 		goto format_error;
@@ -31540,31 +32468,31 @@
 		break;
 	}
 	case 0xfcU:
 	case 0xfdU:
 	case 0xfeU:
 	case 0xffU:
 		goto format_error;
-	}  /* end switch */
+	} /* end switch */
 
 	return;
 
- format_error:
+format_error:
 	duk__cbor_decode_error(dec_ctx);
 }
-#else  /* DUK_CBOR_DECODE_FASTPATH */
+#else /* DUK_CBOR_DECODE_FASTPATH */
 DUK_LOCAL void duk__cbor_decode_value(duk_cbor_decode_context *dec_ctx) {
 	duk_uint8_t ib, mt, ai;
 
 	/* Any paths potentially recursing back to duk__cbor_decode_value()
 	 * must perform a Duktape value stack growth check.  Avoid the check
 	 * here for simple paths like primitive values.
 	 */
 
- reread_initial_byte:
+reread_initial_byte:
 	DUK_DDD(DUK_DDDPRINT("cbor decode off=%ld len=%ld", (long) dec_ctx->off, (long) dec_ctx->len));
 
 	ib = duk__cbor_decode_readbyte(dec_ctx);
 	mt = ib >> 5U;
 	ai = ib & 0x1fU;
 
 	/* Additional information in [24,27] = [0x18,0x1b] has relatively
@@ -31572,56 +32500,56 @@
 	 * bytes.  For major type 7 the 1-byte value is a 'simple type', and
 	 * 2/4/8-byte values are floats.  For other major types the 1/2/4/8
 	 * byte values are integers.  The lengths are uniform, but the typing
 	 * is not.
 	 */
 
 	switch (mt) {
-	case 0U: {  /* unsigned integer */
+	case 0U: { /* unsigned integer */
 		duk__cbor_decode_push_aival_int(dec_ctx, ib, 0 /*negative*/);
 		break;
 	}
-	case 1U: {  /* negative integer */
+	case 1U: { /* negative integer */
 		duk__cbor_decode_push_aival_int(dec_ctx, ib, 1 /*negative*/);
 		break;
 	}
-	case 2U: {  /* byte string */
+	case 2U: { /* byte string */
 		if (ai == 0x1fU) {
 			duk__cbor_decode_and_join_strbuf(dec_ctx, 0x40U);
 		} else {
 			duk__cbor_decode_rewind(dec_ctx, 1U);
 			duk__cbor_decode_buffer(dec_ctx, 0x40U);
 		}
 		break;
 	}
-	case 3U: {  /* text string */
+	case 3U: { /* text string */
 		duk__cbor_decode_string(dec_ctx, ib, ai);
 		break;
 	}
-	case 4U: {  /* array of data items */
+	case 4U: { /* array of data items */
 		if (DUK_UNLIKELY(duk__cbor_decode_array(dec_ctx, ib, ai) == 0)) {
 			goto format_error;
 		}
 		break;
 	}
-	case 5U: {  /* map of pairs of data items */
+	case 5U: { /* map of pairs of data items */
 		if (DUK_UNLIKELY(duk__cbor_decode_map(dec_ctx, ib, ai) == 0)) {
 			goto format_error;
 		}
 		break;
 	}
-	case 6U: {  /* semantic tagging */
+	case 6U: { /* semantic tagging */
 		/* Tags are ignored now, re-read initial byte.  A tagged
 		 * value may itself be tagged (an unlimited number of times)
 		 * so keep on peeling away tags.
 		 */
 		duk__cbor_decode_skip_aival_int(dec_ctx, ib);
 		goto reread_initial_byte;
 	}
-	case 7U: {  /* floating point numbers, simple data types, break; other */
+	case 7U: { /* floating point numbers, simple data types, break; other */
 		switch (ai) {
 		case 0x14U: {
 			duk_push_false(dec_ctx->thr);
 			break;
 		}
 		case 0x15U: {
 			duk_push_true(dec_ctx->thr);
@@ -31631,61 +32559,61 @@
 			duk_push_null(dec_ctx->thr);
 			break;
 		}
 		case 0x17U: {
 			duk_push_undefined(dec_ctx->thr);
 			break;
 		}
-		case 0x18U: {  /* more simple values (1 byte) */
+		case 0x18U: { /* more simple values (1 byte) */
 			/* Simple value encoded in additional byte (none
 			 * are defined so far).  RFC 7049 states that the
 			 * follow-up byte must be 32-255 to minimize
 			 * confusion.  So, a non-shortest encoding like
 			 * f815 (= true, shortest encoding f5) must be
 			 * rejected.  cbor.me tester rejects f815, but
 			 * e.g. Python CBOR binding decodes it as true.
 			 */
 			goto format_error;
 		}
-		case 0x19U: {  /* half-float (2 bytes) */
+		case 0x19U: { /* half-float (2 bytes) */
 			duk_double_t d;
 			d = duk__cbor_decode_half_float(dec_ctx);
 			duk_push_number(dec_ctx->thr, d);
 			break;
 		}
-		case 0x1aU: {  /* float (4 bytes) */
+		case 0x1aU: { /* float (4 bytes) */
 			duk_double_t d;
 			d = duk__cbor_decode_float(dec_ctx);
 			duk_push_number(dec_ctx->thr, d);
 			break;
 		}
-		case 0x1bU: {  /* double (8 bytes) */
+		case 0x1bU: { /* double (8 bytes) */
 			duk_double_t d;
 			d = duk__cbor_decode_double(dec_ctx);
 			duk_push_number(dec_ctx->thr, d);
 			break;
 		}
-		case 0xffU:  /* unexpected break */
+		case 0xffU: /* unexpected break */
 		default: {
 			goto format_error;
 		}
-		}  /* end switch */
+		} /* end switch */
 		break;
 	}
 	default: {
-		goto format_error;  /* will never actually occur */
+		goto format_error; /* will never actually occur */
 	}
-	}  /* end switch */
+	} /* end switch */
 
 	return;
 
- format_error:
+format_error:
 	duk__cbor_decode_error(dec_ctx);
 }
-#endif  /* DUK_CBOR_DECODE_FASTPATH */
+#endif /* DUK_CBOR_DECODE_FASTPATH */
 
 DUK_LOCAL void duk__cbor_encode(duk_hthread *thr, duk_idx_t idx, duk_uint_t encode_flags) {
 	duk_cbor_encode_context enc_ctx;
 	duk_uint8_t *buf;
 
 	DUK_UNREF(encode_flags);
 
@@ -31737,29 +32665,29 @@
 	if (dec_ctx.off != dec_ctx.len) {
 		(void) duk_type_error(thr, "trailing garbage");
 	}
 
 	duk_replace(thr, idx);
 }
 
-#else  /* DUK_USE_CBOR_SUPPORT */
+#else /* DUK_USE_CBOR_SUPPORT */
 
 DUK_LOCAL void duk__cbor_encode(duk_hthread *thr, duk_idx_t idx, duk_uint_t encode_flags) {
 	DUK_UNREF(idx);
 	DUK_UNREF(encode_flags);
 	DUK_ERROR_UNSUPPORTED(thr);
 }
 
 DUK_LOCAL void duk__cbor_decode(duk_hthread *thr, duk_idx_t idx, duk_uint_t decode_flags) {
 	DUK_UNREF(idx);
 	DUK_UNREF(decode_flags);
 	DUK_ERROR_UNSUPPORTED(thr);
 }
 
-#endif  /* DUK_USE_CBOR_SUPPORT */
+#endif /* DUK_USE_CBOR_SUPPORT */
 
 /*
  *  Public APIs
  */
 
 DUK_EXTERNAL void duk_cbor_encode(duk_hthread *thr, duk_idx_t idx, duk_uint_t encode_flags) {
 	DUK_ASSERT_API_ENTRY(thr);
@@ -31787,25 +32715,25 @@
 
 DUK_INTERNAL duk_ret_t duk_bi_cbor_decode(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 1);
 
 	duk__cbor_decode(thr, -1, 0 /*flags*/);
 	return 1;
 }
-#else  /* DUK_USE_CBOR_SUPPORT */
+#else /* DUK_USE_CBOR_SUPPORT */
 DUK_INTERNAL duk_ret_t duk_bi_cbor_encode(duk_hthread *thr) {
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 DUK_INTERNAL duk_ret_t duk_bi_cbor_decode(duk_hthread *thr) {
 	DUK_ERROR_UNSUPPORTED(thr);
 	DUK_WO_NORETURN(return 0;);
 }
-#endif  /* DUK_USE_CBOR_SUPPORT */
-#endif  /* DUK_USE_CBOR_BUILTIN */
+#endif /* DUK_USE_CBOR_SUPPORT */
+#endif /* DUK_USE_CBOR_BUILTIN */
 
 /* automatic undefs */
 #undef DUK__CBOR_AI
 #line 1 "duk_bi_date.c"
 /*
  *  Date built-ins
  *
@@ -31833,59 +32761,88 @@
 DUK_LOCAL_DECL duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags);
 
 /*
  *  Other file level defines
  */
 
 /* Debug macro to print all parts and dparts (used manually because of debug level). */
-#define  DUK__DPRINT_PARTS_AND_DPARTS(parts,dparts)  do { \
+#define DUK__DPRINT_PARTS_AND_DPARTS(parts, dparts) \
+	do { \
 		DUK_D(DUK_DPRINT("parts: %ld %ld %ld %ld %ld %ld %ld %ld, dparts: %lf %lf %lf %lf %lf %lf %lf %lf", \
-		                 (long) (parts)[0], (long) (parts)[1], \
-		                 (long) (parts)[2], (long) (parts)[3], \
-		                 (long) (parts)[4], (long) (parts)[5], \
-		                 (long) (parts)[6], (long) (parts)[7], \
-		                 (double) (dparts)[0], (double) (dparts)[1], \
-		                 (double) (dparts)[2], (double) (dparts)[3], \
-		                 (double) (dparts)[4], (double) (dparts)[5], \
-		                 (double) (dparts)[6], (double) (dparts)[7])); \
+		                 (long) (parts)[0], \
+		                 (long) (parts)[1], \
+		                 (long) (parts)[2], \
+		                 (long) (parts)[3], \
+		                 (long) (parts)[4], \
+		                 (long) (parts)[5], \
+		                 (long) (parts)[6], \
+		                 (long) (parts)[7], \
+		                 (double) (dparts)[0], \
+		                 (double) (dparts)[1], \
+		                 (double) (dparts)[2], \
+		                 (double) (dparts)[3], \
+		                 (double) (dparts)[4], \
+		                 (double) (dparts)[5], \
+		                 (double) (dparts)[6], \
+		                 (double) (dparts)[7])); \
 	} while (0)
-#define  DUK__DPRINT_PARTS(parts)  do { \
+#define DUK__DPRINT_PARTS(parts) \
+	do { \
 		DUK_D(DUK_DPRINT("parts: %ld %ld %ld %ld %ld %ld %ld %ld", \
-		                 (long) (parts)[0], (long) (parts)[1], \
-		                 (long) (parts)[2], (long) (parts)[3], \
-		                 (long) (parts)[4], (long) (parts)[5], \
-		                 (long) (parts)[6], (long) (parts)[7])); \
+		                 (long) (parts)[0], \
+		                 (long) (parts)[1], \
+		                 (long) (parts)[2], \
+		                 (long) (parts)[3], \
+		                 (long) (parts)[4], \
+		                 (long) (parts)[5], \
+		                 (long) (parts)[6], \
+		                 (long) (parts)[7])); \
 	} while (0)
-#define  DUK__DPRINT_DPARTS(dparts)  do { \
+#define DUK__DPRINT_DPARTS(dparts) \
+	do { \
 		DUK_D(DUK_DPRINT("dparts: %lf %lf %lf %lf %lf %lf %lf %lf", \
-		                 (double) (dparts)[0], (double) (dparts)[1], \
-		                 (double) (dparts)[2], (double) (dparts)[3], \
-		                 (double) (dparts)[4], (double) (dparts)[5], \
-		                 (double) (dparts)[6], (double) (dparts)[7])); \
+		                 (double) (dparts)[0], \
+		                 (double) (dparts)[1], \
+		                 (double) (dparts)[2], \
+		                 (double) (dparts)[3], \
+		                 (double) (dparts)[4], \
+		                 (double) (dparts)[5], \
+		                 (double) (dparts)[6], \
+		                 (double) (dparts)[7])); \
 	} while (0)
 
 /* Equivalent year for DST calculations outside [1970,2038[ range, see
  * E5 Section 15.9.1.8.  Equivalent year has the same leap-year-ness and
  * starts with the same weekday on Jan 1.
  * https://bugzilla.mozilla.org/show_bug.cgi?id=351066
  */
-#define DUK__YEAR(x) ((duk_uint8_t) ((x) - 1970))
+#define DUK__YEAR(x) ((duk_uint8_t) ((x) -1970))
 DUK_LOCAL duk_uint8_t duk__date_equivyear[14] = {
 #if 1
 	/* This is based on V8 EquivalentYear() algorithm (see util/genequivyear.py):
 	 * http://code.google.com/p/v8/source/browse/trunk/src/date.h#146
 	 */
 
 	/* non-leap year: sunday, monday, ... */
-	DUK__YEAR(2023), DUK__YEAR(2035), DUK__YEAR(2019), DUK__YEAR(2031),
-	DUK__YEAR(2015), DUK__YEAR(2027), DUK__YEAR(2011),
+	DUK__YEAR(2023),
+	DUK__YEAR(2035),
+	DUK__YEAR(2019),
+	DUK__YEAR(2031),
+	DUK__YEAR(2015),
+	DUK__YEAR(2027),
+	DUK__YEAR(2011),
 
 	/* leap year: sunday, monday, ... */
-	DUK__YEAR(2012), DUK__YEAR(2024), DUK__YEAR(2008), DUK__YEAR(2020),
-	DUK__YEAR(2032), DUK__YEAR(2016), DUK__YEAR(2028)
+	DUK__YEAR(2012),
+	DUK__YEAR(2024),
+	DUK__YEAR(2008),
+	DUK__YEAR(2020),
+	DUK__YEAR(2032),
+	DUK__YEAR(2016),
+	DUK__YEAR(2028)
 #endif
 
 #if 0
 	/* This is based on Rhino EquivalentYear() algorithm:
 	 * https://github.com/mozilla/rhino/blob/f99cc11d616f0cdda2c42bde72b3484df6182947/src/org/mozilla/javascript/NativeDate.java
 	 */
 
@@ -31900,95 +32857,110 @@
 };
 
 /*
  *  ISO 8601 subset parser.
  */
 
 /* Parser part count. */
-#define DUK__NUM_ISO8601_PARSER_PARTS  9
+#define DUK__NUM_ISO8601_PARSER_PARTS 9
 
 /* Parser part indices. */
-#define DUK__PI_YEAR         0
-#define DUK__PI_MONTH        1
-#define DUK__PI_DAY          2
-#define DUK__PI_HOUR         3
-#define DUK__PI_MINUTE       4
-#define DUK__PI_SECOND       5
-#define DUK__PI_MILLISECOND  6
-#define DUK__PI_TZHOUR       7
-#define DUK__PI_TZMINUTE     8
+#define DUK__PI_YEAR        0
+#define DUK__PI_MONTH       1
+#define DUK__PI_DAY         2
+#define DUK__PI_HOUR        3
+#define DUK__PI_MINUTE      4
+#define DUK__PI_SECOND      5
+#define DUK__PI_MILLISECOND 6
+#define DUK__PI_TZHOUR      7
+#define DUK__PI_TZMINUTE    8
 
 /* Parser part masks. */
-#define DUK__PM_YEAR         (1 << DUK__PI_YEAR)
-#define DUK__PM_MONTH        (1 << DUK__PI_MONTH)
-#define DUK__PM_DAY          (1 << DUK__PI_DAY)
-#define DUK__PM_HOUR         (1 << DUK__PI_HOUR)
-#define DUK__PM_MINUTE       (1 << DUK__PI_MINUTE)
-#define DUK__PM_SECOND       (1 << DUK__PI_SECOND)
-#define DUK__PM_MILLISECOND  (1 << DUK__PI_MILLISECOND)
-#define DUK__PM_TZHOUR       (1 << DUK__PI_TZHOUR)
-#define DUK__PM_TZMINUTE     (1 << DUK__PI_TZMINUTE)
+#define DUK__PM_YEAR        (1 << DUK__PI_YEAR)
+#define DUK__PM_MONTH       (1 << DUK__PI_MONTH)
+#define DUK__PM_DAY         (1 << DUK__PI_DAY)
+#define DUK__PM_HOUR        (1 << DUK__PI_HOUR)
+#define DUK__PM_MINUTE      (1 << DUK__PI_MINUTE)
+#define DUK__PM_SECOND      (1 << DUK__PI_SECOND)
+#define DUK__PM_MILLISECOND (1 << DUK__PI_MILLISECOND)
+#define DUK__PM_TZHOUR      (1 << DUK__PI_TZHOUR)
+#define DUK__PM_TZMINUTE    (1 << DUK__PI_TZMINUTE)
 
 /* Parser separator indices. */
-#define DUK__SI_PLUS         0
-#define DUK__SI_MINUS        1
-#define DUK__SI_T            2
-#define DUK__SI_SPACE        3
-#define DUK__SI_COLON        4
-#define DUK__SI_PERIOD       5
-#define DUK__SI_Z            6
-#define DUK__SI_NUL          7
+#define DUK__SI_PLUS   0
+#define DUK__SI_MINUS  1
+#define DUK__SI_T      2
+#define DUK__SI_SPACE  3
+#define DUK__SI_COLON  4
+#define DUK__SI_PERIOD 5
+#define DUK__SI_Z      6
+#define DUK__SI_NUL    7
 
 /* Parser separator masks. */
-#define DUK__SM_PLUS         (1 << DUK__SI_PLUS)
-#define DUK__SM_MINUS        (1 << DUK__SI_MINUS)
-#define DUK__SM_T            (1 << DUK__SI_T)
-#define DUK__SM_SPACE        (1 << DUK__SI_SPACE)
-#define DUK__SM_COLON        (1 << DUK__SI_COLON)
-#define DUK__SM_PERIOD       (1 << DUK__SI_PERIOD)
-#define DUK__SM_Z            (1 << DUK__SI_Z)
-#define DUK__SM_NUL          (1 << DUK__SI_NUL)
+#define DUK__SM_PLUS   (1 << DUK__SI_PLUS)
+#define DUK__SM_MINUS  (1 << DUK__SI_MINUS)
+#define DUK__SM_T      (1 << DUK__SI_T)
+#define DUK__SM_SPACE  (1 << DUK__SI_SPACE)
+#define DUK__SM_COLON  (1 << DUK__SI_COLON)
+#define DUK__SM_PERIOD (1 << DUK__SI_PERIOD)
+#define DUK__SM_Z      (1 << DUK__SI_Z)
+#define DUK__SM_NUL    (1 << DUK__SI_NUL)
 
 /* Rule control flags. */
-#define DUK__CF_NEG          (1 << 0)  /* continue matching, set neg_tzoffset flag */
-#define DUK__CF_ACCEPT       (1 << 1)  /* accept string */
-#define DUK__CF_ACCEPT_NUL   (1 << 2)  /* accept string if next char is NUL (otherwise reject) */
-
-#define DUK__PACK_RULE(partmask,sepmask,nextpart,flags)  \
-	((duk_uint32_t) (partmask) + \
-	 (((duk_uint32_t) (sepmask)) << 9) + \
-	 (((duk_uint32_t) (nextpart)) << 17) + \
+#define DUK__CF_NEG        (1 << 0) /* continue matching, set neg_tzoffset flag */
+#define DUK__CF_ACCEPT     (1 << 1) /* accept string */
+#define DUK__CF_ACCEPT_NUL (1 << 2) /* accept string if next char is NUL (otherwise reject) */
+
+#define DUK__PACK_RULE(partmask, sepmask, nextpart, flags) \
+	((duk_uint32_t) (partmask) + (((duk_uint32_t) (sepmask)) << 9) + (((duk_uint32_t) (nextpart)) << 17) + \
 	 (((duk_uint32_t) (flags)) << 21))
 
-#define DUK__UNPACK_RULE(rule,var_nextidx,var_flags)  do { \
+#define DUK__UNPACK_RULE(rule, var_nextidx, var_flags) \
+	do { \
 		(var_nextidx) = (duk_small_uint_t) (((rule) >> 17) & 0x0f); \
 		(var_flags) = (duk_small_uint_t) ((rule) >> 21); \
 	} while (0)
 
-#define DUK__RULE_MASK_PART_SEP  0x1ffffUL
+#define DUK__RULE_MASK_PART_SEP 0x1ffffUL
 
 /* Matching separator index is used in the control table */
 DUK_LOCAL const duk_uint8_t duk__parse_iso8601_seps[] = {
-	DUK_ASC_PLUS /*0*/, DUK_ASC_MINUS /*1*/, DUK_ASC_UC_T /*2*/, DUK_ASC_SPACE /*3*/,
+	DUK_ASC_PLUS /*0*/,  DUK_ASC_MINUS /*1*/,  DUK_ASC_UC_T /*2*/, DUK_ASC_SPACE /*3*/,
 	DUK_ASC_COLON /*4*/, DUK_ASC_PERIOD /*5*/, DUK_ASC_UC_Z /*6*/, DUK_ASC_NUL /*7*/
 };
 
 /* Rule table: first matching rule is used to determine what to do next. */
 DUK_LOCAL const duk_uint32_t duk__parse_iso8601_control[] = {
 	DUK__PACK_RULE(DUK__PM_YEAR, DUK__SM_MINUS, DUK__PI_MONTH, 0),
 	DUK__PACK_RULE(DUK__PM_MONTH, DUK__SM_MINUS, DUK__PI_DAY, 0),
 	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY, DUK__SM_T | DUK__SM_SPACE, DUK__PI_HOUR, 0),
 	DUK__PACK_RULE(DUK__PM_HOUR, DUK__SM_COLON, DUK__PI_MINUTE, 0),
 	DUK__PACK_RULE(DUK__PM_MINUTE, DUK__SM_COLON, DUK__PI_SECOND, 0),
 	DUK__PACK_RULE(DUK__PM_SECOND, DUK__SM_PERIOD, DUK__PI_MILLISECOND, 0),
 	DUK__PACK_RULE(DUK__PM_TZHOUR, DUK__SM_COLON, DUK__PI_TZMINUTE, 0),
-	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND | DUK__PM_MILLISECOND, DUK__SM_PLUS, DUK__PI_TZHOUR, 0),
-	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND | DUK__PM_MILLISECOND, DUK__SM_MINUS, DUK__PI_TZHOUR, DUK__CF_NEG),
-	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND | DUK__PM_MILLISECOND, DUK__SM_Z, 0, DUK__CF_ACCEPT_NUL),
-	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND | DUK__PM_MILLISECOND | DUK__PM_TZHOUR /*Note2*/ | DUK__PM_TZMINUTE, DUK__SM_NUL, 0, DUK__CF_ACCEPT)
+	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND |
+	                   DUK__PM_MILLISECOND,
+	               DUK__SM_PLUS,
+	               DUK__PI_TZHOUR,
+	               0),
+	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND |
+	                   DUK__PM_MILLISECOND,
+	               DUK__SM_MINUS,
+	               DUK__PI_TZHOUR,
+	               DUK__CF_NEG),
+	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND |
+	                   DUK__PM_MILLISECOND,
+	               DUK__SM_Z,
+	               0,
+	               DUK__CF_ACCEPT_NUL),
+	DUK__PACK_RULE(DUK__PM_YEAR | DUK__PM_MONTH | DUK__PM_DAY | DUK__PM_HOUR /*Note1*/ | DUK__PM_MINUTE | DUK__PM_SECOND |
+	                   DUK__PM_MILLISECOND | DUK__PM_TZHOUR /*Note2*/ | DUK__PM_TZMINUTE,
+	               DUK__SM_NUL,
+	               0,
+	               DUK__CF_ACCEPT)
 
 	/* Note1: the specification doesn't require matching a time form with
 	 *        just hours ("HH"), but we accept it here, e.g. "2012-01-02T12Z".
 	 *
 	 * Note2: the specification doesn't require matching a timezone offset
 	 *        with just hours ("HH"), but accept it here, e.g. "2012-01-02T03:04:05+02"
 	 */
@@ -32005,15 +32977,15 @@
 	duk_bool_t neg_year = 0;
 	duk_bool_t neg_tzoffset = 0;
 	duk_uint_fast8_t ch;
 	duk_small_uint_t i;
 
 	/* During parsing, month and day are one-based; set defaults here. */
 	duk_memzero(parts, sizeof(parts));
-	DUK_ASSERT(parts[DUK_DATE_IDX_YEAR] == 0);  /* don't care value, year is mandatory */
+	DUK_ASSERT(parts[DUK_DATE_IDX_YEAR] == 0); /* don't care value, year is mandatory */
 	parts[DUK_DATE_IDX_MONTH] = 1;
 	parts[DUK_DATE_IDX_DAY] = 1;
 
 	/* Special handling for year sign. */
 	p = (const duk_uint8_t *) str;
 	ch = p[0];
 	if (ch == DUK_ASC_PLUS) {
@@ -32022,15 +32994,16 @@
 		neg_year = 1;
 		p++;
 	}
 
 	for (;;) {
 		ch = *p++;
 		DUK_DDD(DUK_DDDPRINT("parsing, part_idx=%ld, char=%ld ('%c')",
-		                     (long) part_idx, (long) ch,
+		                     (long) part_idx,
+		                     (long) ch,
 		                     (int) ((ch >= 0x20 && ch <= 0x7e) ? ch : DUK_ASC_QUESTION)));
 
 		if (ch >= DUK_ASC_0 && ch <= DUK_ASC_9) {
 			if (ndigits >= 9) {
 				DUK_DDD(DUK_DDDPRINT("too many digits -> reject"));
 				goto reject;
 			}
@@ -32067,36 +33040,41 @@
 			}
 			if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_seps) / sizeof(duk_uint8_t))) {
 				DUK_DDD(DUK_DDDPRINT("separator character doesn't match -> reject"));
 				goto reject;
 			}
 
 			sep_idx = i;
-			match_val = (1UL << part_idx) + (1UL << (sep_idx + 9));  /* match against rule part/sep bits */
+			match_val = (1UL << part_idx) + (1UL << (sep_idx + 9)); /* match against rule part/sep bits */
 
 			for (i = 0; i < (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t)); i++) {
 				duk_uint_fast32_t rule = duk__parse_iso8601_control[i];
 				duk_small_uint_t nextpart;
 				duk_small_uint_t cflags;
 
 				DUK_DDD(DUK_DDDPRINT("part_idx=%ld, sep_idx=%ld, match_val=0x%08lx, considering rule=0x%08lx",
-				                     (long) part_idx, (long) sep_idx,
-				                     (unsigned long) match_val, (unsigned long) rule));
+				                     (long) part_idx,
+				                     (long) sep_idx,
+				                     (unsigned long) match_val,
+				                     (unsigned long) rule));
 
 				if ((rule & match_val) != match_val) {
 					continue;
 				}
 
 				DUK__UNPACK_RULE(rule, nextpart, cflags);
 
 				DUK_DDD(DUK_DDDPRINT("rule match -> part_idx=%ld, sep_idx=%ld, match_val=0x%08lx, "
 				                     "rule=0x%08lx -> nextpart=%ld, cflags=0x%02lx",
-				                     (long) part_idx, (long) sep_idx,
-				                     (unsigned long) match_val, (unsigned long) rule,
-				                     (long) nextpart, (unsigned long) cflags));
+				                     (long) part_idx,
+				                     (long) sep_idx,
+				                     (unsigned long) match_val,
+				                     (unsigned long) rule,
+				                     (long) nextpart,
+				                     (unsigned long) cflags));
 
 				if (cflags & DUK__CF_NEG) {
 					neg_tzoffset = 1;
 				}
 
 				if (cflags & DUK__CF_ACCEPT) {
 					goto accept;
@@ -32108,54 +33086,54 @@
 						goto accept;
 					}
 					goto reject;
 				}
 
 				part_idx = nextpart;
 				break;
-			}  /* rule match */
+			} /* rule match */
 
 			if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t))) {
 				DUK_DDD(DUK_DDDPRINT("no rule matches -> reject"));
 				goto reject;
 			}
 
 			if (ch == 0) {
 				/* This shouldn't be necessary, but check just in case
 				 * to avoid any chance of overruns.
 				 */
 				DUK_DDD(DUK_DDDPRINT("NUL after rule matching (should not happen) -> reject"));
 				goto reject;
 			}
-		}  /* if-digit-else-ctrl */
-	}  /* char loop */
+		} /* if-digit-else-ctrl */
+	} /* char loop */
 
 	/* We should never exit the loop above. */
 	DUK_UNREACHABLE();
 
- reject:
+reject:
 	DUK_DDD(DUK_DDDPRINT("reject"));
 	return 0;
 
- accept:
+accept:
 	DUK_DDD(DUK_DDDPRINT("accept"));
 
 	/* Apply timezone offset to get the main parts in UTC */
 	if (neg_year) {
 		parts[DUK__PI_YEAR] = -parts[DUK__PI_YEAR];
 	}
 	if (neg_tzoffset) {
 		parts[DUK__PI_HOUR] += parts[DUK__PI_TZHOUR];
 		parts[DUK__PI_MINUTE] += parts[DUK__PI_TZMINUTE];
 	} else {
 		parts[DUK__PI_HOUR] -= parts[DUK__PI_TZHOUR];
 		parts[DUK__PI_MINUTE] -= parts[DUK__PI_TZMINUTE];
 	}
-	parts[DUK__PI_MONTH] -= 1;  /* zero-based month */
-	parts[DUK__PI_DAY] -= 1;  /* zero-based day */
+	parts[DUK__PI_MONTH] -= 1; /* zero-based month */
+	parts[DUK__PI_DAY] -= 1; /* zero-based day */
 
 	/* Use double parts, they tolerate unnormalized time.
 	 *
 	 * Note: DUK_DATE_IDX_WEEKDAY is initialized with a bogus value (DUK__PI_TZHOUR)
 	 * on purpose.  It won't be actually used by duk_bi_date_get_timeval_from_dparts(),
 	 * but will make the value initialized just in case, and avoid any
 	 * potential for Valgrind issues.
@@ -32224,32 +33202,30 @@
  *
  *  Some helpers are used for getters and can operate on normalized values
  *  which can be represented with 32-bit signed integers.  Other helpers are
  *  needed by setters and operate on un-normalized double values, must watch
  *  out for non-finite numbers etc.
  */
 
-DUK_LOCAL duk_uint8_t duk__days_in_month[12] = {
-	(duk_uint8_t) 31, (duk_uint8_t) 28, (duk_uint8_t) 31, (duk_uint8_t) 30,
-	(duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 31,
-	(duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31
-};
+DUK_LOCAL duk_uint8_t duk__days_in_month[12] = { (duk_uint8_t) 31, (duk_uint8_t) 28, (duk_uint8_t) 31, (duk_uint8_t) 30,
+	                                         (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 31,
+	                                         (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31 };
 
 /* Maximum iteration count for computing UTC-to-local time offset when
  * creating an ECMAScript time value from local parts.
  */
-#define DUK__LOCAL_TZOFFSET_MAXITER   4
+#define DUK__LOCAL_TZOFFSET_MAXITER 4
 
 /* Because 'day since epoch' can be negative and is used to compute weekday
  * using a modulo operation, add this multiple of 7 to avoid negative values
  * when year is below 1970 epoch.  ECMAScript time values are restricted to
  * +/- 100 million days from epoch, so this adder fits nicely into 32 bits.
  * Round to a multiple of 7 (= floor(100000000 / 7) * 7) and add margin.
  */
-#define DUK__WEEKDAY_MOD_ADDER  (20000000 * 7)  /* 0x08583b00 */
+#define DUK__WEEKDAY_MOD_ADDER (20000000 * 7) /* 0x08583b00 */
 
 DUK_INTERNAL duk_bool_t duk_bi_date_is_leap_year(duk_int_t year) {
 	if ((year % 4) != 0) {
 		return 0;
 	}
 	if ((year % 100) != 0) {
 		return 1;
@@ -32302,18 +33278,16 @@
 }
 
 /* Compute day number of the first day of a given year. */
 DUK_LOCAL duk_int_t duk__day_from_year(duk_int_t year) {
 	/* Note: in integer arithmetic, (x / 4) is same as floor(x / 4) for non-negative
 	 * values, but is incorrect for negative ones.
 	 */
-	return 365 * (year - 1970)
-	       + duk__div_floor(year - 1969, 4)
-	       - duk__div_floor(year - 1901, 100)
-	       + duk__div_floor(year - 1601, 400);
+	return 365 * (year - 1970) + duk__div_floor(year - 1969, 4) - duk__div_floor(year - 1901, 100) +
+	       duk__div_floor(year - 1601, 400);
 }
 
 /* Given a day number, determine year and day-within-year. */
 DUK_LOCAL duk_int_t duk__year_from_day(duk_int_t day, duk_small_int_t *out_day_within_year) {
 	duk_int_t year;
 	duk_int_t diff_days;
 
@@ -32327,27 +33301,26 @@
 		year = 1970 + day / 366;
 	}
 
 	for (;;) {
 		diff_days = duk__day_from_year(year) - day;
 		DUK_DDD(DUK_DDDPRINT("year=%ld day=%ld, diff_days=%ld", (long) year, (long) day, (long) diff_days));
 		if (diff_days <= 0) {
-			DUK_ASSERT(-diff_days < 366);  /* fits into duk_small_int_t */
+			DUK_ASSERT(-diff_days < 366); /* fits into duk_small_int_t */
 			*out_day_within_year = -diff_days;
-			DUK_DDD(DUK_DDDPRINT("--> year=%ld, day-within-year=%ld",
-			                     (long) year, (long) *out_day_within_year));
+			DUK_DDD(DUK_DDDPRINT("--> year=%ld, day-within-year=%ld", (long) year, (long) *out_day_within_year));
 			DUK_ASSERT(*out_day_within_year >= 0);
 			DUK_ASSERT(*out_day_within_year < (duk_bi_date_is_leap_year(year) ? 366 : 365));
 			return year;
 		}
 
 		/* Note: this is very tricky; we must never 'overshoot' the
 		 * correction downwards.
 		 */
-		year -= 1 + (diff_days - 1) / 366;  /* conservative */
+		year -= 1 + (diff_days - 1) / 366; /* conservative */
 	}
 }
 
 /* Given a (year, month, day-within-month) triple, compute day number.
  * The input triple is un-normalized and may contain non-finite values.
  */
 DUK_LOCAL duk_double_t duk__make_day(duk_double_t year, duk_double_t month, duk_double_t day) {
@@ -32412,28 +33385,28 @@
  * come from duk_time_to_components() API call) which are truncated.  Possible
  * local time adjustment has already been applied when reading the time value.
  */
 DUK_INTERNAL void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags) {
 	duk_double_t d1, d2;
 	duk_int_t t1, t2;
 	duk_int_t day_since_epoch;
-	duk_int_t year;  /* does not fit into 16 bits */
+	duk_int_t year; /* does not fit into 16 bits */
 	duk_small_int_t day_in_year;
 	duk_small_int_t month;
 	duk_small_int_t day;
 	duk_small_int_t dim;
 	duk_int_t jan1_since_epoch;
 	duk_small_int_t jan1_weekday;
 	duk_int_t equiv_year;
 	duk_small_uint_t i;
 	duk_bool_t is_leap;
 	duk_small_int_t arridx;
 
-	DUK_ASSERT(DUK_ISFINITE(d));    /* caller checks */
-	d = DUK_FLOOR(d);  /* remove fractions if present */
+	DUK_ASSERT(DUK_ISFINITE(d)); /* caller checks */
+	d = DUK_FLOOR(d); /* remove fractions if present */
 	DUK_ASSERT(duk_double_equals(DUK_FLOOR(d), d));
 
 	/* The timevalue must be in valid ECMAScript range, but since a local
 	 * time offset can be applied, we need to allow a +/- 24h leeway to
 	 * the value.  In other words, although the UTC time is within the
 	 * ECMAScript range, the local part values can be just outside of it.
 	 */
@@ -32457,47 +33430,53 @@
 	DUK_ASSERT(duk_double_equals((duk_double_t) t1, d1));
 	DUK_ASSERT(duk_double_equals((duk_double_t) t2, d2));
 
 	/* t1 = milliseconds within day (fits 32 bit)
 	 * t2 = day number from epoch (fits 32 bit, may be negative)
 	 */
 
-	parts[DUK_DATE_IDX_MILLISECOND] = t1 % 1000; t1 /= 1000;
-	parts[DUK_DATE_IDX_SECOND] = t1 % 60; t1 /= 60;
-	parts[DUK_DATE_IDX_MINUTE] = t1 % 60; t1 /= 60;
+	parts[DUK_DATE_IDX_MILLISECOND] = t1 % 1000;
+	t1 /= 1000;
+	parts[DUK_DATE_IDX_SECOND] = t1 % 60;
+	t1 /= 60;
+	parts[DUK_DATE_IDX_MINUTE] = t1 % 60;
+	t1 /= 60;
 	parts[DUK_DATE_IDX_HOUR] = t1;
 	DUK_ASSERT(parts[DUK_DATE_IDX_MILLISECOND] >= 0 && parts[DUK_DATE_IDX_MILLISECOND] <= 999);
 	DUK_ASSERT(parts[DUK_DATE_IDX_SECOND] >= 0 && parts[DUK_DATE_IDX_SECOND] <= 59);
 	DUK_ASSERT(parts[DUK_DATE_IDX_MINUTE] >= 0 && parts[DUK_DATE_IDX_MINUTE] <= 59);
 	DUK_ASSERT(parts[DUK_DATE_IDX_HOUR] >= 0 && parts[DUK_DATE_IDX_HOUR] <= 23);
 
 	DUK_DDD(DUK_DDDPRINT("d=%lf, d1=%lf, d2=%lf, t1=%ld, t2=%ld, parts: hour=%ld min=%ld sec=%ld msec=%ld",
-	                     (double) d, (double) d1, (double) d2, (long) t1, (long) t2,
+	                     (double) d,
+	                     (double) d1,
+	                     (double) d2,
+	                     (long) t1,
+	                     (long) t2,
 	                     (long) parts[DUK_DATE_IDX_HOUR],
 	                     (long) parts[DUK_DATE_IDX_MINUTE],
 	                     (long) parts[DUK_DATE_IDX_SECOND],
 	                     (long) parts[DUK_DATE_IDX_MILLISECOND]));
 
 	/* This assert depends on the input parts representing time inside
 	 * the ECMAScript range.
 	 */
 	DUK_ASSERT(t2 + DUK__WEEKDAY_MOD_ADDER >= 0);
-	parts[DUK_DATE_IDX_WEEKDAY] = (t2 + 4 + DUK__WEEKDAY_MOD_ADDER) % 7;  /* E5.1 Section 15.9.1.6 */
+	parts[DUK_DATE_IDX_WEEKDAY] = (t2 + 4 + DUK__WEEKDAY_MOD_ADDER) % 7; /* E5.1 Section 15.9.1.6 */
 	DUK_ASSERT(parts[DUK_DATE_IDX_WEEKDAY] >= 0 && parts[DUK_DATE_IDX_WEEKDAY] <= 6);
 
 	year = duk__year_from_day(t2, &day_in_year);
 	day = day_in_year;
 	is_leap = duk_bi_date_is_leap_year(year);
 	for (month = 0; month < 12; month++) {
 		dim = duk__days_in_month[month];
 		if (month == 1 && is_leap) {
 			dim++;
 		}
-		DUK_DDD(DUK_DDDPRINT("month=%ld, dim=%ld, day=%ld",
-		                     (long) month, (long) dim, (long) day));
+		DUK_DDD(DUK_DDDPRINT("month=%ld, dim=%ld, day=%ld", (long) month, (long) dim, (long) day));
 		if (day < dim) {
 			break;
 		}
 		day -= dim;
 	}
 	DUK_DDD(DUK_DDDPRINT("final month=%ld", (long) month));
 	DUK_ASSERT(month >= 0 && month <= 11);
@@ -32514,39 +33493,43 @@
 	 * practical problems with it; an equivalent year is used for it too,
 	 * which breaks some DST computations for 1970 right now, see e.g.
 	 * test-bi-date-tzoffset-brute-fi.js.
 	 */
 	if ((flags & DUK_DATE_FLAG_EQUIVYEAR) && (year < 1971 || year > 2037)) {
 		DUK_ASSERT(is_leap == 0 || is_leap == 1);
 
-		jan1_since_epoch = day_since_epoch - day_in_year;  /* day number for Jan 1 since epoch */
+		jan1_since_epoch = day_since_epoch - day_in_year; /* day number for Jan 1 since epoch */
 		DUK_ASSERT(jan1_since_epoch + DUK__WEEKDAY_MOD_ADDER >= 0);
-		jan1_weekday = (jan1_since_epoch + 4 + DUK__WEEKDAY_MOD_ADDER) % 7;  /* E5.1 Section 15.9.1.6 */
+		jan1_weekday = (jan1_since_epoch + 4 + DUK__WEEKDAY_MOD_ADDER) % 7; /* E5.1 Section 15.9.1.6 */
 		DUK_ASSERT(jan1_weekday >= 0 && jan1_weekday <= 6);
 		arridx = jan1_weekday;
 		if (is_leap) {
 			arridx += 7;
 		}
 		DUK_ASSERT(arridx >= 0 && arridx < (duk_small_int_t) (sizeof(duk__date_equivyear) / sizeof(duk_uint8_t)));
 
 		equiv_year = (duk_int_t) duk__date_equivyear[arridx] + 1970;
 		year = equiv_year;
 		DUK_DDD(DUK_DDDPRINT("equiv year mapping, year=%ld, day_in_year=%ld, day_since_epoch=%ld, "
 		                     "jan1_since_epoch=%ld, jan1_weekday=%ld -> equiv year %ld",
-		                     (long) year, (long) day_in_year, (long) day_since_epoch,
-		                     (long) jan1_since_epoch, (long) jan1_weekday, (long) equiv_year));
+		                     (long) year,
+		                     (long) day_in_year,
+		                     (long) day_since_epoch,
+		                     (long) jan1_since_epoch,
+		                     (long) jan1_weekday,
+		                     (long) equiv_year));
 	}
 
 	parts[DUK_DATE_IDX_YEAR] = year;
 	parts[DUK_DATE_IDX_MONTH] = month;
 	parts[DUK_DATE_IDX_DAY] = day;
 
 	if (flags & DUK_DATE_FLAG_ONEBASED) {
-		parts[DUK_DATE_IDX_MONTH]++;  /* zero-based -> one-based */
-		parts[DUK_DATE_IDX_DAY]++;    /* -""- */
+		parts[DUK_DATE_IDX_MONTH]++; /* zero-based -> one-based */
+		parts[DUK_DATE_IDX_DAY]++; /* -""- */
 	}
 
 	if (dparts != NULL) {
 		for (i = 0; i < DUK_DATE_IDX_NUM_PARTS; i++) {
 			dparts[i] = (duk_double_t) parts[i];
 		}
 	}
@@ -32618,16 +33601,15 @@
 
 	/* MakeDay */
 	tmp_day = duk__make_day(dparts[DUK_DATE_IDX_YEAR], dparts[DUK_DATE_IDX_MONTH], dparts[DUK_DATE_IDX_DAY]);
 
 	/* MakeDate */
 	d = tmp_day * ((duk_double_t) DUK_DATE_MSEC_DAY) + tmp_time;
 
-	DUK_DDD(DUK_DDDPRINT("time=%lf day=%lf --> timeval=%lf",
-	                     (double) tmp_time, (double) tmp_day, (double) d));
+	DUK_DDD(DUK_DDDPRINT("time=%lf day=%lf --> timeval=%lf", (double) tmp_time, (double) tmp_day, (double) d));
 
 	/* Optional UTC conversion. */
 	if (flags & DUK_DATE_FLAG_LOCALTIME) {
 		/* DUK_USE_DATE_GET_LOCAL_TZOFFSET() needs to be called with a
 		 * time value computed from UTC parts.  At this point we only
 		 * have 'd' which is a time value computed from local parts, so
 		 * it is off by the UTC-to-local time offset which we don't know
@@ -32649,33 +33631,43 @@
 		d -= tzoff * 1000L;
 		DUK_UNREF(tzoffprev1);
 		DUK_UNREF(tzoffprev2);
 #endif
 
 		/* Iteration solution */
 		tzoff = 0;
-		tzoffprev1 = 999999999L;  /* invalid value which never matches */
+		tzoffprev1 = 999999999L; /* invalid value which never matches */
 		for (i = 0; i < DUK__LOCAL_TZOFFSET_MAXITER; i++) {
 			tzoffprev2 = tzoffprev1;
 			tzoffprev1 = tzoff;
 			tzoff = DUK_USE_DATE_GET_LOCAL_TZOFFSET(d - tzoff * 1000L);
 			DUK_DDD(DUK_DDDPRINT("tzoffset iteration, i=%d, tzoff=%ld, tzoffprev1=%ld tzoffprev2=%ld",
-			                     (int) i, (long) tzoff, (long) tzoffprev1, (long) tzoffprev2));
+			                     (int) i,
+			                     (long) tzoff,
+			                     (long) tzoffprev1,
+			                     (long) tzoffprev2));
 			if (tzoff == tzoffprev1) {
 				DUK_DDD(DUK_DDDPRINT("tzoffset iteration finished, i=%d, tzoff=%ld, tzoffprev1=%ld, tzoffprev2=%ld",
-				                     (int) i, (long) tzoff, (long) tzoffprev1, (long) tzoffprev2));
+				                     (int) i,
+				                     (long) tzoff,
+				                     (long) tzoffprev1,
+				                     (long) tzoffprev2));
 				break;
 			} else if (tzoff == tzoffprev2) {
 				/* Two value cycle, see e.g. test-bi-date-tzoffset-basic-fi.js.
 				 * In these cases, favor a higher tzoffset to get a consistent
 				 * result which is independent of iteration count.  Not sure if
 				 * this is a generically correct solution.
 				 */
-				DUK_DDD(DUK_DDDPRINT("tzoffset iteration two-value cycle, i=%d, tzoff=%ld, tzoffprev1=%ld, tzoffprev2=%ld",
-				                     (int) i, (long) tzoff, (long) tzoffprev1, (long) tzoffprev2));
+				DUK_DDD(DUK_DDDPRINT(
+				    "tzoffset iteration two-value cycle, i=%d, tzoff=%ld, tzoffprev1=%ld, tzoffprev2=%ld",
+				    (int) i,
+				    (long) tzoff,
+				    (long) tzoffprev1,
+				    (long) tzoffprev2));
 				if (tzoffprev1 > tzoff) {
 					tzoff = tzoffprev1;
 				}
 				break;
 			}
 		}
 		DUK_DDD(DUK_DDDPRINT("tzoffset iteration, tzoff=%ld", (long) tzoff));
@@ -32698,15 +33690,15 @@
  */
 DUK_LOCAL duk_double_t duk__push_this_get_timeval_tzoffset(duk_hthread *thr, duk_small_uint_t flags, duk_int_t *out_tzoffset) {
 	duk_hobject *h;
 	duk_double_t d;
 	duk_int_t tzoffset = 0;
 
 	duk_push_this(thr);
-	h = duk_get_hobject(thr, -1);  /* XXX: getter with class check, useful in built-ins */
+	h = duk_get_hobject(thr, -1); /* XXX: getter with class check, useful in built-ins */
 	if (h == NULL || DUK_HOBJECT_GET_CLASS_NUMBER(h) != DUK_HOBJECT_CLASS_DATE) {
 		DUK_ERROR_TYPE(thr, "expected Date");
 		DUK_WO_NORETURN(return 0.0;);
 	}
 
 	duk_xget_owndataprop_stridx_short(thr, -1, DUK_STRIDX_INT_VALUE);
 	d = duk_to_number_m1(thr);
@@ -32724,15 +33716,15 @@
 	/* if no NaN handling flag, may still be NaN here, but not Inf */
 	DUK_ASSERT(!DUK_ISINF(d));
 
 	if (flags & DUK_DATE_FLAG_LOCALTIME) {
 		/* Note: DST adjustment is determined using UTC time.
 		 * If 'd' is NaN, tzoffset will be 0.
 		 */
-		tzoffset = DUK_USE_DATE_GET_LOCAL_TZOFFSET(d);  /* seconds */
+		tzoffset = DUK_USE_DATE_GET_LOCAL_TZOFFSET(d); /* seconds */
 		d += tzoffset * 1000L;
 	}
 	if (out_tzoffset) {
 		*out_tzoffset = tzoffset;
 	}
 
 	/* [ ... this ] */
@@ -32749,43 +33741,44 @@
  */
 DUK_LOCAL duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags) {
 	duk_double_t d;
 
 	/* [ ... this ] */
 
 	d = duk_bi_date_get_timeval_from_dparts(dparts, flags);
-	duk_push_number(thr, d);  /* -> [ ... this timeval_new ] */
-	duk_dup_top(thr);         /* -> [ ... this timeval_new timeval_new ] */
+	duk_push_number(thr, d); /* -> [ ... this timeval_new ] */
+	duk_dup_top(thr); /* -> [ ... this timeval_new timeval_new ] */
 
 	/* Must force write because e.g. .setYear() must work even when
 	 * the Date instance is frozen.
 	 */
 	duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_W);
 
 	/* Stack top: new time value, return 1 to allow tail calls. */
 	return 1;
 }
 
 /* 'out_buf' must be at least DUK_BI_DATE_ISO8601_BUFSIZE long. */
 DUK_LOCAL void duk__format_parts_iso8601(duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags, duk_uint8_t *out_buf) {
-	char yearstr[8];   /* "-123456\0" */
-	char tzstr[8];     /* "+11:22\0" */
+	char yearstr[8]; /* "-123456\0" */
+	char tzstr[8]; /* "+11:22\0" */
 	char sep = (flags & DUK_DATE_FLAG_SEP_T) ? DUK_ASC_UC_T : DUK_ASC_SPACE;
 
 	DUK_ASSERT(parts[DUK_DATE_IDX_MONTH] >= 1 && parts[DUK_DATE_IDX_MONTH] <= 12);
 	DUK_ASSERT(parts[DUK_DATE_IDX_DAY] >= 1 && parts[DUK_DATE_IDX_DAY] <= 31);
 	DUK_ASSERT(parts[DUK_DATE_IDX_YEAR] >= -999999 && parts[DUK_DATE_IDX_YEAR] <= 999999);
 
 	/* Note: %06d for positive value, %07d for negative value to include
 	 * sign and 6 digits.
 	 */
 	DUK_SNPRINTF(yearstr,
 	             sizeof(yearstr),
-	             (parts[DUK_DATE_IDX_YEAR] >= 0 && parts[DUK_DATE_IDX_YEAR] <= 9999) ? "%04ld" :
-	                    ((parts[DUK_DATE_IDX_YEAR] >= 0) ? "+%06ld" : "%07ld"),
+	             (parts[DUK_DATE_IDX_YEAR] >= 0 && parts[DUK_DATE_IDX_YEAR] <= 9999) ?
+                         "%04ld" :
+                         ((parts[DUK_DATE_IDX_YEAR] >= 0) ? "+%06ld" : "%07ld"),
 	             (long) parts[DUK_DATE_IDX_YEAR]);
 	yearstr[sizeof(yearstr) - 1] = (char) 0;
 
 	if (flags & DUK_DATE_FLAG_LOCALTIME) {
 		/* tzoffset seconds are dropped; 16 bits suffice for
 		 * time offset in minutes
 		 */
@@ -32798,56 +33791,70 @@
 		} else {
 			tmp = -tzoffset;
 			fmt = "-%02d:%02d";
 		}
 		tmp = tmp / 60;
 		arg_hours = tmp / 60;
 		arg_minutes = tmp % 60;
-		DUK_ASSERT(arg_hours <= 24);  /* Even less is actually guaranteed for a valid tzoffset. */
-		arg_hours = arg_hours & 0x3f;  /* For [0,24] this is a no-op, but fixes GCC 7 warning, see https://github.com/svaarala/duktape/issues/1602. */
+		DUK_ASSERT(arg_hours <= 24); /* Even less is actually guaranteed for a valid tzoffset. */
+		arg_hours = arg_hours & 0x3f; /* For [0,24] this is a no-op, but fixes GCC 7 warning, see
+		                                 https://github.com/svaarala/duktape/issues/1602. */
 
 		DUK_SNPRINTF(tzstr, sizeof(tzstr), fmt, (int) arg_hours, (int) arg_minutes);
 		tzstr[sizeof(tzstr) - 1] = (char) 0;
 	} else {
 		tzstr[0] = DUK_ASC_UC_Z;
 		tzstr[1] = (char) 0;
 	}
 
 	/* Unlike year, the other parts fit into 16 bits so %d format
 	 * is portable.
 	 */
 	if ((flags & DUK_DATE_FLAG_TOSTRING_DATE) && (flags & DUK_DATE_FLAG_TOSTRING_TIME)) {
-		DUK_SPRINTF((char *) out_buf, "%s-%02d-%02d%c%02d:%02d:%02d.%03d%s",
-		            (const char *) yearstr, (int) parts[DUK_DATE_IDX_MONTH], (int) parts[DUK_DATE_IDX_DAY], (int) sep,
-		            (int) parts[DUK_DATE_IDX_HOUR], (int) parts[DUK_DATE_IDX_MINUTE],
-		            (int) parts[DUK_DATE_IDX_SECOND], (int) parts[DUK_DATE_IDX_MILLISECOND], (const char *) tzstr);
+		DUK_SPRINTF((char *) out_buf,
+		            "%s-%02d-%02d%c%02d:%02d:%02d.%03d%s",
+		            (const char *) yearstr,
+		            (int) parts[DUK_DATE_IDX_MONTH],
+		            (int) parts[DUK_DATE_IDX_DAY],
+		            (int) sep,
+		            (int) parts[DUK_DATE_IDX_HOUR],
+		            (int) parts[DUK_DATE_IDX_MINUTE],
+		            (int) parts[DUK_DATE_IDX_SECOND],
+		            (int) parts[DUK_DATE_IDX_MILLISECOND],
+		            (const char *) tzstr);
 	} else if (flags & DUK_DATE_FLAG_TOSTRING_DATE) {
-		DUK_SPRINTF((char *) out_buf, "%s-%02d-%02d",
-		            (const char *) yearstr, (int) parts[DUK_DATE_IDX_MONTH], (int) parts[DUK_DATE_IDX_DAY]);
+		DUK_SPRINTF((char *) out_buf,
+		            "%s-%02d-%02d",
+		            (const char *) yearstr,
+		            (int) parts[DUK_DATE_IDX_MONTH],
+		            (int) parts[DUK_DATE_IDX_DAY]);
 	} else {
 		DUK_ASSERT(flags & DUK_DATE_FLAG_TOSTRING_TIME);
-		DUK_SPRINTF((char *) out_buf, "%02d:%02d:%02d.%03d%s",
-		            (int) parts[DUK_DATE_IDX_HOUR], (int) parts[DUK_DATE_IDX_MINUTE],
-		            (int) parts[DUK_DATE_IDX_SECOND], (int) parts[DUK_DATE_IDX_MILLISECOND],
+		DUK_SPRINTF((char *) out_buf,
+		            "%02d:%02d:%02d.%03d%s",
+		            (int) parts[DUK_DATE_IDX_HOUR],
+		            (int) parts[DUK_DATE_IDX_MINUTE],
+		            (int) parts[DUK_DATE_IDX_SECOND],
+		            (int) parts[DUK_DATE_IDX_MILLISECOND],
 		            (const char *) tzstr);
 	}
 }
 
 /* Helper for string conversion calls: check 'this' binding, get the
  * internal time value, and format date and/or time in a few formats.
  * Return value allows tail calls.
  */
 DUK_LOCAL duk_ret_t duk__to_string_helper(duk_hthread *thr, duk_small_uint_t flags) {
 	duk_double_t d;
 	duk_int_t parts[DUK_DATE_IDX_NUM_PARTS];
-	duk_int_t tzoffset;  /* seconds, doesn't fit into 16 bits */
+	duk_int_t tzoffset; /* seconds, doesn't fit into 16 bits */
 	duk_bool_t rc;
 	duk_uint8_t buf[DUK_BI_DATE_ISO8601_BUFSIZE];
 
-	DUK_UNREF(rc);  /* unreferenced with some options */
+	DUK_UNREF(rc); /* unreferenced with some options */
 
 	d = duk__push_this_get_timeval_tzoffset(thr, flags, &tzoffset);
 	if (DUK_ISNAN(d)) {
 		duk_push_hstring_stridx(thr, DUK_STRIDX_INVALID_DATE);
 		return 1;
 	}
 	DUK_ASSERT(DUK_ISFINITE(d));
@@ -32891,27 +33898,27 @@
  * internal time value, split it into parts (either as UTC time or
  * local time), push a specified component as a return value to the
  * value stack and return 1 (caller can then tail call us).
  */
 DUK_LOCAL duk_ret_t duk__get_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_idx) {
 	duk_double_t d;
 	duk_int_t parts[DUK_DATE_IDX_NUM_PARTS];
-	duk_small_uint_t idx_part = (duk_small_uint_t) (flags_and_idx >> DUK_DATE_FLAG_VALUE_SHIFT);  /* unpack args */
+	duk_small_uint_t idx_part = (duk_small_uint_t) (flags_and_idx >> DUK_DATE_FLAG_VALUE_SHIFT); /* unpack args */
 
-	DUK_ASSERT_DISABLE(idx_part >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(idx_part >= 0); /* unsigned */
 	DUK_ASSERT(idx_part < DUK_DATE_IDX_NUM_PARTS);
 
 	d = duk__push_this_get_timeval(thr, flags_and_idx);
 	if (DUK_ISNAN(d)) {
 		duk_push_nan(thr);
 		return 1;
 	}
 	DUK_ASSERT(DUK_ISFINITE(d));
 
-	duk_bi_date_timeval_to_parts(d, parts, NULL, flags_and_idx);  /* no need to mask idx portion */
+	duk_bi_date_timeval_to_parts(d, parts, NULL, flags_and_idx); /* no need to mask idx portion */
 
 	/* Setter APIs detect special year numbers (0...99) and apply a +1900
 	 * only in certain cases.  The legacy getYear() getter applies -1900
 	 * unconditionally.
 	 */
 	duk_push_int(thr, (flags_and_idx & DUK_DATE_FLAG_SUB1900) ? parts[idx_part] - 1900 : parts[idx_part]);
 	return 1;
@@ -32925,15 +33932,15 @@
  * (caller can then tail call us).
  */
 DUK_LOCAL duk_ret_t duk__set_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_maxnargs) {
 	duk_double_t d;
 	duk_int_t parts[DUK_DATE_IDX_NUM_PARTS];
 	duk_double_t dparts[DUK_DATE_IDX_NUM_PARTS];
 	duk_idx_t nargs;
-	duk_small_uint_t maxnargs = (duk_small_uint_t) (flags_and_maxnargs >> DUK_DATE_FLAG_VALUE_SHIFT);  /* unpack args */
+	duk_small_uint_t maxnargs = (duk_small_uint_t) (flags_and_maxnargs >> DUK_DATE_FLAG_VALUE_SHIFT); /* unpack args */
 	duk_small_uint_t idx_first, idx;
 	duk_small_uint_t i;
 
 	nargs = duk_get_top(thr);
 	d = duk__push_this_get_timeval(thr, flags_and_maxnargs);
 	DUK_ASSERT(DUK_ISFINITE(d) || DUK_ISNAN(d));
 
@@ -32972,24 +33979,24 @@
 	if (flags_and_maxnargs & DUK_DATE_FLAG_TIMESETTER) {
 		DUK_ASSERT(maxnargs >= 1 && maxnargs <= 4);
 		idx_first = DUK_DATE_IDX_MILLISECOND - (maxnargs - 1);
 	} else {
 		DUK_ASSERT(maxnargs >= 1 && maxnargs <= 3);
 		idx_first = DUK_DATE_IDX_DAY - (maxnargs - 1);
 	}
-	DUK_ASSERT_DISABLE(idx_first >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(idx_first >= 0); /* unsigned */
 	DUK_ASSERT(idx_first < DUK_DATE_IDX_NUM_PARTS);
 
 	for (i = 0; i < maxnargs; i++) {
 		if ((duk_idx_t) i >= nargs) {
 			/* no argument given -> leave components untouched */
 			break;
 		}
 		idx = idx_first + i;
-		DUK_ASSERT_DISABLE(idx >= 0);  /* unsigned */
+		DUK_ASSERT_DISABLE(idx >= 0); /* unsigned */
 		DUK_ASSERT(idx < DUK_DATE_IDX_NUM_PARTS);
 
 		if (idx == DUK_DATE_IDX_YEAR && (flags_and_maxnargs & DUK_DATE_FLAG_YEAR_FIXUP)) {
 			duk__twodigit_year_fixup(thr, (duk_idx_t) i);
 		}
 
 		dparts[idx] = duk_to_number(thr, (duk_idx_t) i);
@@ -33033,15 +34040,15 @@
 	/* E5 Sections 15.9.3.1, B.2.4, B.2.5 */
 	duk_to_number(thr, idx_val);
 	if (duk_is_nan(thr, idx_val)) {
 		return;
 	}
 	duk_dup(thr, idx_val);
 	duk_to_int(thr, -1);
-	d = duk_get_number(thr, -1);  /* get as double to handle huge numbers correctly */
+	d = duk_get_number(thr, -1); /* get as double to handle huge numbers correctly */
 	if (d >= 0.0 && d <= 99.0) {
 		d += 1900.0;
 		duk_push_number(thr, d);
 		duk_replace(thr, idx_val);
 	}
 	duk_pop(thr);
 }
@@ -33081,18 +34088,22 @@
 			 */
 			d = 0.0;
 		}
 		dparts[idx] = d;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("parts from args -> %lf %lf %lf %lf %lf %lf %lf %lf",
-	                     (double) dparts[0], (double) dparts[1],
-	                     (double) dparts[2], (double) dparts[3],
-	                     (double) dparts[4], (double) dparts[5],
-	                     (double) dparts[6], (double) dparts[7]));
+	                     (double) dparts[0],
+	                     (double) dparts[1],
+	                     (double) dparts[2],
+	                     (double) dparts[3],
+	                     (double) dparts[4],
+	                     (double) dparts[5],
+	                     (double) dparts[6],
+	                     (double) dparts[7]));
 }
 
 /*
  *  Indirect magic value lookup for Date methods.
  *
  *  Date methods don't put their control flags into the function magic value
  *  because they wouldn't fit into a LIGHTFUNC's magic field.  Instead, the
@@ -33240,17 +34251,16 @@
 	duk_bool_t is_cons = duk_is_constructor_call(thr);
 	duk_double_t dparts[DUK_DATE_IDX_NUM_PARTS];
 	duk_double_t d;
 
 	DUK_DDD(DUK_DDDPRINT("Date constructor, nargs=%ld, is_cons=%ld", (long) nargs, (long) is_cons));
 
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DATE),
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DATE),
 	                              DUK_BIDX_DATE_PROTOTYPE);
 
 	/* Unlike most built-ins, the internal [[PrimitiveValue]] of a Date
 	 * is mutable.
 	 */
 
 	if (nargs == 0 || !is_cons) {
@@ -33264,28 +34274,28 @@
 		return 1;
 	} else if (nargs == 1) {
 		const char *str;
 		duk_to_primitive(thr, 0, DUK_HINT_NONE);
 		str = duk_get_string_notsymbol(thr, 0);
 		if (str) {
 			duk__parse_string(thr, str);
-			duk_replace(thr, 0);  /* may be NaN */
+			duk_replace(thr, 0); /* may be NaN */
 		}
-		d = duk__timeclip(duk_to_number(thr, 0));  /* symbols fail here */
+		d = duk__timeclip(duk_to_number(thr, 0)); /* symbols fail here */
 		duk_push_number(thr, d);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_W);
 		return 1;
 	}
 
 	duk__set_parts_from_args(thr, dparts, nargs);
 
 	/* Parts are in local time, convert when setting. */
 
-	(void) duk__set_this_timeval_from_dparts(thr, dparts, DUK_DATE_FLAG_LOCALTIME /*flags*/);  /* -> [ ... this timeval ] */
-	duk_pop(thr);  /* -> [ ... this ] */
+	(void) duk__set_this_timeval_from_dparts(thr, dparts, DUK_DATE_FLAG_LOCALTIME /*flags*/); /* -> [ ... this timeval ] */
+	duk_pop(thr); /* -> [ ... this ] */
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_date_constructor_parse(duk_hthread *thr) {
 	return duk__parse_string(thr, duk_to_string(thr, 0));
 }
 
@@ -33308,15 +34318,15 @@
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_date_constructor_now(duk_hthread *thr) {
 	duk_double_t d;
 
 	d = duk_time_get_ecmascript_time_nofrac(thr);
-	DUK_ASSERT(duk_double_equals(duk__timeclip(d), d));  /* TimeClip() should never be necessary */
+	DUK_ASSERT(duk_double_equals(duk__timeclip(d), d)); /* TimeClip() should never be necessary */
 	duk_push_number(thr, d);
 	return 1;
 }
 
 /*
  *  String/JSON conversions
  *
@@ -33357,15 +34367,15 @@
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_date_prototype_value_of(duk_hthread *thr) {
 	/* This native function is also used for Date.prototype.getTime()
 	 * as their behavior is identical.
 	 */
 
-	duk_double_t d = duk__push_this_get_timeval(thr, 0 /*flags*/);  /* -> [ this ] */
+	duk_double_t d = duk__push_this_get_timeval(thr, 0 /*flags*/); /* -> [ this ] */
 	DUK_ASSERT(DUK_ISFINITE(d) || DUK_ISNAN(d));
 	duk_push_number(thr, d);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_date_prototype_to_json(duk_hthread *thr) {
 	/* Note: toJSON() is a generic function which works even if 'this'
@@ -33383,15 +34393,15 @@
 			duk_push_null(thr);
 			return 1;
 		}
 	}
 	duk_pop(thr);
 
 	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_TO_ISO_STRING);
-	duk_dup_m2(thr);  /* -> [ O toIsoString O ] */
+	duk_dup_m2(thr); /* -> [ O toIsoString O ] */
 	duk_call_method(thr, 0);
 	return 1;
 }
 
 /*
  *  Getters.
  *
@@ -33556,29 +34566,28 @@
 	 */
 
 	duk_push_this(thr);
 	duk_require_object(thr, -1);
 	DUK_ASSERT_TOP(thr, 2);
 
 	hintstr = duk_require_lstring(thr, 0, &hintlen);
-	if ((hintlen == 6 && DUK_STRCMP(hintstr, "string") == 0) ||
-	    (hintlen == 7 && DUK_STRCMP(hintstr, "default") == 0)) {
+	if ((hintlen == 6 && DUK_STRCMP(hintstr, "string") == 0) || (hintlen == 7 && DUK_STRCMP(hintstr, "default") == 0)) {
 		hint = DUK_HINT_STRING;
 	} else if (hintlen == 6 && DUK_STRCMP(hintstr, "number") == 0) {
 		hint = DUK_HINT_NUMBER;
 	} else {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 
 	duk_to_primitive_ordinary(thr, -1, hint);
 	return 1;
 }
-#endif  /* DUK_USE_SYMBOL_BUILTIN */
+#endif /* DUK_USE_SYMBOL_BUILTIN */
 
-#endif  /* DUK_USE_DATE_BUILTIN */
+#endif /* DUK_USE_DATE_BUILTIN */
 
 /* automatic undefs */
 #undef DUK__CF_ACCEPT
 #undef DUK__CF_ACCEPT_NUL
 #undef DUK__CF_NEG
 #undef DUK__DPRINT_DPARTS
 #undef DUK__DPRINT_PARTS
@@ -33634,49 +34643,48 @@
 /* #include duk_internal.h -> already included */
 
 /* The necessary #includes are in place in duk_config.h. */
 
 /* Buffer sizes for some UNIX calls.  Larger than strictly necessary
  * to avoid Valgrind errors.
  */
-#define DUK__STRPTIME_BUF_SIZE  64
-#define DUK__STRFTIME_BUF_SIZE  64
+#define DUK__STRPTIME_BUF_SIZE 64
+#define DUK__STRFTIME_BUF_SIZE 64
 
 #if defined(DUK_USE_DATE_NOW_GETTIMEOFDAY)
 /* Get current ECMAScript time (= UNIX/Posix time, but in milliseconds). */
 DUK_INTERNAL duk_double_t duk_bi_date_get_now_gettimeofday(void) {
 	struct timeval tv;
 	duk_double_t d;
 
 	if (gettimeofday(&tv, NULL) != 0) {
 		DUK_D(DUK_DPRINT("gettimeofday() failed"));
 		return 0.0;
 	}
 
 	/* As of Duktape 2.2.0 allow fractions. */
-	d = ((duk_double_t) tv.tv_sec) * 1000.0 +
-	    ((duk_double_t) tv.tv_usec) / 1000.0;
+	d = ((duk_double_t) tv.tv_sec) * 1000.0 + ((duk_double_t) tv.tv_usec) / 1000.0;
 
 	return d;
 }
-#endif  /* DUK_USE_DATE_NOW_GETTIMEOFDAY */
+#endif /* DUK_USE_DATE_NOW_GETTIMEOFDAY */
 
 #if defined(DUK_USE_DATE_NOW_TIME)
 /* Not a very good provider: only full seconds are available. */
 DUK_INTERNAL duk_double_t duk_bi_date_get_now_time(void) {
 	time_t t;
 
 	t = time(NULL);
 	if (t == (time_t) -1) {
 		DUK_D(DUK_DPRINT("time() failed"));
 		return 0.0;
 	}
 	return ((duk_double_t) t) * 1000.0;
 }
-#endif  /* DUK_USE_DATE_NOW_TIME */
+#endif /* DUK_USE_DATE_NOW_TIME */
 
 #if defined(DUK_USE_DATE_TZO_GMTIME) || defined(DUK_USE_DATE_TZO_GMTIME_R) || defined(DUK_USE_DATE_TZO_GMTIME_S)
 /* Get local time offset (in seconds) for a certain (UTC) instant 'd'. */
 DUK_INTERNAL duk_int_t duk_bi_date_get_local_tzoffset_gmtime(duk_double_t d) {
 	time_t t, t1, t2;
 	duk_int_t parts[DUK_DATE_IDX_NUM_PARTS];
 	duk_double_t dparts[DUK_DATE_IDX_NUM_PARTS];
@@ -33751,15 +34759,15 @@
 	 *    https://bugzilla.mozilla.org/show_bug.cgi?id=351066
 	 */
 
 	duk_bi_date_timeval_to_parts(d, parts, dparts, DUK_DATE_FLAG_EQUIVYEAR /*flags*/);
 	DUK_ASSERT(parts[DUK_DATE_IDX_YEAR] >= 1970 && parts[DUK_DATE_IDX_YEAR] <= 2038);
 
 	d = duk_bi_date_get_timeval_from_dparts(dparts, 0 /*flags*/);
-	DUK_ASSERT(d >= 0 && d < 2147483648.0 * 1000.0);  /* unsigned 31-bit range */
+	DUK_ASSERT(d >= 0 && d < 2147483648.0 * 1000.0); /* unsigned 31-bit range */
 	t = (time_t) (d / 1000.0);
 	DUK_DDD(DUK_DDDPRINT("timeval: %lf -> time_t %ld", (double) d, (long) t));
 
 	duk_memzero((void *) tms, sizeof(struct tm) * 2);
 
 #if defined(DUK_USE_DATE_TZO_GMTIME_R)
 	(void) gmtime_r(&t, &tms[0]);
@@ -33773,32 +34781,44 @@
 	tm_ptr = localtime(&t);
 	duk_memcpy((void *) &tms[1], tm_ptr, sizeof(struct tm));
 #else
 #error internal error
 #endif
 	DUK_DDD(DUK_DDDPRINT("gmtime result: tm={sec:%ld,min:%ld,hour:%ld,mday:%ld,mon:%ld,year:%ld,"
 	                     "wday:%ld,yday:%ld,isdst:%ld}",
-	                     (long) tms[0].tm_sec, (long) tms[0].tm_min, (long) tms[0].tm_hour,
-	                     (long) tms[0].tm_mday, (long) tms[0].tm_mon, (long) tms[0].tm_year,
-	                     (long) tms[0].tm_wday, (long) tms[0].tm_yday, (long) tms[0].tm_isdst));
+	                     (long) tms[0].tm_sec,
+	                     (long) tms[0].tm_min,
+	                     (long) tms[0].tm_hour,
+	                     (long) tms[0].tm_mday,
+	                     (long) tms[0].tm_mon,
+	                     (long) tms[0].tm_year,
+	                     (long) tms[0].tm_wday,
+	                     (long) tms[0].tm_yday,
+	                     (long) tms[0].tm_isdst));
 	DUK_DDD(DUK_DDDPRINT("localtime result: tm={sec:%ld,min:%ld,hour:%ld,mday:%ld,mon:%ld,year:%ld,"
 	                     "wday:%ld,yday:%ld,isdst:%ld}",
-	                     (long) tms[1].tm_sec, (long) tms[1].tm_min, (long) tms[1].tm_hour,
-	                     (long) tms[1].tm_mday, (long) tms[1].tm_mon, (long) tms[1].tm_year,
-	                     (long) tms[1].tm_wday, (long) tms[1].tm_yday, (long) tms[1].tm_isdst));
+	                     (long) tms[1].tm_sec,
+	                     (long) tms[1].tm_min,
+	                     (long) tms[1].tm_hour,
+	                     (long) tms[1].tm_mday,
+	                     (long) tms[1].tm_mon,
+	                     (long) tms[1].tm_year,
+	                     (long) tms[1].tm_wday,
+	                     (long) tms[1].tm_yday,
+	                     (long) tms[1].tm_isdst));
 
 	/* tm_isdst is both an input and an output to mktime(), use 0 to
 	 * avoid DST handling in mktime():
 	 * - https://github.com/svaarala/duktape/issues/406
 	 * - http://stackoverflow.com/questions/8558919/mktime-and-tm-isdst
 	 */
 	tms[0].tm_isdst = 0;
 	tms[1].tm_isdst = 0;
-	t1 = mktime(&tms[0]);  /* UTC */
-	t2 = mktime(&tms[1]);  /* local */
+	t1 = mktime(&tms[0]); /* UTC */
+	t2 = mktime(&tms[1]); /* local */
 	if (t1 == (time_t) -1 || t2 == (time_t) -1) {
 		/* This check used to be for (t < 0) but on some platforms
 		 * time_t is unsigned and apparently the proper way to detect
 		 * an mktime() error return is the cast above.  See e.g.:
 		 * http://pubs.opengroup.org/onlinepubs/009695299/functions/mktime.html
 		 */
 		goto mktime_error;
@@ -33813,55 +34833,61 @@
 	 * XXX: allow direct subtraction on known platforms.
 	 */
 #if 0
 	return (duk_int_t) (t2 - t1);
 #endif
 	return (duk_int_t) difftime(t2, t1);
 
- mktime_error:
+mktime_error:
 	/* XXX: return something more useful, so that caller can throw? */
 	DUK_D(DUK_DPRINT("mktime() failed, d=%lf", (double) d));
 	return 0;
 }
-#endif  /* DUK_USE_DATE_TZO_GMTIME */
+#endif /* DUK_USE_DATE_TZO_GMTIME */
 
 #if defined(DUK_USE_DATE_PRS_STRPTIME)
 DUK_INTERNAL duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str) {
 	struct tm tm;
 	time_t t;
 	char buf[DUK__STRPTIME_BUF_SIZE];
 
 	/* Copy to buffer with slack to avoid Valgrind gripes from strptime. */
 	DUK_ASSERT(str != NULL);
-	duk_memzero(buf, sizeof(buf));  /* valgrind whine without this */
+	duk_memzero(buf, sizeof(buf)); /* valgrind whine without this */
 	DUK_SNPRINTF(buf, sizeof(buf), "%s", (const char *) str);
 	buf[sizeof(buf) - 1] = (char) 0;
 
 	DUK_DDD(DUK_DDDPRINT("parsing: '%s'", (const char *) buf));
 
 	duk_memzero(&tm, sizeof(tm));
 	if (strptime((const char *) buf, "%c", &tm) != NULL) {
 		DUK_DDD(DUK_DDDPRINT("before mktime: tm={sec:%ld,min:%ld,hour:%ld,mday:%ld,mon:%ld,year:%ld,"
 		                     "wday:%ld,yday:%ld,isdst:%ld}",
-		                     (long) tm.tm_sec, (long) tm.tm_min, (long) tm.tm_hour,
-		                     (long) tm.tm_mday, (long) tm.tm_mon, (long) tm.tm_year,
-		                     (long) tm.tm_wday, (long) tm.tm_yday, (long) tm.tm_isdst));
-		tm.tm_isdst = -1;  /* negative: dst info not available */
+		                     (long) tm.tm_sec,
+		                     (long) tm.tm_min,
+		                     (long) tm.tm_hour,
+		                     (long) tm.tm_mday,
+		                     (long) tm.tm_mon,
+		                     (long) tm.tm_year,
+		                     (long) tm.tm_wday,
+		                     (long) tm.tm_yday,
+		                     (long) tm.tm_isdst));
+		tm.tm_isdst = -1; /* negative: dst info not available */
 
 		t = mktime(&tm);
 		DUK_DDD(DUK_DDDPRINT("mktime() -> %ld", (long) t));
 		if (t >= 0) {
 			duk_push_number(thr, ((duk_double_t) t) * 1000.0);
 			return 1;
 		}
 	}
 
 	return 0;
 }
-#endif  /* DUK_USE_DATE_PRS_STRPTIME */
+#endif /* DUK_USE_DATE_PRS_STRPTIME */
 
 #if defined(DUK_USE_DATE_PRS_GETDATE)
 DUK_INTERNAL duk_bool_t duk_bi_date_parse_string_getdate(duk_hthread *thr, const char *str) {
 	struct tm tm;
 	duk_small_int_t rc;
 	time_t t;
 
@@ -33880,18 +34906,21 @@
 			duk_push_number(thr, (duk_double_t) t);
 			return 1;
 		}
 	}
 
 	return 0;
 }
-#endif  /* DUK_USE_DATE_PRS_GETDATE */
+#endif /* DUK_USE_DATE_PRS_GETDATE */
 
 #if defined(DUK_USE_DATE_FMT_STRFTIME)
-DUK_INTERNAL duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr, duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags) {
+DUK_INTERNAL duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr,
+                                                          duk_int_t *parts,
+                                                          duk_int_t tzoffset,
+                                                          duk_small_uint_t flags) {
 	char buf[DUK__STRFTIME_BUF_SIZE];
 	struct tm tm;
 	const char *fmt;
 
 	DUK_UNREF(tzoffset);
 
 	/* If the platform doesn't support the entire ECMAScript range, we need
@@ -33901,26 +34930,25 @@
 	 * range is supported.  For smaller time_t values (4 bytes in practice),
 	 * assumes that the signed 32-bit range is supported.
 	 *
 	 * XXX: detect this more correctly per platform.  The size of time_t is
 	 * probably not an accurate guarantee of strftime() supporting or not
 	 * supporting a large time range (the full ECMAScript range).
 	 */
-	if (sizeof(time_t) < 8 &&
-	    (parts[DUK_DATE_IDX_YEAR] < 1970 || parts[DUK_DATE_IDX_YEAR] > 2037)) {
+	if (sizeof(time_t) < 8 && (parts[DUK_DATE_IDX_YEAR] < 1970 || parts[DUK_DATE_IDX_YEAR] > 2037)) {
 		/* be paranoid for 32-bit time values (even avoiding negative ones) */
 		return 0;
 	}
 
 	duk_memzero(&tm, sizeof(tm));
 	tm.tm_sec = parts[DUK_DATE_IDX_SECOND];
 	tm.tm_min = parts[DUK_DATE_IDX_MINUTE];
 	tm.tm_hour = parts[DUK_DATE_IDX_HOUR];
-	tm.tm_mday = parts[DUK_DATE_IDX_DAY];       /* already one-based */
-	tm.tm_mon = parts[DUK_DATE_IDX_MONTH] - 1;  /* one-based -> zero-based */
+	tm.tm_mday = parts[DUK_DATE_IDX_DAY]; /* already one-based */
+	tm.tm_mon = parts[DUK_DATE_IDX_MONTH] - 1; /* one-based -> zero-based */
 	tm.tm_year = parts[DUK_DATE_IDX_YEAR] - 1900;
 	tm.tm_wday = parts[DUK_DATE_IDX_WEEKDAY];
 	tm.tm_isdst = 0;
 
 	duk_memzero(buf, sizeof(buf));
 	if ((flags & DUK_DATE_FLAG_TOSTRING_DATE) && (flags & DUK_DATE_FLAG_TOSTRING_TIME)) {
 		fmt = "%c";
@@ -33932,15 +34960,15 @@
 	}
 	(void) strftime(buf, sizeof(buf) - 1, fmt, &tm);
 	DUK_ASSERT(buf[sizeof(buf) - 1] == 0);
 
 	duk_push_string(thr, buf);
 	return 1;
 }
-#endif  /* DUK_USE_DATE_FMT_STRFTIME */
+#endif /* DUK_USE_DATE_FMT_STRFTIME */
 
 #if defined(DUK_USE_GET_MONOTONIC_TIME_CLOCK_GETTIME)
 DUK_INTERNAL duk_double_t duk_bi_date_get_monotonic_time_clock_gettime(void) {
 	struct timespec ts;
 
 	if (clock_gettime(CLOCK_MONOTONIC, &ts) == 0) {
 		return (duk_double_t) ts.tv_sec * 1000.0 + (duk_double_t) ts.tv_nsec / 1000000.0;
@@ -33981,28 +35009,28 @@
 }
 
 #if defined(DUK_USE_DATE_NOW_WINDOWS_SUBMS)
 DUK_LOCAL void duk__convert_filetime_to_ularge(const FILETIME *ft, ULARGE_INTEGER *res) {
 	res->LowPart = ft->dwLowDateTime;
 	res->HighPart = ft->dwHighDateTime;
 }
-#endif  /* DUK_USE_DATE_NOW_WINDOWS_SUBMS */
+#endif /* DUK_USE_DATE_NOW_WINDOWS_SUBMS */
 
 DUK_LOCAL void duk__set_systime_jan1970(SYSTEMTIME *st) {
 	duk_memzero((void *) st, sizeof(*st));
 	st->wYear = 1970;
 	st->wMonth = 1;
-	st->wDayOfWeek = 4;  /* not sure whether or not needed; Thursday */
+	st->wDayOfWeek = 4; /* not sure whether or not needed; Thursday */
 	st->wDay = 1;
 	DUK_ASSERT(st->wHour == 0);
 	DUK_ASSERT(st->wMinute == 0);
 	DUK_ASSERT(st->wSecond == 0);
 	DUK_ASSERT(st->wMilliseconds == 0);
 }
-#endif  /* defined(DUK_USE_DATE_NOW_WINDOWS) || defined(DUK_USE_DATE_TZO_WINDOWS) */
+#endif /* defined(DUK_USE_DATE_NOW_WINDOWS) || defined(DUK_USE_DATE_TZO_WINDOWS) */
 
 #if defined(DUK_USE_DATE_NOW_WINDOWS)
 DUK_INTERNAL duk_double_t duk_bi_date_get_now_windows(void) {
 	/* Suggested step-by-step method from documentation of RtlTimeToSecondsSince1970:
 	 * http://msdn.microsoft.com/en-us/library/windows/desktop/ms724928(v=vs.85).aspx
 	 */
 	SYSTEMTIME st1, st2;
@@ -34016,15 +35044,15 @@
 
 	/* Difference is in 100ns units, convert to milliseconds, keeping
 	 * fractions since Duktape 2.2.0.  This is only theoretical because
 	 * SYSTEMTIME is limited to milliseconds.
 	 */
 	return (duk_double_t) ((LONGLONG) tmp1.QuadPart - (LONGLONG) tmp2.QuadPart) / 10000.0;
 }
-#endif  /* DUK_USE_DATE_NOW_WINDOWS */
+#endif /* DUK_USE_DATE_NOW_WINDOWS */
 
 #if defined(DUK_USE_DATE_NOW_WINDOWS_SUBMS)
 DUK_INTERNAL duk_double_t duk_bi_date_get_now_windows_subms(void) {
 	/* Variant of the basic algorithm using GetSystemTimePreciseAsFileTime()
 	 * for more accuracy.
 	 */
 	FILETIME ft1;
@@ -34038,15 +35066,15 @@
 	duk__convert_systime_to_ularge((const SYSTEMTIME *) &st2, &tmp2);
 
 	/* Difference is in 100ns units, convert to milliseconds, keeping
 	 * fractions since Duktape 2.2.0.
 	 */
 	return (duk_double_t) ((LONGLONG) tmp1.QuadPart - (LONGLONG) tmp2.QuadPart) / 10000.0;
 }
-#endif  /* DUK_USE_DATE_NOW_WINDOWS */
+#endif /* DUK_USE_DATE_NOW_WINDOWS */
 
 #if defined(DUK_USE_DATE_TZO_WINDOWS)
 DUK_INTERNAL duk_int_t duk_bi_date_get_local_tzoffset_windows(duk_double_t d) {
 	SYSTEMTIME st1;
 	SYSTEMTIME st2;
 	SYSTEMTIME st3;
 	ULARGE_INTEGER tmp1;
@@ -34063,33 +35091,33 @@
 
 	/* Use the approach described in "Remarks" of FileTimeToLocalFileTime:
 	 * http://msdn.microsoft.com/en-us/library/windows/desktop/ms724277(v=vs.85).aspx
 	 */
 
 	duk__set_systime_jan1970(&st1);
 	duk__convert_systime_to_ularge((const SYSTEMTIME *) &st1, &tmp1);
-	tmp2.QuadPart = (ULONGLONG) (d * 10000.0);  /* millisec -> 100ns units since jan 1, 1970 */
-	tmp2.QuadPart += tmp1.QuadPart;             /* input 'd' in Windows UTC, 100ns units */
+	tmp2.QuadPart = (ULONGLONG) (d * 10000.0); /* millisec -> 100ns units since jan 1, 1970 */
+	tmp2.QuadPart += tmp1.QuadPart; /* input 'd' in Windows UTC, 100ns units */
 
 	ft1.dwLowDateTime = tmp2.LowPart;
 	ft1.dwHighDateTime = tmp2.HighPart;
 	if (FileTimeToSystemTime((const FILETIME *) &ft1, &st2) == 0) {
 		DUK_D(DUK_DPRINT("FileTimeToSystemTime() failed, return tzoffset 0"));
 		return 0;
 	}
 	if (SystemTimeToTzSpecificLocalTime((LPTIME_ZONE_INFORMATION) NULL, &st2, &st3) == 0) {
 		DUK_D(DUK_DPRINT("SystemTimeToTzSpecificLocalTime() failed, return tzoffset 0"));
 		return 0;
 	}
 	duk__convert_systime_to_ularge((const SYSTEMTIME *) &st3, &tmp3);
 
 	/* Positive if local time ahead of UTC. */
-	return (duk_int_t) (((LONGLONG) tmp3.QuadPart - (LONGLONG) tmp2.QuadPart) / DUK_I64_CONSTANT(10000000));  /* seconds */
+	return (duk_int_t) (((LONGLONG) tmp3.QuadPart - (LONGLONG) tmp2.QuadPart) / DUK_I64_CONSTANT(10000000)); /* seconds */
 }
-#endif  /* DUK_USE_DATE_TZO_WINDOWS */
+#endif /* DUK_USE_DATE_TZO_WINDOWS */
 
 #if defined(DUK_USE_DATE_TZO_WINDOWS_NO_DST)
 DUK_INTERNAL duk_int_t duk_bi_date_get_local_tzoffset_windows_no_dst(duk_double_t d) {
 	SYSTEMTIME st1;
 	SYSTEMTIME st2;
 	FILETIME ft1;
 	FILETIME ft2;
@@ -34116,25 +35144,27 @@
 	}
 	if (FileTimeToSystemTime((const FILETIME *) &ft2, &st2) == 0) {
 		DUK_D(DUK_DPRINT("FileTimeToSystemTime() failed, return tzoffset 0"));
 		return 0;
 	}
 	duk__convert_systime_to_ularge((const SYSTEMTIME *) &st2, &tmp2);
 
-	return (duk_int_t) (((LONGLONG) tmp2.QuadPart - (LONGLONG) tmp1.QuadPart) / DUK_I64_CONSTANT(10000000));  /* seconds */
+	return (duk_int_t) (((LONGLONG) tmp2.QuadPart - (LONGLONG) tmp1.QuadPart) / DUK_I64_CONSTANT(10000000)); /* seconds */
 }
-#endif  /* DUK_USE_DATE_TZO_WINDOWS_NO_DST */
+#endif /* DUK_USE_DATE_TZO_WINDOWS_NO_DST */
 
 #if defined(DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC)
 DUK_INTERNAL duk_double_t duk_bi_date_get_monotonic_time_windows_qpc(void) {
 	LARGE_INTEGER count, freq;
 
 	/* There are legacy issues with QueryPerformanceCounter():
-	 * - Potential jumps: https://support.microsoft.com/en-us/help/274323/performance-counter-value-may-unexpectedly-leap-forward
-	 * - Differences between cores (XP): https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx#qpc_support_in_windows_versions
+	 * - Potential jumps:
+	 * https://support.microsoft.com/en-us/help/274323/performance-counter-value-may-unexpectedly-leap-forward
+	 * - Differences between cores (XP):
+	 * https://msdn.microsoft.com/en-us/library/windows/desktop/dn553408(v=vs.85).aspx#qpc_support_in_windows_versions
 	 *
 	 * We avoid these by enabling QPC by default only for Vista or later.
 	 */
 
 	if (QueryPerformanceCounter(&count) && QueryPerformanceFrequency(&freq)) {
 		/* XXX: QueryPerformanceFrequency() can be cached */
 		return (duk_double_t) count.QuadPart / (duk_double_t) freq.QuadPart * 1000.0;
@@ -34143,15 +35173,15 @@
 		 * will always succeed and will thus never return zero."
 		 * Provide minimal error path just in case user enables this
 		 * feature in pre-XP Windows.
 		 */
 		return 0.0;
 	}
 }
-#endif  /* DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC */
+#endif /* DUK_USE_GET_MONOTONIC_TIME_WINDOWS_QPC */
 #line 1 "duk_bi_duktape.c"
 /*
  *  Duktape built-ins
  *
  *  Size optimization note: it might seem that vararg multipurpose functions
  *  like fin(), enc(), and dec() are not very size optimal, but using a single
  *  user-visible ECMAScript function saves a lot of run-time footprint; each
@@ -34207,25 +35237,25 @@
 	} else {
 		/* Get. */
 		DUK_ASSERT(duk_get_top(thr) == 1);
 		duk_get_finalizer(thr, 0);
 		return 1;
 	}
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 DUK_INTERNAL duk_ret_t duk_bi_duktape_object_enc(duk_hthread *thr) {
 	duk_hstring *h_str;
 
 	/* Vararg function: must be careful to check/require arguments.
 	 * The JSON helpers accept invalid indices and treat them like
 	 * non-existent optional parameters.
 	 */
 
-	h_str = duk_require_hstring(thr, 0);  /* Could reject symbols, but no point: won't match comparisons. */
+	h_str = duk_require_hstring(thr, 0); /* Could reject symbols, but no point: won't match comparisons. */
 	duk_require_valid_index(thr, 1);
 
 	if (h_str == DUK_HTHREAD_STRING_HEX(thr)) {
 		duk_set_top(thr, 2);
 		duk_hex_encode(thr, 1);
 		DUK_ASSERT_TOP(thr, 2);
 	} else if (h_str == DUK_HTHREAD_STRING_BASE64(thr)) {
@@ -34234,26 +35264,24 @@
 		DUK_ASSERT_TOP(thr, 2);
 #if defined(DUK_USE_JSON_SUPPORT) && defined(DUK_USE_JX)
 	} else if (h_str == DUK_HTHREAD_STRING_JX(thr)) {
 		duk_bi_json_stringify_helper(thr,
 		                             1 /*idx_value*/,
 		                             2 /*idx_replacer*/,
 		                             3 /*idx_space*/,
-		                             DUK_JSON_FLAG_EXT_CUSTOM |
-		                             DUK_JSON_FLAG_ASCII_ONLY |
-		                             DUK_JSON_FLAG_AVOID_KEY_QUOTES /*flags*/);
+		                             DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_ASCII_ONLY |
+		                                 DUK_JSON_FLAG_AVOID_KEY_QUOTES /*flags*/);
 #endif
 #if defined(DUK_USE_JSON_SUPPORT) && defined(DUK_USE_JC)
 	} else if (h_str == DUK_HTHREAD_STRING_JC(thr)) {
 		duk_bi_json_stringify_helper(thr,
 		                             1 /*idx_value*/,
 		                             2 /*idx_replacer*/,
 		                             3 /*idx_space*/,
-		                             DUK_JSON_FLAG_EXT_COMPATIBLE |
-		                             DUK_JSON_FLAG_ASCII_ONLY /*flags*/);
+		                             DUK_JSON_FLAG_EXT_COMPATIBLE | DUK_JSON_FLAG_ASCII_ONLY /*flags*/);
 #endif
 	} else {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 	return 1;
 }
 
@@ -34261,56 +35289,50 @@
 	duk_hstring *h_str;
 
 	/* Vararg function: must be careful to check/require arguments.
 	 * The JSON helpers accept invalid indices and treat them like
 	 * non-existent optional parameters.
 	 */
 
-	h_str = duk_require_hstring(thr, 0);  /* Could reject symbols, but no point: won't match comparisons */
+	h_str = duk_require_hstring(thr, 0); /* Could reject symbols, but no point: won't match comparisons */
 	duk_require_valid_index(thr, 1);
 
 	if (h_str == DUK_HTHREAD_STRING_HEX(thr)) {
 		duk_set_top(thr, 2);
 		duk_hex_decode(thr, 1);
 		DUK_ASSERT_TOP(thr, 2);
 	} else if (h_str == DUK_HTHREAD_STRING_BASE64(thr)) {
 		duk_set_top(thr, 2);
 		duk_base64_decode(thr, 1);
 		DUK_ASSERT_TOP(thr, 2);
 #if defined(DUK_USE_JSON_SUPPORT) && defined(DUK_USE_JX)
 	} else if (h_str == DUK_HTHREAD_STRING_JX(thr)) {
-		duk_bi_json_parse_helper(thr,
-		                         1 /*idx_value*/,
-		                         2 /*idx_replacer*/,
-		                         DUK_JSON_FLAG_EXT_CUSTOM /*flags*/);
+		duk_bi_json_parse_helper(thr, 1 /*idx_value*/, 2 /*idx_replacer*/, DUK_JSON_FLAG_EXT_CUSTOM /*flags*/);
 #endif
 #if defined(DUK_USE_JSON_SUPPORT) && defined(DUK_USE_JC)
 	} else if (h_str == DUK_HTHREAD_STRING_JC(thr)) {
-		duk_bi_json_parse_helper(thr,
-		                         1 /*idx_value*/,
-		                         2 /*idx_replacer*/,
-		                         DUK_JSON_FLAG_EXT_COMPATIBLE /*flags*/);
+		duk_bi_json_parse_helper(thr, 1 /*idx_value*/, 2 /*idx_replacer*/, DUK_JSON_FLAG_EXT_COMPATIBLE /*flags*/);
 #endif
 	} else {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 	return 1;
 }
 
 /*
  *  Compact an object
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_duktape_object_compact(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 1);
 	duk_compact(thr, 0);
-	return 1;  /* return the argument object */
+	return 1; /* return the argument object */
 }
 
-#endif  /* DUK_USE_DUKTAPE_BUILTIN */
+#endif /* DUK_USE_DUKTAPE_BUILTIN */
 #line 1 "duk_bi_encoding.c"
 /*
  *  WHATWG Encoding API built-ins
  *
  *  API specification: https://encoding.spec.whatwg.org/#api
  *  Web IDL: https://www.w3.org/TR/WebIDL/
  */
@@ -34318,37 +35340,37 @@
 /* #include duk_internal.h -> already included */
 
 /*
  *  Data structures for encoding/decoding
  */
 
 typedef struct {
-	duk_uint8_t *out;      /* where to write next byte(s) */
-	duk_codepoint_t lead;  /* lead surrogate */
+	duk_uint8_t *out; /* where to write next byte(s) */
+	duk_codepoint_t lead; /* lead surrogate */
 } duk__encode_context;
 
 typedef struct {
 	/* UTF-8 decoding state */
-	duk_codepoint_t codepoint;  /* built up incrementally */
-	duk_uint8_t upper;          /* max value of next byte (decode error otherwise) */
-	duk_uint8_t lower;          /* min value of next byte (ditto) */
-	duk_uint8_t needed;         /* how many more bytes we need */
-	duk_uint8_t bom_handled;    /* BOM seen or no longer expected */
+	duk_codepoint_t codepoint; /* built up incrementally */
+	duk_uint8_t upper; /* max value of next byte (decode error otherwise) */
+	duk_uint8_t lower; /* min value of next byte (ditto) */
+	duk_uint8_t needed; /* how many more bytes we need */
+	duk_uint8_t bom_handled; /* BOM seen or no longer expected */
 
 	/* Decoder configuration */
 	duk_uint8_t fatal;
 	duk_uint8_t ignore_bom;
 } duk__decode_context;
 
 /* The signed duk_codepoint_t type is used to signal a decoded codepoint
  * (>= 0) or various other states using negative values.
  */
-#define DUK__CP_CONTINUE   (-1)  /* continue to next byte, no completed codepoint */
-#define DUK__CP_ERROR      (-2)  /* decoding error */
-#define DUK__CP_RETRY      (-3)  /* decoding error; retry last byte */
+#define DUK__CP_CONTINUE (-1) /* continue to next byte, no completed codepoint */
+#define DUK__CP_ERROR    (-2) /* decoding error */
+#define DUK__CP_RETRY    (-3) /* decoding error; retry last byte */
 
 /*
  *  Raw helpers for encoding/decoding
  */
 
 /* Emit UTF-8 (= CESU-8) encoded U+FFFD (replacement char), i.e. ef bf bd. */
 DUK_LOCAL duk_uint8_t *duk__utf8_emit_repl(duk_uint8_t *ptr) {
@@ -34427,15 +35449,15 @@
 			dec_ctx->codepoint = (dec_ctx->codepoint << 6) | (x & 0x3f);
 			if (--dec_ctx->needed > 0) {
 				/* need more bytes */
 				return DUK__CP_CONTINUE;
 			} else {
 				/* got a codepoint */
 				duk_codepoint_t ret;
-				DUK_ASSERT(dec_ctx->codepoint <= 0x10ffffL);  /* Decoding rules guarantee. */
+				DUK_ASSERT(dec_ctx->codepoint <= 0x10ffffL); /* Decoding rules guarantee. */
 				ret = dec_ctx->codepoint;
 				dec_ctx->codepoint = 0x0000L;
 				dec_ctx->needed = 0;
 				return ret;
 			}
 		} else {
 			/* We just encountered an illegal UTF-8 continuation byte.  This might
@@ -34483,15 +35505,16 @@
 			} else {
 				/* consecutive high surrogates, consider first one unpaired */
 				codepoint = DUK_UNICODE_CP_REPLACEMENT_CHARACTER;
 			}
 		} else {
 			/* low surrogate */
 			if (enc_ctx->lead != 0x0000L) {
-				codepoint = (duk_codepoint_t) (0x010000L + ((enc_ctx->lead - 0xd800L) << 10) + (codepoint - 0xdc00L));
+				codepoint =
+				    (duk_codepoint_t) (0x010000L + ((enc_ctx->lead - 0xd800L) << 10) + (codepoint - 0xdc00L));
 				enc_ctx->lead = 0x0000L;
 			} else {
 				/* unpaired low surrogate */
 				DUK_ASSERT(enc_ctx->lead == 0x0000L);
 				codepoint = DUK_UNICODE_CP_REPLACEMENT_CHARACTER;
 			}
 		}
@@ -34504,15 +35527,15 @@
 	}
 
 	/* Codepoint may be original input, a decoded surrogate pair, or may
 	 * have been replaced with U+FFFD.
 	 */
 	enc_ctx->out += duk_unicode_encode_xutf8((duk_ucodepoint_t) codepoint, enc_ctx->out);
 }
-#endif  /* DUK_USE_ENCODING_BUILTINS */
+#endif /* DUK_USE_ENCODING_BUILTINS */
 
 /* Shared helper for buffer-to-string using a TextDecoder() compatible UTF-8
  * decoder.
  */
 DUK_LOCAL duk_ret_t duk__decode_helper(duk_hthread *thr, duk__decode_context *dec_ctx) {
 	const duk_uint8_t *input;
 	duk_size_t len = 0;
@@ -34533,26 +35556,23 @@
 	 * required side effect order.
 	 */
 
 	if (duk_is_undefined(thr, 0)) {
 		duk_push_fixed_buffer_nozero(thr, 0);
 		duk_replace(thr, 0);
 	}
-	(void) duk_require_buffer_data(thr, 0, &len);  /* Need 'len', avoid pointer. */
+	(void) duk_require_buffer_data(thr, 0, &len); /* Need 'len', avoid pointer. */
 
-	if (duk_check_type_mask(thr, 1, DUK_TYPE_MASK_UNDEFINED |
-	                                DUK_TYPE_MASK_NULL |
-	                                DUK_TYPE_MASK_NONE)) {
+	if (duk_check_type_mask(thr, 1, DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_NONE)) {
 		/* Use defaults, treat missing value like undefined. */
 	} else {
-		duk_require_type_mask(thr, 1, DUK_TYPE_MASK_UNDEFINED |
-	                                      DUK_TYPE_MASK_NULL |
-	                                      DUK_TYPE_MASK_LIGHTFUNC |
-	                                      DUK_TYPE_MASK_BUFFER |
-		                              DUK_TYPE_MASK_OBJECT);
+		duk_require_type_mask(thr,
+		                      1,
+		                      DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_LIGHTFUNC |
+		                          DUK_TYPE_MASK_BUFFER | DUK_TYPE_MASK_OBJECT);
 		if (duk_get_prop_literal(thr, 1, "stream")) {
 			stream = duk_to_boolean(thr, -1);
 		}
 	}
 
 	/* Allowance is 3*len in the general case because all bytes may potentially
 	 * become U+FFFD.  If the first byte completes a non-BMP codepoint it will
@@ -34562,15 +35582,16 @@
 	 *
 	 * XXX: As with TextEncoder, need a better buffer allocation strategy here.
 	 */
 	if (len >= (DUK_HBUFFER_MAX_BYTELEN / 3) - 3) {
 		DUK_ERROR_TYPE(thr, DUK_STR_RESULT_TOO_LONG);
 		DUK_WO_NORETURN(return 0;);
 	}
-	output = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, 3 + (3 * len));  /* used parts will be always manually written over */
+	output =
+	    (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, 3 + (3 * len)); /* used parts will be always manually written over */
 
 	input = (const duk_uint8_t *) duk_get_buffer_data(thr, 0, &len_tmp);
 	DUK_ASSERT(input != NULL || len == 0);
 	if (DUK_UNLIKELY(len != len_tmp)) {
 		/* Very unlikely but possible: source buffer was resized by
 		 * a side effect when fixed buffer was pushed.  Output buffer
 		 * may not be large enough to hold output, so just fail if
@@ -34594,15 +35615,15 @@
 			if (codepoint == DUK__CP_CONTINUE) {
 				continue;
 			}
 
 			/* Decoding error with or without retry. */
 			DUK_ASSERT(codepoint == DUK__CP_ERROR || codepoint == DUK__CP_RETRY);
 			if (codepoint == DUK__CP_RETRY) {
-				--in;  /* retry last byte */
+				--in; /* retry last byte */
 			}
 			/* replacement mode: replace with U+FFFD */
 			codepoint = DUK_UNICODE_CP_REPLACEMENT_CHARACTER;
 			if (dec_ctx->fatal) {
 				/* fatal mode: throw a TypeError */
 				goto fail_type;
 			}
@@ -34627,24 +35648,24 @@
 			if (dec_ctx->fatal) {
 				goto fail_type;
 			} else {
 				out += duk_unicode_encode_cesu8(DUK_UNICODE_CP_REPLACEMENT_CHARACTER, out);
 				DUK_ASSERT(out <= output + (3 + (3 * len)));
 			}
 		}
-		duk__utf8_decode_init(dec_ctx);  /* Initialize decoding state for potential reuse. */
+		duk__utf8_decode_init(dec_ctx); /* Initialize decoding state for potential reuse. */
 	}
 
 	/* Output buffer is fixed and thus stable even if there had been
 	 * side effects (which there shouldn't be).
 	 */
 	duk_push_lstring(thr, (const char *) output, (duk_size_t) (out - output));
 	return 1;
 
- fail_type:
+fail_type:
 	DUK_ERROR_TYPE(thr, DUK_STR_UTF8_DECODE_FAILED);
 	DUK_WO_NORETURN(return 0;);
 }
 
 /*
  *  Built-in bindings
  */
@@ -34695,15 +35716,15 @@
 	 * Maybe switch to a chunk-based strategy, or preprocess the string to
 	 * figure out the space needed ahead of time?
 	 */
 	DUK_ASSERT(3 * len >= len);
 	output = (duk_uint8_t *) duk_push_dynamic_buffer(thr, 3 * len);
 
 	if (len > 0) {
-		DUK_ASSERT(duk_is_string(thr, 0));  /* True if len > 0. */
+		DUK_ASSERT(duk_is_string(thr, 0)); /* True if len > 0. */
 
 		/* XXX: duk_decode_string() is used to process the input
 		 * string.  For standard ECMAScript strings, represented
 		 * internally as CESU-8, this is fine.  However, behavior
 		 * beyond CESU-8 is not very strict: codepoints using an
 		 * extended form of UTF-8 are also accepted, and invalid
 		 * codepoint sequences (which are allowed in Duktape strings)
@@ -34771,15 +35792,15 @@
 
 	/* The decode context is not assumed to be zeroed; all fields are
 	 * initialized explicitly.
 	 */
 	dec_ctx = (duk__decode_context *) duk_push_fixed_buffer(thr, sizeof(duk__decode_context));
 	dec_ctx->fatal = (duk_uint8_t) fatal;
 	dec_ctx->ignore_bom = (duk_uint8_t) ignore_bom;
-	duk__utf8_decode_init(dec_ctx);  /* Initializes remaining fields. */
+	duk__utf8_decode_init(dec_ctx); /* Initializes remaining fields. */
 
 	duk_put_prop_literal(thr, -2, DUK_INTERNAL_SYMBOL("Context"));
 	return 0;
 }
 
 /* Get TextDecoder context from 'this'; leaves garbage on stack. */
 DUK_LOCAL duk__decode_context *duk__get_textdecoder_context(duk_hthread *thr) {
@@ -34817,30 +35838,30 @@
 
 DUK_INTERNAL duk_ret_t duk_bi_textdecoder_prototype_decode(duk_hthread *thr) {
 	duk__decode_context *dec_ctx;
 
 	dec_ctx = duk__get_textdecoder_context(thr);
 	return duk__decode_helper(thr, dec_ctx);
 }
-#endif  /* DUK_USE_ENCODING_BUILTINS */
+#endif /* DUK_USE_ENCODING_BUILTINS */
 
 /*
  *  Internal helper for Node.js Buffer
  */
 
 /* Internal helper used for Node.js Buffer .toString().  Value stack convention
  * is currently odd: it mimics TextDecoder .decode() so that argument must be at
  * index 0, and decode options (not present for Buffer) at index 1.  Return value
  * is a Duktape/C function return value.
  */
 DUK_INTERNAL duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr) {
 	duk__decode_context dec_ctx;
 
-	dec_ctx.fatal = 0;  /* use replacement chars */
-	dec_ctx.ignore_bom = 1;  /* ignore BOMs (matches Node.js Buffer .toString()) */
+	dec_ctx.fatal = 0; /* use replacement chars */
+	dec_ctx.ignore_bom = 1; /* ignore BOMs (matches Node.js Buffer .toString()) */
 	duk__utf8_decode_init(&dec_ctx);
 
 	return duk__decode_helper(thr, &dec_ctx);
 }
 
 /* automatic undefs */
 #undef DUK__CP_CONTINUE
@@ -34860,26 +35881,25 @@
 	 * augmentation; when called as normal function, we need to do
 	 * it here.
 	 */
 
 	duk_small_int_t bidx_prototype = duk_get_current_magic(thr);
 
 	/* same for both error and each subclass like TypeError */
-	duk_uint_t flags_and_class = DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                             DUK_HOBJECT_FLAG_FASTREFS |
-	                             DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ERROR);
+	duk_uint_t flags_and_class =
+	    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ERROR);
 
 	(void) duk_push_object_helper(thr, flags_and_class, bidx_prototype);
 
 	/* If message is undefined, the own property 'message' is not set at
 	 * all to save property space.  An empty message is inherited anyway.
 	 */
 	if (!duk_is_undefined(thr, 0)) {
 		duk_to_string(thr, 0);
-		duk_dup_0(thr);  /* [ message error message ] */
+		duk_dup_0(thr); /* [ message error message ] */
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_MESSAGE, DUK_PROPDESC_FLAGS_WC);
 	}
 
 	/* Augment the error if called as a normal function.  __FILE__ and __LINE__
 	 * are not desirable in this case.
 	 */
 
@@ -34930,15 +35950,15 @@
 	}
 	if (duk_get_length(thr, -1) == 0) {
 		/* message is empty -> return name */
 		duk_pop(thr);
 		return 1;
 	}
 	duk_push_literal(thr, ": ");
-	duk_insert(thr, -2);  /* ... name ': ' message */
+	duk_insert(thr, -2); /* ... name ': ' message */
 	duk_concat(thr, 3);
 
 	return 1;
 }
 
 #if defined(DUK_USE_TRACEBACKS)
 
@@ -34953,46 +35973,46 @@
  *  NOTE: although _Tracedata is an internal property, user code can currently
  *  write to the array (or replace it with something other than an array).
  *  The code below must tolerate arbitrary _Tracedata.  It can throw errors
  *  etc, but cannot cause a segfault or memory unsafe behavior.
  */
 
 /* constants arbitrary, chosen for small loads */
-#define DUK__OUTPUT_TYPE_TRACEBACK   (-1)
-#define DUK__OUTPUT_TYPE_FILENAME    0
-#define DUK__OUTPUT_TYPE_LINENUMBER  1
+#define DUK__OUTPUT_TYPE_TRACEBACK  (-1)
+#define DUK__OUTPUT_TYPE_FILENAME   0
+#define DUK__OUTPUT_TYPE_LINENUMBER 1
 
 DUK_LOCAL duk_ret_t duk__error_getter_helper(duk_hthread *thr, duk_small_int_t output_type) {
 	duk_idx_t idx_td;
-	duk_small_int_t i;  /* traceback depth fits into 16 bits */
-	duk_small_int_t t;  /* stack type fits into 16 bits */
-	duk_small_int_t count_func = 0;  /* traceback depth ensures fits into 16 bits */
+	duk_small_int_t i; /* traceback depth fits into 16 bits */
+	duk_small_int_t t; /* stack type fits into 16 bits */
+	duk_small_int_t count_func = 0; /* traceback depth ensures fits into 16 bits */
 	const char *str_tailcall = " tailcall";
 	const char *str_strict = " strict";
 	const char *str_construct = " construct";
 	const char *str_prevyield = " preventsyield";
 	const char *str_directeval = " directeval";
 	const char *str_empty = "";
 
-	DUK_ASSERT_TOP(thr, 0);  /* fixed arg count */
+	DUK_ASSERT_TOP(thr, 0); /* fixed arg count */
 
 	duk_push_this(thr);
 	duk_xget_owndataprop_stridx_short(thr, -1, DUK_STRIDX_INT_TRACEDATA);
 	idx_td = duk_get_top_index(thr);
 
 	duk_push_hstring_stridx(thr, DUK_STRIDX_NEWLINE_4SPACE);
 	duk_push_this(thr);
 
 	/* [ ... this tracedata sep this ] */
 
 	/* XXX: skip null filename? */
 
 	if (duk_check_type(thr, idx_td, DUK_TYPE_OBJECT)) {
 		/* Current tracedata contains 2 entries per callstack entry. */
-		for (i = 0; ; i += 2) {
+		for (i = 0;; i += 2) {
 			duk_int_t pc;
 			duk_uint_t line;
 			duk_uint_t flags;
 			duk_double_t d;
 			const char *funcname;
 			const char *filename;
 			duk_hobject *h_func;
@@ -35040,54 +36060,61 @@
 						duk_push_uint(thr, line);
 						return 1;
 					}
 				}
 
 				/* XXX: Change 'anon' handling here too, to use empty string for anonymous functions? */
 				/* XXX: Could be improved by coercing to a readable duk_tval (especially string escaping) */
-				h_name = duk_get_hstring_notsymbol(thr, -2);  /* may be NULL */
+				h_name = duk_get_hstring_notsymbol(thr, -2); /* may be NULL */
 				funcname = (h_name == NULL || h_name == DUK_HTHREAD_STRING_EMPTY_STRING(thr)) ?
-				           "[anon]" : (const char *) DUK_HSTRING_GET_DATA(h_name);
+                                               "[anon]" :
+                                               (const char *) DUK_HSTRING_GET_DATA(h_name);
 				filename = duk_get_string_notsymbol(thr, -1);
 				filename = filename ? filename : "";
 				DUK_ASSERT(funcname != NULL);
 				DUK_ASSERT(filename != NULL);
 
-				h_func = duk_get_hobject(thr, -4);  /* NULL for lightfunc */
+				h_func = duk_get_hobject(thr, -4); /* NULL for lightfunc */
 
 				if (h_func == NULL) {
-					duk_push_sprintf(thr, "at %s light%s%s%s%s%s",
-					                 (const char *) funcname,
-					                 (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
+					duk_push_sprintf(
+					    thr,
+					    "at %s light%s%s%s%s%s",
+					    (const char *) funcname,
+					    (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
 				} else if (DUK_HOBJECT_HAS_NATFUNC(h_func)) {
-					duk_push_sprintf(thr, "at %s (%s) native%s%s%s%s%s",
-					                 (const char *) funcname,
-					                 (const char *) filename,
-					                 (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
+					duk_push_sprintf(
+					    thr,
+					    "at %s (%s) native%s%s%s%s%s",
+					    (const char *) funcname,
+					    (const char *) filename,
+					    (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
 				} else {
-					duk_push_sprintf(thr, "at %s (%s:%lu)%s%s%s%s%s",
-					                 (const char *) funcname,
-					                 (const char *) filename,
-					                 (unsigned long) line,
-					                 (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
-					                 (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
+					duk_push_sprintf(
+					    thr,
+					    "at %s (%s:%lu)%s%s%s%s%s",
+					    (const char *) funcname,
+					    (const char *) filename,
+					    (unsigned long) line,
+					    (const char *) ((flags & DUK_ACT_FLAG_STRICT) ? str_strict : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_TAILCALLED) ? str_tailcall : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_CONSTRUCT) ? str_construct : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_DIRECT_EVAL) ? str_directeval : str_empty),
+					    (const char *) ((flags & DUK_ACT_FLAG_PREVENT_YIELD) ? str_prevyield : str_empty));
 				}
-				duk_replace(thr, -5);   /* [ ... v1 v2 name filename str ] -> [ ... str v2 name filename ] */
-				duk_pop_3(thr);         /* -> [ ... str ] */
+				duk_replace(thr, -5); /* [ ... v1 v2 name filename str ] -> [ ... str v2 name filename ] */
+				duk_pop_3(thr); /* -> [ ... str ] */
 			} else if (t == DUK_TYPE_STRING) {
 				const char *str_file;
 
 				/*
 				 *  __FILE__ / __LINE__ entry, here 'pc' is line number directly.
 				 *  Sometimes __FILE__ / __LINE__ is reported as the source for
 				 *  the error (fileName, lineNumber), sometimes not.
@@ -35110,18 +36137,20 @@
 
 				/* Tracedata is trusted but avoid any risk of using a NULL
 				 * for %s format because it has undefined behavior.  Symbols
 				 * don't need to be explicitly rejected as they pose no memory
 				 * safety issues.
 				 */
 				str_file = (const char *) duk_get_string(thr, -2);
-				duk_push_sprintf(thr, "at [anon] (%s:%ld) internal",
-				                 (const char *) (str_file ? str_file : "null"), (long) pc);
-				duk_replace(thr, -3);  /* [ ... v1 v2 str ] -> [ ... str v2 ] */
-				duk_pop(thr);          /* -> [ ... str ] */
+				duk_push_sprintf(thr,
+				                 "at [anon] (%s:%ld) internal",
+				                 (const char *) (str_file ? str_file : "null"),
+				                 (long) pc);
+				duk_replace(thr, -3); /* [ ... v1 v2 str ] -> [ ... str v2 ] */
+				duk_pop(thr); /* -> [ ... str ] */
 			} else {
 				/* unknown, ignore */
 				duk_pop_2(thr);
 				break;
 			}
 		}
 
@@ -35160,15 +36189,15 @@
 	return duk__error_getter_helper(thr, DUK__OUTPUT_TYPE_FILENAME);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_hthread *thr) {
 	return duk__error_getter_helper(thr, DUK__OUTPUT_TYPE_LINENUMBER);
 }
 
-#else  /* DUK_USE_TRACEBACKS */
+#else /* DUK_USE_TRACEBACKS */
 
 /*
  *  Traceback handling when tracebacks disabled.
  *
  *  The fileName / lineNumber stubs are now necessary because built-in
  *  data will include the accessor properties in Error.prototype.  If those
  *  are removed for builds without tracebacks, these can also be removed.
@@ -35191,39 +36220,39 @@
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_hthread *thr) {
 	DUK_UNREF(thr);
 	return 0;
 }
 
-#endif  /* DUK_USE_TRACEBACKS */
+#endif /* DUK_USE_TRACEBACKS */
 
 DUK_LOCAL duk_ret_t duk__error_setter_helper(duk_hthread *thr, duk_small_uint_t stridx_key) {
 	/* Attempt to write 'stack', 'fileName', 'lineNumber' works as if
 	 * user code called Object.defineProperty() to create an overriding
 	 * own property.  This allows user code to overwrite .fileName etc
 	 * intuitively as e.g. "err.fileName = 'dummy'" as one might expect.
 	 * See https://github.com/svaarala/duktape/issues/387.
 	 */
 
-	DUK_ASSERT_TOP(thr, 1);  /* fixed arg count: value */
+	DUK_ASSERT_TOP(thr, 1); /* fixed arg count: value */
 
 	duk_push_this(thr);
 	duk_push_hstring_stridx(thr, stridx_key);
 	duk_dup_0(thr);
 
 	/* [ ... obj key value ] */
 
-	DUK_DD(DUK_DDPRINT("error setter: %!T %!T %!T",
-	                   duk_get_tval(thr, -3), duk_get_tval(thr, -2), duk_get_tval(thr, -1)));
+	DUK_DD(DUK_DDPRINT("error setter: %!T %!T %!T", duk_get_tval(thr, -3), duk_get_tval(thr, -2), duk_get_tval(thr, -1)));
 
-	duk_def_prop(thr, -3, DUK_DEFPROP_HAVE_VALUE |
-	                      DUK_DEFPROP_HAVE_WRITABLE | DUK_DEFPROP_WRITABLE |
-	                      DUK_DEFPROP_HAVE_ENUMERABLE | /*not enumerable*/
-	                      DUK_DEFPROP_HAVE_CONFIGURABLE | DUK_DEFPROP_CONFIGURABLE);
+	duk_def_prop(thr,
+	             -3,
+	             DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_HAVE_WRITABLE | DUK_DEFPROP_WRITABLE |
+	                 DUK_DEFPROP_HAVE_ENUMERABLE | /*not enumerable*/
+	                 DUK_DEFPROP_HAVE_CONFIGURABLE | DUK_DEFPROP_CONFIGURABLE);
 	return 0;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_error_prototype_stack_setter(duk_hthread *thr) {
 	return duk__error_setter_helper(thr, DUK_STRIDX_STACK);
 }
 
@@ -35263,25 +36292,25 @@
 	duk_hobject *outer_lex_env;
 	duk_hobject *outer_var_env;
 
 	/* normal and constructor calls have identical semantics */
 
 	nargs = duk_get_top(thr);
 	for (i = 0; i < nargs; i++) {
-		duk_to_string(thr, i);  /* Rejects Symbols during coercion. */
+		duk_to_string(thr, i); /* Rejects Symbols during coercion. */
 	}
 
 	if (nargs == 0) {
 		duk_push_hstring_empty(thr);
 		duk_push_hstring_empty(thr);
 	} else if (nargs == 1) {
 		/* XXX: cover this with the generic >1 case? */
 		duk_push_hstring_empty(thr);
 	} else {
-		duk_insert(thr, 0);   /* [ arg1 ... argN-1 body] -> [body arg1 ... argN-1] */
+		duk_insert(thr, 0); /* [ arg1 ... argN-1 body] -> [body arg1 ... argN-1] */
 		duk_push_literal(thr, ",");
 		duk_insert(thr, 1);
 		duk_join(thr, nargs - 1);
 	}
 
 	/* [ body formals ], formals is comma separated list that needs to be parsed */
 
@@ -35290,26 +36319,26 @@
 	/* XXX: this placeholder is not always correct, but use for now.
 	 * It will fail in corner cases; see test-dev-func-cons-args.js.
 	 */
 	duk_push_literal(thr, "function(");
 	duk_dup_1(thr);
 	duk_push_literal(thr, "){");
 	duk_dup_0(thr);
-	duk_push_literal(thr, "\n}");  /* Newline is important to handle trailing // comment. */
+	duk_push_literal(thr, "\n}"); /* Newline is important to handle trailing // comment. */
 	duk_concat(thr, 5);
 
 	/* [ body formals source ] */
 
 	DUK_ASSERT_TOP(thr, 3);
 
 	/* strictness is not inherited, intentional */
 	comp_flags = DUK_COMPILE_FUNCEXPR;
 
-	duk_push_hstring_stridx(thr, DUK_STRIDX_COMPILE);  /* XXX: copy from caller? */  /* XXX: ignored now */
-	h_sourcecode = duk_require_hstring(thr, -2);  /* no symbol check needed; -2 is concat'd code */
+	duk_push_hstring_stridx(thr, DUK_STRIDX_COMPILE); /* XXX: copy from caller? */ /* XXX: ignored now */
+	h_sourcecode = duk_require_hstring(thr, -2); /* no symbol check needed; -2 is concat'd code */
 	duk_js_compile(thr,
 	               (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_sourcecode),
 	               (duk_size_t) DUK_HSTRING_GET_BYTELEN(h_sourcecode),
 	               comp_flags);
 
 	/* Force .name to 'anonymous' (ES2015). */
 	duk_push_literal(thr, "anonymous");
@@ -35330,15 +36359,15 @@
 
 	duk_js_push_closure(thr, func, outer_var_env, outer_lex_env, 1 /*add_auto_proto*/);
 
 	/* [ body formals source template closure ] */
 
 	return 1;
 }
-#endif  /* DUK_USE_FUNCTION_BUILTIN */
+#endif /* DUK_USE_FUNCTION_BUILTIN */
 
 #if defined(DUK_USE_FUNCTION_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_function_prototype_to_string(duk_hthread *thr) {
 	duk_tval *tv;
 
 	/*
 	 *  E5 Section 15.3.4.2 places few requirements on the output of
@@ -35396,15 +36425,15 @@
 		duk_push_lightfunc_tostring(thr, tv);
 	} else {
 		goto type_error;
 	}
 
 	return 1;
 
- type_error:
+type_error:
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 }
 #endif
 
 /* Always present because the native function pointer is needed in call
  * handling.
  */
@@ -35438,28 +36467,28 @@
 /* Create a bound function which points to a target function which may
  * be bound or non-bound.  If the target is bound, the argument lists
  * and 'this' binding of the functions are merged and the resulting
  * function points directly to the non-bound target.
  */
 DUK_INTERNAL duk_ret_t duk_bi_function_prototype_bind(duk_hthread *thr) {
 	duk_hboundfunc *h_bound;
-	duk_idx_t nargs;  /* bound args, not counting 'this' binding */
+	duk_idx_t nargs; /* bound args, not counting 'this' binding */
 	duk_idx_t bound_nargs;
 	duk_int_t bound_len;
 	duk_tval *tv_prevbound;
 	duk_idx_t n_prevbound;
 	duk_tval *tv_res;
 	duk_tval *tv_tmp;
 
 	/* XXX: C API call, e.g. duk_push_bound_function(thr, target_idx, nargs); */
 
 	/* Vararg function, careful arg handling, e.g. thisArg may not
 	 * be present.
 	 */
-	nargs = duk_get_top(thr) - 1;  /* actual args, not counting 'this' binding */
+	nargs = duk_get_top(thr) - 1; /* actual args, not counting 'this' binding */
 	if (nargs < 0) {
 		nargs++;
 		duk_push_undefined(thr);
 	}
 	DUK_ASSERT(nargs >= 0);
 
 	/* Limit 'nargs' for bound functions to guarantee arithmetic
@@ -35546,15 +36575,15 @@
 
 		DUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv_tmp));
 		DUK_HOBJECT_SET_STRICT((duk_hobject *) h_bound);
 		bound_proto = thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE];
 		DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, (duk_hobject *) h_bound, bound_proto);
 	}
 
-	DUK_TVAL_INCREF(thr, &h_bound->target);  /* old values undefined, no decref needed */
+	DUK_TVAL_INCREF(thr, &h_bound->target); /* old values undefined, no decref needed */
 	DUK_TVAL_INCREF(thr, &h_bound->this_binding);
 
 	bound_nargs = n_prevbound + nargs;
 	if (bound_nargs > (duk_idx_t) DUK_HBOUNDFUNC_MAX_ARGS) {
 		DUK_DCERROR_RANGE_INVALID_COUNT(thr);
 	}
 	tv_res = (duk_tval *) DUK_ALLOC_CHECKED(thr, ((duk_size_t) bound_nargs) * sizeof(duk_tval));
@@ -35571,38 +36600,38 @@
 
 	/* [ thisArg arg1 ... argN func boundFunc ] */
 
 	/* Bound function 'length' property is interesting.
 	 * For lightfuncs, simply read the virtual property.
 	 */
 	duk_get_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH);
-	bound_len = duk_get_int(thr, -1);  /* ES2015: no coercion */
+	bound_len = duk_get_int(thr, -1); /* ES2015: no coercion */
 	if (bound_len < nargs) {
 		bound_len = 0;
 	} else {
 		bound_len -= nargs;
 	}
 	if (sizeof(duk_int_t) > 4 && bound_len > (duk_int_t) DUK_UINT32_MAX) {
 		bound_len = (duk_int_t) DUK_UINT32_MAX;
 	}
 	duk_pop(thr);
 	DUK_ASSERT(bound_len >= 0);
 	tv_tmp = thr->valstack_top++;
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(tv_tmp));
 	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv_tmp));
-	DUK_TVAL_SET_U32(tv_tmp, (duk_uint32_t) bound_len);  /* in-place update, fastint */
-	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_C);  /* attrs in E6 Section 9.2.4 */
+	DUK_TVAL_SET_U32(tv_tmp, (duk_uint32_t) bound_len); /* in-place update, fastint */
+	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_C); /* attrs in E6 Section 9.2.4 */
 
 	/* XXX: could these be virtual? */
 	/* Caller and arguments must use the same thrower, [[ThrowTypeError]]. */
 	duk_xdef_prop_stridx_thrower(thr, -1, DUK_STRIDX_CALLER);
 	duk_xdef_prop_stridx_thrower(thr, -1, DUK_STRIDX_LC_ARGUMENTS);
 
 	/* Function name and fileName (non-standard). */
-	duk_push_literal(thr, "bound ");  /* ES2015 19.2.3.2. */
+	duk_push_literal(thr, "bound "); /* ES2015 19.2.3.2. */
 	duk_get_prop_stridx(thr, -3, DUK_STRIDX_NAME);
 	if (!duk_is_string_notsymbol(thr, -1)) {
 		/* ES2015 has requirement to check that .name of target is a string
 		 * (also must check for Symbol); if not, targetName should be the
 		 * empty string.  ES2015 19.2.3.2.
 		 */
 		duk_pop(thr);
@@ -35615,15 +36644,15 @@
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_FILE_NAME, DUK_PROPDESC_FLAGS_C);
 #endif
 
 	DUK_DDD(DUK_DDDPRINT("created bound function: %!iT", (duk_tval *) duk_get_tval(thr, -1)));
 
 	return 1;
 }
-#endif  /* DUK_USE_FUNCTION_BUILTIN */
+#endif /* DUK_USE_FUNCTION_BUILTIN */
 
 /* %NativeFunctionPrototype% .length getter. */
 DUK_INTERNAL duk_ret_t duk_bi_native_function_length(duk_hthread *thr) {
 	duk_tval *tv;
 	duk_hnatfunc *h;
 	duk_int16_t func_nargs;
 
@@ -35646,15 +36675,15 @@
 		lf_len = DUK_LFUNC_FLAGS_GET_LENGTH(lf_flags);
 		duk_push_uint(thr, lf_len);
 	} else {
 		goto fail_type;
 	}
 	return 1;
 
- fail_type:
+fail_type:
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 }
 
 /* %NativeFunctionPrototype% .name getter. */
 DUK_INTERNAL duk_ret_t duk_bi_native_function_name(duk_hthread *thr) {
 	duk_tval *tv;
 	duk_hnatfunc *h;
@@ -35675,28 +36704,28 @@
 	} else if (DUK_TVAL_IS_LIGHTFUNC(tv)) {
 		duk_push_lightfunc_name(thr, tv);
 	} else {
 		goto fail_type;
 	}
 	return 1;
 
- fail_type:
+fail_type:
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 }
 
 #if defined(DUK_USE_SYMBOL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_function_prototype_hasinstance(duk_hthread *thr) {
 	/* This binding: RHS, stack index 0: LHS. */
 	duk_bool_t ret;
 
 	ret = duk_js_instanceof_ordinary(thr, DUK_GET_TVAL_POSIDX(thr, 0), DUK_GET_THIS_TVAL_PTR(thr));
 	duk_push_boolean(thr, ret);
 	return 1;
 }
-#endif  /* DUK_USE_SYMBOL_BUILTIN */
+#endif /* DUK_USE_SYMBOL_BUILTIN */
 #line 1 "duk_bi_global.c"
 /*
  *  Global object built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -35708,81 +36737,79 @@
  * lookups (no shifting) and no explicit check for x < 0x80 before table
  * lookup.
  */
 
 /* Macros for creating and checking bitmasks for character encoding.
  * Bit number is a bit counterintuitive, but minimizes code size.
  */
-#define DUK__MKBITS(a,b,c,d,e,f,g,h)  ((duk_uint8_t) ( \
-	((a) << 0) | ((b) << 1) | ((c) << 2) | ((d) << 3) | \
-	((e) << 4) | ((f) << 5) | ((g) << 6) | ((h) << 7) \
-	))
-#define DUK__CHECK_BITMASK(table,cp)  ((table)[(cp) >> 3] & (1 << ((cp) & 0x07)))
+#define DUK__MKBITS(a, b, c, d, e, f, g, h) \
+	((duk_uint8_t) (((a) << 0) | ((b) << 1) | ((c) << 2) | ((d) << 3) | ((e) << 4) | ((f) << 5) | ((g) << 6) | ((h) << 7)))
+#define DUK__CHECK_BITMASK(table, cp) ((table)[(cp) >> 3] & (1 << ((cp) &0x07)))
 
 /* E5.1 Section 15.1.3.3: uriReserved + uriUnescaped + '#' */
 DUK_LOCAL const duk_uint8_t duk__encode_uriunescaped_table[16] = {
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x00-0x0f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x10-0x1f */
-	DUK__MKBITS(0, 1, 0, 1, 1, 0, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x20-0x2f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 0, 1, 0, 1),  /* 0x30-0x3f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x40-0x4f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1),  /* 0x50-0x5f */
-	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x60-0x6f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 1, 0),  /* 0x70-0x7f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x00-0x0f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x10-0x1f */
+	DUK__MKBITS(0, 1, 0, 1, 1, 0, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x20-0x2f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 0, 1, 0, 1), /* 0x30-0x3f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x40-0x4f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1), /* 0x50-0x5f */
+	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x60-0x6f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 1, 0), /* 0x70-0x7f */
 };
 
 /* E5.1 Section 15.1.3.4: uriUnescaped */
 DUK_LOCAL const duk_uint8_t duk__encode_uricomponent_unescaped_table[16] = {
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x00-0x0f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x10-0x1f */
-	DUK__MKBITS(0, 1, 0, 0, 0, 0, 0, 1), DUK__MKBITS(1, 1, 1, 0, 0, 1, 1, 0),  /* 0x20-0x2f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 0, 0, 0, 0, 0, 0),  /* 0x30-0x3f */
-	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x40-0x4f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1),  /* 0x50-0x5f */
-	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x60-0x6f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 1, 0),  /* 0x70-0x7f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x00-0x0f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x10-0x1f */
+	DUK__MKBITS(0, 1, 0, 0, 0, 0, 0, 1), DUK__MKBITS(1, 1, 1, 0, 0, 1, 1, 0), /* 0x20-0x2f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 0, 0, 0, 0, 0, 0), /* 0x30-0x3f */
+	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x40-0x4f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1), /* 0x50-0x5f */
+	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x60-0x6f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 1, 0), /* 0x70-0x7f */
 };
 
 /* E5.1 Section 15.1.3.1: uriReserved + '#' */
 DUK_LOCAL const duk_uint8_t duk__decode_uri_reserved_table[16] = {
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x00-0x0f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x10-0x1f */
-	DUK__MKBITS(0, 0, 0, 1, 1, 0, 1, 0), DUK__MKBITS(0, 0, 0, 1, 1, 0, 0, 1),  /* 0x20-0x2f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 1, 1, 0, 1, 0, 1),  /* 0x30-0x3f */
-	DUK__MKBITS(1, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x40-0x4f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x50-0x5f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x60-0x6f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x70-0x7f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x00-0x0f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x10-0x1f */
+	DUK__MKBITS(0, 0, 0, 1, 1, 0, 1, 0), DUK__MKBITS(0, 0, 0, 1, 1, 0, 0, 1), /* 0x20-0x2f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 1, 1, 0, 1, 0, 1), /* 0x30-0x3f */
+	DUK__MKBITS(1, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x40-0x4f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x50-0x5f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x60-0x6f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x70-0x7f */
 };
 
 /* E5.1 Section 15.1.3.2: empty */
 DUK_LOCAL const duk_uint8_t duk__decode_uri_component_reserved_table[16] = {
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x00-0x0f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x10-0x1f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x20-0x2f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x30-0x3f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x40-0x4f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x50-0x5f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x60-0x6f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x70-0x7f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x00-0x0f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x10-0x1f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x20-0x2f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x30-0x3f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x40-0x4f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x50-0x5f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x60-0x6f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x70-0x7f */
 };
 
 #if defined(DUK_USE_SECTION_B)
 /* E5.1 Section B.2.2, step 7. */
 DUK_LOCAL const duk_uint8_t duk__escape_unescaped_table[16] = {
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x00-0x0f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0),  /* 0x10-0x1f */
-	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 1, 1, 0, 1, 1, 1),  /* 0x20-0x2f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 0, 0, 0, 0, 0, 0),  /* 0x30-0x3f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x40-0x4f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1),  /* 0x50-0x5f */
-	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1),  /* 0x60-0x6f */
-	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 0)   /* 0x70-0x7f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x00-0x0f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), /* 0x10-0x1f */
+	DUK__MKBITS(0, 0, 0, 0, 0, 0, 0, 0), DUK__MKBITS(0, 0, 1, 1, 0, 1, 1, 1), /* 0x20-0x2f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 0, 0, 0, 0, 0, 0), /* 0x30-0x3f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x40-0x4f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 1), /* 0x50-0x5f */
+	DUK__MKBITS(0, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), /* 0x60-0x6f */
+	DUK__MKBITS(1, 1, 1, 1, 1, 1, 1, 1), DUK__MKBITS(1, 1, 1, 0, 0, 0, 0, 0) /* 0x70-0x7f */
 };
-#endif  /* DUK_USE_SECTION_B */
+#endif /* DUK_USE_SECTION_B */
 
 typedef struct {
 	duk_hthread *thr;
 	duk_hstring *h_str;
 	duk_bufwriter_ctx bw;
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_start;
@@ -35815,28 +36842,28 @@
 	duk_codepoint_t cp;
 
 	tfm_ctx->thr = thr;
 
 	tfm_ctx->h_str = duk_to_hstring(thr, 0);
 	DUK_ASSERT(tfm_ctx->h_str != NULL);
 
-	DUK_BW_INIT_PUSHBUF(thr, &tfm_ctx->bw, DUK_HSTRING_GET_BYTELEN(tfm_ctx->h_str));  /* initial size guess */
+	DUK_BW_INIT_PUSHBUF(thr, &tfm_ctx->bw, DUK_HSTRING_GET_BYTELEN(tfm_ctx->h_str)); /* initial size guess */
 
 	tfm_ctx->p_start = DUK_HSTRING_GET_DATA(tfm_ctx->h_str);
 	tfm_ctx->p_end = tfm_ctx->p_start + DUK_HSTRING_GET_BYTELEN(tfm_ctx->h_str);
 	tfm_ctx->p = tfm_ctx->p_start;
 
 	while (tfm_ctx->p < tfm_ctx->p_end) {
 		cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &tfm_ctx->p, tfm_ctx->p_start, tfm_ctx->p_end);
 		callback(tfm_ctx, udata, cp);
 	}
 
 	DUK_BW_COMPACT(thr, &tfm_ctx->bw);
 
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if transform is safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if transform is safe. */
 	return 1;
 }
 
 DUK_LOCAL void duk__transform_callback_encode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 	duk_uint8_t xutf8_buf[DUK_UNICODE_MAX_XUTF8_LENGTH];
 	duk_small_int_t len;
 	duk_codepoint_t cp1, cp2;
@@ -35854,15 +36881,19 @@
 	} else if ((cp < 0x80L) && DUK__CHECK_BITMASK(unescaped_table, cp)) {
 		DUK_BW_WRITE_RAW_U8(tfm_ctx->thr, &tfm_ctx->bw, (duk_uint8_t) cp);
 		return;
 	} else if (cp >= 0xdc00L && cp <= 0xdfffL) {
 		goto uri_error;
 	} else if (cp >= 0xd800L && cp <= 0xdbffL) {
 		/* Needs lookahead */
-		if (duk_unicode_decode_xutf8(tfm_ctx->thr, &tfm_ctx->p, tfm_ctx->p_start, tfm_ctx->p_end, (duk_ucodepoint_t *) &cp2) == 0) {
+		if (duk_unicode_decode_xutf8(tfm_ctx->thr,
+		                             &tfm_ctx->p,
+		                             tfm_ctx->p_start,
+		                             tfm_ctx->p_end,
+		                             (duk_ucodepoint_t *) &cp2) == 0) {
 			goto uri_error;
 		}
 		if (!(cp2 >= 0xdc00L && cp2 <= 0xdfffL)) {
 			goto uri_error;
 		}
 		cp1 = cp;
 		cp = (duk_codepoint_t) (((cp1 - 0xd800L) << 10) + (cp2 - 0xdc00L) + 0x10000L);
@@ -35885,42 +36916,42 @@
 	len = duk_unicode_encode_xutf8((duk_ucodepoint_t) cp, xutf8_buf);
 	for (i = 0; i < len; i++) {
 		t = (duk_small_int_t) xutf8_buf[i];
 		DUK_BW_WRITE_RAW_U8_3(tfm_ctx->thr,
 		                      &tfm_ctx->bw,
 		                      DUK_ASC_PERCENT,
 		                      (duk_uint8_t) duk_uc_nybbles[t >> 4],
-                                      (duk_uint8_t) duk_uc_nybbles[t & 0x0f]);
+		                      (duk_uint8_t) duk_uc_nybbles[t & 0x0f]);
 	}
 
 	return;
 
- uri_error:
+uri_error:
 	DUK_ERROR_URI(tfm_ctx->thr, DUK_STR_INVALID_INPUT);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__transform_callback_decode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 	const duk_uint8_t *reserved_table = (const duk_uint8_t *) udata;
 	duk_small_uint_t utf8_blen;
 	duk_codepoint_t min_cp;
-	duk_small_int_t t;  /* must be signed */
+	duk_small_int_t t; /* must be signed */
 	duk_small_uint_t i;
 
 	/* Maximum write size: XUTF8 path writes max DUK_UNICODE_MAX_XUTF8_LENGTH,
 	 * percent escape path writes max two times CESU-8 encoded BMP length.
 	 */
 	DUK_BW_ENSURE(tfm_ctx->thr,
 	              &tfm_ctx->bw,
-	              (DUK_UNICODE_MAX_XUTF8_LENGTH >= 2 * DUK_UNICODE_MAX_CESU8_BMP_LENGTH ?
-	              DUK_UNICODE_MAX_XUTF8_LENGTH : DUK_UNICODE_MAX_CESU8_BMP_LENGTH));
+	              (DUK_UNICODE_MAX_XUTF8_LENGTH >= 2 * DUK_UNICODE_MAX_CESU8_BMP_LENGTH ? DUK_UNICODE_MAX_XUTF8_LENGTH :
+                                                                                              DUK_UNICODE_MAX_CESU8_BMP_LENGTH));
 
 	if (cp == (duk_codepoint_t) '%') {
 		const duk_uint8_t *p = tfm_ctx->p;
-		duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);  /* bytes left */
+		duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p); /* bytes left */
 
 		DUK_DDD(DUK_DDDPRINT("percent encoding, left=%ld", (long) left));
 
 		if (left < 2) {
 			goto uri_error;
 		}
 
@@ -35930,19 +36961,15 @@
 			goto uri_error;
 		}
 
 		if (t < 0x80) {
 			if (DUK__CHECK_BITMASK(reserved_table, t)) {
 				/* decode '%xx' to '%xx' if decoded char in reserved set */
 				DUK_ASSERT(tfm_ctx->p - 1 >= tfm_ctx->p_start);
-				DUK_BW_WRITE_RAW_U8_3(tfm_ctx->thr,
-				                      &tfm_ctx->bw,
-				                      DUK_ASC_PERCENT,
-				                      p[0],
-				                      p[1]);
+				DUK_BW_WRITE_RAW_U8_3(tfm_ctx->thr, &tfm_ctx->bw, DUK_ASC_PERCENT, p[0], p[1]);
 			} else {
 				DUK_BW_WRITE_RAW_U8(tfm_ctx->thr, &tfm_ctx->bw, (duk_uint8_t) t);
 			}
 			tfm_ctx->p += 2;
 			return;
 		}
 
@@ -35985,25 +37012,28 @@
 		}
 
 		p += 3;
 		for (i = 1; i < utf8_blen; i++) {
 			/* p points to digit part ('%xy', p points to 'x') */
 			t = duk__decode_hex_escape(p, 2);
 			DUK_DDD(DUK_DDDPRINT("i=%ld utf8_blen=%ld cp=%ld t=0x%02lx",
-			                     (long) i, (long) utf8_blen, (long) cp, (unsigned long) t));
+			                     (long) i,
+			                     (long) utf8_blen,
+			                     (long) cp,
+			                     (unsigned long) t));
 			if (t < 0) {
 				goto uri_error;
 			}
 			if ((t & 0xc0) != 0x80) {
 				goto uri_error;
 			}
 			cp = (cp << 6) + (t & 0x3f);
 			p += 3;
 		}
-		p--;  /* p overshoots */
+		p--; /* p overshoots */
 		tfm_ctx->p = p;
 
 		DUK_DDD(DUK_DDDPRINT("final cp=%ld, min_cp=%ld", (long) cp, (long) min_cp));
 
 		if (cp < min_cp || cp > 0x10ffffL || (cp >= 0xd800L && cp <= 0xdfffL)) {
 			goto uri_error;
 		}
@@ -36029,15 +37059,15 @@
 			DUK_BW_WRITE_RAW_XUTF8(tfm_ctx->thr, &tfm_ctx->bw, cp);
 		}
 	} else {
 		DUK_BW_WRITE_RAW_XUTF8(tfm_ctx->thr, &tfm_ctx->bw, cp);
 	}
 	return;
 
- uri_error:
+uri_error:
 	DUK_ERROR_URI(tfm_ctx->thr, DUK_STR_INVALID_INPUT);
 	DUK_WO_NORETURN(return;);
 }
 
 #if defined(DUK_USE_SECTION_B)
 DUK_LOCAL void duk__transform_callback_escape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 	DUK_UNREF(udata);
@@ -36070,42 +37100,40 @@
 		 * escape() and unescape() are legacy functions, we don't.
 		 */
 		goto esc_error;
 	}
 
 	return;
 
- esc_error:
+esc_error:
 	DUK_ERROR_TYPE(tfm_ctx->thr, DUK_STR_INVALID_INPUT);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__transform_callback_unescape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 	duk_small_int_t t;
 
 	DUK_UNREF(udata);
 
 	if (cp == (duk_codepoint_t) '%') {
 		const duk_uint8_t *p = tfm_ctx->p;
-		duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);  /* bytes left */
+		duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p); /* bytes left */
 
-		if (left >= 5 && p[0] == 'u' &&
-		    ((t = duk__decode_hex_escape(p + 1, 4)) >= 0)) {
+		if (left >= 5 && p[0] == 'u' && ((t = duk__decode_hex_escape(p + 1, 4)) >= 0)) {
 			cp = (duk_codepoint_t) t;
 			tfm_ctx->p += 5;
-		} else if (left >= 2 &&
-		           ((t = duk__decode_hex_escape(p, 2)) >= 0)) {
+		} else if (left >= 2 && ((t = duk__decode_hex_escape(p, 2)) >= 0)) {
 			cp = (duk_codepoint_t) t;
 			tfm_ctx->p += 2;
 		}
 	}
 
 	DUK_BW_WRITE_ENSURE_XUTF8(tfm_ctx->thr, &tfm_ctx->bw, cp);
 }
-#endif  /* DUK_USE_SECTION_B */
+#endif /* DUK_USE_SECTION_B */
 
 /*
  *  Eval
  *
  *  Eval needs to handle both a "direct eval" and an "indirect eval".
  *  Direct eval handling needs access to the caller's activation so that its
  *  lexical environment can be accessed.  A direct eval is only possible from
@@ -36122,71 +37150,67 @@
 	duk_hobject *outer_lex_env;
 	duk_hobject *outer_var_env;
 	duk_bool_t this_to_global = 1;
 	duk_small_uint_t comp_flags;
 	duk_int_t level = -2;
 	duk_small_uint_t call_flags;
 
-	DUK_ASSERT(duk_get_top(thr) == 1 || duk_get_top(thr) == 2);  /* 2 when called by debugger */
-	DUK_ASSERT(thr->callstack_top >= 1);  /* at least this function exists */
+	DUK_ASSERT(duk_get_top(thr) == 1 || duk_get_top(thr) == 2); /* 2 when called by debugger */
+	DUK_ASSERT(thr->callstack_top >= 1); /* at least this function exists */
 	DUK_ASSERT(thr->callstack_curr != NULL);
 	DUK_ASSERT((thr->callstack_curr->flags & DUK_ACT_FLAG_DIRECT_EVAL) == 0 || /* indirect eval */
-	           (thr->callstack_top >= 2));  /* if direct eval, calling activation must exist */
+	           (thr->callstack_top >= 2)); /* if direct eval, calling activation must exist */
 
 	/*
 	 *  callstack_top - 1 --> this function
 	 *  callstack_top - 2 --> caller (may not exist)
 	 *
 	 *  If called directly from C, callstack_top might be 1.  If calling
 	 *  activation doesn't exist, call must be indirect.
 	 */
 
 	h = duk_get_hstring_notsymbol(thr, 0);
 	if (!h) {
 		/* Symbol must be returned as is, like any non-string values. */
-		return 1;  /* return arg as-is */
+		return 1; /* return arg as-is */
 	}
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	/* NOTE: level is used only by the debugger and should never be present
 	 * for an ECMAScript eval().
 	 */
-	DUK_ASSERT(level == -2);  /* by default, use caller's environment */
+	DUK_ASSERT(level == -2); /* by default, use caller's environment */
 	if (duk_get_top(thr) >= 2 && duk_is_number(thr, 1)) {
 		level = duk_get_int(thr, 1);
 	}
-	DUK_ASSERT(level <= -2);  /* This is guaranteed by debugger code. */
+	DUK_ASSERT(level <= -2); /* This is guaranteed by debugger code. */
 #endif
 
 	/* [ source ] */
 
 	comp_flags = DUK_COMPILE_EVAL;
-	act_eval = thr->callstack_curr;  /* this function */
+	act_eval = thr->callstack_curr; /* this function */
 	DUK_ASSERT(act_eval != NULL);
 	act_caller = duk_hthread_get_activation_for_level(thr, level);
 	if (act_caller != NULL) {
 		/* Have a calling activation, check for direct eval (otherwise
 		 * assume indirect eval.
 		 */
-		if ((act_caller->flags & DUK_ACT_FLAG_STRICT) &&
-		    (act_eval->flags & DUK_ACT_FLAG_DIRECT_EVAL)) {
+		if ((act_caller->flags & DUK_ACT_FLAG_STRICT) && (act_eval->flags & DUK_ACT_FLAG_DIRECT_EVAL)) {
 			/* Only direct eval inherits strictness from calling code
 			 * (E5.1 Section 10.1.1).
 			 */
 			comp_flags |= DUK_COMPILE_STRICT;
 		}
 	} else {
 		DUK_ASSERT((act_eval->flags & DUK_ACT_FLAG_DIRECT_EVAL) == 0);
 	}
 
-	duk_push_hstring_stridx(thr, DUK_STRIDX_INPUT);  /* XXX: copy from caller? */
-	duk_js_compile(thr,
-	               (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h),
-	               (duk_size_t) DUK_HSTRING_GET_BYTELEN(h),
-	               comp_flags);
+	duk_push_hstring_stridx(thr, DUK_STRIDX_INPUT); /* XXX: copy from caller? */
+	duk_js_compile(thr, (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h), (duk_size_t) DUK_HSTRING_GET_BYTELEN(h), comp_flags);
 	func = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC((duk_hobject *) func));
 
 	/* [ source template ] */
 
 	/* E5 Section 10.4.2 */
 
@@ -36211,29 +37235,29 @@
 
 			DUK_DDD(DUK_DDDPRINT("direct eval call to a strict function -> "
 			                     "var_env and lex_env to a fresh env, "
 			                     "this_binding to caller's this_binding"));
 
 			act_lex_env = act_caller->lex_env;
 
-			new_env = duk_hdecenv_alloc(thr,
-			                            DUK_HOBJECT_FLAG_EXTENSIBLE |
-			                            DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
+			new_env =
+			    duk_hdecenv_alloc(thr,
+			                      DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
 			DUK_ASSERT(new_env != NULL);
 			duk_push_hobject(thr, (duk_hobject *) new_env);
 
 			DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) new_env) == NULL);
 			DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) new_env, act_lex_env);
 			DUK_HOBJECT_INCREF_ALLOWNULL(thr, act_lex_env);
 			DUK_DDD(DUK_DDDPRINT("new_env allocated: %!iO", (duk_heaphdr *) new_env));
 
 			outer_lex_env = (duk_hobject *) new_env;
 			outer_var_env = (duk_hobject *) new_env;
 
-			duk_insert(thr, 0);  /* stash to bottom of value stack to keep new_env reachable for duration of eval */
+			duk_insert(thr, 0); /* stash to bottom of value stack to keep new_env reachable for duration of eval */
 
 			/* compiler's responsibility */
 			DUK_ASSERT(DUK_HOBJECT_HAS_NEWENV((duk_hobject *) func));
 		} else {
 			DUK_DDD(DUK_DDDPRINT("direct eval call to a non-strict function -> "
 			                     "var_env and lex_env to caller's envs, "
 			                     "this_binding to caller's this_binding"));
@@ -36261,15 +37285,16 @@
 	if (this_to_global) {
 		DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
 		duk_push_hobject_bidx(thr, DUK_BIDX_GLOBAL);
 	} else {
 		duk_tval *tv;
 		DUK_ASSERT(thr->callstack_top >= 2);
 		DUK_ASSERT(act_caller != NULL);
-		tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act_caller->bottom_byteoff - sizeof(duk_tval));  /* this is just beneath bottom */
+		tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act_caller->bottom_byteoff -
+		                            sizeof(duk_tval)); /* this is just beneath bottom */
 		DUK_ASSERT(tv >= thr->valstack);
 		duk_push_tval(thr, tv);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("eval -> lex_env=%!iO, var_env=%!iO, this_binding=%!T",
 	                     (duk_heaphdr *) outer_lex_env,
 	                     (duk_heaphdr *) outer_var_env,
@@ -36300,27 +37325,23 @@
 
 #if defined(DUK_USE_GLOBAL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_parse_int(duk_hthread *thr) {
 	duk_int32_t radix;
 	duk_small_uint_t s2n_flags;
 
 	DUK_ASSERT_TOP(thr, 2);
-	duk_to_string(thr, 0);  /* Reject symbols. */
+	duk_to_string(thr, 0); /* Reject symbols. */
 
 	radix = duk_to_int32(thr, 1);
 
 	/* While parseInt() recognizes 0xdeadbeef, it doesn't recognize
 	 * ES2015 0o123 or 0b10001.
 	 */
-	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE |
-	            DUK_S2N_FLAG_ALLOW_GARBAGE |
-	            DUK_S2N_FLAG_ALLOW_PLUS |
-	            DUK_S2N_FLAG_ALLOW_MINUS |
-	            DUK_S2N_FLAG_ALLOW_LEADING_ZERO |
-	            DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT;
+	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE | DUK_S2N_FLAG_ALLOW_GARBAGE | DUK_S2N_FLAG_ALLOW_PLUS | DUK_S2N_FLAG_ALLOW_MINUS |
+	            DUK_S2N_FLAG_ALLOW_LEADING_ZERO | DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT;
 
 	/* Specification stripPrefix maps to DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT.
 	 *
 	 * Don't autodetect octals (from leading zeroes), require user code to
 	 * provide an explicit radix 8 for parsing octal.  See write-up from Mozilla:
 	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt#ECMAScript_5_Removes_Octal_Interpretation
 	 */
@@ -36336,95 +37357,92 @@
 		radix = 10;
 	}
 
 	duk_dup_0(thr);
 	duk_numconv_parse(thr, (duk_small_int_t) radix, s2n_flags);
 	return 1;
 
- ret_nan:
+ret_nan:
 	duk_push_nan(thr);
 	return 1;
 }
-#endif  /* DUK_USE_GLOBAL_BUILTIN */
+#endif /* DUK_USE_GLOBAL_BUILTIN */
 
 #if defined(DUK_USE_GLOBAL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_parse_float(duk_hthread *thr) {
 	duk_small_uint_t s2n_flags;
 
 	DUK_ASSERT_TOP(thr, 1);
-	duk_to_string(thr, 0);  /* Reject symbols. */
+	duk_to_string(thr, 0); /* Reject symbols. */
 
 	/* XXX: check flags */
-	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE |
-	            DUK_S2N_FLAG_ALLOW_EXP |
-	            DUK_S2N_FLAG_ALLOW_GARBAGE |
-	            DUK_S2N_FLAG_ALLOW_PLUS |
-	            DUK_S2N_FLAG_ALLOW_MINUS |
-	            DUK_S2N_FLAG_ALLOW_INF |
-	            DUK_S2N_FLAG_ALLOW_FRAC |
-	            DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
-	            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC |
-	            DUK_S2N_FLAG_ALLOW_LEADING_ZERO;
+	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE | DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_GARBAGE | DUK_S2N_FLAG_ALLOW_PLUS |
+	            DUK_S2N_FLAG_ALLOW_MINUS | DUK_S2N_FLAG_ALLOW_INF | DUK_S2N_FLAG_ALLOW_FRAC | DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
+	            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC | DUK_S2N_FLAG_ALLOW_LEADING_ZERO;
 
 	duk_numconv_parse(thr, 10 /*radix*/, s2n_flags);
 	return 1;
 }
-#endif  /* DUK_USE_GLOBAL_BUILTIN */
+#endif /* DUK_USE_GLOBAL_BUILTIN */
 
 /*
  *  Number checkers
  */
 
 #if defined(DUK_USE_GLOBAL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_is_nan(duk_hthread *thr) {
 	duk_double_t d = duk_to_number(thr, 0);
 	duk_push_boolean(thr, (duk_bool_t) DUK_ISNAN(d));
 	return 1;
 }
-#endif  /* DUK_USE_GLOBAL_BUILTIN */
+#endif /* DUK_USE_GLOBAL_BUILTIN */
 
 #if defined(DUK_USE_GLOBAL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_is_finite(duk_hthread *thr) {
 	duk_double_t d = duk_to_number(thr, 0);
 	duk_push_boolean(thr, (duk_bool_t) DUK_ISFINITE(d));
 	return 1;
 }
-#endif  /* DUK_USE_GLOBAL_BUILTIN */
+#endif /* DUK_USE_GLOBAL_BUILTIN */
 
 /*
  *  URI handling
  */
 
 #if defined(DUK_USE_GLOBAL_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_decode_uri(duk_hthread *thr) {
 	return duk__transform_helper(thr, duk__transform_callback_decode_uri, (const void *) duk__decode_uri_reserved_table);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_global_object_decode_uri_component(duk_hthread *thr) {
-	return duk__transform_helper(thr, duk__transform_callback_decode_uri, (const void *) duk__decode_uri_component_reserved_table);
+	return duk__transform_helper(thr,
+	                             duk__transform_callback_decode_uri,
+	                             (const void *) duk__decode_uri_component_reserved_table);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_global_object_encode_uri(duk_hthread *thr) {
 	return duk__transform_helper(thr, duk__transform_callback_encode_uri, (const void *) duk__encode_uriunescaped_table);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_global_object_encode_uri_component(duk_hthread *thr) {
-	return duk__transform_helper(thr, duk__transform_callback_encode_uri, (const void *) duk__encode_uricomponent_unescaped_table);
+	return duk__transform_helper(thr,
+	                             duk__transform_callback_encode_uri,
+	                             (const void *) duk__encode_uricomponent_unescaped_table);
 }
 
 #if defined(DUK_USE_SECTION_B)
 DUK_INTERNAL duk_ret_t duk_bi_global_object_escape(duk_hthread *thr) {
 	return duk__transform_helper(thr, duk__transform_callback_escape, (const void *) NULL);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_global_object_unescape(duk_hthread *thr) {
 	return duk__transform_helper(thr, duk__transform_callback_unescape, (const void *) NULL);
 }
-#endif  /* DUK_USE_SECTION_B */
-#endif  /* DUK_USE_GLOBAL_BUILTIN */
+#endif /* DUK_USE_SECTION_B */
+#endif /* DUK_USE_GLOBAL_BUILTIN */
 
 /* automatic undefs */
 #undef DUK__CHECK_BITMASK
 #undef DUK__MKBITS
 #line 1 "duk_bi_json.c"
 /*
  *  JSON built-ins.
@@ -36446,19 +37464,19 @@
 
 #if defined(DUK_USE_JSON_SUPPORT)
 
 /*
  *  Local defines and forward declarations.
  */
 
-#define DUK__JSON_DECSTR_BUFSIZE 128
-#define DUK__JSON_DECSTR_CHUNKSIZE 64
-#define DUK__JSON_ENCSTR_CHUNKSIZE 64
+#define DUK__JSON_DECSTR_BUFSIZE    128
+#define DUK__JSON_DECSTR_CHUNKSIZE  64
+#define DUK__JSON_ENCSTR_CHUNKSIZE  64
 #define DUK__JSON_STRINGIFY_BUFSIZE 128
-#define DUK__JSON_MAX_ESC_LEN 10  /* '\Udeadbeef' */
+#define DUK__JSON_MAX_ESC_LEN       10 /* '\Udeadbeef' */
 
 DUK_LOCAL_DECL void duk__json_dec_syntax_error(duk_json_dec_ctx *js_ctx);
 DUK_LOCAL_DECL void duk__json_dec_eat_white(duk_json_dec_ctx *js_ctx);
 #if defined(DUK_USE_JX)
 DUK_LOCAL_DECL duk_uint8_t duk__json_dec_peek(duk_json_dec_ctx *js_ctx);
 #endif
 DUK_LOCAL_DECL duk_uint8_t duk__json_dec_get(duk_json_dec_ctx *js_ctx);
@@ -36520,111 +37538,96 @@
 DUK_LOCAL const duk_uint8_t duk__json_quotestr_lookup[256] = {
 	/* 0x00 ... 0x7f: as is
 	 * 0x80: escape generically
 	 * 0x81: slow path
 	 * 0xa0 ... 0xff: backslash + one char
 	 */
 
-	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe2, 0xf4, 0xee, 0x80, 0xe6, 0xf2, 0x80, 0x80,
-	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
-	0x20, 0x21, 0xa2, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
-	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
-	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0xdc, 0x5d, 0x5e, 0x5f,
-	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
-	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
-	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe2, 0xf4, 0xee, 0x80, 0xe6, 0xf2, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
+	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x20, 0x21, 0xa2, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
+	0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0xdc, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
+	0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
+	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 	0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81
 };
-#else  /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
-DUK_LOCAL const duk_uint8_t duk__json_quotestr_esc[14] = {
-	DUK_ASC_NUL, DUK_ASC_NUL, DUK_ASC_NUL, DUK_ASC_NUL,
-	DUK_ASC_NUL, DUK_ASC_NUL, DUK_ASC_NUL, DUK_ASC_NUL,
-	DUK_ASC_LC_B, DUK_ASC_LC_T, DUK_ASC_LC_N, DUK_ASC_NUL,
-	DUK_ASC_LC_F, DUK_ASC_LC_R
-};
-#endif  /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
+#else /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
+DUK_LOCAL const duk_uint8_t duk__json_quotestr_esc[14] = { DUK_ASC_NUL,  DUK_ASC_NUL, DUK_ASC_NUL,  DUK_ASC_NUL,  DUK_ASC_NUL,
+	                                                   DUK_ASC_NUL,  DUK_ASC_NUL, DUK_ASC_NUL,  DUK_ASC_LC_B, DUK_ASC_LC_T,
+	                                                   DUK_ASC_LC_N, DUK_ASC_NUL, DUK_ASC_LC_F, DUK_ASC_LC_R };
+#endif /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
 
 #if defined(DUK_USE_JSON_DECSTRING_FASTPATH)
 DUK_LOCAL const duk_uint8_t duk__json_decstr_lookup[256] = {
 	/* 0x00: slow path
 	 * other: as is
 	 */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x20, 0x21, 0x00, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
-	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
-	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
-	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x5d, 0x5e, 0x5f,
-	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
-	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
-	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
-	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
-	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
-	0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
-	0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
-	0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
-	0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x23, 0x24, 0x25, 0x26, 0x27,
+	0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
+	0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
+	0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+	0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,
+	0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
+	0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
+	0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
+	0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
+	0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 	0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
 };
-#endif  /* DUK_USE_JSON_DECSTRING_FASTPATH */
+#endif /* DUK_USE_JSON_DECSTRING_FASTPATH */
 
 #if defined(DUK_USE_JSON_EATWHITE_FASTPATH)
 DUK_LOCAL const duk_uint8_t duk__json_eatwhite_lookup[256] = {
 	/* 0x00: finish (non-white)
 	 * 0x01: continue
 	 */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
-#endif  /* DUK_USE_JSON_EATWHITE_FASTPATH */
+#endif /* DUK_USE_JSON_EATWHITE_FASTPATH */
 
 #if defined(DUK_USE_JSON_DECNUMBER_FASTPATH)
 DUK_LOCAL const duk_uint8_t duk__json_decnumber_lookup[256] = {
 	/* 0x00: finish (not part of number)
 	 * 0x01: continue
 	 */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00,
-	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
 };
-#endif  /* DUK_USE_JSON_DECNUMBER_FASTPATH */
+#endif /* DUK_USE_JSON_DECNUMBER_FASTPATH */
 
 /*
  *  Parsing implementation.
  *
  *  JSON lexer is now separate from duk_lexer.c because there are numerous
  *  small differences making it difficult to share the lexer.
  *
@@ -36636,16 +37639,15 @@
  */
 
 DUK_LOCAL void duk__json_dec_syntax_error(duk_json_dec_ctx *js_ctx) {
 	/* Shared handler to minimize parser size.  Cause will be
 	 * hidden, unfortunately, but we'll have an offset which
 	 * is often quite enough.
 	 */
-	DUK_ERROR_FMT1(js_ctx->thr, DUK_ERR_SYNTAX_ERROR, DUK_STR_FMT_INVALID_JSON,
-	               (long) (js_ctx->p - js_ctx->p_start));
+	DUK_ERROR_FMT1(js_ctx->thr, DUK_ERR_SYNTAX_ERROR, DUK_STR_FMT_INVALID_JSON, (long) (js_ctx->p - js_ctx->p_start));
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__json_dec_eat_white(duk_json_dec_ctx *js_ctx) {
 	const duk_uint8_t *p;
 	duk_uint8_t t;
 
@@ -36654,26 +37656,26 @@
 		DUK_ASSERT(p <= js_ctx->p_end);
 		t = *p;
 
 #if defined(DUK_USE_JSON_EATWHITE_FASTPATH)
 		/* This fast path is pretty marginal in practice.
 		 * XXX: candidate for removal.
 		 */
-		DUK_ASSERT(duk__json_eatwhite_lookup[0x00] == 0x00);  /* end-of-input breaks */
+		DUK_ASSERT(duk__json_eatwhite_lookup[0x00] == 0x00); /* end-of-input breaks */
 		if (duk__json_eatwhite_lookup[t] == 0) {
 			break;
 		}
-#else  /* DUK_USE_JSON_EATWHITE_FASTPATH */
+#else /* DUK_USE_JSON_EATWHITE_FASTPATH */
 		if (!(t == 0x20 || t == 0x0a || t == 0x0d || t == 0x09)) {
 			/* NUL also comes here.  Comparison order matters, 0x20
 			 * is most common whitespace.
 			 */
 			break;
 		}
-#endif  /* DUK_USE_JSON_EATWHITE_FASTPATH */
+#endif /* DUK_USE_JSON_EATWHITE_FASTPATH */
 		p++;
 	}
 	js_ctx->p = p;
 }
 
 #if defined(DUK_USE_JX)
 DUK_LOCAL duk_uint8_t duk__json_dec_peek(duk_json_dec_ctx *js_ctx) {
@@ -36699,16 +37701,15 @@
 	duk_uint8_t x;
 	duk_small_int_t t;
 
 	for (i = 0; i < n; i++) {
 		/* XXX: share helper from lexer; duk_lexer.c / hexval(). */
 
 		x = duk__json_dec_get(js_ctx);
-		DUK_DDD(DUK_DDDPRINT("decode_hex_escape: i=%ld, n=%ld, res=%ld, x=%ld",
-		                     (long) i, (long) n, (long) res, (long) x));
+		DUK_DDD(DUK_DDDPRINT("decode_hex_escape: i=%ld, n=%ld, res=%ld, x=%ld", (long) i, (long) n, (long) res, (long) x));
 
 		/* x == 0x00 (EOF) causes syntax_error */
 		DUK_ASSERT(duk_hex_dectab[0] == -1);
 		t = duk_hex_dectab[x & 0xff];
 		if (DUK_LIKELY(t >= 0)) {
 			res = (res * 16) + (duk_uint_fast32_t) t;
 		} else {
@@ -36716,15 +37717,15 @@
 			goto syntax_error;
 		}
 	}
 
 	DUK_DDD(DUK_DDDPRINT("final hex decoded value: %ld", (long) res));
 	return res;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 	return 0;
 }
 
 DUK_LOCAL void duk__json_dec_req_stridx(duk_json_dec_ctx *js_ctx, duk_small_uint_t stridx) {
 	duk_hstring *h;
@@ -36737,15 +37738,15 @@
 	 */
 
 	DUK_ASSERT_STRIDX_VALID(stridx);
 	h = DUK_HTHREAD_GET_STRING(js_ctx->thr, stridx);
 	DUK_ASSERT(h != NULL);
 
 	p = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h) + 1;
-	DUK_ASSERT(*(js_ctx->p - 1) == *(p - 1));  /* first character has been matched */
+	DUK_ASSERT(*(js_ctx->p - 1) == *(p - 1)); /* first character has been matched */
 
 	for (;;) {
 		x = *p;
 		if (x == 0) {
 			break;
 		}
 		y = duk__json_dec_get(js_ctx);
@@ -36754,61 +37755,74 @@
 			goto syntax_error;
 		}
 		p++;
 	}
 
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
 
 DUK_LOCAL duk_small_int_t duk__json_dec_string_escape(duk_json_dec_ctx *js_ctx, duk_uint8_t **ext_p) {
 	duk_uint_fast32_t cp;
 
 	/* EOF (-1) will be cast to an unsigned value first
 	 * and then re-cast for the switch.  In any case, it
 	 * will match the default case (syntax error).
 	 */
 	cp = (duk_uint_fast32_t) duk__json_dec_get(js_ctx);
 	switch (cp) {
-	case DUK_ASC_BACKSLASH: break;
-	case DUK_ASC_DOUBLEQUOTE: break;
-	case DUK_ASC_SLASH: break;
-	case DUK_ASC_LC_T: cp = 0x09; break;
-	case DUK_ASC_LC_N: cp = 0x0a; break;
-	case DUK_ASC_LC_R: cp = 0x0d; break;
-	case DUK_ASC_LC_F: cp = 0x0c; break;
-	case DUK_ASC_LC_B: cp = 0x08; break;
+	case DUK_ASC_BACKSLASH:
+		break;
+	case DUK_ASC_DOUBLEQUOTE:
+		break;
+	case DUK_ASC_SLASH:
+		break;
+	case DUK_ASC_LC_T:
+		cp = 0x09;
+		break;
+	case DUK_ASC_LC_N:
+		cp = 0x0a;
+		break;
+	case DUK_ASC_LC_R:
+		cp = 0x0d;
+		break;
+	case DUK_ASC_LC_F:
+		cp = 0x0c;
+		break;
+	case DUK_ASC_LC_B:
+		cp = 0x08;
+		break;
 	case DUK_ASC_LC_U: {
 		cp = duk__json_dec_decode_hex_escape(js_ctx, 4);
 		break;
 	}
 #if defined(DUK_USE_JX)
 	case DUK_ASC_UC_U: {
 		if (js_ctx->flag_ext_custom) {
 			cp = duk__json_dec_decode_hex_escape(js_ctx, 8);
 		} else {
-			return 1;  /* syntax error */
+			return 1; /* syntax error */
 		}
 		break;
 	}
 	case DUK_ASC_LC_X: {
 		if (js_ctx->flag_ext_custom) {
 			cp = duk__json_dec_decode_hex_escape(js_ctx, 2);
 		} else {
-			return 1;  /* syntax error */
+			return 1; /* syntax error */
 		}
 		break;
 	}
-#endif  /* DUK_USE_JX */
+#endif /* DUK_USE_JX */
 	default:
 		/* catches EOF (0x00) */
-		return 1;  /* syntax error */
+		return 1; /* syntax error */
 	}
 
 	DUK_RAW_WRITEINC_XUTF8(*ext_p, cp);
 
 	return 0;
 }
 
@@ -36842,15 +37856,15 @@
 		 */
 
 		safe = DUK__JSON_DECSTR_CHUNKSIZE;
 
 		/* Ensure space for 1:1 output plus one escape. */
 		q = DUK_BW_ENSURE_RAW(js_ctx->thr, bw, safe + DUK_UNICODE_MAX_XUTF8_LENGTH, q);
 
-		p = js_ctx->p;  /* temp copy, write back for next loop */
+		p = js_ctx->p; /* temp copy, write back for next loop */
 		for (;;) {
 			if (safe == 0) {
 				js_ctx->p = p;
 				break;
 			}
 			safe--;
 
@@ -36877,16 +37891,16 @@
 				break;
 			} else {
 				js_ctx->p = p;
 				goto syntax_error;
 			}
 		}
 	}
- found_quote:
-#else  /* DUK_USE_JSON_DECSTRING_FASTPATH */
+found_quote:
+#else /* DUK_USE_JSON_DECSTRING_FASTPATH */
 	for (;;) {
 		duk_uint8_t x;
 
 		q = DUK_BW_ENSURE_RAW(js_ctx->thr, bw, DUK_UNICODE_MAX_XUTF8_LENGTH, q);
 
 		x = duk__json_dec_get(js_ctx);
 
@@ -36899,24 +37913,24 @@
 		} else if (x < 0x20) {
 			/* catches EOF (NUL) */
 			goto syntax_error;
 		} else {
 			*q++ = (duk_uint8_t) x;
 		}
 	}
-#endif  /* DUK_USE_JSON_DECSTRING_FASTPATH */
+#endif /* DUK_USE_JSON_DECSTRING_FASTPATH */
 
 	DUK_BW_SETPTR_AND_COMPACT(js_ctx->thr, bw, q);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if input string is safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if input string is safe. */
 
 	/* [ ... str ] */
 
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
 
 #if defined(DUK_USE_JX)
 /* Decode a plain string consisting entirely of identifier characters.
  * Used to parse plain keys (e.g. "foo: 123").
@@ -36924,15 +37938,15 @@
 DUK_LOCAL void duk__json_dec_plain_string(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	const duk_uint8_t *p;
 	duk_small_int_t x;
 
 	/* Caller has already eaten the first char so backtrack one byte. */
 
-	js_ctx->p--;  /* safe */
+	js_ctx->p--; /* safe */
 	p = js_ctx->p;
 
 	/* Here again we parse bytes, and non-ASCII UTF-8 will cause end of
 	 * parsing (which is correct except if there are non-shortest encodings).
 	 * There is also no need to check explicitly for end of input buffer as
 	 * the input is NUL padded and NUL will exit the parsing loop.
 	 *
@@ -36956,15 +37970,15 @@
 	}
 
 	duk_push_lstring(thr, (const char *) js_ctx->p, (duk_size_t) (p - js_ctx->p));
 	js_ctx->p = p;
 
 	/* [ ... str ] */
 }
-#endif  /* DUK_USE_JX */
+#endif /* DUK_USE_JX */
 
 #if defined(DUK_USE_JX)
 DUK_LOCAL void duk__json_dec_pointer(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	const duk_uint8_t *p;
 	duk_small_int_t x;
 	void *voidptr;
@@ -36999,25 +38013,25 @@
 	 * results in a null pointer which is a better placeholder than a missing
 	 * value or an error.
 	 */
 
 	voidptr = NULL;
 	(void) DUK_SSCANF((const char *) js_ctx->p, DUK_STR_FMT_PTR, &voidptr);
 	duk_push_pointer(thr, voidptr);
-	js_ctx->p = p + 1;  /* skip ')' */
+	js_ctx->p = p + 1; /* skip ')' */
 
 	/* [ ... ptr ] */
 
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
-#endif  /* DUK_USE_JX */
+#endif /* DUK_USE_JX */
 
 #if defined(DUK_USE_JX)
 DUK_LOCAL void duk__json_dec_buffer(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	const duk_uint8_t *p;
 	duk_uint8_t *buf;
 	duk_size_t src_len;
@@ -37057,25 +38071,25 @@
 	/* XXX: this is not very nice; unnecessary copy is made. */
 	src_len = (duk_size_t) (p - js_ctx->p);
 	buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_len);
 	DUK_ASSERT(buf != NULL);
 	duk_memcpy((void *) buf, (const void *) js_ctx->p, src_len);
 	duk_hex_decode(thr, -1);
 
-	js_ctx->p = p + 1;  /* skip '|' */
+	js_ctx->p = p + 1; /* skip '|' */
 
 	/* [ ... buf ] */
 
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
-#endif  /* DUK_USE_JX */
+#endif /* DUK_USE_JX */
 
 /* Parse a number, other than NaN or +/- Infinity */
 DUK_LOCAL void duk__json_dec_number(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	const duk_uint8_t *p_start;
 	const duk_uint8_t *p;
 	duk_uint8_t x;
@@ -37090,68 +38104,66 @@
 	 */
 
 	p = js_ctx->p;
 	for (;;) {
 		x = *p;
 
 		DUK_DDD(DUK_DDDPRINT("parse_number: p_start=%p, p=%p, p_end=%p, x=%ld",
-		                     (const void *) p_start, (const void *) p,
-		                     (const void *) js_ctx->p_end, (long) x));
+		                     (const void *) p_start,
+		                     (const void *) p,
+		                     (const void *) js_ctx->p_end,
+		                     (long) x));
 
 #if defined(DUK_USE_JSON_DECNUMBER_FASTPATH)
 		/* This fast path is pretty marginal in practice.
 		 * XXX: candidate for removal.
 		 */
-		DUK_ASSERT(duk__json_decnumber_lookup[0x00] == 0x00);  /* end-of-input breaks */
+		DUK_ASSERT(duk__json_decnumber_lookup[0x00] == 0x00); /* end-of-input breaks */
 		if (duk__json_decnumber_lookup[x] == 0) {
 			break;
 		}
-#else  /* DUK_USE_JSON_DECNUMBER_FASTPATH */
+#else /* DUK_USE_JSON_DECNUMBER_FASTPATH */
 		if (!((x >= DUK_ASC_0 && x <= DUK_ASC_9) ||
-		      (x == DUK_ASC_PERIOD || x == DUK_ASC_LC_E ||
-		       x == DUK_ASC_UC_E || x == DUK_ASC_MINUS || x == DUK_ASC_PLUS))) {
+		      (x == DUK_ASC_PERIOD || x == DUK_ASC_LC_E || x == DUK_ASC_UC_E || x == DUK_ASC_MINUS || x == DUK_ASC_PLUS))) {
 			/* Plus sign must be accepted for positive exponents
 			 * (e.g. '1.5e+2').  This clause catches NULs.
 			 */
 			break;
 		}
-#endif  /* DUK_USE_JSON_DECNUMBER_FASTPATH */
-		p++;  /* safe, because matched (NUL causes a break) */
+#endif /* DUK_USE_JSON_DECNUMBER_FASTPATH */
+		p++; /* safe, because matched (NUL causes a break) */
 	}
 	js_ctx->p = p;
 
 	DUK_ASSERT(js_ctx->p > p_start);
 	duk_push_lstring(thr, (const char *) p_start, (duk_size_t) (p - p_start));
 
-	s2n_flags = DUK_S2N_FLAG_ALLOW_EXP |
-	            DUK_S2N_FLAG_ALLOW_MINUS |  /* but don't allow leading plus */
+	s2n_flags = DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_MINUS | /* but don't allow leading plus */
 	            DUK_S2N_FLAG_ALLOW_FRAC;
 
-	DUK_DDD(DUK_DDDPRINT("parse_number: string before parsing: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("parse_number: string before parsing: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 	duk_numconv_parse(thr, 10 /*radix*/, s2n_flags);
 	if (duk_is_nan(thr, -1)) {
 		duk__json_dec_syntax_error(js_ctx);
 	}
 	DUK_ASSERT(duk_is_number(thr, -1));
-	DUK_DDD(DUK_DDDPRINT("parse_number: final number: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("parse_number: final number: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	/* [ ... num ] */
 }
 
 DUK_LOCAL void duk__json_dec_objarr_entry(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_require_stack(thr, DUK_JSON_DEC_REQSTACK);
 
 	/* c recursion check */
 
 	duk_native_stack_check(thr);
 
-	DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0); /* unsigned */
 	DUK_ASSERT(js_ctx->recursion_depth <= js_ctx->recursion_limit);
 	if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
 		DUK_ERROR_RANGE(thr, DUK_STR_DEC_RECLIMIT);
 		DUK_WO_NORETURN(return;);
 	}
 	js_ctx->recursion_depth++;
 }
@@ -37162,15 +38174,15 @@
 	DUK_ASSERT(js_ctx->recursion_depth > 0);
 	DUK_ASSERT(js_ctx->recursion_depth <= js_ctx->recursion_limit);
 	js_ctx->recursion_depth--;
 }
 
 DUK_LOCAL void duk__json_dec_object(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
-	duk_int_t key_count;  /* XXX: a "first" flag would suffice */
+	duk_int_t key_count; /* XXX: a "first" flag would suffice */
 	duk_uint8_t x;
 
 	DUK_DDD(DUK_DDDPRINT("parse_object"));
 
 	duk__json_dec_objarr_entry(js_ctx);
 
 	duk_push_object(thr);
@@ -37179,15 +38191,16 @@
 
 	key_count = 0;
 	for (;;) {
 		x = duk__json_dec_get_nonwhite(js_ctx);
 
 		DUK_DDD(DUK_DDDPRINT("parse_object: obj=%!T, x=%ld, key_count=%ld",
 		                     (duk_tval *) duk_get_tval(thr, -1),
-		                     (long) x, (long) key_count));
+		                     (long) x,
+		                     (long) key_count));
 
 		/* handle comma and closing brace */
 
 		if (x == DUK_ASC_COMMA && key_count > 0) {
 			/* accept comma, expect new value */
 			x = duk__json_dec_get_nonwhite(js_ctx);
 		} else if (x == DUK_ASC_RCURLY) {
@@ -37204,16 +38217,15 @@
 		}
 
 		/* parse key and value */
 
 		if (x == DUK_ASC_DOUBLEQUOTE) {
 			duk__json_dec_string(js_ctx);
 #if defined(DUK_USE_JX)
-		} else if (js_ctx->flag_ext_custom &&
-		           duk_unicode_is_identifier_start((duk_codepoint_t) x)) {
+		} else if (js_ctx->flag_ext_custom && duk_unicode_is_identifier_start((duk_codepoint_t) x)) {
 			duk__json_dec_plain_string(js_ctx);
 #endif
 		} else {
 			goto syntax_error;
 		}
 
 		/* [ ... obj key ] */
@@ -37232,21 +38244,20 @@
 		/* [ ... obj ] */
 
 		key_count++;
 	}
 
 	/* [ ... obj ] */
 
-	DUK_DDD(DUK_DDDPRINT("parse_object: final object is %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("parse_object: final object is %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	duk__json_dec_objarr_exit(js_ctx);
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
 
 DUK_LOCAL void duk__json_dec_array(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_uarridx_t arr_idx;
@@ -37262,29 +38273,30 @@
 
 	arr_idx = 0;
 	for (;;) {
 		x = duk__json_dec_get_nonwhite(js_ctx);
 
 		DUK_DDD(DUK_DDDPRINT("parse_array: arr=%!T, x=%ld, arr_idx=%ld",
 		                     (duk_tval *) duk_get_tval(thr, -1),
-		                     (long) x, (long) arr_idx));
+		                     (long) x,
+		                     (long) arr_idx));
 
 		/* handle comma and closing bracket */
 
 		if ((x == DUK_ASC_COMMA) && (arr_idx != 0)) {
 			/* accept comma, expect new value */
 			;
 		} else if (x == DUK_ASC_RBRACKET) {
 			/* eat closing bracket */
 			break;
 		} else if (arr_idx == 0) {
 			/* accept anything, expect first value (EOF will be
 			 * caught by duk__json_dec_value() below.
 			 */
-			js_ctx->p--;  /* backtrack (safe) */
+			js_ctx->p--; /* backtrack (safe) */
 		} else {
 			/* catches EOF (NUL) and initial comma */
 			goto syntax_error;
 		}
 
 		/* parse value */
 
@@ -37300,21 +38312,20 @@
 	 * set the values.
 	 */
 
 	duk_set_length(thr, -1, arr_idx);
 
 	/* [ ... arr ] */
 
-	DUK_DDD(DUK_DDDPRINT("parse_array: final array is %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("parse_array: final array is %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	duk__json_dec_objarr_exit(js_ctx);
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
 
 DUK_LOCAL void duk__json_dec_value(duk_json_dec_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_uint8_t x;
@@ -37326,22 +38337,22 @@
 	/* Note: duk__json_dec_req_stridx() backtracks one char */
 
 	if (x == DUK_ASC_DOUBLEQUOTE) {
 		duk__json_dec_string(js_ctx);
 	} else if ((x >= DUK_ASC_0 && x <= DUK_ASC_9) || (x == DUK_ASC_MINUS)) {
 #if defined(DUK_USE_JX)
 		if (js_ctx->flag_ext_custom && x == DUK_ASC_MINUS && duk__json_dec_peek(js_ctx) == DUK_ASC_UC_I) {
-			duk__json_dec_req_stridx(js_ctx, DUK_STRIDX_MINUS_INFINITY);  /* "-Infinity", '-' has been eaten */
+			duk__json_dec_req_stridx(js_ctx, DUK_STRIDX_MINUS_INFINITY); /* "-Infinity", '-' has been eaten */
 			duk_push_number(thr, -DUK_DOUBLE_INFINITY);
 		} else {
 #else
-		{  /* unconditional block */
+		{ /* unconditional block */
 #endif
 			/* We already ate 'x', so backup one byte. */
-			js_ctx->p--;  /* safe */
+			js_ctx->p--; /* safe */
 			duk__json_dec_number(js_ctx);
 		}
 	} else if (x == DUK_ASC_LC_T) {
 		duk__json_dec_req_stridx(js_ctx, DUK_STRIDX_TRUE);
 		duk_push_true(thr);
 	} else if (x == DUK_ASC_LC_F) {
 		duk__json_dec_req_stridx(js_ctx, DUK_STRIDX_FALSE);
@@ -37374,15 +38385,15 @@
 	}
 
 	duk__json_dec_eat_white(js_ctx);
 
 	/* [ ... val ] */
 	return;
 
- syntax_error:
+syntax_error:
 	duk__json_dec_syntax_error(js_ctx);
 	DUK_UNREACHABLE();
 }
 
 /* Recursive value reviver, implements the Walk() algorithm.  The parsing
  * step ensures there is a reasonable depth limit to the input.  However,
  * the reviver may create more depth by editing object or array entries, so
@@ -37397,31 +38408,35 @@
 
 	DUK_DDD(DUK_DDDPRINT("walk: top=%ld, holder=%!T, name=%!T",
 	                     (long) duk_get_top(thr),
 	                     (duk_tval *) duk_get_tval(thr, -2),
 	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	duk_dup_top(thr);
-	duk_get_prop(thr, -3);  /* -> [ ... holder name val ] */
+	duk_get_prop(thr, -3); /* -> [ ... holder name val ] */
 
 	h = duk_get_hobject(thr, -1);
 	if (h != NULL) {
 		if (duk_js_isarray_hobject(h)) {
 			arr_len = (duk_uarridx_t) duk_get_length(thr, -1);
 			for (i = 0; i < arr_len; i++) {
 				/* [ ... holder name val ] */
 
 				DUK_DDD(DUK_DDDPRINT("walk: array, top=%ld, i=%ld, arr_len=%ld, holder=%!T, name=%!T, val=%!T",
-				                     (long) duk_get_top(thr), (long) i, (long) arr_len,
-				                     (duk_tval *) duk_get_tval(thr, -3), (duk_tval *) duk_get_tval(thr, -2),
+				                     (long) duk_get_top(thr),
+				                     (long) i,
+				                     (long) arr_len,
+				                     (duk_tval *) duk_get_tval(thr, -3),
+				                     (duk_tval *) duk_get_tval(thr, -2),
 				                     (duk_tval *) duk_get_tval(thr, -1)));
 
 				duk_dup_top(thr);
-				(void) duk_push_uint_to_hstring(thr, (duk_uint_t) i);  /* -> [ ... holder name val val ToString(i) ] */
-				duk__json_dec_reviver_walk(js_ctx);  /* -> [ ... holder name val new_elem ] */
+				(void) duk_push_uint_to_hstring(thr,
+				                                (duk_uint_t) i); /* -> [ ... holder name val val ToString(i) ] */
+				duk__json_dec_reviver_walk(js_ctx); /* -> [ ... holder name val new_elem ] */
 
 				if (duk_is_undefined(thr, -1)) {
 					duk_pop(thr);
 					duk_del_prop_index(thr, -1, i);
 				} else {
 					/* XXX: duk_xdef_prop_index_wec() would be more appropriate
 					 * here but it currently makes some assumptions that might
@@ -37431,17 +38446,20 @@
 				}
 			}
 		} else {
 			/* [ ... holder name val ] */
 			duk_enum(thr, -1, DUK_ENUM_OWN_PROPERTIES_ONLY /*flags*/);
 			while (duk_next(thr, -1 /*enum_index*/, 0 /*get_value*/)) {
 				DUK_DDD(DUK_DDDPRINT("walk: object, top=%ld, holder=%!T, name=%!T, val=%!T, enum=%!iT, obj_key=%!T",
-				                     (long) duk_get_top(thr), (duk_tval *) duk_get_tval(thr, -5),
-				                     (duk_tval *) duk_get_tval(thr, -4), (duk_tval *) duk_get_tval(thr, -3),
-				                     (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
+				                     (long) duk_get_top(thr),
+				                     (duk_tval *) duk_get_tval(thr, -5),
+				                     (duk_tval *) duk_get_tval(thr, -4),
+				                     (duk_tval *) duk_get_tval(thr, -3),
+				                     (duk_tval *) duk_get_tval(thr, -2),
+				                     (duk_tval *) duk_get_tval(thr, -1)));
 
 				/* [ ... holder name val enum obj_key ] */
 				duk_dup_m3(thr);
 				duk_dup_m2(thr);
 
 				/* [ ... holder name val enum obj_key val obj_key ] */
 				duk__json_dec_reviver_walk(js_ctx);
@@ -37459,42 +38477,41 @@
 					 * if the own property with that name has been deleted.  This
 					 * does not happen normally, but a clever reviver can trigger
 					 * that, see complex reviver case in: test-bug-json-parse-__proto__.js.
 					 */
 					duk_put_prop(thr, -4);
 				}
 			}
-			duk_pop(thr);  /* pop enum */
+			duk_pop(thr); /* pop enum */
 		}
 	}
 
 	/* [ ... holder name val ] */
 
 	duk_dup(thr, js_ctx->idx_reviver);
-	duk_insert(thr, -4);  /* -> [ ... reviver holder name val ] */
-	duk_call_method(thr, 2);  /* -> [ ... res ] */
+	duk_insert(thr, -4); /* -> [ ... reviver holder name val ] */
+	duk_call_method(thr, 2); /* -> [ ... res ] */
 
 	duk__json_dec_objarr_exit(js_ctx);
 
-	DUK_DDD(DUK_DDDPRINT("walk: top=%ld, result=%!T",
-	                     (long) duk_get_top(thr), (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("walk: top=%ld, result=%!T", (long) duk_get_top(thr), (duk_tval *) duk_get_tval(thr, -1)));
 }
 
 /*
  *  Stringify implementation.
  */
 
-#define DUK__EMIT_1(js_ctx,ch)          duk__emit_1((js_ctx), (duk_uint_fast8_t) (ch))
-#define DUK__EMIT_2(js_ctx,ch1,ch2)     duk__emit_2((js_ctx), (duk_uint_fast8_t) (ch1), (duk_uint_fast8_t) (ch2))
-#define DUK__EMIT_HSTR(js_ctx,h)        duk__emit_hstring((js_ctx), (h))
+#define DUK__EMIT_1(js_ctx, ch)       duk__emit_1((js_ctx), (duk_uint_fast8_t) (ch))
+#define DUK__EMIT_2(js_ctx, ch1, ch2) duk__emit_2((js_ctx), (duk_uint_fast8_t) (ch1), (duk_uint_fast8_t) (ch2))
+#define DUK__EMIT_HSTR(js_ctx, h)     duk__emit_hstring((js_ctx), (h))
 #if defined(DUK_USE_FASTINT) || defined(DUK_USE_JX) || defined(DUK_USE_JC)
-#define DUK__EMIT_CSTR(js_ctx,p)        duk__emit_cstring((js_ctx), (p))
+#define DUK__EMIT_CSTR(js_ctx, p) duk__emit_cstring((js_ctx), (p))
 #endif
-#define DUK__EMIT_STRIDX(js_ctx,i)      duk__emit_stridx((js_ctx), (i))
-#define DUK__UNEMIT_1(js_ctx)           duk__unemit_1((js_ctx))
+#define DUK__EMIT_STRIDX(js_ctx, i) duk__emit_stridx((js_ctx), (i))
+#define DUK__UNEMIT_1(js_ctx)       duk__unemit_1((js_ctx))
 
 DUK_LOCAL void duk__emit_1(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch) {
 	DUK_BW_WRITE_ENSURE_U8(js_ctx->thr, &js_ctx->bw, ch);
 }
 
 DUK_LOCAL void duk__emit_2(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch1, duk_uint_fast8_t ch2) {
 	DUK_BW_WRITE_ENSURE_U8_2(js_ctx->thr, &js_ctx->bw, ch1, ch2);
@@ -37521,18 +38538,16 @@
 }
 
 DUK_LOCAL void duk__unemit_1(duk_json_enc_ctx *js_ctx) {
 	DUK_ASSERT(DUK_BW_GET_SIZE(js_ctx->thr, &js_ctx->bw) >= 1);
 	DUK_BW_ADD_PTR(js_ctx->thr, &js_ctx->bw, -1);
 }
 
-#define DUK__MKESC(nybbles,esc1,esc2)  \
-	(((duk_uint_fast32_t) (nybbles)) << 16) | \
-	(((duk_uint_fast32_t) (esc1)) << 8) | \
-	((duk_uint_fast32_t) (esc2))
+#define DUK__MKESC(nybbles, esc1, esc2) \
+	(((duk_uint_fast32_t) (nybbles)) << 16) | (((duk_uint_fast32_t) (esc1)) << 8) | ((duk_uint_fast32_t) (esc2))
 
 DUK_LOCAL duk_uint8_t *duk__emit_esc_auto_fast(duk_json_enc_ctx *js_ctx, duk_uint_fast32_t cp, duk_uint8_t *q) {
 	duk_uint_fast32_t tmp;
 	duk_small_uint_t dig;
 
 	DUK_UNREF(js_ctx);
 
@@ -37549,15 +38564,15 @@
 		if (DUK_UNLIKELY(js_ctx->flag_ext_custom != 0U)) {
 			tmp = DUK__MKESC(2, DUK_ASC_BACKSLASH, DUK_ASC_LC_X);
 		} else {
 			tmp = DUK__MKESC(4, DUK_ASC_BACKSLASH, DUK_ASC_LC_U);
 		}
 	} else
 #endif
-	if (DUK_LIKELY(cp < 0x10000UL)) {
+	    if (DUK_LIKELY(cp < 0x10000UL)) {
 		tmp = DUK__MKESC(4, DUK_ASC_BACKSLASH, DUK_ASC_LC_U);
 	} else {
 #if defined(DUK_USE_JX)
 		if (DUK_LIKELY(js_ctx->flag_ext_custom != 0U)) {
 			tmp = DUK__MKESC(8, DUK_ASC_BACKSLASH, DUK_ASC_UC_U);
 		} else
 #endif
@@ -37581,15 +38596,15 @@
 		*q++ = duk_lc_digits[dig];
 	}
 
 	return q;
 }
 
 DUK_LOCAL void duk__json_enc_key_autoquote(duk_json_enc_ctx *js_ctx, duk_hstring *k) {
-	const duk_int8_t *p, *p_start, *p_end;  /* Note: intentionally signed. */
+	const duk_int8_t *p, *p_start, *p_end; /* Note: intentionally signed. */
 	duk_size_t k_len;
 	duk_codepoint_t cp;
 
 	DUK_ASSERT(k != NULL);
 
 	/* Accept ASCII strings which conform to identifier requirements
 	 * as being emitted without key quotes.  Since we only accept ASCII
@@ -37622,28 +38637,28 @@
 		/* This seems faster than emitting bytes one at a time and
 		 * then potentially rewinding.
 		 */
 		DUK__EMIT_HSTR(js_ctx, k);
 		return;
 	}
 
- quote_normally:
+quote_normally:
 	duk__json_enc_quote_string(js_ctx, k);
 }
 
 /* The Quote(value) operation: quote a string.
  *
  * Stack policy: [ ] -> [ ].
  */
 
 DUK_LOCAL void duk__json_enc_quote_string(duk_json_enc_ctx *js_ctx, duk_hstring *h_str) {
 	duk_hthread *thr = js_ctx->thr;
 	const duk_uint8_t *p, *p_start, *p_end, *p_now, *p_tmp;
 	duk_uint8_t *q;
-	duk_ucodepoint_t cp;  /* typed for duk_unicode_decode_xutf8() */
+	duk_ucodepoint_t cp; /* typed for duk_unicode_decode_xutf8() */
 
 	DUK_DDD(DUK_DDDPRINT("duk__json_enc_quote_string: h_str=%!O", (duk_heaphdr *) h_str));
 
 	DUK_ASSERT(h_str != NULL);
 	p_start = DUK_HSTRING_GET_DATA(h_str);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_str);
 	p = p_start;
@@ -37654,16 +38669,15 @@
 	 * there's no need to ensure space while processing the chunk.
 	 */
 
 	while (p < p_end) {
 		duk_size_t left, now, space;
 
 		left = (duk_size_t) (p_end - p);
-		now = (left > DUK__JSON_ENCSTR_CHUNKSIZE ?
-		       DUK__JSON_ENCSTR_CHUNKSIZE : left);
+		now = (left > DUK__JSON_ENCSTR_CHUNKSIZE ? DUK__JSON_ENCSTR_CHUNKSIZE : left);
 
 		/* Maximum expansion per input byte is 6:
 		 *   - invalid UTF-8 byte causes "\uXXXX" to be emitted (6/1 = 6).
 		 *   - 2-byte UTF-8 encodes as "\uXXXX" (6/2 = 3).
 		 *   - 4-byte UTF-8 encodes as "\Uxxxxxxxx" (10/4 = 2.5).
 		 */
 		space = now * 6;
@@ -37691,15 +38705,15 @@
 				cp = (duk_ucodepoint_t) 0x7f;
 				q = duk__emit_esc_auto_fast(js_ctx, cp, q);
 			} else {
 				DUK_ASSERT(b == 0x81);
 				p--;
 
 				/* slow path is shared */
-#else  /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
+#else /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
 			cp = *p;
 
 			if (DUK_LIKELY(cp <= 0x7f)) {
 				/* ascii fast path: avoid decoding utf-8 */
 				p++;
 				if (cp == 0x22 || cp == 0x5c) {
 					/* double quote or backslash */
@@ -37722,15 +38736,15 @@
 					q = duk__emit_esc_auto_fast(js_ctx, cp, q);
 				} else {
 					/* any other printable -> as is */
 					*q++ = (duk_uint8_t) cp;
 				}
 			} else {
 				/* slow path is shared */
-#endif  /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
+#endif /* DUK_USE_JSON_QUOTESTRING_FASTPATH */
 
 				/* slow path decode */
 
 				/* If XUTF-8 decoding fails, treat the offending byte as a codepoint directly
 				 * and go forward one byte.  This is of course very lossy, but allows some kind
 				 * of output to be produced even for internal strings which don't conform to
 				 * XUTF-8.  All standard ECMAScript strings are always CESU-8, so this behavior
@@ -37798,32 +38812,30 @@
 	if (DUK_LIKELY(!(c == DUK_FP_INFINITE || c == DUK_FP_NAN))) {
 		DUK_ASSERT(DUK_ISFINITE(d));
 
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 		/* Negative zero needs special handling in JX/JC because
 		 * it would otherwise serialize to '0', not '-0'.
 		 */
-		if (DUK_UNLIKELY(c == DUK_FP_ZERO && s != 0 &&
-		                 (js_ctx->flag_ext_custom_or_compatible))) {
-			duk_push_hstring_stridx(thr, DUK_STRIDX_MINUS_ZERO);  /* '-0' */
+		if (DUK_UNLIKELY(c == DUK_FP_ZERO && s != 0 && (js_ctx->flag_ext_custom_or_compatible))) {
+			duk_push_hstring_stridx(thr, DUK_STRIDX_MINUS_ZERO); /* '-0' */
 		} else
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 		{
 			n2s_flags = 0;
 			/* [ ... number ] -> [ ... string ] */
 			duk_numconv_stringify(thr, 10 /*radix*/, 0 /*digits*/, n2s_flags);
 		}
 		h_str = duk_known_hstring(thr, -1);
 		DUK__EMIT_HSTR(js_ctx, h_str);
 		return;
 	}
 
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
-	if (!(js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM |
-	                       DUK_JSON_FLAG_EXT_COMPATIBLE))) {
+	if (!(js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE))) {
 		stridx = DUK_STRIDX_LC_NULL;
 	} else if (c == DUK_FP_NAN) {
 		stridx = js_ctx->stridx_custom_nan;
 	} else if (s == 0) {
 		stridx = js_ctx->stridx_custom_posinf;
 	} else {
 		stridx = js_ctx->stridx_custom_neginf;
@@ -37914,15 +38926,15 @@
 		x = src[i];
 		*q++ = duk_lc_digits[x >> 4];
 		*q++ = duk_lc_digits[x & 0x0f];
 	}
 
 	return q;
 }
-#else  /* DUK_USE_HEX_FASTPATH */
+#else /* DUK_USE_HEX_FASTPATH */
 DUK_LOCAL duk_uint8_t *duk__json_enc_buffer_data_hex(const duk_uint8_t *src, duk_size_t src_len, duk_uint8_t *dst) {
 	const duk_uint8_t *p;
 	const duk_uint8_t *p_end;
 	duk_uint8_t *q;
 	duk_small_uint_t x;
 
 	p = src;
@@ -37932,24 +38944,24 @@
 		x = *p++;
 		*q++ = duk_lc_digits[x >> 4];
 		*q++ = duk_lc_digits[x & 0x0f];
 	}
 
 	return q;
 }
-#endif  /* DUK_USE_HEX_FASTPATH */
+#endif /* DUK_USE_HEX_FASTPATH */
 
 DUK_LOCAL void duk__json_enc_buffer_data(duk_json_enc_ctx *js_ctx, duk_uint8_t *buf_data, duk_size_t buf_len) {
 	duk_hthread *thr;
 	duk_uint8_t *q;
 	duk_size_t space;
 
 	thr = js_ctx->thr;
 
-	DUK_ASSERT(js_ctx->flag_ext_custom || js_ctx->flag_ext_compatible);  /* caller checks */
+	DUK_ASSERT(js_ctx->flag_ext_custom || js_ctx->flag_ext_compatible); /* caller checks */
 	DUK_ASSERT(js_ctx->flag_ext_custom_or_compatible);
 
 	/* Buffer values are encoded in (lowercase) hex to make the
 	 * binary data readable.  Base64 or similar would be more
 	 * compact but less readable, and the point of JX/JC
 	 * variants is to be as useful to a programmer as possible.
 	 */
@@ -37957,15 +38969,15 @@
 	/* The #if defined() clutter here needs to handle the three
 	 * cases: (1) JX+JC, (2) JX only, (3) JC only.
 	 */
 
 	/* Note: space must cater for both JX and JC. */
 	space = 9 + buf_len * 2 + 2;
 	DUK_ASSERT(DUK_HBUFFER_MAX_BYTELEN <= 0x7ffffffeUL);
-	DUK_ASSERT((space - 2) / 2 >= buf_len);  /* overflow not possible, buffer limits */
+	DUK_ASSERT((space - 2) / 2 >= buf_len); /* overflow not possible, buffer limits */
 	q = DUK_BW_ENSURE_GETPTR(thr, &js_ctx->bw, space);
 
 #if defined(DUK_USE_JX) && defined(DUK_USE_JC)
 	if (js_ctx->flag_ext_custom)
 #endif
 #if defined(DUK_USE_JX)
 	{
@@ -37977,31 +38989,31 @@
 #endif
 #if defined(DUK_USE_JX) && defined(DUK_USE_JC)
 	else
 #endif
 #if defined(DUK_USE_JC)
 	{
 		DUK_ASSERT(js_ctx->flag_ext_compatible);
-		duk_memcpy((void *) q, (const void *) "{\"_buf\":\"", 9);  /* len: 9 */
+		duk_memcpy((void *) q, (const void *) "{\"_buf\":\"", 9); /* len: 9 */
 		q += 9;
 		q = duk__json_enc_buffer_data_hex(buf_data, buf_len, q);
 		*q++ = DUK_ASC_DOUBLEQUOTE;
 		*q++ = DUK_ASC_RCURLY;
 	}
 #endif
 
 	DUK_BW_SET_PTR(thr, &js_ctx->bw, q);
 }
 
 DUK_LOCAL void duk__json_enc_buffer_jx_jc(duk_json_enc_ctx *js_ctx, duk_hbuffer *h) {
 	duk__json_enc_buffer_data(js_ctx,
-	                     (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(js_ctx->thr->heap, h),
-	                     (duk_size_t) DUK_HBUFFER_GET_SIZE(h));
+	                          (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(js_ctx->thr->heap, h),
+	                          (duk_size_t) DUK_HBUFFER_GET_SIZE(h));
 }
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 
 #if defined(DUK_USE_JSON_STRINGIFY_FASTPATH)
 DUK_LOCAL void duk__json_enc_buffer_json_fastpath(duk_json_enc_ctx *js_ctx, duk_hbuffer *h) {
 	duk_size_t i, n;
 	const duk_uint8_t *buf;
 	duk_uint8_t *q;
 
@@ -38033,29 +39045,29 @@
 		q = DUK_BW_GET_PTR(js_ctx->thr, &js_ctx->bw);
 		for (i = 0; i < n; i++) {
 			q = DUK_BW_ENSURE_RAW(js_ctx->thr, &js_ctx->bw, 32, q);
 			q += DUK_SPRINTF((char *) q, "\"%lu\":%u,", (unsigned long) i, (unsigned int) buf[i]);
 		}
 		DUK_BW_SET_PTR(js_ctx->thr, &js_ctx->bw, q);
 	}
-	DUK__UNEMIT_1(js_ctx);  /* eat trailing comma */
+	DUK__UNEMIT_1(js_ctx); /* eat trailing comma */
 
 	if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 		duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth);
 	}
 	DUK__EMIT_1(js_ctx, DUK_ASC_RCURLY);
 }
-#endif  /* DUK_USE_JSON_STRINGIFY_FASTPATH */
+#endif /* DUK_USE_JSON_STRINGIFY_FASTPATH */
 
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 DUK_LOCAL void duk__json_enc_pointer(duk_json_enc_ctx *js_ctx, void *ptr) {
-	char buf[64];  /* XXX: how to figure correct size? */
+	char buf[64]; /* XXX: how to figure correct size? */
 	const char *fmt;
 
-	DUK_ASSERT(js_ctx->flag_ext_custom || js_ctx->flag_ext_compatible);  /* caller checks */
+	DUK_ASSERT(js_ctx->flag_ext_custom || js_ctx->flag_ext_compatible); /* caller checks */
 	DUK_ASSERT(js_ctx->flag_ext_custom_or_compatible);
 
 	duk_memzero(buf, sizeof(buf));
 
 	/* The #if defined() clutter here needs to handle the three
 	 * cases: (1) JX+JC, (2) JX only, (3) JC only.
 	 */
@@ -38074,60 +39086,60 @@
 	{
 		DUK_ASSERT(js_ctx->flag_ext_compatible);
 		fmt = ptr ? "{\"_ptr\":\"%p\"}" : "{\"_ptr\":\"null\"}";
 	}
 #endif
 
 	/* When ptr == NULL, the format argument is unused. */
-	DUK_SNPRINTF(buf, sizeof(buf) - 1, fmt, ptr);  /* must not truncate */
+	DUK_SNPRINTF(buf, sizeof(buf) - 1, fmt, ptr); /* must not truncate */
 	DUK__EMIT_CSTR(js_ctx, buf);
 }
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 DUK_LOCAL void duk__json_enc_bufobj(duk_json_enc_ctx *js_ctx, duk_hbufobj *h_bufobj) {
 	DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 
 	if (h_bufobj->buf == NULL || !DUK_HBUFOBJ_VALID_SLICE(h_bufobj)) {
 		DUK__EMIT_STRIDX(js_ctx, DUK_STRIDX_LC_NULL);
 	} else {
 		/* Handle both full and partial slice (as long as covered). */
 		duk__json_enc_buffer_data(js_ctx,
-		                     (duk_uint8_t *) DUK_HBUFOBJ_GET_SLICE_BASE(js_ctx->thr->heap, h_bufobj),
-		                     (duk_size_t) h_bufobj->length);
+		                          (duk_uint8_t *) DUK_HBUFOBJ_GET_SLICE_BASE(js_ctx->thr->heap, h_bufobj),
+		                          (duk_size_t) h_bufobj->length);
 	}
 }
-#endif  /* DUK_USE_JX || DUK_USE_JC */
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* Indent helper.  Calling code relies on js_ctx->recursion_depth also being
  * directly related to indent depth.
  */
 #if defined(DUK_USE_PREFER_SIZE)
 DUK_LOCAL void duk__json_enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth) {
 	DUK_ASSERT(js_ctx->h_gap != NULL);
-	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(js_ctx->h_gap) > 0);  /* caller guarantees */
+	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(js_ctx->h_gap) > 0); /* caller guarantees */
 
 	DUK__EMIT_1(js_ctx, 0x0a);
 	while (depth-- > 0) {
 		DUK__EMIT_HSTR(js_ctx, js_ctx->h_gap);
 	}
 }
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 DUK_LOCAL void duk__json_enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth) {
 	const duk_uint8_t *gap_data;
 	duk_size_t gap_len;
-	duk_size_t avail_bytes;   /* bytes of indent available for copying */
-	duk_size_t need_bytes;    /* bytes of indent still needed */
+	duk_size_t avail_bytes; /* bytes of indent available for copying */
+	duk_size_t need_bytes; /* bytes of indent still needed */
 	duk_uint8_t *p_start;
 	duk_uint8_t *p;
 
 	DUK_ASSERT(js_ctx->h_gap != NULL);
-	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(js_ctx->h_gap) > 0);  /* caller guarantees */
+	DUK_ASSERT(DUK_HSTRING_GET_BYTELEN(js_ctx->h_gap) > 0); /* caller guarantees */
 
 	DUK__EMIT_1(js_ctx, 0x0a);
 	if (DUK_UNLIKELY(depth == 0)) {
 		return;
 	}
 
 	/* To handle deeper indents efficiently, make use of copies we've
@@ -38153,22 +39165,22 @@
 	while (need_bytes >= avail_bytes) {
 		duk_memcpy((void *) p, (const void *) p_start, (size_t) avail_bytes);
 		p += avail_bytes;
 		need_bytes -= avail_bytes;
 		avail_bytes <<= 1;
 	}
 
-	DUK_ASSERT(need_bytes < avail_bytes);  /* need_bytes may be zero */
+	DUK_ASSERT(need_bytes < avail_bytes); /* need_bytes may be zero */
 	duk_memcpy((void *) p, (const void *) p_start, (size_t) need_bytes);
 	p += need_bytes;
 	/*avail_bytes += need_bytes*/
 
 	DUK_BW_SET_PTR(js_ctx->thr, &js_ctx->bw, p);
 }
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 /* Shared entry handling for object/array serialization. */
 DUK_LOCAL void duk__json_enc_objarr_entry(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_hobject *h_target;
 	duk_uint_fast32_t i, n;
 
@@ -38177,15 +39189,15 @@
 	duk_native_stack_check(thr);
 	duk_require_stack(thr, DUK_JSON_ENC_REQSTACK);
 
 	/* Loop check using a hybrid approach: a fixed-size visited[] array
 	 * with overflow in a loop check object.
 	 */
 
-	h_target = duk_known_hobject(thr, -1);  /* object or array */
+	h_target = duk_known_hobject(thr, -1); /* object or array */
 
 	n = js_ctx->recursion_depth;
 	if (DUK_UNLIKELY(n > DUK_JSON_ENC_LOOPARRAY)) {
 		n = DUK_JSON_ENC_LOOPARRAY;
 	}
 	for (i = 0; i < n; i++) {
 		if (DUK_UNLIKELY(js_ctx->visiting[i] == h_target)) {
@@ -38194,35 +39206,36 @@
 			DUK_WO_NORETURN(return;);
 		}
 	}
 	if (js_ctx->recursion_depth < DUK_JSON_ENC_LOOPARRAY) {
 		js_ctx->visiting[js_ctx->recursion_depth] = h_target;
 	} else {
 		duk_push_sprintf(thr, DUK_STR_FMT_PTR, (void *) h_target);
-		duk_dup_top(thr);  /* -> [ ... voidp voidp ] */
+		duk_dup_top(thr); /* -> [ ... voidp voidp ] */
 		if (duk_has_prop(thr, js_ctx->idx_loop)) {
 			DUK_ERROR_TYPE(thr, DUK_STR_CYCLIC_INPUT);
 			DUK_WO_NORETURN(return;);
 		}
-		duk_push_true(thr);  /* -> [ ... voidp true ] */
-		duk_put_prop(thr, js_ctx->idx_loop);  /* -> [ ... ] */
+		duk_push_true(thr); /* -> [ ... voidp true ] */
+		duk_put_prop(thr, js_ctx->idx_loop); /* -> [ ... ] */
 	}
 
 	/* C recursion check. */
 
-	DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0); /* unsigned */
 	DUK_ASSERT(js_ctx->recursion_depth <= js_ctx->recursion_limit);
 	if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
 		DUK_ERROR_RANGE(thr, DUK_STR_ENC_RECLIMIT);
 		DUK_WO_NORETURN(return;);
 	}
 	js_ctx->recursion_depth++;
 
 	DUK_DDD(DUK_DDDPRINT("shared entry finished: top=%ld, loop=%!T",
-	                     (long) duk_get_top(thr), (duk_tval *) duk_get_tval(thr, js_ctx->idx_loop)));
+	                     (long) duk_get_top(thr),
+	                     (duk_tval *) duk_get_tval(thr, js_ctx->idx_loop)));
 }
 
 /* Shared exit handling for object/array serialization. */
 DUK_LOCAL void duk__json_enc_objarr_exit(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_hobject *h_target;
 
@@ -38230,28 +39243,29 @@
 
 	DUK_ASSERT(js_ctx->recursion_depth > 0);
 	DUK_ASSERT(js_ctx->recursion_depth <= js_ctx->recursion_limit);
 	js_ctx->recursion_depth--;
 
 	/* Loop check. */
 
-	h_target = duk_known_hobject(thr, *entry_top - 1);  /* original target at entry_top - 1 */
+	h_target = duk_known_hobject(thr, *entry_top - 1); /* original target at entry_top - 1 */
 
 	if (js_ctx->recursion_depth < DUK_JSON_ENC_LOOPARRAY) {
 		/* Previous entry was inside visited[], nothing to do. */
 	} else {
 		duk_push_sprintf(thr, DUK_STR_FMT_PTR, (void *) h_target);
-		duk_del_prop(thr, js_ctx->idx_loop);  /* -> [ ... ] */
+		duk_del_prop(thr, js_ctx->idx_loop); /* -> [ ... ] */
 	}
 
 	/* Restore stack top after unbalanced code paths. */
 	duk_set_top(thr, *entry_top);
 
 	DUK_DDD(DUK_DDDPRINT("shared entry finished: top=%ld, loop=%!T",
-	                     (long) duk_get_top(thr), (duk_tval *) duk_get_tval(thr, js_ctx->idx_loop)));
+	                     (long) duk_get_top(thr),
+	                     (duk_tval *) duk_get_tval(thr, js_ctx->idx_loop)));
 }
 
 /* The JO(value) operation: encode object.
  *
  * Stack policy: [ object ] -> [ object ].
  */
 DUK_LOCAL void duk__json_enc_object(duk_json_enc_ctx *js_ctx) {
@@ -38271,44 +39285,45 @@
 	idx_obj = entry_top - 1;
 
 	if (js_ctx->idx_proplist >= 0) {
 		idx_keys = js_ctx->idx_proplist;
 	} else {
 		/* XXX: would be nice to enumerate an object at specified index */
 		duk_dup(thr, idx_obj);
-		(void) duk_hobject_get_enumerated_keys(thr, DUK_ENUM_OWN_PROPERTIES_ONLY /*flags*/);  /* [ ... target ] -> [ ... target keys ] */
+		(void) duk_hobject_get_enumerated_keys(
+		    thr,
+		    DUK_ENUM_OWN_PROPERTIES_ONLY /*flags*/); /* [ ... target ] -> [ ... target keys ] */
 		idx_keys = duk_require_normalize_index(thr, -1);
 		/* leave stack unbalanced on purpose */
 	}
 
-	DUK_DDD(DUK_DDDPRINT("idx_keys=%ld, h_keys=%!T",
-	                     (long) idx_keys, (duk_tval *) duk_get_tval(thr, idx_keys)));
+	DUK_DDD(DUK_DDDPRINT("idx_keys=%ld, h_keys=%!T", (long) idx_keys, (duk_tval *) duk_get_tval(thr, idx_keys)));
 
 	/* Steps 8-10 have been merged to avoid a "partial" variable. */
 
 	DUK__EMIT_1(js_ctx, DUK_ASC_LCURLY);
 
 	/* XXX: keys is an internal object with all keys to be processed
 	 * in its (gapless) array part.  Because nobody can touch the keys
 	 * object, we could iterate its array part directly (keeping in mind
 	 * that it can be reallocated).
 	 */
 
 	arr_len = (duk_uarridx_t) duk_get_length(thr, idx_keys);
 	emitted = 0;
 	for (i = 0; i < arr_len; i++) {
-		duk_get_prop_index(thr, idx_keys, i);  /* -> [ ... key ] */
+		duk_get_prop_index(thr, idx_keys, i); /* -> [ ... key ] */
 
 		DUK_DDD(DUK_DDDPRINT("object property loop: holder=%!T, key=%!T",
 		                     (duk_tval *) duk_get_tval(thr, idx_obj),
 		                     (duk_tval *) duk_get_tval(thr, -1)));
 
 		h_key = duk_known_hstring(thr, -1);
 		DUK_ASSERT(h_key != NULL);
-		DUK_ASSERT(!DUK_HSTRING_HAS_SYMBOL(h_key));  /* proplist filtering; enum options */
+		DUK_ASSERT(!DUK_HSTRING_HAS_SYMBOL(h_key)); /* proplist filtering; enum options */
 
 		prev_size = DUK_BW_GET_SIZE(js_ctx->thr, &js_ctx->bw);
 		if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 			duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth);
 			duk__json_enc_key_autoquote(js_ctx, h_key);
 			DUK__EMIT_2(js_ctx, DUK_ASC_COLON, DUK_ASC_SPACE);
 		} else {
@@ -38329,15 +39344,15 @@
 		}
 
 		/* [ ... ] */
 	}
 
 	if (emitted) {
 		DUK_ASSERT(*((duk_uint8_t *) DUK_BW_GET_PTR(js_ctx->thr, &js_ctx->bw) - 1) == DUK_ASC_COMMA);
-		DUK__UNEMIT_1(js_ctx);  /* eat trailing comma */
+		DUK__UNEMIT_1(js_ctx); /* eat trailing comma */
 		if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 			DUK_ASSERT(js_ctx->recursion_depth >= 1);
 			duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
 		}
 	}
 	DUK__EMIT_1(js_ctx, DUK_ASC_RCURLY);
 
@@ -38353,38 +39368,38 @@
 DUK_LOCAL void duk__json_enc_array(duk_json_enc_ctx *js_ctx) {
 	duk_hthread *thr = js_ctx->thr;
 	duk_idx_t entry_top;
 	duk_idx_t idx_arr;
 	duk_bool_t emitted;
 	duk_uarridx_t i, arr_len;
 
-	DUK_DDD(DUK_DDDPRINT("duk__json_enc_array: array=%!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("duk__json_enc_array: array=%!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	duk__json_enc_objarr_entry(js_ctx, &entry_top);
 
 	idx_arr = entry_top - 1;
 
 	/* Steps 8-10 have been merged to avoid a "partial" variable. */
 
 	DUK__EMIT_1(js_ctx, DUK_ASC_LBRACKET);
 
 	arr_len = (duk_uarridx_t) duk_get_length(thr, idx_arr);
 	emitted = 0;
 	for (i = 0; i < arr_len; i++) {
 		DUK_DDD(DUK_DDDPRINT("array entry loop: array=%!T, index=%ld, arr_len=%ld",
 		                     (duk_tval *) duk_get_tval(thr, idx_arr),
-		                     (long) i, (long) arr_len));
+		                     (long) i,
+		                     (long) arr_len));
 
 		if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 			DUK_ASSERT(js_ctx->recursion_depth >= 1);
 			duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth);
 		}
 
-		(void) duk_push_uint_to_hstring(thr, (duk_uint_t) i);  /* -> [ ... key ] */
+		(void) duk_push_uint_to_hstring(thr, (duk_uint_t) i); /* -> [ ... key ] */
 
 		/* [ ... key ] */
 
 		if (DUK_UNLIKELY(duk__json_enc_value(js_ctx, idx_arr) == 0)) {
 			/* Value would normally be omitted, replace with 'null'. */
 			DUK__EMIT_STRIDX(js_ctx, DUK_STRIDX_LC_NULL);
 		} else {
@@ -38395,15 +39410,15 @@
 
 		DUK__EMIT_1(js_ctx, DUK_ASC_COMMA);
 		emitted = 1;
 	}
 
 	if (emitted) {
 		DUK_ASSERT(*((duk_uint8_t *) DUK_BW_GET_PTR(js_ctx->thr, &js_ctx->bw) - 1) == DUK_ASC_COMMA);
-		DUK__UNEMIT_1(js_ctx);  /* eat trailing comma */
+		DUK__UNEMIT_1(js_ctx); /* eat trailing comma */
 		if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 			DUK_ASSERT(js_ctx->recursion_depth >= 1);
 			duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
 		}
 	}
 	DUK__EMIT_1(js_ctx, DUK_ASC_RBRACKET);
 
@@ -38420,62 +39435,61 @@
 	duk_hthread *thr = js_ctx->thr;
 	duk_tval *tv;
 	duk_tval *tv_holder;
 	duk_tval *tv_key;
 	duk_small_int_t c;
 
 	DUK_DDD(DUK_DDDPRINT("duk__json_enc_value: idx_holder=%ld, holder=%!T, key=%!T",
-	                     (long) idx_holder, (duk_tval *) duk_get_tval(thr, idx_holder),
+	                     (long) idx_holder,
+	                     (duk_tval *) duk_get_tval(thr, idx_holder),
 	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	tv_holder = DUK_GET_TVAL_POSIDX(thr, idx_holder);
 	DUK_ASSERT(DUK_TVAL_IS_OBJECT(tv_holder));
 	tv_key = DUK_GET_TVAL_NEGIDX(thr, -1);
 	DUK_ASSERT(DUK_TVAL_IS_STRING(tv_key));
-	DUK_ASSERT(!DUK_HSTRING_HAS_SYMBOL(DUK_TVAL_GET_STRING(tv_key)));  /* Caller responsible. */
+	DUK_ASSERT(!DUK_HSTRING_HAS_SYMBOL(DUK_TVAL_GET_STRING(tv_key))); /* Caller responsible. */
 	(void) duk_hobject_getprop(thr, tv_holder, tv_key);
 
 	/* -> [ ... key val ] */
 
 	DUK_DDD(DUK_DDDPRINT("value=%!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	/* Standard JSON checks for .toJSON() only for actual objects; for
 	 * example, setting Number.prototype.toJSON and then serializing a
 	 * number won't invoke the .toJSON() method.  However, lightfuncs and
 	 * plain buffers mimic objects so we check for their .toJSON() method.
 	 */
-	if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT |
-	                                 DUK_TYPE_MASK_LIGHTFUNC |
-	                                 DUK_TYPE_MASK_BUFFER)) {
+	if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER)) {
 		duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_TO_JSON);
-		if (duk_is_callable(thr, -1)) {  /* toJSON() can also be a lightfunc */
+		if (duk_is_callable(thr, -1)) { /* toJSON() can also be a lightfunc */
 			DUK_DDD(DUK_DDDPRINT("value is object, has callable toJSON() -> call it"));
 			/* XXX: duk_dup_unvalidated(thr, -2) etc. */
-			duk_dup_m2(thr);          /* -> [ ... key val toJSON val ] */
-			duk_dup_m4(thr);          /* -> [ ... key val toJSON val key ] */
-			duk_call_method(thr, 1);  /* -> [ ... key val val' ] */
-			duk_remove_m2(thr);       /* -> [ ... key val' ] */
+			duk_dup_m2(thr); /* -> [ ... key val toJSON val ] */
+			duk_dup_m4(thr); /* -> [ ... key val toJSON val key ] */
+			duk_call_method(thr, 1); /* -> [ ... key val val' ] */
+			duk_remove_m2(thr); /* -> [ ... key val' ] */
 		} else {
-			duk_pop(thr);             /* -> [ ... key val ] */
+			duk_pop(thr); /* -> [ ... key val ] */
 		}
 	}
 
 	/* [ ... key val ] */
 
 	DUK_DDD(DUK_DDDPRINT("value=%!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	if (js_ctx->h_replacer) {
 		/* XXX: Here a "slice copy" would be useful. */
 		DUK_DDD(DUK_DDDPRINT("replacer is set, call replacer"));
-		duk_push_hobject(thr, js_ctx->h_replacer);  /* -> [ ... key val replacer ] */
-		duk_dup(thr, idx_holder);                   /* -> [ ... key val replacer holder ] */
-		duk_dup_m4(thr);                            /* -> [ ... key val replacer holder key ] */
-		duk_dup_m4(thr);                            /* -> [ ... key val replacer holder key val ] */
-		duk_call_method(thr, 2);                    /* -> [ ... key val val' ] */
-		duk_remove_m2(thr);                         /* -> [ ... key val' ] */
+		duk_push_hobject(thr, js_ctx->h_replacer); /* -> [ ... key val replacer ] */
+		duk_dup(thr, idx_holder); /* -> [ ... key val replacer holder ] */
+		duk_dup_m4(thr); /* -> [ ... key val replacer holder key ] */
+		duk_dup_m4(thr); /* -> [ ... key val replacer holder key val ] */
+		duk_call_method(thr, 2); /* -> [ ... key val val' ] */
+		duk_remove_m2(thr); /* -> [ ... key val' ] */
 	}
 
 	/* [ ... key val ] */
 
 	DUK_DDD(DUK_DDDPRINT("value=%!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	tv = DUK_GET_TVAL_NEGIDX(thr, -1);
@@ -38483,26 +39497,25 @@
 		duk_hobject *h;
 
 		h = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h != NULL);
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
-		if (DUK_HOBJECT_IS_BUFOBJ(h) &&
-		    js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE)) {
+		if (DUK_HOBJECT_IS_BUFOBJ(h) && js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE)) {
 			/* With JX/JC a bufferobject gets serialized specially. */
 			duk_hbufobj *h_bufobj;
 			h_bufobj = (duk_hbufobj *) h;
 			DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 			duk__json_enc_bufobj(js_ctx, h_bufobj);
 			goto pop2_emitted;
 		}
 		/* Otherwise bufferobjects get serialized as normal objects. */
-#endif  /* JX || JC */
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* JX || JC */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 		c = (duk_small_int_t) DUK_HOBJECT_GET_CLASS_NUMBER(h);
 		switch (c) {
 		case DUK_HOBJECT_CLASS_NUMBER: {
 			DUK_DDD(DUK_DDDPRINT("value is a Number object -> coerce with ToNumber()"));
 			duk_to_number_m1(thr);
 			/* The coercion potentially invokes user .valueOf() and .toString()
 			 * but can't result in a function value because ToPrimitive() would
@@ -38534,32 +39547,31 @@
 			 * Boolean can't result in functions so suffices to check here.
 			 * Symbol objects are handled like plain objects (their primitive
 			 * value is NOT looked up like for e.g. String objects).
 			 */
 			DUK_ASSERT(h != NULL);
 			if (DUK_HOBJECT_IS_CALLABLE(h)) {
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
-				if (js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM |
-				                     DUK_JSON_FLAG_EXT_COMPATIBLE)) {
+				if (js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE)) {
 					/* We only get here when doing non-standard JSON encoding */
 					DUK_DDD(DUK_DDDPRINT("-> function allowed, serialize to custom format"));
 					DUK_ASSERT(js_ctx->flag_ext_custom || js_ctx->flag_ext_compatible);
 					DUK__EMIT_STRIDX(js_ctx, js_ctx->stridx_custom_function);
 					goto pop2_emitted;
 				} else {
 					DUK_DDD(DUK_DDDPRINT("-> will result in undefined (function)"));
 					goto pop2_undef;
 				}
-#else  /* DUK_USE_JX || DUK_USE_JC */
+#else /* DUK_USE_JX || DUK_USE_JC */
 				DUK_DDD(DUK_DDDPRINT("-> will result in undefined (function)"));
 				goto pop2_undef;
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 			}
 		}
-		}  /* end switch */
+		} /* end switch */
 	}
 
 	/* [ ... key val ] */
 
 	DUK_DDD(DUK_DDDPRINT("value=%!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	if (duk_check_type_mask(thr, -1, js_ctx->mask_for_undefined)) {
@@ -38578,25 +39590,24 @@
 	}
 #endif
 	case DUK_TAG_NULL: {
 		DUK__EMIT_STRIDX(js_ctx, DUK_STRIDX_LC_NULL);
 		break;
 	}
 	case DUK_TAG_BOOLEAN: {
-		DUK__EMIT_STRIDX(js_ctx, DUK_TVAL_GET_BOOLEAN(tv) ?
-		                 DUK_STRIDX_TRUE : DUK_STRIDX_FALSE);
+		DUK__EMIT_STRIDX(js_ctx, DUK_TVAL_GET_BOOLEAN(tv) ? DUK_STRIDX_TRUE : DUK_STRIDX_FALSE);
 		break;
 	}
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 	/* When JX/JC not in use, the type mask above will avoid this case if needed. */
 	case DUK_TAG_POINTER: {
 		duk__json_enc_pointer(js_ctx, DUK_TVAL_GET_POINTER(tv));
 		break;
 	}
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 	case DUK_TAG_STRING: {
 		duk_hstring *h = DUK_TVAL_GET_STRING(tv);
 		DUK_ASSERT(h != NULL);
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h))) {
 			goto pop2_undef;
 		}
 		duk__json_enc_quote_string(js_ctx, h);
@@ -38667,22 +39678,22 @@
 		 */
 		duk__json_enc_double(js_ctx);
 		break;
 	}
 	}
 
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
- pop2_emitted:
+pop2_emitted:
 #endif
 	duk_pop_2(thr); /* [ ... key val ] -> [ ... ] */
-	return 1;  /* emitted */
+	return 1; /* emitted */
 
- pop2_undef:
-	duk_pop_2(thr);  /* [ ... key val ] -> [ ... ] */
-	return 0;  /* not emitted */
+pop2_undef:
+	duk_pop_2(thr); /* [ ... key val ] -> [ ... ] */
+	return 0; /* not emitted */
 }
 
 /* E5 Section 15.12.3, main algorithm, step 4.b.ii steps 1-4. */
 DUK_LOCAL duk_bool_t duk__json_enc_allow_into_proplist(duk_tval *tv) {
 	duk_small_int_t c;
 
 	/* XXX: some kind of external internal type checker?
@@ -38750,16 +39761,15 @@
 #endif
 	}
 	case DUK_TAG_NULL: {
 		DUK__EMIT_STRIDX(js_ctx, DUK_STRIDX_LC_NULL);
 		break;
 	}
 	case DUK_TAG_BOOLEAN: {
-		DUK__EMIT_STRIDX(js_ctx, DUK_TVAL_GET_BOOLEAN(tv) ?
-		                 DUK_STRIDX_TRUE : DUK_STRIDX_FALSE);
+		DUK__EMIT_STRIDX(js_ctx, DUK_TVAL_GET_BOOLEAN(tv) ? DUK_STRIDX_TRUE : DUK_STRIDX_FALSE);
 		break;
 	}
 	case DUK_TAG_STRING: {
 		duk_hstring *h;
 		h = DUK_TVAL_GET_STRING(tv);
 		DUK_ASSERT(h != NULL);
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h))) {
@@ -38768,16 +39778,15 @@
 		duk__json_enc_quote_string(js_ctx, h);
 		break;
 	}
 	case DUK_TAG_OBJECT: {
 		duk_hobject *obj;
 		duk_tval *tv_val;
 		duk_bool_t emitted = 0;
-		duk_uint32_t c_bit, c_all, c_array, c_unbox, c_undef,
-		             c_func, c_bufobj, c_object, c_abort;
+		duk_uint32_t c_bit, c_all, c_array, c_unbox, c_undef, c_func, c_bufobj, c_object, c_abort;
 
 		/* For objects JSON.stringify() only looks for own, enumerable
 		 * properties which is nice for the fast path here.
 		 *
 		 * For arrays JSON.stringify() uses [[Get]] so it will actually
 		 * inherit properties during serialization!  This fast path
 		 * supports gappy arrays as long as there's no actual inherited
@@ -38802,15 +39811,15 @@
 		DUK_ASSERT(obj != NULL);
 		DUK_HOBJECT_ASSERT_VALID(obj);
 
 		/* Once recursion depth is increased, exit path must decrease
 		 * it (though it's OK to abort the fast path).
 		 */
 
-		DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0);  /* unsigned */
+		DUK_ASSERT_DISABLE(js_ctx->recursion_depth >= 0); /* unsigned */
 		DUK_ASSERT(js_ctx->recursion_depth <= js_ctx->recursion_limit);
 		if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
 			DUK_DD(DUK_DDPRINT("fast path recursion limit"));
 			DUK_ERROR_RANGE(js_ctx->thr, DUK_STR_DEC_RECLIMIT);
 			DUK_WO_NORETURN(return 0;);
 		}
 
@@ -38854,36 +39863,31 @@
 		 * fast path invocation.
 		 */
 		DUK_ASSERT(DUK_HOBJECT_CLASS_MAX <= 31);
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 		if (js_ctx->flag_ext_custom_or_compatible) {
 			c_all = DUK_HOBJECT_CMASK_ALL;
 			c_array = DUK_HOBJECT_CMASK_ARRAY;
-			c_unbox = DUK_HOBJECT_CMASK_NUMBER |
-			          DUK_HOBJECT_CMASK_STRING |
-			          DUK_HOBJECT_CMASK_BOOLEAN |
-			          DUK_HOBJECT_CMASK_POINTER;  /* Symbols are not unboxed. */
+			c_unbox = DUK_HOBJECT_CMASK_NUMBER | DUK_HOBJECT_CMASK_STRING | DUK_HOBJECT_CMASK_BOOLEAN |
+			          DUK_HOBJECT_CMASK_POINTER; /* Symbols are not unboxed. */
 			c_func = DUK_HOBJECT_CMASK_FUNCTION;
 			c_bufobj = DUK_HOBJECT_CMASK_ALL_BUFOBJS;
 			c_undef = 0;
 			c_abort = 0;
 			c_object = c_all & ~(c_array | c_unbox | c_func | c_bufobj | c_undef | c_abort);
-		}
-		else
+		} else
 #endif
 		{
 			c_all = DUK_HOBJECT_CMASK_ALL;
 			c_array = DUK_HOBJECT_CMASK_ARRAY;
-			c_unbox = DUK_HOBJECT_CMASK_NUMBER |
-			          DUK_HOBJECT_CMASK_STRING |
-			          DUK_HOBJECT_CMASK_BOOLEAN;  /* Symbols are not unboxed. */
+			c_unbox = DUK_HOBJECT_CMASK_NUMBER | DUK_HOBJECT_CMASK_STRING |
+			          DUK_HOBJECT_CMASK_BOOLEAN; /* Symbols are not unboxed. */
 			c_func = 0;
 			c_bufobj = 0;
-			c_undef = DUK_HOBJECT_CMASK_FUNCTION |
-			          DUK_HOBJECT_CMASK_POINTER;
+			c_undef = DUK_HOBJECT_CMASK_FUNCTION | DUK_HOBJECT_CMASK_POINTER;
 			/* As the fast path doesn't currently properly support
 			 * duk_hbufobj virtual properties, abort fast path if
 			 * we encounter them in plain JSON mode.
 			 */
 			c_abort = DUK_HOBJECT_CMASK_ALL_BUFOBJS;
 			c_object = c_all & ~(c_array | c_unbox | c_func | c_bufobj | c_undef | c_abort);
 		}
@@ -38957,15 +39961,15 @@
 			/* If any non-Array value had enumerable virtual own
 			 * properties, they should be serialized here (actually,
 			 * before the explicit properties).  Standard types don't.
 			 */
 
 			if (emitted) {
 				DUK_ASSERT(*((duk_uint8_t *) DUK_BW_GET_PTR(js_ctx->thr, &js_ctx->bw) - 1) == DUK_ASC_COMMA);
-				DUK__UNEMIT_1(js_ctx);  /* eat trailing comma */
+				DUK__UNEMIT_1(js_ctx); /* eat trailing comma */
 				if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 					DUK_ASSERT(js_ctx->recursion_depth >= 1);
 					duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
 				}
 			}
 			DUK__EMIT_1(js_ctx, DUK_ASC_RCURLY);
 		} else if (c_bit & c_array) {
@@ -39027,61 +40031,59 @@
 #if defined(DUK_USE_JX)
 				DUK__EMIT_STRIDX(js_ctx, js_ctx->stridx_custom_undefined);
 #else
 				DUK__EMIT_STRIDX(js_ctx, DUK_STRIDX_LC_NULL);
 #endif
 				/* fall through */
 
-			 elem_done:
+			elem_done:
 				DUK__EMIT_1(js_ctx, DUK_ASC_COMMA);
 				emitted = 1;
 			}
 
 			if (emitted) {
 				DUK_ASSERT(*((duk_uint8_t *) DUK_BW_GET_PTR(js_ctx->thr, &js_ctx->bw) - 1) == DUK_ASC_COMMA);
-				DUK__UNEMIT_1(js_ctx);  /* eat trailing comma */
+				DUK__UNEMIT_1(js_ctx); /* eat trailing comma */
 				if (DUK_UNLIKELY(js_ctx->h_gap != NULL)) {
 					DUK_ASSERT(js_ctx->recursion_depth >= 1);
 					duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
 				}
 			}
 			DUK__EMIT_1(js_ctx, DUK_ASC_RBRACKET);
 		} else if (c_bit & c_unbox) {
 			/* Certain boxed types are required to go through
 			 * automatic unboxing.  Rely on internal value being
 			 * sane (to avoid infinite recursion).
 			 */
-			DUK_ASSERT((c_bit & DUK_HOBJECT_CMASK_SYMBOL) == 0);  /* Symbols are not unboxed. */
+			DUK_ASSERT((c_bit & DUK_HOBJECT_CMASK_SYMBOL) == 0); /* Symbols are not unboxed. */
 
 #if 1
 			/* The code below is incorrect if .toString() or .valueOf() have
 			 * have been overridden.  The correct approach would be to look up
 			 * the method(s) and if they resolve to the built-in function we
 			 * can safely bypass it and look up the internal value directly.
 			 * Unimplemented for now, abort fast path for boxed values.
 			 */
 			goto abort_fastpath;
-#else  /* disabled */
+#else /* disabled */
 			/* Disabled until fixed, see above. */
 			duk_tval *tv_internal;
 
 			DUK_DD(DUK_DDPRINT("auto unboxing in fast path"));
 
 			tv_internal = duk_hobject_get_internal_value_tval_ptr(js_ctx->thr->heap, obj);
 			DUK_ASSERT(tv_internal != NULL);
-			DUK_ASSERT(DUK_TVAL_IS_STRING(tv_internal) ||
-			           DUK_TVAL_IS_NUMBER(tv_internal) ||
-			           DUK_TVAL_IS_BOOLEAN(tv_internal) ||
-			           DUK_TVAL_IS_POINTER(tv_internal));
+			DUK_ASSERT(DUK_TVAL_IS_STRING(tv_internal) || DUK_TVAL_IS_NUMBER(tv_internal) ||
+			           DUK_TVAL_IS_BOOLEAN(tv_internal) || DUK_TVAL_IS_POINTER(tv_internal));
 
 			tv = tv_internal;
 			DUK_ASSERT(js_ctx->recursion_depth > 0);
-			js_ctx->recursion_depth--;  /* required to keep recursion depth correct */
+			js_ctx->recursion_depth--; /* required to keep recursion depth correct */
 			goto restart_match;
-#endif  /* disabled */
+#endif /* disabled */
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 		} else if (c_bit & c_func) {
 			DUK__EMIT_STRIDX(js_ctx, js_ctx->stridx_custom_function);
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 		} else if (c_bit & c_bufobj) {
 			duk__json_enc_bufobj(js_ctx, (duk_hbufobj *) obj);
 #endif
@@ -39186,20 +40188,20 @@
 		DUK_ASSERT(DUK_TVAL_IS_DOUBLE(tv));
 		d = DUK_TVAL_GET_DOUBLE(tv);
 		DUK_SPRINTF(buf, "%lg", d);
 		DUK__EMIT_CSTR(js_ctx, buf);
 #endif
 	}
 	}
-	return 1;  /* not undefined */
+	return 1; /* not undefined */
 
- emit_undefined:
-	return 0;  /* value was undefined/unsupported */
+emit_undefined:
+	return 0; /* value was undefined/unsupported */
 
- abort_fastpath:
+abort_fastpath:
 	/* Error message doesn't matter: the error is ignored anyway. */
 	DUK_DD(DUK_DDPRINT("aborting fast path"));
 	DUK_ERROR_INTERNAL(js_ctx->thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_LOCAL duk_ret_t duk__json_stringify_fast(duk_hthread *thr, void *udata) {
@@ -39211,30 +40213,27 @@
 
 	js_ctx = (duk_json_enc_ctx *) udata;
 	DUK_ASSERT(js_ctx != NULL);
 
 	tv = DUK_GET_TVAL_NEGIDX(thr, -1);
 	if (duk__json_stringify_fast_value(js_ctx, tv) == 0) {
 		DUK_DD(DUK_DDPRINT("top level value not supported, fail fast path"));
-		DUK_DCERROR_TYPE_INVALID_ARGS(thr);  /* Error message is ignored, so doesn't matter. */
+		DUK_DCERROR_TYPE_INVALID_ARGS(thr); /* Error message is ignored, so doesn't matter. */
 	}
 
 	return 0;
 }
-#endif  /* DUK_USE_JSON_STRINGIFY_FASTPATH */
+#endif /* DUK_USE_JSON_STRINGIFY_FASTPATH */
 
 /*
  *  Top level wrappers
  */
 
 DUK_INTERNAL
-void duk_bi_json_parse_helper(duk_hthread *thr,
-                              duk_idx_t idx_value,
-                              duk_idx_t idx_reviver,
-                              duk_small_uint_t flags) {
+void duk_bi_json_parse_helper(duk_hthread *thr, duk_idx_t idx_value, duk_idx_t idx_reviver, duk_small_uint_t flags) {
 	duk_json_dec_ctx js_ctx_alloc;
 	duk_json_dec_ctx *js_ctx = &js_ctx_alloc;
 	duk_hstring *h_text;
 #if defined(DUK_USE_ASSERTIONS)
 	duk_idx_t entry_top = duk_get_top(thr);
 #endif
 
@@ -39267,60 +40266,58 @@
 #if defined(DUK_USE_JC)
 	js_ctx->flag_ext_compatible = flags & DUK_JSON_FLAG_EXT_COMPATIBLE;
 #endif
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
 	js_ctx->flag_ext_custom_or_compatible = flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE);
 #endif
 
-	h_text = duk_to_hstring(thr, idx_value);  /* coerce in-place; rejects Symbols */
+	h_text = duk_to_hstring(thr, idx_value); /* coerce in-place; rejects Symbols */
 	DUK_ASSERT(h_text != NULL);
 
 	/* JSON parsing code is allowed to read [p_start,p_end]: p_end is
 	 * valid and points to the string NUL terminator (which is always
 	 * guaranteed for duk_hstrings.
 	 */
 	js_ctx->p_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_text);
 	js_ctx->p = js_ctx->p_start;
-	js_ctx->p_end = ((const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_text)) +
-	                DUK_HSTRING_GET_BYTELEN(h_text);
+	js_ctx->p_end = ((const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_text)) + DUK_HSTRING_GET_BYTELEN(h_text);
 	DUK_ASSERT(*(js_ctx->p_end) == 0x00);
 
-	duk__json_dec_value(js_ctx);  /* -> [ ... value ] */
+	duk__json_dec_value(js_ctx); /* -> [ ... value ] */
 	DUK_ASSERT(js_ctx->recursion_depth == 0);
 
 	/* Trailing whitespace has been eaten by duk__json_dec_value(), so if
 	 * we're not at end of input here, it's a SyntaxError.
 	 */
 
 	if (js_ctx->p != js_ctx->p_end) {
 		duk__json_dec_syntax_error(js_ctx);
 	}
 
 	if (duk_is_callable(thr, idx_reviver)) {
-		DUK_DDD(DUK_DDDPRINT("applying reviver: %!T",
-		                     (duk_tval *) duk_get_tval(thr, idx_reviver)));
+		DUK_DDD(DUK_DDDPRINT("applying reviver: %!T", (duk_tval *) duk_get_tval(thr, idx_reviver)));
 
 		js_ctx->idx_reviver = idx_reviver;
 
 		duk_push_object(thr);
-		duk_dup_m2(thr);  /* -> [ ... val root val ] */
-		duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_EMPTY_STRING);  /* default attrs ok */
-		duk_push_hstring_stridx(thr, DUK_STRIDX_EMPTY_STRING);  /* -> [ ... val root "" ] */
+		duk_dup_m2(thr); /* -> [ ... val root val ] */
+		duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_EMPTY_STRING); /* default attrs ok */
+		duk_push_hstring_stridx(thr, DUK_STRIDX_EMPTY_STRING); /* -> [ ... val root "" ] */
 
 		DUK_DDD(DUK_DDDPRINT("start reviver walk, root=%!T, name=%!T",
 		                     (duk_tval *) duk_get_tval(thr, -2),
 		                     (duk_tval *) duk_get_tval(thr, -1)));
 
 		DUK_ASSERT(js_ctx->recursion_depth == 0);
-		duk__json_dec_reviver_walk(js_ctx);  /* [ ... val root "" ] -> [ ... val val' ] */
+		duk__json_dec_reviver_walk(js_ctx); /* [ ... val root "" ] -> [ ... val val' ] */
 		DUK_ASSERT(js_ctx->recursion_depth == 0);
-		duk_remove_m2(thr);             /* -> [ ... val' ] */
+		duk_remove_m2(thr); /* -> [ ... val' ] */
 	} else {
-		DUK_DDD(DUK_DDDPRINT("reviver does not exist or is not callable: %!T",
-		                     (duk_tval *) duk_get_tval(thr, idx_reviver)));
+		DUK_DDD(
+		    DUK_DDDPRINT("reviver does not exist or is not callable: %!T", (duk_tval *) duk_get_tval(thr, idx_reviver)));
 	}
 
 	/* Final result is at stack top. */
 
 	DUK_DDD(DUK_DDDPRINT("JSON parse end: text=%!T, reviver=%!T, flags=0x%08lx, result=%!T, stack_top=%ld",
 	                     (duk_tval *) duk_get_tval(thr, idx_value),
 	                     (duk_tval *) duk_get_tval(thr, idx_reviver),
@@ -39386,57 +40383,51 @@
 	js_ctx->flag_ext_custom_or_compatible = flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE);
 #endif
 
 	/* The #if defined() clutter here handles the JX/JC enable/disable
 	 * combinations properly.
 	 */
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
-	js_ctx->stridx_custom_undefined = DUK_STRIDX_LC_NULL;  /* standard JSON; array gaps */
+	js_ctx->stridx_custom_undefined = DUK_STRIDX_LC_NULL; /* standard JSON; array gaps */
 #if defined(DUK_USE_JX)
 	if (flags & DUK_JSON_FLAG_EXT_CUSTOM) {
 		js_ctx->stridx_custom_undefined = DUK_STRIDX_LC_UNDEFINED;
 		js_ctx->stridx_custom_nan = DUK_STRIDX_NAN;
 		js_ctx->stridx_custom_neginf = DUK_STRIDX_MINUS_INFINITY;
 		js_ctx->stridx_custom_posinf = DUK_STRIDX_INFINITY;
 		js_ctx->stridx_custom_function =
-		        (flags & DUK_JSON_FLAG_AVOID_KEY_QUOTES) ?
-		                DUK_STRIDX_JSON_EXT_FUNCTION2 :
-		                DUK_STRIDX_JSON_EXT_FUNCTION1;
+		    (flags & DUK_JSON_FLAG_AVOID_KEY_QUOTES) ? DUK_STRIDX_JSON_EXT_FUNCTION2 : DUK_STRIDX_JSON_EXT_FUNCTION1;
 	}
-#endif  /* DUK_USE_JX */
+#endif /* DUK_USE_JX */
 #if defined(DUK_USE_JX) && defined(DUK_USE_JC)
 	else
-#endif  /* DUK_USE_JX && DUK_USE_JC */
+#endif /* DUK_USE_JX && DUK_USE_JC */
 #if defined(DUK_USE_JC)
-	if (js_ctx->flags & DUK_JSON_FLAG_EXT_COMPATIBLE) {
+	    if (js_ctx->flags & DUK_JSON_FLAG_EXT_COMPATIBLE) {
 		js_ctx->stridx_custom_undefined = DUK_STRIDX_JSON_EXT_UNDEFINED;
 		js_ctx->stridx_custom_nan = DUK_STRIDX_JSON_EXT_NAN;
 		js_ctx->stridx_custom_neginf = DUK_STRIDX_JSON_EXT_NEGINF;
 		js_ctx->stridx_custom_posinf = DUK_STRIDX_JSON_EXT_POSINF;
 		js_ctx->stridx_custom_function = DUK_STRIDX_JSON_EXT_FUNCTION1;
 	}
-#endif  /* DUK_USE_JC */
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+#endif /* DUK_USE_JC */
+#endif /* DUK_USE_JX || DUK_USE_JC */
 
 #if defined(DUK_USE_JX) || defined(DUK_USE_JC)
-	if (js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM |
-	                     DUK_JSON_FLAG_EXT_COMPATIBLE)) {
-		DUK_ASSERT(js_ctx->mask_for_undefined == 0);  /* already zero */
-	}
-	else
-#endif  /* DUK_USE_JX || DUK_USE_JC */
+	if (js_ctx->flags & (DUK_JSON_FLAG_EXT_CUSTOM | DUK_JSON_FLAG_EXT_COMPATIBLE)) {
+		DUK_ASSERT(js_ctx->mask_for_undefined == 0); /* already zero */
+	} else
+#endif /* DUK_USE_JX || DUK_USE_JC */
 	{
 		/* Plain buffer is treated like ArrayBuffer and serialized.
 		 * Lightfuncs are treated like objects, but JSON explicitly
 		 * skips serializing Function objects so we can just reject
 		 * lightfuncs here.
 		 */
-		js_ctx->mask_for_undefined = DUK_TYPE_MASK_UNDEFINED |
-		                             DUK_TYPE_MASK_POINTER |
-		                             DUK_TYPE_MASK_LIGHTFUNC;
+		js_ctx->mask_for_undefined = DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_POINTER | DUK_TYPE_MASK_LIGHTFUNC;
 	}
 
 	DUK_BW_INIT_PUSHBUF(thr, &js_ctx->bw, DUK__JSON_STRINGIFY_BUFSIZE);
 
 	js_ctx->idx_loop = duk_push_bare_object(thr);
 	DUK_ASSERT(js_ctx->idx_loop >= 0);
 
@@ -39458,36 +40449,35 @@
 			 */
 
 			duk_uarridx_t plist_idx = 0;
 			duk_small_uint_t enum_flags;
 
 			js_ctx->idx_proplist = duk_push_bare_array(thr);
 
-			enum_flags = DUK_ENUM_ARRAY_INDICES_ONLY |
-			             DUK_ENUM_SORT_ARRAY_INDICES;  /* expensive flag */
+			enum_flags = DUK_ENUM_ARRAY_INDICES_ONLY | DUK_ENUM_SORT_ARRAY_INDICES; /* expensive flag */
 			duk_enum(thr, idx_replacer, enum_flags);
 			while (duk_next(thr, -1 /*enum_index*/, 1 /*get_value*/)) {
 				/* [ ... proplist enum_obj key val ] */
 				if (duk__json_enc_allow_into_proplist(duk_get_tval(thr, -1))) {
 					/* XXX: duplicates should be eliminated here */
 					DUK_DDD(DUK_DDDPRINT("proplist enum: key=%!T, val=%!T --> accept",
 					                     (duk_tval *) duk_get_tval(thr, -2),
 					                     (duk_tval *) duk_get_tval(thr, -1)));
-					duk_to_string(thr, -1);  /* extra coercion of strings is OK */
-					duk_put_prop_index(thr, -4, plist_idx);  /* -> [ ... proplist enum_obj key ] */
+					duk_to_string(thr, -1); /* extra coercion of strings is OK */
+					duk_put_prop_index(thr, -4, plist_idx); /* -> [ ... proplist enum_obj key ] */
 					plist_idx++;
 					duk_pop(thr);
 				} else {
 					DUK_DDD(DUK_DDDPRINT("proplist enum: key=%!T, val=%!T --> reject",
 					                     (duk_tval *) duk_get_tval(thr, -2),
 					                     (duk_tval *) duk_get_tval(thr, -1)));
 					duk_pop_2(thr);
 				}
-                        }
-                        duk_pop(thr);  /* pop enum */
+			}
+			duk_pop(thr); /* pop enum */
 
 			/* [ ... proplist ] */
 		}
 	}
 
 	/* [ ... buf loop (proplist) ] */
 
@@ -39505,29 +40495,28 @@
 		}
 	}
 
 	if (duk_is_number(thr, idx_space)) {
 		duk_small_int_t nspace;
 		/* spaces[] must be static to allow initializer with old compilers like BCC */
 		static const char spaces[10] = {
-			DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE,
-			DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE,
-			DUK_ASC_SPACE, DUK_ASC_SPACE
-		};  /* XXX: helper */
+			DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE,
+			DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE, DUK_ASC_SPACE
+		}; /* XXX: helper */
 
 		/* ToInteger() coercion; NaN -> 0, infinities are clamped to 0 and 10 */
 		nspace = (duk_small_int_t) duk_to_int_clamped(thr, idx_space, 0 /*minval*/, 10 /*maxval*/);
 		DUK_ASSERT(nspace >= 0 && nspace <= 10);
 
 		duk_push_lstring(thr, spaces, (duk_size_t) nspace);
 		js_ctx->h_gap = duk_known_hstring(thr, -1);
 		DUK_ASSERT(js_ctx->h_gap != NULL);
 	} else if (duk_is_string_notsymbol(thr, idx_space)) {
 		duk_dup(thr, idx_space);
-		duk_substring(thr, -1, 0, 10);  /* clamp to 10 chars */
+		duk_substring(thr, -1, 0, 10); /* clamp to 10 chars */
 		js_ctx->h_gap = duk_known_hstring(thr, -1);
 	} else {
 		/* nop */
 	}
 
 	if (js_ctx->h_gap != NULL) {
 		/* If gap is empty, behave as if not given at all.  Check
@@ -39543,16 +40532,16 @@
 
 	/*
 	 *  Fast path: assume no mutation, iterate object property tables
 	 *  directly; bail out if that assumption doesn't hold.
 	 */
 
 #if defined(DUK_USE_JSON_STRINGIFY_FASTPATH)
-	if (js_ctx->h_replacer == NULL &&  /* replacer is a mutation risk */
-	    js_ctx->idx_proplist == -1) {  /* proplist is very rare */
+	if (js_ctx->h_replacer == NULL && /* replacer is a mutation risk */
+	    js_ctx->idx_proplist == -1) { /* proplist is very rare */
 		duk_int_t pcall_rc;
 		duk_small_uint_t prev_ms_base_flags;
 
 		DUK_DD(DUK_DDPRINT("try JSON.stringify() fast path"));
 
 		/* Use recursion_limit to ensure we don't overwrite js_ctx->visiting[]
 		 * array so we don't need two counter checks in the fast path.  The
@@ -39569,18 +40558,17 @@
 		 * limited loop detection).
 		 */
 
 		duk_dup(thr, idx_value);
 
 		/* Must prevent finalizers which may have arbitrary side effects. */
 		prev_ms_base_flags = thr->heap->ms_base_flags;
-		thr->heap->ms_base_flags |=
-		        DUK_MS_FLAG_NO_OBJECT_COMPACTION;      /* Avoid attempt to compact any objects. */
-		thr->heap->pf_prevent_count++;                 /* Prevent finalizers. */
-		DUK_ASSERT(thr->heap->pf_prevent_count != 0);  /* Wrap. */
+		thr->heap->ms_base_flags |= DUK_MS_FLAG_NO_OBJECT_COMPACTION; /* Avoid attempt to compact any objects. */
+		thr->heap->pf_prevent_count++; /* Prevent finalizers. */
+		DUK_ASSERT(thr->heap->pf_prevent_count != 0); /* Wrap. */
 
 		pcall_rc = duk_safe_call(thr, duk__json_stringify_fast, (void *) js_ctx /*udata*/, 1 /*nargs*/, 0 /*nret*/);
 
 		DUK_ASSERT(thr->heap->pf_prevent_count > 0);
 		thr->heap->pf_prevent_count--;
 		thr->heap->ms_base_flags = prev_ms_base_flags;
 
@@ -39623,15 +40611,15 @@
 	duk_push_hstring_empty(thr);
 
 	/* [ ... buf loop (proplist) (gap) holder "" ] */
 
 	js_ctx->recursion_limit = DUK_USE_JSON_ENC_RECLIMIT;
 	DUK_ASSERT(js_ctx->recursion_depth == 0);
 
-	if (DUK_UNLIKELY(duk__json_enc_value(js_ctx, idx_holder) == 0)) {  /* [ ... holder key ] -> [ ... holder ] */
+	if (DUK_UNLIKELY(duk__json_enc_value(js_ctx, idx_holder) == 0)) { /* [ ... holder key ] -> [ ... holder ] */
 		/* Result is undefined. */
 		duk_push_undefined(thr);
 	} else {
 		/* Convert buffer to result string. */
 		DUK_BW_PUSH_AS_STRING(thr, &js_ctx->bw);
 	}
 
@@ -39645,15 +40633,15 @@
 	                     (duk_tval *) duk_get_tval(thr, idx_holder)));
 
 	/* The stack has a variable shape here, so force it to the
 	 * desired one explicitly.
 	 */
 
 #if defined(DUK_USE_JSON_STRINGIFY_FASTPATH)
- replace_finished:
+replace_finished:
 #endif
 	duk_replace(thr, entry_top);
 	duk_set_top(thr, entry_top + 1);
 
 	DUK_DDD(DUK_DDDPRINT("JSON stringify end: value=%!T, replacer=%!T, space=%!T, "
 	                     "flags=0x%08lx, result=%!T, stack_top=%ld",
 	                     (duk_tval *) duk_get_tval(thr, idx_value),
@@ -39669,33 +40657,26 @@
 #if defined(DUK_USE_JSON_BUILTIN)
 
 /*
  *  Entry points
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_json_object_parse(duk_hthread *thr) {
-	duk_bi_json_parse_helper(thr,
-	                         0 /*idx_value*/,
-	                         1 /*idx_replacer*/,
-	                         0 /*flags*/);
+	duk_bi_json_parse_helper(thr, 0 /*idx_value*/, 1 /*idx_replacer*/, 0 /*flags*/);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_json_object_stringify(duk_hthread *thr) {
-	duk_bi_json_stringify_helper(thr,
-	                             0 /*idx_value*/,
-	                             1 /*idx_replacer*/,
-	                             2 /*idx_space*/,
-	                             0 /*flags*/);
+	duk_bi_json_stringify_helper(thr, 0 /*idx_value*/, 1 /*idx_replacer*/, 2 /*idx_space*/, 0 /*flags*/);
 	return 1;
 }
 
-#endif  /* DUK_USE_JSON_BUILTIN */
+#endif /* DUK_USE_JSON_BUILTIN */
 
-#endif  /* DUK_USE_JSON_SUPPORT */
+#endif /* DUK_USE_JSON_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__EMIT_1
 #undef DUK__EMIT_2
 #undef DUK__EMIT_CSTR
 #undef DUK__EMIT_HSTR
 #undef DUK__EMIT_STRIDX
@@ -39846,15 +40827,15 @@
 #else
 	/* Handles -0 correctly: -0.0 matches 'x >= 0.0' but floor()
 	 * is required to return -0 when the argument is -0.
 	 */
 	return x >= 0.0 ? DUK_FLOOR(x) : DUK_CEIL(x);
 #endif
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 DUK_LOCAL double duk__round_fixed(double x) {
 	/* Numbers half-way between integers must be rounded towards +Infinity,
 	 * e.g. -3.5 must be rounded to -3 (not -4).  When rounded to zero, zero
 	 * sign must be set appropriately.  E5.1 Section 15.8.2.15.
 	 *
 	 * Note that ANSI C round() is "round to nearest integer, away from zero",
@@ -39961,59 +40942,31 @@
 	DUK_ASSERT(duk_double_equals(DUK_ATAN2(-DUK_DOUBLE_INFINITY, DUK_DOUBLE_INFINITY), -0.7853981633974483));
 	DUK_ASSERT(duk_double_equals(DUK_ATAN2(DUK_DOUBLE_INFINITY, -DUK_DOUBLE_INFINITY), 2.356194490192345));
 	DUK_ASSERT(duk_double_equals(DUK_ATAN2(-DUK_DOUBLE_INFINITY, -DUK_DOUBLE_INFINITY), -2.356194490192345));
 #endif
 
 	return DUK_ATAN2(x, y);
 }
-#endif  /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
+#endif /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
 
 /* order must match constants in genbuiltins.py */
 DUK_LOCAL const duk__one_arg_func duk__one_arg_funcs[] = {
 #if defined(DUK_USE_AVOID_PLATFORM_FUNCPTRS)
-	duk__fabs,
-	duk__acos,
-	duk__asin,
-	duk__atan,
-	duk__ceil,
-	duk__cos,
-	duk__exp,
-	duk__floor,
-	duk__log,
-	duk__round_fixed,
-	duk__sin,
-	duk__sqrt,
-	duk__tan,
+	duk__fabs,  duk__acos, duk__asin,        duk__atan, duk__ceil, duk__cos, duk__exp,
+	duk__floor, duk__log,  duk__round_fixed, duk__sin,  duk__sqrt, duk__tan,
 #if defined(DUK_USE_ES6)
-	duk__cbrt,
-	duk__log2,
-	duk__log10,
-	duk__trunc
-#endif
-#else  /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
-	DUK_FABS,
-	DUK_ACOS,
-	DUK_ASIN,
-	DUK_ATAN,
-	DUK_CEIL,
-	DUK_COS,
-	DUK_EXP,
-	DUK_FLOOR,
-	DUK_LOG,
-	duk__round_fixed,
-	DUK_SIN,
-	DUK_SQRT,
-	DUK_TAN,
+	duk__cbrt,  duk__log2, duk__log10,       duk__trunc
+#endif
+#else /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
+	DUK_FABS,  DUK_ACOS,  DUK_ASIN,         DUK_ATAN,  DUK_CEIL, DUK_COS, DUK_EXP,
+	DUK_FLOOR, DUK_LOG,   duk__round_fixed, DUK_SIN,   DUK_SQRT, DUK_TAN,
 #if defined(DUK_USE_ES6)
-	duk__cbrt,
-	duk__log2,
-	duk__log10,
-	duk__trunc
+	duk__cbrt, duk__log2, duk__log10,       duk__trunc
 #endif
-#endif  /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
+#endif /* DUK_USE_AVOID_PLATFORM_FUNCPTRS */
 };
 
 /* order must match constants in genbuiltins.py */
 DUK_LOCAL const duk__two_arg_func duk__two_arg_funcs[] = {
 #if defined(DUK_USE_AVOID_PLATFORM_FUNCPTRS)
 	duk__atan2_fixed,
 	duk_js_arith_pow
@@ -40040,15 +40993,15 @@
 	duk_small_int_t fun_idx = duk_get_current_magic(thr);
 	duk__two_arg_func fun;
 	duk_double_t arg1;
 	duk_double_t arg2;
 
 	DUK_ASSERT(fun_idx >= 0);
 	DUK_ASSERT(fun_idx < (duk_small_int_t) (sizeof(duk__two_arg_funcs) / sizeof(duk__two_arg_func)));
-	arg1 = duk_to_number(thr, 0);  /* explicit ordered evaluation to match coercion semantics */
+	arg1 = duk_to_number(thr, 0); /* explicit ordered evaluation to match coercion semantics */
 	arg2 = duk_to_number(thr, 1);
 	fun = duk__two_arg_funcs[fun_idx];
 	duk_push_number(thr, (duk_double_t) fun((double) arg1, (double) arg2));
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_math_object_max(duk_hthread *thr) {
@@ -40056,15 +41009,15 @@
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_math_object_min(duk_hthread *thr) {
 	return duk__math_minmax(thr, DUK_DOUBLE_INFINITY, duk__fmin_fixed);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_math_object_random(duk_hthread *thr) {
-	duk_push_number(thr, (duk_double_t) DUK_UTIL_GET_RANDOM_DOUBLE(thr));
+	duk_push_number(thr, (duk_double_t) duk_util_get_random_double(thr));
 	return 1;
 }
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_math_object_hypot(duk_hthread *thr) {
 	/*
 	 *  E6 Section 20.2.2.18: Math.hypot
@@ -40126,33 +41079,33 @@
 		comp = (prelim - sum) - summand;
 		sum = prelim;
 	}
 
 	duk_push_number(thr, (duk_double_t) DUK_SQRT(sum) * max);
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_math_object_sign(duk_hthread *thr) {
 	duk_double_t d;
 
 	d = duk_to_number(thr, 0);
 	if (duk_double_is_nan(d)) {
 		DUK_ASSERT(duk_is_nan(thr, -1));
-		return 1;  /* NaN input -> return NaN */
+		return 1; /* NaN input -> return NaN */
 	}
 	if (duk_double_equals(d, 0.0)) {
 		/* Zero sign kept, i.e. -0 -> -0, +0 -> +0. */
 		return 1;
 	}
 	duk_push_int(thr, (d > 0.0 ? 1 : -1));
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_math_object_clz32(duk_hthread *thr) {
 	duk_uint32_t x;
 	duk_small_uint_t i;
 
 #if defined(DUK_USE_PREFER_SIZE)
@@ -40164,15 +41117,15 @@
 			break;
 		}
 		i++;
 	}
 	DUK_ASSERT(i <= 32);
 	duk_push_uint(thr, i);
 	return 1;
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	i = 0;
 	x = duk_to_uint32(thr, 0);
 	if (x & 0xffff0000UL) {
 		x >>= 16;
 	} else {
 		i += 16;
 	}
@@ -40200,17 +41153,17 @@
 		;
 	} else {
 		i += 1;
 	}
 	DUK_ASSERT(i <= 32);
 	duk_push_uint(thr, i);
 	return 1;
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_math_object_imul(duk_hthread *thr) {
 	duk_uint32_t x, y, z;
 
 	x = duk_to_uint32(thr, 0);
 	y = duk_to_uint32(thr, 1);
@@ -40219,17 +41172,17 @@
 	/* While arguments are ToUint32() coerced and the multiplication
 	 * is unsigned as such, the final result is curiously interpreted
 	 * as a signed 32-bit value.
 	 */
 	duk_push_i32(thr, (duk_int32_t) z);
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
-#endif  /* DUK_USE_MATH_BUILTIN */
+#endif /* DUK_USE_MATH_BUILTIN */
 #line 1 "duk_bi_number.c"
 /*
  *  Number built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -40244,27 +41197,27 @@
 
 	duk_push_this(thr);
 	if (duk_is_number(thr, -1)) {
 		DUK_DDD(DUK_DDDPRINT("plain number value: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 		goto done;
 	}
 	h = duk_get_hobject(thr, -1);
-	if (!h ||
-	    (DUK_HOBJECT_GET_CLASS_NUMBER(h) != DUK_HOBJECT_CLASS_NUMBER)) {
+	if (!h || (DUK_HOBJECT_GET_CLASS_NUMBER(h) != DUK_HOBJECT_CLASS_NUMBER)) {
 		DUK_DDD(DUK_DDDPRINT("unacceptable this value: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 		DUK_ERROR_TYPE(thr, "number expected");
 		DUK_WO_NORETURN(return 0.0;);
 	}
 	duk_xget_owndataprop_stridx_short(thr, -1, DUK_STRIDX_INT_VALUE);
 	DUK_ASSERT(duk_is_number(thr, -1));
 	DUK_DDD(DUK_DDDPRINT("number object: %!T, internal value: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
+	                     (duk_tval *) duk_get_tval(thr, -2),
+	                     (duk_tval *) duk_get_tval(thr, -1)));
 	duk_remove_m2(thr);
 
- done:
+done:
 	return duk_get_number(thr, -1);
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_number_constructor(duk_hthread *thr) {
 	duk_idx_t nargs;
 	duk_hobject *h_this;
 
@@ -40305,17 +41258,17 @@
 	h_this = duk_known_hobject(thr, -1);
 	DUK_HOBJECT_SET_CLASS_NUMBER(h_this, DUK_HOBJECT_CLASS_NUMBER);
 
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h_this) == thr->builtins[DUK_BIDX_NUMBER_PROTOTYPE]);
 	DUK_ASSERT(DUK_HOBJECT_GET_CLASS_NUMBER(h_this) == DUK_HOBJECT_CLASS_NUMBER);
 	DUK_ASSERT(DUK_HOBJECT_HAS_EXTENSIBLE(h_this));
 
-	duk_dup_0(thr);  /* -> [ val obj val ] */
+	duk_dup_0(thr); /* -> [ val obj val ] */
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE);
-	return 0;  /* no return value -> don't replace created value */
+	return 0; /* no return value -> don't replace created value */
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_number_prototype_value_of(duk_hthread *thr) {
 	(void) duk__push_this_number_plain(thr);
 	return 1;
 }
 
@@ -40329,18 +41282,15 @@
 	} else {
 		radix = (duk_small_int_t) duk_to_int_check_range(thr, 0, 2, 36);
 	}
 	DUK_DDD(DUK_DDDPRINT("radix=%ld", (long) radix));
 
 	n2s_flags = 0;
 
-	duk_numconv_stringify(thr,
-	                      radix /*radix*/,
-	                      0 /*digits*/,
-	                      n2s_flags /*flags*/);
+	duk_numconv_stringify(thr, radix /*radix*/, 0 /*digits*/, n2s_flags /*flags*/);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_number_prototype_to_locale_string(duk_hthread *thr) {
 	/* XXX: just use toString() for now; permitted although not recommended.
 	 * nargs==1, so radix is passed to toString().
 	 */
@@ -40370,24 +41320,20 @@
 		goto use_to_string;
 	}
 
 	if (d >= 1.0e21 || d <= -1.0e21) {
 		goto use_to_string;
 	}
 
-	n2s_flags = DUK_N2S_FLAG_FIXED_FORMAT |
-	            DUK_N2S_FLAG_FRACTION_DIGITS;
+	n2s_flags = DUK_N2S_FLAG_FIXED_FORMAT | DUK_N2S_FLAG_FRACTION_DIGITS;
 
-	duk_numconv_stringify(thr,
-	                      10 /*radix*/,
-	                      frac_digits /*digits*/,
-	                      n2s_flags /*flags*/);
+	duk_numconv_stringify(thr, 10 /*radix*/, frac_digits /*digits*/, n2s_flags /*flags*/);
 	return 1;
 
- use_to_string:
+use_to_string:
 	DUK_ASSERT_TOP(thr, 2);
 	duk_to_string(thr, -1);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_number_prototype_to_exponential(duk_hthread *thr) {
 	duk_bool_t frac_undefined;
@@ -40395,33 +41341,29 @@
 	duk_double_t d;
 	duk_small_int_t c;
 	duk_small_uint_t n2s_flags;
 
 	d = duk__push_this_number_plain(thr);
 
 	frac_undefined = duk_is_undefined(thr, 0);
-	duk_to_int(thr, 0);  /* for side effects */
+	duk_to_int(thr, 0); /* for side effects */
 
 	c = (duk_small_int_t) DUK_FPCLASSIFY(d);
 	if (c == DUK_FP_NAN || c == DUK_FP_INFINITE) {
 		goto use_to_string;
 	}
 
 	frac_digits = (duk_small_int_t) duk_to_int_check_range(thr, 0, 0, 20);
 
-	n2s_flags = DUK_N2S_FLAG_FORCE_EXP |
-	           (frac_undefined ? 0 : DUK_N2S_FLAG_FIXED_FORMAT);
+	n2s_flags = DUK_N2S_FLAG_FORCE_EXP | (frac_undefined ? 0 : DUK_N2S_FLAG_FIXED_FORMAT);
 
-	duk_numconv_stringify(thr,
-	                      10 /*radix*/,
-	                      frac_digits + 1 /*leading digit + fractions*/,
-	                      n2s_flags /*flags*/);
+	duk_numconv_stringify(thr, 10 /*radix*/, frac_digits + 1 /*leading digit + fractions*/, n2s_flags /*flags*/);
 	return 1;
 
- use_to_string:
+use_to_string:
 	DUK_ASSERT_TOP(thr, 2);
 	duk_to_string(thr, -1);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_number_prototype_to_precision(duk_hthread *thr) {
 	/* The specification has quite awkward order of coercion and
@@ -40438,33 +41380,29 @@
 
 	d = duk__push_this_number_plain(thr);
 	if (duk_is_undefined(thr, 0)) {
 		goto use_to_string;
 	}
 	DUK_ASSERT_TOP(thr, 2);
 
-	duk_to_int(thr, 0);  /* for side effects */
+	duk_to_int(thr, 0); /* for side effects */
 
 	c = (duk_small_int_t) DUK_FPCLASSIFY(d);
 	if (c == DUK_FP_NAN || c == DUK_FP_INFINITE) {
 		goto use_to_string;
 	}
 
 	prec = (duk_small_int_t) duk_to_int_check_range(thr, 0, 1, 21);
 
-	n2s_flags = DUK_N2S_FLAG_FIXED_FORMAT |
-	            DUK_N2S_FLAG_NO_ZERO_PAD;
+	n2s_flags = DUK_N2S_FLAG_FIXED_FORMAT | DUK_N2S_FLAG_NO_ZERO_PAD;
 
-	duk_numconv_stringify(thr,
-	                      10 /*radix*/,
-	                      prec /*digits*/,
-	                      n2s_flags /*flags*/);
+	duk_numconv_stringify(thr, 10 /*radix*/, prec /*digits*/, n2s_flags /*flags*/);
 	return 1;
 
- use_to_string:
+use_to_string:
 	/* Used when precision is undefined; also used for NaN (-> "NaN"),
 	 * and +/- infinity (-> "Infinity", "-Infinity").
 	 */
 
 	DUK_ASSERT_TOP(thr, 2);
 	duk_to_string(thr, -1);
 	return 1;
@@ -40482,35 +41420,35 @@
 	if (duk_is_number(thr, 0)) {
 		duk_double_t d;
 
 		magic = duk_get_current_magic(thr);
 		d = duk_get_number(thr, 0);
 
 		switch (magic) {
-		case 0:  /* isFinite() */
+		case 0: /* isFinite() */
 			ret = duk_double_is_finite(d);
 			break;
-		case 1:  /* isInteger() */
+		case 1: /* isInteger() */
 			ret = duk_double_is_integer(d);
 			break;
-		case 2:  /* isNaN() */
+		case 2: /* isNaN() */
 			ret = duk_double_is_nan(d);
 			break;
-		default:  /* isSafeInteger() */
+		default: /* isSafeInteger() */
 			DUK_ASSERT(magic == 3);
 			ret = duk_double_is_safe_integer(d);
 		}
 	}
 
 	duk_push_boolean(thr, ret);
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
-#endif  /* DUK_USE_NUMBER_BUILTIN */
+#endif /* DUK_USE_NUMBER_BUILTIN */
 #line 1 "duk_bi_object.c"
 /*
  *  Object built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -40525,48 +41463,42 @@
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor(duk_hthread *thr) {
 	duk_uint_t arg_mask;
 
 	arg_mask = duk_get_type_mask(thr, 0);
 
-	if (!duk_is_constructor_call(thr) &&  /* not a constructor call */
-	    ((arg_mask & (DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_UNDEFINED)) == 0)) {  /* and argument not null or undefined */
+	if (!duk_is_constructor_call(thr) && /* not a constructor call */
+	    ((arg_mask & (DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_UNDEFINED)) == 0)) { /* and argument not null or undefined */
 		duk_to_object(thr, 0);
 		return 1;
 	}
 
 	/* Pointer and buffer primitive values are treated like other
 	 * primitives values which have a fully fledged object counterpart:
 	 * promote to an object value.  Lightfuncs and plain buffers are
 	 * coerced with ToObject() even they could also be returned as is.
 	 */
-	if (arg_mask & (DUK_TYPE_MASK_OBJECT |
-	                DUK_TYPE_MASK_STRING |
-	                DUK_TYPE_MASK_BOOLEAN |
-	                DUK_TYPE_MASK_NUMBER |
-	                DUK_TYPE_MASK_POINTER |
-	                DUK_TYPE_MASK_BUFFER |
-	                DUK_TYPE_MASK_LIGHTFUNC)) {
+	if (arg_mask & (DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_BOOLEAN | DUK_TYPE_MASK_NUMBER |
+	                DUK_TYPE_MASK_POINTER | DUK_TYPE_MASK_BUFFER | DUK_TYPE_MASK_LIGHTFUNC)) {
 		/* For DUK_TYPE_OBJECT the coercion is a no-op and could
 		 * be checked for explicitly, but Object(obj) calls are
 		 * not very common so opt for minimal footprint.
 		 */
 		duk_to_object(thr, 0);
 		return 1;
 	}
 
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
 	                              DUK_BIDX_OBJECT_PROTOTYPE);
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) && defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_assign(duk_hthread *thr) {
 	duk_idx_t nargs;
 	duk_int_t idx;
 
 	nargs = duk_get_top_require_min(thr, 1 /*min_top*/);
@@ -40615,17 +41547,16 @@
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	duk_hbufobj_promote_plain(thr, 0);
 #endif
 	proto = duk_require_hobject_accept_mask(thr, 0, DUK_TYPE_MASK_NULL);
 	DUK_ASSERT(proto != NULL || duk_is_null(thr, 0));
 
 	(void) duk_push_object_helper_proto(thr,
-	                                    DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                    DUK_HOBJECT_FLAG_FASTREFS |
-	                                    DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                                    DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
 	                                    proto);
 
 	if (!duk_is_undefined(thr, 1)) {
 		/* [ O Properties obj ] */
 
 		duk_replace(thr, 0);
 
@@ -40638,47 +41569,45 @@
 		return duk_bi_object_constructor_define_properties(thr);
 	}
 
 	/* [ O Properties obj ] */
 
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_define_properties(duk_hthread *thr) {
 	duk_small_uint_t pass;
 	duk_uint_t defprop_flags;
 	duk_hobject *obj;
 	duk_idx_t idx_value;
 	duk_hobject *get;
 	duk_hobject *set;
 
 	/* Lightfunc and plain buffer handling by ToObject() coercion. */
 	obj = duk_require_hobject_promote_mask(thr, 0, DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER);
 	DUK_ASSERT(obj != NULL);
 
-	duk_to_object(thr, 1);        /* properties object */
+	duk_to_object(thr, 1); /* properties object */
 
-	DUK_DDD(DUK_DDDPRINT("target=%!iT, properties=%!iT",
-	                     (duk_tval *) duk_get_tval(thr, 0),
-	                     (duk_tval *) duk_get_tval(thr, 1)));
+	DUK_DDD(DUK_DDDPRINT("target=%!iT, properties=%!iT", (duk_tval *) duk_get_tval(thr, 0), (duk_tval *) duk_get_tval(thr, 1)));
 
 	/*
 	 *  Two pass approach to processing the property descriptors.
 	 *  On first pass validate and normalize all descriptors before
 	 *  any changes are made to the target object.  On second pass
 	 *  make the actual modifications to the target object.
 	 *
 	 *  Right now we'll just use the same normalize/validate helper
 	 *  on both passes, ignoring its outputs on the first pass.
 	 */
 
 	for (pass = 0; pass < 2; pass++) {
-		duk_set_top(thr, 2);  /* -> [ hobject props ] */
+		duk_set_top(thr, 2); /* -> [ hobject props ] */
 		duk_enum(thr, 1, DUK_ENUM_OWN_PROPERTIES_ONLY | DUK_ENUM_INCLUDE_SYMBOLS /*enum_flags*/);
 
 		for (;;) {
 			duk_hstring *key;
 
 			/* [ hobject props enum(props) ] */
 
@@ -40690,142 +41619,131 @@
 
 			DUK_DDD(DUK_DDDPRINT("-> key=%!iT, desc=%!iT",
 			                     (duk_tval *) duk_get_tval(thr, -2),
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 
 			/* [ hobject props enum(props) key desc ] */
 
-			duk_hobject_prepare_property_descriptor(thr,
-			                                        4 /*idx_desc*/,
-			                                        &defprop_flags,
-			                                        &idx_value,
-			                                        &get,
-			                                        &set);
+			duk_hobject_prepare_property_descriptor(thr, 4 /*idx_desc*/, &defprop_flags, &idx_value, &get, &set);
 
 			/* [ hobject props enum(props) key desc [multiple values] ] */
 
 			if (pass == 0) {
 				continue;
 			}
 
 			/* This allows symbols on purpose. */
 			key = duk_known_hstring(thr, 3);
 			DUK_ASSERT(key != NULL);
 
-			duk_hobject_define_property_helper(thr,
-			                                   defprop_flags,
-			                                   obj,
-			                                   key,
-			                                   idx_value,
-			                                   get,
-			                                   set,
-			                                   1 /*throw_flag*/);
+			duk_hobject_define_property_helper(thr, defprop_flags, obj, key, idx_value, get, set, 1 /*throw_flag*/);
 		}
 	}
 
 	/*
 	 *  Return target object
 	 */
 
 	duk_dup_0(thr);
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_seal_freeze_shared(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 1);
 
 	duk_seal_freeze_raw(thr, 0, (duk_bool_t) duk_get_current_magic(thr) /*is_freeze*/);
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_is_sealed_frozen_shared(duk_hthread *thr) {
 	duk_hobject *h;
 	duk_bool_t is_frozen;
 	duk_uint_t mask;
 
 	is_frozen = (duk_bool_t) duk_get_current_magic(thr);
 	mask = duk_get_type_mask(thr, 0);
 	if (mask & (DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER)) {
 		DUK_ASSERT(is_frozen == 0 || is_frozen == 1);
-		duk_push_boolean(thr, (mask & DUK_TYPE_MASK_LIGHTFUNC) ?
-		                          1 :               /* lightfunc always frozen and sealed */
-		                          (is_frozen ^ 1)); /* buffer sealed but not frozen (index props writable) */
+		duk_push_boolean(thr,
+		                 (mask & DUK_TYPE_MASK_LIGHTFUNC) ? 1 : /* lightfunc always frozen and sealed */
+                                     (is_frozen ^ 1)); /* buffer sealed but not frozen (index props writable) */
 	} else {
 		/* ES2015 Sections 19.1.2.12, 19.1.2.13: anything other than an object
 		 * is considered to be already sealed and frozen.
 		 */
 		h = duk_get_hobject(thr, 0);
-		duk_push_boolean(thr, (h == NULL) ||
-		                      duk_hobject_object_is_sealed_frozen_helper(thr, h, is_frozen /*is_frozen*/));
+		duk_push_boolean(thr, (h == NULL) || duk_hobject_object_is_sealed_frozen_helper(thr, h, is_frozen /*is_frozen*/));
 	}
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_to_locale_string(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 0);
 	(void) duk_push_this_coercible_to_object(thr);
 	duk_get_prop_stridx_short(thr, 0, DUK_STRIDX_TO_STRING);
-#if 0  /* This is mentioned explicitly in the E5.1 spec, but duk_call_method() checks for it in practice. */
+#if 0 /* This is mentioned explicitly in the E5.1 spec, but duk_call_method() checks for it in practice. */
 	duk_require_callable(thr, 1);
 #endif
-	duk_dup_0(thr);  /* -> [ O toString O ] */
-	duk_call_method(thr, 0);  /* XXX: call method tail call? */
+	duk_dup_0(thr); /* -> [ O toString O ] */
+	duk_call_method(thr, 0); /* XXX: call method tail call? */
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_value_of(duk_hthread *thr) {
 	/* For lightfuncs and plain buffers, returns Object() coerced. */
 	(void) duk_push_this_coercible_to_object(thr);
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_is_prototype_of(duk_hthread *thr) {
 	duk_hobject *h_v;
 	duk_hobject *h_obj;
 
 	DUK_ASSERT_TOP(thr, 1);
 
 	h_v = duk_get_hobject(thr, 0);
 	if (!h_v) {
-		duk_push_false(thr);  /* XXX: tail call: return duk_push_false(thr) */
+		duk_push_false(thr); /* XXX: tail call: return duk_push_false(thr) */
 		return 1;
 	}
 
 	h_obj = duk_push_this_coercible_to_object(thr);
 	DUK_ASSERT(h_obj != NULL);
 
 	/* E5.1 Section 15.2.4.6, step 3.a, lookup proto once before compare.
 	 * Prototype loops should cause an error to be thrown.
 	 */
-	duk_push_boolean(thr, duk_hobject_prototype_chain_contains(thr, DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h_v), h_obj, 0 /*ignore_loop*/));
+	duk_push_boolean(
+	    thr,
+	    duk_hobject_prototype_chain_contains(thr, DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h_v), h_obj, 0 /*ignore_loop*/));
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_has_own_property(duk_hthread *thr) {
 	return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, 0 /*required_desc_flags*/);
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_property_is_enumerable(duk_hthread *thr) {
 	return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, DUK_PROPDESC_FLAG_ENUMERABLE /*required_desc_flags*/);
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 /* Shared helper to implement Object.getPrototypeOf,
  * Object.prototype.__proto__ getter, and Reflect.getPrototypeOf.
  *
  * http://www.ecma-international.org/ecma-262/6.0/index.html#sec-get-object.prototype.__proto__
  */
@@ -40874,15 +41792,15 @@
 	if (proto != NULL) {
 		duk_push_hobject(thr, proto);
 	} else {
 		duk_push_null(thr);
 	}
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 /* Shared helper to implement ES2015 Object.setPrototypeOf,
  * Object.prototype.__proto__ setter, and Reflect.setPrototypeOf.
  *
  * http://www.ecma-international.org/ecma-262/6.0/index.html#sec-get-object.prototype.__proto__
  * http://www.ecma-international.org/ecma-262/6.0/index.html#sec-object.setprototypeof
@@ -40893,15 +41811,15 @@
 	 *  magic = 1: Object.setPrototypeOf()
 	 *  magic = 2: Reflect.setPrototypeOf()
 	 */
 
 	duk_hobject *h_obj;
 	duk_hobject *h_new_proto;
 	duk_hobject *h_curr;
-	duk_ret_t ret_success = 1;  /* retval for success path */
+	duk_ret_t ret_success = 1; /* retval for success path */
 	duk_uint_t mask;
 	duk_int_t magic;
 
 	/* Preliminaries for __proto__ and setPrototypeOf (E6 19.1.2.18 steps 1-4). */
 	magic = duk_get_current_magic(thr);
 	if (magic == 0) {
 		duk_push_this_check_object_coercible(thr);
@@ -40914,30 +41832,27 @@
 		 * setPrototypeOf() call which returns the target object.
 		 */
 		ret_success = 0;
 	} else {
 		if (magic == 1) {
 			duk_require_object_coercible(thr, 0);
 		} else {
-			duk_require_hobject_accept_mask(thr, 0,
-			                                DUK_TYPE_MASK_LIGHTFUNC |
-			                                DUK_TYPE_MASK_BUFFER);
+			duk_require_hobject_accept_mask(thr, 0, DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER);
 		}
 		duk_require_type_mask(thr, 1, DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_OBJECT);
 	}
 
 	h_new_proto = duk_get_hobject(thr, 1);
 	/* h_new_proto may be NULL */
 
 	mask = duk_get_type_mask(thr, 0);
 	if (mask & (DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER)) {
 		duk_hobject *curr_proto;
-		curr_proto = thr->builtins[(mask & DUK_TYPE_MASK_LIGHTFUNC) ?
-		                               DUK_BIDX_FUNCTION_PROTOTYPE :
-		                               DUK_BIDX_UINT8ARRAY_PROTOTYPE];
+		curr_proto =
+		    thr->builtins[(mask & DUK_TYPE_MASK_LIGHTFUNC) ? DUK_BIDX_FUNCTION_PROTOTYPE : DUK_BIDX_UINT8ARRAY_PROTOTYPE];
 		if (h_new_proto == curr_proto) {
 			goto skip;
 		}
 		goto fail_nonextensible;
 	}
 	h_obj = duk_get_hobject(thr, 0);
 	if (h_obj == NULL) {
@@ -40959,31 +41874,31 @@
 		if (h_curr == h_obj) {
 			goto fail_loop;
 		}
 	}
 	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, h_obj, h_new_proto);
 	/* fall thru */
 
- skip:
+skip:
 	duk_set_top(thr, 1);
 	if (magic == 2) {
 		duk_push_true(thr);
 	}
 	return ret_success;
 
- fail_nonextensible:
- fail_loop:
+fail_nonextensible:
+fail_loop:
 	if (magic != 2) {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	} else {
 		duk_push_false(thr);
 		return 1;
 	}
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_define_property(duk_hthread *thr) {
 	/*
 	 *  magic = 0: Object.defineProperty()
 	 *  magic = 1: Reflect.defineProperty()
 	 */
@@ -41027,50 +41942,38 @@
 	 *  Validate and convert argument property descriptor (an ECMAScript
 	 *  object) into a set of defprop_flags and possibly property value,
 	 *  getter, and/or setter values on the value stack.
 	 *
 	 *  Lightfunc set/get values are coerced to full Functions.
 	 */
 
-	duk_hobject_prepare_property_descriptor(thr,
-	                                        2 /*idx_desc*/,
-	                                        &defprop_flags,
-	                                        &idx_value,
-	                                        &get,
-	                                        &set);
+	duk_hobject_prepare_property_descriptor(thr, 2 /*idx_desc*/, &defprop_flags, &idx_value, &get, &set);
 
 	/*
 	 *  Use Object.defineProperty() helper for the actual operation.
 	 */
 
 	DUK_ASSERT(magic == 0U || magic == 1U);
 	throw_flag = magic ^ 1U;
-	ret = duk_hobject_define_property_helper(thr,
-	                                         defprop_flags,
-	                                         obj,
-	                                         key,
-	                                         idx_value,
-	                                         get,
-	                                         set,
-	                                         throw_flag);
+	ret = duk_hobject_define_property_helper(thr, defprop_flags, obj, key, idx_value, get, set, throw_flag);
 
 	/* Ignore the normalize/validate helper outputs on the value stack,
 	 * they're popped automatically.
 	 */
 
 	if (magic == 0U) {
 		/* Object.defineProperty(): return target object. */
 		duk_push_hobject(thr, obj);
 	} else {
 		/* Reflect.defineProperty(): return success/fail. */
 		duk_push_boolean(thr, ret);
 	}
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_get_own_property_descriptor(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 2);
 
 	/* ES2015 Section 19.1.2.6, step 1 */
 	if (duk_get_current_magic(thr) == 0) {
@@ -41078,15 +41981,15 @@
 	}
 
 	/* [ obj key ] */
 
 	duk_hobject_object_get_own_property_descriptor(thr, -2);
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_is_extensible(duk_hthread *thr) {
 	/*
 	 *  magic = 0: Object.isExtensible()
 	 *  magic = 1: Reflect.isExtensible()
 	 */
@@ -41101,45 +42004,36 @@
 		 */
 		h = duk_require_hobject_accept_mask(thr, 0, DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER);
 	}
 
 	duk_push_boolean(thr, (h != NULL) && DUK_HOBJECT_HAS_EXTENSIBLE(h));
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 /* Shared helper for various key/symbol listings, magic:
  * 0=Object.keys()
  * 1=Object.getOwnPropertyNames(),
  * 2=Object.getOwnPropertySymbols(),
  * 3=Reflect.ownKeys()
  */
 DUK_LOCAL const duk_small_uint_t duk__object_keys_enum_flags[4] = {
 	/* Object.keys() */
-	DUK_ENUM_OWN_PROPERTIES_ONLY |
-	    DUK_ENUM_NO_PROXY_BEHAVIOR,
+	DUK_ENUM_OWN_PROPERTIES_ONLY | DUK_ENUM_NO_PROXY_BEHAVIOR,
 
 	/* Object.getOwnPropertyNames() */
-	DUK_ENUM_INCLUDE_NONENUMERABLE |
-	    DUK_ENUM_OWN_PROPERTIES_ONLY |
-	    DUK_ENUM_NO_PROXY_BEHAVIOR,
+	DUK_ENUM_INCLUDE_NONENUMERABLE | DUK_ENUM_OWN_PROPERTIES_ONLY | DUK_ENUM_NO_PROXY_BEHAVIOR,
 
 	/* Object.getOwnPropertySymbols() */
-	DUK_ENUM_INCLUDE_SYMBOLS |
-	    DUK_ENUM_OWN_PROPERTIES_ONLY |
-	    DUK_ENUM_EXCLUDE_STRINGS |
-	    DUK_ENUM_INCLUDE_NONENUMERABLE |
+	DUK_ENUM_INCLUDE_SYMBOLS | DUK_ENUM_OWN_PROPERTIES_ONLY | DUK_ENUM_EXCLUDE_STRINGS | DUK_ENUM_INCLUDE_NONENUMERABLE |
 	    DUK_ENUM_NO_PROXY_BEHAVIOR,
 
 	/* Reflect.ownKeys() */
-	DUK_ENUM_INCLUDE_SYMBOLS |
-	    DUK_ENUM_OWN_PROPERTIES_ONLY |
-	    DUK_ENUM_INCLUDE_NONENUMERABLE |
-	    DUK_ENUM_NO_PROXY_BEHAVIOR
+	DUK_ENUM_INCLUDE_SYMBOLS | DUK_ENUM_OWN_PROPERTIES_ONLY | DUK_ENUM_INCLUDE_NONENUMERABLE | DUK_ENUM_NO_PROXY_BEHAVIOR
 };
 
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_keys_shared(duk_hthread *thr) {
 	duk_hobject *obj;
 #if defined(DUK_USE_ES6_PROXY)
 	duk_hobject *h_proxy_target;
 	duk_hobject *h_proxy_handler;
@@ -41163,17 +42057,15 @@
 	DUK_ASSERT(obj != NULL);
 	DUK_UNREF(obj);
 
 	/* XXX: proxy chains */
 
 #if defined(DUK_USE_ES6_PROXY)
 	/* XXX: better sharing of code between proxy target call sites */
-	if (DUK_LIKELY(!duk_hobject_proxy_check(obj,
-	                                        &h_proxy_target,
-	                                        &h_proxy_handler))) {
+	if (DUK_LIKELY(!duk_hobject_proxy_check(obj, &h_proxy_target, &h_proxy_handler))) {
 		goto skip_proxy;
 	}
 
 	duk_push_hobject(thr, h_proxy_handler);
 	if (!duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_OWN_KEYS)) {
 		/* Careful with reachability here: don't pop 'obj' before pushing
 		 * proxy target.
@@ -41184,36 +42076,36 @@
 		duk_replace(thr, 0);
 		DUK_ASSERT_TOP(thr, 1);
 		goto skip_proxy;
 	}
 
 	/* [ obj handler trap ] */
 	duk_insert(thr, -2);
-	duk_push_hobject(thr, h_proxy_target);  /* -> [ obj trap handler target ] */
-	duk_call_method(thr, 1 /*nargs*/);      /* -> [ obj trap_result ] */
+	duk_push_hobject(thr, h_proxy_target); /* -> [ obj trap handler target ] */
+	duk_call_method(thr, 1 /*nargs*/); /* -> [ obj trap_result ] */
 	h_trap_result = duk_require_hobject(thr, -1);
 	DUK_UNREF(h_trap_result);
 
 	magic = duk_get_current_magic(thr);
 	DUK_ASSERT(magic >= 0 && magic < (duk_int_t) (sizeof(duk__object_keys_enum_flags) / sizeof(duk_small_uint_t)));
 	enum_flags = duk__object_keys_enum_flags[magic];
 
 	duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);
 	return 1;
 
- skip_proxy:
-#endif  /* DUK_USE_ES6_PROXY */
+skip_proxy:
+#endif /* DUK_USE_ES6_PROXY */
 
 	DUK_ASSERT_TOP(thr, 1);
 	magic = duk_get_current_magic(thr);
 	DUK_ASSERT(magic >= 0 && magic < (duk_int_t) (sizeof(duk__object_keys_enum_flags) / sizeof(duk_small_uint_t)));
 	enum_flags = duk__object_keys_enum_flags[magic];
 	return duk_hobject_get_enumerated_keys(thr, enum_flags);
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 #if defined(DUK_USE_OBJECT_BUILTIN) || defined(DUK_USE_REFLECT_BUILTIN)
 DUK_INTERNAL duk_ret_t duk_bi_object_constructor_prevent_extensions(duk_hthread *thr) {
 	/*
 	 *  magic = 0: Object.preventExtensions()
 	 *  magic = 1: Reflect.preventExtensions()
 	 */
@@ -41225,20 +42117,16 @@
 	magic = duk_get_current_magic(thr);
 
 	/* Silent success for lightfuncs and plain buffers always. */
 	mask = DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER;
 
 	/* Object.preventExtensions() silent success for non-object. */
 	if (magic == 0) {
-		mask |= DUK_TYPE_MASK_UNDEFINED |
-		        DUK_TYPE_MASK_NULL |
-		        DUK_TYPE_MASK_BOOLEAN |
-		        DUK_TYPE_MASK_NUMBER |
-		        DUK_TYPE_MASK_STRING |
-		        DUK_TYPE_MASK_POINTER;
+		mask |= DUK_TYPE_MASK_UNDEFINED | DUK_TYPE_MASK_NULL | DUK_TYPE_MASK_BOOLEAN | DUK_TYPE_MASK_NUMBER |
+		        DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_POINTER;
 	}
 
 	if (duk_check_type_mask(thr, 0, mask)) {
 		/* Not an object, already non-extensible so always success. */
 		goto done;
 	}
 	h = duk_require_hobject(thr, 0);
@@ -41247,21 +42135,21 @@
 	DUK_HOBJECT_CLEAR_EXTENSIBLE(h);
 
 	/* A non-extensible object cannot gain any more properties,
 	 * so this is a good time to compact.
 	 */
 	duk_hobject_compact_props(thr, h);
 
- done:
+done:
 	if (magic == 1) {
 		duk_push_true(thr);
 	}
 	return 1;
 }
-#endif  /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_OBJECT_BUILTIN || DUK_USE_REFLECT_BUILTIN */
 
 /*
  *  __defineGetter__, __defineSetter__, __lookupGetter__, __lookupSetter__
  */
 
 #if defined(DUK_USE_ES8)
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_defineaccessor(duk_hthread *thr) {
@@ -41269,17 +42157,18 @@
 	duk_insert(thr, 0);
 	duk_to_object(thr, 0);
 	duk_require_callable(thr, 2);
 
 	/* [ ToObject(this) key getter/setter ] */
 
 	/* ToPropertyKey() coercion is not needed, duk_def_prop() does it. */
-	duk_def_prop(thr, 0, DUK_DEFPROP_SET_ENUMERABLE |
-	                     DUK_DEFPROP_SET_CONFIGURABLE |
-	                     (duk_get_current_magic(thr) ? DUK_DEFPROP_HAVE_SETTER : DUK_DEFPROP_HAVE_GETTER));
+	duk_def_prop(thr,
+	             0,
+	             DUK_DEFPROP_SET_ENUMERABLE | DUK_DEFPROP_SET_CONFIGURABLE |
+	                 (duk_get_current_magic(thr) ? DUK_DEFPROP_HAVE_SETTER : DUK_DEFPROP_HAVE_GETTER));
 	return 0;
 }
 DUK_INTERNAL duk_ret_t duk_bi_object_prototype_lookupaccessor(duk_hthread *thr) {
 	duk_uint_t sanity;
 
 	duk_push_this(thr);
 	duk_to_object(thr, -1);
@@ -41306,15 +42195,15 @@
 		}
 
 		duk_get_prototype(thr, -1);
 		duk_remove(thr, -2);
 	}
 	return 1;
 }
-#endif  /* DUK_USE_ES8 */
+#endif /* DUK_USE_ES8 */
 #line 1 "duk_bi_performance.c"
 /*
  *  High resolution time API (performance.now() et al)
  *
  *  API specification: https://encoding.spec.whatwg.org/#ap://www.w3.org/TR/hr-time/
  */
 
@@ -41328,25 +42217,25 @@
 	 * monotonic clock, or a time value that represents a duration
 	 * between two DOMHighResTimeStamp's.
 	 */
 	duk_push_number(thr, duk_time_get_monotonic_time(thr));
 	return 1;
 }
 
-#if 0  /* Missing until semantics decided. */
+#if 0 /* Missing until semantics decided. */
 DUK_INTERNAL duk_ret_t duk_bi_performance_timeorigin_getter(duk_hthread *thr) {
 	/* No decision yet how to handle timeOrigins, e.g. should one be
 	 * initialized per heap, or per global object set.  See
 	 * https://www.w3.org/TR/hr-time/#time-origin.
 	 */
 	duk_push_uint(thr, 0);
 	return 1;
 }
-#endif  /* 0 */
-#endif  /* DUK_USE_PERFORMANCE_BUILTIN */
+#endif /* 0 */
+#endif /* DUK_USE_PERFORMANCE_BUILTIN */
 #line 1 "duk_bi_pointer.c"
 /*
  *  Pointer built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -41365,17 +42254,16 @@
 		duk_to_pointer(thr, 0);
 	}
 	DUK_ASSERT(duk_is_pointer(thr, 0));
 	duk_set_top(thr, 1);
 
 	if (duk_is_constructor_call(thr)) {
 		(void) duk_push_object_helper(thr,
-		                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-		                              DUK_HOBJECT_FLAG_FASTREFS |
-		                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_POINTER),
+		                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+		                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_POINTER),
 		                              DUK_BIDX_POINTER_PROTOTYPE);
 
 		/* Pointer object internal value is immutable. */
 		duk_dup_0(thr);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE);
 	}
 	/* Note: unbalanced stack on purpose */
@@ -41412,15 +42300,15 @@
 	}
 
 	if (to_string) {
 		duk_to_string(thr, -1);
 	}
 	return 1;
 
- type_error:
+type_error:
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 }
 #line 1 "duk_bi_promise.c"
 /*
  *  Promise built-in
  */
 
@@ -41459,15 +42347,15 @@
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_promise_then(duk_hthread *thr) {
 	DUK_ERROR_TYPE(thr, "unimplemented");
 	DUK_WO_NORETURN(return 0;);
 }
 
-#endif  /* DUK_USE_PROMISE_BUILTIN */
+#endif /* DUK_USE_PROMISE_BUILTIN */
 #line 1 "duk_bi_proxy.c"
 /*
  *  Proxy built-in (ES2015)
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -41531,15 +42419,15 @@
 
 		/* [ obj trap_result res_arr propname ] */
 		duk_push_uarridx(thr, idx++);
 		duk_insert(thr, -2);
 		duk_def_prop(thr, -3, DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_SET_WEC);
 		continue;
 
-	 skip_key:
+	skip_key:
 		duk_pop(thr);
 		continue;
 	}
 
 	/* XXX: Missing trap result validation for non-configurable target keys
 	 * (must be present), for non-extensible target all target keys must be
 	 * present and no extra keys can be present.
@@ -41548,25 +42436,25 @@
 
 	/* XXX: The key enumerability check should trigger the "getOwnPropertyDescriptor"
 	 * trap which has not yet been implemented.  In the absence of such a trap,
 	 * the enumerability should be checked from the target object; this is
 	 * handled above.
 	 */
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 #if defined(DUK_USE_ES6_PROXY)
 DUK_INTERNAL duk_ret_t duk_bi_proxy_constructor(duk_hthread *thr) {
-	DUK_ASSERT_TOP(thr, 2);  /* [ target handler ] */
+	DUK_ASSERT_TOP(thr, 2); /* [ target handler ] */
 
 	duk_require_constructor_call(thr);
-	duk_push_proxy(thr, 0 /*flags*/);  /* [ target handler ] -> [ proxy ] */
-	return 1;  /* replacement */
+	duk_push_proxy(thr, 0 /*flags*/); /* [ target handler ] -> [ proxy ] */
+	return 1; /* replacement */
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 #line 1 "duk_bi_reflect.c"
 /*
  *  'Reflect' built-in (ES2016 Section 26.1)
  *  http://www.ecma-international.org/ecma-262/7.0/#sec-reflect-object
  *
  *  Many Reflect built-in functions are provided by shared helpers in
  *  duk_bi_object.c or duk_bi_function.c.
@@ -41609,15 +42497,15 @@
 		DUK_WO_NORETURN(return 0;);
 	}
 
 	/* [ target key receiver? ...? ] */
 
 	tv_obj = DUK_GET_TVAL_POSIDX(thr, 0);
 	tv_key = DUK_GET_TVAL_POSIDX(thr, 1);
-	(void) duk_hobject_getprop(thr, tv_obj, tv_key);  /* This could also be a duk_get_prop(). */
+	(void) duk_hobject_getprop(thr, tv_obj, tv_key); /* This could also be a duk_get_prop(). */
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_reflect_object_has(duk_hthread *thr) {
 	duk_tval *tv_obj;
 	duk_tval *tv_key;
 	duk_bool_t ret;
@@ -41658,15 +42546,15 @@
 	tv_obj = DUK_GET_TVAL_POSIDX(thr, 0);
 	tv_key = DUK_GET_TVAL_POSIDX(thr, 1);
 	tv_val = DUK_GET_TVAL_POSIDX(thr, 2);
 	ret = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, 0 /*throw_flag*/);
 	duk_push_boolean(thr, ret);
 	return 1;
 }
-#endif  /* DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_REFLECT_BUILTIN */
 #line 1 "duk_bi_regexp.c"
 /*
  *  RegExp built-ins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -41675,44 +42563,41 @@
 DUK_LOCAL void duk__get_this_regexp(duk_hthread *thr) {
 	duk_hobject *h;
 
 	duk_push_this(thr);
 	h = duk_require_hobject_with_class(thr, -1, DUK_HOBJECT_CLASS_REGEXP);
 	DUK_ASSERT(h != NULL);
 	DUK_UNREF(h);
-	duk_insert(thr, 0);  /* prepend regexp to valstack 0 index */
+	duk_insert(thr, 0); /* prepend regexp to valstack 0 index */
 }
 
 /* XXX: much to improve (code size) */
 DUK_INTERNAL duk_ret_t duk_bi_regexp_constructor(duk_hthread *thr) {
 	duk_hobject *h_pattern;
 
 	DUK_ASSERT_TOP(thr, 2);
 	h_pattern = duk_get_hobject(thr, 0);
 
-	if (!duk_is_constructor_call(thr) &&
-	    h_pattern != NULL &&
-	    DUK_HOBJECT_GET_CLASS_NUMBER(h_pattern) == DUK_HOBJECT_CLASS_REGEXP &&
-	    duk_is_undefined(thr, 1)) {
+	if (!duk_is_constructor_call(thr) && h_pattern != NULL &&
+	    DUK_HOBJECT_GET_CLASS_NUMBER(h_pattern) == DUK_HOBJECT_CLASS_REGEXP && duk_is_undefined(thr, 1)) {
 		/* Called as a function, pattern has [[Class]] "RegExp" and
 		 * flags is undefined -> return object as is.
 		 */
 		/* XXX: ES2015 has a NewTarget SameValue() check which is not
 		 * yet implemented.
 		 */
 		duk_dup_0(thr);
 		return 1;
 	}
 
 	/* Else functionality is identical for function call and constructor
 	 * call.
 	 */
 
-	if (h_pattern != NULL &&
-	    DUK_HOBJECT_GET_CLASS_NUMBER(h_pattern) == DUK_HOBJECT_CLASS_REGEXP) {
+	if (h_pattern != NULL && DUK_HOBJECT_GET_CLASS_NUMBER(h_pattern) == DUK_HOBJECT_CLASS_REGEXP) {
 		duk_get_prop_stridx_short(thr, 0, DUK_STRIDX_SOURCE);
 		if (duk_is_undefined(thr, 1)) {
 			/* In ES5 one would need to read the flags individually;
 			 * in ES2015 just read .flags.
 			 */
 			duk_get_prop_stridx(thr, 0, DUK_STRIDX_FLAGS);
 		} else {
@@ -41720,28 +42605,29 @@
 			duk_dup_1(thr);
 		}
 	} else {
 		if (duk_is_undefined(thr, 0)) {
 			duk_push_hstring_empty(thr);
 		} else {
 			duk_dup_0(thr);
-			duk_to_string(thr, -1);  /* Rejects Symbols. */
+			duk_to_string(thr, -1); /* Rejects Symbols. */
 		}
 		if (duk_is_undefined(thr, 1)) {
 			duk_push_hstring_empty(thr);
 		} else {
 			duk_dup_1(thr);
-			duk_to_string(thr, -1);  /* Rejects Symbols. */
+			duk_to_string(thr, -1); /* Rejects Symbols. */
 		}
 
 		/* [ ... pattern flags ] */
 	}
 
 	DUK_DDD(DUK_DDDPRINT("RegExp constructor/function call, pattern=%!T, flags=%!T",
-	                     (duk_tval *) duk_get_tval(thr, -2), (duk_tval *) duk_get_tval(thr, -1)));
+	                     (duk_tval *) duk_get_tval(thr, -2),
+	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	/* [ ... pattern flags ] (both uncoerced) */
 
 	duk_to_string(thr, -2);
 	duk_to_string(thr, -1);
 	duk_regexp_compile(thr);
 
@@ -41783,25 +42669,25 @@
 
 DUK_INTERNAL duk_ret_t duk_bi_regexp_prototype_tostring(duk_hthread *thr) {
 	/* This must be generic in ES2015 and later. */
 	DUK_ASSERT_TOP(thr, 0);
 	duk_push_this(thr);
 	duk_push_literal(thr, "/");
 	duk_get_prop_stridx(thr, 0, DUK_STRIDX_SOURCE);
-	duk_dup_m2(thr);  /* another "/" */
+	duk_dup_m2(thr); /* another "/" */
 	duk_get_prop_stridx(thr, 0, DUK_STRIDX_FLAGS);
 	duk_concat(thr, 4);
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_regexp_prototype_flags(duk_hthread *thr) {
 	/* .flags is ES2015 but present even when ES2015 bindings are
 	 * disabled because the constructor relies on it.
 	 */
-	duk_uint8_t buf[8];  /* enough for all flags + NUL */
+	duk_uint8_t buf[8]; /* enough for all flags + NUL */
 	duk_uint8_t *p = buf;
 
 	/* .flags is generic and works on any object. */
 	duk_push_this(thr);
 	(void) duk_require_hobject(thr, -1);
 	if (duk_get_prop_stridx_boolean(thr, 0, DUK_STRIDX_GLOBAL, NULL)) {
 		*p++ = DUK_ASC_LC_G;
@@ -41834,66 +42720,66 @@
 	h = duk_require_hobject(thr, -1);
 	magic = duk_get_current_magic(thr);
 
 	if (DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_REGEXP) {
 		duk_xget_owndataprop_stridx_short(thr, 0, DUK_STRIDX_INT_SOURCE);
 		duk_xget_owndataprop_stridx_short(thr, 0, DUK_STRIDX_INT_BYTECODE);
 		h_bc = duk_require_hstring(thr, -1);
-		re_flags = (duk_small_uint_t) DUK_HSTRING_GET_DATA(h_bc)[0];  /* Safe even if h_bc length is 0 (= NUL) */
+		re_flags = (duk_small_uint_t) DUK_HSTRING_GET_DATA(h_bc)[0]; /* Safe even if h_bc length is 0 (= NUL) */
 		duk_pop(thr);
 	} else if (h == thr->builtins[DUK_BIDX_REGEXP_PROTOTYPE]) {
 		/* In ES2015 and ES2016 a TypeError would be thrown here.
 		 * However, this had real world issues so ES2017 draft
 		 * allows RegExp.prototype specifically, returning '(?:)'
 		 * for .source and undefined for all flags.
 		 */
 		if (magic != 16 /* .source */) {
 			return 0;
 		}
-		duk_push_literal(thr, "(?:)");  /* .source handled by switch-case */
+		duk_push_literal(thr, "(?:)"); /* .source handled by switch-case */
 		re_flags = 0;
 	} else {
 		DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 	}
 
 	/* [ regexp source ] */
 
 	switch (magic) {
-	case 0: {  /* global */
+	case 0: { /* global */
 		duk_push_boolean(thr, (re_flags & DUK_RE_FLAG_GLOBAL));
 		break;
 	}
-	case 1: {  /* ignoreCase */
+	case 1: { /* ignoreCase */
 		duk_push_boolean(thr, (re_flags & DUK_RE_FLAG_IGNORE_CASE));
 		break;
 	}
-	case 2: {  /* multiline */
+	case 2: { /* multiline */
 		duk_push_boolean(thr, (re_flags & DUK_RE_FLAG_MULTILINE));
 		break;
 	}
 #if 0
 	/* Don't provide until implemented to avoid interfering with feature
 	 * detection in user code.
 	 */
 	case 3:    /* sticky */
 	case 4: {  /* unicode */
 		duk_push_false(thr);
 		break;
 	}
 #endif
-	default: {  /* source */
+	default: { /* source */
 		/* leave 'source' on top */
 		break;
 	}
 	}
 
 	return 1;
 }
 
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 #line 1 "duk_bi_string.c"
 /*
  *  String built-ins
  *
  *  Most String built-ins must only accept strings (or String objects).
  *  Symbols, represented internally as strings, must be generally rejected.
  *  The duk_push_this_coercible_to_string() helper does this automatically.
@@ -41925,15 +42811,16 @@
 	}
 	h = duk_to_hstring(thr, idx);
 	DUK_ASSERT(h != NULL);
 
 	return h;
 }
 
-DUK_LOCAL duk_int_t duk__str_search_shared(duk_hthread *thr, duk_hstring *h_this, duk_hstring *h_search, duk_int_t start_cpos, duk_bool_t backwards) {
+DUK_LOCAL duk_int_t
+duk__str_search_shared(duk_hthread *thr, duk_hstring *h_this, duk_hstring *h_search, duk_int_t start_cpos, duk_bool_t backwards) {
 	duk_int_t cpos;
 	duk_int_t bpos;
 	const duk_uint8_t *p_start, *p_end, *p;
 	const duk_uint8_t *q_start;
 	duk_int_t q_blen;
 	duk_uint8_t firstbyte;
 	duk_uint8_t t;
@@ -41960,15 +42847,15 @@
 	/* This loop is optimized for size.  For speed, there should be
 	 * two separate loops, and we should ensure that memcmp() can be
 	 * used without an extra "will searchstring fit" check.  Doing
 	 * the preconditioning for 'p' and 'p_end' is easy but cpos
 	 * must be updated if 'p' is wound back (backward scanning).
 	 */
 
-	firstbyte = q_start[0];  /* leading byte of match string */
+	firstbyte = q_start[0]; /* leading byte of match string */
 	while (p <= p_end && p >= p_start) {
 		t = *p;
 
 		/* For ECMAScript strings, this check can only match for
 		 * initial UTF-8 bytes (not continuation bytes).  For other
 		 * strings all bets are off.
 		 */
@@ -42026,23 +42913,21 @@
 	} else {
 		h = duk_to_hstring_acceptsymbol(thr, 0);
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h) && !duk_is_constructor_call(thr))) {
 			duk_push_symbol_descriptive_string(thr, h);
 			duk_replace(thr, 0);
 		}
 	}
-	duk_to_string(thr, 0);  /* catches symbol argument for constructor call */
+	duk_to_string(thr, 0); /* catches symbol argument for constructor call */
 	DUK_ASSERT(duk_is_string(thr, 0));
-	duk_set_top(thr, 1);  /* Top may be 1 or larger. */
+	duk_set_top(thr, 1); /* Top may be 1 or larger. */
 
 	if (duk_is_constructor_call(thr)) {
 		/* String object internal value is immutable */
-		flags = DUK_HOBJECT_FLAG_EXTENSIBLE |
-		        DUK_HOBJECT_FLAG_FASTREFS |
-		        DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ |
+		flags = DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ |
 		        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_STRING);
 		duk_push_object_helper(thr, flags, DUK_BIDX_STRING_PROTOTYPE);
 		duk_dup_0(thr);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VALUE, DUK_PROPDESC_FLAGS_NONE);
 	}
 	/* Note: unbalanced stack on purpose */
 
@@ -42060,30 +42945,29 @@
 	 * helpful (perhaps coerce the value stack first here and then
 	 * build a string from a duk_tval number sequence in one go?).
 	 */
 
 	n = duk_get_top(thr);
 
 	bw = &bw_alloc;
-	DUK_BW_INIT_PUSHBUF(thr, bw, (duk_size_t) n);  /* initial estimate for ASCII only codepoints */
+	DUK_BW_INIT_PUSHBUF(thr, bw, (duk_size_t) n); /* initial estimate for ASCII only codepoints */
 
 	for (i = 0; i < n; i++) {
 		/* XXX: could improve bufwriter handling to write multiple codepoints
 		 * with one ensure call but the relative benefit would be quite small.
 		 */
 
 		if (nonbmp) {
 			/* ES2015 requires that (1) SameValue(cp, ToInteger(cp)) and
 			 * (2) cp >= 0 and cp <= 0x10ffff.  This check does not
 			 * implement the steps exactly but the outcome should be
 			 * the same.
 			 */
 			duk_int32_t i32 = 0;
-			if (!duk_is_whole_get_int32(duk_to_number(thr, i), &i32) ||
-			    i32 < 0 || i32 > 0x10ffffL) {
+			if (!duk_is_whole_get_int32(duk_to_number(thr, i), &i32) || i32 < 0 || i32 > 0x10ffffL) {
 				DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 			}
 			DUK_ASSERT(i32 >= 0 && i32 <= 0x10ffffL);
 			cp = (duk_ucodepoint_t) i32;
 			DUK_BW_WRITE_ENSURE_CESU8(thr, bw, cp);
 		} else {
 #if defined(DUK_USE_NONSTD_STRING_FROMCHARCODE_32BIT)
@@ -42099,15 +42983,15 @@
 			DUK_ASSERT(cp >= 0 && cp <= 0x10ffffL);
 			DUK_BW_WRITE_ENSURE_CESU8(thr, bw, cp);
 #endif
 		}
 	}
 
 	DUK_BW_COMPACT(thr, bw);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe, extended UTF-8 or CESU-8 encoded. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe, extended UTF-8 or CESU-8 encoded. */
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_string_constructor_from_char_code(duk_hthread *thr) {
 	return duk__construct_from_codepoints(thr, 0 /*nonbmp*/);
 }
 
@@ -42141,18 +43025,18 @@
 
 		duk_xget_owndataprop_stridx_short(thr, -1, DUK_STRIDX_INT_VALUE);
 		DUK_ASSERT(duk_is_string(thr, -1));
 	} else {
 		goto type_error;
 	}
 
-	(void) duk_require_hstring_notsymbol(thr, -1);  /* Reject symbols (and wrapped symbols). */
+	(void) duk_require_hstring_notsymbol(thr, -1); /* Reject symbols (and wrapped symbols). */
 	return 1;
 
- type_error:
+type_error:
 	DUK_DCERROR_TYPE_INVALID_ARGS(thr);
 }
 
 /*
  *  Character and charcode access
  */
 
@@ -42280,15 +43164,15 @@
 	duk_int_t len;
 
 	/* Unlike non-obsolete String calls, substr() algorithm in E5.1
 	 * specification will happily coerce undefined and null to strings
 	 * ("undefined" and "null").
 	 */
 	duk_push_this(thr);
-	h = duk_to_hstring_m1(thr);  /* Reject Symbols. */
+	h = duk_to_hstring_m1(thr); /* Reject Symbols. */
 	DUK_ASSERT(h != NULL);
 	len = (duk_int_t) DUK_HSTRING_GET_CHARLEN(h);
 
 	/* [ start length str ] */
 
 	/* The implementation for computing of start_pos and end_pos differs
 	 * from the standard algorithm, but is intended to result in the exactly
@@ -42312,15 +43196,15 @@
 	DUK_ASSERT(start_pos >= 0 && start_pos <= len);
 	DUK_ASSERT(end_pos >= 0 && end_pos <= len);
 	DUK_ASSERT(end_pos >= start_pos);
 
 	duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 	return 1;
 }
-#endif  /* DUK_USE_SECTION_B */
+#endif /* DUK_USE_SECTION_B */
 
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_slice(duk_hthread *thr) {
 	duk_hstring *h;
 	duk_int_t start_pos, end_pos;
 	duk_int_t len;
 
 	h = duk_push_this_coercible_to_string(thr);
@@ -42371,15 +43255,15 @@
  */
 
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_indexof_shared(duk_hthread *thr) {
 	duk_hstring *h_this;
 	duk_hstring *h_search;
 	duk_int_t clen_this;
 	duk_int_t cpos;
-	duk_small_uint_t is_lastindexof = (duk_small_uint_t) duk_get_current_magic(thr);  /* 0=indexOf, 1=lastIndexOf */
+	duk_small_uint_t is_lastindexof = (duk_small_uint_t) duk_get_current_magic(thr); /* 0=indexOf, 1=lastIndexOf */
 
 	h_this = duk_push_this_coercible_to_string(thr);
 	DUK_ASSERT(h_this != NULL);
 	clen_this = (duk_int_t) DUK_HSTRING_GET_CHARLEN(h_this);
 
 	h_search = duk_to_hstring(thr, 0);
 	DUK_ASSERT(h_search != NULL);
@@ -42428,23 +43312,23 @@
 #endif
 	duk_bool_t is_repl_func;
 	duk_uint32_t match_start_coff, match_start_boff;
 #if defined(DUK_USE_REGEXP_SUPPORT)
 	duk_int_t match_caps;
 #endif
 	duk_uint32_t prev_match_end_boff;
-	const duk_uint8_t *r_start, *r_end, *r;   /* repl string scan */
+	const duk_uint8_t *r_start, *r_end, *r; /* repl string scan */
 	duk_size_t tmp_sz;
 
 	DUK_ASSERT_TOP(thr, 2);
 	h_input = duk_push_this_coercible_to_string(thr);
 	DUK_ASSERT(h_input != NULL);
 
 	bw = &bw_alloc;
-	DUK_BW_INIT_PUSHBUF(thr, bw, DUK_HSTRING_GET_BYTELEN(h_input));  /* input size is good output starting point */
+	DUK_BW_INIT_PUSHBUF(thr, bw, DUK_HSTRING_GET_BYTELEN(h_input)); /* input size is good output starting point */
 
 	DUK_ASSERT_TOP(thr, 4);
 
 	/* stack[0] = search value
 	 * stack[1] = replace value
 	 * stack[2] = input string
 	 * stack[3] = result buffer
@@ -42457,34 +43341,34 @@
 		is_global = duk_get_prop_stridx_boolean(thr, 0, DUK_STRIDX_GLOBAL, NULL);
 
 		if (is_global) {
 			/* start match from beginning */
 			duk_push_int(thr, 0);
 			duk_put_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
 		}
-#else  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
 		DUK_DCERROR_UNSUPPORTED(thr);
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 	} else {
-		duk_to_string(thr, 0);  /* rejects symbols */
+		duk_to_string(thr, 0); /* rejects symbols */
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		is_regexp = 0;
 		is_global = 0;
 #endif
 	}
 
 	if (duk_is_function(thr, 1)) {
 		is_repl_func = 1;
 		r_start = NULL;
 		r_end = NULL;
 	} else {
 		duk_hstring *h_repl;
 
 		is_repl_func = 0;
-		h_repl = duk_to_hstring(thr, 1);  /* reject symbols */
+		h_repl = duk_to_hstring(thr, 1); /* reject symbols */
 		DUK_ASSERT(h_repl != NULL);
 		r_start = DUK_HSTRING_GET_DATA(h_repl);
 		r_end = r_start + DUK_HSTRING_GET_BYTELEN(h_repl);
 	}
 
 	prev_match_end_boff = 0;
 
@@ -42514,74 +43398,75 @@
 
 		DUK_ASSERT_TOP(thr, 4);
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		if (is_regexp) {
 			duk_dup_0(thr);
 			duk_dup_2(thr);
-			duk_regexp_match(thr);  /* [ ... regexp input ] -> [ res_obj ] */
+			duk_regexp_match(thr); /* [ ... regexp input ] -> [ res_obj ] */
 			if (!duk_is_object(thr, -1)) {
 				duk_pop(thr);
 				break;
 			}
 
 			duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_INDEX);
 			DUK_ASSERT(duk_is_number(thr, -1));
 			match_start_coff = duk_get_uint(thr, -1);
 			duk_pop(thr);
 
 			duk_get_prop_index(thr, -1, 0);
 			DUK_ASSERT(duk_is_string(thr, -1));
 			h_match = duk_known_hstring(thr, -1);
-			duk_pop(thr);  /* h_match is borrowed, remains reachable through match_obj */
+			duk_pop(thr); /* h_match is borrowed, remains reachable through match_obj */
 
 			if (DUK_HSTRING_GET_BYTELEN(h_match) == 0) {
 				/* This should be equivalent to match() algorithm step 8.f.iii.2:
 				 * detect an empty match and allow it, but don't allow it twice.
 				 */
 				duk_uint32_t last_index;
 
 				duk_get_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
 				last_index = (duk_uint32_t) duk_get_uint(thr, -1);
 				DUK_DDD(DUK_DDDPRINT("empty match, bump lastIndex: %ld -> %ld",
-				                     (long) last_index, (long) (last_index + 1)));
+				                     (long) last_index,
+				                     (long) (last_index + 1)));
 				duk_pop(thr);
 				duk_push_uint(thr, (duk_uint_t) (last_index + 1));
 				duk_put_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
 			}
 
-			DUK_ASSERT(duk_get_length(thr, -1) <= DUK_INT_MAX);  /* string limits */
+			DUK_ASSERT(duk_get_length(thr, -1) <= DUK_INT_MAX); /* string limits */
 			match_caps = (duk_int_t) duk_get_length(thr, -1);
 		} else {
-#else  /* DUK_USE_REGEXP_SUPPORT */
-		{  /* unconditionally */
-#endif  /* DUK_USE_REGEXP_SUPPORT */
-			const duk_uint8_t *p_start, *p_end, *p;   /* input string scan */
-			const duk_uint8_t *q_start;               /* match string */
+#else /* DUK_USE_REGEXP_SUPPORT */
+		{ /* unconditionally */
+#endif /* DUK_USE_REGEXP_SUPPORT */
+			const duk_uint8_t *p_start, *p_end, *p; /* input string scan */
+			const duk_uint8_t *q_start; /* match string */
 			duk_size_t p_blen;
 			duk_size_t q_blen;
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
-			DUK_ASSERT(!is_global);  /* single match always */
+			DUK_ASSERT(!is_global); /* single match always */
 #endif
 
 			p_start = DUK_HSTRING_GET_DATA(h_input);
 			p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_input);
 			p_blen = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h_input);
 			p = p_start;
 
 			h_search = duk_known_hstring(thr, 0);
 			q_start = DUK_HSTRING_GET_DATA(h_search);
 			q_blen = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h_search);
 
 			if (q_blen > p_blen) {
-				break;  /* no match */
+				break; /* no match */
 			}
 
-			p_end -= q_blen;  /* ensure full memcmp() fits in while */
+			p_end -= q_blen; /* ensure full memcmp() fits in while */
 			DUK_ASSERT(p_end >= p);
 
 			match_start_coff = 0;
 
 			while (p <= p_end) {
 				DUK_ASSERT(p + q_blen <= DUK_HSTRING_GET_DATA(h_input) + DUK_HSTRING_GET_BYTELEN(h_input));
 				if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
@@ -42599,15 +43484,15 @@
 				}
 				p++;
 			}
 
 			/* not found */
 			break;
 		}
-	 found:
+	found:
 
 		/* stack[0] = search value
 		 * stack[1] = replace value
 		 * stack[2] = input string
 		 * stack[3] = result buffer
 		 * stack[4] = regexp match OR match string
 		 */
@@ -42633,32 +43518,32 @@
 				duk_int_t idx;
 				duk_require_stack(thr, match_caps + 2);
 				for (idx = 0; idx < match_caps; idx++) {
 					/* match followed by capture(s) */
 					duk_get_prop_index(thr, 4, (duk_uarridx_t) idx);
 				}
 			} else {
-#else  /* DUK_USE_REGEXP_SUPPORT */
-			{  /* unconditionally */
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
+			{ /* unconditionally */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 				/* match == search string, by definition */
 				duk_dup_0(thr);
 			}
 			duk_push_uint(thr, (duk_uint_t) match_start_coff);
 			duk_dup_2(thr);
 
 			/* [ ... replacer match [captures] match_char_offset input ] */
 
 			duk_call(thr, duk_get_top(thr) - idx_args);
-			h_repl = duk_to_hstring_m1(thr);  /* -> [ ... repl_value ] */
+			h_repl = duk_to_hstring_m1(thr); /* -> [ ... repl_value ] */
 			DUK_ASSERT(h_repl != NULL);
 
 			DUK_BW_WRITE_ENSURE_HSTRING(thr, bw, h_repl);
 
-			duk_pop(thr);  /* repl_value */
+			duk_pop(thr); /* repl_value */
 		} else {
 			r = r_start;
 
 			while (r < r_end) {
 				duk_int_t ch1;
 				duk_int_t ch2;
 #if defined(DUK_USE_REGEXP_SUPPORT)
@@ -42697,17 +43582,18 @@
 				case DUK_ASC_SINGLEQUOTE: {
 					duk_uint32_t match_end_boff;
 
 					/* Use match charlen instead of bytelen, just in case the input and
 					 * match codepoint encodings would have different lengths.
 					 */
 					/* XXX: charlen computed here, and also in char2byte helper. */
-					match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr,
-					                                                                   h_input,
-					                                                                   match_start_coff + (duk_uint_fast32_t) DUK_HSTRING_GET_CHARLEN(h_match));
+					match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(
+					    thr,
+					    h_input,
+					    match_start_coff + (duk_uint_fast32_t) DUK_HSTRING_GET_CHARLEN(h_match));
 
 					tmp_sz = (duk_size_t) (DUK_HSTRING_GET_BYTELEN(h_input) - match_end_boff);
 					DUK_BW_WRITE_ENSURE_BYTES(thr, bw, DUK_HSTRING_GET_DATA(h_input) + match_end_boff, tmp_sz);
 					r++;
 					continue;
 				}
 				default: {
@@ -42735,15 +43621,15 @@
 								capnum = captmp;
 								capadv = 2;
 							}
 						}
 					}
 
 					if (capnum > 0 && capnum < match_caps) {
-						DUK_ASSERT(is_regexp != 0);  /* match_caps == 0 without regexps */
+						DUK_ASSERT(is_regexp != 0); /* match_caps == 0 without regexps */
 
 						/* regexp res_obj is at offset 4 */
 						duk_get_prop_index(thr, 4, (duk_uarridx_t) capnum);
 						if (duk_is_string(thr, -1)) {
 							duk_hstring *h_tmp_str;
 
 							h_tmp_str = duk_known_hstring(thr, -1);
@@ -42754,46 +43640,46 @@
 						}
 						duk_pop(thr);
 						r += capadv;
 						continue;
 					} else {
 						goto repl_write;
 					}
-#else  /* DUK_USE_REGEXP_SUPPORT */
-					goto repl_write;  /* unconditionally */
-#endif  /* DUK_USE_REGEXP_SUPPORT */
-				}  /* default case */
-				}  /* switch (ch2) */
+#else /* DUK_USE_REGEXP_SUPPORT */
+					goto repl_write; /* unconditionally */
+#endif /* DUK_USE_REGEXP_SUPPORT */
+				} /* default case */
+				} /* switch (ch2) */
 
-			 repl_write:
+			repl_write:
 				/* ch1 = (r_increment << 8) + byte */
 
 				DUK_BW_WRITE_ENSURE_U8(thr, bw, (duk_uint8_t) (ch1 & 0xff));
 				r += ch1 >> 8;
-			}  /* while repl */
-		}  /* if (is_repl_func) */
+			} /* while repl */
+		} /* if (is_repl_func) */
 
-		duk_pop(thr);  /* pop regexp res_obj or match string */
+		duk_pop(thr); /* pop regexp res_obj or match string */
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		if (!is_global) {
 #else
-		{  /* unconditionally; is_global==0 */
+		{ /* unconditionally; is_global==0 */
 #endif
 			break;
 		}
 	}
 
 	/* trailer */
 	tmp_sz = (duk_size_t) (DUK_HSTRING_GET_BYTELEN(h_input) - prev_match_end_boff);
 	DUK_BW_WRITE_ENSURE_BYTES(thr, bw, DUK_HSTRING_GET_DATA(h_input) + prev_match_end_boff, tmp_sz);
 
 	DUK_ASSERT_TOP(thr, 4);
 	DUK_BW_COMPACT(thr, bw);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if inputs are safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if inputs are safe. */
 	return 1;
 }
 
 /*
  *  split()
  */
 
@@ -42805,15 +43691,15 @@
 	duk_hstring *h_input;
 	duk_hstring *h_sep;
 	duk_uint32_t limit;
 	duk_uint32_t arr_idx;
 #if defined(DUK_USE_REGEXP_SUPPORT)
 	duk_bool_t is_regexp;
 #endif
-	duk_bool_t matched;  /* set to 1 if any match exists (needed for empty input special case) */
+	duk_bool_t matched; /* set to 1 if any match exists (needed for empty input special case) */
 	duk_uint32_t prev_match_end_coff, prev_match_end_boff;
 	duk_uint32_t match_start_boff, match_start_coff;
 	duk_uint32_t match_end_boff, match_end_coff;
 
 	h_input = duk_push_this_coercible_to_string(thr);
 	DUK_ASSERT(h_input != NULL);
 
@@ -42843,15 +43729,15 @@
 		duk_dup_2(thr);
 		duk_put_prop_index(thr, 3, 0);
 		return 1;
 	} else if (duk_get_hobject_with_class(thr, 0, DUK_HOBJECT_CLASS_REGEXP) != NULL) {
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		duk_push_hobject_bidx(thr, DUK_BIDX_REGEXP_CONSTRUCTOR);
 		duk_dup_0(thr);
-		duk_new(thr, 1);  /* [ ... RegExp val ] -> [ ... res ] */
+		duk_new(thr, 1); /* [ ... RegExp val ] -> [ ... res ] */
 		duk_replace(thr, 0);
 		/* lastIndex is initialized to zero by new RegExp() */
 		is_regexp = 1;
 #else
 		DUK_DCERROR_UNSUPPORTED(thr);
 #endif
 	} else {
@@ -42882,15 +43768,15 @@
 
 		DUK_ASSERT_TOP(thr, 4);
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		if (is_regexp) {
 			duk_dup_0(thr);
 			duk_dup_2(thr);
-			duk_regexp_match_force_global(thr);  /* [ ... regexp input ] -> [ res_obj ] */
+			duk_regexp_match_force_global(thr); /* [ ... regexp input ] -> [ res_obj ] */
 			if (!duk_is_object(thr, -1)) {
 				duk_pop(thr);
 				break;
 			}
 			matched = 1;
 
 			duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_INDEX);
@@ -42915,44 +43801,44 @@
 			if (prev_match_end_boff == match_end_boff) {
 				duk_push_uint(thr, (duk_uint_t) (match_end_coff + 1));
 				duk_put_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
 				duk_pop(thr);
 				continue;
 			}
 		} else {
-#else  /* DUK_USE_REGEXP_SUPPORT */
-		{  /* unconditionally */
-#endif  /* DUK_USE_REGEXP_SUPPORT */
-			const duk_uint8_t *p_start, *p_end, *p;   /* input string scan */
-			const duk_uint8_t *q_start;               /* match string */
+#else /* DUK_USE_REGEXP_SUPPORT */
+		{ /* unconditionally */
+#endif /* DUK_USE_REGEXP_SUPPORT */
+			const duk_uint8_t *p_start, *p_end, *p; /* input string scan */
+			const duk_uint8_t *q_start; /* match string */
 			duk_size_t q_blen, q_clen;
 
 			p_start = DUK_HSTRING_GET_DATA(h_input);
 			p_end = p_start + DUK_HSTRING_GET_BYTELEN(h_input);
 			p = p_start + prev_match_end_boff;
 
-			h_sep = duk_known_hstring(thr, 0);  /* symbol already rejected above */
+			h_sep = duk_known_hstring(thr, 0); /* symbol already rejected above */
 			q_start = DUK_HSTRING_GET_DATA(h_sep);
 			q_blen = (duk_size_t) DUK_HSTRING_GET_BYTELEN(h_sep);
 			q_clen = (duk_size_t) DUK_HSTRING_GET_CHARLEN(h_sep);
 
-			p_end -= q_blen;  /* ensure full memcmp() fits in while */
+			p_end -= q_blen; /* ensure full memcmp() fits in while */
 
 			match_start_coff = prev_match_end_coff;
 
 			if (q_blen == 0) {
 				/* Handle empty separator case: it will always match, and always
 				 * triggers the check in step 13.c.iii initially.  Note that we
 				 * must skip to either end of string or start of first codepoint,
 				 * skipping over any continuation bytes!
 				 *
 				 * Don't allow an empty string to match at the end of the input.
 				 */
 
-				matched = 1;  /* empty separator can always match */
+				matched = 1; /* empty separator can always match */
 
 				match_start_coff++;
 				p++;
 				while (p < p_end) {
 					if ((p[0] & 0xc0) != 0x80) {
 						goto found;
 					}
@@ -42960,56 +43846,59 @@
 				}
 				goto not_found;
 			}
 
 			DUK_ASSERT(q_blen > 0 && q_clen > 0);
 			while (p <= p_end) {
 				DUK_ASSERT(p + q_blen <= DUK_HSTRING_GET_DATA(h_input) + DUK_HSTRING_GET_BYTELEN(h_input));
-				DUK_ASSERT(q_blen > 0);  /* no issues with empty memcmp() */
+				DUK_ASSERT(q_blen > 0); /* no issues with empty memcmp() */
 				if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
 					/* never an empty match, so step 13.c.iii can't be triggered */
 					goto found;
 				}
 
 				/* track utf-8 non-continuation bytes */
 				if ((p[0] & 0xc0) != 0x80) {
 					match_start_coff++;
 				}
 				p++;
 			}
 
-		 not_found:
+		not_found:
 			/* not found */
 			break;
 
-		 found:
+		found:
 			matched = 1;
 			match_start_boff = (duk_uint32_t) (p - p_start);
-			match_end_coff = (duk_uint32_t) (match_start_coff + q_clen);  /* constrained by string length */
-			match_end_boff = (duk_uint32_t) (match_start_boff + q_blen);  /* ditto */
+			match_end_coff = (duk_uint32_t) (match_start_coff + q_clen); /* constrained by string length */
+			match_end_boff = (duk_uint32_t) (match_start_boff + q_blen); /* ditto */
 
 			/* empty match (may happen with empty separator) -> bump and continue */
 			if (prev_match_end_boff == match_end_boff) {
 				prev_match_end_boff++;
 				prev_match_end_coff++;
 				continue;
 			}
-		}  /* if (is_regexp) */
+		} /* if (is_regexp) */
 
 		/* stack[0] = separator (string or regexp)
 		 * stack[1] = limit
 		 * stack[2] = input string
 		 * stack[3] = result array
 		 * stack[4] = regexp res_obj (if is_regexp)
 		 */
 
 		DUK_DDD(DUK_DDDPRINT("split; match_start b=%ld,c=%ld, match_end b=%ld,c=%ld, prev_end b=%ld,c=%ld",
-		                     (long) match_start_boff, (long) match_start_coff,
-		                     (long) match_end_boff, (long) match_end_coff,
-		                     (long) prev_match_end_boff, (long) prev_match_end_coff));
+		                     (long) match_start_boff,
+		                     (long) match_start_coff,
+		                     (long) match_end_boff,
+		                     (long) match_end_coff,
+		                     (long) prev_match_end_boff,
+		                     (long) prev_match_end_coff));
 
 		duk_push_lstring(thr,
 		                 (const char *) (DUK_HSTRING_GET_DATA(h_input) + prev_match_end_boff),
 		                 (duk_size_t) (match_start_boff - prev_match_end_boff));
 		duk_put_prop_index(thr, 3, arr_idx);
 		arr_idx++;
 		if (arr_idx >= limit) {
@@ -43018,41 +43907,41 @@
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		if (is_regexp) {
 			duk_size_t i, len;
 
 			len = duk_get_length(thr, 4);
 			for (i = 1; i < len; i++) {
-				DUK_ASSERT(i <= DUK_UARRIDX_MAX);  /* cannot have >4G captures */
+				DUK_ASSERT(i <= DUK_UARRIDX_MAX); /* cannot have >4G captures */
 				duk_get_prop_index(thr, 4, (duk_uarridx_t) i);
 				duk_put_prop_index(thr, 3, arr_idx);
 				arr_idx++;
 				if (arr_idx >= limit) {
 					goto hit_limit;
 				}
 			}
 
 			duk_pop(thr);
 			/* lastIndex already set up for next match */
 		} else {
-#else  /* DUK_USE_REGEXP_SUPPORT */
-		{  /* unconditionally */
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
+		{
+		/* unconditionally */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 			/* no action */
 		}
 
 		prev_match_end_boff = match_end_boff;
 		prev_match_end_coff = match_end_coff;
 		continue;
-	}  /* for */
+	} /* for */
 
 	/* Combined step 11 (empty string special case) and 14-15. */
 
-	DUK_DDD(DUK_DDDPRINT("split trailer; prev_end b=%ld,c=%ld",
-	                     (long) prev_match_end_boff, (long) prev_match_end_coff));
+	DUK_DDD(DUK_DDDPRINT("split trailer; prev_end b=%ld,c=%ld", (long) prev_match_end_boff, (long) prev_match_end_coff));
 
 	if (DUK_HSTRING_GET_BYTELEN(h_input) > 0 || !matched) {
 		/* Add trailer if:
 		 *   a) non-empty input
 		 *   b) empty input and no (zero size) match found (step 11)
 		 */
 
@@ -43061,15 +43950,15 @@
 		                 (duk_size_t) (DUK_HSTRING_GET_BYTELEN(h_input) - prev_match_end_boff));
 		duk_put_prop_index(thr, 3, arr_idx);
 		/* No arr_idx update or limit check */
 	}
 
 	return 1;
 
- hit_limit:
+hit_limit:
 #if defined(DUK_USE_REGEXP_SUPPORT)
 	if (is_regexp) {
 		duk_pop(thr);
 	}
 #endif
 
 	return 1;
@@ -43093,60 +43982,60 @@
 
 	h = duk_get_hobject_with_class(thr, idx, DUK_HOBJECT_CLASS_REGEXP);
 	if (!h) {
 		goto do_new;
 	}
 	return;
 
- do_new:
+do_new:
 	duk_push_hobject_bidx(thr, DUK_BIDX_REGEXP_CONSTRUCTOR);
 	duk_dup(thr, idx);
-	duk_new(thr, 1);  /* [ ... RegExp val ] -> [ ... res ] */
+	duk_new(thr, 1); /* [ ... RegExp val ] -> [ ... res ] */
 	duk_replace(thr, idx);
 }
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_search(duk_hthread *thr) {
 	/* Easiest way to implement the search required by the specification
 	 * is to do a RegExp test() with lastIndex forced to zero.  To avoid
 	 * side effects on the argument, "clone" the RegExp if a RegExp was
 	 * given as input.
 	 *
 	 * The global flag of the RegExp should be ignored; setting lastIndex
 	 * to zero (which happens when "cloning" the RegExp) should have an
 	 * equivalent effect.
 	 */
 
 	DUK_ASSERT_TOP(thr, 1);
-	(void) duk_push_this_coercible_to_string(thr);  /* at index 1 */
+	(void) duk_push_this_coercible_to_string(thr); /* at index 1 */
 	duk__to_regexp_helper(thr, 0 /*index*/, 1 /*force_new*/);
 
 	/* stack[0] = regexp
 	 * stack[1] = string
 	 */
 
 	/* Avoid using RegExp.prototype methods, as they're writable and
 	 * configurable and may have been changed.
 	 */
 
 	duk_dup_0(thr);
-	duk_dup_1(thr);  /* [ ... re_obj input ] */
-	duk_regexp_match(thr);  /* -> [ ... res_obj ] */
+	duk_dup_1(thr); /* [ ... re_obj input ] */
+	duk_regexp_match(thr); /* -> [ ... res_obj ] */
 
 	if (!duk_is_object(thr, -1)) {
 		duk_push_int(thr, -1);
 		return 1;
 	}
 
 	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_INDEX);
 	DUK_ASSERT(duk_is_number(thr, -1));
 	return 1;
 }
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_match(duk_hthread *thr) {
 	duk_bool_t global;
 	duk_int_t prev_last_index;
 	duk_int_t this_index;
 	duk_int_t arr_idx;
@@ -43158,16 +44047,16 @@
 	DUK_ASSERT_TOP(thr, 2);
 
 	/* stack[0] = regexp
 	 * stack[1] = string
 	 */
 
 	if (!global) {
-		duk_regexp_match(thr);  /* -> [ res_obj ] */
-		return 1;  /* return 'res_obj' */
+		duk_regexp_match(thr); /* -> [ res_obj ] */
+		return 1; /* return 'res_obj' */
 	}
 
 	/* Global case is more complex. */
 
 	/* [ regexp string ] */
 
 	duk_push_int(thr, 0);
@@ -43180,15 +44069,15 @@
 	arr_idx = 0;
 
 	for (;;) {
 		DUK_ASSERT_TOP(thr, 3);
 
 		duk_dup_0(thr);
 		duk_dup_1(thr);
-		duk_regexp_match(thr);  /* -> [ ... regexp string ] -> [ ... res_obj ] */
+		duk_regexp_match(thr); /* -> [ ... regexp string ] -> [ ... res_obj ] */
 
 		if (!duk_is_object(thr, -1)) {
 			duk_pop(thr);
 			break;
 		}
 
 		duk_get_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
@@ -43199,32 +44088,32 @@
 		if (this_index == prev_last_index) {
 			this_index++;
 			duk_push_int(thr, this_index);
 			duk_put_prop_stridx_short(thr, 0, DUK_STRIDX_LAST_INDEX);
 		}
 		prev_last_index = this_index;
 
-		duk_get_prop_index(thr, -1, 0);  /* match string */
+		duk_get_prop_index(thr, -1, 0); /* match string */
 		duk_put_prop_index(thr, 2, (duk_uarridx_t) arr_idx);
 		arr_idx++;
-		duk_pop(thr);  /* res_obj */
+		duk_pop(thr); /* res_obj */
 	}
 
 	if (arr_idx == 0) {
 		duk_push_null(thr);
 	}
 
-	return 1;  /* return 'res_arr' or 'null' */
+	return 1; /* return 'res_arr' or 'null' */
 }
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_concat(duk_hthread *thr) {
 	/* duk_concat() coerces arguments with ToString() in correct order */
 	(void) duk_push_this_coercible_to_string(thr);
-	duk_insert(thr, 0);  /* this is relatively expensive */
+	duk_insert(thr, 0); /* this is relatively expensive */
 	duk_concat(thr, duk_get_top(thr));
 	return 1;
 }
 
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_trim(duk_hthread *thr) {
 	DUK_ASSERT_TOP(thr, 0);
 	(void) duk_push_this_coercible_to_string(thr);
@@ -43281,61 +44170,63 @@
 	DUK_ASSERT(buf != NULL);
 	src = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_input);
 	DUK_ASSERT(src != NULL);
 
 #if defined(DUK_USE_PREFER_SIZE)
 	p = buf;
 	while (count-- > 0) {
-		duk_memcpy((void *) p, (const void *) src, input_blen);  /* copy size may be zero, but pointers are valid */
+		duk_memcpy((void *) p, (const void *) src, input_blen); /* copy size may be zero, but pointers are valid */
 		p += input_blen;
 	}
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	/* Take advantage of already copied pieces to speed up the process
 	 * especially for small repeated strings.
 	 */
 	p = buf;
 	p_end = p + result_len;
 	copy_size = input_blen;
 	for (;;) {
 		duk_size_t remain = (duk_size_t) (p_end - p);
 		DUK_DDD(DUK_DDDPRINT("remain=%ld, copy_size=%ld, input_blen=%ld, result_len=%ld",
-		                     (long) remain, (long) copy_size, (long) input_blen,
+		                     (long) remain,
+		                     (long) copy_size,
+		                     (long) input_blen,
 		                     (long) result_len));
 		if (remain <= copy_size) {
 			/* If result_len is zero, this case is taken and does
 			 * a zero size copy (with valid pointers).
 			 */
 			duk_memcpy((void *) p, (const void *) src, remain);
 			break;
 		} else {
 			duk_memcpy((void *) p, (const void *) src, copy_size);
 			p += copy_size;
 		}
 
-		src = (const duk_uint8_t *) buf;  /* Use buf as source for larger copies. */
+		src = (const duk_uint8_t *) buf; /* Use buf as source for larger copies. */
 		copy_size = (duk_size_t) (p - buf);
 	}
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 	/* XXX: It would be useful to be able to create a duk_hstring with
 	 * a certain byte size whose data area wasn't initialized and which
 	 * wasn't in the string table yet.  This would allow a string to be
 	 * constructed directly without a buffer temporary and when it was
 	 * finished, it could be injected into the string table.  Currently
 	 * this isn't possible because duk_hstrings are only tracked by the
 	 * intern table (they are not in heap_allocated).
 	 */
 
-	duk_buffer_to_string(thr, -1);  /* Safe if input is safe. */
+	duk_buffer_to_string(thr, -1); /* Safe if input is safe. */
 	return 1;
 
- fail_range:
+fail_range:
 	DUK_DCERROR_RANGE_INVALID_ARGS(thr);
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_locale_compare(duk_hthread *thr) {
 	duk_hstring *h1;
 	duk_hstring *h2;
 	duk_size_t h1_len, h2_len, prefix_len;
 	duk_small_int_t ret = 0;
 	duk_small_int_t rc;
@@ -43381,15 +44272,15 @@
 	} else if (h1_len == h2_len) {
 		DUK_ASSERT(ret == 0);
 		goto done;
 	}
 	ret = -1;
 	goto done;
 
- done:
+done:
 	duk_push_int(thr, (duk_int_t) ret);
 	return 1;
 }
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_startswith_endswith(duk_hthread *thr) {
 	duk_int_t magic;
@@ -43468,19 +44359,19 @@
 		const duk_uint8_t *p_cmp_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_target) + off;
 		const duk_uint8_t *p_search = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h_search);
 		if (duk_memcmp_unsafe((const void *) p_cmp_start, (const void *) p_search, (size_t) blen_search) == 0) {
 			result = 1;
 		}
 	}
 
- finish:
+finish:
 	duk_push_boolean(thr, result);
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 #if defined(DUK_USE_ES6)
 DUK_INTERNAL duk_ret_t duk_bi_string_prototype_includes(duk_hthread *thr) {
 	duk_hstring *h;
 	duk_hstring *h_search;
 	duk_int_t len;
 	duk_int_t pos;
@@ -43495,16 +44386,16 @@
 	pos = duk_to_int_clamped(thr, 1, 0, len);
 	DUK_ASSERT(pos >= 0 && pos <= len);
 
 	pos = duk__str_search_shared(thr, h, h_search, pos, 0 /*backwards*/);
 	duk_push_boolean(thr, pos >= 0);
 	return 1;
 }
-#endif  /* DUK_USE_ES6 */
-#endif  /* DUK_USE_STRING_BUILTIN */
+#endif /* DUK_USE_ES6 */
+#endif /* DUK_USE_STRING_BUILTIN */
 #line 1 "duk_bi_symbol.c"
 /*
  *  Symbol built-in
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -43539,26 +44430,28 @@
 	 *   +1    0xff after description, before unique suffix
 	 *   +17   autogenerated unique suffix: 'ffffffff-ffffffff' is longest
 	 *   +1    0xff after unique suffix for symbols with undefined description
 	 */
 	buf = (duk_uint8_t *) duk_push_fixed_buffer(thr, 1 + len + 1 + 17 + 1);
 	DUK_ASSERT(buf != NULL);
 	p = buf + 1;
-	DUK_ASSERT(desc != NULL || len == 0);  /* may be NULL if len is 0 */
+	DUK_ASSERT(desc != NULL || len == 0); /* may be NULL if len is 0 */
 	duk_memcpy_unsafe((void *) p, (const void *) desc, len);
 	p += len;
 	if (magic == 0) {
 		/* Symbol(): create unique symbol.  Use two 32-bit values
 		 * to avoid dependency on 64-bit types and 64-bit integer
 		 * formatting (at least for now).
 		 */
 		if (++thr->heap->sym_counter[0] == 0) {
 			thr->heap->sym_counter[1]++;
 		}
-		p += DUK_SPRINTF((char *) p, "\xFF" "%lx-%lx",
+		p += DUK_SPRINTF((char *) p,
+		                 "\xFF"
+		                 "%lx-%lx",
 		                 (unsigned long) thr->heap->sym_counter[1],
 		                 (unsigned long) thr->heap->sym_counter[0]);
 		if (desc == NULL) {
 			/* Special case for 'undefined' description, trailing
 			 * 0xff distinguishes from empty string description,
 			 * but needs minimal special case handling elsewhere.
 			 */
@@ -43667,15 +44560,15 @@
 	if (h_str == NULL) {
 		return DUK_RET_TYPE_ERROR;
 	}
 	duk_push_hstring(thr, h_str);
 	return 1;
 }
 
-#endif  /* DUK_USE_SYMBOL_BUILTIN */
+#endif /* DUK_USE_SYMBOL_BUILTIN */
 #line 1 "duk_bi_thread.c"
 /*
  *  Thread builtins
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -43702,15 +44595,15 @@
 	new_thr->state = DUK_HTHREAD_STATE_INACTIVE;
 
 	/* push initial function call to new thread stack; this is
 	 * picked up by resume().
 	 */
 	duk_push_hobject(new_thr, func);
 
-	return 1;  /* return thread */
+	return 1; /* return thread */
 }
 #endif
 
 /*
  *  Resume a thread.
  *
  *  The thread must be in resumable state, either (a) new thread which hasn't
@@ -43748,41 +44641,40 @@
 	/* [ thread value ] */
 
 	/*
 	 *  Thread state and calling context checks
 	 */
 
 	if (thr->callstack_top < 2) {
-		DUK_DD(DUK_DDPRINT("resume state invalid: callstack should contain at least 2 entries (caller and Duktape.Thread.resume)"));
+		DUK_DD(DUK_DDPRINT(
+		    "resume state invalid: callstack should contain at least 2 entries (caller and Duktape.Thread.resume)"));
 		goto state_error;
 	}
 	DUK_ASSERT(thr->callstack_curr != NULL);
 	DUK_ASSERT(thr->callstack_curr->parent != NULL);
-	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL);  /* us */
+	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL); /* us */
 	DUK_ASSERT(DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)));
-	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr->parent) != NULL);  /* caller */
+	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr->parent) != NULL); /* caller */
 
 	caller_func = DUK_ACT_GET_FUNC(thr->callstack_curr->parent);
 	if (!DUK_HOBJECT_IS_COMPFUNC(caller_func)) {
 		DUK_DD(DUK_DDPRINT("resume state invalid: caller must be ECMAScript code"));
 		goto state_error;
 	}
 
 	/* Note: there is no requirement that: 'thr->callstack_preventcount == 1'
 	 * like for yield.
 	 */
 
-	if (thr_resume->state != DUK_HTHREAD_STATE_INACTIVE &&
-	    thr_resume->state != DUK_HTHREAD_STATE_YIELDED) {
+	if (thr_resume->state != DUK_HTHREAD_STATE_INACTIVE && thr_resume->state != DUK_HTHREAD_STATE_YIELDED) {
 		DUK_DD(DUK_DDPRINT("resume state invalid: target thread must be INACTIVE or YIELDED"));
 		goto state_error;
 	}
 
-	DUK_ASSERT(thr_resume->state == DUK_HTHREAD_STATE_INACTIVE ||
-	           thr_resume->state == DUK_HTHREAD_STATE_YIELDED);
+	DUK_ASSERT(thr_resume->state == DUK_HTHREAD_STATE_INACTIVE || thr_resume->state == DUK_HTHREAD_STATE_YIELDED);
 
 	/* Further state-dependent pre-checks */
 
 	if (thr_resume->state == DUK_HTHREAD_STATE_YIELDED) {
 		/* no pre-checks now, assume a previous yield() has left things in
 		 * tip-top shape (longjmp handler will assert for these).
 		 */
@@ -43792,22 +44684,21 @@
 		DUK_ASSERT(thr_resume->state == DUK_HTHREAD_STATE_INACTIVE);
 
 		/* The initial function must be an ECMAScript function (but
 		 * can be bound).  We must make sure of that before we longjmp
 		 * because an error in the RESUME handler call processing will
 		 * not be handled very cleanly.
 		 */
-		if ((thr_resume->callstack_top != 0) ||
-		    (thr_resume->valstack_top - thr_resume->valstack != 1)) {
+		if ((thr_resume->callstack_top != 0) || (thr_resume->valstack_top - thr_resume->valstack != 1)) {
 			goto state_error;
 		}
 
 		duk_push_tval(thr, DUK_GET_TVAL_NEGIDX(thr_resume, -1));
 		duk_resolve_nonbound_function(thr);
-		h_fun = duk_require_hobject(thr, -1);  /* reject lightfuncs on purpose */
+		h_fun = duk_require_hobject(thr, -1); /* reject lightfuncs on purpose */
 		if (!DUK_HOBJECT_IS_CALLABLE(h_fun) || !DUK_HOBJECT_IS_COMPFUNC(h_fun)) {
 			goto state_error;
 		}
 		duk_pop(thr);
 	}
 
 #if 0
@@ -43828,16 +44719,16 @@
 	 *  error handler is called here right before throwing, but it also
 	 *  runs in the resumer's thread.  It might be nice to get a traceback
 	 *  from the resumee but this is not the case now.
 	 */
 
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
 	if (is_error) {
-		DUK_ASSERT_TOP(thr, 2);  /* value (error) is at stack top */
-		duk_err_augment_error_throw(thr);  /* in resumer's context */
+		DUK_ASSERT_TOP(thr, 2); /* value (error) is at stack top */
+		duk_err_augment_error_throw(thr); /* in resumer's context */
 	}
 #endif
 
 #if defined(DUK_USE_DEBUG)
 	if (is_error) {
 		DUK_DDD(DUK_DDDPRINT("RESUME ERROR: thread=%!T, value=%!T",
 		                     (duk_tval *) duk_get_tval(thr, 0),
@@ -43853,29 +44744,29 @@
 	}
 #endif
 
 	thr->heap->lj.type = DUK_LJ_TYPE_RESUME;
 
 	/* lj value2: thread */
 	DUK_ASSERT(thr->valstack_bottom < thr->valstack_top);
-	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value2, &thr->valstack_bottom[0]);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value2, &thr->valstack_bottom[0]); /* side effects */
 
 	/* lj value1: value */
 	DUK_ASSERT(thr->valstack_bottom + 1 < thr->valstack_top);
-	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value1, &thr->valstack_bottom[1]);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value1, &thr->valstack_bottom[1]); /* side effects */
 	DUK_TVAL_CHKFAST_INPLACE_SLOW(&thr->heap->lj.value1);
 
 	thr->heap->lj.iserror = is_error;
 
-	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL);  /* call is from executor, so we know we have a jmpbuf */
-	duk_err_longjmp(thr);  /* execution resumes in bytecode executor */
+	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL); /* call is from executor, so we know we have a jmpbuf */
+	duk_err_longjmp(thr); /* execution resumes in bytecode executor */
 	DUK_UNREACHABLE();
 	/* Never here, fall through to error (from compiler point of view). */
 
- state_error:
+state_error:
 	DUK_DCERROR_TYPE_INVALID_STATE(thr);
 }
 #endif
 
 /*
  *  Yield the current thread.
  *
@@ -43916,83 +44807,83 @@
 	if (!thr->resumer) {
 		DUK_DD(DUK_DDPRINT("yield state invalid: current thread must have a resumer"));
 		goto state_error;
 	}
 	DUK_ASSERT(thr->resumer->state == DUK_HTHREAD_STATE_RESUMED);
 
 	if (thr->callstack_top < 2) {
-		DUK_DD(DUK_DDPRINT("yield state invalid: callstack should contain at least 2 entries (caller and Duktape.Thread.yield)"));
+		DUK_DD(DUK_DDPRINT(
+		    "yield state invalid: callstack should contain at least 2 entries (caller and Duktape.Thread.yield)"));
 		goto state_error;
 	}
 	DUK_ASSERT(thr->callstack_curr != NULL);
 	DUK_ASSERT(thr->callstack_curr->parent != NULL);
-	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL);  /* us */
+	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL); /* us */
 	DUK_ASSERT(DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)));
-	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr->parent) != NULL);  /* caller */
+	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr->parent) != NULL); /* caller */
 
 	caller_func = DUK_ACT_GET_FUNC(thr->callstack_curr->parent);
 	if (!DUK_HOBJECT_IS_COMPFUNC(caller_func)) {
 		DUK_DD(DUK_DDPRINT("yield state invalid: caller must be ECMAScript code"));
 		goto state_error;
 	}
 
-	DUK_ASSERT(thr->callstack_preventcount >= 1);  /* should never be zero, because we (Duktape.Thread.yield) are on the stack */
+	DUK_ASSERT(thr->callstack_preventcount >= 1); /* should never be zero, because we (Duktape.Thread.yield) are on the stack */
 	if (thr->callstack_preventcount != 1) {
 		/* Note: the only yield-preventing call is Duktape.Thread.yield(), hence check for 1, not 0 */
-		DUK_DD(DUK_DDPRINT("yield state invalid: there must be no yield-preventing calls in current thread callstack (preventcount is %ld)",
+		DUK_DD(DUK_DDPRINT("yield state invalid: there must be no yield-preventing calls in current thread callstack "
+		                   "(preventcount is %ld)",
 		                   (long) thr->callstack_preventcount));
 		goto state_error;
 	}
 
 	/*
 	 *  The error object has been augmented with a traceback and other
 	 *  info from its creation point -- usually the current thread.
 	 *  The error handler, however, is called right before throwing
 	 *  and runs in the yielder's thread.
 	 */
 
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
 	if (is_error) {
-		DUK_ASSERT_TOP(thr, 1);  /* value (error) is at stack top */
-		duk_err_augment_error_throw(thr);  /* in yielder's context */
+		DUK_ASSERT_TOP(thr, 1); /* value (error) is at stack top */
+		duk_err_augment_error_throw(thr); /* in yielder's context */
 	}
 #endif
 
 #if defined(DUK_USE_DEBUG)
 	if (is_error) {
-		DUK_DDD(DUK_DDDPRINT("YIELD ERROR: value=%!T",
-		                     (duk_tval *) duk_get_tval(thr, 0)));
+		DUK_DDD(DUK_DDDPRINT("YIELD ERROR: value=%!T", (duk_tval *) duk_get_tval(thr, 0)));
 	} else {
-		DUK_DDD(DUK_DDDPRINT("YIELD NORMAL: value=%!T",
-		                     (duk_tval *) duk_get_tval(thr, 0)));
+		DUK_DDD(DUK_DDDPRINT("YIELD NORMAL: value=%!T", (duk_tval *) duk_get_tval(thr, 0)));
 	}
 #endif
 
 	/*
 	 *  Process yield
 	 *
 	 *  After longjmp(), processing continues in bytecode executor longjmp
 	 *  handler, which will e.g. update thr->resumer to NULL.
 	 */
 
 	thr->heap->lj.type = DUK_LJ_TYPE_YIELD;
 
 	/* lj value1: value */
 	DUK_ASSERT(thr->valstack_bottom < thr->valstack_top);
-	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value1, &thr->valstack_bottom[0]);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, &thr->heap->lj.value1, &thr->valstack_bottom[0]); /* side effects */
 	DUK_TVAL_CHKFAST_INPLACE_SLOW(&thr->heap->lj.value1);
 
 	thr->heap->lj.iserror = is_error;
 
-	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL);  /* call is from executor, so we know we have a jmpbuf */
-	duk_err_longjmp(thr);  /* execution resumes in bytecode executor */
+	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL); /* call is from executor, so we know we have a jmpbuf */
+	duk_err_longjmp(thr); /* execution resumes in bytecode executor */
 	DUK_UNREACHABLE();
 	/* Never here, fall through to error (from compiler point of view). */
 
- state_error:
+state_error:
 	DUK_DCERROR_TYPE_INVALID_STATE(thr);
 }
 #endif
 
 #if defined(DUK_USE_COROUTINE_SUPPORT)
 DUK_INTERNAL duk_ret_t duk_bi_thread_current(duk_hthread *thr) {
 	duk_push_current_thread(thr);
@@ -44064,25 +44955,25 @@
 			fb->offset += (duk_size_t) res;
 		}
 	}
 	va_end(ap);
 }
 
 DUK_INTERNAL void duk_fb_put_funcptr(duk_fixedbuffer *fb, duk_uint8_t *fptr, duk_size_t fptr_size) {
-	char buf[64+1];
+	char buf[64 + 1];
 	duk_debug_format_funcptr(buf, sizeof(buf), fptr, fptr_size);
 	buf[sizeof(buf) - 1] = (char) 0;
 	duk_fb_put_cstring(fb, buf);
 }
 
 DUK_INTERNAL duk_bool_t duk_fb_is_full(duk_fixedbuffer *fb) {
 	return (fb->offset >= fb->length);
 }
 
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 #line 1 "duk_debug_vsnprintf.c"
 /*
  *  Custom formatter for debug printing, allowing Duktape specific data
  *  structures (such as tagged values and heap objects) to be printed with
  *  a nice format string.  Because debug printing should not affect execution
  *  state, formatting here must be independent of execution (see implications
  *  below) and must not allocate memory.
@@ -44141,66 +45032,66 @@
 /* #include stdio.h -> already included */
 /* #include stdarg.h -> already included */
 #include <string.h>
 
 /* list of conversion specifiers that terminate a format tag;
  * this is unfortunately guesswork.
  */
-#define DUK__ALLOWED_STANDARD_SPECIFIERS  "diouxXeEfFgGaAcsCSpnm"
+#define DUK__ALLOWED_STANDARD_SPECIFIERS "diouxXeEfFgGaAcsCSpnm"
 
 /* maximum length of standard format tag that we support */
-#define DUK__MAX_FORMAT_TAG_LENGTH  32
+#define DUK__MAX_FORMAT_TAG_LENGTH 32
 
 /* heapobj recursion depth when deep printing is selected */
-#define DUK__DEEP_DEPTH_LIMIT  8
+#define DUK__DEEP_DEPTH_LIMIT 8
 
 /* maximum recursion depth for loop detection stacks */
-#define DUK__LOOP_STACK_DEPTH  256
+#define DUK__LOOP_STACK_DEPTH 256
 
 /* must match bytecode defines now; build autogenerate? */
 DUK_LOCAL const char * const duk__bc_optab[256] = {
-	"LDREG", "STREG", "JUMP", "LDCONST", "LDINT", "LDINTX", "LDTHIS", "LDUNDEF",
-	"LDNULL", "LDTRUE", "LDFALSE", "GETVAR", "BNOT", "LNOT", "UNM", "UNP",
-	"EQ_RR", "EQ_CR", "EQ_RC", "EQ_CC", "NEQ_RR", "NEQ_CR", "NEQ_RC", "NEQ_CC",
-	"SEQ_RR", "SEQ_CR", "SEQ_RC", "SEQ_CC", "SNEQ_RR", "SNEQ_CR", "SNEQ_RC", "SNEQ_CC",
-
-	"GT_RR", "GT_CR", "GT_RC", "GT_CC", "GE_RR", "GE_CR", "GE_RC", "GE_CC",
-	"LT_RR", "LT_CR", "LT_RC", "LT_CC", "LE_RR", "LE_CR", "LE_RC", "LE_CC",
-	"IFTRUE_R", "IFTRUE_C", "IFFALSE_R", "IFFALSE_C", "ADD_RR", "ADD_CR", "ADD_RC", "ADD_CC",
-	"SUB_RR", "SUB_CR", "SUB_RC", "SUB_CC", "MUL_RR", "MUL_CR", "MUL_RC", "MUL_CC",
-
-	"DIV_RR", "DIV_CR", "DIV_RC", "DIV_CC", "MOD_RR", "MOD_CR", "MOD_RC", "MOD_CC",
-	"EXP_RR", "EXP_CR", "EXP_RC", "EXP_CC", "BAND_RR", "BAND_CR", "BAND_RC", "BAND_CC",
-	"BOR_RR", "BOR_CR", "BOR_RC", "BOR_CC", "BXOR_RR", "BXOR_CR", "BXOR_RC", "BXOR_CC",
-	"BASL_RR", "BASL_CR", "BASL_RC", "BASL_CC", "BLSR_RR", "BLSR_CR", "BLSR_RC", "BLSR_CC",
-
-	"BASR_RR", "BASR_CR", "BASR_RC", "BASR_CC", "INSTOF_RR", "INSTOF_CR", "INSTOF_RC", "INSTOF_CC",
-	"IN_RR", "IN_CR", "IN_RC", "IN_CC", "GETPROP_RR", "GETPROP_CR", "GETPROP_RC", "GETPROP_CC",
-	"PUTPROP_RR", "PUTPROP_CR", "PUTPROP_RC", "PUTPROP_CC", "DELPROP_RR", "DELPROP_CR", "DELPROP_RC", "DELPROP_CC",
-	"PREINCR", "PREDECR", "POSTINCR", "POSTDECR", "PREINCV", "PREDECV", "POSTINCV", "POSTDECV",
+	"LDREG",       "STREG",       "JUMP",        "LDCONST",     "LDINT",       "LDINTX",      "LDTHIS",      "LDUNDEF",
+	"LDNULL",      "LDTRUE",      "LDFALSE",     "GETVAR",      "BNOT",        "LNOT",        "UNM",         "UNP",
+	"EQ_RR",       "EQ_CR",       "EQ_RC",       "EQ_CC",       "NEQ_RR",      "NEQ_CR",      "NEQ_RC",      "NEQ_CC",
+	"SEQ_RR",      "SEQ_CR",      "SEQ_RC",      "SEQ_CC",      "SNEQ_RR",     "SNEQ_CR",     "SNEQ_RC",     "SNEQ_CC",
+
+	"GT_RR",       "GT_CR",       "GT_RC",       "GT_CC",       "GE_RR",       "GE_CR",       "GE_RC",       "GE_CC",
+	"LT_RR",       "LT_CR",       "LT_RC",       "LT_CC",       "LE_RR",       "LE_CR",       "LE_RC",       "LE_CC",
+	"IFTRUE_R",    "IFTRUE_C",    "IFFALSE_R",   "IFFALSE_C",   "ADD_RR",      "ADD_CR",      "ADD_RC",      "ADD_CC",
+	"SUB_RR",      "SUB_CR",      "SUB_RC",      "SUB_CC",      "MUL_RR",      "MUL_CR",      "MUL_RC",      "MUL_CC",
+
+	"DIV_RR",      "DIV_CR",      "DIV_RC",      "DIV_CC",      "MOD_RR",      "MOD_CR",      "MOD_RC",      "MOD_CC",
+	"EXP_RR",      "EXP_CR",      "EXP_RC",      "EXP_CC",      "BAND_RR",     "BAND_CR",     "BAND_RC",     "BAND_CC",
+	"BOR_RR",      "BOR_CR",      "BOR_RC",      "BOR_CC",      "BXOR_RR",     "BXOR_CR",     "BXOR_RC",     "BXOR_CC",
+	"BASL_RR",     "BASL_CR",     "BASL_RC",     "BASL_CC",     "BLSR_RR",     "BLSR_CR",     "BLSR_RC",     "BLSR_CC",
+
+	"BASR_RR",     "BASR_CR",     "BASR_RC",     "BASR_CC",     "INSTOF_RR",   "INSTOF_CR",   "INSTOF_RC",   "INSTOF_CC",
+	"IN_RR",       "IN_CR",       "IN_RC",       "IN_CC",       "GETPROP_RR",  "GETPROP_CR",  "GETPROP_RC",  "GETPROP_CC",
+	"PUTPROP_RR",  "PUTPROP_CR",  "PUTPROP_RC",  "PUTPROP_CC",  "DELPROP_RR",  "DELPROP_CR",  "DELPROP_RC",  "DELPROP_CC",
+	"PREINCR",     "PREDECR",     "POSTINCR",    "POSTDECR",    "PREINCV",     "PREDECV",     "POSTINCV",    "POSTDECV",
 
-	"PREINCP_RR", "PREINCP_CR", "PREINCP_RC", "PREINCP_CC", "PREDECP_RR", "PREDECP_CR", "PREDECP_RC", "PREDECP_CC",
+	"PREINCP_RR",  "PREINCP_CR",  "PREINCP_RC",  "PREINCP_CC",  "PREDECP_RR",  "PREDECP_CR",  "PREDECP_RC",  "PREDECP_CC",
 	"POSTINCP_RR", "POSTINCP_CR", "POSTINCP_RC", "POSTINCP_CC", "POSTDECP_RR", "POSTDECP_CR", "POSTDECP_RC", "POSTDECP_CC",
-	"DECLVAR_RR", "DECLVAR_CR", "DECLVAR_RC", "DECLVAR_CC", "REGEXP_RR", "REGEXP_RC", "REGEXP_CR", "REGEXP_CC",
-	"CLOSURE", "TYPEOF", "TYPEOFID", "PUTVAR", "DELVAR", "RETREG", "RETUNDEF", "RETCONST",
+	"DECLVAR_RR",  "DECLVAR_CR",  "DECLVAR_RC",  "DECLVAR_CC",  "REGEXP_RR",   "REGEXP_RC",   "REGEXP_CR",   "REGEXP_CC",
+	"CLOSURE",     "TYPEOF",      "TYPEOFID",    "PUTVAR",      "DELVAR",      "RETREG",      "RETUNDEF",    "RETCONST",
 
-	"RETCONSTN", "LABEL", "ENDLABEL", "BREAK", "CONTINUE", "TRYCATCH", "ENDTRY", "ENDCATCH",
-	"ENDFIN", "THROW", "INVLHS", "CSREG", "CSVAR_RR", "CSVAR_CR", "CSVAR_RC", "CSVAR_CC",
-	"CALL0", "CALL1", "CALL2", "CALL3", "CALL4", "CALL5", "CALL6", "CALL7",
-	"CALL8", "CALL9", "CALL10", "CALL11", "CALL12", "CALL13", "CALL14", "CALL15",
-
-	"NEWOBJ", "NEWARR", "MPUTOBJ", "MPUTOBJI", "INITSET", "INITGET", "MPUTARR", "MPUTARRI",
-	"SETALEN", "INITENUM", "NEXTENUM", "NEWTARGET", "DEBUGGER", "NOP", "INVALID", "UNUSED207",
-	"GETPROPC_RR", "GETPROPC_CR", "GETPROPC_RC", "GETPROPC_CC", "UNUSED212", "UNUSED213", "UNUSED214", "UNUSED215",
-	"UNUSED216", "UNUSED217", "UNUSED218", "UNUSED219", "UNUSED220", "UNUSED221", "UNUSED222", "UNUSED223",
-
-	"UNUSED224", "UNUSED225", "UNUSED226", "UNUSED227", "UNUSED228", "UNUSED229", "UNUSED230", "UNUSED231",
-	"UNUSED232", "UNUSED233", "UNUSED234", "UNUSED235", "UNUSED236", "UNUSED237", "UNUSED238", "UNUSED239",
-	"UNUSED240", "UNUSED241", "UNUSED242", "UNUSED243", "UNUSED244", "UNUSED245", "UNUSED246", "UNUSED247",
-	"UNUSED248", "UNUSED249", "UNUSED250", "UNUSED251", "UNUSED252", "UNUSED253", "UNUSED254", "UNUSED255"
+	"RETCONSTN",   "LABEL",       "ENDLABEL",    "BREAK",       "CONTINUE",    "TRYCATCH",    "ENDTRY",      "ENDCATCH",
+	"ENDFIN",      "THROW",       "INVLHS",      "CSREG",       "CSVAR_RR",    "CSVAR_CR",    "CSVAR_RC",    "CSVAR_CC",
+	"CALL0",       "CALL1",       "CALL2",       "CALL3",       "CALL4",       "CALL5",       "CALL6",       "CALL7",
+	"CALL8",       "CALL9",       "CALL10",      "CALL11",      "CALL12",      "CALL13",      "CALL14",      "CALL15",
+
+	"NEWOBJ",      "NEWARR",      "MPUTOBJ",     "MPUTOBJI",    "INITSET",     "INITGET",     "MPUTARR",     "MPUTARRI",
+	"SETALEN",     "INITENUM",    "NEXTENUM",    "NEWTARGET",   "DEBUGGER",    "NOP",         "INVALID",     "UNUSED207",
+	"GETPROPC_RR", "GETPROPC_CR", "GETPROPC_RC", "GETPROPC_CC", "UNUSED212",   "UNUSED213",   "UNUSED214",   "UNUSED215",
+	"UNUSED216",   "UNUSED217",   "UNUSED218",   "UNUSED219",   "UNUSED220",   "UNUSED221",   "UNUSED222",   "UNUSED223",
+
+	"UNUSED224",   "UNUSED225",   "UNUSED226",   "UNUSED227",   "UNUSED228",   "UNUSED229",   "UNUSED230",   "UNUSED231",
+	"UNUSED232",   "UNUSED233",   "UNUSED234",   "UNUSED235",   "UNUSED236",   "UNUSED237",   "UNUSED238",   "UNUSED239",
+	"UNUSED240",   "UNUSED241",   "UNUSED242",   "UNUSED243",   "UNUSED244",   "UNUSED245",   "UNUSED246",   "UNUSED247",
+	"UNUSED248",   "UNUSED249",   "UNUSED250",   "UNUSED251",   "UNUSED252",   "UNUSED253",   "UNUSED254",   "UNUSED255"
 };
 
 typedef struct duk__dprint_state duk__dprint_state;
 struct duk__dprint_state {
 	duk_fixedbuffer *fb;
 
 	/* loop_stack_index could be perhaps be replaced by 'depth', but it's nice
@@ -44242,36 +45133,38 @@
 		return;
 	}
 
 	if (st->binary) {
 		duk_size_t i;
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_LBRACKET);
 		for (i = 0; i < (duk_size_t) sizeof(*h); i++) {
-			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *)h)[i]);
+			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *) h)[i]);
 		}
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_RBRACKET);
 	}
 
-#if defined(DUK_USE_REFERENCE_COUNTING)  /* currently implicitly also DUK_USE_DOUBLE_LINKED_HEAP */
+#if defined(DUK_USE_REFERENCE_COUNTING) /* currently implicitly also DUK_USE_DOUBLE_LINKED_HEAP */
 	if (st->heavy) {
-		duk_fb_sprintf(fb, "[h_next=%p,h_prev=%p,h_refcount=%lu,h_flags=%08lx,type=%ld,"
+		duk_fb_sprintf(fb,
+		               "[h_next=%p,h_prev=%p,h_refcount=%lu,h_flags=%08lx,type=%ld,"
 		               "reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
 		               (void *) DUK_HEAPHDR_GET_NEXT(NULL, h),
 		               (void *) DUK_HEAPHDR_GET_PREV(NULL, h),
 		               (unsigned long) DUK_HEAPHDR_GET_REFCOUNT(h),
 		               (unsigned long) DUK_HEAPHDR_GET_FLAGS(h),
 		               (long) DUK_HEAPHDR_GET_TYPE(h),
 		               (long) (DUK_HEAPHDR_HAS_REACHABLE(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_TEMPROOT(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZABLE(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZED(h) ? 1 : 0));
 	}
 #else
 	if (st->heavy) {
-		duk_fb_sprintf(fb, "[h_next=%p,h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
+		duk_fb_sprintf(fb,
+		               "[h_next=%p,h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
 		               (void *) DUK_HEAPHDR_GET_NEXT(NULL, h),
 		               (unsigned long) DUK_HEAPHDR_GET_FLAGS(h),
 		               (long) DUK_HEAPHDR_GET_TYPE(h),
 		               (long) (DUK_HEAPHDR_HAS_REACHABLE(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_TEMPROOT(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZABLE(h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZED(h) ? 1 : 0));
@@ -44290,33 +45183,35 @@
 		return;
 	}
 
 	if (st->binary) {
 		duk_size_t i;
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_LBRACKET);
 		for (i = 0; i < (duk_size_t) sizeof(*h); i++) {
-			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *)h)[i]);
+			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *) h)[i]);
 		}
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_RBRACKET);
 	}
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	if (st->heavy) {
-		duk_fb_sprintf(fb, "[h_refcount=%lu,h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
+		duk_fb_sprintf(fb,
+		               "[h_refcount=%lu,h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
 		               (unsigned long) DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h),
 		               (unsigned long) DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) h),
 		               (long) DUK_HEAPHDR_GET_TYPE((duk_heaphdr *) h),
 		               (long) (DUK_HEAPHDR_HAS_REACHABLE((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_TEMPROOT((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZABLE((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) h) ? 1 : 0));
 	}
 #else
 	if (st->heavy) {
-		duk_fb_sprintf(fb, "[h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
+		duk_fb_sprintf(fb,
+		               "[h_flags=%08lx,type=%ld,reachable=%ld,temproot=%ld,finalizable=%ld,finalized=%ld]",
 		               (unsigned long) DUK_HEAPHDR_GET_FLAGS((duk_heaphdr *) h),
 		               (long) DUK_HEAPHDR_GET_TYPE((duk_heaphdr *) h),
 		               (long) (DUK_HEAPHDR_HAS_REACHABLE((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_TEMPROOT((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZABLE((duk_heaphdr *) h) ? 1 : 0),
 		               (long) (DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) h) ? 1 : 0));
 	}
@@ -44379,15 +45274,16 @@
 	}
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	/* XXX: limit to quoted strings only, to save keys from being cluttered? */
 	duk_fb_sprintf(fb, "/%lu", (unsigned long) DUK_HEAPHDR_GET_REFCOUNT(&h->hdr));
 #endif
 }
 
-#define DUK__COMMA()  do { \
+#define DUK__COMMA() \
+	do { \
 		if (first) { \
 			first = 0; \
 		} else { \
 			duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_COMMA); \
 		} \
 	} while (0)
 
@@ -44492,180 +45388,261 @@
 			if (!st->internal && DUK_HSTRING_HAS_HIDDEN(key)) {
 				continue;
 			}
 			DUK__COMMA();
 			duk__print_hstring(st, key, 0);
 			duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_COLON);
 			if (DUK_HOBJECT_E_SLOT_IS_ACCESSOR(NULL, h, i)) {
-				duk_fb_sprintf(fb, "[get:%p,set:%p]",
+				duk_fb_sprintf(fb,
+				               "[get:%p,set:%p]",
 				               (void *) DUK_HOBJECT_E_GET_VALUE(NULL, h, i).a.get,
 				               (void *) DUK_HOBJECT_E_GET_VALUE(NULL, h, i).a.set);
 			} else {
 				tv = &DUK_HOBJECT_E_GET_VALUE(NULL, h, i).v;
 				duk__print_tval(st, tv);
 			}
 			if (st->heavy) {
 				duk_fb_sprintf(fb, "<%02lx>", (unsigned long) DUK_HOBJECT_E_GET_FLAGS(NULL, h, i));
 			}
 		}
 	}
 	if (st->internal) {
 		if (DUK_HOBJECT_IS_ARRAY(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__array:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__array:true");
 		}
 		if (DUK_HOBJECT_HAS_EXTENSIBLE(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__extensible:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__extensible:true");
 		}
 		if (DUK_HOBJECT_HAS_CONSTRUCTABLE(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__constructable:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__constructable:true");
 		}
 		if (DUK_HOBJECT_HAS_BOUNDFUNC(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__boundfunc:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__boundfunc:true");
 		}
 		if (DUK_HOBJECT_HAS_COMPFUNC(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__compfunc:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__compfunc:true");
 		}
 		if (DUK_HOBJECT_HAS_NATFUNC(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__natfunc:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__natfunc:true");
 		}
 		if (DUK_HOBJECT_HAS_BUFOBJ(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__bufobj:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__bufobj:true");
 		}
 		if (DUK_HOBJECT_IS_THREAD(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__thread:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__thread:true");
 		}
 		if (DUK_HOBJECT_HAS_ARRAY_PART(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__array_part:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__array_part:true");
 		}
 		if (DUK_HOBJECT_HAS_STRICT(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__strict:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__strict:true");
 		}
 		if (DUK_HOBJECT_HAS_NOTAIL(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__notail:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__notail:true");
 		}
 		if (DUK_HOBJECT_HAS_NEWENV(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__newenv:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__newenv:true");
 		}
 		if (DUK_HOBJECT_HAS_NAMEBINDING(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__namebinding:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__namebinding:true");
 		}
 		if (DUK_HOBJECT_HAS_CREATEARGS(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__createargs:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__createargs:true");
 		}
 		if (DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__exotic_array:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__exotic_array:true");
 		}
 		if (DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__exotic_stringobj:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__exotic_stringobj:true");
 		}
 		if (DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__exotic_arguments:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__exotic_arguments:true");
 		}
 		if (DUK_HOBJECT_IS_BUFOBJ(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__exotic_bufobj:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__exotic_bufobj:true");
 		}
 		if (DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(h)) {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__exotic_proxyobj:true");
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__exotic_proxyobj:true");
 		}
 	}
 
 	if (st->internal && DUK_HOBJECT_IS_ARRAY(h)) {
 		duk_harray *a = (duk_harray *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__length:%ld", (long) a->length);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__length_nonwritable:%ld", (long) a->length_nonwritable);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__length:%ld", (long) a->length);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__length_nonwritable:%ld", (long) a->length_nonwritable);
 	} else if (st->internal && DUK_HOBJECT_IS_COMPFUNC(h)) {
 		duk_hcompfunc *f = (duk_hcompfunc *) h;
-		DUK__COMMA(); duk_fb_put_cstring(fb, "__data:");
+		DUK__COMMA();
+		duk_fb_put_cstring(fb, "__data:");
 		duk__print_hbuffer(st, (duk_hbuffer *) DUK_HCOMPFUNC_GET_DATA(NULL, f));
-		DUK__COMMA(); duk_fb_put_cstring(fb, "__lexenv:"); duk__print_hobject(st, DUK_HCOMPFUNC_GET_LEXENV(NULL, f));
-		DUK__COMMA(); duk_fb_put_cstring(fb, "__varenv:"); duk__print_hobject(st, DUK_HCOMPFUNC_GET_VARENV(NULL, f));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__nregs:%ld", (long) f->nregs);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__nargs:%ld", (long) f->nargs);
+		DUK__COMMA();
+		duk_fb_put_cstring(fb, "__lexenv:");
+		duk__print_hobject(st, DUK_HCOMPFUNC_GET_LEXENV(NULL, f));
+		DUK__COMMA();
+		duk_fb_put_cstring(fb, "__varenv:");
+		duk__print_hobject(st, DUK_HCOMPFUNC_GET_VARENV(NULL, f));
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__nregs:%ld", (long) f->nregs);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__nargs:%ld", (long) f->nargs);
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
-		DUK__COMMA(); duk_fb_sprintf(fb, "__start_line:%ld", (long) f->start_line);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__end_line:%ld", (long) f->end_line);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__start_line:%ld", (long) f->start_line);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__end_line:%ld", (long) f->end_line);
 #endif
-		DUK__COMMA(); duk_fb_put_cstring(fb, "__data:");
+		DUK__COMMA();
+		duk_fb_put_cstring(fb, "__data:");
 		duk__print_hbuffer(st, (duk_hbuffer *) DUK_HCOMPFUNC_GET_DATA(NULL, f));
 	} else if (st->internal && DUK_HOBJECT_IS_NATFUNC(h)) {
 		duk_hnatfunc *f = (duk_hnatfunc *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__func:");
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__func:");
 		duk_fb_put_funcptr(fb, (duk_uint8_t *) &f->func, sizeof(f->func));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__nargs:%ld", (long) f->nargs);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__magic:%ld", (long) f->magic);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__nargs:%ld", (long) f->nargs);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__magic:%ld", (long) f->magic);
 	} else if (st->internal && DUK_HOBJECT_IS_DECENV(h)) {
 		duk_hdecenv *e = (duk_hdecenv *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__thread:"); duk__print_hobject(st, (duk_hobject *) e->thread);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__varmap:"); duk__print_hobject(st, (duk_hobject *) e->varmap);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__regbase_byteoff:%ld", (long) e->regbase_byteoff);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__thread:");
+		duk__print_hobject(st, (duk_hobject *) e->thread);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__varmap:");
+		duk__print_hobject(st, (duk_hobject *) e->varmap);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__regbase_byteoff:%ld", (long) e->regbase_byteoff);
 	} else if (st->internal && DUK_HOBJECT_IS_OBJENV(h)) {
 		duk_hobjenv *e = (duk_hobjenv *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__target:"); duk__print_hobject(st, (duk_hobject *) e->target);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__has_this:%ld", (long) e->has_this);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__target:");
+		duk__print_hobject(st, (duk_hobject *) e->target);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__has_this:%ld", (long) e->has_this);
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	} else if (st->internal && DUK_HOBJECT_IS_BUFOBJ(h)) {
 		duk_hbufobj *b = (duk_hbufobj *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__buf:");
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__buf:");
 		duk__print_hbuffer(st, (duk_hbuffer *) b->buf);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__buf_prop:");
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__buf_prop:");
 		duk__print_hobject(st, (duk_hobject *) b->buf_prop);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__offset:%ld", (long) b->offset);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__length:%ld", (long) b->length);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__shift:%ld", (long) b->shift);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__elemtype:%ld", (long) b->elem_type);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__offset:%ld", (long) b->offset);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__length:%ld", (long) b->length);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__shift:%ld", (long) b->shift);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__elemtype:%ld", (long) b->elem_type);
 #endif
 	} else if (st->internal && DUK_HOBJECT_IS_PROXY(h)) {
 		duk_hproxy *p = (duk_hproxy *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__target:");
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__target:");
 		duk__print_hobject(st, p->target);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__handler:");
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__handler:");
 		duk__print_hobject(st, p->handler);
 	} else if (st->internal && DUK_HOBJECT_IS_THREAD(h)) {
 		duk_hthread *t = (duk_hthread *) h;
-		DUK__COMMA(); duk_fb_sprintf(fb, "__ptr_curr_pc:%p", (void *) t->ptr_curr_pc);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__heap:%p", (void *) t->heap);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__strict:%ld", (long) t->strict);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__state:%ld", (long) t->state);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__unused1:%ld", (long) t->unused1);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__unused2:%ld", (long) t->unused2);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__valstack:%p", (void *) t->valstack);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__valstack_end:%p/%ld", (void *) t->valstack_end, (long) (t->valstack_end - t->valstack));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__valstack_alloc_end:%p/%ld", (void *) t->valstack_alloc_end, (long) (t->valstack_alloc_end - t->valstack));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__valstack_bottom:%p/%ld", (void *) t->valstack_bottom, (long) (t->valstack_bottom - t->valstack));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__valstack_top:%p/%ld", (void *) t->valstack_top, (long) (t->valstack_top - t->valstack));
-		DUK__COMMA(); duk_fb_sprintf(fb, "__callstack_curr:%p", (void *) t->callstack_curr);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__callstack_top:%ld", (long) t->callstack_top);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__callstack_preventcount:%ld", (long) t->callstack_preventcount);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__resumer:"); duk__print_hobject(st, (duk_hobject *) t->resumer);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__compile_ctx:%p", (void *) t->compile_ctx);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__ptr_curr_pc:%p", (void *) t->ptr_curr_pc);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__heap:%p", (void *) t->heap);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__strict:%ld", (long) t->strict);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__state:%ld", (long) t->state);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__unused1:%ld", (long) t->unused1);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__unused2:%ld", (long) t->unused2);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__valstack:%p", (void *) t->valstack);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__valstack_end:%p/%ld", (void *) t->valstack_end, (long) (t->valstack_end - t->valstack));
+		DUK__COMMA();
+		duk_fb_sprintf(fb,
+		               "__valstack_alloc_end:%p/%ld",
+		               (void *) t->valstack_alloc_end,
+		               (long) (t->valstack_alloc_end - t->valstack));
+		DUK__COMMA();
+		duk_fb_sprintf(fb,
+		               "__valstack_bottom:%p/%ld",
+		               (void *) t->valstack_bottom,
+		               (long) (t->valstack_bottom - t->valstack));
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__valstack_top:%p/%ld", (void *) t->valstack_top, (long) (t->valstack_top - t->valstack));
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__callstack_curr:%p", (void *) t->callstack_curr);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__callstack_top:%ld", (long) t->callstack_top);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__callstack_preventcount:%ld", (long) t->callstack_preventcount);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__resumer:");
+		duk__print_hobject(st, (duk_hobject *) t->resumer);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__compile_ctx:%p", (void *) t->compile_ctx);
 #if defined(DUK_USE_INTERRUPT_COUNTER)
-		DUK__COMMA(); duk_fb_sprintf(fb, "__interrupt_counter:%ld", (long) t->interrupt_counter);
-		DUK__COMMA(); duk_fb_sprintf(fb, "__interrupt_init:%ld", (long) t->interrupt_init);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__interrupt_counter:%ld", (long) t->interrupt_counter);
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__interrupt_init:%ld", (long) t->interrupt_init);
 #endif
 
 		/* XXX: print built-ins array? */
-
 	}
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	if (st->internal) {
-		DUK__COMMA(); duk_fb_sprintf(fb, "__refcount:%lu", (unsigned long) DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h));
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__refcount:%lu", (unsigned long) DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h));
 	}
 #endif
 	if (st->internal) {
-		DUK__COMMA(); duk_fb_sprintf(fb, "__class:%ld", (long) DUK_HOBJECT_GET_CLASS_NUMBER(h));
+		DUK__COMMA();
+		duk_fb_sprintf(fb, "__class:%ld", (long) DUK_HOBJECT_GET_CLASS_NUMBER(h));
 	}
 
-	DUK__COMMA(); duk_fb_sprintf(fb, "__heapptr:%p", (void *) h);  /* own pointer */
+	DUK__COMMA();
+	duk_fb_sprintf(fb, "__heapptr:%p", (void *) h); /* own pointer */
 
 	/* prototype should be last, for readability */
 	if (DUK_HOBJECT_GET_PROTOTYPE(NULL, h)) {
 		if (st->follow_proto) {
-			DUK__COMMA(); duk_fb_put_cstring(fb, "__prototype:"); duk__print_hobject(st, DUK_HOBJECT_GET_PROTOTYPE(NULL, h));
+			DUK__COMMA();
+			duk_fb_put_cstring(fb, "__prototype:");
+			duk__print_hobject(st, DUK_HOBJECT_GET_PROTOTYPE(NULL, h));
 		} else {
-			DUK__COMMA(); duk_fb_sprintf(fb, "__prototype:%p", (void *) DUK_HOBJECT_GET_PROTOTYPE(NULL, h));
+			DUK__COMMA();
+			duk_fb_sprintf(fb, "__prototype:%p", (void *) DUK_HOBJECT_GET_PROTOTYPE(NULL, h));
 		}
 	}
 
 	duk_fb_put_cstring(fb, brace2);
 
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 	if (st->heavy && DUK_HOBJECT_GET_HSIZE(h) > 0) {
@@ -44683,15 +45660,15 @@
 				duk_fb_sprintf(fb, "%ld", (long) h_idx);
 			}
 		}
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_RANGLE);
 	}
 #endif
 
- finished:
+finished:
 	st->depth--;
 	if (pushed_loopstack) {
 		st->loop_stack_index--;
 		st->loop_stack[st->loop_stack_index] = NULL;
 	}
 }
 
@@ -44710,20 +45687,22 @@
 		duk_fb_put_cstring(fb, "NULL");
 		return;
 	}
 
 	if (DUK_HBUFFER_HAS_DYNAMIC(h)) {
 		if (DUK_HBUFFER_HAS_EXTERNAL(h)) {
 			duk_hbuffer_external *g = (duk_hbuffer_external *) h;
-			duk_fb_sprintf(fb, "buffer:external:%p:%ld",
+			duk_fb_sprintf(fb,
+			               "buffer:external:%p:%ld",
 			               (void *) DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(NULL, g),
 			               (long) DUK_HBUFFER_EXTERNAL_GET_SIZE(g));
 		} else {
 			duk_hbuffer_dynamic *g = (duk_hbuffer_dynamic *) h;
-			duk_fb_sprintf(fb, "buffer:dynamic:%p:%ld",
+			duk_fb_sprintf(fb,
+			               "buffer:dynamic:%p:%ld",
 			               (void *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(NULL, g),
 			               (long) DUK_HBUFFER_DYNAMIC_GET_SIZE(g));
 		}
 	} else {
 		duk_fb_sprintf(fb, "buffer:fixed:%ld", (long) DUK_HBUFFER_GET_SIZE(h));
 	}
 
@@ -44788,15 +45767,15 @@
 		return;
 	}
 
 	if (st->binary) {
 		duk_size_t i;
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_LBRACKET);
 		for (i = 0; i < (duk_size_t) sizeof(*tv); i++) {
-			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *)tv)[i]);
+			duk_fb_sprintf(fb, "%02lx", (unsigned long) ((duk_uint8_t *) tv)[i]);
 		}
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_RBRACKET);
 	}
 
 	if (st->heavy) {
 		duk_fb_put_byte(fb, (duk_uint8_t) DUK_ASC_LANGLE);
 	}
@@ -44871,25 +45850,30 @@
 
 	op = (duk_small_int_t) DUK_DEC_OP(ins);
 	op_name = duk__bc_optab[op];
 
 	/* XXX: option to fix opcode length so it lines up nicely */
 
 	if (op == DUK_OP_JUMP) {
-		duk_int_t diff1 = (duk_int_t) (DUK_DEC_ABC(ins) - DUK_BC_JUMP_BIAS);  /* from next pc */
-		duk_int_t diff2 = diff1 + 1;                                          /* from curr pc */
+		duk_int_t diff1 = (duk_int_t) (DUK_DEC_ABC(ins) - DUK_BC_JUMP_BIAS); /* from next pc */
+		duk_int_t diff2 = diff1 + 1; /* from curr pc */
 
-		duk_fb_sprintf(fb, "%s %ld (to pc%c%ld)",
-		               (const char *) op_name, (long) diff1,
-		               (int) (diff2 >= 0 ? '+' : '-'),  /* char format: use int */
+		duk_fb_sprintf(fb,
+		               "%s %ld (to pc%c%ld)",
+		               (const char *) op_name,
+		               (long) diff1,
+		               (int) (diff2 >= 0 ? '+' : '-'), /* char format: use int */
 		               (long) (diff2 >= 0 ? diff2 : -diff2));
 	} else {
-		duk_fb_sprintf(fb, "%s %ld, %ld, %ld",
-		               (const char *) op_name, (long) DUK_DEC_A(ins),
-		               (long) DUK_DEC_B(ins), (long) DUK_DEC_C(ins));
+		duk_fb_sprintf(fb,
+		               "%s %ld, %ld, %ld",
+		               (const char *) op_name,
+		               (long) DUK_DEC_A(ins),
+		               (long) DUK_DEC_B(ins),
+		               (long) DUK_DEC_C(ins));
 	}
 }
 
 DUK_LOCAL void duk__print_opcode(duk__dprint_state *st, duk_small_int_t opcode) {
 	duk_fixedbuffer *fb = st->fb;
 
 	if (opcode < DUK_BC_OP_MIN || opcode > DUK_BC_OP_MAX) {
@@ -44907,41 +45891,52 @@
 	}
 
 	if (!cat) {
 		duk_fb_put_cstring(fb, "NULL");
 		return;
 	}
 
-	duk_fb_sprintf(fb, "[catcher ptr=%p parent=%p varname=%p pc_base=%p, idx_base=%ld, flags=0x%08lx]",
+	duk_fb_sprintf(fb,
+	               "[catcher ptr=%p parent=%p varname=%p pc_base=%p, idx_base=%ld, flags=0x%08lx]",
 	               (void *) cat,
-	               (void *) cat->parent, (void *) cat->h_varname, (void *) cat->pc_base,
-		       (long) cat->idx_base, (unsigned long) cat->flags);
+	               (void *) cat->parent,
+	               (void *) cat->h_varname,
+	               (void *) cat->pc_base,
+	               (long) cat->idx_base,
+	               (unsigned long) cat->flags);
 }
 
-
 DUK_LOCAL void duk__print_activation(duk__dprint_state *st, duk_activation *act) {
 	duk_fixedbuffer *fb = st->fb;
 
 	if (duk_fb_is_full(fb)) {
 		return;
 	}
 
 	if (!act) {
 		duk_fb_put_cstring(fb, "NULL");
 		return;
 	}
 
 	/* prev_caller: conditional, omitted on purpose, it's rarely used. */
 	/* prev_line: conditional, omitted on purpose (but would be nice). */
-	duk_fb_sprintf(fb, "[activation ptr=%p tv_func=<omit> func=%p parent=%p var_env=%p lex_env=%p cat=%p curr_pc=%p bottom_byteoff=%ld retval_byteoff=%ld reserve_byteoff=%ld flags=%ld]",
+	duk_fb_sprintf(fb,
+	               "[activation ptr=%p tv_func=<omit> func=%p parent=%p var_env=%p lex_env=%p cat=%p curr_pc=%p "
+	               "bottom_byteoff=%ld retval_byteoff=%ld reserve_byteoff=%ld flags=%ld]",
 	               (void *) act,
-	               (void *) act->func, (void *) act->parent, (void *) act->var_env,
-		       (void *) act->lex_env, (void *) act->cat, (void *) act->curr_pc,
-		       (long) act->bottom_byteoff, (long) act->retval_byteoff, (long) act->reserve_byteoff,
-		       (long) act->flags);
+	               (void *) act->func,
+	               (void *) act->parent,
+	               (void *) act->var_env,
+	               (void *) act->lex_env,
+	               (void *) act->cat,
+	               (void *) act->curr_pc,
+	               (long) act->bottom_byteoff,
+	               (long) act->retval_byteoff,
+	               (long) act->reserve_byteoff,
+	               (long) act->flags);
 }
 
 DUK_INTERNAL duk_int_t duk_debug_vsnprintf(char *str, duk_size_t size, const char *format, va_list ap) {
 	duk_fixedbuffer fb;
 	const char *p = format;
 	const char *p_end = p + DUK_STRLEN(format);
 	duk_int_t retval;
@@ -44952,15 +45947,15 @@
 	fb.offset = 0;
 	fb.truncated = 0;
 
 	while (p < p_end) {
 		char ch = *p++;
 		const char *p_begfmt = NULL;
 		duk_bool_t got_exclamation = 0;
-		duk_bool_t got_long = 0;  /* %lf, %ld etc */
+		duk_bool_t got_long = 0; /* %lf, %ld etc */
 		duk__dprint_state st;
 
 		if (ch != DUK_ASC_PERCENT) {
 			duk_fb_put_byte(&fb, (duk_uint8_t) ch);
 			continue;
 		}
 
@@ -45115,27 +46110,27 @@
 			} else {
 				/* ignore */
 			}
 		}
 	}
 	goto done;
 
- format_error:
+format_error:
 	duk_fb_put_cstring(&fb, "FMTERR");
 	/* fall through */
 
- done:
+done:
 	retval = (duk_int_t) fb.offset;
 	duk_fb_put_byte(&fb, (duk_uint8_t) 0);
 
 	/* return total chars written excluding terminator */
 	return retval;
 }
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL duk_int_t duk_debug_snprintf(char *str, duk_size_t size, const char *format, ...) {
 	duk_int_t retval;
 	va_list ap;
 	va_start(ap, format);
 	retval = duk_debug_vsnprintf(str, size, format, ap);
 	va_end(ap);
 	return retval;
@@ -45168,15 +46163,15 @@
 #else
 		ch = fptr[fptr_size - 1 - i];
 #endif
 		p += DUK_SNPRINTF((char *) p, (duk_size_t) left, "%02lx", (unsigned long) ch);
 	}
 }
 
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 /* automatic undefs */
 #undef DUK__ALLOWED_STANDARD_SPECIFIERS
 #undef DUK__COMMA
 #undef DUK__DEEP_DEPTH_LIMIT
 #undef DUK__LOOP_STACK_DEPTH
 #undef DUK__MAX_FORMAT_TAG_LENGTH
@@ -45190,25 +46185,31 @@
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 
 /*
  *  Assert helpers
  */
 
 #if defined(DUK_USE_ASSERTIONS)
-#define DUK__DBG_TPORT_ENTER() do { \
+#define DUK__DBG_TPORT_ENTER() \
+	do { \
 		DUK_ASSERT(heap->dbg_calling_transport == 0); \
 		heap->dbg_calling_transport = 1; \
 	} while (0)
-#define DUK__DBG_TPORT_EXIT() do { \
+#define DUK__DBG_TPORT_EXIT() \
+	do { \
 		DUK_ASSERT(heap->dbg_calling_transport == 1); \
 		heap->dbg_calling_transport = 0; \
 	} while (0)
 #else
-#define DUK__DBG_TPORT_ENTER() do {} while (0)
-#define DUK__DBG_TPORT_EXIT() do {} while (0)
+#define DUK__DBG_TPORT_ENTER() \
+	do { \
+	} while (0)
+#define DUK__DBG_TPORT_EXIT() \
+	do { \
+	} while (0)
 #endif
 
 /*
  *  Helper structs
  */
 
 typedef union {
@@ -45220,15 +46221,16 @@
 	 */
 } duk__ptr_union;
 
 /*
  *  Detach handling
  */
 
-#define DUK__SET_CONN_BROKEN(thr,reason) do { \
+#define DUK__SET_CONN_BROKEN(thr, reason) \
+	do { \
 		/* For now shared handler is fine. */ \
 		duk__debug_do_detach1((thr)->heap, (reason)); \
 	} while (0)
 
 DUK_LOCAL void duk__debug_do_detach1(duk_heap *heap, duk_int_t reason) {
 	/* Can be called multiple times with no harm.  Mark the transport
 	 * bad (dbg_read_cb == NULL) and clear state except for the detached
@@ -45241,15 +46243,15 @@
 	if (heap->dbg_detaching) {
 		DUK_D(DUK_DPRINT("debugger already detaching, ignore detach1"));
 		return;
 	}
 
 	DUK_D(DUK_DPRINT("debugger transport detaching, marking transport broken"));
 
-	heap->dbg_detaching = 1;  /* prevent multiple in-progress detaches */
+	heap->dbg_detaching = 1; /* prevent multiple in-progress detaches */
 
 	if (heap->dbg_write_cb != NULL) {
 		duk_hthread *thr;
 
 		thr = heap->heap_thread;
 		DUK_ASSERT(thr != NULL);
 
@@ -45269,16 +46271,16 @@
 	/* heap->dbg_processing: keep on purpose to avoid debugger re-entry in detaching state */
 	heap->dbg_state_dirty = 0;
 	heap->dbg_force_restart = 0;
 	heap->dbg_pause_flags = 0;
 	heap->dbg_pause_act = NULL;
 	heap->dbg_pause_startline = 0;
 	heap->dbg_have_next_byte = 0;
-	duk_debug_clear_paused(heap);  /* XXX: some overlap with field inits above */
-	heap->dbg_state_dirty = 0;     /* XXX: clear_paused sets dirty; rework? */
+	duk_debug_clear_paused(heap); /* XXX: some overlap with field inits above */
+	heap->dbg_state_dirty = 0; /* XXX: clear_paused sets dirty; rework? */
 
 	/* Ensure there are no stale active breakpoint pointers.
 	 * Breakpoint list is currently kept - we could empty it
 	 * here but we'd need to handle refcounts correctly, and
 	 * we'd need a 'thr' reference for that.
 	 *
 	 * XXX: clear breakpoint on either attach or detach?
@@ -45330,15 +46332,15 @@
 	duk_heap *heap;
 
 	DUK_ASSERT(thr != NULL);
 
 	heap = thr->heap;
 	DUK_D(DUK_DPRINT("transport read/write error, NULL all callbacks expected detached"));
 	heap->dbg_read_cb = NULL;
-	heap->dbg_write_cb = NULL;  /* this is especially critical to avoid another write call in detach1() */
+	heap->dbg_write_cb = NULL; /* this is especially critical to avoid another write call in detach1() */
 	heap->dbg_peek_cb = NULL;
 	heap->dbg_read_flush_cb = NULL;
 	heap->dbg_write_flush_cb = NULL;
 	heap->dbg_request_cb = NULL;
 	/* keep heap->dbg_detached_cb */
 }
 
@@ -45352,25 +46354,27 @@
 	line = duk_debug_curr_line(thr);
 	if (line == 0) {
 		/* No line info for current function. */
 		duk_small_uint_t updated_flags;
 
 		updated_flags = pause_flags & ~(DUK_PAUSE_FLAG_LINE_CHANGE);
 		DUK_D(DUK_DPRINT("no line info for current activation, disable line-based pause flags: 0x%08lx -> 0x%08lx",
-		                 (long) pause_flags, (long) updated_flags));
+		                 (long) pause_flags,
+		                 (long) updated_flags));
 		pause_flags = updated_flags;
 	}
 
 	heap->dbg_pause_flags = pause_flags;
 	heap->dbg_pause_act = thr->callstack_curr;
 	heap->dbg_pause_startline = (duk_uint32_t) line;
 	heap->dbg_state_dirty = 1;
 
 	DUK_D(DUK_DPRINT("set state for automatic pause triggers, flags=0x%08lx, act=%p, startline=%ld",
-	                 (long) heap->dbg_pause_flags, (void *) heap->dbg_pause_act,
+	                 (long) heap->dbg_pause_flags,
+	                 (void *) heap->dbg_pause_act,
 	                 (long) heap->dbg_pause_startline));
 }
 
 /*
  *  Debug connection peek and flush primitives
  */
 
@@ -45517,58 +46521,54 @@
 #endif
 		DUK__DBG_TPORT_ENTER();
 		got = heap->dbg_read_cb(heap->dbg_udata, (char *) p, left);
 		DUK__DBG_TPORT_EXIT();
 
 		if (got == 0 || got > left) {
 			DUK_D(DUK_DPRINT("connection error during read, return zero data"));
-			duk__debug_null_most_callbacks(thr);  /* avoid calling write callback in detach1() */
+			duk__debug_null_most_callbacks(thr); /* avoid calling write callback in detach1() */
 			DUK__SET_CONN_BROKEN(thr, 1);
 			goto fail;
 		}
 		p += got;
 	}
 	return;
 
- fail:
+fail:
 	duk_memzero((void *) data, (size_t) length);
 }
 
 DUK_INTERNAL duk_uint8_t duk_debug_read_byte(duk_hthread *thr) {
 	duk_uint8_t x;
 
-	x = 0;  /* just in case callback is broken and won't write 'x' */
+	x = 0; /* just in case callback is broken and won't write 'x' */
 	duk_debug_read_bytes(thr, &x, 1);
 	return x;
 }
 
 DUK_LOCAL duk_uint32_t duk__debug_read_uint32_raw(duk_hthread *thr) {
 	duk_uint8_t buf[4];
 
 	DUK_ASSERT(thr != NULL);
 
 	duk_debug_read_bytes(thr, buf, 4);
-	return ((duk_uint32_t) buf[0] << 24) |
-	       ((duk_uint32_t) buf[1] << 16) |
-	       ((duk_uint32_t) buf[2] << 8) |
-	       (duk_uint32_t) buf[3];
+	return ((duk_uint32_t) buf[0] << 24) | ((duk_uint32_t) buf[1] << 16) | ((duk_uint32_t) buf[2] << 8) | (duk_uint32_t) buf[3];
 }
 
 DUK_LOCAL duk_int32_t duk__debug_read_int32_raw(duk_hthread *thr) {
 	return (duk_int32_t) duk__debug_read_uint32_raw(thr);
 }
 
 DUK_LOCAL duk_uint16_t duk__debug_read_uint16_raw(duk_hthread *thr) {
 	duk_uint8_t buf[2];
 
 	DUK_ASSERT(thr != NULL);
 
 	duk_debug_read_bytes(thr, buf, 2);
-	return ((duk_uint16_t) buf[0] << 8) |
-	       (duk_uint16_t) buf[1];
+	return ((duk_uint16_t) buf[0] << 8) | (duk_uint16_t) buf[1];
 }
 
 DUK_INTERNAL duk_int32_t duk_debug_read_int(duk_hthread *thr) {
 	duk_small_uint_t x;
 	duk_small_uint_t t;
 
 	DUK_ASSERT(thr != NULL);
@@ -45592,18 +46592,18 @@
 	duk_uint8_t buf[31];
 	duk_uint8_t *p;
 
 	if (len <= sizeof(buf)) {
 		duk_debug_read_bytes(thr, buf, (duk_size_t) len);
 		duk_push_lstring(thr, (const char *) buf, (duk_size_t) len);
 	} else {
-		p = (duk_uint8_t *) duk_push_fixed_buffer(thr, (duk_size_t) len);  /* zero for paranoia */
+		p = (duk_uint8_t *) duk_push_fixed_buffer(thr, (duk_size_t) len); /* zero for paranoia */
 		DUK_ASSERT(p != NULL);
 		duk_debug_read_bytes(thr, p, (duk_size_t) len);
-		(void) duk_buffer_to_string(thr, -1);  /* Safety relies on debug client, which is OK. */
+		(void) duk_buffer_to_string(thr, -1); /* Safety relies on debug client, which is OK. */
 	}
 
 	return duk_require_hstring(thr, -1);
 }
 
 DUK_INTERNAL duk_hstring *duk_debug_read_hstring(duk_hthread *thr) {
 	duk_small_uint_t x;
@@ -45621,25 +46621,25 @@
 		len = (duk_uint32_t) duk__debug_read_uint32_raw(thr);
 	} else {
 		goto fail;
 	}
 
 	return duk__debug_read_hstring_raw(thr, len);
 
- fail:
+fail:
 	DUK_D(DUK_DPRINT("debug connection error: failed to decode int"));
 	DUK__SET_CONN_BROKEN(thr, 1);
-	duk_push_hstring_empty(thr);  /* always push some string */
+	duk_push_hstring_empty(thr); /* always push some string */
 	return duk_require_hstring(thr, -1);
 }
 
 DUK_LOCAL duk_hbuffer *duk__debug_read_hbuffer_raw(duk_hthread *thr, duk_uint32_t len) {
 	duk_uint8_t *p;
 
-	p = (duk_uint8_t *) duk_push_fixed_buffer(thr, (duk_size_t) len);  /* zero for paranoia */
+	p = (duk_uint8_t *) duk_push_fixed_buffer(thr, (duk_size_t) len); /* zero for paranoia */
 	DUK_ASSERT(p != NULL);
 	duk_debug_read_bytes(thr, p, (duk_size_t) len);
 
 	return duk_require_hbuffer(thr, -1);
 }
 
 DUK_LOCAL void *duk__debug_read_pointer_raw(duk_hthread *thr) {
@@ -45654,15 +46654,15 @@
 	}
 	duk_debug_read_bytes(thr, (duk_uint8_t *) &pu.p, sizeof(pu));
 #if defined(DUK_USE_INTEGER_LE)
 	duk_byteswap_bytes((duk_uint8_t *) pu.b, sizeof(pu));
 #endif
 	return (void *) pu.p;
 
- fail:
+fail:
 	DUK_D(DUK_DPRINT("debug connection error: failed to decode pointer"));
 	DUK__SET_CONN_BROKEN(thr, 1);
 	return (void *) NULL;
 }
 
 DUK_LOCAL duk_double_t duk__debug_read_double_raw(duk_hthread *thr) {
 	duk_double_union du;
@@ -45712,15 +46712,15 @@
 		break;
 	default:
 		goto fail;
 	}
 
 	return (duk_heaphdr *) duk__debug_read_pointer_raw(thr);
 
- fail:
+fail:
 	DUK_D(DUK_DPRINT("debug connection error: failed to decode any pointer (object, pointer, heapptr)"));
 	DUK__SET_CONN_BROKEN(thr, 1);
 	return NULL;
 }
 
 DUK_INTERNAL duk_tval *duk_debug_read_tval(duk_hthread *thr) {
 	duk_uint8_t x;
@@ -45818,23 +46818,23 @@
 	}
 	case DUK_DBG_IB_HEAPPTR: {
 		duk_heaphdr *h;
 		h = (duk_heaphdr *) duk__debug_read_pointer_raw(thr);
 		duk_push_heapptr(thr, (void *) h);
 		break;
 	}
-	case DUK_DBG_IB_UNUSED:  /* unused: not accepted in inbound messages */
+	case DUK_DBG_IB_UNUSED: /* unused: not accepted in inbound messages */
 	default:
 		goto fail;
 	}
 
- return_ptr:
+return_ptr:
 	return DUK_GET_TVAL_NEGIDX(thr, -1);
 
- fail:
+fail:
 	DUK_D(DUK_DPRINT("debug connection error: failed to decode tval"));
 	DUK__SET_CONN_BROKEN(thr, 1);
 	return NULL;
 }
 
 /*
  *  Debug connection write primitives
@@ -45876,15 +46876,15 @@
 		left = 1;
 #endif
 		DUK__DBG_TPORT_ENTER();
 		got = heap->dbg_write_cb(heap->dbg_udata, (const char *) p, left);
 		DUK__DBG_TPORT_EXIT();
 
 		if (got == 0 || got > left) {
-			duk__debug_null_most_callbacks(thr);  /* avoid calling write callback in detach1() */
+			duk__debug_null_most_callbacks(thr); /* avoid calling write callback in detach1() */
 			DUK_D(DUK_DPRINT("connection error during write"));
 			DUK__SET_CONN_BROKEN(thr, 1);
 			return;
 		}
 		p += got;
 	}
 }
@@ -45943,16 +46943,15 @@
 	 * the full 32-bit unsigned range (only 32-bit signed).  For now,
 	 * unsigned 32-bit values simply written as signed ones.  This is not
 	 * a concrete issue except for 32-bit heaphdr fields.  Proper solutions
 	 * would be to (a) write such integers as IEEE doubles or (b) add an
 	 * unsigned 32-bit dvalue.
 	 */
 	if (x >= 0x80000000UL) {
-		DUK_D(DUK_DPRINT("writing unsigned integer 0x%08lx as signed integer",
-		                 (long) x));
+		DUK_D(DUK_DPRINT("writing unsigned integer 0x%08lx as signed integer", (long) x));
 	}
 	duk_debug_write_int(thr, (duk_int32_t) x);
 }
 
 DUK_INTERNAL void duk_debug_write_strbuf(duk_hthread *thr, const char *data, duk_size_t length, duk_uint8_t marker_base) {
 	duk_uint8_t buf[5];
 	duk_size_t buflen;
@@ -45985,17 +46984,15 @@
 DUK_INTERNAL void duk_debug_write_string(duk_hthread *thr, const char *data, duk_size_t length) {
 	duk_debug_write_strbuf(thr, data, length, DUK_DBG_IB_STR4);
 }
 
 DUK_INTERNAL void duk_debug_write_cstring(duk_hthread *thr, const char *data) {
 	DUK_ASSERT(thr != NULL);
 
-	duk_debug_write_string(thr,
-	                       data,
-	                       data ? DUK_STRLEN(data) : 0);
+	duk_debug_write_string(thr, data, data ? DUK_STRLEN(data) : 0);
 }
 
 DUK_INTERNAL void duk_debug_write_hstring(duk_hthread *thr, duk_hstring *h) {
 	DUK_ASSERT(thr != NULL);
 
 	/* XXX: differentiate null pointer from empty string? */
 	duk_debug_write_string(thr,
@@ -46041,15 +47038,15 @@
 	duk__debug_write_pointer_raw(thr, ptr, DUK_DBG_IB_POINTER);
 }
 
 #if defined(DUK_USE_DEBUGGER_DUMPHEAP) || defined(DUK_USE_DEBUGGER_INSPECT)
 DUK_INTERNAL void duk_debug_write_heapptr(duk_hthread *thr, duk_heaphdr *h) {
 	duk__debug_write_pointer_raw(thr, (void *) h, DUK_DBG_IB_HEAPPTR);
 }
-#endif  /* DUK_USE_DEBUGGER_DUMPHEAP || DUK_USE_DEBUGGER_INSPECT */
+#endif /* DUK_USE_DEBUGGER_DUMPHEAP || DUK_USE_DEBUGGER_INSPECT */
 
 DUK_INTERNAL void duk_debug_write_hobject(duk_hthread *thr, duk_hobject *obj) {
 	duk_uint8_t buf[3];
 	duk__ptr_union pu;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(sizeof(obj) >= 1 && sizeof(obj) <= 16);
@@ -46084,16 +47081,15 @@
 	case DUK_TAG_UNUSED:
 		duk_debug_write_byte(thr, DUK_DBG_IB_UNUSED);
 		break;
 	case DUK_TAG_NULL:
 		duk_debug_write_byte(thr, DUK_DBG_IB_NULL);
 		break;
 	case DUK_TAG_BOOLEAN:
-		DUK_ASSERT(DUK_TVAL_GET_BOOLEAN(tv) == 0 ||
-		           DUK_TVAL_GET_BOOLEAN(tv) == 1);
+		DUK_ASSERT(DUK_TVAL_GET_BOOLEAN(tv) == 0 || DUK_TVAL_GET_BOOLEAN(tv) == 1);
 		duk_debug_write_boolean(thr, DUK_TVAL_GET_BOOLEAN(tv));
 		break;
 	case DUK_TAG_POINTER:
 		duk_debug_write_pointer(thr, (void *) DUK_TVAL_GET_POINTER(tv));
 		break;
 	case DUK_TAG_LIGHTFUNC:
 		DUK_TVAL_GET_LIGHTFUNC(tv, lf_func, lf_flags);
@@ -46130,22 +47126,30 @@
 		du1.d = DUK_TVAL_GET_NUMBER(tv);
 		i32 = (duk_int32_t) du1.d;
 		du2.d = (duk_double_t) i32;
 
 		DUK_DD(DUK_DDPRINT("i32=%ld du1=%02x%02x%02x%02x%02x%02x%02x%02x "
 		                   "du2=%02x%02x%02x%02x%02x%02x%02x%02x",
 		                   (long) i32,
-		                   (unsigned int) du1.uc[0], (unsigned int) du1.uc[1],
-		                   (unsigned int) du1.uc[2], (unsigned int) du1.uc[3],
-		                   (unsigned int) du1.uc[4], (unsigned int) du1.uc[5],
-		                   (unsigned int) du1.uc[6], (unsigned int) du1.uc[7],
-		                   (unsigned int) du2.uc[0], (unsigned int) du2.uc[1],
-		                   (unsigned int) du2.uc[2], (unsigned int) du2.uc[3],
-		                   (unsigned int) du2.uc[4], (unsigned int) du2.uc[5],
-		                   (unsigned int) du2.uc[6], (unsigned int) du2.uc[7]));
+		                   (unsigned int) du1.uc[0],
+		                   (unsigned int) du1.uc[1],
+		                   (unsigned int) du1.uc[2],
+		                   (unsigned int) du1.uc[3],
+		                   (unsigned int) du1.uc[4],
+		                   (unsigned int) du1.uc[5],
+		                   (unsigned int) du1.uc[6],
+		                   (unsigned int) du1.uc[7],
+		                   (unsigned int) du2.uc[0],
+		                   (unsigned int) du2.uc[1],
+		                   (unsigned int) du2.uc[2],
+		                   (unsigned int) du2.uc[3],
+		                   (unsigned int) du2.uc[4],
+		                   (unsigned int) du2.uc[5],
+		                   (unsigned int) du2.uc[6],
+		                   (unsigned int) du2.uc[7]));
 
 		if (duk_memcmp((const void *) du1.uc, (const void *) du2.uc, sizeof(du1.uc)) == 0) {
 			duk_debug_write_int(thr, i32);
 		} else {
 			DUK_DBLUNION_DOUBLE_HTON(&du1);
 			duk_debug_write_byte(thr, DUK_DBG_IB_NUMBER);
 			duk_debug_write_bytes(thr, (const duk_uint8_t *) du1.uc, sizeof(du1.uc));
@@ -46161,21 +47165,21 @@
 	if (DUK_TVAL_IS_HEAP_ALLOCATED(tv)) {
 		duk_heaphdr *h = DUK_TVAL_GET_HEAPHDR(tv);
 		duk_debug_write_heapptr(thr, h);
 	} else {
 		duk_debug_write_tval(thr, tv);
 	}
 }
-#endif  /* DUK_USE_DEBUGGER_DUMPHEAP */
+#endif /* DUK_USE_DEBUGGER_DUMPHEAP */
 
 /*
  *  Debug connection message write helpers
  */
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_INTERNAL void duk_debug_write_request(duk_hthread *thr, duk_small_uint_t command) {
 	duk_debug_write_byte(thr, DUK_DBG_IB_REQUEST);
 	duk_debug_write_int(thr, command);
 }
 #endif
 
 DUK_INTERNAL void duk_debug_write_reply(duk_hthread *thr) {
@@ -46270,15 +47274,15 @@
 	/*
 	 *  NFY <int: 5> <int: fatal> <str: msg> <str: filename> <int: linenumber> EOM
 	 */
 
 	duk_activation *act;
 	duk_uint32_t pc;
 
-	DUK_ASSERT(thr->valstack_top > thr->valstack);  /* At least: ... [err] */
+	DUK_ASSERT(thr->valstack_top > thr->valstack); /* At least: ... [err] */
 
 	duk_debug_write_notify(thr, DUK_DBG_CMD_THROW);
 	duk_debug_write_int(thr, (duk_int32_t) fatal);
 
 	/* Report thrown value to client coerced to string */
 	duk_dup_top(thr);
 	duk__debug_write_hstring_safe_top(thr);
@@ -46311,15 +47315,15 @@
 			duk_debug_write_cstring(thr, "");
 			duk_debug_write_uint(thr, 0);
 		}
 	}
 
 	duk_debug_write_eom(thr);
 }
-#endif  /* DUK_USE_DEBUGGER_THROW_NOTIFY */
+#endif /* DUK_USE_DEBUGGER_THROW_NOTIFY */
 
 /*
  *  Debug message processing
  */
 
 /* Skip dvalue. */
 DUK_LOCAL duk_bool_t duk__debug_skip_dvalue(duk_hthread *thr) {
@@ -46335,17 +47339,17 @@
 	if (x >= 0x80) {
 		return 0;
 	}
 	if (x >= 0x60) {
 		duk_debug_skip_bytes(thr, (duk_size_t) (x - 0x60));
 		return 0;
 	}
-	switch(x) {
+	switch (x) {
 	case DUK_DBG_IB_EOM:
-		return 1;  /* Return 1: got EOM */
+		return 1; /* Return 1: got EOM */
 	case DUK_DBG_IB_REQUEST:
 	case DUK_DBG_IB_REPLY:
 	case DUK_DBG_IB_ERROR:
 	case DUK_DBG_IB_NOTIFY:
 		break;
 	case DUK_DBG_IB_INT4:
 		(void) duk__debug_read_uint32_raw(thr);
@@ -46386,17 +47390,17 @@
 		break;
 	default:
 		goto fail;
 	}
 
 	return 0;
 
- fail:
+fail:
 	DUK__SET_CONN_BROKEN(thr, 1);
-	return 1;  /* Pretend like we got EOM */
+	return 1; /* Pretend like we got EOM */
 }
 
 /* Skip dvalues to EOM. */
 DUK_LOCAL void duk__debug_skip_to_eom(duk_hthread *thr) {
 	for (;;) {
 		if (duk__debug_skip_dvalue(thr)) {
 			break;
@@ -46408,15 +47412,15 @@
  * error message and return zero.
  */
 DUK_LOCAL duk_int32_t duk__debug_read_validate_csindex(duk_hthread *thr) {
 	duk_int32_t level;
 	level = duk_debug_read_int(thr);
 	if (level >= 0 || -level > (duk_int32_t) thr->callstack_top) {
 		duk_debug_write_error_eom(thr, DUK_DBG_ERR_NOTFOUND, "invalid callstack index");
-		return 0;  /* zero indicates failure */
+		return 0; /* zero indicates failure */
 	}
 	return level;
 }
 
 /* Read a call stack index and lookup the corresponding duk_activation.
  * If index is invalid, write out an error message and return NULL.
  */
@@ -46477,15 +47481,15 @@
 	duk_small_uint_t pause_flags;
 
 	DUK_D(DUK_DPRINT("debug command Resume"));
 
 	duk_debug_clear_paused(heap);
 
 	pause_flags = 0;
-#if 0  /* manual testing */
+#if 0 /* manual testing */
 	pause_flags |= DUK_PAUSE_FLAG_ONE_OPCODE;
 	pause_flags |= DUK_PAUSE_FLAG_CAUGHT_ERROR;
 	pause_flags |= DUK_PAUSE_FLAG_UNCAUGHT_ERROR;
 #endif
 #if defined(DUK_USE_DEBUGGER_PAUSE_UNCAUGHT)
 	pause_flags |= DUK_PAUSE_FLAG_UNCAUGHT_ERROR;
 #endif
@@ -46498,20 +47502,17 @@
 
 DUK_LOCAL void duk__debug_handle_step(duk_hthread *thr, duk_heap *heap, duk_int32_t cmd) {
 	duk_small_uint_t pause_flags;
 
 	DUK_D(DUK_DPRINT("debug command StepInto/StepOver/StepOut: %d", (int) cmd));
 
 	if (cmd == DUK_DBG_CMD_STEPINTO) {
-		pause_flags = DUK_PAUSE_FLAG_LINE_CHANGE |
-		              DUK_PAUSE_FLAG_FUNC_ENTRY |
-		              DUK_PAUSE_FLAG_FUNC_EXIT;
+		pause_flags = DUK_PAUSE_FLAG_LINE_CHANGE | DUK_PAUSE_FLAG_FUNC_ENTRY | DUK_PAUSE_FLAG_FUNC_EXIT;
 	} else if (cmd == DUK_DBG_CMD_STEPOVER) {
-		pause_flags = DUK_PAUSE_FLAG_LINE_CHANGE |
-		              DUK_PAUSE_FLAG_FUNC_EXIT;
+		pause_flags = DUK_PAUSE_FLAG_LINE_CHANGE | DUK_PAUSE_FLAG_FUNC_EXIT;
 	} else {
 		DUK_ASSERT(cmd == DUK_DBG_CMD_STEPOUT);
 		pause_flags = DUK_PAUSE_FLAG_FUNC_EXIT;
 	}
 #if defined(DUK_USE_DEBUGGER_PAUSE_UNCAUGHT)
 	pause_flags |= DUK_PAUSE_FLAG_UNCAUGHT_ERROR;
 #endif
@@ -46582,15 +47583,15 @@
 	DUK_UNREF(heap);
 	DUK_D(DUK_DPRINT("debug command GetVar"));
 
 	act = duk__debug_read_level_get_activation(thr);
 	if (act == NULL) {
 		return;
 	}
-	str = duk_debug_read_hstring(thr);  /* push to stack */
+	str = duk_debug_read_hstring(thr); /* push to stack */
 	DUK_ASSERT(str != NULL);
 
 	rc = duk_js_getvar_activation(thr, act, str, 0);
 
 	duk_debug_write_reply(thr);
 	if (rc) {
 		duk_debug_write_int(thr, 1);
@@ -46611,15 +47612,15 @@
 	DUK_UNREF(heap);
 	DUK_D(DUK_DPRINT("debug command PutVar"));
 
 	act = duk__debug_read_level_get_activation(thr);
 	if (act == NULL) {
 		return;
 	}
-	str = duk_debug_read_hstring(thr);  /* push to stack */
+	str = duk_debug_read_hstring(thr); /* push to stack */
 	DUK_ASSERT(str != NULL);
 	tv = duk_debug_read_tval(thr);
 	if (tv == NULL) {
 		/* detached */
 		return;
 	}
 
@@ -46709,15 +47710,15 @@
 			while (duk_next(thr, -1 /*enum_index*/, 0 /*get_value*/)) {
 				varname = duk_known_hstring(thr, -1);
 
 				duk_js_getvar_activation(thr, act, varname, 0 /*throw_flag*/);
 				/* [ ... func varmap enum key value this ] */
 				duk_debug_write_hstring(thr, duk_get_hstring(thr, -3));
 				duk_debug_write_tval(thr, duk_get_tval(thr, -2));
-				duk_pop_3(thr);  /* -> [ ... func varmap enum ] */
+				duk_pop_3(thr); /* -> [ ... func varmap enum ] */
 			}
 		} else {
 			DUK_D(DUK_DPRINT("varmap missing in GetLocals, ignore"));
 		}
 	} else {
 		DUK_D(DUK_DPRINT("varmap is not an object in GetLocals, ignore"));
 	}
@@ -46744,35 +47745,34 @@
 	 * Callstack index for debug commands only affects scope -- the callstack
 	 * as seen by, e.g. Duktape.act() will be the same regardless.
 	 */
 
 	/* nargs == 2 so we can pass a callstack index to eval(). */
 	idx_func = duk_get_top(thr);
 	duk_push_c_function(thr, duk_bi_global_object_eval, 2 /*nargs*/);
-	duk_push_undefined(thr);  /* 'this' binding shouldn't matter here */
+	duk_push_undefined(thr); /* 'this' binding shouldn't matter here */
 
 	/* Read callstack index, if non-null. */
 	if (duk_debug_peek_byte(thr) == DUK_DBG_IB_NULL) {
 		direct_eval = 0;
-		level = -1;  /* Not needed, but silences warning. */
+		level = -1; /* Not needed, but silences warning. */
 		(void) duk_debug_read_byte(thr);
 	} else {
 		direct_eval = 1;
 		level = duk__debug_read_validate_csindex(thr);
 		if (level == 0) {
 			return;
 		}
 	}
 
-	DUK_ASSERT(!direct_eval ||
-	           (level < 0 && -level <= (duk_int32_t) thr->callstack_top));
+	DUK_ASSERT(!direct_eval || (level < 0 && -level <= (duk_int32_t) thr->callstack_top));
 
 	(void) duk_debug_read_hstring(thr);
 	if (direct_eval) {
-		duk_push_int(thr, level - 1);  /* compensate for eval() call */
+		duk_push_int(thr, level - 1); /* compensate for eval() call */
 	}
 
 	/* [ ... eval "eval" eval_input level? ] */
 
 	call_flags = 0;
 	if (direct_eval) {
 		duk_activation *act;
@@ -46819,23 +47819,23 @@
 	DUK_UNREF(heap);
 	DUK_D(DUK_DPRINT("debug command Detach"));
 
 	duk_debug_write_reply(thr);
 	duk_debug_write_eom(thr);
 
 	DUK_D(DUK_DPRINT("debug connection detached, mark broken"));
-	DUK__SET_CONN_BROKEN(thr, 0);  /* not an error */
+	DUK__SET_CONN_BROKEN(thr, 0); /* not an error */
 }
 
 DUK_LOCAL void duk__debug_handle_apprequest(duk_hthread *thr, duk_heap *heap) {
 	duk_idx_t old_top;
 
 	DUK_D(DUK_DPRINT("debug command AppRequest"));
 
-	old_top = duk_get_top(thr);  /* save stack top */
+	old_top = duk_get_top(thr); /* save stack top */
 
 	if (heap->dbg_request_cb != NULL) {
 		duk_idx_t nrets;
 		duk_idx_t nvalues = 0;
 		duk_idx_t top, idx;
 
 		/* Read tvals from the message and push them onto the valstack,
@@ -46843,36 +47843,43 @@
 		 */
 		while (duk_debug_peek_byte(thr) != DUK_DBG_IB_EOM) {
 			duk_tval *tv;
 			if (!duk_check_stack(thr, 1)) {
 				DUK_D(DUK_DPRINT("failed to allocate space for request dvalue(s)"));
 				goto fail;
 			}
-			tv = duk_debug_read_tval(thr);  /* push to stack */
+			tv = duk_debug_read_tval(thr); /* push to stack */
 			if (tv == NULL) {
 				/* detached */
 				return;
 			}
 			nvalues++;
 		}
 		DUK_ASSERT(duk_get_top(thr) == old_top + nvalues);
 
 		/* Request callback should push values for reply to client onto valstack */
 		DUK_D(DUK_DPRINT("calling into AppRequest request_cb with nvalues=%ld, old_top=%ld, top=%ld",
-		                 (long) nvalues, (long) old_top, (long) duk_get_top(thr)));
+		                 (long) nvalues,
+		                 (long) old_top,
+		                 (long) duk_get_top(thr)));
 		nrets = heap->dbg_request_cb(thr, heap->dbg_udata, nvalues);
 		DUK_D(DUK_DPRINT("returned from AppRequest request_cb; nvalues=%ld -> nrets=%ld, old_top=%ld, top=%ld",
-		                 (long) nvalues, (long) nrets, (long) old_top, (long) duk_get_top(thr)));
+		                 (long) nvalues,
+		                 (long) nrets,
+		                 (long) old_top,
+		                 (long) duk_get_top(thr)));
 		if (nrets >= 0) {
 			DUK_ASSERT(duk_get_top(thr) >= old_top + nrets);
 			if (duk_get_top(thr) < old_top + nrets) {
 				DUK_D(DUK_DPRINT("AppRequest callback doesn't match value stack configuration, "
 				                 "top=%ld < old_top=%ld + nrets=%ld; "
 				                 "this might mean it's unsafe to continue!",
-				                 (long) duk_get_top(thr), (long) old_top, (long) nrets));
+				                 (long) duk_get_top(thr),
+				                 (long) old_top,
+				                 (long) nrets));
 				goto fail;
 			}
 
 			/* Reply with tvals pushed by request callback */
 			duk_debug_write_byte(thr, DUK_DBG_IB_REPLY);
 			top = duk_get_top(thr);
 			for (idx = top - nrets; idx < top; idx++) {
@@ -46884,24 +47891,24 @@
 			if (duk_get_top(thr) < old_top + 1) {
 				DUK_D(DUK_DPRINT("request callback return value doesn't match value stack configuration"));
 				goto fail;
 			}
 			duk_debug_write_error_eom(thr, DUK_DBG_ERR_APPLICATION, duk_get_string(thr, -1));
 		}
 
-		duk_set_top(thr, old_top);  /* restore stack top */
+		duk_set_top(thr, old_top); /* restore stack top */
 	} else {
 		DUK_D(DUK_DPRINT("no request callback, treat AppRequest as unsupported"));
 		duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNSUPPORTED, "AppRequest unsupported by target");
 	}
 
 	return;
 
- fail:
-	duk_set_top(thr, old_top);  /* restore stack top */
+fail:
+	duk_set_top(thr, old_top); /* restore stack top */
 	DUK__SET_CONN_BROKEN(thr, 1);
 }
 
 /*
  *  DumpHeap command
  */
 
@@ -46944,24 +47951,24 @@
 		duk_debug_write_uint(thr, (duk_uint32_t) DUK_HOBJECT_GET_HSIZE(h));
 
 		for (i = 0; i < (duk_uint_fast32_t) DUK_HOBJECT_GET_ENEXT(h); i++) {
 			duk_debug_write_uint(thr, (duk_uint32_t) DUK_HOBJECT_E_GET_FLAGS(heap, h, i));
 			k = DUK_HOBJECT_E_GET_KEY(heap, h, i);
 			duk_debug_write_heapptr(thr, (duk_heaphdr *) k);
 			if (k == NULL) {
-				duk_debug_write_int(thr, 0);  /* isAccessor */
+				duk_debug_write_int(thr, 0); /* isAccessor */
 				duk_debug_write_unused(thr);
 				continue;
 			}
 			if (DUK_HOBJECT_E_SLOT_IS_ACCESSOR(heap, h, i)) {
-				duk_debug_write_int(thr, 1);  /* isAccessor */
+				duk_debug_write_int(thr, 1); /* isAccessor */
 				duk_debug_write_heapptr(thr, (duk_heaphdr *) DUK_HOBJECT_E_GET_VALUE_PTR(heap, h, i)->a.get);
 				duk_debug_write_heapptr(thr, (duk_heaphdr *) DUK_HOBJECT_E_GET_VALUE_PTR(heap, h, i)->a.set);
 			} else {
-				duk_debug_write_int(thr, 0);  /* isAccessor */
+				duk_debug_write_int(thr, 0); /* isAccessor */
 
 				duk__debug_write_tval_heapptr(thr, &DUK_HOBJECT_E_GET_VALUE_PTR(heap, h, i)->v);
 			}
 		}
 
 		for (i = 0; i < (duk_uint_fast32_t) DUK_HOBJECT_GET_ASIZE(h); i++) {
 			/* Note: array dump will include elements beyond
@@ -47015,15 +48022,15 @@
 	DUK_D(DUK_DPRINT("debug command DumpHeap"));
 
 	duk_debug_write_reply(thr);
 	duk__debug_dump_heap_allocated(thr, heap);
 	duk__debug_dump_strtab(thr, heap);
 	duk_debug_write_eom(thr);
 }
-#endif  /* DUK_USE_DEBUGGER_DUMPHEAP */
+#endif /* DUK_USE_DEBUGGER_DUMPHEAP */
 
 DUK_LOCAL void duk__debug_handle_get_bytecode(duk_hthread *thr, duk_heap *heap) {
 	duk_activation *act;
 	duk_hcompfunc *fun = NULL;
 	duk_size_t i, n;
 	duk_tval *tv;
 	duk_hobject **fn;
@@ -47084,19 +48091,19 @@
 	}
 	duk_debug_write_string(thr,
 	                       (const char *) DUK_HCOMPFUNC_GET_CODE_BASE(heap, fun),
 	                       (duk_size_t) DUK_HCOMPFUNC_GET_CODE_SIZE(heap, fun));
 	duk_debug_write_eom(thr);
 	return;
 
- fail_args:
+fail_args:
 	duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNKNOWN, "invalid argument");
 	return;
 
- fail_index:
+fail_index:
 	duk_debug_write_error_eom(thr, DUK_DBG_ERR_NOTFOUND, "invalid callstack index");
 	return;
 }
 
 /*
  *  Object inspection commands: GetHeapObjInfo, GetObjPropDesc,
  *  GetObjPropDescRange
@@ -47140,71 +48147,40 @@
 	DUK_HSTRING_FLAG_SYMBOL,
 	DUK_HSTRING_FLAG_HIDDEN,
 	DUK_HSTRING_FLAG_RESERVED_WORD,
 	DUK_HSTRING_FLAG_STRICT_RESERVED_WORD,
 	DUK_HSTRING_FLAG_EVAL_OR_ARGUMENTS,
 #endif
 	DUK_HSTRING_FLAG_EXTDATA,
-	0  /* terminator */
+	0 /* terminator */
 };
 DUK_LOCAL const char * const duk__debug_getinfo_hobject_keys[] = {
-	"extensible",
-	"constructable",
-	"callable",
-	"boundfunc",
-	"compfunc",
-	"natfunc",
-	"bufobj",
-	"fastrefs",
-	"array_part",
-	"strict",
-	"notail",
-	"newenv",
-	"namebinding",
-	"createargs",
-	"have_finalizer",
-	"exotic_array",
-	"exotic_stringobj",
-	"exotic_arguments",
-	"exotic_proxyobj",
-	"special_call"
+	"extensible",     "constructable", "callable",         "boundfunc",        "compfunc",        "natfunc",     "bufobj",
+	"fastrefs",       "array_part",    "strict",           "notail",           "newenv",          "namebinding", "createargs",
+	"have_finalizer", "exotic_array",  "exotic_stringobj", "exotic_arguments", "exotic_proxyobj", "special_call"
 	/* NULL not needed here */
 };
 DUK_LOCAL duk_uint_t duk__debug_getinfo_hobject_masks[] = {
-	DUK_HOBJECT_FLAG_EXTENSIBLE,
-	DUK_HOBJECT_FLAG_CONSTRUCTABLE,
-	DUK_HOBJECT_FLAG_CALLABLE,
-	DUK_HOBJECT_FLAG_BOUNDFUNC,
-	DUK_HOBJECT_FLAG_COMPFUNC,
-	DUK_HOBJECT_FLAG_NATFUNC,
-	DUK_HOBJECT_FLAG_BUFOBJ,
-	DUK_HOBJECT_FLAG_FASTREFS,
-	DUK_HOBJECT_FLAG_ARRAY_PART,
-	DUK_HOBJECT_FLAG_STRICT,
-	DUK_HOBJECT_FLAG_NOTAIL,
-	DUK_HOBJECT_FLAG_NEWENV,
-	DUK_HOBJECT_FLAG_NAMEBINDING,
-	DUK_HOBJECT_FLAG_CREATEARGS,
-	DUK_HOBJECT_FLAG_HAVE_FINALIZER,
-	DUK_HOBJECT_FLAG_EXOTIC_ARRAY,
-	DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ,
-	DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS,
-	DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ,
-	DUK_HOBJECT_FLAG_SPECIAL_CALL,
-	0  /* terminator */
+	DUK_HOBJECT_FLAG_EXTENSIBLE,      DUK_HOBJECT_FLAG_CONSTRUCTABLE,    DUK_HOBJECT_FLAG_CALLABLE,
+	DUK_HOBJECT_FLAG_BOUNDFUNC,       DUK_HOBJECT_FLAG_COMPFUNC,         DUK_HOBJECT_FLAG_NATFUNC,
+	DUK_HOBJECT_FLAG_BUFOBJ,          DUK_HOBJECT_FLAG_FASTREFS,         DUK_HOBJECT_FLAG_ARRAY_PART,
+	DUK_HOBJECT_FLAG_STRICT,          DUK_HOBJECT_FLAG_NOTAIL,           DUK_HOBJECT_FLAG_NEWENV,
+	DUK_HOBJECT_FLAG_NAMEBINDING,     DUK_HOBJECT_FLAG_CREATEARGS,       DUK_HOBJECT_FLAG_HAVE_FINALIZER,
+	DUK_HOBJECT_FLAG_EXOTIC_ARRAY,    DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ, DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS,
+	DUK_HOBJECT_FLAG_EXOTIC_PROXYOBJ, DUK_HOBJECT_FLAG_SPECIAL_CALL,     0 /* terminator */
 };
 DUK_LOCAL const char * const duk__debug_getinfo_hbuffer_keys[] = {
 	"dynamic",
 	"external"
 	/* NULL not needed here */
 };
 DUK_LOCAL duk_uint_t duk__debug_getinfo_hbuffer_masks[] = {
 	DUK_HBUFFER_FLAG_DYNAMIC,
 	DUK_HBUFFER_FLAG_EXTERNAL,
-	0  /* terminator */
+	0 /* terminator */
 };
 
 DUK_LOCAL void duk__debug_getinfo_flags_key(duk_hthread *thr, const char *key) {
 	duk_debug_write_uint(thr, 0);
 	duk_debug_write_cstring(thr, key);
 }
 
@@ -47222,27 +48198,30 @@
 
 DUK_LOCAL void duk__debug_getinfo_prop_bool(duk_hthread *thr, const char *key, duk_bool_t val) {
 	duk_debug_write_uint(thr, 0);
 	duk_debug_write_cstring(thr, key);
 	duk_debug_write_boolean(thr, val);
 }
 
-DUK_LOCAL void duk__debug_getinfo_bitmask(duk_hthread *thr, const char * const * keys, duk_uint_t *masks, duk_uint_t flags) {
+DUK_LOCAL void duk__debug_getinfo_bitmask(duk_hthread *thr, const char * const *keys, duk_uint_t *masks, duk_uint_t flags) {
 	const char *key;
 	duk_uint_t mask;
 
 	for (;;) {
 		mask = *masks++;
 		if (mask == 0) {
 			break;
 		}
 		key = *keys++;
 		DUK_ASSERT(key != NULL);
 
-		DUK_DD(DUK_DDPRINT("inspect bitmask: key=%s, mask=0x%08lx, flags=0x%08lx", key, (unsigned long) mask, (unsigned long) flags));
+		DUK_DD(DUK_DDPRINT("inspect bitmask: key=%s, mask=0x%08lx, flags=0x%08lx",
+		                   key,
+		                   (unsigned long) mask,
+		                   (unsigned long) flags));
 		duk__debug_getinfo_prop_bool(thr, key, flags & mask);
 	}
 }
 
 /* Inspect a property using a virtual index into a conceptual property list
  * consisting of (1) all array part items from [0,a_size[ (even when above
  * .length) and (2) all entry part items from [0,e_next[.  Unused slots are
@@ -47310,17 +48289,20 @@
 
 DUK_LOCAL void duk__debug_handle_get_heap_obj_info(duk_hthread *thr, duk_heap *heap) {
 	duk_heaphdr *h;
 
 	DUK_D(DUK_DPRINT("debug command GetHeapObjInfo"));
 	DUK_UNREF(heap);
 
-	DUK_ASSERT(sizeof(duk__debug_getinfo_hstring_keys) / sizeof(const char *) == sizeof(duk__debug_getinfo_hstring_masks) / sizeof(duk_uint_t) - 1);
-	DUK_ASSERT(sizeof(duk__debug_getinfo_hobject_keys) / sizeof(const char *) == sizeof(duk__debug_getinfo_hobject_masks) / sizeof(duk_uint_t) - 1);
-	DUK_ASSERT(sizeof(duk__debug_getinfo_hbuffer_keys) / sizeof(const char *) == sizeof(duk__debug_getinfo_hbuffer_masks) / sizeof(duk_uint_t) - 1);
+	DUK_ASSERT(sizeof(duk__debug_getinfo_hstring_keys) / sizeof(const char *) ==
+	           sizeof(duk__debug_getinfo_hstring_masks) / sizeof(duk_uint_t) - 1);
+	DUK_ASSERT(sizeof(duk__debug_getinfo_hobject_keys) / sizeof(const char *) ==
+	           sizeof(duk__debug_getinfo_hobject_masks) / sizeof(duk_uint_t) - 1);
+	DUK_ASSERT(sizeof(duk__debug_getinfo_hbuffer_keys) / sizeof(const char *) ==
+	           sizeof(duk__debug_getinfo_hbuffer_masks) / sizeof(duk_uint_t) - 1);
 
 	h = duk_debug_read_any_ptr(thr);
 	if (!h) {
 		duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNKNOWN, "invalid target");
 		return;
 	}
 
@@ -47500,30 +48482,30 @@
 			duk__debug_getinfo_prop_uint(thr, "elem_type", (duk_uint_t) h_bufobj->elem_type);
 			duk__debug_getinfo_prop_bool(thr, "is_typedarray", (duk_uint_t) h_bufobj->is_typedarray);
 			if (h_bufobj->buf != NULL) {
 				duk__debug_getinfo_flags_key(thr, "buffer");
 				duk_debug_write_heapptr(thr, (duk_heaphdr *) h_bufobj->buf);
 			}
 		}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 		break;
 	}
 	case DUK_HTYPE_BUFFER: {
 		duk_hbuffer *h_buf;
 
 		h_buf = (duk_hbuffer *) h;
 		duk__debug_getinfo_bitmask(thr,
 		                           duk__debug_getinfo_hbuffer_keys,
 		                           duk__debug_getinfo_hbuffer_masks,
 		                           DUK_HEAPHDR_GET_FLAGS_RAW(h));
 		duk__debug_getinfo_prop_uint(thr, "size", (duk_uint_t) DUK_HBUFFER_GET_SIZE(h_buf));
 		duk__debug_getinfo_flags_key(thr, "dataptr");
 		duk_debug_write_pointer(thr, (void *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_buf));
 		duk__debug_getinfo_flags_key(thr, "data");
-		duk_debug_write_hbuffer(thr, h_buf);  /* tolerates NULL h_buf */
+		duk_debug_write_hbuffer(thr, h_buf); /* tolerates NULL h_buf */
 		break;
 	}
 	default: {
 		/* Since we already started writing the reply, just emit nothing. */
 		DUK_D(DUK_DPRINT("inspect target pointer has invalid heaphdr type"));
 	}
 	}
@@ -47553,28 +48535,27 @@
 
 	if (duk_hobject_get_own_propdesc(thr, h_obj, h_key, &desc, 0 /*flags*/)) {
 		duk_int_t virtual_idx;
 		duk_bool_t rc;
 
 		/* To use the shared helper need the virtual index. */
 		DUK_ASSERT(desc.e_idx >= 0 || desc.a_idx >= 0);
-		virtual_idx = (desc.a_idx >= 0 ? desc.a_idx :
-		               (duk_int_t) DUK_HOBJECT_GET_ASIZE(h_obj) + desc.e_idx);
+		virtual_idx = (desc.a_idx >= 0 ? desc.a_idx : (duk_int_t) DUK_HOBJECT_GET_ASIZE(h_obj) + desc.e_idx);
 
 		duk_debug_write_reply(thr);
 		rc = duk__debug_getprop_index(thr, heap, h_obj, (duk_uint_t) virtual_idx);
 		DUK_ASSERT(rc == 1);
 		DUK_UNREF(rc);
 		duk_debug_write_eom(thr);
 	} else {
 		duk_debug_write_error_eom(thr, DUK_DBG_ERR_NOTFOUND, "not found");
 	}
 	return;
 
- fail_args:
+fail_args:
 	duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNKNOWN, "invalid args");
 }
 
 DUK_LOCAL void duk__debug_handle_get_obj_prop_desc_range(duk_hthread *thr, duk_heap *heap) {
 	duk_heaphdr *h;
 	duk_hobject *h_obj;
 	duk_uint_t idx, idx_start, idx_end;
@@ -47602,19 +48583,19 @@
 		if (!duk__debug_getprop_index(thr, heap, h_obj, idx)) {
 			break;
 		}
 	}
 	duk_debug_write_eom(thr);
 	return;
 
- fail_args:
+fail_args:
 	duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNKNOWN, "invalid args");
 }
 
-#endif  /* DUK_USE_DEBUGGER_INSPECT */
+#endif /* DUK_USE_DEBUGGER_INSPECT */
 
 /*
  *  Process incoming debug requests
  *
  *  Individual request handlers can push temporaries on the value stack and
  *  rely on duk__debug_process_message() to restore the value stack top
  *  automatically.
@@ -47704,15 +48685,15 @@
 			break;
 		}
 #if defined(DUK_USE_DEBUGGER_DUMPHEAP)
 		case DUK_DBG_CMD_DUMPHEAP: {
 			duk__debug_handle_dump_heap(thr, heap);
 			break;
 		}
-#endif  /* DUK_USE_DEBUGGER_DUMPHEAP */
+#endif /* DUK_USE_DEBUGGER_DUMPHEAP */
 		case DUK_DBG_CMD_GETBYTECODE: {
 			duk__debug_handle_get_bytecode(thr, heap);
 			break;
 		}
 		case DUK_DBG_CMD_APPREQUEST: {
 			duk__debug_handle_apprequest(thr, heap);
 			break;
@@ -47726,20 +48707,20 @@
 			duk__debug_handle_get_obj_prop_desc(thr, heap);
 			break;
 		}
 		case DUK_DBG_CMD_GETOBJPROPDESCRANGE: {
 			duk__debug_handle_get_obj_prop_desc_range(thr, heap);
 			break;
 		}
-#endif  /* DUK_USE_DEBUGGER_INSPECT */
+#endif /* DUK_USE_DEBUGGER_INSPECT */
 		default: {
 			DUK_D(DUK_DPRINT("debug command unsupported: %d", (int) cmd));
 			duk_debug_write_error_eom(thr, DUK_DBG_ERR_UNSUPPORTED, "unsupported command");
 		}
-		}  /* switch cmd */
+		} /* switch cmd */
 		break;
 	}
 	case DUK_DBG_IB_REPLY: {
 		DUK_D(DUK_DPRINT("debug reply, skipping"));
 		break;
 	}
 	case DUK_DBG_IB_ERROR: {
@@ -47750,22 +48731,22 @@
 		DUK_D(DUK_DPRINT("debug notify, skipping"));
 		break;
 	}
 	default: {
 		DUK_D(DUK_DPRINT("invalid initial byte, drop connection: %d", (int) x));
 		goto fail;
 	}
-	}  /* switch initial byte */
+	} /* switch initial byte */
 
 	DUK_ASSERT(duk_get_top(thr) >= entry_top);
 	duk_set_top(thr, entry_top);
 	duk__debug_skip_to_eom(thr);
 	return;
 
- fail:
+fail:
 	DUK_ASSERT(duk_get_top(thr) >= entry_top);
 	duk_set_top(thr, entry_top);
 	DUK__SET_CONN_BROKEN(thr, 1);
 	return;
 }
 
 DUK_LOCAL void duk__check_resend_status(duk_hthread *thr) {
@@ -47784,16 +48765,18 @@
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 #if defined(DUK_USE_ASSERTIONS)
 	entry_top = duk_get_top(thr);
 #endif
 
 	DUK_D(DUK_DPRINT("process debug messages: read_cb=%s, no_block=%ld, detaching=%ld, processing=%ld",
-	                 thr->heap->dbg_read_cb ? "not NULL" : "NULL", (long) no_block,
-	                 (long) thr->heap->dbg_detaching, (long) thr->heap->dbg_processing));
+	                 thr->heap->dbg_read_cb ? "not NULL" : "NULL",
+	                 (long) no_block,
+	                 (long) thr->heap->dbg_detaching,
+	                 (long) thr->heap->dbg_processing));
 	DUK_DD(DUK_DDPRINT("top at entry: %ld", (long) duk_get_top(thr)));
 
 	/* thr->heap->dbg_detaching may be != 0 if a debugger write outside
 	 * the message loop caused a transport error and detach1() to run.
 	 */
 	DUK_ASSERT(thr->heap->dbg_detaching == 0 || thr->heap->dbg_detaching == 1);
 	DUK_ASSERT(thr->heap->dbg_processing == 0);
@@ -47832,21 +48815,22 @@
 			 * re-attached; duk_debugger_attach() sets dbg_processing
 			 * to 0 at the moment.
 			 */
 
 			DUK_D(DUK_DPRINT("detach pending (dbg_read_cb == NULL, dbg_detaching != 0), call detach2"));
 
 			duk__debug_do_detach2(thr->heap);
-			thr->heap->dbg_processing = 1;  /* may be set to 0 by duk_debugger_attach() inside callback */
+			thr->heap->dbg_processing = 1; /* may be set to 0 by duk_debugger_attach() inside callback */
 
 			DUK_D(DUK_DPRINT("after detach2 (and possible reattach): dbg_read_cb=%s, dbg_detaching=%ld",
-			                 thr->heap->dbg_read_cb ? "not NULL" : "NULL", (long) thr->heap->dbg_detaching));
+			                 thr->heap->dbg_read_cb ? "not NULL" : "NULL",
+			                 (long) thr->heap->dbg_detaching));
 		}
-		DUK_ASSERT(thr->heap->dbg_detaching == 0);  /* true even with reattach */
-		DUK_ASSERT(thr->heap->dbg_processing == 1);  /* even after a detach and possible reattach */
+		DUK_ASSERT(thr->heap->dbg_detaching == 0); /* true even with reattach */
+		DUK_ASSERT(thr->heap->dbg_processing == 1); /* even after a detach and possible reattach */
 
 		if (thr->heap->dbg_read_cb == NULL) {
 			DUK_D(DUK_DPRINT("debug connection broken (and not detaching), stop processing messages"));
 			break;
 		}
 
 		if (!DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap) || no_block) {
@@ -47863,25 +48847,25 @@
 			DUK_D(DUK_DPRINT("paused, process debug message, blocking if necessary"));
 		}
 
 		duk__check_resend_status(thr);
 		duk__debug_process_message(thr);
 		duk__check_resend_status(thr);
 
-		retval = 1;  /* processed one or more messages */
+		retval = 1; /* processed one or more messages */
 	}
 
 	DUK_ASSERT(thr->heap->dbg_detaching == 0);
 	DUK_ASSERT(thr->heap->dbg_processing == 1);
 	thr->heap->dbg_processing = 0;
 
 	/* As an initial implementation, read flush after exiting the message
 	 * loop.  If transport is broken, this is a no-op (with debug logs).
 	 */
-	duk_debug_read_flush(thr);  /* this cannot initiate a detach */
+	duk_debug_read_flush(thr); /* this cannot initiate a detach */
 	DUK_ASSERT(thr->heap->dbg_detaching == 0);
 
 	DUK_DD(DUK_DDPRINT("top at exit: %ld", (long) duk_get_top(thr)));
 
 #if defined(DUK_USE_ASSERTIONS)
 	/* Easy to get wrong, so assert for it. */
 	DUK_ASSERT(entry_top == duk_get_top(thr));
@@ -47924,19 +48908,16 @@
 		duk_hthread_sync_currpc(thr);
 		old_pc = act->curr_pc;
 		fun = (duk_hcompfunc *) DUK_ACT_GET_FUNC(act);
 
 		/* Short circuit if is safe: if act->curr_pc != NULL, 'fun' is
 		 * guaranteed to be a non-NULL ECMAScript function.
 		 */
-		DUK_ASSERT(act->curr_pc == NULL ||
-		           (fun != NULL && DUK_HOBJECT_IS_COMPFUNC((duk_hobject *) fun)));
-		if (use_prev_pc &&
-		    act->curr_pc != NULL &&
-		    act->curr_pc > DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, fun)) {
+		DUK_ASSERT(act->curr_pc == NULL || (fun != NULL && DUK_HOBJECT_IS_COMPFUNC((duk_hobject *) fun)));
+		if (use_prev_pc && act->curr_pc != NULL && act->curr_pc > DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, fun)) {
 			act->curr_pc--;
 		}
 	}
 
 	/* Process debug messages until we are no longer paused. */
 
 	/* NOTE: This is a bit fragile.  It's important to ensure that
@@ -47955,15 +48936,15 @@
 	 * debugger message loop gains the ability to adjust the current PC
 	 * (e.g. a forced jump) restoring the PC here will break.  Another
 	 * approach would be to use a state flag for the "decrement 1 from
 	 * topmost activation's PC" and take it into account whenever dealing
 	 * with PC values.
 	 */
 	if (act != NULL) {
-		act->curr_pc = old_pc;  /* restore PC */
+		act->curr_pc = old_pc; /* restore PC */
 	}
 }
 
 /*
  *  Breakpoint management
  */
 
@@ -47979,24 +48960,25 @@
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(filename != NULL);
 	heap = thr->heap;
 	DUK_ASSERT(heap != NULL);
 
 	if (heap->dbg_breakpoint_count >= DUK_HEAP_MAX_BREAKPOINTS) {
 		DUK_D(DUK_DPRINT("failed to add breakpoint for %O:%ld, all breakpoint slots used",
-		                 (duk_heaphdr *) filename, (long) line));
+		                 (duk_heaphdr *) filename,
+		                 (long) line));
 		return -1;
 	}
 	heap->dbg_breakpoints_active[0] = (duk_breakpoint *) NULL;
 	b = heap->dbg_breakpoints + (heap->dbg_breakpoint_count++);
 	b->filename = filename;
 	b->line = line;
 	DUK_HSTRING_INCREF(thr, filename);
 
-	return (duk_small_int_t) (heap->dbg_breakpoint_count - 1);  /* index */
+	return (duk_small_int_t) (heap->dbg_breakpoint_count - 1); /* index */
 }
 
 DUK_INTERNAL duk_bool_t duk_debug_remove_breakpoint(duk_hthread *thr, duk_small_uint_t breakpoint_index) {
 	duk_heap *heap;
 	duk_hstring *h;
 	duk_breakpoint *b;
 	duk_size_t move_size;
@@ -48006,35 +48988,33 @@
 	 * active breakpoint list here.
 	 */
 
 	DUK_ASSERT(thr != NULL);
 	heap = thr->heap;
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(duk_debug_is_attached(thr->heap));
-	DUK_ASSERT_DISABLE(breakpoint_index >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(breakpoint_index >= 0); /* unsigned */
 
 	if (breakpoint_index >= heap->dbg_breakpoint_count) {
 		DUK_D(DUK_DPRINT("invalid breakpoint index: %ld", (long) breakpoint_index));
 		return 0;
 	}
 	b = heap->dbg_breakpoints + breakpoint_index;
 
 	h = b->filename;
 	DUK_ASSERT(h != NULL);
 
 	move_size = sizeof(duk_breakpoint) * (heap->dbg_breakpoint_count - breakpoint_index - 1);
-	duk_memmove((void *) b,
-	            (const void *) (b + 1),
-	            (size_t) move_size);
+	duk_memmove((void *) b, (const void *) (b + 1), (size_t) move_size);
 
 	heap->dbg_breakpoint_count--;
 	heap->dbg_breakpoints_active[0] = (duk_breakpoint *) NULL;
 
-	DUK_HSTRING_DECREF(thr, h);  /* side effects */
-	DUK_UNREF(h);  /* w/o refcounting */
+	DUK_HSTRING_DECREF(thr, h); /* side effects */
+	DUK_UNREF(h); /* w/o refcounting */
 
 	/* Breakpoint entries above the used area are left as garbage. */
 
 	return 1;
 }
 
 /*
@@ -48052,18 +49032,18 @@
 DUK_INTERNAL void duk_debug_set_paused(duk_heap *heap) {
 	if (duk_debug_is_paused(heap)) {
 		DUK_D(DUK_DPRINT("trying to set paused state when already paused, ignoring"));
 	} else {
 		DUK_HEAP_SET_DEBUGGER_PAUSED(heap);
 		heap->dbg_state_dirty = 1;
 		duk_debug_clear_pause_state(heap);
-		DUK_ASSERT(heap->ms_running == 0);  /* debugger can't be triggered within mark-and-sweep */
-		heap->ms_running = 2;  /* prevent mark-and-sweep, prevent refzero queueing */
+		DUK_ASSERT(heap->ms_running == 0); /* debugger can't be triggered within mark-and-sweep */
+		heap->ms_running = 2; /* prevent mark-and-sweep, prevent refzero queueing */
 		heap->ms_prevent_count++;
-		DUK_ASSERT(heap->ms_prevent_count != 0);  /* Wrap. */
+		DUK_ASSERT(heap->ms_prevent_count != 0); /* Wrap. */
 		DUK_ASSERT(heap->heap_thread != NULL);
 	}
 }
 
 DUK_INTERNAL void duk_debug_clear_paused(duk_heap *heap) {
 	if (duk_debug_is_paused(heap)) {
 		DUK_HEAP_CLEAR_DEBUGGER_PAUSED(heap);
@@ -48081,19 +49061,19 @@
 
 DUK_INTERNAL void duk_debug_clear_pause_state(duk_heap *heap) {
 	heap->dbg_pause_flags = 0;
 	heap->dbg_pause_act = NULL;
 	heap->dbg_pause_startline = 0;
 }
 
-#else  /* DUK_USE_DEBUGGER_SUPPORT */
+#else /* DUK_USE_DEBUGGER_SUPPORT */
 
 /* No debugger support. */
 
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__DBG_TPORT_ENTER
 #undef DUK__DBG_TPORT_EXIT
 #undef DUK__SET_CONN_BROKEN
 #line 1 "duk_error_augment.c"
 /*
@@ -48176,42 +49156,38 @@
 	 *  We must be careful of not triggering an error when looking up the
 	 *  property.  For instance, if the property is a getter, we don't want
 	 *  to call it, only plain values are allowed.  The value, if it exists,
 	 *  is not checked.  If the value is not a function, a TypeError happens
 	 *  when it is called and that error replaces the original one.
 	 */
 
-	DUK_ASSERT_VALSTACK_SPACE(thr, 4);  /* 3 entries actually needed below */
+	DUK_ASSERT_VALSTACK_SPACE(thr, 4); /* 3 entries actually needed below */
 
 	/* [ ... errval ] */
 
 	if (thr->builtins[DUK_BIDX_DUKTAPE] == NULL) {
 		/* When creating built-ins, some of the built-ins may not be set
 		 * and we want to tolerate that when throwing errors.
 		 */
 		DUK_DD(DUK_DDPRINT("error occurred when DUK_BIDX_DUKTAPE is NULL, ignoring"));
 		return;
 	}
-	tv_hnd = duk_hobject_find_entry_tval_ptr_stridx(thr->heap,
-	                                                thr->builtins[DUK_BIDX_DUKTAPE],
-	                                                stridx_cb);
+	tv_hnd = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, thr->builtins[DUK_BIDX_DUKTAPE], stridx_cb);
 	if (tv_hnd == NULL) {
-		DUK_DD(DUK_DDPRINT("error handler does not exist or is not a plain value: %!T",
-		                   (duk_tval *) tv_hnd));
+		DUK_DD(DUK_DDPRINT("error handler does not exist or is not a plain value: %!T", (duk_tval *) tv_hnd));
 		return;
 	}
-	DUK_DDD(DUK_DDDPRINT("error handler dump (callability not checked): %!T",
-	                     (duk_tval *) tv_hnd));
+	DUK_DDD(DUK_DDDPRINT("error handler dump (callability not checked): %!T", (duk_tval *) tv_hnd));
 	duk_push_tval(thr, tv_hnd);
 
 	/* [ ... errval errhandler ] */
 
-	duk_insert(thr, -2);  /* -> [ ... errhandler errval ] */
+	duk_insert(thr, -2); /* -> [ ... errhandler errval ] */
 	duk_push_undefined(thr);
-	duk_insert(thr, -2);  /* -> [ ... errhandler undefined(= this) errval ] */
+	duk_insert(thr, -2); /* -> [ ... errhandler undefined(= this) errval ] */
 
 	/* [ ... errhandler undefined errval ] */
 
 	/*
 	 *  heap->augmenting_error prevents recursive re-entry and also causes
 	 *  call handling to use a larger (but not unbounded) call stack limit
 	 *  for the duration of error augmentation.
@@ -48220,29 +49196,33 @@
 	 *  replace the original error value.  (This would be easy to change.)
 	 */
 
 	DUK_ASSERT(thr->heap->augmenting_error == 0);
 	thr->heap->augmenting_error = 1;
 
 	rc = duk_pcall_method(thr, 1);
-	DUK_UNREF(rc);  /* no need to check now: both success and error are OK */
+	DUK_UNREF(rc); /* no need to check now: both success and error are OK */
 
 	DUK_ASSERT(thr->heap->augmenting_error == 1);
 	thr->heap->augmenting_error = 0;
 
 	/* [ ... errval ] */
 }
-#endif  /* DUK_USE_ERRTHROW || DUK_USE_ERRCREATE */
+#endif /* DUK_USE_ERRTHROW || DUK_USE_ERRCREATE */
 
 /*
  *  Add ._Tracedata to an error on the stack top.
  */
 
 #if defined(DUK_USE_TRACEBACKS)
-DUK_LOCAL void duk__add_traceback(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_small_uint_t flags) {
+DUK_LOCAL void duk__add_traceback(duk_hthread *thr,
+                                  duk_hthread *thr_callstack,
+                                  const char *c_filename,
+                                  duk_int_t c_line,
+                                  duk_small_uint_t flags) {
 	duk_activation *act;
 	duk_int_t depth;
 	duk_int_t arr_size;
 	duk_tval *tv;
 	duk_hstring *s;
 	duk_uint32_t u32;
 	duk_double_t d;
@@ -48256,23 +49236,22 @@
 	 *  The traceback format is pretty arcane in an attempt to keep it compact
 	 *  and cheap to create.  It may change arbitrarily from version to version.
 	 *  It should be decoded/accessed through version specific accessors only.
 	 *
 	 *  See doc/error-objects.rst.
 	 */
 
-	DUK_DDD(DUK_DDDPRINT("adding traceback to object: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("adding traceback to object: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	/* Preallocate array to correct size, so that we can just write out
 	 * the _Tracedata values into the array part.
 	 */
 	act = thr->callstack_curr;
 	depth = DUK_USE_TRACEBACK_DEPTH;
-	DUK_ASSERT(thr_callstack->callstack_top <= DUK_INT_MAX);  /* callstack limits */
+	DUK_ASSERT(thr_callstack->callstack_top <= DUK_INT_MAX); /* callstack limits */
 	if (depth > (duk_int_t) thr_callstack->callstack_top) {
 		depth = (duk_int_t) thr_callstack->callstack_top;
 	}
 	if (depth > 0) {
 		if (flags & DUK_AUGMENT_FLAG_SKIP_ONE) {
 			DUK_ASSERT(act != NULL);
 			act = act->parent;
@@ -48306,67 +49285,69 @@
 	 */
 	if (thr->compile_ctx != NULL && thr->compile_ctx->h_filename != NULL) {
 		s = thr->compile_ctx->h_filename;
 		DUK_TVAL_SET_STRING(tv, s);
 		DUK_HSTRING_INCREF(thr, s);
 		tv++;
 
-		u32 = (duk_uint32_t) thr->compile_ctx->curr_token.start_line;  /* (flags<<32) + (line), flags = 0 */
+		u32 = (duk_uint32_t) thr->compile_ctx->curr_token.start_line; /* (flags<<32) + (line), flags = 0 */
 		DUK_TVAL_SET_U32(tv, u32);
 		tv++;
 	}
 
 	/* Filename/line from C macros (__FILE__, __LINE__) are added as an
 	 * entry with a special format: (string, number).  The number contains
 	 * the line and flags.
 	 */
 
 	/* [ ... error c_filename? arr ] */
 
 	if (c_filename) {
 		DUK_ASSERT(DUK_TVAL_IS_STRING(thr->valstack_top - 2));
-		s = DUK_TVAL_GET_STRING(thr->valstack_top - 2);  /* interned c_filename */
+		s = DUK_TVAL_GET_STRING(thr->valstack_top - 2); /* interned c_filename */
 		DUK_ASSERT(s != NULL);
 		DUK_TVAL_SET_STRING(tv, s);
 		DUK_HSTRING_INCREF(thr, s);
 		tv++;
 
-		d = ((flags & DUK_AUGMENT_FLAG_NOBLAME_FILELINE) ? ((duk_double_t) DUK_TB_FLAG_NOBLAME_FILELINE) * DUK_DOUBLE_2TO32 : 0.0) +
+		d = ((flags & DUK_AUGMENT_FLAG_NOBLAME_FILELINE) ?
+                         ((duk_double_t) DUK_TB_FLAG_NOBLAME_FILELINE) * DUK_DOUBLE_2TO32 :
+                         0.0) +
 		    (duk_double_t) c_line;
 		DUK_TVAL_SET_DOUBLE(tv, d);
 		tv++;
 	}
 
 	/* Traceback depth doesn't take into account the filename/line
 	 * special handling above (intentional).
 	 */
 	for (; depth-- > 0; act = act->parent) {
 		duk_uint32_t pc;
 		duk_tval *tv_src;
 
 		/* [... arr] */
 
-		DUK_ASSERT(act != NULL);  /* depth check above, assumes book-keeping is correct */
-		DUK_ASSERT_DISABLE(act->pc >= 0);  /* unsigned */
+		DUK_ASSERT(act != NULL); /* depth check above, assumes book-keeping is correct */
+		DUK_ASSERT_DISABLE(act->pc >= 0); /* unsigned */
 
 		/* Add function object. */
-		tv_src = &act->tv_func;  /* object (function) or lightfunc */
+		tv_src = &act->tv_func; /* object (function) or lightfunc */
 		DUK_ASSERT(DUK_TVAL_IS_OBJECT(tv_src) || DUK_TVAL_IS_LIGHTFUNC(tv_src));
 		DUK_TVAL_SET_TVAL(tv, tv_src);
 		DUK_TVAL_INCREF(thr, tv);
 		tv++;
 
 		/* Add a number containing: pc, activation flags.
 		 *
 		 * PC points to next instruction, find offending PC.  Note that
 		 * PC == 0 for native code.
 		 */
 		pc = (duk_uint32_t) duk_hthread_get_act_prev_pc(thr_callstack, act);
-		DUK_ASSERT_DISABLE(pc >= 0);  /* unsigned */
-		DUK_ASSERT((duk_double_t) pc < DUK_DOUBLE_2TO32);  /* assume PC is at most 32 bits and non-negative */
+		DUK_ASSERT_DISABLE(pc >= 0); /* unsigned */
+		DUK_ASSERT((duk_double_t) pc < DUK_DOUBLE_2TO32); /* assume PC is at most 32 bits and non-negative */
 		d = ((duk_double_t) act->flags) * DUK_DOUBLE_2TO32 + (duk_double_t) pc;
 		DUK_TVAL_SET_DOUBLE(tv, d);
 		tv++;
 	}
 
 #if defined(DUK_USE_ASSERTIONS)
 	{
@@ -48383,24 +49364,28 @@
 
 	if (c_filename) {
 		duk_remove_m2(thr);
 	}
 
 	/* [ ... error arr ] */
 
-	duk_xdef_prop_stridx_short_wec(thr, -2, DUK_STRIDX_INT_TRACEDATA);  /* -> [ ... error ] */
+	duk_xdef_prop_stridx_short_wec(thr, -2, DUK_STRIDX_INT_TRACEDATA); /* -> [ ... error ] */
 }
-#endif  /* DUK_USE_TRACEBACKS */
+#endif /* DUK_USE_TRACEBACKS */
 
 /*
  *  Add .fileName and .lineNumber to an error on the stack top.
  */
 
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE) && !defined(DUK_USE_TRACEBACKS)
-DUK_LOCAL void duk__add_fileline(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_small_uint_t flags) {
+DUK_LOCAL void duk__add_fileline(duk_hthread *thr,
+                                 duk_hthread *thr_callstack,
+                                 const char *c_filename,
+                                 duk_int_t c_line,
+                                 duk_small_uint_t flags) {
 #if defined(DUK_USE_ASSERTIONS)
 	duk_int_t entry_top;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 	entry_top = duk_get_top(thr);
 #endif
@@ -48430,15 +49415,15 @@
 		/* Finally, blame the innermost callstack entry which has a
 		 * .fileName property.
 		 */
 		duk_small_uint_t depth;
 		duk_uint32_t ecma_line;
 		duk_activation *act;
 
-		DUK_ASSERT(thr_callstack->callstack_top <= DUK_INT_MAX);  /* callstack limits */
+		DUK_ASSERT(thr_callstack->callstack_top <= DUK_INT_MAX); /* callstack limits */
 		depth = DUK_USE_TRACEBACK_DEPTH;
 		if (depth > thr_callstack->callstack_top) {
 			depth = thr_callstack->callstack_top;
 		}
 		for (act = thr_callstack->callstack_curr; depth-- > 0; act = act->parent) {
 			duk_hobject *func;
 			duk_uint32_t pc;
@@ -48449,18 +49434,20 @@
 				/* Lightfunc, not blamed now. */
 				continue;
 			}
 
 			/* PC points to next instruction, find offending PC,
 			 * PC == 0 for native code.
 			 */
-			pc = duk_hthread_get_act_prev_pc(thr, act);  /* thr argument only used for thr->heap, so specific thread doesn't matter */
+			pc = duk_hthread_get_act_prev_pc(
+			    thr,
+			    act); /* thr argument only used for thr->heap, so specific thread doesn't matter */
 			DUK_UNREF(pc);
-			DUK_ASSERT_DISABLE(pc >= 0);  /* unsigned */
-			DUK_ASSERT((duk_double_t) pc < DUK_DOUBLE_2TO32);  /* assume PC is at most 32 bits and non-negative */
+			DUK_ASSERT_DISABLE(pc >= 0); /* unsigned */
+			DUK_ASSERT((duk_double_t) pc < DUK_DOUBLE_2TO32); /* assume PC is at most 32 bits and non-negative */
 
 			duk_push_hobject(thr, func);
 
 			/* [ ... error func ] */
 
 			duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_FILE_NAME);
 			if (!duk_is_string_notsymbol(thr, -1)) {
@@ -48473,15 +49460,15 @@
 			ecma_line = 0;
 #if defined(DUK_USE_PC2LINE)
 			if (DUK_HOBJECT_IS_COMPFUNC(func)) {
 				ecma_line = duk_hobject_pc2line_query(thr, -2, (duk_uint_fast32_t) pc);
 			} else {
 				/* Native function, no relevant lineNumber. */
 			}
-#endif  /* DUK_USE_PC2LINE */
+#endif /* DUK_USE_PC2LINE */
 			duk_push_u32(thr, ecma_line);
 
 			/* [ ... error func fileName lineNumber ] */
 
 			duk_replace(thr, -3);
 
 			/* [ ... error lineNumber fileName ] */
@@ -48492,47 +49479,45 @@
 		 * .lineNumber (matches what we do with a _Tracedata based
 		 * no-match lookup.
 		 */
 		duk_push_undefined(thr);
 		duk_push_undefined(thr);
 	}
 
- define_props:
+define_props:
 	/* [ ... error lineNumber fileName ] */
 #if defined(DUK_USE_ASSERTIONS)
 	DUK_ASSERT(duk_get_top(thr) == entry_top + 2);
 #endif
 	duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_FILE_NAME, DUK_PROPDESC_FLAGS_C | DUK_PROPDESC_FLAG_NO_OVERWRITE);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LINE_NUMBER, DUK_PROPDESC_FLAGS_C | DUK_PROPDESC_FLAG_NO_OVERWRITE);
 }
-#endif  /* DUK_USE_AUGMENT_ERROR_CREATE && !DUK_USE_TRACEBACKS */
+#endif /* DUK_USE_AUGMENT_ERROR_CREATE && !DUK_USE_TRACEBACKS */
 
 /*
  *  Add line number to a compiler error.
  */
 
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
 DUK_LOCAL void duk__add_compiler_error_line(duk_hthread *thr) {
-
 	/* Append a "(line NNN)" to the "message" property of any error
 	 * thrown during compilation.  Usually compilation errors are
 	 * SyntaxErrors but they can also be out-of-memory errors and
 	 * the like.
 	 */
 
 	/* [ ... error ] */
 
 	DUK_ASSERT(duk_is_object(thr, -1));
 
 	if (!(thr->compile_ctx != NULL && thr->compile_ctx->h_filename != NULL)) {
 		return;
 	}
 
-	DUK_DDD(DUK_DDDPRINT("compile error, before adding line info: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("compile error, before adding line info: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 
 	if (duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_MESSAGE)) {
 		duk_bool_t at_end;
 
 		/* Best guesstimate that error occurred at end of input, token
 		 * truncated by end of input, etc.
 		 */
@@ -48546,45 +49531,50 @@
 		                 "lex.input_length=%ld, window[0].codepoint=%ld, window[1].codepoint=%ld",
 		                 (long) at_end,
 		                 (long) thr->compile_ctx->curr_token.start_offset,
 		                 (long) thr->compile_ctx->lex.input_length,
 		                 (long) thr->compile_ctx->lex.window[0].codepoint,
 		                 (long) thr->compile_ctx->lex.window[1].codepoint));
 
-		duk_push_sprintf(thr, " (line %ld%s)",
+		duk_push_sprintf(thr,
+		                 " (line %ld%s)",
 		                 (long) thr->compile_ctx->curr_token.start_line,
 		                 at_end ? ", end of input" : "");
 		duk_concat(thr, 2);
 		duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_MESSAGE);
 	} else {
 		duk_pop(thr);
 	}
 
-	DUK_DDD(DUK_DDDPRINT("compile error, after adding line info: %!T",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("compile error, after adding line info: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 }
-#endif  /* DUK_USE_AUGMENT_ERROR_CREATE */
+#endif /* DUK_USE_AUGMENT_ERROR_CREATE */
 
 /*
  *  Augment an error being created using Duktape specific properties
  *  like _Tracedata or .fileName/.lineNumber.
  */
 
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
-DUK_LOCAL void duk__err_augment_builtin_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_hobject *obj, duk_small_uint_t flags) {
+DUK_LOCAL void duk__err_augment_builtin_create(duk_hthread *thr,
+                                               duk_hthread *thr_callstack,
+                                               const char *c_filename,
+                                               duk_int_t c_line,
+                                               duk_hobject *obj,
+                                               duk_small_uint_t flags) {
 #if defined(DUK_USE_ASSERTIONS)
 	duk_int_t entry_top;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 	entry_top = duk_get_top(thr);
 #endif
 	DUK_ASSERT(obj != NULL);
 
-	DUK_UNREF(obj);  /* unreferenced w/o tracebacks */
+	DUK_UNREF(obj); /* unreferenced w/o tracebacks */
 
 	duk__add_compiler_error_line(thr);
 
 #if defined(DUK_USE_TRACEBACKS)
 	/* If tracebacks are enabled, the '_Tracedata' property is the only
 	 * thing we need: 'fileName' and 'lineNumber' are virtual properties
 	 * which use '_Tracedata'.  (Check _Tracedata only as own property.)
@@ -48601,15 +49591,15 @@
 	duk__add_fileline(thr, thr_callstack, c_filename, c_line, flags);
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 	DUK_ASSERT(duk_get_top(thr) == entry_top);
 #endif
 }
-#endif  /* DUK_USE_AUGMENT_ERROR_CREATE */
+#endif /* DUK_USE_AUGMENT_ERROR_CREATE */
 
 /*
  *  Augment an error at creation time with _Tracedata/fileName/lineNumber
  *  and allow a user error handler (if defined) to process/replace the error.
  *  The error to be augmented is at the stack top.
  *
  *  thr: thread containing the error value
@@ -48619,15 +49609,19 @@
  *  flags & DUK_AUGMENT_FLAG_NOBLAME_FILELINE:
  *      if true, don't fileName/line as error source, otherwise use traceback
  *      (needed because user code filename/line are reported but internal ones
  *      are not)
  */
 
 #if defined(DUK_USE_AUGMENT_ERROR_CREATE)
-DUK_INTERNAL void duk_err_augment_error_create(duk_hthread *thr, duk_hthread *thr_callstack, const char *c_filename, duk_int_t c_line, duk_small_uint_t flags) {
+DUK_INTERNAL void duk_err_augment_error_create(duk_hthread *thr,
+                                               duk_hthread *thr_callstack,
+                                               const char *c_filename,
+                                               duk_int_t c_line,
+                                               duk_small_uint_t flags) {
 	duk_hobject *obj;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr_callstack != NULL);
 
 	/* [ ... error ] */
 
@@ -48665,29 +49659,29 @@
 
 	/* [ ... error ] */
 
 #if defined(DUK_USE_ERRCREATE)
 	duk__err_augment_user(thr, DUK_STRIDX_ERR_CREATE);
 #endif
 }
-#endif  /* DUK_USE_AUGMENT_ERROR_CREATE */
+#endif /* DUK_USE_AUGMENT_ERROR_CREATE */
 
 /*
  *  Augment an error at throw time; allow a user error handler (if defined)
  *  to process/replace the error.  The error to be augmented is at the
  *  stack top.
  */
 
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
 DUK_INTERNAL void duk_err_augment_error_throw(duk_hthread *thr) {
 #if defined(DUK_USE_ERRTHROW)
 	duk__err_augment_user(thr, DUK_STRIDX_ERR_THROW);
-#endif  /* DUK_USE_ERRTHROW */
+#endif /* DUK_USE_ERRTHROW */
 }
-#endif  /* DUK_USE_AUGMENT_ERROR_THROW */
+#endif /* DUK_USE_AUGMENT_ERROR_THROW */
 #line 1 "duk_error_longjmp.c"
 /*
  *  Do a longjmp call, calling the fatal error handler if no
  *  catchpoint exists.
  */
 
 /* #include duk_internal.h -> already included */
@@ -48730,16 +49724,18 @@
 #endif
 
 DUK_INTERNAL void duk_err_longjmp(duk_hthread *thr) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 
 	DUK_DD(DUK_DDPRINT("longjmp error: type=%d iserror=%d value1=%!T value2=%!T",
-	                   (int) thr->heap->lj.type, (int) thr->heap->lj.iserror,
-	                   &thr->heap->lj.value1, &thr->heap->lj.value2));
+	                   (int) thr->heap->lj.type,
+	                   (int) thr->heap->lj.iserror,
+	                   &thr->heap->lj.value1,
+	                   &thr->heap->lj.value2));
 
 	/* Prevent finalizer execution during error handling.  All error
 	 * handling sites will process pending finalizers once error handling
 	 * is complete and we're ready for the side effects.  Does not prevent
 	 * refzero freeing or mark-and-sweep during error handling.
 	 *
 	 * NOTE: when we come here some calling code may have used DECREF
@@ -48749,43 +49745,45 @@
 	 * the error catcher will run the finalizers once error handling
 	 * is complete.
 	 */
 
 	DUK_ASSERT_LJSTATE_SET(thr->heap);
 
 	thr->heap->pf_prevent_count++;
-	DUK_ASSERT(thr->heap->pf_prevent_count != 0);  /* Wrap. */
+	DUK_ASSERT(thr->heap->pf_prevent_count != 0); /* Wrap. */
 
 #if defined(DUK_USE_ASSERTIONS)
 	/* XXX: set this immediately when longjmp state is set */
-	DUK_ASSERT(thr->heap->error_not_allowed == 0);  /* Detect error within critical section. */
+	DUK_ASSERT(thr->heap->error_not_allowed == 0); /* Detect error within critical section. */
 	thr->heap->error_not_allowed = 1;
 #endif
 
 	DUK_DD(DUK_DDPRINT("about to longjmp, pf_prevent_count=%ld", (long) thr->heap->pf_prevent_count));
 
 	/* If we don't have a jmpbuf_ptr, there is little we can do except
 	 * cause a fatal error.  The caller's expectation is that we never
 	 * return.
 	 */
 	if (!thr->heap->lj.jmpbuf_ptr) {
 		DUK_D(DUK_DPRINT("uncaught error: type=%d iserror=%d value1=%!T value2=%!T",
-		                 (int) thr->heap->lj.type, (int) thr->heap->lj.iserror,
-		                 &thr->heap->lj.value1, &thr->heap->lj.value2));
+		                 (int) thr->heap->lj.type,
+		                 (int) thr->heap->lj.iserror,
+		                 &thr->heap->lj.value1,
+		                 &thr->heap->lj.value2));
 
 #if defined(DUK_USE_PREFER_SIZE)
 		duk__uncaught_minimal(thr);
 #else
 		duk__uncaught_error_aware(thr);
 #endif
 		DUK_UNREACHABLE();
 	}
 
 #if defined(DUK_USE_CPP_EXCEPTIONS)
-	throw duk_internal_exception();  /* dummy */
+	throw duk_internal_exception(); /* dummy */
 #else
 	DUK_LONGJMP(thr->heap->lj.jmpbuf_ptr->jb);
 #endif
 
 	DUK_UNREACHABLE();
 }
 #line 1 "duk_error_misc.c"
@@ -48813,22 +49811,22 @@
 
 	DUK_ASSERT(thr != NULL);
 
 	for (; thr != NULL; thr = thr->resumer) {
 		for (act = thr->callstack_curr; act != NULL; act = act->parent) {
 			for (cat = act->cat; cat != NULL; cat = cat->parent) {
 				if (DUK_CAT_HAS_CATCH_ENABLED(cat)) {
-					return 1;  /* all we need to know */
+					return 1; /* all we need to know */
 				}
 			}
 		}
 	}
 	return 0;
 }
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 /*
  *  Get prototype object for an integer error code.
  */
 
 DUK_INTERNAL duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t code) {
 	switch (code) {
@@ -48870,19 +49868,18 @@
 	DUK_ASSERT(thr->heap != NULL);
 
 	/* XXX: Allow customizing the pause and notify behavior at runtime
 	 * using debugger runtime flags.  For now the behavior is fixed using
 	 * config options.
 	 */
 
-	if (!duk_debug_is_attached(thr->heap) ||
-	    thr->heap->dbg_processing ||
-	    thr->heap->lj.type != DUK_LJ_TYPE_THROW ||
+	if (!duk_debug_is_attached(thr->heap) || thr->heap->dbg_processing || thr->heap->lj.type != DUK_LJ_TYPE_THROW ||
 	    thr->heap->creating_error) {
-		DUK_D(DUK_DPRINT("skip debugger error integration; not attached, debugger processing, not THROW, or error thrown while creating error"));
+		DUK_D(DUK_DPRINT("skip debugger error integration; not attached, debugger processing, not THROW, or error thrown "
+		                 "while creating error"));
 		return;
 	}
 
 	/* Don't intercept a DoubleError, we may have caused the initial double
 	 * fault and attempting to intercept it will cause us to be called
 	 * recursively and exhaust the C stack.  (This should no longer happen
 	 * for the initial throw because DoubleError path doesn't do a debugger
@@ -48902,15 +49899,15 @@
 	 * they can arbitrarily clobber the longjmp state.
 	 */
 	duk_push_tval(thr, tv_obj);
 
 	/* Store and reset longjmp state. */
 	DUK_ASSERT_LJSTATE_SET(thr->heap);
 	DUK_TVAL_DECREF_NORZ(thr, tv_obj);
-	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(&thr->heap->lj.value2));  /* Always for THROW type. */
+	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(&thr->heap->lj.value2)); /* Always for THROW type. */
 	DUK_TVAL_SET_UNDEFINED(tv_obj);
 	thr->heap->lj.type = DUK_LJ_TYPE_UNKNOWN;
 	DUK_ASSERT_LJSTATE_UNSET(thr->heap);
 
 #if defined(DUK_USE_DEBUGGER_THROW_NOTIFY)
 	/* Report it to the debug client */
 	DUK_D(DUK_DPRINT("throw with debugger attached, report to client"));
@@ -48937,15 +49934,15 @@
 	DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(&thr->heap->lj.value2));
 	DUK_TVAL_SET_TVAL(&thr->heap->lj.value1, tv_obj);
 	DUK_TVAL_INCREF(thr, tv_obj);
 	DUK_ASSERT_LJSTATE_SET(thr->heap);
 
 	duk_pop(thr);
 }
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 /*
  *  Helpers for setting up heap longjmp state.
  */
 
 DUK_INTERNAL void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val) {
 	duk_heap *heap;
@@ -48983,22 +49980,28 @@
  *  If an error occurs while we're dealing with the current error, we might
  *  enter an infinite recursion loop.  This is prevented by detecting a
  *  "double fault" through the heap->creating_error flag; the recursion
  *  then stops at the second level.
  */
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
-DUK_INTERNAL void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code, const char *msg, const char *filename, duk_int_t line) {
+DUK_INTERNAL void duk_err_create_and_throw(duk_hthread *thr,
+                                           duk_errcode_t code,
+                                           const char *msg,
+                                           const char *filename,
+                                           duk_int_t line) {
 #else
 DUK_INTERNAL void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code) {
 #endif
 #if defined(DUK_USE_VERBOSE_ERRORS)
 	DUK_DD(DUK_DDPRINT("duk_err_create_and_throw(): code=%ld, msg=%s, filename=%s, line=%ld",
-	                   (long) code, (const char *) msg,
-	                   (const char *) filename, (long) line));
+	                   (long) code,
+	                   (const char *) msg,
+	                   (const char *) filename,
+	                   (long) line));
 #else
 	DUK_DD(DUK_DDPRINT("duk_err_create_and_throw(): code=%ld", (long) code));
 #endif
 
 	DUK_ASSERT(thr != NULL);
 
 	/* Even though nested call is possible because we throw an error when
@@ -49050,37 +50053,27 @@
 
 		duk_require_stack(thr, 1);
 
 		/* XXX: usually unnecessary '%s' formatting here, but cannot
 		 * use 'msg' as a format string directly.
 		 */
 #if defined(DUK_USE_VERBOSE_ERRORS)
-		duk_push_error_object_raw(thr,
-		                          code | DUK_ERRCODE_FLAG_NOBLAME_FILELINE,
-		                          filename,
-		                          line,
-		                          "%s",
-		                          (const char *) msg);
-#else
-		duk_push_error_object_raw(thr,
-		                          code | DUK_ERRCODE_FLAG_NOBLAME_FILELINE,
-		                          NULL,
-		                          0,
-		                          NULL);
+		duk_push_error_object_raw(thr, code | DUK_ERRCODE_FLAG_NOBLAME_FILELINE, filename, line, "%s", (const char *) msg);
+#else
+		duk_push_error_object_raw(thr, code | DUK_ERRCODE_FLAG_NOBLAME_FILELINE, NULL, 0, NULL);
 #endif
 
 		/* Note that an alloc error may happen during error augmentation.
 		 * This may happen both when the original error is an alloc error
 		 * and when it's something else.  Because any error in augmentation
 		 * must be handled correctly anyway, there's no special check for
 		 * avoiding it for alloc errors (this differs from Duktape 1.x).
 		 */
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
-		DUK_DDD(DUK_DDDPRINT("THROW ERROR (INTERNAL): %!iT (before throw augment)",
-		                     (duk_tval *) duk_get_tval(thr, -1)));
+		DUK_DDD(DUK_DDDPRINT("THROW ERROR (INTERNAL): %!iT (before throw augment)", (duk_tval *) duk_get_tval(thr, -1)));
 		duk_err_augment_error_throw(thr);
 #endif
 
 		duk_err_setup_ljstate1(thr, DUK_LJ_TYPE_THROW, DUK_GET_TVAL_NEGIDX(thr, -1));
 		thr->heap->creating_error = 0;
 
 		/* Error is now created and we assume no errors can occur any
@@ -49095,15 +50088,16 @@
 	}
 
 	/*
 	 *  Finally, longjmp
 	 */
 
 	DUK_DDD(DUK_DDDPRINT("THROW ERROR (INTERNAL): %!iT, %!iT (after throw augment)",
-	                     (duk_tval *) &thr->heap->lj.value1, (duk_tval *) &thr->heap->lj.value2));
+	                     (duk_tval *) &thr->heap->lj.value1,
+	                     (duk_tval *) &thr->heap->lj.value2));
 
 	duk_err_longjmp(thr);
 	DUK_UNREACHABLE();
 }
 
 /*
  *  Helper for C function call negative return values.
@@ -49150,38 +50144,37 @@
 	/* Size sanity check.  Should not be necessary because caller is
 	 * required to check this, but we don't want to cause a segfault
 	 * if the size wraps either in duk_size_t computation or when
 	 * storing the size in a 16-bit field.
 	 */
 	if (size > DUK_HBUFFER_MAX_BYTELEN) {
 		DUK_D(DUK_DPRINT("hbuffer alloc failed: size too large: %ld", (long) size));
-		return NULL;  /* no need to write 'out_bufdata' */
+		return NULL; /* no need to write 'out_bufdata' */
 	}
 
 	if (flags & DUK_BUF_FLAG_EXTERNAL) {
 		header_size = sizeof(duk_hbuffer_external);
 		alloc_size = sizeof(duk_hbuffer_external);
 	} else if (flags & DUK_BUF_FLAG_DYNAMIC) {
 		header_size = sizeof(duk_hbuffer_dynamic);
 		alloc_size = sizeof(duk_hbuffer_dynamic);
 	} else {
 		header_size = sizeof(duk_hbuffer_fixed);
 		alloc_size = sizeof(duk_hbuffer_fixed) + size;
-		DUK_ASSERT(alloc_size >= sizeof(duk_hbuffer_fixed));  /* no wrapping */
+		DUK_ASSERT(alloc_size >= sizeof(duk_hbuffer_fixed)); /* no wrapping */
 	}
 
 	res = (duk_hbuffer *) DUK_ALLOC(heap, alloc_size);
 	if (DUK_UNLIKELY(res == NULL)) {
 		goto alloc_error;
 	}
 
 	/* zero everything unless requested not to do so */
 #if defined(DUK_USE_ZERO_BUFFER_DATA)
-	duk_memzero((void *) res,
-	            (flags & DUK_BUF_FLAG_NOZERO) ? header_size : alloc_size);
+	duk_memzero((void *) res, (flags & DUK_BUF_FLAG_NOZERO) ? header_size : alloc_size);
 #else
 	duk_memzero((void *) res, header_size);
 #endif
 
 	if (flags & DUK_BUF_FLAG_EXTERNAL) {
 		duk_hbuffer_external *h;
 		h = (duk_hbuffer_external *) res;
@@ -49196,15 +50189,15 @@
 #endif
 		DUK_ASSERT(DUK_HBUFFER_EXTERNAL_GET_DATA_PTR(heap, h) == NULL);
 	} else if (flags & DUK_BUF_FLAG_DYNAMIC) {
 		duk_hbuffer_dynamic *h = (duk_hbuffer_dynamic *) res;
 		void *ptr;
 
 		if (size > 0) {
-			DUK_ASSERT(!(flags & DUK_BUF_FLAG_EXTERNAL));  /* alloc external with size zero */
+			DUK_ASSERT(!(flags & DUK_BUF_FLAG_EXTERNAL)); /* alloc external with size zero */
 			DUK_DDD(DUK_DDDPRINT("dynamic buffer with nonzero size, alloc actual buffer"));
 #if defined(DUK_USE_ZERO_BUFFER_DATA)
 			ptr = DUK_ALLOC_ZEROED(heap, size);
 #else
 			ptr = DUK_ALLOC(heap, size);
 #endif
 			if (DUK_UNLIKELY(ptr == NULL)) {
@@ -49236,24 +50229,24 @@
 		DUK_HBUFFER_SET_DYNAMIC(res);
 		if (flags & DUK_BUF_FLAG_EXTERNAL) {
 			DUK_HBUFFER_SET_EXTERNAL(res);
 		}
 	} else {
 		DUK_ASSERT(!(flags & DUK_BUF_FLAG_EXTERNAL));
 	}
-        DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap, &res->hdr);
+	DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap, &res->hdr);
 
 	DUK_DDD(DUK_DDDPRINT("allocated hbuffer: %p", (void *) res));
 	return res;
 
- alloc_error:
+alloc_error:
 	DUK_DD(DUK_DDPRINT("hbuffer allocation failed"));
 
 	DUK_FREE(heap, res);
-	return NULL;  /* no need to write 'out_bufdata' */
+	return NULL; /* no need to write 'out_bufdata' */
 }
 
 /* For indirect allocs. */
 
 DUK_INTERNAL void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud) {
 	duk_hbuffer_dynamic *buf = (duk_hbuffer_dynamic *) ud;
 	DUK_UNREF(heap);
@@ -49268,15 +50261,15 @@
 
 #if defined(DUK_USE_ASSERTIONS)
 
 DUK_INTERNAL void duk_hbuffer_assert_valid(duk_hbuffer *h) {
 	DUK_ASSERT(h != NULL);
 }
 
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 #line 1 "duk_hbuffer_ops.c"
 /*
  *  duk_hbuffer operations such as resizing and inserting/appending data to
  *  a dynamic buffer.
  */
 
 /* #include duk_internal.h -> already included */
@@ -49325,16 +50318,15 @@
 		 *  is grown, zero the new part.
 		 */
 
 		prev_size = DUK_HBUFFER_DYNAMIC_GET_SIZE(buf);
 		if (new_size > prev_size) {
 			DUK_ASSERT(new_size - prev_size > 0);
 #if defined(DUK_USE_ZERO_BUFFER_DATA)
-			duk_memzero((void *) ((char *) res + prev_size),
-			            (duk_size_t) (new_size - prev_size));
+			duk_memzero((void *) ((char *) res + prev_size), (duk_size_t) (new_size - prev_size));
 #endif
 		}
 
 		DUK_HBUFFER_DYNAMIC_SET_SIZE(buf, new_size);
 		DUK_HBUFFER_DYNAMIC_SET_DATA_PTR(thr->heap, buf, res);
 	} else {
 		DUK_ERROR_ALLOC_FAILED(thr);
@@ -49368,25 +50360,25 @@
 		/* Slice starting point is beyond current length. */
 		return 0;
 	}
 	buf_avail = buf_size - h_bufobj->offset;
 
 	return buf_avail >= len ? len : buf_avail;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 #line 1 "duk_heap_alloc.c"
 /*
  *  duk_heap allocation and freeing.
  */
 
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_ROM_STRINGS)
 /* Fixed seed value used with ROM strings. */
-#define DUK__FIXED_HASH_SEED       0xabcd1234
+#define DUK__FIXED_HASH_SEED 0xabcd1234
 #endif
 
 /*
  *  Free a heap object.
  *
  *  Free heap object and its internal (non-heap) pointers.  Assumes that
  *  caller has removed the object from heap allocated list or the string
@@ -49467,16 +50459,16 @@
 	DUK_ASSERT(h != NULL);
 
 	DUK_UNREF(heap);
 	DUK_UNREF(h);
 
 #if defined(DUK_USE_HSTRING_EXTDATA) && defined(DUK_USE_EXTSTR_FREE)
 	if (DUK_HSTRING_HAS_EXTDATA(h)) {
-		DUK_DDD(DUK_DDDPRINT("free extstr: hstring %!O, extdata: %p",
-		                     h, DUK_HSTRING_GET_EXTDATA((duk_hstring_external *) h)));
+		DUK_DDD(
+		    DUK_DDDPRINT("free extstr: hstring %!O, extdata: %p", h, DUK_HSTRING_GET_EXTDATA((duk_hstring_external *) h)));
 		DUK_USE_EXTSTR_FREE(heap->heap_udata, (const void *) DUK_HSTRING_GET_EXTDATA((duk_hstring_external *) h));
 	}
 #endif
 	DUK_FREE(heap, (void *) h);
 }
 
 DUK_INTERNAL void duk_heap_free_heaphdr_raw(duk_heap *heap, duk_heaphdr *hdr) {
@@ -49492,15 +50484,14 @@
 	case DUK_HTYPE_OBJECT:
 		duk_free_hobject(heap, (duk_hobject *) hdr);
 		break;
 	default:
 		DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(hdr) == DUK_HTYPE_BUFFER);
 		duk_free_hbuffer(heap, (duk_hbuffer *) hdr);
 	}
-
 }
 
 /*
  *  Free the heap.
  *
  *  Frees heap-related non-heap-tracked allocations such as the
  *  string intern table; then frees the heap allocated objects;
@@ -49522,18 +50513,18 @@
 		act_next = act->parent;
 		DUK_FREE(heap, (void *) act);
 		act = act_next;
 #if defined(DUK_USE_DEBUG)
 		count_act++;
 #endif
 	}
-	heap->activation_free = NULL;  /* needed when called from mark-and-sweep */
+	heap->activation_free = NULL; /* needed when called from mark-and-sweep */
 	return count_act;
 }
-#endif  /* DUK_USE_CACHE_ACTIVATION */
+#endif /* DUK_USE_CACHE_ACTIVATION */
 
 #if defined(DUK_USE_CACHE_CATCHER)
 DUK_LOCAL duk_size_t duk__heap_free_catcher_freelist(duk_heap *heap) {
 	duk_catcher *cat;
 	duk_catcher *cat_next;
 	duk_size_t count_cat = 0;
 
@@ -49541,19 +50532,19 @@
 		cat_next = cat->parent;
 		DUK_FREE(heap, (void *) cat);
 		cat = cat_next;
 #if defined(DUK_USE_DEBUG)
 		count_cat++;
 #endif
 	}
-	heap->catcher_free = NULL;  /* needed when called from mark-and-sweep */
+	heap->catcher_free = NULL; /* needed when called from mark-and-sweep */
 
 	return count_cat;
 }
-#endif  /* DUK_USE_CACHE_CATCHER */
+#endif /* DUK_USE_CACHE_CATCHER */
 
 DUK_INTERNAL void duk_heap_free_freelists(duk_heap *heap) {
 	duk_size_t count_act = 0;
 	duk_size_t count_cat = 0;
 
 #if defined(DUK_USE_CACHE_ACTIVATION)
 	count_act = duk__heap_free_activation_freelist(heap);
@@ -49561,51 +50552,49 @@
 #if defined(DUK_USE_CACHE_CATCHER)
 	count_cat = duk__heap_free_catcher_freelist(heap);
 #endif
 	DUK_UNREF(heap);
 	DUK_UNREF(count_act);
 	DUK_UNREF(count_cat);
 
-	DUK_D(DUK_DPRINT("freed %ld activation freelist entries, %ld catcher freelist entries",
-	                 (long) count_act, (long) count_cat));
+	DUK_D(
+	    DUK_DPRINT("freed %ld activation freelist entries, %ld catcher freelist entries", (long) count_act, (long) count_cat));
 }
 
 DUK_LOCAL void duk__free_allocated(duk_heap *heap) {
 	duk_heaphdr *curr;
 	duk_heaphdr *next;
 
 	curr = heap->heap_allocated;
 	while (curr) {
 		/* We don't log or warn about freeing zero refcount objects
 		 * because they may happen with finalizer processing.
 		 */
 
-		DUK_DDD(DUK_DDDPRINT("FINALFREE (allocated): %!iO",
-		                     (duk_heaphdr *) curr));
+		DUK_DDD(DUK_DDDPRINT("FINALFREE (allocated): %!iO", (duk_heaphdr *) curr));
 		next = DUK_HEAPHDR_GET_NEXT(heap, curr);
 		duk_heap_free_heaphdr_raw(heap, curr);
 		curr = next;
 	}
 }
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_LOCAL void duk__free_finalize_list(duk_heap *heap) {
 	duk_heaphdr *curr;
 	duk_heaphdr *next;
 
 	curr = heap->finalize_list;
 	while (curr) {
-		DUK_DDD(DUK_DDDPRINT("FINALFREE (finalize_list): %!iO",
-		                     (duk_heaphdr *) curr));
+		DUK_DDD(DUK_DDDPRINT("FINALFREE (finalize_list): %!iO", (duk_heaphdr *) curr));
 		next = DUK_HEAPHDR_GET_NEXT(heap, curr);
 		duk_heap_free_heaphdr_raw(heap, curr);
 		curr = next;
 	}
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 DUK_LOCAL void duk__free_stringtable(duk_heap *heap) {
 	/* strings are only tracked by stringtable */
 	duk_heap_strtable_free(heap);
 }
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
@@ -49615,17 +50604,17 @@
 	duk_size_t count_all;
 	duk_size_t count_finalized;
 	duk_size_t curr_limit;
 
 	DUK_ASSERT(heap != NULL);
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);  /* refzero not running -> must be empty */
+	DUK_ASSERT(heap->refzero_list == NULL); /* refzero not running -> must be empty */
 #endif
-	DUK_ASSERT(heap->finalize_list == NULL);  /* mark-and-sweep last pass */
+	DUK_ASSERT(heap->finalize_list == NULL); /* mark-and-sweep last pass */
 
 	if (heap->heap_thread == NULL) {
 		/* May happen when heap allocation fails right off.  There
 		 * cannot be any finalizable objects in this case.
 		 */
 		DUK_D(DUK_DPRINT("no heap_thread in heap destruct, assume no finalizable objects"));
 		return;
@@ -49640,34 +50629,35 @@
 	 * can detect this situation separate from the normal runtime
 	 * mark-and-sweep case.  This allows better assertions (GH-2030).
 	 */
 	DUK_ASSERT(heap->pf_prevent_count == 0);
 	DUK_ASSERT(heap->ms_running == 0);
 	DUK_ASSERT(heap->ms_prevent_count == 0);
 	heap->pf_prevent_count = 1;
-	heap->ms_running = 2;  /* Use distinguishable value. */
-	heap->ms_prevent_count = 1;  /* Bump, because mark-and-sweep assumes it's bumped when ms_running is set. */
+	heap->ms_running = 2; /* Use distinguishable value. */
+	heap->ms_prevent_count = 1; /* Bump, because mark-and-sweep assumes it's bumped when ms_running is set. */
 
-	curr_limit = 0;  /* suppress warning, not used */
-	for (round_no = 0; ; round_no++) {
+	curr_limit = 0; /* suppress warning, not used */
+	for (round_no = 0;; round_no++) {
 		curr = heap->heap_allocated;
 		count_all = 0;
 		count_finalized = 0;
 		while (curr) {
 			count_all++;
 			if (DUK_HEAPHDR_IS_OBJECT(curr)) {
 				/* Only objects in heap_allocated may have finalizers.  Check that
 				 * the object itself has a _Finalizer property (own or inherited)
 				 * so that we don't execute finalizers for e.g. Proxy objects.
 				 */
 				DUK_ASSERT(curr != NULL);
 
 				if (DUK_HOBJECT_HAS_FINALIZER_FAST(heap, (duk_hobject *) curr)) {
 					if (!DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) curr)) {
-						DUK_ASSERT(DUK_HEAP_HAS_FINALIZER_NORESCUE(heap));  /* maps to finalizer 2nd argument */
+						DUK_ASSERT(
+						    DUK_HEAP_HAS_FINALIZER_NORESCUE(heap)); /* maps to finalizer 2nd argument */
 						duk_heap_run_finalizer(heap, (duk_hobject *) curr);
 						count_finalized++;
 					}
 				}
 			}
 			curr = DUK_HEAPHDR_GET_NEXT(heap, curr);
 		}
@@ -49686,18 +50676,21 @@
 
 		if (round_no == 0) {
 			/* Cannot wrap: each object is at least 8 bytes so count is
 			 * at most 1/8 of that.
 			 */
 			curr_limit = count_all * 2;
 		} else {
-			curr_limit = (curr_limit * 3) / 4;   /* Decrease by 25% every round */
+			curr_limit = (curr_limit * 3) / 4; /* Decrease by 25% every round */
 		}
 		DUK_D(DUK_DPRINT("finalizer round %ld complete, %ld objects, tried to execute %ld finalizers, current limit is %ld",
-		                 (long) round_no, (long) count_all, (long) count_finalized, (long) curr_limit));
+		                 (long) round_no,
+		                 (long) count_all,
+		                 (long) count_finalized,
+		                 (long) curr_limit));
 
 		if (count_finalized == 0) {
 			DUK_D(DUK_DPRINT("no more finalizable objects, forced finalization finished"));
 			break;
 		}
 		if (count_finalized >= curr_limit) {
 			DUK_D(DUK_DPRINT("finalizer count above limit, potentially runaway finalizer; skip remaining finalizers"));
@@ -49706,15 +50699,15 @@
 	}
 
 	DUK_ASSERT(heap->ms_running == 2);
 	DUK_ASSERT(heap->pf_prevent_count == 1);
 	heap->ms_running = 0;
 	heap->pf_prevent_count = 0;
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 DUK_INTERNAL void duk_heap_free(duk_heap *heap) {
 	DUK_D(DUK_DPRINT("free heap: %p", (void *) heap));
 
 #if defined(DUK_USE_DEBUG)
 	duk_heap_strtable_dump(heap);
 #endif
@@ -49749,47 +50742,47 @@
 	DUK_ASSERT(heap->pf_skip_finalizers == 0);
 	DUK_D(DUK_DPRINT("forced gc #1 in heap destruction"));
 	duk_heap_mark_and_sweep(heap, 0);
 	DUK_D(DUK_DPRINT("forced gc #2 in heap destruction"));
 	duk_heap_mark_and_sweep(heap, 0);
 	DUK_D(DUK_DPRINT("forced gc #3 in heap destruction (don't run finalizers)"));
 	heap->pf_skip_finalizers = 1;
-	duk_heap_mark_and_sweep(heap, 0);  /* Skip finalizers; queue finalizable objects to heap_allocated. */
+	duk_heap_mark_and_sweep(heap, 0); /* Skip finalizers; queue finalizable objects to heap_allocated. */
 
 	/* There are never objects in refzero_list at this point, or at any
 	 * point beyond a DECREF (even a DECREF_NORZ).  Since Duktape 2.1
 	 * refzero_list processing is side effect free, so it is always
 	 * processed to completion by a DECREF initially triggering a zero
 	 * refcount.
 	 */
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);  /* Always processed to completion inline. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always processed to completion inline. */
 #endif
 #if defined(DUK_USE_FINALIZER_SUPPORT)
-	DUK_ASSERT(heap->finalize_list == NULL);  /* Last mark-and-sweep with skip_finalizers. */
+	DUK_ASSERT(heap->finalize_list == NULL); /* Last mark-and-sweep with skip_finalizers. */
 #endif
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	DUK_D(DUK_DPRINT("run finalizers for remaining finalizable objects"));
-	DUK_HEAP_SET_FINALIZER_NORESCUE(heap);  /* Rescue no longer supported. */
+	DUK_HEAP_SET_FINALIZER_NORESCUE(heap); /* Rescue no longer supported. */
 	duk__free_run_finalizers(heap);
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 	/* Note: heap->heap_thread, heap->curr_thread, and heap->heap_object
 	 * are on the heap allocated list.
 	 */
 
 	DUK_D(DUK_DPRINT("freeing temporary freelists"));
 	duk_heap_free_freelists(heap);
 
 	DUK_D(DUK_DPRINT("freeing heap_allocated of heap: %p", (void *) heap));
 	duk__free_allocated(heap);
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);  /* Always processed to completion inline. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always processed to completion inline. */
 #endif
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	DUK_D(DUK_DPRINT("freeing finalize_list of heap: %p", (void *) heap));
 	duk__free_finalize_list(heap);
 #endif
 
@@ -49824,28 +50817,30 @@
 		const duk_hstring *h;
 		duk_uint32_t hash;
 
 		h = duk_rom_strings_lookup[i];
 		while (h != NULL) {
 			hash = duk_heap_hashstring(heap, (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h), DUK_HSTRING_GET_BYTELEN(h));
 			DUK_DD(DUK_DDPRINT("duk_rom_strings_lookup[%d] -> hash 0x%08lx, computed 0x%08lx",
-			                   (int) i, (unsigned long) DUK_HSTRING_GET_HASH(h), (unsigned long) hash));
+			                   (int) i,
+			                   (unsigned long) DUK_HSTRING_GET_HASH(h),
+			                   (unsigned long) hash));
 			DUK_ASSERT(hash == (duk_uint32_t) DUK_HSTRING_GET_HASH(h));
 
 			h = (const duk_hstring *) h->hdr.h_next;
 		}
 	}
 #endif
 	return 1;
 }
-#else  /* DUK_USE_ROM_STRINGS */
+#else /* DUK_USE_ROM_STRINGS */
 
 DUK_LOCAL duk_bool_t duk__init_heap_strings(duk_heap *heap) {
 	duk_bitdecoder_ctx bd_ctx;
-	duk_bitdecoder_ctx *bd = &bd_ctx;  /* convenience */
+	duk_bitdecoder_ctx *bd = &bd_ctx; /* convenience */
 	duk_small_uint_t i;
 
 	duk_memzero(&bd_ctx, sizeof(bd_ctx));
 	bd->data = (const duk_uint8_t *) duk_strings_data;
 	bd->length = (duk_size_t) DUK_STRDATA_DATA_LENGTH;
 
 	for (i = 0; i < DUK_HEAP_NUM_STRINGS; i++) {
@@ -49893,43 +50888,41 @@
 #else
 		heap->strs[i] = h;
 #endif
 	}
 
 	return 1;
 
- failed:
+failed:
 	return 0;
 }
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 DUK_LOCAL duk_bool_t duk__init_heap_thread(duk_heap *heap) {
 	duk_hthread *thr;
 
 	DUK_D(DUK_DPRINT("heap init: alloc heap thread"));
-	thr = duk_hthread_alloc_unchecked(heap,
-	                                  DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_THREAD));
+	thr = duk_hthread_alloc_unchecked(heap, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_THREAD));
 	if (thr == NULL) {
 		DUK_D(DUK_DPRINT("failed to alloc heap_thread"));
 		return 0;
 	}
 	thr->state = DUK_HTHREAD_STATE_INACTIVE;
 #if defined(DUK_USE_ROM_STRINGS)
 	/* No strs[] pointer. */
-#else  /* DUK_USE_ROM_STRINGS */
+#else /* DUK_USE_ROM_STRINGS */
 #if defined(DUK_USE_HEAPPTR16)
 	thr->strs16 = heap->strs16;
 #else
 	thr->strs = heap->strs;
 #endif
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 	heap->heap_thread = thr;
-	DUK_HTHREAD_INCREF(thr, thr);  /* Note: first argument not really used */
+	DUK_HTHREAD_INCREF(thr, thr); /* Note: first argument not really used */
 
 	/* 'thr' is now reachable */
 
 	DUK_D(DUK_DPRINT("heap init: init heap thread stacks"));
 	if (!duk_hthread_init_stacks(heap, thr)) {
 		return 0;
 	}
@@ -49940,37 +50933,38 @@
 	/* default prototype */
 	DUK_HOBJECT_SET_PROTOTYPE_INIT_INCREF(thr, (duk_hobject *) thr, thr->builtins[DUK_BIDX_THREAD_PROTOTYPE]);
 
 	return 1;
 }
 
 #if defined(DUK_USE_DEBUG)
-#define DUK__DUMPSZ(t)  do { \
+#define DUK__DUMPSZ(t) \
+	do { \
 		DUK_D(DUK_DPRINT("" #t "=%ld", (long) sizeof(t))); \
 	} while (0)
 
 /* These is not 100% because format would need to be non-portable "long long".
  * Also print out as doubles to catch cases where the "long" type is not wide
  * enough; the limits will then not be printed accurately but the magnitude
  * will be correct.
  */
-#define DUK__DUMPLM_SIGNED_RAW(t,a,b)  do { \
-		DUK_D(DUK_DPRINT(t "=[%ld,%ld]=[%lf,%lf]", \
-		                 (long) (a), (long) (b), \
-		                 (double) (a), (double) (b))); \
-	} while (0)
-#define DUK__DUMPLM_UNSIGNED_RAW(t,a,b)  do { \
-		DUK_D(DUK_DPRINT(t "=[%lu,%lu]=[%lf,%lf]", \
-		                 (unsigned long) (a), (unsigned long) (b), \
-		                 (double) (a), (double) (b))); \
+#define DUK__DUMPLM_SIGNED_RAW(t, a, b) \
+	do { \
+		DUK_D(DUK_DPRINT(t "=[%ld,%ld]=[%lf,%lf]", (long) (a), (long) (b), (double) (a), (double) (b))); \
+	} while (0)
+#define DUK__DUMPLM_UNSIGNED_RAW(t, a, b) \
+	do { \
+		DUK_D(DUK_DPRINT(t "=[%lu,%lu]=[%lf,%lf]", (unsigned long) (a), (unsigned long) (b), (double) (a), (double) (b))); \
 	} while (0)
-#define DUK__DUMPLM_SIGNED(t)  do { \
+#define DUK__DUMPLM_SIGNED(t) \
+	do { \
 		DUK__DUMPLM_SIGNED_RAW("DUK_" #t "_{MIN,MAX}", DUK_##t##_MIN, DUK_##t##_MAX); \
 	} while (0)
-#define DUK__DUMPLM_UNSIGNED(t)  do { \
+#define DUK__DUMPLM_UNSIGNED(t) \
+	do { \
 		DUK__DUMPLM_UNSIGNED_RAW("DUK_" #t "_{MIN,MAX}", DUK_##t##_MIN, DUK_##t##_MAX); \
 	} while (0)
 
 DUK_LOCAL void duk__dump_type_sizes(void) {
 	DUK_D(DUK_DPRINT("sizeof()"));
 
 	/* basic platform types */
@@ -50035,15 +51029,15 @@
 	DUK__DUMPSZ(duk_uarridx_t);
 
 	/* tval */
 	DUK__DUMPSZ(duk_double_union);
 	DUK__DUMPSZ(duk_tval);
 
 	/* structs from duk_forwdecl.h */
-	DUK__DUMPSZ(duk_jmpbuf);  /* just one 'int' for C++ exceptions */
+	DUK__DUMPSZ(duk_jmpbuf); /* just one 'int' for C++ exceptions */
 	DUK__DUMPSZ(duk_heaphdr);
 	DUK__DUMPSZ(duk_heaphdr_string);
 	DUK__DUMPSZ(duk_hstring);
 	DUK__DUMPSZ(duk_hstring_external);
 	DUK__DUMPSZ(duk_hobject);
 	DUK__DUMPSZ(duk_harray);
 	DUK__DUMPSZ(duk_hcompfunc);
@@ -50159,15 +51153,15 @@
 	DUK_D(DUK_DPRINT("IEEE double endianness: mixed"));
 #elif defined(DUK_USE_DOUBLE_BE)
 	DUK_D(DUK_DPRINT("IEEE double endianness: big"));
 #else
 	DUK_D(DUK_DPRINT("IEEE double endianness: ???"));
 #endif
 }
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 DUK_INTERNAL
 duk_heap *duk_heap_alloc(duk_alloc_function alloc_func,
                          duk_realloc_function realloc_func,
                          duk_free_function free_func,
                          void *heap_udata,
                          duk_fatal_function fatal_func) {
@@ -50180,15 +51174,15 @@
 	 *  Random config sanity asserts
 	 */
 
 	DUK_ASSERT(DUK_USE_STRTAB_MINSIZE >= 64);
 
 	DUK_ASSERT((DUK_HTYPE_STRING & 0x01U) == 0);
 	DUK_ASSERT((DUK_HTYPE_BUFFER & 0x01U) == 0);
-	DUK_ASSERT((DUK_HTYPE_OBJECT & 0x01U) == 1);  /* DUK_HEAPHDR_IS_OBJECT() relies ont his. */
+	DUK_ASSERT((DUK_HTYPE_OBJECT & 0x01U) == 1); /* DUK_HEAPHDR_IS_OBJECT() relies ont his. */
 
 	/*
 	 *  Debug dump type sizes
 	 */
 
 #if defined(DUK_USE_DEBUG)
 	duk__dump_misc_options();
@@ -50221,15 +51215,15 @@
 #if defined(DUK_USE_PACKED_TVAL)
 	if (sizeof(duk_tval) != 8) {
 #else
 	if (sizeof(duk_tval) != 16) {
 #endif
 		fatal_func(heap_udata, "sizeof(duk_tval) not 8 or 16, cannot use DUK_USE_EXEC_REGCONST_OPTIMIZE option");
 	}
-#endif  /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
+#endif /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
 
 	/*
 	 *  Computed values (e.g. INFINITY)
 	 */
 
 #if defined(DUK_USE_COMPUTED_NAN)
 	do {
@@ -50305,37 +51299,37 @@
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	res->strtable16 = NULL;
 #else
 	res->strtable = NULL;
 #endif
 #if defined(DUK_USE_ROM_STRINGS)
 	/* no res->strs[] */
-#else  /* DUK_USE_ROM_STRINGS */
+#else /* DUK_USE_ROM_STRINGS */
 #if defined(DUK_USE_HEAPPTR16)
 	/* res->strs16[] is zeroed and zero decodes to NULL, so no NULL inits. */
 #else
 	{
 		duk_small_uint_t i;
-	        for (i = 0; i < DUK_HEAP_NUM_STRINGS; i++) {
+		for (i = 0; i < DUK_HEAP_NUM_STRINGS; i++) {
 			res->strs[i] = NULL;
-	        }
+		}
 	}
 #endif
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	res->dbg_read_cb = NULL;
 	res->dbg_write_cb = NULL;
 	res->dbg_peek_cb = NULL;
 	res->dbg_read_flush_cb = NULL;
 	res->dbg_write_flush_cb = NULL;
 	res->dbg_request_cb = NULL;
 	res->dbg_udata = NULL;
 	res->dbg_pause_act = NULL;
 #endif
-#endif  /* DUK_USE_EXPLICIT_NULL_INIT */
+#endif /* DUK_USE_EXPLICIT_NULL_INIT */
 
 	res->alloc_func = alloc_func;
 	res->realloc_func = realloc_func;
 	res->free_func = free_func;
 	res->heap_udata = heap_udata;
 	res->fatal_func = fatal_func;
 
@@ -50366,25 +51360,25 @@
 	 *
 	 * This still generates a /Wp64 warning on VS2010 when compiling for x86.
 	 */
 #if defined(DUK_USE_ROM_STRINGS)
 	/* XXX: make a common DUK_USE_ option, and allow custom fixed seed? */
 	DUK_D(DUK_DPRINT("using rom strings, force heap hash_seed to fixed value 0x%08lx", (long) DUK__FIXED_HASH_SEED));
 	res->hash_seed = (duk_uint32_t) DUK__FIXED_HASH_SEED;
-#else  /* DUK_USE_ROM_STRINGS */
+#else /* DUK_USE_ROM_STRINGS */
 	res->hash_seed = (duk_uint32_t) (duk_uintptr_t) res;
 #if !defined(DUK_USE_STRHASH_DENSE)
-	res->hash_seed ^= 5381;  /* Bernstein hash init value is normally 5381; XOR it in in case pointer low bits are 0 */
+	res->hash_seed ^= 5381; /* Bernstein hash init value is normally 5381; XOR it in in case pointer low bits are 0 */
 #endif
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 	res->lj.jmpbuf_ptr = NULL;
 #endif
-	DUK_ASSERT(res->lj.type == DUK_LJ_TYPE_UNKNOWN);  /* zero */
+	DUK_ASSERT(res->lj.type == DUK_LJ_TYPE_UNKNOWN); /* zero */
 	DUK_ASSERT(res->lj.iserror == 0);
 	DUK_TVAL_SET_UNDEFINED(&res->lj.value1);
 	DUK_TVAL_SET_UNDEFINED(&res->lj.value2);
 
 	DUK_ASSERT_LJSTATE_UNSET(res);
 
 	/*
@@ -50412,22 +51406,22 @@
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	/* zero assumption */
 	duk_memzero(res->strtable16, sizeof(duk_uint16_t) * st_initsize);
 #else
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 	{
 		duk_uint32_t i;
-	        for (i = 0; i < st_initsize; i++) {
+		for (i = 0; i < st_initsize; i++) {
 			res->strtable[i] = NULL;
-	        }
+		}
 	}
 #else
 	duk_memzero(res->strtable, sizeof(duk_hstring *) * st_initsize);
-#endif  /* DUK_USE_EXPLICIT_NULL_INIT */
-#endif  /* DUK_USE_STRTAB_PTRCOMP */
+#endif /* DUK_USE_EXPLICIT_NULL_INIT */
+#endif /* DUK_USE_STRTAB_PTRCOMP */
 
 	/*
 	 *  Init stringcache
 	 */
 
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 	{
@@ -50449,15 +51443,15 @@
 		duk_uint_t i;
 		for (i = 0; i < DUK_USE_LITCACHE_SIZE; i++) {
 			res->litcache[i].addr = NULL;
 			res->litcache[i].h = NULL;
 		}
 	}
 #endif
-#endif  /* DUK_USE_LITCACHE_SIZE */
+#endif /* DUK_USE_LITCACHE_SIZE */
 
 	/* XXX: error handling is incomplete.  It would be cleanest if
 	 * there was a setjmp catchpoint, so that all init code could
 	 * freely throw errors.  If that were the case, the return code
 	 * passing here could be removed.
 	 */
 
@@ -50490,17 +51484,17 @@
 	 */
 
 #if defined(DUK_USE_INJECT_HEAP_ALLOC_ERROR) && (DUK_USE_INJECT_HEAP_ALLOC_ERROR == 4)
 	goto failed;
 #endif
 	DUK_D(DUK_DPRINT("heap init: initialize heap object"));
 	DUK_ASSERT(res->heap_thread != NULL);
-	res->heap_object = duk_hobject_alloc_unchecked(res, DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                                    DUK_HOBJECT_FLAG_FASTREFS |
-	                                                    DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT));
+	res->heap_object = duk_hobject_alloc_unchecked(res,
+	                                               DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                                   DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT));
 	if (res->heap_object == NULL) {
 		goto failed;
 	}
 	DUK_HOBJECT_INCREF(res->heap_thread, res->heap_object);
 
 	/*
 	 *  Odds and ends depending on the heap thread
@@ -50508,16 +51502,16 @@
 
 #if !defined(DUK_USE_GET_RANDOM_DOUBLE)
 #if defined(DUK_USE_PREFER_SIZE) || !defined(DUK_USE_64BIT_OPS)
 	res->rnd_state = (duk_uint32_t) duk_time_get_ecmascript_time(res->heap_thread);
 	duk_util_tinyrandom_prepare_seed(res->heap_thread);
 #else
 	res->rnd_state[0] = (duk_uint64_t) duk_time_get_ecmascript_time(res->heap_thread);
-	DUK_ASSERT(res->rnd_state[1] == 0);  /* Not filled here, filled in by seed preparation. */
-#if 0  /* Manual test values matching misc/xoroshiro128plus_test.c. */
+	DUK_ASSERT(res->rnd_state[1] == 0); /* Not filled here, filled in by seed preparation. */
+#if 0 /* Manual test values matching misc/xoroshiro128plus_test.c. */
 	res->rnd_state[0] = DUK_U64_CONSTANT(0xdeadbeef12345678);
 	res->rnd_state[1] = DUK_U64_CONSTANT(0xcafed00d12345678);
 #endif
 	duk_util_tinyrandom_prepare_seed(res->heap_thread);
 	/* Mix in heap pointer: this ensures that if two Duktape heaps are
 	 * created on the same millisecond, they get a different PRNG
 	 * sequence (unless e.g. virtual memory addresses cause also the
@@ -50561,15 +51555,15 @@
 	/*
 	 *  All done.
 	 */
 
 	DUK_D(DUK_DPRINT("allocated heap: %p", (void *) res));
 	return res;
 
- failed:
+failed:
 	DUK_D(DUK_DPRINT("heap allocation failed"));
 
 	if (res != NULL) {
 		/* Assumes that allocated pointers and alloc funcs are valid
 		 * if res exists.
 		 */
 		DUK_ASSERT(res->ms_prevent_count == 1);
@@ -50622,22 +51616,22 @@
 	/* Force a reallocation with pointer change for value stack
 	 * to maximize side effects.
 	 */
 	duk_hthread_valstack_torture_realloc(thr);
 
 	/* Inner function call, error throw. */
 	duk_eval_string_noresult(thr,
-		"(function dummy() {\n"
-		"    dummy.prototype = null;  /* break reference loop */\n"
-		"    try {\n"
-		"        throw 'fake-finalizer-dummy-error';\n"
-		"    } catch (e) {\n"
-		"        void e;\n"
-		"    }\n"
-		"})()");
+	                         "(function dummy() {\n"
+	                         "    dummy.prototype = null;  /* break reference loop */\n"
+	                         "    try {\n"
+	                         "        throw 'fake-finalizer-dummy-error';\n"
+	                         "    } catch (e) {\n"
+	                         "        void e;\n"
+	                         "    }\n"
+	                         "})()");
 
 	/* The above creates garbage (e.g. a function instance).  Because
 	 * the function/prototype reference loop is broken, it gets collected
 	 * immediately by DECREF.  If Function.prototype has a _Finalizer
 	 * property (happens in some test cases), the garbage gets queued to
 	 * finalize_list.  This still won't cause an infinite loop because
 	 * the torture finalizer is called once per finalize_list run and
@@ -50661,15 +51655,15 @@
 	}
 
 	/* Run fake finalizer.  Avoid creating unnecessary garbage. */
 	duk_push_c_function(thr, duk__fake_global_finalizer, 0 /*nargs*/);
 	(void) duk_pcall(thr, 0 /*nargs*/);
 	duk_pop(thr);
 }
-#endif  /* DUK_USE_FINALIZER_TORTURE */
+#endif /* DUK_USE_FINALIZER_TORTURE */
 
 /*
  *  Process the finalize_list to completion.
  *
  *  An object may be placed on finalize_list by either refcounting or
  *  mark-and-sweep.  The refcount of objects placed by refcounting will be
  *  zero; the refcount of objects placed by mark-and-sweep is > 0.  In both
@@ -50773,20 +51767,21 @@
 	while ((curr = heap->finalize_list) != NULL) {
 #if defined(DUK_USE_REFERENCE_COUNTING)
 		duk_bool_t queue_back;
 #endif
 
 		DUK_DD(DUK_DDPRINT("processing finalize_list entry: %p -> %!iO", (void *) curr, curr));
 
-		DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT);  /* Only objects have finalizers. */
+		DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT); /* Only objects have finalizers. */
 		DUK_ASSERT(!DUK_HEAPHDR_HAS_REACHABLE(curr));
 		DUK_ASSERT(!DUK_HEAPHDR_HAS_TEMPROOT(curr));
-		DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZABLE(curr));  /* All objects on finalize_list will have this flag (except object being finalized right now). */
-		DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZED(curr));   /* Queueing code ensures. */
-		DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY(curr));  /* ROM objects never get freed (or finalized). */
+		DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZABLE(
+		    curr)); /* All objects on finalize_list will have this flag (except object being finalized right now). */
+		DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZED(curr)); /* Queueing code ensures. */
+		DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY(curr)); /* ROM objects never get freed (or finalized). */
 
 #if defined(DUK_USE_ASSERTIONS)
 		DUK_ASSERT(heap->currently_finalizing == NULL);
 		heap->currently_finalizing = curr;
 #endif
 
 		/* Clear FINALIZABLE for object being finalized, so that
@@ -50806,32 +51801,34 @@
 #endif
 
 			/* The object's refcount is >0 throughout so it won't be
 			 * refzero processed prematurely.
 			 */
 #if defined(DUK_USE_REFERENCE_COUNTING)
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(curr) >= 1);
-			had_zero_refcount = (DUK_HEAPHDR_GET_REFCOUNT(curr) == 1);  /* Preincremented on finalize_list insert. */
+			had_zero_refcount = (DUK_HEAPHDR_GET_REFCOUNT(curr) == 1); /* Preincremented on finalize_list insert. */
 #endif
 
 			DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZED(curr));
-			duk_heap_run_finalizer(heap, (duk_hobject *) curr);  /* must never longjmp */
+			duk_heap_run_finalizer(heap, (duk_hobject *) curr); /* must never longjmp */
 			DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZED(curr));
 			/* XXX: assert that object is still in finalize_list
 			 * when duk_push_heapptr() allows automatic rescue.
 			 */
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
 			DUK_DD(DUK_DDPRINT("refcount after finalizer (includes bump): %ld", (long) DUK_HEAPHDR_GET_REFCOUNT(curr)));
-			if (DUK_HEAPHDR_GET_REFCOUNT(curr) == 1) {  /* Only artificial bump in refcount? */
+			if (DUK_HEAPHDR_GET_REFCOUNT(curr) == 1) { /* Only artificial bump in refcount? */
 #if defined(DUK_USE_DEBUG)
 				if (had_zero_refcount) {
-					DUK_DD(DUK_DDPRINT("finalized object's refcount is zero -> free immediately (refcount queued)"));
+					DUK_DD(DUK_DDPRINT(
+					    "finalized object's refcount is zero -> free immediately (refcount queued)"));
 				} else {
-					DUK_DD(DUK_DDPRINT("finalized object's refcount is zero -> free immediately (mark-and-sweep queued)"));
+					DUK_DD(DUK_DDPRINT(
+					    "finalized object's refcount is zero -> free immediately (mark-and-sweep queued)"));
 				}
 #endif
 				queue_back = 0;
 			} else
 #endif
 			{
 #if defined(DUK_USE_REFERENCE_COUNTING)
@@ -50873,29 +51870,29 @@
 			/* FINALIZED is only cleared if object originally
 			 * queued for finalization by refcounting.  For
 			 * mark-and-sweep FINALIZED is left set, so that
 			 * next mark-and-sweep round can make a rescue/free
 			 * decision.
 			 */
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(curr) >= 1);
-			DUK_HEAPHDR_PREDEC_REFCOUNT(curr);  /* Remove artificial refcount bump. */
+			DUK_HEAPHDR_PREDEC_REFCOUNT(curr); /* Remove artificial refcount bump. */
 			DUK_HEAPHDR_CLEAR_FINALIZABLE(curr);
 			DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap, curr);
 		} else {
 			/* No need to remove the refcount bump here. */
-			DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT);  /* currently, always the case */
+			DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT); /* currently, always the case */
 			DUK_DD(DUK_DDPRINT("refcount finalize after finalizer call: %!O", curr));
 			duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);
 			duk_free_hobject(heap, (duk_hobject *) curr);
 			DUK_DD(DUK_DDPRINT("freed hobject after finalization: %p", (void *) curr));
 		}
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 		DUK_HEAPHDR_CLEAR_FINALIZABLE(curr);
 		DUK_HEAP_INSERT_INTO_HEAP_ALLOCATED(heap, curr);
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 #if defined(DUK_USE_DEBUG)
 		count++;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 		DUK_ASSERT(heap->currently_finalizing != NULL);
@@ -50953,19 +51950,19 @@
 	 *
 	 * XXX: Finalizer lookup should traverse the prototype chain (to allow
 	 * inherited finalizers) but should not invoke accessors or proxy object
 	 * behavior.  At the moment this lookup will invoke proxy behavior, so
 	 * caller must ensure that this function is not called if the target is
 	 * a Proxy.
 	 */
-	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_INT_FINALIZER);  /* -> [... obj finalizer] */
+	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_INT_FINALIZER); /* -> [... obj finalizer] */
 	duk_dup_m2(thr);
 	duk_push_boolean(thr, DUK_HEAP_HAS_FINALIZER_NORESCUE(thr->heap));
 	DUK_DDD(DUK_DDDPRINT("calling finalizer"));
-	duk_call(thr, 2);  /* [ ... obj finalizer obj heapDestruct ]  -> [ ... obj retval ] */
+	duk_call(thr, 2); /* [ ... obj finalizer obj heapDestruct ]  -> [ ... obj retval ] */
 	DUK_DDD(DUK_DDDPRINT("finalizer returned successfully"));
 	return 0;
 
 	/* Note: we rely on duk_safe_call() to fix up the stack for the caller,
 	 * so we don't need to pop stuff here.  There is no return value;
 	 * caller determines rescued status based on object refcount.
 	 */
@@ -51006,49 +52003,50 @@
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) obj));
 #if 0
 	if (DUK_HEAPHDR_HAS_FINALIZED((duk_heaphdr *) obj)) {
 		DUK_D(DUK_DPRINT("object already finalized, avoid running finalizer twice: %!O", obj));
 		return;
 	}
 #endif
-	DUK_HEAPHDR_SET_FINALIZED((duk_heaphdr *) obj);  /* ensure never re-entered until rescue cycle complete */
+	DUK_HEAPHDR_SET_FINALIZED((duk_heaphdr *) obj); /* ensure never re-entered until rescue cycle complete */
 
 #if defined(DUK_USE_ES6_PROXY)
 	if (DUK_HOBJECT_IS_PROXY(obj)) {
 		/* This may happen if duk_set_finalizer() or Duktape.fin() is
 		 * called for a Proxy object.  In such cases the fast finalizer
 		 * flag will be set on the Proxy, not the target, and neither
 		 * will be finalized.
 		 */
 		DUK_D(DUK_DPRINT("object is a Proxy, skip finalizer call"));
 		return;
 	}
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
-	duk_push_hobject(thr, obj);  /* this also increases refcount by one */
-	rc = duk_safe_call(thr, duk__finalize_helper, NULL /*udata*/, 0 /*nargs*/, 1 /*nrets*/);  /* -> [... obj retval/error] */
-	DUK_ASSERT_TOP(thr, entry_top + 2);  /* duk_safe_call discipline */
+	duk_push_hobject(thr, obj); /* this also increases refcount by one */
+	rc = duk_safe_call(thr, duk__finalize_helper, NULL /*udata*/, 0 /*nargs*/, 1 /*nrets*/); /* -> [... obj retval/error] */
+	DUK_ASSERT_TOP(thr, entry_top + 2); /* duk_safe_call discipline */
 
 	if (rc != DUK_EXEC_SUCCESS) {
 		/* Note: we ask for one return value from duk_safe_call to get this
 		 * error debugging here.
 		 */
 		DUK_D(DUK_DPRINT("wrapped finalizer call failed for object %p (ignored); error: %!T",
-		                 (void *) obj, (duk_tval *) duk_get_tval(thr, -1)));
+		                 (void *) obj,
+		                 (duk_tval *) duk_get_tval(thr, -1)));
 	}
-	duk_pop_2(thr);  /* -> [...] */
+	duk_pop_2(thr); /* -> [...] */
 
 	DUK_ASSERT_TOP(thr, entry_top);
 }
 
-#else  /* DUK_USE_FINALIZER_SUPPORT */
+#else /* DUK_USE_FINALIZER_SUPPORT */
 
 /* nothing */
 
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 #line 1 "duk_heap_hashstring.c"
 /*
  *  String hash computation (interning).
  *
  *  String hashing is performance critical because a string hash is computed
  *  for all new strings which are candidates to be added to the string table.
  *  However, strings actually added to the string table go through a codepoint
@@ -51065,17 +52063,17 @@
  *  for ROM string support!
  */
 
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_STRHASH_DENSE)
 /* Constants for duk_hashstring(). */
-#define DUK__STRHASH_SHORTSTRING   4096L
-#define DUK__STRHASH_MEDIUMSTRING  (256L * 1024L)
-#define DUK__STRHASH_BLOCKSIZE     256L
+#define DUK__STRHASH_SHORTSTRING  4096L
+#define DUK__STRHASH_MEDIUMSTRING (256L * 1024L)
+#define DUK__STRHASH_BLOCKSIZE    256L
 
 DUK_INTERNAL duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len) {
 	duk_uint32_t hash;
 
 	/* Use Murmurhash2 directly for short strings, and use "block skipping"
 	 * for long strings: hash an initial part and then sample the rest of
 	 * the string with reasonably sized chunks.  An initial offset for the
@@ -51124,15 +52122,15 @@
 	/* Truncate to 16 bits here, so that a computed hash can be compared
 	 * against a hash stored in a 16-bit field.
 	 */
 	hash &= 0x0000ffffUL;
 #endif
 	return hash;
 }
-#else  /* DUK_USE_STRHASH_DENSE */
+#else /* DUK_USE_STRHASH_DENSE */
 DUK_INTERNAL duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len) {
 	duk_uint32_t hash;
 	duk_size_t step;
 	duk_size_t off;
 
 	/* Slightly modified "Bernstein hash" from:
 	 *
@@ -51142,30 +52140,30 @@
 	 * Lua 5.1.5, and different hash initializer.
 	 *
 	 * The reverse direction ensures last byte it always included in the
 	 * hash which is a good default as changing parts of the string are
 	 * more often in the suffix than in the prefix.
 	 */
 
-	hash = heap->hash_seed ^ ((duk_uint32_t) len);  /* Bernstein hash init value is normally 5381 */
+	hash = heap->hash_seed ^ ((duk_uint32_t) len); /* Bernstein hash init value is normally 5381 */
 	step = (len >> DUK_USE_STRHASH_SKIP_SHIFT) + 1;
 	for (off = len; off >= step; off -= step) {
-		DUK_ASSERT(off >= 1);  /* off >= step, and step >= 1 */
+		DUK_ASSERT(off >= 1); /* off >= step, and step >= 1 */
 		hash = (hash * 33) + str[off - 1];
 	}
 
 #if defined(DUK_USE_STRHASH16)
 	/* Truncate to 16 bits here, so that a computed hash can be compared
 	 * against a hash stored in a 16-bit field.
 	 */
 	hash &= 0x0000ffffUL;
 #endif
 	return hash;
 }
-#endif  /* DUK_USE_STRHASH_DENSE */
+#endif /* DUK_USE_STRHASH_DENSE */
 
 /* automatic undefs */
 #undef DUK__STRHASH_BLOCKSIZE
 #undef DUK__STRHASH_MEDIUMSTRING
 #undef DUK__STRHASH_SHORTSTRING
 #line 1 "duk_heap_markandsweep.c"
 /*
@@ -51280,28 +52278,28 @@
 		duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) e->target);
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	} else if (DUK_HOBJECT_IS_BUFOBJ(h)) {
 		duk_hbufobj *b = (duk_hbufobj *) h;
 		DUK_HBUFOBJ_ASSERT_VALID(b);
 		duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf);
 		duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf_prop);
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 	} else if (DUK_HOBJECT_IS_BOUNDFUNC(h)) {
 		duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
 		DUK_HBOUNDFUNC_ASSERT_VALID(f);
 		duk__mark_tval(heap, &f->target);
 		duk__mark_tval(heap, &f->this_binding);
 		duk__mark_tvals(heap, f->args, f->nargs);
 #if defined(DUK_USE_ES6_PROXY)
 	} else if (DUK_HOBJECT_IS_PROXY(h)) {
 		duk_hproxy *p = (duk_hproxy *) h;
 		DUK_HPROXY_ASSERT_VALID(p);
 		duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->target);
 		duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->handler);
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 	} else if (DUK_HOBJECT_IS_THREAD(h)) {
 		duk_hthread *t = (duk_hthread *) h;
 		duk_activation *act;
 		duk_tval *tv;
 
 		DUK_HTHREAD_ASSERT_VALID(t);
 
@@ -51314,15 +52312,15 @@
 		for (act = t->callstack_curr; act != NULL; act = act->parent) {
 			duk__mark_heaphdr(heap, (duk_heaphdr *) DUK_ACT_GET_FUNC(act));
 			duk__mark_heaphdr(heap, (duk_heaphdr *) act->var_env);
 			duk__mark_heaphdr(heap, (duk_heaphdr *) act->lex_env);
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 			duk__mark_heaphdr(heap, (duk_heaphdr *) act->prev_caller);
 #endif
-#if 0  /* nothing now */
+#if 0 /* nothing now */
 			for (cat = act->cat; cat != NULL; cat = cat->parent) {
 			}
 #endif
 		}
 
 		duk__mark_heaphdr(heap, (duk_heaphdr *) t->resumer);
 
@@ -51337,29 +52335,28 @@
 		DUK_D(DUK_DPRINT("missing FASTREFS flag for: %!iO", h));
 		DUK_ASSERT(0);
 	}
 }
 
 /* Mark any duk_heaphdr type.  Recursion tracking happens only here. */
 DUK_LOCAL void duk__mark_heaphdr(duk_heap *heap, duk_heaphdr *h) {
-	DUK_DDD(DUK_DDDPRINT("duk__mark_heaphdr %p, type %ld",
-	                     (void *) h,
-	                     (h != NULL ? (long) DUK_HEAPHDR_GET_TYPE(h) : (long) -1)));
+	DUK_DDD(
+	    DUK_DDDPRINT("duk__mark_heaphdr %p, type %ld", (void *) h, (h != NULL ? (long) DUK_HEAPHDR_GET_TYPE(h) : (long) -1)));
 
 	/* XXX: add non-null variant? */
 	if (h == NULL) {
 		return;
 	}
 
 	DUK_HEAPHDR_ASSERT_VALID(h);
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY(h) || DUK_HEAPHDR_HAS_REACHABLE(h));
 
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_REFERENCE_COUNTING)
 	if (!DUK_HEAPHDR_HAS_READONLY(h)) {
-		h->h_assert_refcount++;  /* Comparison refcount: bump even if already reachable. */
+		h->h_assert_refcount++; /* Comparison refcount: bump even if already reachable. */
 	}
 #endif
 	if (DUK_HEAPHDR_HAS_REACHABLE(h)) {
 		DUK_DDD(DUK_DDDPRINT("already marked reachable, skip"));
 		return;
 	}
 #if defined(DUK_USE_ROM_OBJECTS)
@@ -51375,15 +52372,15 @@
 		DUK_D(DUK_DPRINT("mark-and-sweep recursion limit reached, marking as temproot: %p", (void *) h));
 		DUK_HEAP_SET_MARKANDSWEEP_RECLIMIT_REACHED(heap);
 		DUK_HEAPHDR_SET_TEMPROOT(h);
 		return;
 	}
 
 	heap->ms_recursion_depth++;
-	DUK_ASSERT(heap->ms_recursion_depth != 0);  /* Wrap. */
+	DUK_ASSERT(heap->ms_recursion_depth != 0); /* Wrap. */
 
 	switch (DUK_HEAPHDR_GET_TYPE(h)) {
 	case DUK_HTYPE_STRING:
 		duk__mark_hstring(heap, (duk_hstring *) h);
 		break;
 	case DUK_HTYPE_OBJECT:
 		duk__mark_hobject(heap, (duk_hobject *) h);
@@ -51490,17 +52487,15 @@
 		/* A finalizer is looked up from the object and up its
 		 * prototype chain (which allows inherited finalizers).
 		 * The finalizer is checked for using a duk_hobject flag
 		 * which is kept in sync with the presence and callability
 		 * of a _Finalizer hidden symbol.
 		 */
 
-		if (!DUK_HEAPHDR_HAS_REACHABLE(hdr) &&
-		    DUK_HEAPHDR_IS_OBJECT(hdr) &&
-		    !DUK_HEAPHDR_HAS_FINALIZED(hdr) &&
+		if (!DUK_HEAPHDR_HAS_REACHABLE(hdr) && DUK_HEAPHDR_IS_OBJECT(hdr) && !DUK_HEAPHDR_HAS_FINALIZED(hdr) &&
 		    DUK_HOBJECT_HAS_FINALIZER_FAST(heap, (duk_hobject *) hdr)) {
 			/* heaphdr:
 			 *  - is not reachable
 			 *  - is an object
 			 *  - is not a finalized object waiting for rescue/keep decision
 			 *  - has a finalizer
 			 */
@@ -51517,29 +52512,28 @@
 		hdr = DUK_HEAPHDR_GET_NEXT(heap, hdr);
 	}
 
 	if (count_finalizable == 0) {
 		return;
 	}
 
-	DUK_DD(DUK_DDPRINT("marked %ld heap objects as finalizable, now mark them reachable",
-	                   (long) count_finalizable));
+	DUK_DD(DUK_DDPRINT("marked %ld heap objects as finalizable, now mark them reachable", (long) count_finalizable));
 
 	hdr = heap->heap_allocated;
 	while (hdr != NULL) {
 		if (DUK_HEAPHDR_HAS_FINALIZABLE(hdr)) {
 			duk__mark_heaphdr_nonnull(heap, hdr);
 		}
 
 		hdr = DUK_HEAPHDR_GET_NEXT(heap, hdr);
 	}
 
 	/* Caller will finish the marking process if we hit a recursion limit. */
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 /*
  *  Mark objects on finalize_list.
  */
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_LOCAL void duk__mark_finalize_list(duk_heap *heap) {
@@ -51562,15 +52556,15 @@
 #if defined(DUK_USE_DEBUG)
 	if (count_finalize_list > 0) {
 		DUK_D(DUK_DPRINT("marked %ld objects on the finalize_list as reachable (previous finalizer run skipped)",
 		                 (long) count_finalize_list));
 	}
 #endif
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 /*
  *  Fallback marking handler if recursion limit is reached.
  *
  *  Iterates 'temproots' until recursion limit is no longer hit.  Temproots
  *  can be in heap_allocated or finalize_list; refzero_list is now always
  *  empty for mark-and-sweep.  A temproot may occur in finalize_list now if
@@ -51595,17 +52589,17 @@
 	if (!DUK_HEAPHDR_HAS_TEMPROOT(hdr)) {
 		DUK_DDD(DUK_DDDPRINT("not a temp root: %p", (void *) hdr));
 		return;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("found a temp root: %p", (void *) hdr));
 	DUK_HEAPHDR_CLEAR_TEMPROOT(hdr);
-	DUK_HEAPHDR_CLEAR_REACHABLE(hdr);  /* Done so that duk__mark_heaphdr() works correctly. */
+	DUK_HEAPHDR_CLEAR_REACHABLE(hdr); /* Done so that duk__mark_heaphdr() works correctly. */
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_REFERENCE_COUNTING)
-	hdr->h_assert_refcount--;  /* Same node visited twice. */
+	hdr->h_assert_refcount--; /* Same node visited twice. */
 #endif
 	duk__mark_heaphdr_nonnull(heap, hdr);
 
 #if defined(DUK_USE_DEBUG)
 	(*count)++;
 #endif
 }
@@ -51692,15 +52686,15 @@
 			 */
 			duk_heaphdr_refcount_finalize_norz(heap, hdr);
 		}
 
 		hdr = DUK_HEAPHDR_GET_NEXT(heap, hdr);
 	}
 }
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /*
  *  Clear (reachable) flags of finalize_list.
  *
  *  We could mostly do in the sweep phase when we move objects from the
  *  heap into the finalize_list.  However, if a finalizer run is skipped
  *  during a mark-and-sweep, the objects on the finalize_list will be marked
@@ -51715,23 +52709,22 @@
 
 	DUK_DD(DUK_DDPRINT("duk__clear_finalize_list_flags: %p", (void *) heap));
 
 	hdr = heap->finalize_list;
 	while (hdr) {
 		DUK_HEAPHDR_CLEAR_REACHABLE(hdr);
 #if defined(DUK_USE_ASSERTIONS)
-		DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZABLE(hdr) || \
-		           (heap->currently_finalizing == hdr));
+		DUK_ASSERT(DUK_HEAPHDR_HAS_FINALIZABLE(hdr) || (heap->currently_finalizing == hdr));
 #endif
 		/* DUK_HEAPHDR_FLAG_FINALIZED may be set. */
 		DUK_ASSERT(!DUK_HEAPHDR_HAS_TEMPROOT(hdr));
 		hdr = DUK_HEAPHDR_GET_NEXT(heap, hdr);
 	}
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 /*
  *  Sweep stringtable.
  */
 
 DUK_LOCAL void duk__sweep_stringtable(duk_heap *heap, duk_size_t *out_count_keep) {
 	duk_hstring *h;
@@ -51759,16 +52752,15 @@
 		h = heap->strtable[i];
 #endif
 		prev = NULL;
 		while (h != NULL) {
 			duk_hstring *next;
 			next = h->hdr.h_next;
 
-			if (DUK_HEAPHDR_HAS_REACHABLE((duk_heaphdr *) h))
-			{
+			if (DUK_HEAPHDR_HAS_REACHABLE((duk_heaphdr *) h)) {
 				DUK_HEAPHDR_CLEAR_REACHABLE((duk_heaphdr *) h);
 				count_keep++;
 				prev = h;
 			} else {
 #if defined(DUK_USE_DEBUG)
 				count_free++;
 #endif
@@ -51787,16 +52779,16 @@
 #endif
 #if defined(DUK_USE_REFERENCE_COUNTING)
 				/* Non-zero refcounts should not happen for unreachable strings,
 				 * because we refcount finalize all unreachable objects which
 				 * should have decreased unreachable string refcounts to zero
 				 * (even for cycles).  However, pinned strings have a +1 bump.
 				 */
-				DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) ==
-				           DUK_HSTRING_HAS_PINNED_LITERAL(h) ? 1U : 0U);
+				DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) == DUK_HSTRING_HAS_PINNED_LITERAL(h) ? 1U :
+                                                                                                                              0U);
 #endif
 
 				/* Deal with weak references first. */
 				duk_heap_strcache_string_remove(heap, (duk_hstring *) h);
 
 				/* Remove the string from the string table. */
 				duk_heap_strtable_unlink_prev(heap, (duk_hstring *) h, (duk_hstring *) prev);
@@ -51809,28 +52801,27 @@
 				/* Don't update 'prev'; it should be last string kept. */
 			}
 
 			h = next;
 		}
 	}
 
- done:
+done:
 #if defined(DUK_USE_DEBUG)
-	DUK_D(DUK_DPRINT("mark-and-sweep sweep stringtable: %ld freed, %ld kept",
-	                 (long) count_free, (long) count_keep));
+	DUK_D(DUK_DPRINT("mark-and-sweep sweep stringtable: %ld freed, %ld kept", (long) count_free, (long) count_keep));
 #endif
 	*out_count_keep = count_keep;
 }
 
 /*
  *  Sweep heap.
  */
 
 DUK_LOCAL void duk__sweep_heap(duk_heap *heap, duk_small_uint_t flags, duk_size_t *out_count_keep) {
-	duk_heaphdr *prev;  /* last element that was left in the heap */
+	duk_heaphdr *prev; /* last element that was left in the heap */
 	duk_heaphdr *curr;
 	duk_heaphdr *next;
 #if defined(DUK_USE_DEBUG)
 	duk_size_t count_free = 0;
 	duk_size_t count_finalize = 0;
 	duk_size_t count_rescue = 0;
 #endif
@@ -51865,33 +52856,36 @@
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 			if (DUK_UNLIKELY(DUK_HEAPHDR_HAS_FINALIZABLE(curr))) {
 				DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZED(curr));
 				DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT);
 				DUK_DD(DUK_DDPRINT("sweep; reachable, finalizable --> move to finalize_list: %p", (void *) curr));
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
-				DUK_HEAPHDR_PREINC_REFCOUNT(curr);  /* Bump refcount so that refzero never occurs when pending a finalizer call. */
+				DUK_HEAPHDR_PREINC_REFCOUNT(
+				    curr); /* Bump refcount so that refzero never occurs when pending a finalizer call. */
 #endif
 				DUK_HEAP_INSERT_INTO_FINALIZE_LIST(heap, curr);
 #if defined(DUK_USE_DEBUG)
 				count_finalize++;
 #endif
-			}
-			else
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+			} else
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 			{
 				if (DUK_UNLIKELY(DUK_HEAPHDR_HAS_FINALIZED(curr))) {
 					DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZABLE(curr));
 					DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT);
 
 					if (flags & DUK_MS_FLAG_POSTPONE_RESCUE) {
-						DUK_DD(DUK_DDPRINT("sweep; reachable, finalized, but postponing rescue decisions --> keep object (with FINALIZED set): %!iO", curr));
+						DUK_DD(DUK_DDPRINT("sweep; reachable, finalized, but postponing rescue decisions "
+						                   "--> keep object (with FINALIZED set): %!iO",
+						                   curr));
 						count_keep++;
 					} else {
-						DUK_DD(DUK_DDPRINT("sweep; reachable, finalized --> rescued after finalization: %p", (void *) curr));
+						DUK_DD(DUK_DDPRINT("sweep; reachable, finalized --> rescued after finalization: %p",
+						                   (void *) curr));
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 						DUK_HEAPHDR_CLEAR_FINALIZED(curr);
 #endif
 #if defined(DUK_USE_DEBUG)
 						count_rescue++;
 #endif
 					}
@@ -51952,15 +52946,16 @@
 			 */
 			DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(curr) == 0);
 #endif
 			DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZABLE(curr));
 
 #if defined(DUK_USE_DEBUG)
 			if (DUK_HEAPHDR_HAS_FINALIZED(curr)) {
-				DUK_DD(DUK_DDPRINT("sweep; unreachable, finalized --> finalized object not rescued: %p", (void *) curr));
+				DUK_DD(DUK_DDPRINT("sweep; unreachable, finalized --> finalized object not rescued: %p",
+				                   (void *) curr));
 			} else {
 				DUK_DD(DUK_DDPRINT("sweep; not reachable --> free: %p", (void *) curr));
 			}
 
 #endif
 
 			/* Note: object cannot be a finalizable unreachable object, as
@@ -51986,15 +52981,18 @@
 	if (prev != NULL) {
 		DUK_HEAPHDR_SET_NEXT(heap, prev, NULL);
 	}
 	DUK_HEAPHDR_ASSERT_LINKS(heap, prev);
 
 #if defined(DUK_USE_DEBUG)
 	DUK_D(DUK_DPRINT("mark-and-sweep sweep objects (non-string): %ld freed, %ld kept, %ld rescued, %ld queued for finalization",
-	                 (long) count_free, (long) count_keep, (long) count_rescue, (long) count_finalize));
+	                 (long) count_free,
+	                 (long) count_keep,
+	                 (long) count_rescue,
+	                 (long) count_finalize));
 #endif
 	*out_count_keep = count_keep;
 }
 
 /*
  *  Litcache helpers.
  */
@@ -52009,15 +53007,15 @@
 		e->addr = NULL;
 		/* e->h does not need to be invalidated: when e->addr is
 		 * NULL, e->h is considered garbage.
 		 */
 		e++;
 	}
 }
-#endif  /* DUK_USE_LITCACHE_SIZE */
+#endif /* DUK_USE_LITCACHE_SIZE */
 
 /*
  *  Object compaction.
  *
  *  Compaction is assumed to never throw an error.
  */
 
@@ -52028,15 +53026,20 @@
 	DUK_UNREF(udata);
 	obj = duk_known_hobject(thr, -1);
 	duk_hobject_compact_props(thr, obj);
 	return 0;
 }
 
 #if defined(DUK_USE_DEBUG)
-DUK_LOCAL void duk__compact_object_list(duk_heap *heap, duk_hthread *thr, duk_heaphdr *start, duk_size_t *p_count_check, duk_size_t *p_count_compact, duk_size_t *p_count_bytes_saved) {
+DUK_LOCAL void duk__compact_object_list(duk_heap *heap,
+                                        duk_hthread *thr,
+                                        duk_heaphdr *start,
+                                        duk_size_t *p_count_check,
+                                        duk_size_t *p_count_compact,
+                                        duk_size_t *p_count_bytes_saved) {
 #else
 DUK_LOCAL void duk__compact_object_list(duk_heap *heap, duk_hthread *thr, duk_heaphdr *start) {
 #endif
 	duk_heaphdr *curr;
 #if defined(DUK_USE_DEBUG)
 	duk_size_t old_size, new_size;
 #endif
@@ -52050,36 +53053,34 @@
 
 		if (DUK_HEAPHDR_GET_TYPE(curr) != DUK_HTYPE_OBJECT) {
 			goto next;
 		}
 		obj = (duk_hobject *) curr;
 
 #if defined(DUK_USE_DEBUG)
-		old_size = DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj),
-		                                      DUK_HOBJECT_GET_ASIZE(obj),
-		                                      DUK_HOBJECT_GET_HSIZE(obj));
+		old_size =
+		    DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj), DUK_HOBJECT_GET_ASIZE(obj), DUK_HOBJECT_GET_HSIZE(obj));
 #endif
 
 		DUK_DD(DUK_DDPRINT("compact object: %p", (void *) obj));
 		duk_push_hobject(thr, obj);
 		/* XXX: disable error handlers for duration of compaction? */
 		duk_safe_call(thr, duk__protected_compact_object, NULL, 1, 0);
 
 #if defined(DUK_USE_DEBUG)
-		new_size = DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj),
-		                                      DUK_HOBJECT_GET_ASIZE(obj),
-		                                      DUK_HOBJECT_GET_HSIZE(obj));
+		new_size =
+		    DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj), DUK_HOBJECT_GET_ASIZE(obj), DUK_HOBJECT_GET_HSIZE(obj));
 #endif
 
 #if defined(DUK_USE_DEBUG)
 		(*p_count_compact)++;
 		(*p_count_bytes_saved) += (duk_size_t) (old_size - new_size);
 #endif
 
-	 next:
+	next:
 		curr = DUK_HEAPHDR_GET_NEXT(heap, curr);
 #if defined(DUK_USE_DEBUG)
 		(*p_count_check)++;
 #endif
 	}
 }
 
@@ -52103,20 +53104,22 @@
 #else
 	duk__compact_object_list(heap, heap->heap_thread, heap->heap_allocated);
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	duk__compact_object_list(heap, heap->heap_thread, heap->finalize_list);
 #endif
 #endif
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);  /* Always handled to completion inline in DECREF. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always handled to completion inline in DECREF. */
 #endif
 
 #if defined(DUK_USE_DEBUG)
 	DUK_D(DUK_DPRINT("mark-and-sweep compact objects: %ld checked, %ld compaction attempts, %ld bytes saved by compaction",
-	                 (long) count_check, (long) count_compact, (long) count_bytes_saved));
+	                 (long) count_check,
+	                 (long) count_compact,
+	                 (long) count_bytes_saved));
 #endif
 }
 
 /*
  *  Assertion helpers.
  */
 
@@ -52155,15 +53158,15 @@
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_TEMPROOT(h));
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_FINALIZABLE(h));
 	/* may have FINALIZED */
 }
 DUK_LOCAL void duk__assert_heaphdr_flags(duk_heap *heap) {
 	duk__assert_walk_list(heap, heap->heap_allocated, duk__assert_heaphdr_flags_cb);
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);  /* Always handled to completion inline in DECREF. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always handled to completion inline in DECREF. */
 #endif
 	/* XXX: Assertions for finalize_list? */
 }
 
 DUK_LOCAL void duk__assert_validity_cb1(duk_heap *heap, duk_heaphdr *h) {
 	DUK_UNREF(heap);
 	DUK_ASSERT(DUK_HEAPHDR_IS_OBJECT(h) || DUK_HEAPHDR_IS_BUFFER(h));
@@ -52186,30 +53189,29 @@
 }
 
 #if defined(DUK_USE_REFERENCE_COUNTING)
 DUK_LOCAL void duk__assert_valid_refcounts_cb(duk_heap *heap, duk_heaphdr *h) {
 	/* Cannot really assert much w.r.t. refcounts now. */
 
 	DUK_UNREF(heap);
-	if (DUK_HEAPHDR_GET_REFCOUNT(h) == 0 &&
-	    DUK_HEAPHDR_HAS_FINALIZED(h)) {
+	if (DUK_HEAPHDR_GET_REFCOUNT(h) == 0 && DUK_HEAPHDR_HAS_FINALIZED(h)) {
 		/* An object may be in heap_allocated list with a zero
 		 * refcount if it has just been finalized and is waiting
 		 * to be collected by the next cycle.
 		 * (This doesn't currently happen however.)
 		 */
 	} else if (DUK_HEAPHDR_GET_REFCOUNT(h) == 0) {
 		/* An object may be in heap_allocated list with a zero
 		 * refcount also if it is a temporary object created
 		 * during debugger paused state.  It will get collected
 		 * by mark-and-sweep based on its reachability status
 		 * (presumably not reachable because refcount is 0).
 		 */
 	}
-	DUK_ASSERT_DISABLE(DUK_HEAPHDR_GET_REFCOUNT(h) >= 0);  /* Unsigned. */
+	DUK_ASSERT_DISABLE(DUK_HEAPHDR_GET_REFCOUNT(h) >= 0); /* Unsigned. */
 }
 DUK_LOCAL void duk__assert_valid_refcounts(duk_heap *heap) {
 	duk__assert_walk_list(heap, heap->heap_allocated, duk__assert_valid_refcounts_cb);
 }
 
 DUK_LOCAL void duk__clear_assert_refcounts_cb1(duk_heap *heap, duk_heaphdr *h) {
 	DUK_UNREF(heap);
@@ -52252,16 +53254,18 @@
 	expect_refc = hdr->h_assert_refcount;
 	if (DUK_HEAPHDR_IS_STRING(hdr) && DUK_HSTRING_HAS_PINNED_LITERAL((duk_hstring *) hdr)) {
 		expect_refc++;
 	}
 	count_ok = ((duk_size_t) DUK_HEAPHDR_GET_REFCOUNT(hdr) == expect_refc);
 	if (!count_ok) {
 		DUK_D(DUK_DPRINT("refcount mismatch for: %p: header=%ld counted=%ld --> %!iO",
-		                 (void *) hdr, (long) DUK_HEAPHDR_GET_REFCOUNT(hdr),
-		                 (long) hdr->h_assert_refcount, hdr));
+		                 (void *) hdr,
+		                 (long) DUK_HEAPHDR_GET_REFCOUNT(hdr),
+		                 (long) hdr->h_assert_refcount,
+		                 hdr));
 		DUK_ASSERT(0);
 	}
 }
 
 DUK_LOCAL void duk__check_assert_refcounts_cb1(duk_heap *heap, duk_heaphdr *h) {
 	DUK_UNREF(heap);
 	duk__check_refcount_heaphdr(h);
@@ -52274,15 +53278,15 @@
 	duk__assert_walk_list(heap, heap->heap_allocated, duk__check_assert_refcounts_cb1);
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	duk__assert_walk_list(heap, heap->finalize_list, duk__check_assert_refcounts_cb1);
 #endif
 	/* XXX: Assert anything for refzero_list? */
 	duk__assert_walk_strtable(heap, duk__check_assert_refcounts_cb2);
 }
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 #if defined(DUK_USE_LITCACHE_SIZE)
 DUK_LOCAL void duk__assert_litcache_nulls(duk_heap *heap) {
 	duk_uint_t i;
 	duk_litcache_entry *e;
 
 	e = heap->litcache;
@@ -52290,75 +53294,90 @@
 		/* Entry addresses were NULLed before mark-and-sweep, check
 		 * that they're still NULL afterwards to ensure no pointers
 		 * were recorded through any side effects.
 		 */
 		DUK_ASSERT(e->addr == NULL);
 	}
 }
-#endif  /* DUK_USE_LITCACHE_SIZE */
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_LITCACHE_SIZE */
+#endif /* DUK_USE_ASSERTIONS */
 
 /*
  *  Stats dump.
  */
 
 #if defined(DUK_USE_DEBUG)
 DUK_LOCAL void duk__dump_stats(duk_heap *heap) {
 	DUK_D(DUK_DPRINT("stats executor: opcodes=%ld, interrupt=%ld, throw=%ld",
-	                 (long) heap->stats_exec_opcodes, (long) heap->stats_exec_interrupt,
+	                 (long) heap->stats_exec_opcodes,
+	                 (long) heap->stats_exec_interrupt,
 	                 (long) heap->stats_exec_throw));
 	DUK_D(DUK_DPRINT("stats call: all=%ld, tailcall=%ld, ecmatoecma=%ld",
-	                 (long) heap->stats_call_all, (long) heap->stats_call_tailcall,
+	                 (long) heap->stats_call_all,
+	                 (long) heap->stats_call_tailcall,
 	                 (long) heap->stats_call_ecmatoecma));
 	DUK_D(DUK_DPRINT("stats safecall: all=%ld, nothrow=%ld, throw=%ld",
-	                 (long) heap->stats_safecall_all, (long) heap->stats_safecall_nothrow,
+	                 (long) heap->stats_safecall_all,
+	                 (long) heap->stats_safecall_nothrow,
 	                 (long) heap->stats_safecall_throw));
 	DUK_D(DUK_DPRINT("stats mark-and-sweep: try_count=%ld, skip_count=%ld, emergency_count=%ld",
-	                 (long) heap->stats_ms_try_count, (long) heap->stats_ms_skip_count,
+	                 (long) heap->stats_ms_try_count,
+	                 (long) heap->stats_ms_skip_count,
 	                 (long) heap->stats_ms_emergency_count));
 	DUK_D(DUK_DPRINT("stats stringtable: intern_hit=%ld, intern_miss=%ld, "
 	                 "resize_check=%ld, resize_grow=%ld, resize_shrink=%ld, "
 	                 "litcache_hit=%ld, litcache_miss=%ld, litcache_pin=%ld",
-	                 (long) heap->stats_strtab_intern_hit, (long) heap->stats_strtab_intern_miss,
-	                 (long) heap->stats_strtab_resize_check, (long) heap->stats_strtab_resize_grow,
-	                 (long) heap->stats_strtab_resize_shrink, (long) heap->stats_strtab_litcache_hit,
-	                 (long) heap->stats_strtab_litcache_miss, (long) heap->stats_strtab_litcache_pin));
+	                 (long) heap->stats_strtab_intern_hit,
+	                 (long) heap->stats_strtab_intern_miss,
+	                 (long) heap->stats_strtab_resize_check,
+	                 (long) heap->stats_strtab_resize_grow,
+	                 (long) heap->stats_strtab_resize_shrink,
+	                 (long) heap->stats_strtab_litcache_hit,
+	                 (long) heap->stats_strtab_litcache_miss,
+	                 (long) heap->stats_strtab_litcache_pin));
 	DUK_D(DUK_DPRINT("stats object: realloc_props=%ld, abandon_array=%ld",
-	                 (long) heap->stats_object_realloc_props, (long) heap->stats_object_abandon_array));
+	                 (long) heap->stats_object_realloc_props,
+	                 (long) heap->stats_object_abandon_array));
 	DUK_D(DUK_DPRINT("stats getownpropdesc: count=%ld, hit=%ld, miss=%ld",
-	                 (long) heap->stats_getownpropdesc_count, (long) heap->stats_getownpropdesc_hit,
+	                 (long) heap->stats_getownpropdesc_count,
+	                 (long) heap->stats_getownpropdesc_hit,
 	                 (long) heap->stats_getownpropdesc_miss));
 	DUK_D(DUK_DPRINT("stats getpropdesc: count=%ld, hit=%ld, miss=%ld",
-	                 (long) heap->stats_getpropdesc_count, (long) heap->stats_getpropdesc_hit,
+	                 (long) heap->stats_getpropdesc_count,
+	                 (long) heap->stats_getpropdesc_hit,
 	                 (long) heap->stats_getpropdesc_miss));
 	DUK_D(DUK_DPRINT("stats getprop: all=%ld, arrayidx=%ld, bufobjidx=%ld, "
 	                 "bufferidx=%ld, bufferlen=%ld, stringidx=%ld, stringlen=%ld, "
 	                 "proxy=%ld, arguments=%ld",
-	                 (long) heap->stats_getprop_all, (long) heap->stats_getprop_arrayidx,
-	                 (long) heap->stats_getprop_bufobjidx, (long) heap->stats_getprop_bufferidx,
-	                 (long) heap->stats_getprop_bufferlen, (long) heap->stats_getprop_stringidx,
-	                 (long) heap->stats_getprop_stringlen, (long) heap->stats_getprop_proxy,
+	                 (long) heap->stats_getprop_all,
+	                 (long) heap->stats_getprop_arrayidx,
+	                 (long) heap->stats_getprop_bufobjidx,
+	                 (long) heap->stats_getprop_bufferidx,
+	                 (long) heap->stats_getprop_bufferlen,
+	                 (long) heap->stats_getprop_stringidx,
+	                 (long) heap->stats_getprop_stringlen,
+	                 (long) heap->stats_getprop_proxy,
 	                 (long) heap->stats_getprop_arguments));
 	DUK_D(DUK_DPRINT("stats putprop: all=%ld, arrayidx=%ld, bufobjidx=%ld, "
 	                 "bufferidx=%ld, proxy=%ld",
-	                 (long) heap->stats_putprop_all, (long) heap->stats_putprop_arrayidx,
-	                 (long) heap->stats_putprop_bufobjidx, (long) heap->stats_putprop_bufferidx,
+	                 (long) heap->stats_putprop_all,
+	                 (long) heap->stats_putprop_arrayidx,
+	                 (long) heap->stats_putprop_bufobjidx,
+	                 (long) heap->stats_putprop_bufferidx,
 	                 (long) heap->stats_putprop_proxy));
-	DUK_D(DUK_DPRINT("stats getvar: all=%ld",
-	                 (long) heap->stats_getvar_all));
-	DUK_D(DUK_DPRINT("stats putvar: all=%ld",
-	                 (long) heap->stats_putvar_all));
+	DUK_D(DUK_DPRINT("stats getvar: all=%ld", (long) heap->stats_getvar_all));
+	DUK_D(DUK_DPRINT("stats putvar: all=%ld", (long) heap->stats_putvar_all));
 	DUK_D(DUK_DPRINT("stats envrec: delayedcreate=%ld, create=%ld, newenv=%ld, oldenv=%ld, pushclosure=%ld",
 	                 (long) heap->stats_envrec_delayedcreate,
 	                 (long) heap->stats_envrec_create,
 	                 (long) heap->stats_envrec_newenv,
 	                 (long) heap->stats_envrec_oldenv,
 	                 (long) heap->stats_envrec_pushclosure));
 }
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 /*
  *  Main mark-and-sweep function.
  *
  *  'flags' represents the features requested by the caller.  The current
  *  heap->ms_base_flags is ORed automatically into the flags; the base flags
  *  mask typically prevents certain mark-and-sweep operation to avoid trouble.
@@ -52389,26 +53408,27 @@
 	 * pending.
 	 */
 	if (heap->ms_prevent_count != 0) {
 		DUK_DD(DUK_DDPRINT("reject recursive mark-and-sweep"));
 		DUK_STATS_INC(heap, stats_ms_skip_count);
 		return;
 	}
-	DUK_ASSERT(heap->ms_running == 0);  /* ms_prevent_count is bumped when ms_running is set */
+	DUK_ASSERT(heap->ms_running == 0); /* ms_prevent_count is bumped when ms_running is set */
 
 	/* Heap_thread is used during mark-and-sweep for refcount finalization
 	 * (it's also used for finalizer execution once mark-and-sweep is
 	 * complete).  Heap allocation code ensures heap_thread is set and
 	 * properly initialized before setting ms_prevent_count to 0.
 	 */
 	DUK_ASSERT(heap->heap_thread != NULL);
 	DUK_ASSERT(heap->heap_thread->valstack != NULL);
 
 	DUK_D(DUK_DPRINT("garbage collect (mark-and-sweep) starting, requested flags: 0x%08lx, effective flags: 0x%08lx",
-	                 (unsigned long) flags, (unsigned long) (flags | heap->ms_base_flags)));
+	                 (unsigned long) flags,
+	                 (unsigned long) (flags | heap->ms_base_flags)));
 
 	flags |= heap->ms_base_flags;
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	if (heap->finalize_list != NULL) {
 		flags |= DUK_MS_FLAG_POSTPONE_RESCUE;
 	}
 #endif
@@ -52426,16 +53446,16 @@
 	duk__assert_heaphdr_flags(heap);
 	duk__assert_validity(heap);
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	/* Note: heap->refzero_free_running may be true; a refcount
 	 * finalizer may trigger a mark-and-sweep.
 	 */
 	duk__assert_valid_refcounts(heap);
-#endif  /* DUK_USE_REFERENCE_COUNTING */
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_ASSERTIONS */
 
 	/*
 	 *  Begin
 	 */
 
 	DUK_ASSERT(heap->ms_prevent_count == 0);
 	DUK_ASSERT(heap->ms_running == 0);
@@ -52471,25 +53491,25 @@
 
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_REFERENCE_COUNTING)
 	duk__clear_assert_refcounts(heap);
 #endif
 #if defined(DUK_USE_LITCACHE_SIZE)
 	duk__wipe_litcache(heap);
 #endif
-	duk__mark_roots_heap(heap);               /* Mark main reachability roots. */
+	duk__mark_roots_heap(heap); /* Mark main reachability roots. */
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);   /* Always handled to completion inline in DECREF. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always handled to completion inline in DECREF. */
 #endif
-	duk__mark_temproots_by_heap_scan(heap);   /* Temproots. */
+	duk__mark_temproots_by_heap_scan(heap); /* Temproots. */
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
-	duk__mark_finalizable(heap);              /* Mark finalizable as reachability roots. */
-	duk__mark_finalize_list(heap);            /* Mark finalizer work list as reachability roots. */
+	duk__mark_finalizable(heap); /* Mark finalizable as reachability roots. */
+	duk__mark_finalize_list(heap); /* Mark finalizer work list as reachability roots. */
 #endif
-	duk__mark_temproots_by_heap_scan(heap);   /* Temproots. */
+	duk__mark_temproots_by_heap_scan(heap); /* Temproots. */
 
 	/*
 	 *  Sweep garbage and remove marking flags, and move objects with
 	 *  finalizers to the finalizer work list.
 	 *
 	 *  Objects to be swept need to get their refcounts finalized before
 	 *  they are swept.  In other words, their target object refcounts
@@ -52508,15 +53528,15 @@
 #endif
 	duk__sweep_heap(heap, flags, &count_keep_obj);
 	duk__sweep_stringtable(heap, &count_keep_str);
 #if defined(DUK_USE_ASSERTIONS) && defined(DUK_USE_REFERENCE_COUNTING)
 	duk__check_assert_refcounts(heap);
 #endif
 #if defined(DUK_USE_REFERENCE_COUNTING)
-	DUK_ASSERT(heap->refzero_list == NULL);   /* Always handled to completion inline in DECREF. */
+	DUK_ASSERT(heap->refzero_list == NULL); /* Always handled to completion inline in DECREF. */
 #endif
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	duk__clear_finalize_list_flags(heap);
 #endif
 
 	/*
 	 *  Object compaction (emergency only).
@@ -52535,16 +53555,15 @@
 	 *  cause an infinite loop (they are not compacted).
 	 *
 	 *  At present compaction is not allowed when mark-and-sweep runs
 	 *  during error handling because it involves a duk_safe_call()
 	 *  interfering with error state.
 	 */
 
-	if ((flags & DUK_MS_FLAG_EMERGENCY) &&
-	    !(flags & DUK_MS_FLAG_NO_OBJECT_COMPACTION)) {
+	if ((flags & DUK_MS_FLAG_EMERGENCY) && !(flags & DUK_MS_FLAG_NO_OBJECT_COMPACTION)) {
 		if (heap->lj.type != DUK_LJ_TYPE_UNKNOWN) {
 			DUK_D(DUK_DPRINT("lj.type (%ld) not DUK_LJ_TYPE_UNKNOWN, skip object compaction", (long) heap->lj.type));
 		} else {
 			DUK_D(DUK_DPRINT("object compaction"));
 			duk__compact_objects(heap);
 		}
 	}
@@ -52569,15 +53588,15 @@
 	 *  Finish
 	 */
 
 	DUK_ASSERT(heap->ms_prevent_count == 1);
 	DUK_ASSERT(heap->ms_running == 1);
 	heap->ms_prevent_count = 0;
 	heap->ms_running = 0;
-	heap->creating_error = entry_creating_error;  /* for nested error handling, see GH-2278 */
+	heap->creating_error = entry_creating_error; /* for nested error handling, see GH-2278 */
 
 	/*
 	 *  Assertions after
 	 */
 
 #if defined(DUK_USE_ASSERTIONS)
 	DUK_ASSERT(heap->ms_prevent_count == 0);
@@ -52586,34 +53605,35 @@
 	duk__assert_heaphdr_flags(heap);
 	duk__assert_validity(heap);
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	/* Note: heap->refzero_free_running may be true; a refcount
 	 * finalizer may trigger a mark-and-sweep.
 	 */
 	duk__assert_valid_refcounts(heap);
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 #if defined(DUK_USE_LITCACHE_SIZE)
 	duk__assert_litcache_nulls(heap);
-#endif  /* DUK_USE_LITCACHE_SIZE */
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_LITCACHE_SIZE */
+#endif /* DUK_USE_ASSERTIONS */
 
 	/*
 	 *  Reset trigger counter
 	 */
 
 #if defined(DUK_USE_VOLUNTARY_GC)
 	tmp = (count_keep_obj + count_keep_str) / 256;
-	heap->ms_trigger_counter = (duk_int_t) (
-	    (tmp * DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT) +
-	    DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD);
+	heap->ms_trigger_counter = (duk_int_t) ((tmp * DUK_HEAP_MARK_AND_SWEEP_TRIGGER_MULT) + DUK_HEAP_MARK_AND_SWEEP_TRIGGER_ADD);
 	DUK_D(DUK_DPRINT("garbage collect (mark-and-sweep) finished: %ld objects kept, %ld strings kept, trigger reset to %ld",
-	                 (long) count_keep_obj, (long) count_keep_str, (long) heap->ms_trigger_counter));
+	                 (long) count_keep_obj,
+	                 (long) count_keep_str,
+	                 (long) heap->ms_trigger_counter));
 #else
 	DUK_D(DUK_DPRINT("garbage collect (mark-and-sweep) finished: %ld objects kept, %ld strings kept, no voluntary trigger",
-	                 (long) count_keep_obj, (long) count_keep_str));
+	                 (long) count_keep_obj,
+	                 (long) count_keep_str));
 #endif
 
 	/*
 	 *  Stats dump
 	 */
 
 #if defined(DUK_USE_DEBUG)
@@ -52648,15 +53668,15 @@
 	 */
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 	/* Attempt to process finalize_list, pf_prevent_count check
 	 * is inside the target.
 	 */
 	duk_heap_process_finalize_list(heap);
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 }
 #line 1 "duk_heap_memory.c"
 /*
  *  Memory allocation handling.
  */
 
 /* #include duk_internal.h -> already included */
@@ -52711,15 +53731,16 @@
 
 		duk_heap_mark_and_sweep(heap, flags);
 
 		DUK_ASSERT(size > 0);
 		res = heap->alloc_func(heap->heap_udata, size);
 		if (res != NULL) {
 			DUK_D(DUK_DPRINT("duk_heap_mem_alloc() succeeded after gc (pass %ld), alloc size %ld",
-			                 (long) (i + 1), (long) size));
+			                 (long) (i + 1),
+			                 (long) size));
 			return res;
 		}
 	}
 
 	DUK_D(DUK_DPRINT("duk_heap_mem_alloc() failed even after gc, alloc size %ld", (long) size));
 	return NULL;
 }
@@ -52755,15 +53776,15 @@
 	 * instead.  This reduces size of inlined code.
 	 */
 	res = heap->alloc_func(heap->heap_udata, size);
 	if (DUK_LIKELY(res != NULL)) {
 		return res;
 	}
 
- slowpath:
+slowpath:
 
 	if (size == 0) {
 		DUK_D(DUK_DPRINT("first alloc attempt returned NULL for zero size alloc, use slow path to deal with it"));
 	} else {
 		DUK_D(DUK_DPRINT("first alloc attempt failed, attempt to gc and retry"));
 	}
 	return duk__heap_mem_alloc_slowpath(heap, size);
@@ -52830,21 +53851,15 @@
 	duk_small_int_t i;
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(heap->realloc_func != NULL);
 	/* ptr may be NULL */
 	DUK_ASSERT_DISABLE(newsize >= 0);
 
-	/* Newsize was 0 and realloc() returned NULL, this has the semantics
-	 * of free(oldptr), i.e. memory was successfully freed.
-	 */
-	if (newsize == 0) {
-		DUK_D(DUK_DPRINT("zero size realloc in slow path, return NULL"));
-		return NULL;
-	}
+	/* Unlike for malloc(), zero size NULL result check happens at the call site. */
 
 	DUK_D(DUK_DPRINT("first realloc attempt failed, attempt to gc and retry"));
 
 #if 0
 	/*
 	 *  Avoid a GC if GC is already running.  See duk_heap_mem_alloc().
 	 */
@@ -52867,19 +53882,19 @@
 		flags = 0;
 		if (i >= DUK_HEAP_ALLOC_FAIL_MARKANDSWEEP_EMERGENCY_LIMIT - 1) {
 			flags |= DUK_MS_FLAG_EMERGENCY;
 		}
 
 		duk_heap_mark_and_sweep(heap, flags);
 
-		DUK_ASSERT(newsize > 0);
 		res = heap->realloc_func(heap->heap_udata, ptr, newsize);
-		if (res || newsize == 0) {
+		if (res != NULL || newsize == 0) {
 			DUK_D(DUK_DPRINT("duk_heap_mem_realloc() succeeded after gc (pass %ld), alloc size %ld",
-			                 (long) (i + 1), (long) newsize));
+			                 (long) (i + 1),
+			                 (long) newsize));
 			return res;
 		}
 	}
 
 	DUK_D(DUK_DPRINT("duk_heap_mem_realloc() failed even after gc, alloc size %ld", (long) newsize));
 	return NULL;
 }
@@ -52891,64 +53906,64 @@
 	DUK_ASSERT(heap->realloc_func != NULL);
 	/* ptr may be NULL */
 	DUK_ASSERT_DISABLE(newsize >= 0);
 
 #if defined(DUK_USE_VOLUNTARY_GC)
 	/* Voluntary periodic GC (if enabled). */
 	if (DUK_UNLIKELY(--(heap)->ms_trigger_counter < 0)) {
-		goto slowpath;
+		goto gc_retry;
 	}
 #endif
 
 #if defined(DUK_USE_GC_TORTURE)
 	/* Simulate alloc failure on every realloc, except when mark-and-sweep
 	 * is running.
 	 */
 	if (heap->ms_prevent_count == 0) {
 		DUK_DDD(DUK_DDDPRINT("gc torture enabled, pretend that first realloc attempt fails"));
 		res = NULL;
 		DUK_UNREF(res);
-		goto slowpath;
+		goto gc_retry;
 	}
 #endif
 
 	res = heap->realloc_func(heap->heap_udata, ptr, newsize);
-	if (DUK_LIKELY(res != NULL)) {
+	if (DUK_LIKELY(res != NULL) || newsize == 0) {
+		if (res != NULL && newsize == 0) {
+			DUK_DD(DUK_DDPRINT("first realloc attempt returned NULL for zero size realloc, accept and return NULL"));
+		}
 		return res;
-	}
-
- slowpath:
-
-	if (newsize == 0) {
-		DUK_D(DUK_DPRINT("first realloc attempt returned NULL for zero size realloc, use slow path to deal with it"));
 	} else {
-		DUK_D(DUK_DPRINT("first realloc attempt failed, attempt to gc and retry"));
+		goto gc_retry;
 	}
+	/* Never here. */
+
+gc_retry:
 	return duk__heap_mem_realloc_slowpath(heap, ptr, newsize);
 }
 
 /*
  *  Reallocate memory with garbage collection, using a callback to provide
  *  the current allocated pointer.  This variant is used when a mark-and-sweep
  *  (e.g. finalizers) might change the original pointer.
  */
 
 /* Slow path: voluntary GC triggered, first realloc attempt failed, or zero size. */
-DUK_LOCAL DUK_NOINLINE_PERF DUK_COLD void *duk__heap_mem_realloc_indirect_slowpath(duk_heap *heap, duk_mem_getptr cb, void *ud, duk_size_t newsize) {
+DUK_LOCAL DUK_NOINLINE_PERF DUK_COLD void *duk__heap_mem_realloc_indirect_slowpath(duk_heap *heap,
+                                                                                   duk_mem_getptr cb,
+                                                                                   void *ud,
+                                                                                   duk_size_t newsize) {
 	void *res;
 	duk_small_int_t i;
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(heap->realloc_func != NULL);
 	DUK_ASSERT_DISABLE(newsize >= 0);
 
-	if (newsize == 0) {
-		DUK_D(DUK_DPRINT("zero size indirect realloc in slow path, return NULL"));
-		return NULL;
-	}
+	/* Unlike for malloc(), zero size NULL result check happens at the call site. */
 
 	DUK_D(DUK_DPRINT("first indirect realloc attempt failed, attempt to gc and retry"));
 
 #if 0
 	/*
 	 *  Avoid a GC if GC is already running.  See duk_heap_mem_alloc().
 	 */
@@ -52982,73 +53997,78 @@
 		}
 
 		duk_heap_mark_and_sweep(heap, flags);
 #if defined(DUK_USE_DEBUG)
 		ptr_post = cb(heap, ud);
 		if (ptr_pre != ptr_post) {
 			DUK_DD(DUK_DDPRINT("realloc base pointer changed by mark-and-sweep: %p -> %p",
-			                   (void *) ptr_pre, (void *) ptr_post));
+			                   (void *) ptr_pre,
+			                   (void *) ptr_post));
 		}
 #endif
 
 		/* Note: key issue here is to re-lookup the base pointer on every attempt.
 		 * The pointer being reallocated may change after every mark-and-sweep.
 		 */
 
-		DUK_ASSERT(newsize > 0);
 		res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
-		if (res || newsize == 0) {
+		if (res != NULL || newsize == 0) {
 			DUK_D(DUK_DPRINT("duk_heap_mem_realloc_indirect() succeeded after gc (pass %ld), alloc size %ld",
-			                 (long) (i + 1), (long) newsize));
+			                 (long) (i + 1),
+			                 (long) newsize));
 			return res;
 		}
 	}
 
 	DUK_D(DUK_DPRINT("duk_heap_mem_realloc_indirect() failed even after gc, alloc size %ld", (long) newsize));
 	return NULL;
 }
 
-DUK_INTERNAL DUK_INLINE_PERF DUK_HOT void *duk_heap_mem_realloc_indirect(duk_heap *heap, duk_mem_getptr cb, void *ud, duk_size_t newsize) {
+DUK_INTERNAL DUK_INLINE_PERF DUK_HOT void *duk_heap_mem_realloc_indirect(duk_heap *heap,
+                                                                         duk_mem_getptr cb,
+                                                                         void *ud,
+                                                                         duk_size_t newsize) {
 	void *res;
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(heap->realloc_func != NULL);
 	DUK_ASSERT_DISABLE(newsize >= 0);
 
 #if defined(DUK_USE_VOLUNTARY_GC)
 	/* Voluntary periodic GC (if enabled). */
 	if (DUK_UNLIKELY(--(heap)->ms_trigger_counter < 0)) {
-		goto slowpath;
+		goto gc_retry;
 	}
 #endif
 
 #if defined(DUK_USE_GC_TORTURE)
 	/* Simulate alloc failure on every realloc, except when mark-and-sweep
 	 * is running.
 	 */
 	if (heap->ms_prevent_count == 0) {
 		DUK_DDD(DUK_DDDPRINT("gc torture enabled, pretend that first indirect realloc attempt fails"));
 		res = NULL;
 		DUK_UNREF(res);
-		goto slowpath;
+		goto gc_retry;
 	}
 #endif
 
 	res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
-	if (DUK_LIKELY(res != NULL)) {
+	if (DUK_LIKELY(res != NULL) || newsize == 0) {
+		if (res != NULL && newsize == 0) {
+			DUK_DD(DUK_DDPRINT(
+			    "first indirect realloc attempt returned NULL for zero size realloc, accept and return NULL"));
+		}
 		return res;
-	}
-
- slowpath:
-
-	if (newsize == 0) {
-		DUK_D(DUK_DPRINT("first indirect realloc attempt returned NULL for zero size realloc, use slow path to deal with it"));
 	} else {
-		DUK_D(DUK_DPRINT("first indirect realloc attempt failed, attempt to gc and retry"));
+		goto gc_retry;
 	}
+	/* Never here. */
+
+gc_retry:
 	return duk__heap_mem_realloc_indirect_slowpath(heap, cb, ud, newsize);
 }
 
 /*
  *  Free memory
  */
 
@@ -53130,15 +54150,15 @@
 	}
 	if (next != NULL) {
 		DUK_HEAPHDR_SET_PREV(heap, next, prev);
 	} else {
 		;
 	}
 }
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_INTERNAL void duk_heap_insert_into_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {
 	duk_heaphdr *root;
 
 	root = heap->finalize_list;
 #if defined(DUK_USE_DOUBLE_LINKED_HEAP)
@@ -53149,15 +54169,15 @@
 	}
 #endif
 	DUK_HEAPHDR_SET_NEXT(heap, hdr, root);
 	DUK_HEAPHDR_ASSERT_LINKS(heap, hdr);
 	DUK_HEAPHDR_ASSERT_LINKS(heap, root);
 	heap->finalize_list = hdr;
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_INTERNAL void duk_heap_remove_from_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {
 #if defined(DUK_USE_DOUBLE_LINKED_HEAP)
 	duk_heaphdr *next;
 	duk_heaphdr *prev;
 
@@ -53183,41 +54203,41 @@
 	 */
 	curr = heap->finalize_list;
 	if (curr == hdr) {
 		heap->finalize_list = DUK_HEAPHDR_GET_NEXT(heap, curr);
 	} else {
 		DUK_ASSERT(hdr != heap->finalize_list);
 		for (;;) {
-			DUK_ASSERT(curr != NULL);  /* Caller responsibility. */
+			DUK_ASSERT(curr != NULL); /* Caller responsibility. */
 
 			next = DUK_HEAPHDR_GET_NEXT(heap, curr);
 			if (next == hdr) {
 				next = DUK_HEAPHDR_GET_NEXT(heap, hdr);
 				DUK_HEAPHDR_SET_NEXT(heap, curr, next);
 				break;
 			}
 		}
 	}
 #endif
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL duk_bool_t duk_heap_in_heap_allocated(duk_heap *heap, duk_heaphdr *ptr) {
 	duk_heaphdr *curr;
 	DUK_ASSERT(heap != NULL);
 
 	for (curr = heap->heap_allocated; curr != NULL; curr = DUK_HEAPHDR_GET_NEXT(heap, curr)) {
 		if (curr == ptr) {
 			return 1;
 		}
 	}
 	return 0;
 }
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
 #if defined(DUK_USE_INTERRUPT_COUNTER)
 DUK_INTERNAL void duk_heap_switch_thread(duk_heap *heap, duk_hthread *new_thr) {
 	duk_hthread *curr_thr;
 
 	DUK_ASSERT(heap != NULL);
 
@@ -53242,17 +54262,17 @@
 			new_thr->interrupt_counter = curr_thr->interrupt_counter;
 			new_thr->interrupt_init = curr_thr->interrupt_init;
 		}
 	} else {
 		DUK_DD(DUK_DDPRINT("switch thread, new thread is NULL, no interrupt counter changes"));
 	}
 
-	heap->curr_thread = new_thr;  /* may be NULL */
+	heap->curr_thread = new_thr; /* may be NULL */
 }
-#endif  /* DUK_USE_INTERRUPT_COUNTER */
+#endif /* DUK_USE_INTERRUPT_COUNTER */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL void duk_heap_assert_valid(duk_heap *heap) {
 	DUK_ASSERT(heap != NULL);
 }
 #endif
 #line 1 "duk_heap_refcount.c"
@@ -53414,36 +54434,36 @@
 		duk_hdecenv *e = (duk_hdecenv *) h;
 		DUK_HDECENV_ASSERT_VALID(e);
 		DUK_HTHREAD_DECREF_NORZ_ALLOWNULL(thr, e->thread);
 		DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, e->varmap);
 	} else if (DUK_HOBJECT_IS_OBJENV(h)) {
 		duk_hobjenv *e = (duk_hobjenv *) h;
 		DUK_HOBJENV_ASSERT_VALID(e);
-		DUK_ASSERT(e->target != NULL);  /* Required for object environments. */
+		DUK_ASSERT(e->target != NULL); /* Required for object environments. */
 		DUK_HOBJECT_DECREF_NORZ(thr, e->target);
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	} else if (DUK_HOBJECT_IS_BUFOBJ(h)) {
 		duk_hbufobj *b = (duk_hbufobj *) h;
 		DUK_HBUFOBJ_ASSERT_VALID(b);
 		DUK_HBUFFER_DECREF_NORZ_ALLOWNULL(thr, (duk_hbuffer *) b->buf);
 		DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) b->buf_prop);
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 	} else if (DUK_HOBJECT_IS_BOUNDFUNC(h)) {
 		duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
 		DUK_HBOUNDFUNC_ASSERT_VALID(f);
 		DUK_TVAL_DECREF_NORZ(thr, &f->target);
 		DUK_TVAL_DECREF_NORZ(thr, &f->this_binding);
 		duk__decref_tvals_norz(thr, f->args, f->nargs);
 #if defined(DUK_USE_ES6_PROXY)
 	} else if (DUK_HOBJECT_IS_PROXY(h)) {
 		duk_hproxy *p = (duk_hproxy *) h;
 		DUK_HPROXY_ASSERT_VALID(p);
 		DUK_HOBJECT_DECREF_NORZ(thr, p->target);
 		DUK_HOBJECT_DECREF_NORZ(thr, p->handler);
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 	} else if (DUK_HOBJECT_IS_THREAD(h)) {
 		duk_hthread *t = (duk_hthread *) h;
 		duk_activation *act;
 		duk_tval *tv;
 
 		DUK_HTHREAD_ASSERT_VALID(t);
 
@@ -53456,21 +54476,20 @@
 		for (act = t->callstack_curr; act != NULL; act = act->parent) {
 			DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) DUK_ACT_GET_FUNC(act));
 			DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) act->var_env);
 			DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) act->lex_env);
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 			DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) act->prev_caller);
 #endif
-#if 0  /* nothing now */
+#if 0 /* nothing now */
 			for (cat = act->cat; cat != NULL; cat = cat->parent) {
 			}
 #endif
 		}
 
-
 		for (i = 0; i < DUK_NUM_BUILTINS; i++) {
 			DUK_HOBJECT_DECREF_NORZ_ALLOWNULL(thr, (duk_hobject *) t->builtins[i]);
 		}
 
 		DUK_HTHREAD_DECREF_NORZ_ALLOWNULL(thr, (duk_hthread *) t->resumer);
 	} else {
 		/* We may come here if the object should have a FASTREFS flag
@@ -53547,42 +54566,41 @@
 	duk_int_t count = 0;
 #endif
 
 	DUK_ASSERT(heap != NULL);
 
 	curr = heap->refzero_list;
 	DUK_ASSERT(curr != NULL);
-	DUK_ASSERT(DUK_HEAPHDR_GET_PREV(heap, curr) == NULL);  /* We're called on initial insert only. */
+	DUK_ASSERT(DUK_HEAPHDR_GET_PREV(heap, curr) == NULL); /* We're called on initial insert only. */
 	/* curr->next is GARBAGE. */
 
 	do {
 		duk_heaphdr *prev;
 
 		DUK_DDD(DUK_DDDPRINT("refzero processing %p: %!O", (void *) curr, (duk_heaphdr *) curr));
 
 #if defined(DUK_USE_DEBUG)
 		count++;
 #endif
 
 		DUK_ASSERT(curr != NULL);
-		DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT);  /* currently, always the case */
+		DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(curr) == DUK_HTYPE_OBJECT); /* currently, always the case */
 		/* FINALIZED may be set; don't care about flags here. */
 
 		/* Refcount finalize 'curr'.  Refzero_list must be non-NULL
 		 * here to prevent recursive entry to duk__refcount_free_pending().
 		 */
 		DUK_ASSERT(heap->refzero_list != NULL);
 		duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);
 
 		prev = DUK_HEAPHDR_GET_PREV(heap, curr);
-		DUK_ASSERT((prev == NULL && heap->refzero_list == curr) || \
-		           (prev != NULL && heap->refzero_list != curr));
+		DUK_ASSERT((prev == NULL && heap->refzero_list == curr) || (prev != NULL && heap->refzero_list != curr));
 		/* prev->next is intentionally not updated and is garbage. */
 
-		duk_free_hobject(heap, (duk_hobject *) curr);  /* Invalidates 'curr'. */
+		duk_free_hobject(heap, (duk_hobject *) curr); /* Invalidates 'curr'. */
 
 		curr = prev;
 	} while (curr != NULL);
 
 	heap->refzero_list = NULL;
 
 	DUK_DD(DUK_DDPRINT("refzero processed %ld objects", (long) count));
@@ -53650,15 +54668,15 @@
 			 */
 			if (!skip_free_pending && heap->refzero_list == NULL) {
 				duk_heap_process_finalize_list(heap);
 			}
 			return;
 		}
 	}
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 	/* No need to finalize, free object via refzero_list. */
 
 	root = heap->refzero_list;
 
 	DUK_HEAPHDR_SET_PREV(heap, hdr, NULL);
 	/* 'next' is left as GARBAGE. */
@@ -53694,31 +54712,31 @@
 	}
 }
 
 #if defined(DUK_USE_FINALIZER_SUPPORT)
 DUK_INTERNAL DUK_ALWAYS_INLINE void duk_refzero_check_fast(duk_hthread *thr) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
-	DUK_ASSERT(thr->heap->refzero_list == NULL);  /* Processed to completion inline. */
+	DUK_ASSERT(thr->heap->refzero_list == NULL); /* Processed to completion inline. */
 
 	if (DUK_UNLIKELY(thr->heap->finalize_list != NULL)) {
 		duk_heap_process_finalize_list(thr->heap);
 	}
 }
 
 DUK_INTERNAL void duk_refzero_check_slow(duk_hthread *thr) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
-	DUK_ASSERT(thr->heap->refzero_list == NULL);  /* Processed to completion inline. */
+	DUK_ASSERT(thr->heap->refzero_list == NULL); /* Processed to completion inline. */
 
 	if (DUK_UNLIKELY(thr->heap->finalize_list != NULL)) {
 		duk_heap_process_finalize_list(thr->heap);
 	}
 }
-#endif  /* DUK_USE_FINALIZER_SUPPORT */
+#endif /* DUK_USE_FINALIZER_SUPPORT */
 
 /*
  *  Refzero processing for duk_hstring.
  */
 
 DUK_LOCAL DUK_INLINE void duk__refcount_refzero_hstring(duk_heap *heap, duk_hstring *str) {
 	DUK_ASSERT(heap != NULL);
@@ -53770,15 +54788,16 @@
  *  The DUK__RZ_SUPPRESS_CHECK() condition is also used in heap destruction
  *  when running finalizers for remaining objects: the flag prevents objects
  *  from being moved around in heap linked lists while that's being done.
  *
  *  The suppress condition is important to performance.
  */
 
-#define DUK__RZ_SUPPRESS_ASSERT1() do { \
+#define DUK__RZ_SUPPRESS_ASSERT1() \
+	do { \
 		DUK_ASSERT(thr != NULL); \
 		DUK_ASSERT(thr->heap != NULL); \
 		/* When mark-and-sweep runs, heap_thread must exist. */ \
 		DUK_ASSERT(thr->heap->ms_running == 0 || thr->heap->heap_thread != NULL); \
 		/* In normal operation finalizers are executed with ms_running == 0 \
 		 * so we should never see ms_running == 1 and thr != heap_thread. \
 		 * In heap destruction finalizers are executed with ms_running != 0 \
@@ -53792,40 +54811,49 @@
 		 * if that's the case. \
 		 */ \
 		DUK_ASSERT(thr->heap->heap_initializing == 0 || thr->heap->ms_prevent_count > 0); \
 		DUK_ASSERT(thr->heap->heap_initializing == 0 || thr->heap->pf_prevent_count > 0); \
 	} while (0)
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
-#define DUK__RZ_SUPPRESS_ASSERT2() do { \
+#define DUK__RZ_SUPPRESS_ASSERT2() \
+	do { \
 		/* When debugger is paused, ms_running is set. */ \
 		DUK_ASSERT(!DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap) || thr->heap->ms_running != 0); \
 	} while (0)
-#define DUK__RZ_SUPPRESS_COND()  (heap->ms_running != 0)
+#define DUK__RZ_SUPPRESS_COND() (heap->ms_running != 0)
 #else
-#define DUK__RZ_SUPPRESS_ASSERT2() do { } while (0)
-#define DUK__RZ_SUPPRESS_COND()  (heap->ms_running != 0)
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#define DUK__RZ_SUPPRESS_ASSERT2() \
+	do { \
+	} while (0)
+#define DUK__RZ_SUPPRESS_COND() (heap->ms_running != 0)
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
-#define DUK__RZ_SUPPRESS_CHECK() do { \
+#define DUK__RZ_SUPPRESS_CHECK() \
+	do { \
 		DUK__RZ_SUPPRESS_ASSERT1(); \
 		DUK__RZ_SUPPRESS_ASSERT2(); \
 		if (DUK_UNLIKELY(DUK__RZ_SUPPRESS_COND())) { \
-			DUK_DDD(DUK_DDDPRINT("refzero handling suppressed (not even queued) when mark-and-sweep running, object: %p", (void *) h)); \
+			DUK_DDD( \
+			    DUK_DDDPRINT("refzero handling suppressed (not even queued) when mark-and-sweep running, object: %p", \
+			                 (void *) h)); \
 			return; \
 		} \
 	} while (0)
 
-#define DUK__RZ_STRING() do { \
+#define DUK__RZ_STRING() \
+	do { \
 		duk__refcount_refzero_hstring(heap, (duk_hstring *) h); \
 	} while (0)
-#define DUK__RZ_BUFFER() do { \
+#define DUK__RZ_BUFFER() \
+	do { \
 		duk__refcount_refzero_hbuffer(heap, (duk_hbuffer *) h); \
 	} while (0)
-#define DUK__RZ_OBJECT() do { \
+#define DUK__RZ_OBJECT() \
+	do { \
 		duk__refcount_refzero_hobject(heap, (duk_hobject *) h, skip_free_pending); \
 	} while (0)
 
 /* XXX: test the effect of inlining here vs. NOINLINE in refzero helpers */
 #if defined(DUK_USE_FAST_REFCOUNT_DEFAULT)
 #define DUK__RZ_INLINE DUK_ALWAYS_INLINE
 #else
@@ -53938,15 +54966,15 @@
 
 	if (DUK_TVAL_NEEDS_REFCOUNT_UPDATE(tv)) {
 		duk_heaphdr *h = DUK_TVAL_GET_HEAPHDR(tv);
 		DUK_ASSERT(h != NULL);
 		DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID(h));
 		DUK_ASSERT_DISABLE(h->h_refcount >= 0);
 		DUK_HEAPHDR_PREINC_REFCOUNT(h);
-		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(h) != 0);  /* No wrapping. */
+		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT(h) != 0); /* No wrapping. */
 	}
 }
 
 DUK_INTERNAL void duk_tval_decref(duk_hthread *thr, duk_tval *tv) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(tv != NULL);
 
@@ -53981,45 +55009,50 @@
 		}
 		duk_heaphdr_refzero_norz(thr, h);
 #else
 		duk_heaphdr_decref_norz(thr, h);
 #endif
 	}
 }
-#endif  /* !DUK_USE_FAST_REFCOUNT_DEFAULT */
+#endif /* !DUK_USE_FAST_REFCOUNT_DEFAULT */
 
-#define DUK__DECREF_ASSERTS() do { \
+#define DUK__DECREF_ASSERTS() \
+	do { \
 		DUK_ASSERT(thr != NULL); \
 		DUK_ASSERT(thr->heap != NULL); \
 		DUK_ASSERT(h != NULL); \
 		DUK_ASSERT(DUK_HEAPHDR_HTYPE_VALID((duk_heaphdr *) h)); \
 		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) >= 1); \
 	} while (0)
 #if defined(DUK_USE_ROM_OBJECTS)
-#define DUK__INCREF_SHARED() do { \
+#define DUK__INCREF_SHARED() \
+	do { \
 		if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) h)) { \
 			return; \
 		} \
 		DUK_HEAPHDR_PREINC_REFCOUNT((duk_heaphdr *) h); \
-		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) != 0);  /* No wrapping. */ \
+		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) != 0); /* No wrapping. */ \
 	} while (0)
-#define DUK__DECREF_SHARED() do { \
+#define DUK__DECREF_SHARED() \
+	do { \
 		if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) h)) { \
 			return; \
 		} \
 		if (DUK_HEAPHDR_PREDEC_REFCOUNT((duk_heaphdr *) h) != 0) { \
 			return; \
 		} \
 	} while (0)
 #else
-#define DUK__INCREF_SHARED() do { \
+#define DUK__INCREF_SHARED() \
+	do { \
 		DUK_HEAPHDR_PREINC_REFCOUNT((duk_heaphdr *) h); \
-		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) != 0);  /* No wrapping. */ \
+		DUK_ASSERT(DUK_HEAPHDR_GET_REFCOUNT((duk_heaphdr *) h) != 0); /* No wrapping. */ \
 	} while (0)
-#define DUK__DECREF_SHARED() do { \
+#define DUK__DECREF_SHARED() \
+	do { \
 		if (DUK_HEAPHDR_PREDEC_REFCOUNT((duk_heaphdr *) h) != 0) { \
 			return; \
 		} \
 	} while (0)
 #endif
 
 #if !defined(DUK_USE_FAST_REFCOUNT_DEFAULT)
@@ -54045,17 +55078,17 @@
 	DUK_GC_TORTURE(thr->heap);
 }
 DUK_INTERNAL void duk_heaphdr_decref_norz(duk_hthread *thr, duk_heaphdr *h) {
 	DUK__DECREF_ASSERTS();
 	DUK__DECREF_SHARED();
 	duk_heaphdr_refzero_norz(thr, h);
 }
-#endif  /* !DUK_USE_FAST_REFCOUNT_DEFAULT */
+#endif /* !DUK_USE_FAST_REFCOUNT_DEFAULT */
 
-#if 0  /* Not needed. */
+#if 0 /* Not needed. */
 DUK_INTERNAL void duk_hstring_decref(duk_hthread *thr, duk_hstring *h) {
 	DUK__DECREF_ASSERTS();
 	DUK__DECREF_SHARED();
 	duk_hstring_refzero(thr, h);
 }
 DUK_INTERNAL void duk_hstring_decref_norz(duk_hthread *thr, duk_hstring *h) {
 	DUK__DECREF_ASSERTS();
@@ -54080,19 +55113,19 @@
 DUK_INTERNAL void duk_hobject_decref_norz(duk_hthread *thr, duk_hobject *h) {
 	DUK__DECREF_ASSERTS();
 	DUK__DECREF_SHARED();
 	duk_hobject_refzero_norz(thr, h);
 }
 #endif
 
-#else  /* DUK_USE_REFERENCE_COUNTING */
+#else /* DUK_USE_REFERENCE_COUNTING */
 
 /* no refcounting */
 
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /* automatic undefs */
 #undef DUK__DECREF_ASSERTS
 #undef DUK__DECREF_SHARED
 #undef DUK__INCREF_SHARED
 #undef DUK__RZ_BUFFER
 #undef DUK__RZ_INLINE
@@ -54123,16 +55156,16 @@
  */
 
 DUK_INTERNAL void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h) {
 	duk_uint_t i;
 	for (i = 0; i < DUK_HEAP_STRCACHE_SIZE; i++) {
 		duk_strcache_entry *c = heap->strcache + i;
 		if (c->h == h) {
-			DUK_DD(DUK_DDPRINT("deleting weak strcache reference to hstring %p from heap %p",
-			                   (void *) h, (void *) heap));
+			DUK_DD(
+			    DUK_DDPRINT("deleting weak strcache reference to hstring %p from heap %p", (void *) h, (void *) heap));
 			c->h = NULL;
 
 			/* XXX: the string shouldn't appear twice, but we now loop to the
 			 * end anyway; if fixed, add a looping assertion to ensure there
 			 * is no duplicate.
 			 */
 		}
@@ -54234,29 +55267,33 @@
 	 *
 	 *  For "short" strings we simply scan without checking or updating
 	 *  the cache.  For longer strings we check and update the cache as
 	 *  necessary, inserting a new cache entry if none exists.
 	 */
 
 	DUK_DDD(DUK_DDDPRINT("non-ascii string %p, char_offset=%ld, clen=%ld, blen=%ld",
-	                     (void *) h, (long) char_offset,
+	                     (void *) h,
+	                     (long) char_offset,
 	                     (long) DUK_HSTRING_GET_CHARLEN(h),
 	                     (long) DUK_HSTRING_GET_BYTELEN(h)));
 
 	heap = thr->heap;
 	sce = NULL;
 	use_cache = (char_length > DUK_HEAP_STRINGCACHE_NOCACHE_LIMIT);
 
 	if (use_cache) {
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
 		DUK_DDD(DUK_DDDPRINT("stringcache before char2byte (using cache):"));
 		for (i = 0; i < DUK_HEAP_STRCACHE_SIZE; i++) {
 			duk_strcache_entry *c = heap->strcache + i;
 			DUK_DDD(DUK_DDDPRINT("  [%ld] -> h=%p, cidx=%ld, bidx=%ld",
-			                     (long) i, (void *) c->h, (long) c->cidx, (long) c->bidx));
+			                     (long) i,
+			                     (void *) c->h,
+			                     (long) c->cidx,
+			                     (long) c->bidx));
 		}
 #endif
 
 		for (i = 0; i < DUK_HEAP_STRCACHE_SIZE; i++) {
 			duk_strcache_entry *c = heap->strcache + i;
 
 			if (c->h == h) {
@@ -54272,110 +55309,114 @@
 	 *    - end of string
 	 *    - cache entry (if exists)
 	 */
 
 	DUK_ASSERT(DUK_HSTRING_GET_CHARLEN(h) >= char_offset);
 	dist_start = char_offset;
 	dist_end = char_length - char_offset;
-	dist_sce = 0; DUK_UNREF(dist_sce);  /* initialize for debug prints, needed if sce==NULL */
+	dist_sce = 0;
+	DUK_UNREF(dist_sce); /* initialize for debug prints, needed if sce==NULL */
 
 	p_start = (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h);
 	p_end = (const duk_uint8_t *) (p_start + DUK_HSTRING_GET_BYTELEN(h));
 	p_found = NULL;
 
 	if (sce) {
 		if (char_offset >= sce->cidx) {
 			dist_sce = char_offset - sce->cidx;
 			if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
 				DUK_DDD(DUK_DDDPRINT("non-ascii string, use_cache=%ld, sce=%p:%ld:%ld, "
 				                     "dist_start=%ld, dist_end=%ld, dist_sce=%ld => "
 				                     "scan forwards from sce",
-				                     (long) use_cache, (void *) (sce ? sce->h : NULL),
+				                     (long) use_cache,
+				                     (void *) (sce ? sce->h : NULL),
 				                     (sce ? (long) sce->cidx : (long) -1),
 				                     (sce ? (long) sce->bidx : (long) -1),
-				                     (long) dist_start, (long) dist_end, (long) dist_sce));
+				                     (long) dist_start,
+				                     (long) dist_end,
+				                     (long) dist_sce));
 
-				p_found = duk__scan_forwards(p_start + sce->bidx,
-				                             p_end,
-				                             dist_sce);
+				p_found = duk__scan_forwards(p_start + sce->bidx, p_end, dist_sce);
 				goto scan_done;
 			}
 		} else {
 			dist_sce = sce->cidx - char_offset;
 			if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
 				DUK_DDD(DUK_DDDPRINT("non-ascii string, use_cache=%ld, sce=%p:%ld:%ld, "
 				                     "dist_start=%ld, dist_end=%ld, dist_sce=%ld => "
 				                     "scan backwards from sce",
-				                     (long) use_cache, (void *) (sce ? sce->h : NULL),
+				                     (long) use_cache,
+				                     (void *) (sce ? sce->h : NULL),
 				                     (sce ? (long) sce->cidx : (long) -1),
 				                     (sce ? (long) sce->bidx : (long) -1),
-				                     (long) dist_start, (long) dist_end, (long) dist_sce));
+				                     (long) dist_start,
+				                     (long) dist_end,
+				                     (long) dist_sce));
 
-				p_found = duk__scan_backwards(p_start + sce->bidx,
-				                              p_start,
-				                              dist_sce);
+				p_found = duk__scan_backwards(p_start + sce->bidx, p_start, dist_sce);
 				goto scan_done;
 			}
 		}
 	}
 
 	/* no sce, or sce scan not best */
 
 	if (dist_start <= dist_end) {
 		DUK_DDD(DUK_DDDPRINT("non-ascii string, use_cache=%ld, sce=%p:%ld:%ld, "
 		                     "dist_start=%ld, dist_end=%ld, dist_sce=%ld => "
 		                     "scan forwards from string start",
-		                     (long) use_cache, (void *) (sce ? sce->h : NULL),
+		                     (long) use_cache,
+		                     (void *) (sce ? sce->h : NULL),
 		                     (sce ? (long) sce->cidx : (long) -1),
 		                     (sce ? (long) sce->bidx : (long) -1),
-		                     (long) dist_start, (long) dist_end, (long) dist_sce));
+		                     (long) dist_start,
+		                     (long) dist_end,
+		                     (long) dist_sce));
 
-		p_found = duk__scan_forwards(p_start,
-		                             p_end,
-		                             dist_start);
+		p_found = duk__scan_forwards(p_start, p_end, dist_start);
 	} else {
 		DUK_DDD(DUK_DDDPRINT("non-ascii string, use_cache=%ld, sce=%p:%ld:%ld, "
 		                     "dist_start=%ld, dist_end=%ld, dist_sce=%ld => "
 		                     "scan backwards from string end",
-		                     (long) use_cache, (void *) (sce ? sce->h : NULL),
+		                     (long) use_cache,
+		                     (void *) (sce ? sce->h : NULL),
 		                     (sce ? (long) sce->cidx : (long) -1),
 		                     (sce ? (long) sce->bidx : (long) -1),
-		                     (long) dist_start, (long) dist_end, (long) dist_sce));
+		                     (long) dist_start,
+		                     (long) dist_end,
+		                     (long) dist_sce));
 
-		p_found = duk__scan_backwards(p_end,
-		                              p_start,
-		                              dist_end);
+		p_found = duk__scan_backwards(p_end, p_start, dist_end);
 	}
 
- scan_done:
+scan_done:
 
 	if (DUK_UNLIKELY(p_found == NULL)) {
 		/* Scan error: this shouldn't normally happen; it could happen if
 		 * string is not valid UTF-8 data, and clen/blen are not consistent
 		 * with the scanning algorithm.
 		 */
 		goto scan_error;
 	}
 
 	DUK_ASSERT(p_found >= p_start);
-	DUK_ASSERT(p_found <= p_end);  /* may be equal */
+	DUK_ASSERT(p_found <= p_end); /* may be equal */
 	byte_offset = (duk_uint32_t) (p_found - p_start);
 
-	DUK_DDD(DUK_DDDPRINT("-> string %p, cidx %ld -> bidx %ld",
-	                     (void *) h, (long) char_offset, (long) byte_offset));
+	DUK_DDD(DUK_DDDPRINT("-> string %p, cidx %ld -> bidx %ld", (void *) h, (long) char_offset, (long) byte_offset));
 
 	/*
 	 *  Update cache entry (allocating if necessary), and move the
 	 *  cache entry to the first place (in an "LRU" policy).
 	 */
 
 	if (use_cache) {
 		/* update entry, allocating if necessary */
 		if (!sce) {
-			sce = heap->strcache + DUK_HEAP_STRCACHE_SIZE - 1;  /* take last entry */
+			sce = heap->strcache + DUK_HEAP_STRCACHE_SIZE - 1; /* take last entry */
 			sce->h = h;
 		}
 		DUK_ASSERT(sce != NULL);
 		sce->bidx = (duk_uint32_t) (p_found - p_start);
 		sce->cidx = (duk_uint32_t) char_offset;
 
 		/* LRU: move our entry to first */
@@ -54397,22 +55438,25 @@
 			/* 'sce' points to the wrong entry here, but is no longer used */
 		}
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
 		DUK_DDD(DUK_DDDPRINT("stringcache after char2byte (using cache):"));
 		for (i = 0; i < DUK_HEAP_STRCACHE_SIZE; i++) {
 			duk_strcache_entry *c = heap->strcache + i;
 			DUK_DDD(DUK_DDDPRINT("  [%ld] -> h=%p, cidx=%ld, bidx=%ld",
-			                     (long) i, (void *) c->h, (long) c->cidx, (long) c->bidx));
+			                     (long) i,
+			                     (void *) c->h,
+			                     (long) c->cidx,
+			                     (long) c->bidx));
 		}
 #endif
 	}
 
 	return byte_offset;
 
- scan_error:
+scan_error:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 #line 1 "duk_heap_stringtable.c"
 /*
  *  Heap string table handling, string interning.
  */
@@ -54424,24 +55468,24 @@
  */
 #define DUK__STRTAB_RESIZE_CHECK
 #if (DUK_USE_STRTAB_MINSIZE == DUK_USE_STRTAB_MAXSIZE)
 #undef DUK__STRTAB_RESIZE_CHECK
 #endif
 
 #if defined(DUK_USE_STRTAB_PTRCOMP)
-#define DUK__HEAPPTR_ENC16(heap,ptr)    DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (ptr))
-#define DUK__HEAPPTR_DEC16(heap,val)    DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (val))
-#define DUK__GET_STRTABLE(heap)         ((heap)->strtable16)
+#define DUK__HEAPPTR_ENC16(heap, ptr) DUK_USE_HEAPPTR_ENC16((heap)->heap_udata, (ptr))
+#define DUK__HEAPPTR_DEC16(heap, val) DUK_USE_HEAPPTR_DEC16((heap)->heap_udata, (val))
+#define DUK__GET_STRTABLE(heap)       ((heap)->strtable16)
 #else
-#define DUK__HEAPPTR_ENC16(heap,ptr)    (ptr)
-#define DUK__HEAPPTR_DEC16(heap,val)    (val)
-#define DUK__GET_STRTABLE(heap)         ((heap)->strtable)
+#define DUK__HEAPPTR_ENC16(heap, ptr) (ptr)
+#define DUK__HEAPPTR_DEC16(heap, val) (val)
+#define DUK__GET_STRTABLE(heap)       ((heap)->strtable)
 #endif
 
-#define DUK__STRTAB_U32_MAX_STRLEN      10               /* 4'294'967'295 */
+#define DUK__STRTAB_U32_MAX_STRLEN 10 /* 4'294'967'295 */
 
 /*
  *  Debug dump stringtable.
  */
 
 #if defined(DUK_USE_DEBUG)
 DUK_INTERNAL void duk_heap_strtable_dump(duk_heap *heap) {
@@ -54452,15 +55496,15 @@
 #endif
 	duk_uint32_t i;
 	duk_hstring *h;
 	duk_size_t count_total = 0;
 	duk_size_t count_chain;
 	duk_size_t count_chain_min = DUK_SIZE_MAX;
 	duk_size_t count_chain_max = 0;
-	duk_size_t count_len[8];  /* chain lengths from 0 to 7 */
+	duk_size_t count_len[8]; /* chain lengths from 0 to 7 */
 
 	if (heap == NULL) {
 		DUK_D(DUK_DPRINT("string table, heap=NULL"));
 		return;
 	}
 
 	strtable = DUK__GET_STRTABLE(heap);
@@ -54483,23 +55527,29 @@
 		count_chain_max = (count_chain > count_chain_max ? count_chain : count_chain_max);
 		count_chain_min = (count_chain < count_chain_min ? count_chain : count_chain_min);
 		count_total += count_chain;
 	}
 
 	DUK_D(DUK_DPRINT("string table, strtab=%p, count=%lu, chain min=%lu max=%lu avg=%lf: "
 	                 "counts: %lu %lu %lu %lu %lu %lu %lu %lu ...",
-	                 (void *) heap->strtable, (unsigned long) count_total,
-	                 (unsigned long) count_chain_min, (unsigned long) count_chain_max,
+	                 (void *) heap->strtable,
+	                 (unsigned long) count_total,
+	                 (unsigned long) count_chain_min,
+	                 (unsigned long) count_chain_max,
 	                 (double) count_total / (double) heap->st_size,
-	                 (unsigned long) count_len[0], (unsigned long) count_len[1],
-	                 (unsigned long) count_len[2], (unsigned long) count_len[3],
-	                 (unsigned long) count_len[4], (unsigned long) count_len[5],
-	                 (unsigned long) count_len[6], (unsigned long) count_len[7]));
+	                 (unsigned long) count_len[0],
+	                 (unsigned long) count_len[1],
+	                 (unsigned long) count_len[2],
+	                 (unsigned long) count_len[3],
+	                 (unsigned long) count_len[4],
+	                 (unsigned long) count_len[5],
+	                 (unsigned long) count_len[6],
+	                 (unsigned long) count_len[7]));
 }
-#endif  /* DUK_USE_DEBUG */
+#endif /* DUK_USE_DEBUG */
 
 /*
  *  Assertion helper to ensure strtable is populated correctly.
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_LOCAL void duk__strtable_assert_checks(duk_heap *heap) {
@@ -54532,15 +55582,15 @@
 		DUK_ASSERT(heap->st_mask == 0);
 	}
 
 #if defined(DUK__STRTAB_RESIZE_CHECK)
 	DUK_ASSERT(count == (duk_size_t) heap->st_count);
 #endif
 }
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
 /*
  *  Allocate and initialize a duk_hstring.
  *
  *  Returns a NULL if allocation or initialization fails for some reason.
  *
  *  The string won't be inserted into the string table and isn't tracked in
@@ -54583,24 +55633,24 @@
 		}
 		duk_memzero(res, sizeof(duk_hstring_external));
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 		DUK_HEAPHDR_STRING_INIT_NULLS(&res->hdr);
 #endif
 		DUK_HEAPHDR_SET_TYPE_AND_FLAGS(&res->hdr, DUK_HTYPE_STRING, DUK_HSTRING_FLAG_EXTDATA);
 
-		DUK_ASSERT(extdata[blen] == 0);  /* Application responsibility. */
+		DUK_ASSERT(extdata[blen] == 0); /* Application responsibility. */
 		data = extdata;
 		((duk_hstring_external *) res)->extdata = extdata;
 	} else
-#endif  /* DUK_USE_HSTRING_EXTDATA && DUK_USE_EXTSTR_INTERN_CHECK */
+#endif /* DUK_USE_HSTRING_EXTDATA && DUK_USE_EXTSTR_INTERN_CHECK */
 	{
 		duk_uint8_t *data_tmp;
 
 		/* NUL terminate for convenient C access */
-		DUK_ASSERT(sizeof(duk_hstring) + blen + 1 > blen);  /* No wrap, limits ensure. */
+		DUK_ASSERT(sizeof(duk_hstring) + blen + 1 > blen); /* No wrap, limits ensure. */
 		res = (duk_hstring *) DUK_ALLOC(heap, sizeof(duk_hstring) + blen + 1);
 		if (DUK_UNLIKELY(res == NULL)) {
 			goto alloc_error;
 		}
 		duk_memzero(res, sizeof(duk_hstring));
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 		DUK_HEAPHDR_STRING_INIT_NULLS(&res->hdr);
@@ -54651,28 +55701,28 @@
 		 * The flag is set lazily for RAM strings.
 		 */
 		DUK_ASSERT(!DUK_HSTRING_HAS_ASCII(res));
 
 #if defined(DUK_USE_HSTRING_LAZY_CLEN)
 		/* Charlen initialized to 0, updated on-the-fly. */
 #else
-		duk_hstring_init_charlen(res);  /* Also sets ASCII flag. */
+		duk_hstring_init_charlen(res); /* Also sets ASCII flag. */
 #endif
 	}
 
 	DUK_DDD(DUK_DDDPRINT("interned string, hash=0x%08lx, blen=%ld, has_arridx=%ld, has_extdata=%ld",
 	                     (unsigned long) DUK_HSTRING_GET_HASH(res),
 	                     (long) DUK_HSTRING_GET_BYTELEN(res),
 	                     (long) (DUK_HSTRING_HAS_ARRIDX(res) ? 1 : 0),
 	                     (long) (DUK_HSTRING_HAS_EXTDATA(res) ? 1 : 0)));
 
 	DUK_ASSERT(res != NULL);
 	return res;
 
- alloc_error:
+alloc_error:
 	return NULL;
 }
 
 /*
  *  Grow strtable allocation in-place.
  */
 
@@ -54693,21 +55743,21 @@
 #endif
 
 	DUK_DD(DUK_DDPRINT("grow in-place: %lu -> %lu", (unsigned long) heap->st_size, (unsigned long) heap->st_size * 2));
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(heap->st_resizing == 1);
 	DUK_ASSERT(heap->st_size >= 2);
-	DUK_ASSERT((heap->st_size & (heap->st_size - 1)) == 0);  /* 2^N */
+	DUK_ASSERT((heap->st_size & (heap->st_size - 1)) == 0); /* 2^N */
 	DUK_ASSERT(DUK__GET_STRTABLE(heap) != NULL);
 
 	DUK_STATS_INC(heap, stats_strtab_resize_grow);
 
 	new_st_size = heap->st_size << 1U;
-	DUK_ASSERT(new_st_size > heap->st_size);  /* No overflow. */
+	DUK_ASSERT(new_st_size > heap->st_size); /* No overflow. */
 
 	/* Reallocate the strtable first and then work in-place to rehash
 	 * strings.  We don't need an indirect allocation here: even if GC
 	 * is triggered to satisfy the allocation, recursive strtable resize
 	 * is prevented by flags.  This is also why we don't need to use
 	 * DUK_REALLOC_INDIRECT().
 	 */
@@ -54783,15 +55833,15 @@
 	heap->st_size = new_st_size;
 	heap->st_mask = new_st_size - 1;
 
 #if defined(DUK_USE_ASSERTIONS)
 	duk__strtable_assert_checks(heap);
 #endif
 }
-#endif  /* DUK__STRTAB_RESIZE_CHECK */
+#endif /* DUK__STRTAB_RESIZE_CHECK */
 
 /*
  *  Shrink strtable allocation in-place.
  */
 
 #if defined(DUK__STRTAB_RESIZE_CHECK)
 DUK_LOCAL void duk__strtable_shrink_inplace(duk_heap *heap) {
@@ -54811,15 +55861,15 @@
 #endif
 
 	DUK_DD(DUK_DDPRINT("shrink in-place: %lu -> %lu", (unsigned long) heap->st_size, (unsigned long) heap->st_size / 2));
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(heap->st_resizing == 1);
 	DUK_ASSERT(heap->st_size >= 2);
-	DUK_ASSERT((heap->st_size & (heap->st_size - 1)) == 0);  /* 2^N */
+	DUK_ASSERT((heap->st_size & (heap->st_size - 1)) == 0); /* 2^N */
 	DUK_ASSERT(DUK__GET_STRTABLE(heap) != NULL);
 
 	DUK_STATS_INC(heap, stats_strtab_resize_shrink);
 
 	new_st_size = heap->st_size >> 1U;
 
 	/* Combine two buckets into a single one.  When we shrink, one hash
@@ -54869,23 +55919,23 @@
 	heap->strtable = new_ptr;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 	duk__strtable_assert_checks(heap);
 #endif
 }
-#endif  /* DUK__STRTAB_RESIZE_CHECK */
+#endif /* DUK__STRTAB_RESIZE_CHECK */
 
 /*
  *  Grow/shrink check.
  */
 
 #if defined(DUK__STRTAB_RESIZE_CHECK)
 DUK_LOCAL DUK_COLD DUK_NOINLINE void duk__strtable_resize_check(duk_heap *heap) {
-	duk_uint32_t load_factor;  /* fixed point */
+	duk_uint32_t load_factor; /* fixed point */
 
 	DUK_ASSERT(heap != NULL);
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	DUK_ASSERT(heap->strtable16 != NULL);
 #else
 	DUK_ASSERT(heap->strtable != NULL);
 #endif
@@ -54901,45 +55951,50 @@
 	heap->st_resizing = 1;
 
 	DUK_ASSERT(heap->st_size >= 16U);
 	DUK_ASSERT((heap->st_size >> 4U) >= 1);
 	load_factor = heap->st_count / (heap->st_size >> 4U);
 
 	DUK_DD(DUK_DDPRINT("resize check string table: size=%lu, count=%lu, load_factor=%lu (fixed point .4; float %lf)",
-	                   (unsigned long) heap->st_size, (unsigned long) heap->st_count,
+	                   (unsigned long) heap->st_size,
+	                   (unsigned long) heap->st_count,
 	                   (unsigned long) load_factor,
 	                   (double) heap->st_count / (double) heap->st_size));
 
 	if (load_factor >= DUK_USE_STRTAB_GROW_LIMIT) {
 		if (heap->st_size >= DUK_USE_STRTAB_MAXSIZE) {
 			DUK_DD(DUK_DDPRINT("want to grow strtable (based on load factor) but already maximum size"));
 		} else {
-			DUK_D(DUK_DPRINT("grow string table: %lu -> %lu", (unsigned long) heap->st_size, (unsigned long) heap->st_size * 2));
+			DUK_D(DUK_DPRINT("grow string table: %lu -> %lu",
+			                 (unsigned long) heap->st_size,
+			                 (unsigned long) heap->st_size * 2));
 #if defined(DUK_USE_DEBUG)
 			duk_heap_strtable_dump(heap);
 #endif
 			duk__strtable_grow_inplace(heap);
 		}
 	} else if (load_factor <= DUK_USE_STRTAB_SHRINK_LIMIT) {
 		if (heap->st_size <= DUK_USE_STRTAB_MINSIZE) {
 			DUK_DD(DUK_DDPRINT("want to shrink strtable (based on load factor) but already minimum size"));
 		} else {
-			DUK_D(DUK_DPRINT("shrink string table: %lu -> %lu", (unsigned long) heap->st_size, (unsigned long) heap->st_size / 2));
+			DUK_D(DUK_DPRINT("shrink string table: %lu -> %lu",
+			                 (unsigned long) heap->st_size,
+			                 (unsigned long) heap->st_size / 2));
 #if defined(DUK_USE_DEBUG)
 			duk_heap_strtable_dump(heap);
 #endif
 			duk__strtable_shrink_inplace(heap);
 		}
 	} else {
 		DUK_DD(DUK_DDPRINT("no need for strtable resize"));
 	}
 
 	heap->st_resizing = 0;
 }
-#endif  /* DUK__STRTAB_RESIZE_CHECK */
+#endif /* DUK__STRTAB_RESIZE_CHECK */
 
 /*
  *  Torture grow/shrink: unconditionally grow and shrink back.
  */
 
 #if defined(DUK_USE_STRTAB_TORTURE) && defined(DUK__STRTAB_RESIZE_CHECK)
 DUK_LOCAL void duk__strtable_resize_torture(duk_heap *heap) {
@@ -54955,15 +56010,15 @@
 	heap->st_resizing = 1;
 	duk__strtable_grow_inplace(heap);
 	if (heap->st_size > old_st_size) {
 		duk__strtable_shrink_inplace(heap);
 	}
 	heap->st_resizing = 0;
 }
-#endif  /* DUK_USE_STRTAB_TORTURE && DUK__STRTAB_RESIZE_CHECK */
+#endif /* DUK_USE_STRTAB_TORTURE && DUK__STRTAB_RESIZE_CHECK */
 
 /*
  *  Raw intern; string already checked not to be present.
  */
 
 DUK_LOCAL duk_hstring *duk__strtable_do_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen, duk_uint32_t strhash) {
 	duk_hstring *res;
@@ -54971,16 +56026,20 @@
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	duk_uint16_t *slot;
 #else
 	duk_hstring **slot;
 #endif
 
 	DUK_DDD(DUK_DDDPRINT("do_intern: heap=%p, str=%p, blen=%lu, strhash=%lx, st_size=%lu, st_count=%lu, load=%lf",
-	                     (void *) heap, (const void *) str, (unsigned long) blen, (unsigned long) strhash,
-	                     (unsigned long) heap->st_size, (unsigned long) heap->st_count,
+	                     (void *) heap,
+	                     (const void *) str,
+	                     (unsigned long) blen,
+	                     (unsigned long) strhash,
+	                     (unsigned long) heap->st_size,
+	                     (unsigned long) heap->st_count,
 	                     (double) heap->st_count / (double) heap->st_size));
 
 	DUK_ASSERT(heap != NULL);
 
 	/* Prevent any side effects on the string table and the caller provided
 	 * str/blen arguments while interning is in progress.  For example, if
 	 * the caller provided str/blen from a dynamic buffer, a finalizer
@@ -54988,15 +56047,15 @@
 	 * arguments.
 	 *
 	 * While finalizers must be prevented, mark-and-sweep itself is fine.
 	 * Recursive string table resize is prevented explicitly here.
 	 */
 
 	heap->pf_prevent_count++;
-	DUK_ASSERT(heap->pf_prevent_count != 0);  /* Wrap. */
+	DUK_ASSERT(heap->pf_prevent_count != 0); /* Wrap. */
 
 #if defined(DUK_USE_STRTAB_TORTURE) && defined(DUK__STRTAB_RESIZE_CHECK)
 	duk__strtable_resize_torture(heap);
 #endif
 
 	/* String table grow/shrink check.  Because of chaining (and no
 	 * accumulation issues as with hash probe chains and DELETED
@@ -55015,15 +56074,16 @@
 		duk__strtable_resize_check(heap);
 	}
 #endif
 
 	/* External string check (low memory optimization). */
 
 #if defined(DUK_USE_HSTRING_EXTDATA) && defined(DUK_USE_EXTSTR_INTERN_CHECK)
-	extdata = (const duk_uint8_t *) DUK_USE_EXTSTR_INTERN_CHECK(heap->heap_udata, (void *) DUK_LOSE_CONST(str), (duk_size_t) blen);
+	extdata =
+	    (const duk_uint8_t *) DUK_USE_EXTSTR_INTERN_CHECK(heap->heap_udata, (void *) DUK_LOSE_CONST(str), (duk_size_t) blen);
 #else
 	extdata = (const duk_uint8_t *) NULL;
 #endif
 
 	/* Allocate and initialize string, not yet linked.  This may cause a
 	 * GC which may cause other strings to be interned and inserted into
 	 * the string table before we insert our string.  Finalizer execution
@@ -55053,15 +56113,15 @@
 	/* Insert into string table. */
 
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	slot = heap->strtable16 + (strhash & heap->st_mask);
 #else
 	slot = heap->strtable + (strhash & heap->st_mask);
 #endif
-	DUK_ASSERT(res->hdr.h_next == NULL);  /* This is the case now, but unnecessary zeroing/NULLing. */
+	DUK_ASSERT(res->hdr.h_next == NULL); /* This is the case now, but unnecessary zeroing/NULLing. */
 	res->hdr.h_next = DUK__HEAPPTR_DEC16(heap, *slot);
 	*slot = DUK__HEAPPTR_ENC16(heap, res);
 
 	/* Update string count only for successful inserts. */
 
 #if defined(DUK__STRTAB_RESIZE_CHECK)
 	heap->st_count++;
@@ -55100,55 +56160,55 @@
 		lookup_hash += str[0];
 	}
 	lookup_hash &= 0xff;
 
 	curr = (duk_hstring *) DUK_LOSE_CONST(duk_rom_strings_lookup[lookup_hash]);
 	while (curr != NULL) {
 		/* Unsafe memcmp() because for zero blen, str may be NULL. */
-		if (strhash == DUK_HSTRING_GET_HASH(curr) &&
-		    blen == DUK_HSTRING_GET_BYTELEN(curr) &&
+		if (strhash == DUK_HSTRING_GET_HASH(curr) && blen == DUK_HSTRING_GET_BYTELEN(curr) &&
 		    duk_memcmp_unsafe((const void *) str, (const void *) DUK_HSTRING_GET_DATA(curr), blen) == 0) {
 			DUK_DDD(DUK_DDDPRINT("intern check: rom string: %!O, computed hash 0x%08lx, rom hash 0x%08lx",
-			                     curr, (unsigned long) strhash, (unsigned long) DUK_HSTRING_GET_HASH(curr)));
+			                     curr,
+			                     (unsigned long) strhash,
+			                     (unsigned long) DUK_HSTRING_GET_HASH(curr)));
 			return curr;
 		}
 		curr = curr->hdr.h_next;
 	}
 
 	return NULL;
 }
-#endif  /* DUK_USE_ROM_STRINGS */
+#endif /* DUK_USE_ROM_STRINGS */
 
 DUK_INTERNAL duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen) {
 	duk_uint32_t strhash;
 	duk_hstring *h;
 
 	DUK_DDD(DUK_DDDPRINT("intern check: heap=%p, str=%p, blen=%lu", (void *) heap, (const void *) str, (unsigned long) blen));
 
 	/* Preliminaries. */
 
 	/* XXX: maybe just require 'str != NULL' even for zero size? */
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(blen == 0 || str != NULL);
-	DUK_ASSERT(blen <= DUK_HSTRING_MAX_BYTELEN);  /* Caller is responsible for ensuring this. */
+	DUK_ASSERT(blen <= DUK_HSTRING_MAX_BYTELEN); /* Caller is responsible for ensuring this. */
 	strhash = duk_heap_hashstring(heap, str, (duk_size_t) blen);
 
 	/* String table lookup. */
 
 	DUK_ASSERT(DUK__GET_STRTABLE(heap) != NULL);
 	DUK_ASSERT(heap->st_size > 0);
 	DUK_ASSERT(heap->st_size == heap->st_mask + 1);
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	h = DUK__HEAPPTR_DEC16(heap, heap->strtable16[strhash & heap->st_mask]);
 #else
 	h = heap->strtable[strhash & heap->st_mask];
 #endif
 	while (h != NULL) {
-		if (DUK_HSTRING_GET_HASH(h) == strhash &&
-		    DUK_HSTRING_GET_BYTELEN(h) == blen &&
+		if (DUK_HSTRING_GET_HASH(h) == strhash && DUK_HSTRING_GET_BYTELEN(h) == blen &&
 		    duk_memcmp_unsafe((const void *) str, (const void *) DUK_HSTRING_GET_DATA(h), (size_t) blen) == 0) {
 			/* Found existing entry. */
 			DUK_STATS_INC(heap, stats_strtab_intern_hit);
 			return h;
 		}
 		h = h->hdr.h_next;
 	}
@@ -55166,15 +56226,15 @@
 	}
 #endif
 
 	/* Not found in string table; insert. */
 
 	DUK_STATS_INC(heap, stats_strtab_intern_miss);
 	h = duk__strtable_do_intern(heap, str, blen, strhash);
-	return h;  /* may be NULL */
+	return h; /* may be NULL */
 }
 
 /*
  *  Intern a string from u32.
  */
 
 /* XXX: Could arrange some special handling because we know that the result
@@ -55189,15 +56249,15 @@
 
 	/* This is smaller and faster than a %lu sprintf. */
 	p = buf + sizeof(buf);
 	do {
 		p--;
 		*p = duk_lc_digits[val % 10];
 		val = val / 10;
-	} while (val != 0);  /* For val == 0, emit exactly one '0'. */
+	} while (val != 0); /* For val == 0, emit exactly one '0'. */
 	DUK_ASSERT(p >= buf);
 
 	return duk_heap_strtable_intern(heap, (const duk_uint8_t *) p, (duk_uint32_t) ((buf + sizeof(buf)) - p));
 }
 
 /*
  *  Checked convenience variants.
@@ -55227,15 +56287,15 @@
 DUK_LOCAL duk_uint_t duk__strtable_litcache_key(const duk_uint8_t *str, duk_uint32_t blen) {
 	duk_uintptr_t key;
 
 	DUK_ASSERT(DUK_USE_LITCACHE_SIZE > 0);
 	DUK_ASSERT(DUK_IS_POWER_OF_TWO((duk_uint_t) DUK_USE_LITCACHE_SIZE));
 
 	key = (duk_uintptr_t) blen ^ (duk_uintptr_t) str;
-	key &= (duk_uintptr_t) (DUK_USE_LITCACHE_SIZE - 1);  /* Assumes size is power of 2. */
+	key &= (duk_uintptr_t) (DUK_USE_LITCACHE_SIZE - 1); /* Assumes size is power of 2. */
 	/* Due to masking, cast is in 32-bit range. */
 	DUK_ASSERT(key <= DUK_UINT_MAX);
 	return (duk_uint_t) key;
 }
 
 DUK_INTERNAL duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen) {
 	duk_uint_t key;
@@ -55243,15 +56303,17 @@
 	duk_hstring *h;
 
 	/* Fast path check: literal exists in literal cache. */
 	key = duk__strtable_litcache_key(str, blen);
 	ent = thr->heap->litcache + key;
 	if (ent->addr == str) {
 		DUK_DD(DUK_DDPRINT("intern check for cached, pinned literal: str=%p, blen=%ld -> duk_hstring %!O",
-		                   (const void *) str, (long) blen, (duk_heaphdr *) ent->h));
+		                   (const void *) str,
+		                   (long) blen,
+		                   (duk_heaphdr *) ent->h));
 		DUK_ASSERT(ent->h != NULL);
 		DUK_ASSERT(DUK_HSTRING_HAS_PINNED_LITERAL(ent->h));
 		DUK_STATS_INC(thr->heap, stats_strtab_litcache_hit);
 		return ent->h;
 	}
 
 	/* Intern and update (overwrite) cache entry. */
@@ -55273,15 +56335,15 @@
 		DUK_HSTRING_INCREF(thr, h);
 		DUK_HSTRING_SET_PINNED_LITERAL(h);
 		DUK_STATS_INC(thr->heap, stats_strtab_litcache_pin);
 	}
 
 	return h;
 }
-#endif  /* DUK_USE_LITCACHE_SIZE */
+#endif /* DUK_USE_LITCACHE_SIZE */
 
 DUK_INTERNAL duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val) {
 	duk_hstring *res;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 
@@ -55308,15 +56370,16 @@
 #else
 	duk_hstring **slot;
 #endif
 	duk_hstring *other;
 	duk_hstring *prev;
 
 	DUK_DDD(DUK_DDDPRINT("remove: heap=%p, h=%p, blen=%lu, strhash=%lx",
-	                     (void *) heap, (void *) h,
+	                     (void *) heap,
+	                     (void *) h,
 	                     (unsigned long) (h != NULL ? DUK_HSTRING_GET_BYTELEN(h) : 0),
 	                     (unsigned long) (h != NULL ? DUK_HSTRING_GET_HASH(h) : 0)));
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(h != NULL);
 
 #if defined(DUK__STRTAB_RESIZE_CHECK)
@@ -55326,46 +56389,48 @@
 
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	slot = heap->strtable16 + (DUK_HSTRING_GET_HASH(h) & heap->st_mask);
 #else
 	slot = heap->strtable + (DUK_HSTRING_GET_HASH(h) & heap->st_mask);
 #endif
 	other = DUK__HEAPPTR_DEC16(heap, *slot);
-	DUK_ASSERT(other != NULL);  /* At least argument string is in the chain. */
+	DUK_ASSERT(other != NULL); /* At least argument string is in the chain. */
 
 	prev = NULL;
 	while (other != h) {
 		prev = other;
 		other = other->hdr.h_next;
-		DUK_ASSERT(other != NULL);  /* We'll eventually find 'h'. */
+		DUK_ASSERT(other != NULL); /* We'll eventually find 'h'. */
 	}
 	if (prev != NULL) {
 		/* Middle of list. */
 		prev->hdr.h_next = h->hdr.h_next;
 	} else {
 		/* Head of list. */
 		*slot = DUK__HEAPPTR_ENC16(heap, h->hdr.h_next);
 	}
 
 	/* There's no resize check on a string free.  The next string
 	 * intern will do one.
 	 */
 }
-#endif  /* DUK_USE_REFERENCE_COUNTING */
+#endif /* DUK_USE_REFERENCE_COUNTING */
 
 /* Unlink with a 'prev' pointer. */
 DUK_INTERNAL void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev) {
 #if defined(DUK_USE_STRTAB_PTRCOMP)
 	duk_uint16_t *slot;
 #else
 	duk_hstring **slot;
 #endif
 
 	DUK_DDD(DUK_DDDPRINT("remove: heap=%p, prev=%p, h=%p, blen=%lu, strhash=%lx",
-	                     (void *) heap, (void *) prev, (void *) h,
+	                     (void *) heap,
+	                     (void *) prev,
+	                     (void *) h,
 	                     (unsigned long) (h != NULL ? DUK_HSTRING_GET_BYTELEN(h) : 0),
 	                     (unsigned long) (h != NULL ? DUK_HSTRING_GET_HASH(h) : 0)));
 
 	DUK_ASSERT(heap != NULL);
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(prev == NULL || prev->hdr.h_next == h);
 
@@ -55536,15 +56601,15 @@
 	}
 	default: {
 		DUK_ASSERT(0);
 	}
 	}
 }
 
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 #line 1 "duk_hobject_alloc.c"
 /*
  *  Hobject allocation.
  *
  *  Provides primitive allocation functions for all object types (plain object,
  *  compiled function, native function, thread).  The object return is not yet
  *  in "heap allocated" list and has a refcount of zero, so caller must careful.
@@ -55561,15 +56626,15 @@
  */
 
 DUK_LOCAL void duk__init_object_parts(duk_heap *heap, duk_uint_t hobject_flags, duk_hobject *obj) {
 	DUK_ASSERT(obj != NULL);
 	/* Zeroed by caller. */
 
 	obj->hdr.h_flags = hobject_flags | DUK_HTYPE_OBJECT;
-	DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(&obj->hdr) == DUK_HTYPE_OBJECT);  /* Assume zero shift. */
+	DUK_ASSERT(DUK_HEAPHDR_GET_TYPE(&obj->hdr) == DUK_HTYPE_OBJECT); /* Assume zero shift. */
 
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 	DUK_HOBJECT_SET_PROTOTYPE(heap, obj, NULL);
 	DUK_HOBJECT_SET_PROPS(heap, obj, NULL);
 #endif
 #if defined(DUK_USE_HEAPPTR16)
 	/* Zero encoded pointer is required to match NULL. */
@@ -55697,15 +56762,15 @@
 	res->buf = NULL;
 	res->buf_prop = NULL;
 #endif
 
 	DUK_HBUFOBJ_ASSERT_VALID(res);
 	return res;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /* Allocate a new thread.
  *
  * Leaves the built-ins array uninitialized.  The caller must either
  * initialize a new global context or share existing built-ins from
  * another thread.
  */
@@ -55820,28 +56885,26 @@
 
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_ASSERTIONS)
 
 DUK_INTERNAL void duk_hobject_assert_valid(duk_hobject *h) {
 	DUK_ASSERT(h != NULL);
-	DUK_ASSERT(!DUK_HOBJECT_IS_CALLABLE(h) ||
-	           DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FUNCTION);
-	DUK_ASSERT(!DUK_HOBJECT_IS_BUFOBJ(h) ||
-	           (DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_ARRAYBUFFER ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_DATAVIEW ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT8ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT8ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT16ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT16ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT32ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT32ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FLOAT32ARRAY ||
-	            DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FLOAT64ARRAY));
+	DUK_ASSERT(!DUK_HOBJECT_IS_CALLABLE(h) || DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FUNCTION);
+	DUK_ASSERT(!DUK_HOBJECT_IS_BUFOBJ(h) || (DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_ARRAYBUFFER ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_DATAVIEW ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT8ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT8ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT8CLAMPEDARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT16ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT16ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_INT32ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_UINT32ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FLOAT32ARRAY ||
+	                                         DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_FLOAT64ARRAY));
 	/* Object is an Array <=> object has exotic array behavior */
 	DUK_ASSERT((DUK_HOBJECT_GET_CLASS_NUMBER(h) == DUK_HOBJECT_CLASS_ARRAY && DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)) ||
 	           (DUK_HOBJECT_GET_CLASS_NUMBER(h) != DUK_HOBJECT_CLASS_ARRAY && !DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)));
 }
 
 DUK_INTERNAL void duk_harray_assert_valid(duk_harray *h) {
 	DUK_ASSERT(h != NULL);
@@ -55849,16 +56912,15 @@
 	DUK_ASSERT(DUK_HOBJECT_HAS_EXOTIC_ARRAY((duk_hobject *) h));
 }
 
 DUK_INTERNAL void duk_hboundfunc_assert_valid(duk_hboundfunc *h) {
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(DUK_HOBJECT_IS_BOUNDFUNC((duk_hobject *) h));
 	DUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(&h->target) ||
-	           (DUK_TVAL_IS_OBJECT(&h->target) &&
-	            DUK_HOBJECT_IS_CALLABLE(DUK_TVAL_GET_OBJECT(&h->target))));
+	           (DUK_TVAL_IS_OBJECT(&h->target) && DUK_HOBJECT_IS_CALLABLE(DUK_TVAL_GET_OBJECT(&h->target))));
 	DUK_ASSERT(!DUK_TVAL_IS_UNUSED(&h->this_binding));
 	DUK_ASSERT(h->nargs == 0 || h->args != NULL);
 }
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_INTERNAL void duk_hbufobj_assert_valid(duk_hbufobj *h) {
 	DUK_ASSERT(h != NULL);
@@ -55882,15 +56944,15 @@
 		/* No assertions for offset or length; in particular,
 		 * it's OK for length to be longer than underlying
 		 * buffer.  Just ensure they don't wrap when added.
 		 */
 		DUK_ASSERT(h->offset + h->length >= h->offset);
 	}
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 DUK_INTERNAL void duk_hcompfunc_assert_valid(duk_hcompfunc *h) {
 	DUK_ASSERT(h != NULL);
 }
 
 DUK_INTERNAL void duk_hnatfunc_assert_valid(duk_hnatfunc *h) {
 	DUK_ASSERT(h != NULL);
@@ -55936,15 +56998,15 @@
 	DUK_ASSERT(thr->valstack_end >= thr->valstack);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_end >= thr->valstack_top);
 	DUK_ASSERT(thr->valstack_alloc_end >= thr->valstack_end);
 }
 
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 #line 1 "duk_hobject_enum.c"
 /*
  *  Object enumeration support.
  *
  *  Creates an internal enumeration state object to be used e.g. with for-in
  *  enumeration.  The state object contains a snapshot of target object keys
  *  and internal control state for enumeration.  Enumerator flags allow caller
@@ -55964,15 +57026,15 @@
 /* #include duk_internal.h -> already included */
 
 /* XXX: identify enumeration target with an object index (not top of stack) */
 
 /* First enumerated key index in enumerator object, must match exactly the
  * number of control properties inserted to the enumerator.
  */
-#define DUK__ENUM_START_INDEX  2
+#define DUK__ENUM_START_INDEX 2
 
 /* Current implementation suffices for ES2015 for now because there's no symbol
  * sorting, so commented out for now.
  */
 
 /*
  *  Helper to sort enumeration keys using a callback for pairwise duk_hstring
@@ -56033,15 +57095,15 @@
 
 /* Insert element 'b' after element 'a'? */
 DUK_LOCAL duk_bool_t duk__sort_compare_es6(duk_hstring *a, duk_hstring *b, duk__sort_key_t val_b) {
 	duk__sort_key_t val_a;
 
 	DUK_ASSERT(a != NULL);
 	DUK_ASSERT(b != NULL);
-	DUK_UNREF(b);  /* Not actually needed now, val_b suffices. */
+	DUK_UNREF(b); /* Not actually needed now, val_b suffices. */
 
 	val_a = duk__hstring_sort_key(a);
 
 	if (val_a > val_b) {
 		return 0;
 	} else {
 		return 1;
@@ -56054,15 +57116,15 @@
 
 	DUK_ASSERT(h_obj != NULL);
 	DUK_ASSERT(idx_start >= DUK__ENUM_START_INDEX);
 	DUK_ASSERT(idx_end >= idx_start);
 	DUK_UNREF(thr);
 
 	if (idx_end <= idx_start + 1) {
-		return;  /* Zero or one element(s). */
+		return; /* Zero or one element(s). */
 	}
 
 	keys = DUK_HOBJECT_E_GET_KEY_BASE(thr->heap, h_obj);
 
 	for (idx = idx_start + 1; idx < idx_end; idx++) {
 		duk_hstring *h_curr;
 		duk_int_fast32_t idx_insert;
@@ -56072,15 +57134,15 @@
 		DUK_ASSERT(h_curr != NULL);
 
 		/* Scan backwards for insertion place.  This works very well
 		 * when the elements are nearly in order which is the common
 		 * (and optimized for) case.
 		 */
 
-		val_curr = duk__hstring_sort_key(h_curr);  /* Remains same during scanning. */
+		val_curr = duk__hstring_sort_key(h_curr); /* Remains same during scanning. */
 		for (idx_insert = idx - 1; idx_insert >= idx_start; idx_insert--) {
 			duk_hstring *h_insert;
 			h_insert = keys[idx_insert];
 			DUK_ASSERT(h_insert != NULL);
 
 			if (duk__sort_compare_es6(h_insert, h_curr, val_curr)) {
 				break;
@@ -56145,15 +57207,15 @@
 	duk_hobject *curr;
 	duk_hobject *res;
 #if defined(DUK_USE_ES6_PROXY)
 	duk_hobject *h_proxy_target;
 	duk_hobject *h_proxy_handler;
 	duk_hobject *h_trap_result;
 #endif
-	duk_uint_fast32_t i, len;  /* used for array, stack, and entry indices */
+	duk_uint_fast32_t i, len; /* used for array, stack, and entry indices */
 	duk_uint_fast32_t sort_start_index;
 
 	DUK_ASSERT(thr != NULL);
 
 	enum_target = duk_require_hobject(thr, -1);
 	DUK_ASSERT(enum_target != NULL);
 
@@ -56164,31 +57226,29 @@
 
 	/* Target must be stored so that we can recheck whether or not
 	 * keys still exist when we enumerate.  This is not done if the
 	 * enumeration result comes from a proxy trap as there is no
 	 * real object to check against.
 	 */
 	duk_push_hobject(thr, enum_target);
-	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_INT_TARGET);  /* Target is bare, plain put OK. */
+	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_INT_TARGET); /* Target is bare, plain put OK. */
 
 	/* Initialize index so that we skip internal control keys. */
 	duk_push_int(thr, DUK__ENUM_START_INDEX);
-	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_INT_NEXT);  /* Target is bare, plain put OK. */
+	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_INT_NEXT); /* Target is bare, plain put OK. */
 
 	/*
 	 *  Proxy object handling
 	 */
 
 #if defined(DUK_USE_ES6_PROXY)
 	if (DUK_LIKELY((enum_flags & DUK_ENUM_NO_PROXY_BEHAVIOR) != 0)) {
 		goto skip_proxy;
 	}
-	if (DUK_LIKELY(!duk_hobject_proxy_check(enum_target,
-	                                        &h_proxy_target,
-	                                        &h_proxy_handler))) {
+	if (DUK_LIKELY(!duk_hobject_proxy_check(enum_target, &h_proxy_target, &h_proxy_handler))) {
 		goto skip_proxy;
 	}
 
 	/* XXX: share code with Object.keys() Proxy handling */
 
 	/* In ES2015 for-in invoked the "enumerate" trap; in ES2016 "enumerate"
 	 * has been obsoleted and "ownKeys" is used instead.
@@ -56201,38 +57261,38 @@
 		 * enum target is reachable, which keeps the proxy and the proxy
 		 * target reachable.  We do need to replace the internal _Target.
 		 */
 		DUK_DDD(DUK_DDDPRINT("no ownKeys trap, enumerate proxy target instead"));
 		DUK_DDD(DUK_DDDPRINT("h_proxy_target=%!O", (duk_heaphdr *) h_proxy_target));
 		enum_target = h_proxy_target;
 
-		duk_push_hobject(thr, enum_target);  /* -> [ ... enum_target res handler undefined target ] */
-		duk_put_prop_stridx_short(thr, -4, DUK_STRIDX_INT_TARGET);  /* Target is bare, plain put OK. */
+		duk_push_hobject(thr, enum_target); /* -> [ ... enum_target res handler undefined target ] */
+		duk_put_prop_stridx_short(thr, -4, DUK_STRIDX_INT_TARGET); /* Target is bare, plain put OK. */
 
-		duk_pop_2(thr);  /* -> [ ... enum_target res ] */
+		duk_pop_2(thr); /* -> [ ... enum_target res ] */
 		goto skip_proxy;
 	}
 
 	/* [ ... enum_target res handler trap ] */
 	duk_insert(thr, -2);
-	duk_push_hobject(thr, h_proxy_target);    /* -> [ ... enum_target res trap handler target ] */
-	duk_call_method(thr, 1 /*nargs*/);        /* -> [ ... enum_target res trap_result ] */
+	duk_push_hobject(thr, h_proxy_target); /* -> [ ... enum_target res trap handler target ] */
+	duk_call_method(thr, 1 /*nargs*/); /* -> [ ... enum_target res trap_result ] */
 	h_trap_result = duk_require_hobject(thr, -1);
 	DUK_UNREF(h_trap_result);
 
 	duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);
 	/* -> [ ... enum_target res trap_result keys_array ] */
 
 	/* Copy cleaned up trap result keys into the enumerator object. */
 	/* XXX: result is a dense array; could make use of that. */
 	DUK_ASSERT(duk_is_array(thr, -1));
 	len = (duk_uint_fast32_t) duk_get_length(thr, -1);
 	for (i = 0; i < len; i++) {
 		(void) duk_get_prop_index(thr, -1, (duk_uarridx_t) i);
-		DUK_ASSERT(duk_is_string(thr, -1));  /* postprocess cleaned up */
+		DUK_ASSERT(duk_is_string(thr, -1)); /* postprocess cleaned up */
 		/* [ ... enum_target res trap_result keys_array val ] */
 		duk_push_true(thr);
 		/* [ ... enum_target res trap_result keys_array val true ] */
 		duk_put_prop(thr, -5);
 	}
 	/* [ ... enum_target res trap_result keys_array ] */
 	duk_pop_2(thr);
@@ -56245,16 +57305,16 @@
 	 * 'next' operation can read property values if so requested.  The
 	 * fact that the _Target is a proxy disables key existence check
 	 * during enumeration.
 	 */
 	DUK_DDD(DUK_DDDPRINT("proxy enumeration, final res: %!O", (duk_heaphdr *) res));
 	goto compact_and_return;
 
- skip_proxy:
-#endif  /* DUK_USE_ES6_PROXY */
+skip_proxy:
+#endif /* DUK_USE_ES6_PROXY */
 
 	curr = enum_target;
 	sort_start_index = DUK__ENUM_START_INDEX;
 	DUK_ASSERT(DUK_HOBJECT_GET_ENEXT(res) == DUK__ENUM_START_INDEX);
 	while (curr) {
 		duk_uint_fast32_t sort_end_index;
 #if !defined(DUK_USE_PREFER_SIZE)
@@ -56297,15 +57357,15 @@
 
 			/* String and buffer enumeration behavior is identical now,
 			 * so use shared handler.
 			 */
 			if (DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(curr)) {
 				duk_hstring *h_val;
 				h_val = duk_hobject_get_internal_value_string(thr->heap, curr);
-				DUK_ASSERT(h_val != NULL);  /* string objects must not created without internal value */
+				DUK_ASSERT(h_val != NULL); /* string objects must not created without internal value */
 				len = (duk_uint_fast32_t) DUK_HSTRING_GET_CHARLEN(h_val);
 			}
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 			else {
 				duk_hbufobj *h_bufobj;
 				DUK_ASSERT(DUK_HOBJECT_IS_BUFOBJ(curr));
 				h_bufobj = (duk_hbufobj *) curr;
@@ -56320,15 +57380,15 @@
 				} else {
 					/* There's intentionally no check for
 					 * current underlying buffer length.
 					 */
 					len = (duk_uint_fast32_t) (h_bufobj->length >> h_bufobj->shift);
 				}
 			}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 			for (i = 0; i < len; i++) {
 				duk_hstring *k;
 
 				/* This is a bit fragile: the string is not
 				 * reachable until it is pushed by the helper.
 				 */
@@ -56360,15 +57420,15 @@
 				duk_hstring *k;
 				duk_tval *tv;
 
 				tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, curr, i);
 				if (DUK_TVAL_IS_UNUSED(tv)) {
 					continue;
 				}
-				k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i);  /* Fragile reachability. */
+				k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i); /* Fragile reachability. */
 				DUK_ASSERT(k);
 
 				duk__add_enum_key(thr, k);
 
 				/* [enum_target res] */
 			}
 
@@ -56392,26 +57452,25 @@
 				continue;
 			}
 			if (!(enum_flags & DUK_ENUM_INCLUDE_NONENUMERABLE) &&
 			    !DUK_HOBJECT_E_SLOT_IS_ENUMERABLE(thr->heap, curr, i)) {
 				continue;
 			}
 			if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(k))) {
-				if (!(enum_flags & DUK_ENUM_INCLUDE_HIDDEN) &&
-				    DUK_HSTRING_HAS_HIDDEN(k)) {
+				if (!(enum_flags & DUK_ENUM_INCLUDE_HIDDEN) && DUK_HSTRING_HAS_HIDDEN(k)) {
 					continue;
 				}
 				if (!(enum_flags & DUK_ENUM_INCLUDE_SYMBOLS)) {
 					continue;
 				}
 #if !defined(DUK_USE_PREFER_SIZE)
 				need_sort = 1;
 #endif
 			} else {
-				DUK_ASSERT(!DUK_HSTRING_HAS_HIDDEN(k));  /* would also have symbol flag */
+				DUK_ASSERT(!DUK_HSTRING_HAS_HIDDEN(k)); /* would also have symbol flag */
 				if (enum_flags & DUK_ENUM_EXCLUDE_STRINGS) {
 					continue;
 				}
 			}
 			if (DUK_HSTRING_HAS_ARRIDX(k)) {
 				/* This in currently only possible if the
 				 * object has no array part: the array part
@@ -56452,15 +57511,18 @@
 
 		if (!(enum_flags & DUK_ENUM_SORT_ARRAY_INDICES)) {
 #if defined(DUK_USE_PREFER_SIZE)
 			duk__sort_enum_keys_es6(thr, res, (duk_int_fast32_t) sort_start_index, (duk_int_fast32_t) sort_end_index);
 #else
 			if (need_sort) {
 				DUK_DDD(DUK_DDDPRINT("need to sort"));
-				duk__sort_enum_keys_es6(thr, res, (duk_int_fast32_t) sort_start_index, (duk_int_fast32_t) sort_end_index);
+				duk__sort_enum_keys_es6(thr,
+				                        res,
+				                        (duk_int_fast32_t) sort_start_index,
+				                        (duk_int_fast32_t) sort_end_index);
 			} else {
 				DUK_DDD(DUK_DDDPRINT("no need to sort"));
 			}
 #endif
 		}
 
 		sort_start_index = sort_end_index;
@@ -56485,19 +57547,22 @@
 		 * handling.  The caller can request an explicit sort in these
 		 * cases.
 		 */
 
 		/* Sort to ES2015 order which works for pure array incides but
 		 * also for mixed keys.
 		 */
-		duk__sort_enum_keys_es6(thr, res, (duk_int_fast32_t) DUK__ENUM_START_INDEX, (duk_int_fast32_t) DUK_HOBJECT_GET_ENEXT(res));
+		duk__sort_enum_keys_es6(thr,
+		                        res,
+		                        (duk_int_fast32_t) DUK__ENUM_START_INDEX,
+		                        (duk_int_fast32_t) DUK_HOBJECT_GET_ENEXT(res));
 	}
 
 #if defined(DUK_USE_ES6_PROXY)
- compact_and_return:
+compact_and_return:
 #endif
 	/* compact; no need to seal because object is internal */
 	duk_hobject_compact_props(thr, res);
 
 	DUK_DDD(DUK_DDDPRINT("created enumerator object: %!iT", (duk_tval *) duk_get_tval(thr, -1)));
 }
 
@@ -56537,18 +57602,19 @@
 	enum_target = duk_require_hobject(thr, -1);
 	DUK_ASSERT(enum_target != NULL);
 #if defined(DUK_USE_ES6_PROXY)
 	check_existence = (!DUK_HOBJECT_IS_PROXY(enum_target));
 #else
 	check_existence = 1;
 #endif
-	duk_pop(thr);  /* still reachable */
+	duk_pop(thr); /* still reachable */
 
 	DUK_DDD(DUK_DDDPRINT("getting next enum value, enum_target=%!iO, enumerator=%!iT",
-	                     (duk_heaphdr *) enum_target, (duk_tval *) duk_get_tval(thr, -1)));
+	                     (duk_heaphdr *) enum_target,
+	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	/* no array part */
 	for (;;) {
 		duk_hstring *k;
 
 		if (idx >= DUK_HOBJECT_GET_ENEXT(e)) {
 			DUK_DDD(DUK_DDDPRINT("enumeration: ran out of elements"));
@@ -56581,24 +57647,24 @@
 
 	/* [... enum] */
 
 	if (res) {
 		duk_push_hstring(thr, res);
 		if (get_value) {
 			duk_push_hobject(thr, enum_target);
-			duk_dup_m2(thr);       /* -> [... enum key enum_target key] */
+			duk_dup_m2(thr); /* -> [... enum key enum_target key] */
 			duk_get_prop(thr, -2); /* -> [... enum key enum_target val] */
-			duk_remove_m2(thr);    /* -> [... enum key val] */
-			duk_remove(thr, -3);   /* -> [... key val] */
+			duk_remove_m2(thr); /* -> [... enum key val] */
+			duk_remove(thr, -3); /* -> [... key val] */
 		} else {
-			duk_remove_m2(thr);    /* -> [... key] */
+			duk_remove_m2(thr); /* -> [... key] */
 		}
 		return 1;
 	} else {
-		duk_pop(thr);  /* -> [...] */
+		duk_pop(thr); /* -> [...] */
 		return 0;
 	}
 }
 
 /*
  *  Get enumerated keys in an ECMAScript array.  Matches Object.keys() behavior
  *  described in E5 Section 15.2.3.14.
@@ -56637,39 +57703,42 @@
 	keys = DUK_HOBJECT_E_GET_KEY_BASE(thr->heap, e);
 	keys += DUK__ENUM_START_INDEX;
 
 	while (count-- > 0) {
 		duk_hstring *k;
 
 		k = *keys++;
-		DUK_ASSERT(k != NULL);  /* enumerator must have no keys deleted */
+		DUK_ASSERT(k != NULL); /* enumerator must have no keys deleted */
 
 		DUK_TVAL_SET_STRING(tv, k);
 		tv++;
 		DUK_HSTRING_INCREF(thr, k);
 	}
 
 	/* [enum_target enum res] */
 	duk_remove_m2(thr);
 
 	/* [enum_target res] */
 
-	return 1;  /* return 1 to allow callers to tail call */
+	return 1; /* return 1 to allow callers to tail call */
 }
 
 /* automatic undefs */
 #undef DUK__ENUM_START_INDEX
 #line 1 "duk_hobject_misc.c"
 /*
  *  Misc support functions
  */
 
 /* #include duk_internal.h -> already included */
 
-DUK_INTERNAL duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr, duk_hobject *h, duk_hobject *p, duk_bool_t ignore_loop) {
+DUK_INTERNAL duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr,
+                                                             duk_hobject *h,
+                                                             duk_hobject *p,
+                                                             duk_bool_t ignore_loop) {
 	duk_uint_t sanity;
 
 	DUK_ASSERT(thr != NULL);
 
 	/* False if the object is NULL or the prototype 'p' is NULL.
 	 * In particular, false if both are NULL (don't compare equal).
 	 */
@@ -56700,15 +57769,15 @@
 DUK_INTERNAL void duk_hobject_set_prototype_updref(duk_hthread *thr, duk_hobject *h, duk_hobject *p) {
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	duk_hobject *tmp;
 
 	DUK_ASSERT(h);
 	tmp = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h);
 	DUK_HOBJECT_SET_PROTOTYPE(thr->heap, h, p);
-	DUK_HOBJECT_INCREF_ALLOWNULL(thr, p);  /* avoid problems if p == h->prototype */
+	DUK_HOBJECT_INCREF_ALLOWNULL(thr, p); /* avoid problems if p == h->prototype */
 	DUK_HOBJECT_DECREF_ALLOWNULL(thr, tmp);
 #else
 	DUK_ASSERT(h);
 	DUK_UNREF(thr);
 	DUK_HOBJECT_SET_PROTOTYPE(thr->heap, h, p);
 #endif
 }
@@ -56746,15 +57815,15 @@
 
 	duk_push_dynamic_buffer(thr, (duk_size_t) curr_offset);
 	h_buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, -1);
 	DUK_ASSERT(DUK_HBUFFER_HAS_DYNAMIC(h_buf) && !DUK_HBUFFER_HAS_EXTERNAL(h_buf));
 
 	hdr = (duk_uint32_t *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(thr->heap, h_buf);
 	DUK_ASSERT(hdr != NULL);
-	hdr[0] = (duk_uint32_t) length;  /* valid pc range is [0, length[ */
+	hdr[0] = (duk_uint32_t) length; /* valid pc range is [0, length[ */
 
 	curr_pc = 0U;
 	while (curr_pc < length) {
 		new_size = (duk_size_t) (curr_offset + DUK_PC2LINE_MAX_DIFF_LENGTH);
 		duk_hbuffer_resize(thr, h_buf, new_size);
 
 		hdr = (duk_uint32_t *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(thr->heap, h_buf);
@@ -56775,16 +57844,16 @@
 
 		duk_memzero(be_ctx, sizeof(*be_ctx));
 		be_ctx->data = ((duk_uint8_t *) hdr) + curr_offset;
 		be_ctx->length = (duk_size_t) DUK_PC2LINE_MAX_DIFF_LENGTH;
 
 		for (;;) {
 			curr_pc++;
-			if ( ((curr_pc % DUK_PC2LINE_SKIP) == 0) ||  /* end of diff run */
-			     (curr_pc >= length) ) {                 /* end of bytecode */
+			if (((curr_pc % DUK_PC2LINE_SKIP) == 0) || /* end of diff run */
+			    (curr_pc >= length)) { /* end of bytecode */
 				break;
 			}
 			DUK_ASSERT(curr_pc < length);
 			next_line = (duk_int32_t) instrs[curr_pc].line;
 			diff_line = next_line - curr_line;
 
 #if 0
@@ -56823,15 +57892,17 @@
 	/* compact */
 	new_size = (duk_size_t) curr_offset;
 	duk_hbuffer_resize(thr, h_buf, new_size);
 
 	(void) duk_to_fixed_buffer(thr, -1, NULL);
 
 	DUK_DDD(DUK_DDDPRINT("final pc2line data: pc_limit=%ld, length=%ld, %lf bits/opcode --> %!ixT",
-	                     (long) length, (long) new_size, (double) new_size * 8.0 / (double) length,
+	                     (long) length,
+	                     (long) new_size,
+	                     (double) new_size * 8.0 / (double) length,
 	                     (duk_tval *) duk_get_tval(thr, -1)));
 }
 
 /* PC is unsigned.  If caller does PC arithmetic and gets a negative result,
  * it will map to a large PC which is out of bounds and causes a zero to be
  * returned.
  */
@@ -56863,24 +57934,24 @@
 		goto pc2line_error;
 	}
 
 	hdr = (duk_uint32_t *) (void *) DUK_HBUFFER_FIXED_GET_DATA_PTR(thr->heap, buf);
 	pc_limit = hdr[0];
 	if (pc >= pc_limit) {
 		/* Note: pc is unsigned and cannot be negative */
-		DUK_DD(DUK_DDPRINT("pc2line lookup failed: pc out of bounds (pc=%ld, limit=%ld)",
-		                   (long) pc, (long) pc_limit));
+		DUK_DD(DUK_DDPRINT("pc2line lookup failed: pc out of bounds (pc=%ld, limit=%ld)", (long) pc, (long) pc_limit));
 		goto pc2line_error;
 	}
 
 	curr_line = hdr[1 + hdr_index * 2];
 	start_offset = hdr[1 + hdr_index * 2 + 1];
 	if ((duk_size_t) start_offset > DUK_HBUFFER_FIXED_GET_SIZE(buf)) {
 		DUK_DD(DUK_DDPRINT("pc2line lookup failed: start_offset out of bounds (start_offset=%ld, buffer_size=%ld)",
-		                   (long) start_offset, (long) DUK_HBUFFER_GET_SIZE((duk_hbuffer *) buf)));
+		                   (long) start_offset,
+		                   (long) DUK_HBUFFER_GET_SIZE((duk_hbuffer *) buf)));
 		goto pc2line_error;
 	}
 
 	/*
 	 *  Iterate the bitstream (line diffs) until PC is reached
 	 */
 
@@ -56899,15 +57970,15 @@
 #endif
 
 		if (duk_bd_decode_flag(bd_ctx)) {
 			if (duk_bd_decode_flag(bd_ctx)) {
 				if (duk_bd_decode_flag(bd_ctx)) {
 					/* 1 1 1 <32 bits> */
 					duk_uint_fast32_t t;
-					t = duk_bd_decode(bd_ctx, 16);  /* workaround: max nbits = 24 now */
+					t = duk_bd_decode(bd_ctx, 16); /* workaround: max nbits = 24 now */
 					t = (t << 16) + duk_bd_decode(bd_ctx, 16);
 					curr_line = t;
 				} else {
 					/* 1 1 0 <8 bits> */
 					duk_uint_fast32_t t;
 					t = duk_bd_decode(bd_ctx, 8);
 					curr_line = curr_line + t - 0x80;
@@ -56924,15 +57995,15 @@
 
 		n--;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("pc2line lookup result: pc %ld -> line %ld", (long) pc, (long) curr_line));
 	return curr_line;
 
- pc2line_error:
+pc2line_error:
 	DUK_D(DUK_DPRINT("pc2line conversion failed for pc=%ld", (long) pc));
 	return 0;
 }
 
 DUK_INTERNAL duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc) {
 	duk_hbuffer_fixed *pc2line;
 	duk_uint_fast32_t line;
@@ -56952,15 +58023,15 @@
 		line = 0;
 	}
 	duk_pop(thr);
 
 	return line;
 }
 
-#endif  /* DUK_USE_PC2LINE */
+#endif /* DUK_USE_PC2LINE */
 #line 1 "duk_hobject_props.c"
 /*
  *  duk_hobject property access functionality.
  *
  *  This is very central functionality for size, performance, and compliance.
  *  It is also rather intricate; see hobject-algorithms.rst for discussion on
  *  the algorithms and memory-management.rst for discussion on refcounts and
@@ -57002,43 +58073,64 @@
 
 /* #include duk_internal.h -> already included */
 
 /*
  *  Local defines
  */
 
-#define DUK__NO_ARRAY_INDEX             DUK_HSTRING_NO_ARRAY_INDEX
+#define DUK__NO_ARRAY_INDEX DUK_HSTRING_NO_ARRAY_INDEX
 
 /* Marker values for hash part. */
-#define DUK__HASH_UNUSED                DUK_HOBJECT_HASHIDX_UNUSED
-#define DUK__HASH_DELETED               DUK_HOBJECT_HASHIDX_DELETED
+#define DUK__HASH_UNUSED  DUK_HOBJECT_HASHIDX_UNUSED
+#define DUK__HASH_DELETED DUK_HOBJECT_HASHIDX_DELETED
 
 /* Valstack space that suffices for all local calls, excluding any recursion
  * into ECMAScript or Duktape/C calls (Proxy, getters, etc).
  */
-#define DUK__VALSTACK_SPACE             10
+#define DUK__VALSTACK_SPACE 10
 
 /* Valstack space allocated especially for proxy lookup which does a
  * recursive property lookup.
  */
-#define DUK__VALSTACK_PROXY_LOOKUP      20
+#define DUK__VALSTACK_PROXY_LOOKUP 20
 
 /*
  *  Local prototypes
  */
 
-DUK_LOCAL_DECL duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc);
-DUK_LOCAL_DECL void duk__check_arguments_map_for_put(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc, duk_bool_t throw_flag);
-DUK_LOCAL_DECL void duk__check_arguments_map_for_delete(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc);
-
-DUK_LOCAL_DECL duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr, duk_hobject *obj, duk_uint32_t old_len, duk_uint32_t new_len, duk_bool_t force_flag, duk_uint32_t *out_result_len);
+DUK_LOCAL_DECL duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr,
+                                                           duk_hobject *obj,
+                                                           duk_hstring *key,
+                                                           duk_propdesc *temp_desc);
+DUK_LOCAL_DECL void duk__check_arguments_map_for_put(duk_hthread *thr,
+                                                     duk_hobject *obj,
+                                                     duk_hstring *key,
+                                                     duk_propdesc *temp_desc,
+                                                     duk_bool_t throw_flag);
+DUK_LOCAL_DECL void duk__check_arguments_map_for_delete(duk_hthread *thr,
+                                                        duk_hobject *obj,
+                                                        duk_hstring *key,
+                                                        duk_propdesc *temp_desc);
+
+DUK_LOCAL_DECL duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr,
+                                                               duk_hobject *obj,
+                                                               duk_uint32_t old_len,
+                                                               duk_uint32_t new_len,
+                                                               duk_bool_t force_flag,
+                                                               duk_uint32_t *out_result_len);
 DUK_LOCAL_DECL duk_bool_t duk__handle_put_array_length(duk_hthread *thr, duk_hobject *obj);
 
-DUK_LOCAL_DECL duk_bool_t duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
-DUK_LOCAL_DECL duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_uint32_t arr_idx, duk_propdesc *out_desc, duk_small_uint_t flags);
+DUK_LOCAL_DECL duk_bool_t
+duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
+DUK_LOCAL_DECL duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr,
+                                                    duk_hobject *obj,
+                                                    duk_hstring *key,
+                                                    duk_uint32_t arr_idx,
+                                                    duk_propdesc *out_desc,
+                                                    duk_small_uint_t flags);
 
 DUK_LOCAL_DECL void duk__abandon_array_part(duk_hthread *thr, duk_hobject *obj);
 DUK_LOCAL_DECL void duk__grow_props_for_array_item(duk_hthread *thr, duk_hobject *obj, duk_uint32_t highest_arr_idx);
 
 /*
  *  Misc helpers
  */
@@ -57059,15 +58151,15 @@
 
 	/* -0 is accepted here as index 0 because ToString(-0) == "0" which is
 	 * in canonical form and thus an array index.
 	 */
 	dbl = DUK_TVAL_GET_NUMBER(tv);
 	idx = (duk_uint32_t) dbl;
 	if (duk_double_equals((duk_double_t) idx, dbl)) {
-	        /* Is whole and within 32 bit range.  If the value happens to be 0xFFFFFFFF,
+		/* Is whole and within 32 bit range.  If the value happens to be 0xFFFFFFFF,
 		 * it's not a valid array index but will then match DUK__NO_ARRAY_INDEX.
 		 */
 		return idx;
 	}
 	return DUK__NO_ARRAY_INDEX;
 }
 
@@ -57086,15 +58178,15 @@
 	}
 
 	/* If the value happens to be 0xFFFFFFFF, it's not a valid array index
 	 * but will then match DUK__NO_ARRAY_INDEX.
 	 */
 	return (duk_uint32_t) t;
 }
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
 /* Convert a duk_tval on the value stack (in a trusted index we don't validate)
  * to a string or symbol using ES2015 ToPropertyKey():
  * http://www.ecma-international.org/ecma-262/6.0/#sec-topropertykey.
  *
  * Also check if it's a valid array index and return that (or DUK__NO_ARRAY_INDEX
  * if not).
@@ -57111,15 +58203,15 @@
 
 	/* XXX: The revised ES2015 ToPropertyKey() handling (ES5.1 was just
 	 * ToString()) involves a ToPrimitive(), a symbol check, and finally
 	 * a ToString().  Figure out the best way to have a good fast path
 	 * but still be compliant and share code.
 	 */
 
-	tv_dst = DUK_GET_TVAL_NEGIDX(thr, idx);  /* intentionally unvalidated */
+	tv_dst = DUK_GET_TVAL_NEGIDX(thr, idx); /* intentionally unvalidated */
 	if (DUK_TVAL_IS_STRING(tv_dst)) {
 		/* Most important path: strings and plain symbols are used as
 		 * is.  For symbols the array index check below is unnecessary
 		 * (they're never valid array indices) but checking that the
 		 * string is a symbol would make the plain string path slower
 		 * unnecessarily.
 		 */
@@ -57131,15 +58223,15 @@
 	*out_h = h;
 
 	arr_idx = DUK_HSTRING_GET_ARRIDX_FAST(h);
 	return arr_idx;
 }
 
 DUK_LOCAL duk_uint32_t duk__push_tval_to_property_key(duk_hthread *thr, duk_tval *tv_key, duk_hstring **out_h) {
-	duk_push_tval(thr, tv_key);  /* XXX: could use an unsafe push here */
+	duk_push_tval(thr, tv_key); /* XXX: could use an unsafe push here */
 	return duk__to_property_key(thr, -1, out_h);
 }
 
 /* String is an own (virtual) property of a plain buffer. */
 DUK_LOCAL duk_bool_t duk__key_is_plain_buf_ownprop(duk_hthread *thr, duk_hbuffer *buf, duk_hstring *key, duk_uint32_t arr_idx) {
 	DUK_UNREF(thr);
 
@@ -57171,47 +58263,47 @@
 		duk_uint32_t tmp;
 
 		/* Hash size should be 2^N where N is chosen so that 2^N is
 		 * larger than e_size.  Extra shifting is used to ensure hash
 		 * is relatively sparse.
 		 */
 		tmp = e_size;
-		res = 2;  /* Result will be 2 ** (N + 1). */
+		res = 2; /* Result will be 2 ** (N + 1). */
 		while (tmp >= 0x40) {
 			tmp >>= 6;
 			res <<= 6;
 		}
 		while (tmp != 0) {
 			tmp >>= 1;
 			res <<= 1;
 		}
-		DUK_ASSERT((DUK_HOBJECT_MAX_PROPERTIES << 2U) > DUK_HOBJECT_MAX_PROPERTIES);  /* Won't wrap, even shifted by 2. */
+		DUK_ASSERT((DUK_HOBJECT_MAX_PROPERTIES << 2U) > DUK_HOBJECT_MAX_PROPERTIES); /* Won't wrap, even shifted by 2. */
 		DUK_ASSERT(res > e_size);
 		return res;
 	} else {
 		return 0;
 	}
 }
-#endif  /* USE_PROP_HASH_PART */
+#endif /* USE_PROP_HASH_PART */
 
 /* Get minimum entry part growth for a certain size. */
 DUK_LOCAL duk_uint32_t duk__get_min_grow_e(duk_uint32_t e_size) {
 	duk_uint32_t res;
 
 	res = (e_size + DUK_USE_HOBJECT_ENTRY_MINGROW_ADD) / DUK_USE_HOBJECT_ENTRY_MINGROW_DIVISOR;
-	DUK_ASSERT(res >= 1);  /* important for callers */
+	DUK_ASSERT(res >= 1); /* important for callers */
 	return res;
 }
 
 /* Get minimum array part growth for a certain size. */
 DUK_LOCAL duk_uint32_t duk__get_min_grow_a(duk_uint32_t a_size) {
 	duk_uint32_t res;
 
 	res = (a_size + DUK_USE_HOBJECT_ARRAY_MINGROW_ADD) / DUK_USE_HOBJECT_ARRAY_MINGROW_DIVISOR;
-	DUK_ASSERT(res >= 1);  /* important for callers */
+	DUK_ASSERT(res >= 1); /* important for callers */
 	return res;
 }
 
 /* Count actually used entry part entries (non-NULL keys). */
 DUK_LOCAL duk_uint32_t duk__count_used_e_keys(duk_hthread *thr, duk_hobject *obj) {
 	duk_uint_fast32_t i;
 	duk_uint_fast32_t n = 0;
@@ -57233,15 +58325,15 @@
  * NOTE: 'out_min_size' can be computed much faster by starting from the
  * end and breaking out early when finding first used entry, but this is
  * not needed now.
  */
 DUK_LOCAL void duk__compute_a_stats(duk_hthread *thr, duk_hobject *obj, duk_uint32_t *out_used, duk_uint32_t *out_min_size) {
 	duk_uint_fast32_t i;
 	duk_uint_fast32_t used = 0;
-	duk_uint_fast32_t highest_idx = (duk_uint_fast32_t) -1;  /* see below */
+	duk_uint_fast32_t highest_idx = (duk_uint_fast32_t) -1; /* see below */
 	duk_tval *a;
 
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(out_used != NULL);
 	DUK_ASSERT(out_min_size != NULL);
 	DUK_UNREF(thr);
 
@@ -57256,15 +58348,15 @@
 
 	/* Initial value for highest_idx is -1 coerced to unsigned.  This
 	 * is a bit odd, but (highest_idx + 1) will then wrap to 0 below
 	 * for out_min_size as intended.
 	 */
 
 	*out_used = (duk_uint32_t) used;
-	*out_min_size = (duk_uint32_t) (highest_idx + 1);  /* 0 if no used entries */
+	*out_min_size = (duk_uint32_t) (highest_idx + 1); /* 0 if no used entries */
 }
 
 /* Check array density and indicate whether or not the array part should be abandoned. */
 DUK_LOCAL duk_bool_t duk__abandon_array_density_check(duk_uint32_t a_used, duk_uint32_t a_size) {
 	/*
 	 *  Array abandon check; abandon if:
 	 *
@@ -57323,15 +58415,17 @@
 		DUK_DDD(DUK_DDDPRINT("=> fast resize is OK"));
 		return 0;
 	}
 
 	duk__compute_a_stats(thr, obj, &old_used, &old_size);
 
 	DUK_DDD(DUK_DDDPRINT("abandon check, array stats: old_used=%ld, old_size=%ld, arr_idx=%ld",
-	                     (long) old_used, (long) old_size, (long) arr_idx));
+	                     (long) old_used,
+	                     (long) old_size,
+	                     (long) arr_idx));
 
 	min_size = arr_idx + 1;
 #if defined(DUK_USE_OBJSIZES16)
 	if (min_size > DUK_UINT16_MAX) {
 		goto do_abandon;
 	}
 #endif
@@ -57351,15 +58445,15 @@
 		 */
 		goto do_abandon;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("=> decided to keep array part"));
 	return 0;
 
- do_abandon:
+do_abandon:
 	duk__abandon_array_part(thr, obj);
 	DUK_ASSERT(!DUK_HOBJECT_HAS_ARRAY_PART(obj));
 	return 1;
 }
 
 DUK_LOCAL duk_tval *duk__obtain_arridx_slot_slowpath(duk_hthread *thr, duk_uint32_t arr_idx, duk_hobject *obj) {
 	/*
@@ -57378,15 +58472,16 @@
 	 *
 	 *    - Otherwise, compute the resize using an actual density
 	 *      measurement based on counting the used array entries.
 	 */
 
 	DUK_DDD(DUK_DDDPRINT("write to new array requires array resize, decide whether to do a "
 	                     "fast resize without abandon check (arr_idx=%ld, old_size=%ld)",
-	                     (long) arr_idx, (long) DUK_HOBJECT_GET_ASIZE(obj)));
+	                     (long) arr_idx,
+	                     (long) DUK_HOBJECT_GET_ASIZE(obj)));
 
 	if (DUK_UNLIKELY(duk__abandon_array_check(thr, arr_idx, obj) != 0)) {
 		DUK_ASSERT(!DUK_HOBJECT_HAS_ARRAY_PART(obj));
 		return NULL;
 	}
 
 	DUK_DD(DUK_DDPRINT("write to new array entry beyond current length, "
@@ -57437,15 +58532,15 @@
 	DUK_ASSERT(h_proxy->handler != NULL);
 	DUK_ASSERT(h_proxy->target != NULL);
 	*out_handler = h_proxy->handler;
 	*out_target = h_proxy->target;
 
 	return 1;
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 /* Get Proxy target object.  If the argument is not a Proxy, return it as is.
  * If a Proxy is revoked, an error is thrown.
  */
 #if defined(DUK_USE_ES6_PROXY)
 DUK_INTERNAL duk_hobject *duk_hobject_resolve_proxy_target(duk_hobject *obj) {
 	DUK_ASSERT(obj != NULL);
@@ -57463,18 +58558,22 @@
 		obj = h_proxy->target;
 		DUK_ASSERT(obj != NULL);
 	}
 
 	DUK_ASSERT(obj != NULL);
 	return obj;
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 #if defined(DUK_USE_ES6_PROXY)
-DUK_LOCAL duk_bool_t duk__proxy_check_prop(duk_hthread *thr, duk_hobject *obj, duk_small_uint_t stridx_trap, duk_tval *tv_key, duk_hobject **out_target) {
+DUK_LOCAL duk_bool_t duk__proxy_check_prop(duk_hthread *thr,
+                                           duk_hobject *obj,
+                                           duk_small_uint_t stridx_trap,
+                                           duk_tval *tv_key,
+                                           duk_hobject **out_target) {
 	duk_hobject *h_handler;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(tv_key != NULL);
 	DUK_ASSERT(out_target != NULL);
 
@@ -57520,24 +58619,24 @@
 
 	/* XXX: C recursion limit if proxies are allowed as handler/target values */
 
 	duk_require_stack(thr, DUK__VALSTACK_PROXY_LOOKUP);
 	duk_push_hobject(thr, h_handler);
 	if (duk_get_prop_stridx_short(thr, -1, stridx_trap)) {
 		/* -> [ ... handler trap ] */
-		duk_insert(thr, -2);  /* -> [ ... trap handler ] */
+		duk_insert(thr, -2); /* -> [ ... trap handler ] */
 
 		/* stack prepped for func call: [ ... trap handler ] */
 		return 1;
 	} else {
 		duk_pop_2_unsafe(thr);
 		return 0;
 	}
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 /*
  *  Reallocate property allocation, moving properties to the new allocation.
  *
  *  Includes key compaction, rehashing, and can also optionally abandon
  *  the array part, 'migrating' array entries into the beginning of the
  *  new entry part.
@@ -57584,19 +58683,20 @@
 	duk_size_t array_copy_size;
 #if defined(DUK_USE_ASSERTIONS)
 	duk_bool_t prev_error_not_allowed;
 #endif
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
-	DUK_ASSERT(!abandon_array || new_a_size == 0);  /* if abandon_array, new_a_size must be 0 */
-	DUK_ASSERT(DUK_HOBJECT_GET_PROPS(thr->heap, obj) != NULL || (DUK_HOBJECT_GET_ESIZE(obj) == 0 && DUK_HOBJECT_GET_ASIZE(obj) == 0));
-	DUK_ASSERT(new_h_size == 0 || new_h_size >= new_e_size);  /* required to guarantee success of rehashing,
-	                                                           * intentionally use unadjusted new_e_size
-	                                                           */
+	DUK_ASSERT(!abandon_array || new_a_size == 0); /* if abandon_array, new_a_size must be 0 */
+	DUK_ASSERT(DUK_HOBJECT_GET_PROPS(thr->heap, obj) != NULL ||
+	           (DUK_HOBJECT_GET_ESIZE(obj) == 0 && DUK_HOBJECT_GET_ASIZE(obj) == 0));
+	DUK_ASSERT(new_h_size == 0 || new_h_size >= new_e_size); /* required to guarantee success of rehashing,
+	                                                          * intentionally use unadjusted new_e_size
+	                                                          */
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj));
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	DUK_STATS_INC(thr->heap, stats_object_realloc_props);
 
 	/*
 	 *  Pre resize assertions.
@@ -57618,44 +58718,45 @@
 #if defined(DUK_USE_HOBJECT_LAYOUT_2) || defined(DUK_USE_HOBJECT_LAYOUT_3)
 	DUK_DDD(DUK_DDDPRINT("using layout 2 or 3, no need to pad e_size: %ld", (long) new_e_size));
 	new_e_size_adjusted = new_e_size;
 #elif defined(DUK_USE_HOBJECT_LAYOUT_1) && (DUK_HOBJECT_ALIGN_TARGET == 1)
 	DUK_DDD(DUK_DDDPRINT("using layout 1, but no need to pad e_size: %ld", (long) new_e_size));
 	new_e_size_adjusted = new_e_size;
 #elif defined(DUK_USE_HOBJECT_LAYOUT_1) && ((DUK_HOBJECT_ALIGN_TARGET == 4) || (DUK_HOBJECT_ALIGN_TARGET == 8))
-	new_e_size_adjusted = (new_e_size + (duk_uint32_t) DUK_HOBJECT_ALIGN_TARGET - 1U) &
-	                      (~((duk_uint32_t) DUK_HOBJECT_ALIGN_TARGET - 1U));
+	new_e_size_adjusted =
+	    (new_e_size + (duk_uint32_t) DUK_HOBJECT_ALIGN_TARGET - 1U) & (~((duk_uint32_t) DUK_HOBJECT_ALIGN_TARGET - 1U));
 	DUK_DDD(DUK_DDDPRINT("using layout 1, and alignment target is %ld, adjusted e_size: %ld -> %ld",
-	                     (long) DUK_HOBJECT_ALIGN_TARGET, (long) new_e_size, (long) new_e_size_adjusted));
+	                     (long) DUK_HOBJECT_ALIGN_TARGET,
+	                     (long) new_e_size,
+	                     (long) new_e_size_adjusted));
 	DUK_ASSERT(new_e_size_adjusted >= new_e_size);
 #else
 #error invalid hobject layout defines
 #endif
 
 	/*
 	 *  Debug logging after adjustment.
 	 */
 
-	DUK_DDD(DUK_DDDPRINT("attempt to resize hobject %p props (%ld -> %ld bytes), from {p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld} to "
-	                     "{e_size=%ld,a_size=%ld,h_size=%ld}, abandon_array=%ld, unadjusted new_e_size=%ld",
-	                     (void *) obj,
-	                     (long) DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj),
-	                                                       DUK_HOBJECT_GET_ASIZE(obj),
-	                                                       DUK_HOBJECT_GET_HSIZE(obj)),
-	                     (long) DUK_HOBJECT_P_COMPUTE_SIZE(new_e_size_adjusted, new_a_size, new_h_size),
-	                     (void *) DUK_HOBJECT_GET_PROPS(thr->heap, obj),
-	                     (long) DUK_HOBJECT_GET_ESIZE(obj),
-	                     (long) DUK_HOBJECT_GET_ENEXT(obj),
-	                     (long) DUK_HOBJECT_GET_ASIZE(obj),
-	                     (long) DUK_HOBJECT_GET_HSIZE(obj),
-	                     (long) new_e_size_adjusted,
-	                     (long) new_a_size,
-	                     (long) new_h_size,
-	                     (long) abandon_array,
-	                     (long) new_e_size));
+	DUK_DDD(DUK_DDDPRINT(
+	    "attempt to resize hobject %p props (%ld -> %ld bytes), from {p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld} to "
+	    "{e_size=%ld,a_size=%ld,h_size=%ld}, abandon_array=%ld, unadjusted new_e_size=%ld",
+	    (void *) obj,
+	    (long) DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj), DUK_HOBJECT_GET_ASIZE(obj), DUK_HOBJECT_GET_HSIZE(obj)),
+	    (long) DUK_HOBJECT_P_COMPUTE_SIZE(new_e_size_adjusted, new_a_size, new_h_size),
+	    (void *) DUK_HOBJECT_GET_PROPS(thr->heap, obj),
+	    (long) DUK_HOBJECT_GET_ESIZE(obj),
+	    (long) DUK_HOBJECT_GET_ENEXT(obj),
+	    (long) DUK_HOBJECT_GET_ASIZE(obj),
+	    (long) DUK_HOBJECT_GET_HSIZE(obj),
+	    (long) new_e_size_adjusted,
+	    (long) new_a_size,
+	    (long) new_h_size,
+	    (long) abandon_array,
+	    (long) new_e_size));
 
 	/*
 	 *  Property count check.  This is the only point where we ensure that
 	 *  we don't get more (allocated) property space that we can handle.
 	 *  There aren't hard limits as such, but some algorithms may fail
 	 *  if we get too close to the 4G property limit.
 	 *
@@ -57690,30 +58791,30 @@
 	 * within error handling so can't assert for error_not_allowed == 0.
 	 */
 	prev_error_not_allowed = thr->heap->error_not_allowed;
 	thr->heap->error_not_allowed = 1;
 #endif
 	prev_ms_base_flags = thr->heap->ms_base_flags;
 	thr->heap->ms_base_flags |=
-	        DUK_MS_FLAG_NO_OBJECT_COMPACTION;      /* Avoid attempt to compact the current object (all objects really). */
-	thr->heap->pf_prevent_count++;                 /* Avoid finalizers. */
-	DUK_ASSERT(thr->heap->pf_prevent_count != 0);  /* Wrap. */
+	    DUK_MS_FLAG_NO_OBJECT_COMPACTION; /* Avoid attempt to compact the current object (all objects really). */
+	thr->heap->pf_prevent_count++; /* Avoid finalizers. */
+	DUK_ASSERT(thr->heap->pf_prevent_count != 0); /* Wrap. */
 
 	new_alloc_size = DUK_HOBJECT_P_COMPUTE_SIZE(new_e_size_adjusted, new_a_size, new_h_size);
 	DUK_DDD(DUK_DDDPRINT("new hobject allocation size is %ld", (long) new_alloc_size));
 	if (new_alloc_size == 0) {
 		DUK_ASSERT(new_e_size_adjusted == 0);
 		DUK_ASSERT(new_a_size == 0);
 		DUK_ASSERT(new_h_size == 0);
 		new_p = NULL;
 	} else {
 		/* Alloc may trigger mark-and-sweep but no compaction, and
 		 * cannot throw.
 		 */
-#if 0  /* XXX: inject test */
+#if 0 /* XXX: inject test */
 		if (1) {
 			new_p = NULL;
 			goto alloc_failed;
 		}
 #endif
 		new_p = (duk_uint8_t *) DUK_ALLOC(thr->heap, new_alloc_size);
 		if (new_p == NULL) {
@@ -57723,27 +58824,36 @@
 			goto alloc_failed;
 		}
 	}
 
 	/* Set up pointers to the new property area: this is hidden behind a macro
 	 * because it is memory layout specific.
 	 */
-	DUK_HOBJECT_P_SET_REALLOC_PTRS(new_p, new_e_k, new_e_pv, new_e_f, new_a, new_h,
-	                               new_e_size_adjusted, new_a_size, new_h_size);
-	DUK_UNREF(new_h);  /* happens when hash part dropped */
+	DUK_HOBJECT_P_SET_REALLOC_PTRS(new_p,
+	                               new_e_k,
+	                               new_e_pv,
+	                               new_e_f,
+	                               new_a,
+	                               new_h,
+	                               new_e_size_adjusted,
+	                               new_a_size,
+	                               new_h_size);
+	DUK_UNREF(new_h); /* happens when hash part dropped */
 	new_e_next = 0;
 
 	/* if new_p == NULL, all of these pointers are NULL */
-	DUK_ASSERT((new_p != NULL) ||
-	           (new_e_k == NULL && new_e_pv == NULL && new_e_f == NULL &&
-	            new_a == NULL && new_h == NULL));
+	DUK_ASSERT((new_p != NULL) || (new_e_k == NULL && new_e_pv == NULL && new_e_f == NULL && new_a == NULL && new_h == NULL));
 
 	DUK_DDD(DUK_DDDPRINT("new alloc size %ld, new_e_k=%p, new_e_pv=%p, new_e_f=%p, new_a=%p, new_h=%p",
-	                     (long) new_alloc_size, (void *) new_e_k, (void *) new_e_pv, (void *) new_e_f,
-	                     (void *) new_a, (void *) new_h));
+	                     (long) new_alloc_size,
+	                     (void *) new_e_k,
+	                     (void *) new_e_pv,
+	                     (void *) new_e_f,
+	                     (void *) new_a,
+	                     (void *) new_h));
 
 	/*
 	 *  Migrate array part to start of entries if requested.
 	 *
 	 *  Note: from an enumeration perspective the order of entry keys matters.
 	 *  Array keys should appear wherever they appeared before the array abandon
 	 *  operation.  (This no longer matters much because keys are ES2015 sorted.)
@@ -57776,28 +58886,27 @@
 			DUK_ASSERT(DUK_HOBJECT_GET_PROPS(thr->heap, obj) != NULL);
 
 			tv1 = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, i);
 			if (DUK_TVAL_IS_UNUSED(tv1)) {
 				continue;
 			}
 
-			DUK_ASSERT(new_p != NULL && new_e_k != NULL &&
-			           new_e_pv != NULL && new_e_f != NULL);
+			DUK_ASSERT(new_p != NULL && new_e_k != NULL && new_e_pv != NULL && new_e_f != NULL);
 
 			/*
 			 *  Intern key via the valstack to ensure reachability behaves
 			 *  properly.  We must avoid longjmp's here so use non-checked
 			 *  primitives.
 			 *
 			 *  Note: duk_check_stack() potentially reallocs the valstack,
 			 *  invalidating any duk_tval pointers to valstack.  Callers
 			 *  must be careful.
 			 */
 
-#if 0  /* XXX: inject test */
+#if 0 /* XXX: inject test */
 			if (1) {
 				goto abandon_error;
 			}
 #endif
 			/* Never shrinks; auto-adds DUK_VALSTACK_INTERNAL_EXTRA, which
 			 * is generous.
 			 */
@@ -57805,27 +58914,26 @@
 				goto abandon_error;
 			}
 			DUK_ASSERT_VALSTACK_SPACE(thr, 1);
 			key = duk_heap_strtable_intern_u32(thr->heap, (duk_uint32_t) i);
 			if (key == NULL) {
 				goto abandon_error;
 			}
-			duk_push_hstring(thr, key);  /* keep key reachable for GC etc; guaranteed not to fail */
+			duk_push_hstring(thr, key); /* keep key reachable for GC etc; guaranteed not to fail */
 
 			/* Key is now reachable in the valstack, don't INCREF
 			 * the new allocation yet (we'll steal the refcounts
 			 * from the value stack once all keys are done).
 			 */
 
 			new_e_k[new_e_next] = key;
-			tv2 = &new_e_pv[new_e_next].v;  /* array entries are all plain values */
+			tv2 = &new_e_pv[new_e_next].v; /* array entries are all plain values */
 			DUK_TVAL_SET_TVAL(tv2, tv1);
-			new_e_f[new_e_next] = DUK_PROPDESC_FLAG_WRITABLE |
-			                      DUK_PROPDESC_FLAG_ENUMERABLE |
-			                      DUK_PROPDESC_FLAG_CONFIGURABLE;
+			new_e_f[new_e_next] =
+			    DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE | DUK_PROPDESC_FLAG_CONFIGURABLE;
 			new_e_next++;
 
 			/* Note: new_e_next matches pushed temp key count, and nothing can
 			 * fail above between the push and this point.
 			 */
 		}
 
@@ -57844,16 +58952,15 @@
 		DUK_ASSERT(DUK_HOBJECT_GET_PROPS(thr->heap, obj) != NULL);
 
 		key = DUK_HOBJECT_E_GET_KEY(thr->heap, obj, i);
 		if (key == NULL) {
 			continue;
 		}
 
-		DUK_ASSERT(new_p != NULL && new_e_k != NULL &&
-		           new_e_pv != NULL && new_e_f != NULL);
+		DUK_ASSERT(new_p != NULL && new_e_k != NULL && new_e_pv != NULL && new_e_f != NULL);
 
 		new_e_k[new_e_next] = key;
 		new_e_pv[new_e_next] = DUK_HOBJECT_E_GET_VALUE(thr->heap, obj, i);
 		new_e_f[new_e_next] = DUK_HOBJECT_E_GET_FLAGS(thr->heap, obj, i);
 		new_e_next++;
 	}
 	/* the entries [new_e_next, new_e_size_adjusted[ are left uninitialized on purpose (ok, not gc reachable) */
@@ -57879,17 +58986,15 @@
 	} else {
 		array_copy_size = sizeof(duk_tval) * new_a_size;
 	}
 
 	DUK_ASSERT(new_a != NULL || array_copy_size == 0U);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROPS(thr->heap, obj) != NULL || array_copy_size == 0U);
 	DUK_ASSERT(DUK_HOBJECT_GET_ASIZE(obj) > 0 || array_copy_size == 0U);
-	duk_memcpy_unsafe((void *) new_a,
-	                  (const void *) DUK_HOBJECT_A_GET_BASE(thr->heap, obj),
-	                  array_copy_size);
+	duk_memcpy_unsafe((void *) new_a, (const void *) DUK_HOBJECT_A_GET_BASE(thr->heap, obj), array_copy_size);
 
 	for (i = DUK_HOBJECT_GET_ASIZE(obj); i < new_a_size; i++) {
 		duk_tval *tv = &new_a[i];
 		DUK_TVAL_SET_UNUSED(tv);
 	}
 
 	/*
@@ -57909,70 +59014,69 @@
 
 		DUK_ASSERT(new_h != NULL);
 
 		/* fill new_h with u32 0xff = UNUSED */
 		DUK_ASSERT(new_h_size > 0);
 		duk_memset(new_h, 0xff, sizeof(duk_uint32_t) * new_h_size);
 
-		DUK_ASSERT(new_e_next <= new_h_size);  /* equality not actually possible */
+		DUK_ASSERT(new_e_next <= new_h_size); /* equality not actually possible */
 
 		mask = new_h_size - 1;
 		for (i = 0; i < new_e_next; i++) {
 			duk_hstring *key = new_e_k[i];
 			duk_uint32_t j, step;
 
 			DUK_ASSERT(key != NULL);
 			j = DUK_HSTRING_GET_HASH(key) & mask;
-			step = 1;  /* Cache friendly but clustering prone. */
+			step = 1; /* Cache friendly but clustering prone. */
 
 			for (;;) {
-				DUK_ASSERT(new_h[j] != DUK__HASH_DELETED);  /* should never happen */
+				DUK_ASSERT(new_h[j] != DUK__HASH_DELETED); /* should never happen */
 				if (new_h[j] == DUK__HASH_UNUSED) {
 					DUK_DDD(DUK_DDDPRINT("rebuild hit %ld -> %ld", (long) j, (long) i));
 					new_h[j] = (duk_uint32_t) i;
 					break;
 				}
 				DUK_DDD(DUK_DDDPRINT("rebuild miss %ld, step %ld", (long) j, (long) step));
 				j = (j + step) & mask;
 
 				/* Guaranteed to finish (hash is larger than #props). */
 			}
 		}
 	}
-#endif  /* DUK_USE_HOBJECT_HASH_PART */
+#endif /* DUK_USE_HOBJECT_HASH_PART */
 
 	/*
 	 *  Nice debug log.
 	 */
 
-	DUK_DD(DUK_DDPRINT("resized hobject %p props (%ld -> %ld bytes), from {p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld} to "
-	                   "{p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld}, abandon_array=%ld, unadjusted new_e_size=%ld",
-	                   (void *) obj,
-	                   (long) DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj),
-	                                                     DUK_HOBJECT_GET_ASIZE(obj),
-	                                                     DUK_HOBJECT_GET_HSIZE(obj)),
-	                   (long) new_alloc_size,
-	                   (void *) DUK_HOBJECT_GET_PROPS(thr->heap, obj),
-	                   (long) DUK_HOBJECT_GET_ESIZE(obj),
-	                   (long) DUK_HOBJECT_GET_ENEXT(obj),
-	                   (long) DUK_HOBJECT_GET_ASIZE(obj),
-	                   (long) DUK_HOBJECT_GET_HSIZE(obj),
-	                   (void *) new_p,
-	                   (long) new_e_size_adjusted,
-	                   (long) new_e_next,
-	                   (long) new_a_size,
-	                   (long) new_h_size,
-	                   (long) abandon_array,
-	                   (long) new_e_size));
+	DUK_DD(DUK_DDPRINT(
+	    "resized hobject %p props (%ld -> %ld bytes), from {p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld} to "
+	    "{p=%p,e_size=%ld,e_next=%ld,a_size=%ld,h_size=%ld}, abandon_array=%ld, unadjusted new_e_size=%ld",
+	    (void *) obj,
+	    (long) DUK_HOBJECT_P_COMPUTE_SIZE(DUK_HOBJECT_GET_ESIZE(obj), DUK_HOBJECT_GET_ASIZE(obj), DUK_HOBJECT_GET_HSIZE(obj)),
+	    (long) new_alloc_size,
+	    (void *) DUK_HOBJECT_GET_PROPS(thr->heap, obj),
+	    (long) DUK_HOBJECT_GET_ESIZE(obj),
+	    (long) DUK_HOBJECT_GET_ENEXT(obj),
+	    (long) DUK_HOBJECT_GET_ASIZE(obj),
+	    (long) DUK_HOBJECT_GET_HSIZE(obj),
+	    (void *) new_p,
+	    (long) new_e_size_adjusted,
+	    (long) new_e_next,
+	    (long) new_a_size,
+	    (long) new_h_size,
+	    (long) abandon_array,
+	    (long) new_e_size));
 
 	/*
 	 *  All done, switch properties ('p') allocation to new one.
 	 */
 
-	DUK_FREE_CHECKED(thr, DUK_HOBJECT_GET_PROPS(thr->heap, obj));  /* NULL obj->p is OK */
+	DUK_FREE_CHECKED(thr, DUK_HOBJECT_GET_PROPS(thr->heap, obj)); /* NULL obj->p is OK */
 	DUK_HOBJECT_SET_PROPS(thr->heap, obj, new_p);
 	DUK_HOBJECT_SET_ESIZE(obj, new_e_size_adjusted);
 	DUK_HOBJECT_SET_ENEXT(obj, new_e_next);
 	DUK_HOBJECT_SET_ASIZE(obj, new_a_size);
 	DUK_HOBJECT_SET_HSIZE(obj, new_h_size);
 
 	/* Clear array part flag only after switching. */
@@ -58003,19 +59107,19 @@
 	 *  Abandon array failed.  We don't need to DECREF anything
 	 *  because the references in the new allocation are not
 	 *  INCREF'd until abandon is complete.  The string interned
 	 *  keys are on the value stack and are handled normally by
 	 *  unwind.
 	 */
 
- abandon_error:
- alloc_failed:
+abandon_error:
+alloc_failed:
 	DUK_D(DUK_DPRINT("object property table resize failed"));
 
-	DUK_FREE_CHECKED(thr, new_p);  /* OK for NULL. */
+	DUK_FREE_CHECKED(thr, new_p); /* OK for NULL. */
 
 	thr->heap->pf_prevent_count--;
 	thr->heap->ms_base_flags = prev_ms_base_flags;
 #if defined(DUK_USE_ASSERTIONS)
 	DUK_ASSERT(thr->heap->error_not_allowed == 1);
 	thr->heap->error_not_allowed = prev_error_not_allowed;
 #endif
@@ -58024,17 +59128,15 @@
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Helpers to resize properties allocation on specific needs.
  */
 
-DUK_INTERNAL void duk_hobject_resize_entrypart(duk_hthread *thr,
-                                               duk_hobject *obj,
-                                               duk_uint32_t new_e_size) {
+DUK_INTERNAL void duk_hobject_resize_entrypart(duk_hthread *thr, duk_hobject *obj, duk_uint32_t new_e_size) {
 	duk_uint32_t old_e_size;
 	duk_uint32_t new_a_size;
 	duk_uint32_t new_h_size;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
 
@@ -58050,15 +59152,15 @@
 	new_a_size = DUK_HOBJECT_GET_ASIZE(obj);
 
 	duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
 }
 
 /* Grow entry part allocation for one additional entry. */
 DUK_LOCAL void duk__grow_props_for_new_entry_item(duk_hthread *thr, duk_hobject *obj) {
-	duk_uint32_t old_e_used;  /* actually used, non-NULL entries */
+	duk_uint32_t old_e_used; /* actually used, non-NULL entries */
 	duk_uint32_t new_e_size_minimum;
 	duk_uint32_t new_e_size;
 	duk_uint32_t new_a_size;
 	duk_uint32_t new_h_size;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
@@ -58112,15 +59214,15 @@
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(highest_arr_idx >= DUK_HOBJECT_GET_ASIZE(obj));
 
 	new_e_size = DUK_HOBJECT_GET_ESIZE(obj);
 	new_h_size = DUK_HOBJECT_GET_HSIZE(obj);
 	new_a_size_minimum = highest_arr_idx + 1;
 	new_a_size = highest_arr_idx + duk__get_min_grow_a(highest_arr_idx);
-	DUK_ASSERT(new_a_size >= highest_arr_idx + 1);  /* duk__get_min_grow_a() is always >= 1 */
+	DUK_ASSERT(new_a_size >= highest_arr_idx + 1); /* duk__get_min_grow_a() is always >= 1 */
 
 #if defined(DUK_USE_OBJSIZES16)
 	if (new_e_size > DUK_UINT16_MAX) {
 		new_e_size = DUK_UINT16_MAX;
 	}
 	if (new_h_size > DUK_UINT16_MAX) {
 		new_h_size = DUK_UINT16_MAX;
@@ -58144,15 +59246,15 @@
  * this is not strictly required.
  */
 DUK_LOCAL void duk__abandon_array_part(duk_hthread *thr, duk_hobject *obj) {
 	duk_uint32_t new_e_size_minimum;
 	duk_uint32_t new_e_size;
 	duk_uint32_t new_a_size;
 	duk_uint32_t new_h_size;
-	duk_uint32_t e_used;  /* actually used, non-NULL keys */
+	duk_uint32_t e_used; /* actually used, non-NULL keys */
 	duk_uint32_t a_used;
 	duk_uint32_t a_size;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
 
 	e_used = duk__count_used_e_keys(thr, obj);
@@ -58189,16 +59291,21 @@
 		DUK_ERROR_ALLOC_FAILED(thr);
 		DUK_WO_NORETURN(return;);
 	}
 
 	DUK_DD(DUK_DDPRINT("abandon array part for hobject %p, "
 	                   "array stats before: e_used=%ld, a_used=%ld, a_size=%ld; "
 	                   "resize to e_size=%ld, a_size=%ld, h_size=%ld",
-	                   (void *) obj, (long) e_used, (long) a_used, (long) a_size,
-	                   (long) new_e_size, (long) new_a_size, (long) new_h_size));
+	                   (void *) obj,
+	                   (long) e_used,
+	                   (long) a_used,
+	                   (long) a_size,
+	                   (long) new_e_size,
+	                   (long) new_a_size,
+	                   (long) new_h_size));
 
 	duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 1);
 }
 
 /*
  *  Compact an object.  Minimizes allocation size for objects which are
  *  not likely to be extended.  This is useful for internal and non-
@@ -58208,17 +59315,17 @@
  *  This call is relatively expensive, as it needs to scan both the
  *  entries and the array part.
  *
  *  The call may fail due to allocation error.
  */
 
 DUK_INTERNAL void duk_hobject_compact_props(duk_hthread *thr, duk_hobject *obj) {
-	duk_uint32_t e_size;       /* currently used -> new size */
-	duk_uint32_t a_size;       /* currently required */
-	duk_uint32_t a_used;       /* actually used */
+	duk_uint32_t e_size; /* currently used -> new size */
+	duk_uint32_t a_size; /* currently required */
+	duk_uint32_t a_used; /* actually used */
 	duk_uint32_t h_size;
 	duk_bool_t abandon_array;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
 
 #if defined(DUK_USE_ROM_OBJECTS)
@@ -58229,21 +59336,25 @@
 #endif
 
 	e_size = duk__count_used_e_keys(thr, obj);
 	duk__compute_a_stats(thr, obj, &a_used, &a_size);
 
 	DUK_DD(DUK_DDPRINT("compacting hobject, used e keys %ld, used a keys %ld, min a size %ld, "
 	                   "resized array density would be: %ld/%ld = %lf",
-	                   (long) e_size, (long) a_used, (long) a_size,
-	                   (long) a_used, (long) a_size,
+	                   (long) e_size,
+	                   (long) a_used,
+	                   (long) a_size,
+	                   (long) a_used,
+	                   (long) a_size,
 	                   (double) a_used / (double) a_size));
 
 	if (duk__abandon_array_density_check(a_used, a_size)) {
 		DUK_DD(DUK_DDPRINT("decided to abandon array during compaction, a_used=%ld, a_size=%ld",
-		                   (long) a_used, (long) a_size));
+		                   (long) a_used,
+		                   (long) a_size));
 		abandon_array = 1;
 		e_size += a_used;
 		a_size = 0;
 	} else {
 		DUK_DD(DUK_DDPRINT("decided to keep array during compaction"));
 		abandon_array = 0;
 	}
@@ -58255,38 +59366,41 @@
 		h_size = 0;
 	}
 #else
 	h_size = 0;
 #endif
 
 	DUK_DD(DUK_DDPRINT("compacting hobject -> new e_size %ld, new a_size=%ld, new h_size=%ld, abandon_array=%ld",
-	                   (long) e_size, (long) a_size, (long) h_size, (long) abandon_array));
+	                   (long) e_size,
+	                   (long) a_size,
+	                   (long) h_size,
+	                   (long) abandon_array));
 
 	duk_hobject_realloc_props(thr, obj, e_size, a_size, h_size, abandon_array);
 }
 
 /*
  *  Find an existing key from entry part either by linear scan or by
  *  using the hash index (if it exists).
  *
  *  Sets entry index (and possibly the hash index) to output variables,
  *  which allows the caller to update the entry and hash entries in-place.
  *  If entry is not found, both values are set to -1.  If entry is found
  *  but there is no hash part, h_idx is set to -1.
  */
 
-DUK_INTERNAL duk_bool_t duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx) {
+DUK_INTERNAL duk_bool_t
+duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx) {
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(e_idx != NULL);
 	DUK_ASSERT(h_idx != NULL);
 	DUK_UNREF(heap);
 
-	if (DUK_LIKELY(DUK_HOBJECT_GET_HSIZE(obj) == 0))
-	{
+	if (DUK_LIKELY(DUK_HOBJECT_GET_HSIZE(obj) == 0)) {
 		/* Linear scan: more likely because most objects are small.
 		 * This is an important fast path.
 		 *
 		 * XXX: this might be worth inlining for property lookups.
 		 */
 		duk_uint_fast32_t i;
 		duk_uint_fast32_t n;
@@ -58300,62 +59414,59 @@
 				*e_idx = (duk_int_t) i;
 				*h_idx = -1;
 				return 1;
 			}
 		}
 	}
 #if defined(DUK_USE_HOBJECT_HASH_PART)
-	else
-	{
+	else {
 		/* hash lookup */
 		duk_uint32_t n;
 		duk_uint32_t i, step;
 		duk_uint32_t *h_base;
 		duk_uint32_t mask;
 
 		DUK_DDD(DUK_DDDPRINT("duk_hobject_find_entry() using hash part for lookup"));
 
 		h_base = DUK_HOBJECT_H_GET_BASE(heap, obj);
 		n = DUK_HOBJECT_GET_HSIZE(obj);
 		mask = n - 1;
 		i = DUK_HSTRING_GET_HASH(key) & mask;
-		step = 1;  /* Cache friendly but clustering prone. */
+		step = 1; /* Cache friendly but clustering prone. */
 
 		for (;;) {
 			duk_uint32_t t;
 
-			DUK_ASSERT_DISABLE(i >= 0);  /* unsigned */
+			DUK_ASSERT_DISABLE(i >= 0); /* unsigned */
 			DUK_ASSERT(i < DUK_HOBJECT_GET_HSIZE(obj));
 			t = h_base[i];
 			DUK_ASSERT(t == DUK__HASH_UNUSED || t == DUK__HASH_DELETED ||
-			           (t < DUK_HOBJECT_GET_ESIZE(obj)));  /* t >= 0 always true, unsigned */
+			           (t < DUK_HOBJECT_GET_ESIZE(obj))); /* t >= 0 always true, unsigned */
 
 			if (t == DUK__HASH_UNUSED) {
 				break;
 			} else if (t == DUK__HASH_DELETED) {
-				DUK_DDD(DUK_DDDPRINT("lookup miss (deleted) i=%ld, t=%ld",
-				                     (long) i, (long) t));
+				DUK_DDD(DUK_DDDPRINT("lookup miss (deleted) i=%ld, t=%ld", (long) i, (long) t));
 			} else {
 				DUK_ASSERT(t < DUK_HOBJECT_GET_ESIZE(obj));
 				if (DUK_HOBJECT_E_GET_KEY(heap, obj, t) == key) {
-					DUK_DDD(DUK_DDDPRINT("lookup hit i=%ld, t=%ld -> key %p",
-					                     (long) i, (long) t, (void *) key));
+					DUK_DDD(
+					    DUK_DDDPRINT("lookup hit i=%ld, t=%ld -> key %p", (long) i, (long) t, (void *) key));
 					*e_idx = (duk_int_t) t;
 					*h_idx = (duk_int_t) i;
 					return 1;
 				}
-				DUK_DDD(DUK_DDDPRINT("lookup miss i=%ld, t=%ld",
-				                     (long) i, (long) t));
+				DUK_DDD(DUK_DDDPRINT("lookup miss i=%ld, t=%ld", (long) i, (long) t));
 			}
 			i = (i + step) & mask;
 
 			/* Guaranteed to finish (hash is larger than #props). */
 		}
 	}
-#endif  /* DUK_USE_HOBJECT_HASH_PART */
+#endif /* DUK_USE_HOBJECT_HASH_PART */
 
 	/* Not found, leave e_idx and h_idx unset. */
 	return 0;
 }
 
 /* For internal use: get non-accessor entry value */
 DUK_INTERNAL duk_tval *duk_hobject_find_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key) {
@@ -58376,15 +59487,18 @@
 }
 
 DUK_INTERNAL duk_tval *duk_hobject_find_entry_tval_ptr_stridx(duk_heap *heap, duk_hobject *obj, duk_small_uint_t stridx) {
 	return duk_hobject_find_entry_tval_ptr(heap, obj, DUK_HEAP_GET_STRING(heap, stridx));
 }
 
 /* For internal use: get non-accessor entry value and attributes */
-DUK_INTERNAL duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_uint_t *out_attrs) {
+DUK_INTERNAL duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap,
+                                                                 duk_hobject *obj,
+                                                                 duk_hstring *key,
+                                                                 duk_uint_t *out_attrs) {
 	duk_int_t e_idx;
 	duk_int_t h_idx;
 
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(out_attrs != NULL);
 	DUK_UNREF(heap);
@@ -58461,35 +59575,36 @@
 		duk_uint32_t n, mask;
 		duk_uint32_t i, step;
 		duk_uint32_t *h_base = DUK_HOBJECT_H_GET_BASE(thr->heap, obj);
 
 		n = DUK_HOBJECT_GET_HSIZE(obj);
 		mask = n - 1;
 		i = DUK_HSTRING_GET_HASH(key) & mask;
-		step = 1;  /* Cache friendly but clustering prone. */
+		step = 1; /* Cache friendly but clustering prone. */
 
 		for (;;) {
 			duk_uint32_t t = h_base[i];
 			if (t == DUK__HASH_UNUSED || t == DUK__HASH_DELETED) {
 				DUK_DDD(DUK_DDDPRINT("duk__hobject_alloc_entry_checked() inserted key into hash part, %ld -> %ld",
-				                     (long) i, (long) idx));
-				DUK_ASSERT_DISABLE(i >= 0);  /* unsigned */
+				                     (long) i,
+				                     (long) idx));
+				DUK_ASSERT_DISABLE(i >= 0); /* unsigned */
 				DUK_ASSERT(i < DUK_HOBJECT_GET_HSIZE(obj));
 				DUK_ASSERT_DISABLE(idx >= 0);
 				DUK_ASSERT(idx < DUK_HOBJECT_GET_ESIZE(obj));
 				h_base[i] = idx;
 				break;
 			}
 			DUK_DDD(DUK_DDDPRINT("duk__hobject_alloc_entry_checked() miss %ld", (long) i));
 			i = (i + step) & mask;
 
 			/* Guaranteed to finish (hash is larger than #props). */
 		}
 	}
-#endif  /* DUK_USE_HOBJECT_HASH_PART */
+#endif /* DUK_USE_HOBJECT_HASH_PART */
 
 	/* Note: we could return the hash index here too, but it's not
 	 * needed right now.
 	 */
 
 	DUK_ASSERT_DISABLE(idx >= 0);
 	DUK_ASSERT(idx < DUK_HOBJECT_GET_ESIZE(obj));
@@ -58589,57 +59704,64 @@
 	duk_hobject *varenv;
 	duk_bool_t rc;
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	DUK_DDD(DUK_DDDPRINT("arguments map lookup: thr=%p, obj=%p, key=%p, temp_desc=%p "
 	                     "(obj -> %!O, key -> %!O)",
-	                     (void *) thr, (void *) obj, (void *) key, (void *) temp_desc,
-	                     (duk_heaphdr *) obj, (duk_heaphdr *) key));
+	                     (void *) thr,
+	                     (void *) obj,
+	                     (void *) key,
+	                     (void *) temp_desc,
+	                     (duk_heaphdr *) obj,
+	                     (duk_heaphdr *) key));
 
 	if (!duk_hobject_get_own_propdesc(thr, obj, DUK_HTHREAD_STRING_INT_MAP(thr), temp_desc, DUK_GETDESC_FLAG_PUSH_VALUE)) {
 		DUK_DDD(DUK_DDDPRINT("-> no 'map'"));
 		return 0;
 	}
 
 	map = duk_require_hobject(thr, -1);
 	DUK_ASSERT(map != NULL);
-	duk_pop_unsafe(thr);  /* map is reachable through obj */
+	duk_pop_unsafe(thr); /* map is reachable through obj */
 
 	if (!duk_hobject_get_own_propdesc(thr, map, key, temp_desc, DUK_GETDESC_FLAG_PUSH_VALUE)) {
 		DUK_DDD(DUK_DDDPRINT("-> 'map' exists, but key not in map"));
 		return 0;
 	}
 
 	/* [... varname] */
 	DUK_DDD(DUK_DDDPRINT("-> 'map' exists, and contains key, key is mapped to argument/variable binding %!T",
 	                     (duk_tval *) duk_get_tval(thr, -1)));
-	DUK_ASSERT(duk_is_string(thr, -1));  /* guaranteed when building arguments */
+	DUK_ASSERT(duk_is_string(thr, -1)); /* guaranteed when building arguments */
 
 	/* get varenv for varname (callee's declarative lexical environment) */
 	rc = duk_hobject_get_own_propdesc(thr, obj, DUK_HTHREAD_STRING_INT_VARENV(thr), temp_desc, DUK_GETDESC_FLAG_PUSH_VALUE);
 	DUK_UNREF(rc);
-	DUK_ASSERT(rc != 0);  /* arguments MUST have an initialized lexical environment reference */
+	DUK_ASSERT(rc != 0); /* arguments MUST have an initialized lexical environment reference */
 	varenv = duk_require_hobject(thr, -1);
 	DUK_ASSERT(varenv != NULL);
-	duk_pop_unsafe(thr);  /* varenv remains reachable through 'obj' */
+	duk_pop_unsafe(thr); /* varenv remains reachable through 'obj' */
 
 	DUK_DDD(DUK_DDDPRINT("arguments varenv is: %!dO", (duk_heaphdr *) varenv));
 
 	/* success: leave varname in stack */
 	*out_map = map;
 	*out_varenv = varenv;
-	return 1;  /* [... varname] */
+	return 1; /* [... varname] */
 }
 
 /* Lookup 'key' from arguments internal 'map', and leave replacement value
  * on stack top if mapped (and return non-zero).
  * Used in E5 Section 10.6 algorithm for [[GetOwnProperty]] (used by [[Get]]).
  */
-DUK_LOCAL duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc) {
+DUK_LOCAL duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr,
+                                                      duk_hobject *obj,
+                                                      duk_hstring *key,
+                                                      duk_propdesc *temp_desc) {
 	duk_hobject *map;
 	duk_hobject *varenv;
 	duk_hstring *varname;
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
@@ -58647,15 +59769,15 @@
 		return 0;
 	}
 
 	/* [... varname] */
 
 	varname = duk_require_hstring(thr, -1);
 	DUK_ASSERT(varname != NULL);
-	duk_pop_unsafe(thr);  /* varname is still reachable */
+	duk_pop_unsafe(thr); /* varname is still reachable */
 
 	DUK_DDD(DUK_DDDPRINT("arguments object automatic getvar for a bound variable; "
 	                     "key=%!O, varname=%!O",
 	                     (duk_heaphdr *) key,
 	                     (duk_heaphdr *) varname));
 
 	(void) duk_js_getvar_envrec(thr, varenv, varname, 1 /*throw*/);
@@ -58668,15 +59790,19 @@
 	return 1;
 }
 
 /* Lookup 'key' from arguments internal 'map', perform a variable write if mapped.
  * Used in E5 Section 10.6 algorithm for [[DefineOwnProperty]] (used by [[Put]]).
  * Assumes stack top contains 'put' value (which is NOT popped).
  */
-DUK_LOCAL void duk__check_arguments_map_for_put(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc, duk_bool_t throw_flag) {
+DUK_LOCAL void duk__check_arguments_map_for_put(duk_hthread *thr,
+                                                duk_hobject *obj,
+                                                duk_hstring *key,
+                                                duk_propdesc *temp_desc,
+                                                duk_bool_t throw_flag) {
 	duk_hobject *map;
 	duk_hobject *varenv;
 	duk_hstring *varname;
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
@@ -58684,15 +59810,15 @@
 		return;
 	}
 
 	/* [... put_value varname] */
 
 	varname = duk_require_hstring(thr, -1);
 	DUK_ASSERT(varname != NULL);
-	duk_pop_unsafe(thr);  /* varname is still reachable */
+	duk_pop_unsafe(thr); /* varname is still reachable */
 
 	DUK_DDD(DUK_DDDPRINT("arguments object automatic putvar for a bound variable; "
 	                     "key=%!O, varname=%!O, value=%!T",
 	                     (duk_heaphdr *) key,
 	                     (duk_heaphdr *) varname,
 	                     (duk_tval *) duk_require_tval(thr, -1)));
 
@@ -58723,23 +59849,22 @@
 	if (!duk_hobject_get_own_propdesc(thr, obj, DUK_HTHREAD_STRING_INT_MAP(thr), temp_desc, DUK_GETDESC_FLAG_PUSH_VALUE)) {
 		DUK_DDD(DUK_DDDPRINT("arguments: key not mapped, no exotic delete behavior"));
 		return;
 	}
 
 	map = duk_require_hobject(thr, -1);
 	DUK_ASSERT(map != NULL);
-	duk_pop_unsafe(thr);  /* map is reachable through obj */
+	duk_pop_unsafe(thr); /* map is reachable through obj */
 
-	DUK_DDD(DUK_DDDPRINT("-> have 'map', delete key %!O from map (if exists)); ignore result",
-	                     (duk_heaphdr *) key));
+	DUK_DDD(DUK_DDDPRINT("-> have 'map', delete key %!O from map (if exists)); ignore result", (duk_heaphdr *) key));
 
 	/* Note: no recursion issue, we can trust 'map' to behave */
 	DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_BEHAVIOR(map));
 	DUK_DDD(DUK_DDDPRINT("map before deletion: %!O", (duk_heaphdr *) map));
-	(void) duk_hobject_delprop_raw(thr, map, key, 0);  /* ignore result */
+	(void) duk_hobject_delprop_raw(thr, map, key, 0); /* ignore result */
 	DUK_DDD(DUK_DDDPRINT("map after deletion: %!O", (duk_heaphdr *) map));
 }
 
 /*
  *  ECMAScript compliant [[GetOwnProperty]](P), for internal use only.
  *
  *  If property is found:
@@ -58774,22 +59899,32 @@
  *    - There are no virtual accessor properties.  Hence, all getters and
  *      setters are always related to concretely stored properties, which
  *      ensures that the get/set functions in the resulting descriptor are
  *      reachable and have non-zero refcounts.  Should there be virtual
  *      accessor properties later, this would need to change.
  */
 
-DUK_LOCAL duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_uint32_t arr_idx, duk_propdesc *out_desc, duk_small_uint_t flags) {
+DUK_LOCAL duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr,
+                                               duk_hobject *obj,
+                                               duk_hstring *key,
+                                               duk_uint32_t arr_idx,
+                                               duk_propdesc *out_desc,
+                                               duk_small_uint_t flags) {
 	duk_tval *tv;
 
 	DUK_DDD(DUK_DDDPRINT("duk_hobject_get_own_propdesc: thr=%p, obj=%p, key=%p, out_desc=%p, flags=%lx, "
 	                     "arr_idx=%ld (obj -> %!O, key -> %!O)",
-	                     (void *) thr, (void *) obj, (void *) key, (void *) out_desc,
-	                     (long) flags, (long) arr_idx,
-	                     (duk_heaphdr *) obj, (duk_heaphdr *) key));
+	                     (void *) thr,
+	                     (void *) obj,
+	                     (void *) key,
+	                     (void *) out_desc,
+	                     (long) flags,
+	                     (long) arr_idx,
+	                     (duk_heaphdr *) obj,
+	                     (duk_heaphdr *) key));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(out_desc != NULL);
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
@@ -58855,22 +59990,21 @@
 			tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, arr_idx);
 			if (!DUK_TVAL_IS_UNUSED(tv)) {
 				DUK_DDD(DUK_DDDPRINT("-> found in array part"));
 				if (flags & DUK_GETDESC_FLAG_PUSH_VALUE) {
 					duk_push_tval(thr, tv);
 				}
 				/* implicit attributes */
-				out_desc->flags = DUK_PROPDESC_FLAG_WRITABLE |
-				                  DUK_PROPDESC_FLAG_CONFIGURABLE |
-				                  DUK_PROPDESC_FLAG_ENUMERABLE;
+				out_desc->flags =
+				    DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_CONFIGURABLE | DUK_PROPDESC_FLAG_ENUMERABLE;
 				out_desc->get = NULL;
 				out_desc->set = NULL;
 				out_desc->e_idx = -1;
 				out_desc->h_idx = -1;
-				out_desc->a_idx = (duk_int_t) arr_idx;  /* XXX: limit 2G due to being signed */
+				out_desc->a_idx = (duk_int_t) arr_idx; /* XXX: limit 2G due to being signed */
 				goto prop_found;
 			}
 		}
 	}
 
 	DUK_DDD(DUK_DDDPRINT("-> not found as a concrete property"));
 
@@ -58883,15 +60017,16 @@
 		goto prop_not_found;
 	}
 
 	if (DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj)) {
 		duk_harray *a;
 
 		DUK_DDD(DUK_DDDPRINT("array object exotic property get for key: %!O, arr_idx: %ld",
-		                     (duk_heaphdr *) key, (long) arr_idx));
+		                     (duk_heaphdr *) key,
+		                     (long) arr_idx));
 
 		a = (duk_harray *) obj;
 		DUK_HARRAY_ASSERT_VALID(a);
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			DUK_DDD(DUK_DDDPRINT("-> found, key is 'length', length exotic behavior"));
 
@@ -58905,117 +60040,119 @@
 			out_desc->get = NULL;
 			out_desc->set = NULL;
 			out_desc->e_idx = -1;
 			out_desc->h_idx = -1;
 			out_desc->a_idx = -1;
 
 			DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj));
-			goto prop_found_noexotic;  /* cannot be arguments exotic */
+			goto prop_found_noexotic; /* cannot be arguments exotic */
 		}
 	} else if (DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(obj)) {
 		DUK_DDD(DUK_DDDPRINT("string object exotic property get for key: %!O, arr_idx: %ld",
-		                     (duk_heaphdr *) key, (long) arr_idx));
+		                     (duk_heaphdr *) key,
+		                     (long) arr_idx));
 
 		/* XXX: charlen; avoid multiple lookups? */
 
 		if (arr_idx != DUK__NO_ARRAY_INDEX) {
 			duk_hstring *h_val;
 
 			DUK_DDD(DUK_DDDPRINT("array index exists"));
 
 			h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
 			DUK_ASSERT(h_val);
 			if (arr_idx < DUK_HSTRING_GET_CHARLEN(h_val)) {
 				DUK_DDD(DUK_DDDPRINT("-> found, array index inside string"));
 				if (flags & DUK_GETDESC_FLAG_PUSH_VALUE) {
 					duk_push_hstring(thr, h_val);
-					duk_substring(thr, -1, arr_idx, arr_idx + 1);  /* [str] -> [substr] */
+					duk_substring(thr, -1, arr_idx, arr_idx + 1); /* [str] -> [substr] */
 				}
-				out_desc->flags = DUK_PROPDESC_FLAG_ENUMERABLE |  /* E5 Section 15.5.5.2 */
+				out_desc->flags = DUK_PROPDESC_FLAG_ENUMERABLE | /* E5 Section 15.5.5.2 */
 				                  DUK_PROPDESC_FLAG_VIRTUAL;
 				out_desc->get = NULL;
 				out_desc->set = NULL;
 				out_desc->e_idx = -1;
 				out_desc->h_idx = -1;
 				out_desc->a_idx = -1;
 
 				DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj));
-				goto prop_found_noexotic;  /* cannot be arguments exotic */
+				goto prop_found_noexotic; /* cannot be arguments exotic */
 			} else {
 				/* index is above internal string length -> property is fully normal */
 				DUK_DDD(DUK_DDDPRINT("array index outside string -> normal property"));
 			}
 		} else if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			duk_hstring *h_val;
 
 			DUK_DDD(DUK_DDDPRINT("-> found, key is 'length', length exotic behavior"));
 
 			h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
 			DUK_ASSERT(h_val != NULL);
 			if (flags & DUK_GETDESC_FLAG_PUSH_VALUE) {
 				duk_push_uint(thr, (duk_uint_t) DUK_HSTRING_GET_CHARLEN(h_val));
 			}
-			out_desc->flags = DUK_PROPDESC_FLAG_VIRTUAL;  /* E5 Section 15.5.5.1 */
+			out_desc->flags = DUK_PROPDESC_FLAG_VIRTUAL; /* E5 Section 15.5.5.1 */
 			out_desc->get = NULL;
 			out_desc->set = NULL;
 			out_desc->e_idx = -1;
 			out_desc->h_idx = -1;
 			out_desc->a_idx = -1;
 
 			DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj));
-			goto prop_found_noexotic;  /* cannot be arguments exotic */
+			goto prop_found_noexotic; /* cannot be arguments exotic */
 		}
 	}
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 	else if (DUK_HOBJECT_IS_BUFOBJ(obj)) {
 		duk_hbufobj *h_bufobj;
 		duk_uint_t byte_off;
 		duk_small_uint_t elem_size;
 
 		h_bufobj = (duk_hbufobj *) obj;
 		DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
-		DUK_DDD(DUK_DDDPRINT("bufobj property get for key: %!O, arr_idx: %ld",
-		                     (duk_heaphdr *) key, (long) arr_idx));
+		DUK_DDD(DUK_DDDPRINT("bufobj property get for key: %!O, arr_idx: %ld", (duk_heaphdr *) key, (long) arr_idx));
 
 		if (arr_idx != DUK__NO_ARRAY_INDEX && DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h_bufobj)) {
 			DUK_DDD(DUK_DDDPRINT("array index exists"));
 
 			/* Careful with wrapping: arr_idx upshift may easily wrap, whereas
 			 * length downshift won't.
 			 */
 			if (arr_idx < (h_bufobj->length >> h_bufobj->shift)) {
-				byte_off = arr_idx << h_bufobj->shift;  /* no wrap assuming h_bufobj->length is valid */
+				byte_off = arr_idx << h_bufobj->shift; /* no wrap assuming h_bufobj->length is valid */
 				elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
 				if (flags & DUK_GETDESC_FLAG_PUSH_VALUE) {
 					duk_uint8_t *data;
 
-					if (h_bufobj->buf != NULL && DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufobj, byte_off + elem_size)) {
-						data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf) + h_bufobj->offset + byte_off;
+					if (h_bufobj->buf != NULL &&
+					    DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufobj, byte_off + elem_size)) {
+						data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf) +
+						       h_bufobj->offset + byte_off;
 						duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
 					} else {
 						DUK_D(DUK_DPRINT("bufobj access out of underlying buffer, ignoring (read zero)"));
 						duk_push_uint(thr, 0);
 					}
 				}
-				out_desc->flags = DUK_PROPDESC_FLAG_WRITABLE |
-				                  DUK_PROPDESC_FLAG_VIRTUAL;
+				out_desc->flags = DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_VIRTUAL;
 				if (DUK_HOBJECT_GET_CLASS_NUMBER(obj) != DUK_HOBJECT_CLASS_ARRAYBUFFER) {
 					/* ArrayBuffer indices are non-standard and are
 					 * non-enumerable to avoid their serialization.
 					 */
 					out_desc->flags |= DUK_PROPDESC_FLAG_ENUMERABLE;
 				}
 				out_desc->get = NULL;
 				out_desc->set = NULL;
 				out_desc->e_idx = -1;
 				out_desc->h_idx = -1;
 				out_desc->a_idx = -1;
 
 				DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj));
-				goto prop_found_noexotic;  /* cannot be e.g. arguments exotic, since exotic 'traits' are mutually exclusive */
+				goto prop_found_noexotic; /* cannot be e.g. arguments exotic, since exotic 'traits' are mutually
+				                             exclusive */
 			} else {
 				/* index is above internal buffer length -> property is fully normal */
 				DUK_DDD(DUK_DDDPRINT("array index outside buffer -> normal property"));
 			}
 		} else if (key == DUK_HTHREAD_STRING_LENGTH(thr) && DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h_bufobj)) {
 			DUK_DDD(DUK_DDDPRINT("-> found, key is 'length', length exotic behavior"));
 
@@ -59029,55 +60166,54 @@
 			out_desc->get = NULL;
 			out_desc->set = NULL;
 			out_desc->e_idx = -1;
 			out_desc->h_idx = -1;
 			out_desc->a_idx = -1;
 
 			DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj));
-			goto prop_found_noexotic;  /* cannot be arguments exotic */
+			goto prop_found_noexotic; /* cannot be arguments exotic */
 		}
 	}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 	/* Array properties have exotic behavior but they are concrete,
 	 * so no special handling here.
 	 *
 	 * Arguments exotic behavior (E5 Section 10.6, [[GetOwnProperty]]
 	 * is only relevant as a post-check implemented below; hence no
 	 * check here.
 	 */
 
 	/*
 	 *  Not found as concrete or virtual.
 	 */
 
- prop_not_found:
+prop_not_found:
 	DUK_DDD(DUK_DDDPRINT("-> not found (virtual, entry part, or array part)"));
 	DUK_STATS_INC(thr->heap, stats_getownpropdesc_miss);
 	return 0;
 
 	/*
 	 *  Found.
 	 *
 	 *  Arguments object has exotic post-processing, see E5 Section 10.6,
 	 *  description of [[GetOwnProperty]] variant for arguments.
 	 */
 
- prop_found:
+prop_found:
 	DUK_DDD(DUK_DDDPRINT("-> property found, checking for arguments exotic post-behavior"));
 
 	/* Notes:
 	 *  - Only numbered indices are relevant, so arr_idx fast reject is good
 	 *    (this is valid unless there are more than 4**32-1 arguments).
 	 *  - Since variable lookup has no side effects, this can be skipped if
 	 *    DUK_GETDESC_FLAG_PUSH_VALUE is not set.
 	 */
 
-	if (DUK_UNLIKELY(DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj) &&
-	                 arr_idx != DUK__NO_ARRAY_INDEX &&
+	if (DUK_UNLIKELY(DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj) && arr_idx != DUK__NO_ARRAY_INDEX &&
 	                 (flags & DUK_GETDESC_FLAG_PUSH_VALUE))) {
 		duk_propdesc temp_desc;
 
 		/* Magically bound variable cannot be an accessor.  However,
 		 * there may be an accessor property (or a plain property) in
 		 * place with magic behavior removed.  This happens e.g. when
 		 * a magic property is redefined with defineProperty().
@@ -59095,20 +60231,21 @@
 			                     (duk_tval *) duk_get_tval(thr, -2),
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			/* [... old_result result] -> [... result] */
 			duk_remove_m2(thr);
 		}
 	}
 
- prop_found_noexotic:
+prop_found_noexotic:
 	DUK_STATS_INC(thr->heap, stats_getownpropdesc_hit);
 	return 1;
 }
 
-DUK_INTERNAL duk_bool_t duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
+DUK_INTERNAL duk_bool_t
+duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(out_desc != NULL);
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	return duk__get_own_propdesc_raw(thr, obj, key, DUK_HSTRING_GET_ARRIDX_SLOW(key), out_desc, flags);
@@ -59129,15 +60266,16 @@
  *      set)
  *    - Returns zero
  *
  *  May cause arbitrary side effects and invalidate (most) duk_tval
  *  pointers.
  */
 
-DUK_LOCAL duk_bool_t duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
+DUK_LOCAL duk_bool_t
+duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 	duk_hobject *curr;
 	duk_uint32_t arr_idx;
 	duk_uint_t sanity;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
@@ -59147,17 +60285,22 @@
 
 	DUK_STATS_INC(thr->heap, stats_getpropdesc_count);
 
 	arr_idx = DUK_HSTRING_GET_ARRIDX_FAST(key);
 
 	DUK_DDD(DUK_DDDPRINT("duk__get_propdesc: thr=%p, obj=%p, key=%p, out_desc=%p, flags=%lx, "
 	                     "arr_idx=%ld (obj -> %!O, key -> %!O)",
-	                     (void *) thr, (void *) obj, (void *) key, (void *) out_desc,
-	                     (long) flags, (long) arr_idx,
-	                     (duk_heaphdr *) obj, (duk_heaphdr *) key));
+	                     (void *) thr,
+	                     (void *) obj,
+	                     (void *) key,
+	                     (void *) out_desc,
+	                     (long) flags,
+	                     (long) arr_idx,
+	                     (duk_heaphdr *) obj,
+	                     (duk_heaphdr *) key));
 
 	curr = obj;
 	DUK_ASSERT(curr != NULL);
 	sanity = DUK_HOBJECT_PROTOTYPE_CHAIN_SANITY;
 	do {
 		if (duk__get_own_propdesc_raw(thr, curr, key, arr_idx, out_desc, flags)) {
 			/* stack contains value (if requested), 'out_desc' is set */
@@ -59209,19 +60352,16 @@
 #if defined(DUK_USE_ARRAY_PROP_FASTPATH)
 DUK_LOCAL duk_tval *duk__getprop_shallow_fastpath_array_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
 	duk_tval *tv;
 	duk_uint32_t idx;
 
 	DUK_UNREF(thr);
 
-	if (!(DUK_HOBJECT_HAS_ARRAY_PART(obj) &&
-	     !DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj) &&
-	     !DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(obj) &&
-	     !DUK_HOBJECT_IS_BUFOBJ(obj) &&
-	     !DUK_HOBJECT_IS_PROXY(obj))) {
+	if (!(DUK_HOBJECT_HAS_ARRAY_PART(obj) && !DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj) && !DUK_HOBJECT_HAS_EXOTIC_STRINGOBJ(obj) &&
+	      !DUK_HOBJECT_IS_BUFOBJ(obj) && !DUK_HOBJECT_IS_PROXY(obj))) {
 		/* Must have array part and no conflicting exotic behaviors.
 		 * Doesn't need to have array special behavior, e.g. Arguments
 		 * object has array part.
 		 */
 		return NULL;
 	}
 
@@ -59231,15 +60371,15 @@
 	                     "behavior, object has array part)"));
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_key)) {
 		idx = duk__tval_fastint_to_arr_idx(tv_key);
 	} else
 #endif
-	if (DUK_TVAL_IS_DOUBLE(tv_key)) {
+	    if (DUK_TVAL_IS_DOUBLE(tv_key)) {
 		idx = duk__tval_number_to_arr_idx(tv_key);
 	} else {
 		DUK_DDD(DUK_DDDPRINT("key is not a number"));
 		return NULL;
 	}
 
 	/* If index is not valid, idx will be DUK__NO_ARRAY_INDEX which
@@ -59265,78 +60405,80 @@
 		return tv;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("fast path attempt failed, fall back to slow path"));
 	return NULL;
 }
 
-DUK_LOCAL duk_bool_t duk__putprop_shallow_fastpath_array_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key, duk_tval *tv_val) {
+DUK_LOCAL duk_bool_t duk__putprop_shallow_fastpath_array_tval(duk_hthread *thr,
+                                                              duk_hobject *obj,
+                                                              duk_tval *tv_key,
+                                                              duk_tval *tv_val) {
 	duk_tval *tv;
 	duk_harray *a;
 	duk_uint32_t idx;
 	duk_uint32_t old_len, new_len;
 
-	if (!(DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj) &&
-	      DUK_HOBJECT_HAS_ARRAY_PART(obj) &&
-	      DUK_HOBJECT_HAS_EXTENSIBLE(obj))) {
+	if (!(DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj) && DUK_HOBJECT_HAS_ARRAY_PART(obj) && DUK_HOBJECT_HAS_EXTENSIBLE(obj))) {
 		return 0;
 	}
-	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj));  /* caller ensures */
+	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj)); /* caller ensures */
 
 	a = (duk_harray *) obj;
 	DUK_HARRAY_ASSERT_VALID(a);
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_key)) {
 		idx = duk__tval_fastint_to_arr_idx(tv_key);
 	} else
 #endif
-	if (DUK_TVAL_IS_DOUBLE(tv_key)) {
+	    if (DUK_TVAL_IS_DOUBLE(tv_key)) {
 		idx = duk__tval_number_to_arr_idx(tv_key);
 	} else {
 		DUK_DDD(DUK_DDDPRINT("key is not a number"));
 		return 0;
 	}
 
 	/* If index is not valid, idx will be DUK__NO_ARRAY_INDEX which
 	 * is 0xffffffffUL.  We don't need to check for that explicitly
 	 * because 0xffffffffUL will never be inside object 'a_size'.
 	 */
 
-	if (idx >= DUK_HOBJECT_GET_ASIZE(obj)) {  /* for resizing of array part, use slow path */
+	if (idx >= DUK_HOBJECT_GET_ASIZE(obj)) { /* for resizing of array part, use slow path */
 		return 0;
 	}
 	DUK_ASSERT(idx != 0xffffffffUL);
 	DUK_ASSERT(idx != DUK__NO_ARRAY_INDEX);
 
 	old_len = a->length;
 
 	if (idx >= old_len) {
 		DUK_DDD(DUK_DDDPRINT("write new array entry requires length update "
 		                     "(arr_idx=%ld, old_len=%ld)",
-		                     (long) idx, (long) old_len));
+		                     (long) idx,
+		                     (long) old_len));
 		if (DUK_HARRAY_LENGTH_NONWRITABLE(a)) {
 			/* The correct behavior here is either a silent error
 			 * or a TypeError, depending on strictness.  Fall back
 			 * to the slow path to handle the situation.
 			 */
 			return 0;
 		}
 		new_len = idx + 1;
 
 		((duk_harray *) obj)->length = new_len;
 	}
 
 	tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, idx);
-	DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val); /* side effects */
 
 	DUK_DDD(DUK_DDDPRINT("array fast path success for index %ld", (long) idx));
 	return 1;
 }
-#endif  /* DUK_USE_ARRAY_PROP_FASTPATH */
+#endif /* DUK_USE_ARRAY_PROP_FASTPATH */
 
 /*
  *  Fast path for bufobj getprop/putprop
  */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_LOCAL duk_bool_t duk__getprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
@@ -59355,15 +60497,15 @@
 	}
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_key)) {
 		idx = duk__tval_fastint_to_arr_idx(tv_key);
 	} else
 #endif
-	if (DUK_TVAL_IS_DOUBLE(tv_key)) {
+	    if (DUK_TVAL_IS_DOUBLE(tv_key)) {
 		idx = duk__tval_number_to_arr_idx(tv_key);
 	} else {
 		return 0;
 	}
 
 	/* If index is not valid, idx will be DUK__NO_ARRAY_INDEX which
 	 * is 0xffffffffUL.  We don't need to check for that explicitly
@@ -59372,54 +60514,53 @@
 
 	/* Careful with wrapping (left shifting idx would be unsafe). */
 	if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
 		return 0;
 	}
 	DUK_ASSERT(idx != DUK__NO_ARRAY_INDEX);
 
-	byte_off = idx << h_bufobj->shift;  /* no wrap assuming h_bufobj->length is valid */
+	byte_off = idx << h_bufobj->shift; /* no wrap assuming h_bufobj->length is valid */
 	elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
 
 	if (h_bufobj->buf != NULL && DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufobj, byte_off + elem_size)) {
 		data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf) + h_bufobj->offset + byte_off;
 		duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
 	} else {
 		DUK_D(DUK_DPRINT("bufobj access out of underlying buffer, ignoring (read zero)"));
 		duk_push_uint(thr, 0);
 	}
 
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 #if defined(DUK_USE_BUFFEROBJECT_SUPPORT)
 DUK_LOCAL duk_bool_t duk__putprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key, duk_tval *tv_val) {
 	duk_uint32_t idx;
 	duk_hbufobj *h_bufobj;
 	duk_uint_t byte_off;
 	duk_small_uint_t elem_size;
 	duk_uint8_t *data;
 
-	if (!(DUK_HOBJECT_IS_BUFOBJ(obj) &&
-	      DUK_TVAL_IS_NUMBER(tv_val))) {
+	if (!(DUK_HOBJECT_IS_BUFOBJ(obj) && DUK_TVAL_IS_NUMBER(tv_val))) {
 		return 0;
 	}
-	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj));  /* caller ensures; rom objects are never bufobjs now */
+	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj)); /* caller ensures; rom objects are never bufobjs now */
 
 	h_bufobj = (duk_hbufobj *) obj;
 	if (!DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h_bufobj)) {
 		return 0;
 	}
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_key)) {
 		idx = duk__tval_fastint_to_arr_idx(tv_key);
 	} else
 #endif
-	if (DUK_TVAL_IS_DOUBLE(tv_key)) {
+	    if (DUK_TVAL_IS_DOUBLE(tv_key)) {
 		idx = duk__tval_number_to_arr_idx(tv_key);
 	} else {
 		return 0;
 	}
 
 	/* If index is not valid, idx will be DUK__NO_ARRAY_INDEX which
 	 * is 0xffffffffUL.  We don't need to check for that explicitly
@@ -59428,15 +60569,15 @@
 
 	/* Careful with wrapping (left shifting idx would be unsafe). */
 	if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
 		return 0;
 	}
 	DUK_ASSERT(idx != DUK__NO_ARRAY_INDEX);
 
-	byte_off = idx << h_bufobj->shift;  /* no wrap assuming h_bufobj->length is valid */
+	byte_off = idx << h_bufobj->shift; /* no wrap assuming h_bufobj->length is valid */
 	elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
 
 	/* Value is required to be a number in the fast path so there
 	 * are no side effects in write coercion.
 	 */
 	duk_push_tval(thr, tv_val);
 	DUK_ASSERT(duk_is_number(thr, -1));
@@ -59447,15 +60588,15 @@
 	} else {
 		DUK_D(DUK_DPRINT("bufobj access out of underlying buffer, ignoring (write skipped)"));
 	}
 
 	duk_pop_unsafe(thr);
 	return 1;
 }
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 /*
  *  GETPROP: ECMAScript property read.
  */
 
 DUK_INTERNAL duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key) {
 	duk_tval tv_obj_copy;
@@ -59463,16 +60604,19 @@
 	duk_hobject *curr = NULL;
 	duk_hstring *key = NULL;
 	duk_uint32_t arr_idx = DUK__NO_ARRAY_INDEX;
 	duk_propdesc desc;
 	duk_uint_t sanity;
 
 	DUK_DDD(DUK_DDDPRINT("getprop: thr=%p, obj=%p, key=%p (obj -> %!T, key -> %!T)",
-	                     (void *) thr, (void *) tv_obj, (void *) tv_key,
-	                     (duk_tval *) tv_obj, (duk_tval *) tv_key));
+	                     (void *) thr,
+	                     (void *) tv_obj,
+	                     (void *) tv_key,
+	                     (duk_tval *) tv_obj,
+	                     (duk_tval *) tv_key));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(tv_obj != NULL);
 	DUK_ASSERT(tv_key != NULL);
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
@@ -59501,16 +60645,19 @@
 	case DUK_TAG_UNDEFINED:
 	case DUK_TAG_NULL: {
 		/* Note: unconditional throw */
 		DUK_DDD(DUK_DDDPRINT("base object is undefined or null -> reject"));
 #if defined(DUK_USE_PARANOID_ERRORS)
 		DUK_ERROR_TYPE(thr, DUK_STR_INVALID_BASE);
 #else
-		DUK_ERROR_FMT2(thr, DUK_ERR_TYPE_ERROR, "cannot read property %s of %s",
-		               duk_push_string_tval_readable(thr, tv_key), duk_push_string_tval_readable(thr, tv_obj));
+		DUK_ERROR_FMT2(thr,
+		               DUK_ERR_TYPE_ERROR,
+		               "cannot read property %s of %s",
+		               duk_push_string_tval_readable(thr, tv_key),
+		               duk_push_string_tval_readable(thr, tv_obj));
 #endif
 		DUK_WO_NORETURN(return 0;);
 		break;
 	}
 
 	case DUK_TAG_BOOLEAN: {
 		DUK_DDD(DUK_DDDPRINT("base object is a boolean, start lookup from boolean prototype"));
@@ -59532,32 +60679,32 @@
 #if defined(DUK_USE_FASTINT)
 		if (DUK_TVAL_IS_FASTINT(tv_key)) {
 			arr_idx = duk__tval_fastint_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object string, key is a fast-path fastint; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
 		} else
 #endif
-		if (DUK_TVAL_IS_NUMBER(tv_key)) {
+		    if (DUK_TVAL_IS_NUMBER(tv_key)) {
 			arr_idx = duk__tval_number_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object string, key is a fast-path number; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
 		} else {
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object string, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 			pop_count = 1;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
 			duk_pop_n_unsafe(thr, pop_count);
 			duk_push_hstring(thr, h);
-			duk_substring(thr, -1, arr_idx, arr_idx + 1);  /* [str] -> [substr] */
+			duk_substring(thr, -1, arr_idx, arr_idx + 1); /* [str] -> [substr] */
 
 			DUK_STATS_INC(thr->heap, stats_getprop_stringidx);
 			DUK_DDD(DUK_DDDPRINT("-> %!T (base is string, key is an index inside string length "
 			                     "after coercion -> return char)",
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			return 1;
 		}
@@ -59566,31 +60713,32 @@
 			/* This is a pretty awkward control flow, but we need to recheck the
 			 * key coercion here.
 			 */
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object string, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 		}
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
-			duk_pop_unsafe(thr);  /* [key] -> [] */
-			duk_push_uint(thr, (duk_uint_t) DUK_HSTRING_GET_CHARLEN(h));  /* [] -> [res] */
+			duk_pop_unsafe(thr); /* [key] -> [] */
+			duk_push_uint(thr, (duk_uint_t) DUK_HSTRING_GET_CHARLEN(h)); /* [] -> [res] */
 
 			DUK_STATS_INC(thr->heap, stats_getprop_stringlen);
 			DUK_DDD(DUK_DDDPRINT("-> %!T (base is string, key is 'length' after coercion -> "
 			                     "return string length)",
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			return 1;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("base object is a string, start lookup from string prototype"));
 		curr = thr->builtins[DUK_BIDX_STRING_PROTOTYPE];
-		goto lookup;  /* avoid double coercion */
+		goto lookup; /* avoid double coercion */
 	}
 
 	case DUK_TAG_OBJECT: {
 #if defined(DUK_USE_ARRAY_PROP_FASTPATH)
 		duk_tval *tmp;
 #endif
 
@@ -59627,81 +60775,83 @@
 		if (DUK_UNLIKELY(DUK_HOBJECT_IS_PROXY(curr))) {
 			duk_hobject *h_target;
 
 			if (duk__proxy_check_prop(thr, curr, DUK_STRIDX_GET, tv_key, &h_target)) {
 				/* -> [ ... trap handler ] */
 				DUK_DDD(DUK_DDDPRINT("-> proxy object 'get' for key %!T", (duk_tval *) tv_key));
 				DUK_STATS_INC(thr->heap, stats_getprop_proxy);
-				duk_push_hobject(thr, h_target);  /* target */
-				duk_push_tval(thr, tv_key);       /* P */
-				duk_push_tval(thr, tv_obj);       /* Receiver: Proxy object */
+				duk_push_hobject(thr, h_target); /* target */
+				duk_push_tval(thr, tv_key); /* P */
+				duk_push_tval(thr, tv_obj); /* Receiver: Proxy object */
 				duk_call_method(thr, 3 /*nargs*/);
 
 				/* Target object must be checked for a conflicting
 				 * non-configurable property.
 				 */
 				arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 				DUK_ASSERT(key != NULL);
 
 				if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, DUK_GETDESC_FLAG_PUSH_VALUE)) {
-					duk_tval *tv_hook = duk_require_tval(thr, -3);  /* value from hook */
-					duk_tval *tv_targ = duk_require_tval(thr, -1);  /* value from target */
+					duk_tval *tv_hook = duk_require_tval(thr, -3); /* value from hook */
+					duk_tval *tv_targ = duk_require_tval(thr, -1); /* value from target */
 					duk_bool_t datadesc_reject;
 					duk_bool_t accdesc_reject;
 
 					DUK_DDD(DUK_DDDPRINT("proxy 'get': target has matching property %!O, check for "
 					                     "conflicting property; tv_hook=%!T, tv_targ=%!T, desc.flags=0x%08lx, "
 					                     "desc.get=%p, desc.set=%p",
-					                     (duk_heaphdr *) key, (duk_tval *) tv_hook, (duk_tval *) tv_targ,
+					                     (duk_heaphdr *) key,
+					                     (duk_tval *) tv_hook,
+					                     (duk_tval *) tv_targ,
 					                     (unsigned long) desc.flags,
-					                     (void *) desc.get, (void *) desc.set));
+					                     (void *) desc.get,
+					                     (void *) desc.set));
 
 					datadesc_reject = !(desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) &&
 					                  !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) &&
 					                  !(desc.flags & DUK_PROPDESC_FLAG_WRITABLE) &&
 					                  !duk_js_samevalue(tv_hook, tv_targ);
 					accdesc_reject = (desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) &&
-					                 !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) &&
-					                 (desc.get == NULL) &&
+					                 !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && (desc.get == NULL) &&
 					                 !DUK_TVAL_IS_UNDEFINED(tv_hook);
 					if (datadesc_reject || accdesc_reject) {
 						DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 						DUK_WO_NORETURN(return 0;);
 					}
 
 					duk_pop_2_unsafe(thr);
 				} else {
 					duk_pop_unsafe(thr);
 				}
-				return 1;  /* return value */
+				return 1; /* return value */
 			}
 
-			curr = h_target;  /* resume lookup from target */
+			curr = h_target; /* resume lookup from target */
 			DUK_TVAL_SET_OBJECT(tv_obj, curr);
 		}
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 		if (DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(curr)) {
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 
 			DUK_STATS_INC(thr->heap, stats_getprop_arguments);
 			if (duk__check_arguments_map_for_get(thr, curr, key, &desc)) {
 				DUK_DDD(DUK_DDDPRINT("-> %!T (base is object with arguments exotic behavior, "
 				                     "key matches magically bound property -> skip standard "
 				                     "Get with replacement value)",
 				                     (duk_tval *) duk_get_tval(thr, -1)));
 
 				/* no need for 'caller' post-check, because 'key' must be an array index */
 
-				duk_remove_m2(thr);  /* [key result] -> [result] */
+				duk_remove_m2(thr); /* [key result] -> [result] */
 				return 1;
 			}
 
-			goto lookup;  /* avoid double coercion */
+			goto lookup; /* avoid double coercion */
 		}
 		break;
 	}
 
 	/* Buffer has virtual properties similar to string, but indexed values
 	 * are numbers, not 1-byte buffers/strings which would perform badly.
 	 */
@@ -59715,32 +60865,31 @@
 		 */
 
 #if defined(DUK_USE_FASTINT)
 		if (DUK_TVAL_IS_FASTINT(tv_key)) {
 			arr_idx = duk__tval_fastint_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a fast-path fastint; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
-		}
-		else
+		} else
 #endif
-		if (DUK_TVAL_IS_NUMBER(tv_key)) {
+		    if (DUK_TVAL_IS_NUMBER(tv_key)) {
 			arr_idx = duk__tval_number_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a fast-path number; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
 		} else {
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 			pop_count = 1;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
 			duk_pop_n_unsafe(thr, pop_count);
 			duk_push_uint(thr, ((duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h))[arr_idx]);
 			DUK_STATS_INC(thr->heap, stats_getprop_bufferidx);
 			DUK_DDD(DUK_DDDPRINT("-> %!T (base is buffer, key is an index inside buffer length "
 			                     "after coercion -> return byte as number)",
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			return 1;
@@ -59750,31 +60899,32 @@
 			/* This is a pretty awkward control flow, but we need to recheck the
 			 * key coercion here.
 			 */
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 		}
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
-			duk_pop_unsafe(thr);  /* [key] -> [] */
-			duk_push_uint(thr, (duk_uint_t) DUK_HBUFFER_GET_SIZE(h));  /* [] -> [res] */
+			duk_pop_unsafe(thr); /* [key] -> [] */
+			duk_push_uint(thr, (duk_uint_t) DUK_HBUFFER_GET_SIZE(h)); /* [] -> [res] */
 			DUK_STATS_INC(thr->heap, stats_getprop_bufferlen);
 
 			DUK_DDD(DUK_DDDPRINT("-> %!T (base is buffer, key is 'length' "
 			                     "after coercion -> return buffer length)",
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 			return 1;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("base object is a buffer, start lookup from Uint8Array prototype"));
 		curr = thr->builtins[DUK_BIDX_UINT8ARRAY_PROTOTYPE];
-		goto lookup;  /* avoid double coercion */
+		goto lookup; /* avoid double coercion */
 	}
 
 	case DUK_TAG_POINTER: {
 		DUK_DDD(DUK_DDDPRINT("base object is a pointer, start lookup from pointer prototype"));
 		curr = thr->builtins[DUK_BIDX_POINTER_PROTOTYPE];
 		break;
 	}
@@ -59803,83 +60953,81 @@
 	DUK_ASSERT(key == NULL);
 	arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 	DUK_ASSERT(key != NULL);
 	/*
 	 *  Property lookup
 	 */
 
- lookup:
+lookup:
 	/* [key] (coerced) */
 	DUK_ASSERT(curr != NULL);
 	DUK_ASSERT(key != NULL);
 
 	sanity = DUK_HOBJECT_PROTOTYPE_CHAIN_SANITY;
 	do {
 		if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, DUK_GETDESC_FLAG_PUSH_VALUE)) {
 			goto next_in_chain;
 		}
 
 		if (desc.get != NULL) {
 			/* accessor with defined getter */
 			DUK_ASSERT((desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) != 0);
 
-			duk_pop_unsafe(thr);              /* [key undefined] -> [key] */
+			duk_pop_unsafe(thr); /* [key undefined] -> [key] */
 			duk_push_hobject(thr, desc.get);
-			duk_push_tval(thr, tv_obj);       /* note: original, uncoerced base */
+			duk_push_tval(thr, tv_obj); /* note: original, uncoerced base */
 #if defined(DUK_USE_NONSTD_GETTER_KEY_ARGUMENT)
 			duk_dup_m3(thr);
-			duk_call_method(thr, 1);          /* [key getter this key] -> [key retval] */
+			duk_call_method(thr, 1); /* [key getter this key] -> [key retval] */
 #else
-			duk_call_method(thr, 0);          /* [key getter this] -> [key retval] */
+			duk_call_method(thr, 0); /* [key getter this] -> [key retval] */
 #endif
 		} else {
 			/* [key value] or [key undefined] */
 
 			/* data property or accessor without getter */
-			DUK_ASSERT(((desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) == 0) ||
-			           (desc.get == NULL));
+			DUK_ASSERT(((desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) == 0) || (desc.get == NULL));
 
 			/* if accessor without getter, return value is undefined */
-			DUK_ASSERT(((desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) == 0) ||
-			           duk_is_undefined(thr, -1));
+			DUK_ASSERT(((desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) == 0) || duk_is_undefined(thr, -1));
 
 			/* Note: for an accessor without getter, falling through to
 			 * check for "caller" exotic behavior is unnecessary as
 			 * "undefined" will never activate the behavior.  But it does
 			 * no harm, so we'll do it anyway.
 			 */
 		}
 
-		goto found;  /* [key result] */
+		goto found; /* [key result] */
 
-	 next_in_chain:
+	next_in_chain:
 		/* XXX: option to pretend property doesn't exist if sanity limit is
 		 * hit might be useful.
 		 */
 		if (DUK_UNLIKELY(sanity-- == 0)) {
 			DUK_ERROR_RANGE(thr, DUK_STR_PROTOTYPE_CHAIN_LIMIT);
 			DUK_WO_NORETURN(return 0;);
 		}
 		curr = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, curr);
 	} while (curr != NULL);
 
 	/*
 	 *  Not found
 	 */
 
-	duk_to_undefined(thr, -1);  /* [key] -> [undefined] (default value) */
+	duk_to_undefined(thr, -1); /* [key] -> [undefined] (default value) */
 
 	DUK_DDD(DUK_DDDPRINT("-> %!T (not found)", (duk_tval *) duk_get_tval(thr, -1)));
 	return 0;
 
 	/*
 	 *  Found; post-processing (Function and arguments objects)
 	 */
 
- found:
+found:
 	/* [key result] */
 
 #if !defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 	/* Special behavior for 'caller' property of (non-bound) function objects
 	 * and non-strict Arguments objects: if 'caller' -value- (!) is a strict
 	 * mode function, throw a TypeError (E5 Sections 15.3.5.4, 10.6).
 	 * Quite interestingly, a non-strict function with no formal arguments
@@ -59901,44 +61049,40 @@
 	 *
 	 * See test-dev-strict-func-as-caller-prop-value.js for quite extensive
 	 * tests.
 	 *
 	 * This exotic behavior is disabled when the non-standard 'caller' property
 	 * is enabled, as it conflicts with the free use of 'caller'.
 	 */
-	if (key == DUK_HTHREAD_STRING_CALLER(thr) &&
-	    DUK_TVAL_IS_OBJECT(tv_obj)) {
+	if (key == DUK_HTHREAD_STRING_CALLER(thr) && DUK_TVAL_IS_OBJECT(tv_obj)) {
 		duk_hobject *orig = DUK_TVAL_GET_OBJECT(tv_obj);
 		DUK_ASSERT(orig != NULL);
 
-		if (DUK_HOBJECT_IS_NONBOUND_FUNCTION(orig) ||
-		    DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(orig)) {
+		if (DUK_HOBJECT_IS_NONBOUND_FUNCTION(orig) || DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(orig)) {
 			duk_hobject *h;
 
 			/* XXX: The TypeError is currently not applied to bound
 			 * functions because the 'strict' flag is not copied by
 			 * bind().  This may or may not be correct, the specification
 			 * only refers to the value being a "strict mode Function
 			 * object" which is ambiguous.
 			 */
 			DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(orig));
 
-			h = duk_get_hobject(thr, -1);  /* NULL if not an object */
-			if (h &&
-			    DUK_HOBJECT_IS_FUNCTION(h) &&
-			    DUK_HOBJECT_HAS_STRICT(h)) {
+			h = duk_get_hobject(thr, -1); /* NULL if not an object */
+			if (h && DUK_HOBJECT_IS_FUNCTION(h) && DUK_HOBJECT_HAS_STRICT(h)) {
 				/* XXX: sufficient to check 'strict', assert for 'is function' */
 				DUK_ERROR_TYPE(thr, DUK_STR_STRICT_CALLER_READ);
 				DUK_WO_NORETURN(return 0;);
 			}
 		}
 	}
-#endif   /* !DUK_USE_NONSTD_FUNC_CALLER_PROPERTY */
+#endif /* !DUK_USE_NONSTD_FUNC_CALLER_PROPERTY */
 
-	duk_remove_m2(thr);  /* [key result] -> [result] */
+	duk_remove_m2(thr); /* [key result] -> [result] */
 
 	DUK_DDD(DUK_DDDPRINT("-> %!T (found)", (duk_tval *) duk_get_tval(thr, -1)));
 	return 1;
 }
 
 /*
  *  HASPROP: ECMAScript property existence check ("in" operator).
@@ -59952,16 +61096,19 @@
 	duk_hobject *obj;
 	duk_hstring *key;
 	duk_uint32_t arr_idx;
 	duk_bool_t rc;
 	duk_propdesc desc;
 
 	DUK_DDD(DUK_DDDPRINT("hasprop: thr=%p, obj=%p, key=%p (obj -> %!T, key -> %!T)",
-	                     (void *) thr, (void *) tv_obj, (void *) tv_key,
-	                     (duk_tval *) tv_obj, (duk_tval *) tv_key));
+	                     (void *) thr,
+	                     (void *) tv_obj,
+	                     (void *) tv_key,
+	                     (duk_tval *) tv_obj,
+	                     (duk_tval *) tv_key));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(tv_obj != NULL);
 	DUK_ASSERT(tv_key != NULL);
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
@@ -60025,56 +61172,59 @@
 		 * (which is the required behavior in E5/E5.1/E6) so the key is a string
 		 * here already.
 		 */
 
 		if (duk__proxy_check_prop(thr, obj, DUK_STRIDX_HAS, tv_key, &h_target)) {
 			/* [ ... key trap handler ] */
 			DUK_DDD(DUK_DDDPRINT("-> proxy object 'has' for key %!T", (duk_tval *) tv_key));
-			duk_push_hobject(thr, h_target);  /* target */
-			duk_push_tval(thr, tv_key);       /* P */
+			duk_push_hobject(thr, h_target); /* target */
+			duk_push_tval(thr, tv_key); /* P */
 			duk_call_method(thr, 2 /*nargs*/);
 			tmp_bool = duk_to_boolean_top_pop(thr);
 			if (!tmp_bool) {
 				/* Target object must be checked for a conflicting
 				 * non-configurable property.
 				 */
 
-				if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 /*flags*/)) {  /* don't push value */
+				if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 /*flags*/)) { /* don't push
+					                                                                             value */
 					DUK_DDD(DUK_DDDPRINT("proxy 'has': target has matching property %!O, check for "
 					                     "conflicting property; desc.flags=0x%08lx, "
 					                     "desc.get=%p, desc.set=%p",
-					                     (duk_heaphdr *) key, (unsigned long) desc.flags,
-					                     (void *) desc.get, (void *) desc.set));
+					                     (duk_heaphdr *) key,
+					                     (unsigned long) desc.flags,
+					                     (void *) desc.get,
+					                     (void *) desc.set));
 					/* XXX: Extensibility check for target uses IsExtensible().  If we
 					 * implemented the isExtensible trap and didn't reject proxies as
 					 * proxy targets, it should be respected here.
 					 */
-					if (!((desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) &&  /* property is configurable and */
-					      DUK_HOBJECT_HAS_EXTENSIBLE(h_target))) {          /* ... target is extensible */
+					if (!((desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && /* property is configurable and */
+					      DUK_HOBJECT_HAS_EXTENSIBLE(h_target))) { /* ... target is extensible */
 						DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 						DUK_WO_NORETURN(return 0;);
 					}
 				}
 			}
 
-			duk_pop_unsafe(thr);  /* [ key ] -> [] */
+			duk_pop_unsafe(thr); /* [ key ] -> [] */
 			return tmp_bool;
 		}
 
-		obj = h_target;  /* resume check from proxy target */
+		obj = h_target; /* resume check from proxy target */
 	}
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 	/* XXX: inline into a prototype walking loop? */
 
-	rc = duk__get_propdesc(thr, obj, key, &desc, 0 /*flags*/);  /* don't push value */
+	rc = duk__get_propdesc(thr, obj, key, &desc, 0 /*flags*/); /* don't push value */
 	/* fall through */
 
- pop_and_return:
-	duk_pop_unsafe(thr);  /* [ key ] -> [] */
+pop_and_return:
+	duk_pop_unsafe(thr); /* [ key ] -> [] */
 	return rc;
 }
 
 /*
  *  HASPROP variant used internally.
  *
  *  This primitive must never throw an error, callers rely on this.
@@ -60092,15 +61242,15 @@
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
-	return duk__get_propdesc(thr, obj, key, &dummy, DUK_GETDESC_FLAG_IGNORE_PROTOLOOP);  /* don't push value */
+	return duk__get_propdesc(thr, obj, key, &dummy, DUK_GETDESC_FLAG_IGNORE_PROTOLOOP); /* don't push value */
 }
 
 /*
  *  Helper: handle Array object 'length' write which automatically
  *  deletes properties, see E5 Section 15.4.5.1, step 3.  This is
  *  quite tricky to get right.
  *
@@ -60124,24 +61274,24 @@
 		duk_int64_t fi;
 		fi = DUK_TVAL_GET_FASTINT(tv);
 		if (fi < 0 || fi > DUK_I64_CONSTANT(0xffffffff)) {
 			goto fail_range;
 		}
 		return (duk_uint32_t) fi;
 	}
-#else  /* DUK_USE_FASTINT */
+#else /* DUK_USE_FASTINT */
 	/* When fastints are not enabled, the most interesting case is any
 	 * number.
 	 */
 	if (DUK_TVAL_IS_DOUBLE(tv)) {
 		d = DUK_TVAL_GET_NUMBER(tv);
 	}
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 	else
-#endif  /* !DUK_USE_PREFER_SIZE */
+#endif /* !DUK_USE_PREFER_SIZE */
 	{
 		/* In all other cases, and when doing a size optimized build,
 		 * fall back to the comprehensive handler.
 		 */
 		d = duk_js_tonumber(thr, tv);
 	}
 
@@ -60151,15 +61301,15 @@
 	res = duk_double_to_uint32_t(d);
 	if (!duk_double_equals((duk_double_t) res, d)) {
 		goto fail_range;
 	}
 
 	return res;
 
- fail_range:
+fail_range:
 	DUK_ERROR_RANGE(thr, DUK_STR_INVALID_ARRAY_LENGTH);
 	DUK_WO_NORETURN(return 0;);
 }
 
 /* Delete elements required by a smaller length, taking into account
  * potentially non-configurable elements.  Returns non-zero if all
  * elements could be deleted, and zero if all or some elements could
@@ -60179,15 +61329,16 @@
 	duk_uint32_t arr_idx;
 	duk_hstring *key;
 	duk_tval *tv;
 	duk_bool_t rc;
 
 	DUK_DDD(DUK_DDDPRINT("new array length smaller than old (%ld -> %ld), "
 	                     "probably need to remove elements",
-	                     (long) old_len, (long) new_len));
+	                     (long) old_len,
+	                     (long) new_len));
 
 	/*
 	 *  New length is smaller than old length, need to delete properties above
 	 *  the new length.
 	 *
 	 *  If array part exists, this is straightforward: array entries cannot
 	 *  be non-configurable so this is guaranteed to work.
@@ -60225,15 +61376,15 @@
 			i = DUK_HOBJECT_GET_ASIZE(obj);
 		}
 		DUK_ASSERT(i <= DUK_HOBJECT_GET_ASIZE(obj));
 
 		while (i > new_len) {
 			i--;
 			tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, i);
-			DUK_TVAL_SET_UNUSED_UPDREF(thr, tv);  /* side effects */
+			DUK_TVAL_SET_UNUSED_UPDREF(thr, tv); /* side effects */
 		}
 
 		*out_result_len = new_len;
 		return 1;
 	} else {
 		/*
 		 *  Entries part is a bit more complex.
@@ -60260,45 +61411,50 @@
 				continue;
 			}
 			if (!DUK_HSTRING_HAS_ARRIDX(key)) {
 				DUK_DDD(DUK_DDDPRINT("skip entry index %ld: key not an array index", (long) i));
 				continue;
 			}
 
-			DUK_ASSERT(DUK_HSTRING_HAS_ARRIDX(key));  /* XXX: macro checks for array index flag, which is unnecessary here */
+			DUK_ASSERT(
+			    DUK_HSTRING_HAS_ARRIDX(key)); /* XXX: macro checks for array index flag, which is unnecessary here */
 			arr_idx = DUK_HSTRING_GET_ARRIDX_SLOW(key);
 			DUK_ASSERT(arr_idx != DUK__NO_ARRAY_INDEX);
-			DUK_ASSERT(arr_idx < old_len);  /* consistency requires this */
+			DUK_ASSERT(arr_idx < old_len); /* consistency requires this */
 
 			if (arr_idx < new_len) {
 				DUK_DDD(DUK_DDDPRINT("skip entry index %ld: key is array index %ld, below new_len",
-				                     (long) i, (long) arr_idx));
+				                     (long) i,
+				                     (long) arr_idx));
 				continue;
 			}
 			if (DUK_HOBJECT_E_SLOT_IS_CONFIGURABLE(thr->heap, obj, i)) {
 				DUK_DDD(DUK_DDDPRINT("skip entry index %ld: key is a relevant array index %ld, but configurable",
-				                     (long) i, (long) arr_idx));
+				                     (long) i,
+				                     (long) arr_idx));
 				continue;
 			}
 
 			/* relevant array index is non-configurable, blocks write */
 			if (arr_idx >= target_len) {
 				DUK_DDD(DUK_DDDPRINT("entry at index %ld has arr_idx %ld, is not configurable, "
 				                     "update target_len %ld -> %ld",
-				                     (long) i, (long) arr_idx, (long) target_len,
+				                     (long) i,
+				                     (long) arr_idx,
+				                     (long) target_len,
 				                     (long) (arr_idx + 1)));
 				target_len = arr_idx + 1;
 			}
 		}
-	 skip_stage1:
+	skip_stage1:
 
 		/* stage 2: delete configurable entries above target length */
 
-		DUK_DDD(DUK_DDDPRINT("old_len=%ld, new_len=%ld, target_len=%ld",
-		                     (long) old_len, (long) new_len, (long) target_len));
+		DUK_DDD(
+		    DUK_DDDPRINT("old_len=%ld, new_len=%ld, target_len=%ld", (long) old_len, (long) new_len, (long) target_len));
 
 		DUK_DDD(DUK_DDDPRINT("array length write, no array part, stage 2: remove "
 		                     "entries >= target_len"));
 
 		for (i = 0; i < DUK_HOBJECT_GET_ENEXT(obj); i++) {
 			key = DUK_HOBJECT_E_GET_KEY(thr->heap, obj, i);
 			if (!key) {
@@ -60306,28 +61462,29 @@
 				continue;
 			}
 			if (!DUK_HSTRING_HAS_ARRIDX(key)) {
 				DUK_DDD(DUK_DDDPRINT("skip entry index %ld: key not an array index", (long) i));
 				continue;
 			}
 
-			DUK_ASSERT(DUK_HSTRING_HAS_ARRIDX(key));  /* XXX: macro checks for array index flag, which is unnecessary here */
+			DUK_ASSERT(
+			    DUK_HSTRING_HAS_ARRIDX(key)); /* XXX: macro checks for array index flag, which is unnecessary here */
 			arr_idx = DUK_HSTRING_GET_ARRIDX_SLOW(key);
 			DUK_ASSERT(arr_idx != DUK__NO_ARRAY_INDEX);
-			DUK_ASSERT(arr_idx < old_len);  /* consistency requires this */
+			DUK_ASSERT(arr_idx < old_len); /* consistency requires this */
 
 			if (arr_idx < target_len) {
 				DUK_DDD(DUK_DDDPRINT("skip entry index %ld: key is array index %ld, below target_len",
-				                     (long) i, (long) arr_idx));
+				                     (long) i,
+				                     (long) arr_idx));
 				continue;
 			}
-			DUK_ASSERT(force_flag || DUK_HOBJECT_E_SLOT_IS_CONFIGURABLE(thr->heap, obj, i));  /* stage 1 guarantees */
+			DUK_ASSERT(force_flag || DUK_HOBJECT_E_SLOT_IS_CONFIGURABLE(thr->heap, obj, i)); /* stage 1 guarantees */
 
-			DUK_DDD(DUK_DDDPRINT("delete entry index %ld: key is array index %ld",
-			                     (long) i, (long) arr_idx));
+			DUK_DDD(DUK_DDDPRINT("delete entry index %ld: key is array index %ld", (long) i, (long) arr_idx));
 
 			/*
 			 *  Slow delete, but we don't care as we're already in a very slow path.
 			 *  The delete always succeeds: key has no exotic behavior, property
 			 *  is configurable, and no resize occurs.
 			 */
 			rc = duk_hobject_delprop_raw(thr, obj, key, force_flag ? DUK_DELPROP_FLAG_FORCE : 0);
@@ -60450,33 +61607,40 @@
  *
  *    * Input values are taken as pointers which may point to the valstack.
  *      If valstack is resized because of the put (this may happen at least
  *      when the array part is abandoned), the pointers can be invalidated.
  *      (We currently make a copy of all of the input values to avoid issues.)
  */
 
-DUK_INTERNAL duk_bool_t duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag) {
+DUK_INTERNAL duk_bool_t
+duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag) {
 	duk_tval tv_obj_copy;
 	duk_tval tv_key_copy;
 	duk_tval tv_val_copy;
-	duk_hobject *orig = NULL;  /* NULL if tv_obj is primitive */
+	duk_hobject *orig = NULL; /* NULL if tv_obj is primitive */
 	duk_hobject *curr;
 	duk_hstring *key = NULL;
 	duk_propdesc desc;
 	duk_tval *tv;
 	duk_uint32_t arr_idx;
 	duk_bool_t rc;
 	duk_int_t e_idx;
 	duk_uint_t sanity;
-	duk_uint32_t new_array_length = 0;  /* 0 = no update */
+	duk_uint32_t new_array_length = 0; /* 0 = no update */
 
 	DUK_DDD(DUK_DDDPRINT("putprop: thr=%p, obj=%p, key=%p, val=%p, throw=%ld "
 	                     "(obj -> %!T, key -> %!T, val -> %!T)",
-	                     (void *) thr, (void *) tv_obj, (void *) tv_key, (void *) tv_val,
-	                     (long) throw_flag, (duk_tval *) tv_obj, (duk_tval *) tv_key, (duk_tval *) tv_val));
+	                     (void *) thr,
+	                     (void *) tv_obj,
+	                     (void *) tv_key,
+	                     (void *) tv_val,
+	                     (long) throw_flag,
+	                     (duk_tval *) tv_obj,
+	                     (duk_tval *) tv_key,
+	                     (duk_tval *) tv_val));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(tv_obj != NULL);
 	DUK_ASSERT(tv_key != NULL);
 	DUK_ASSERT(tv_val != NULL);
 
@@ -60503,21 +61667,23 @@
 	 *  Coercion and fast path processing.
 	 */
 
 	switch (DUK_TVAL_GET_TAG(tv_obj)) {
 	case DUK_TAG_UNDEFINED:
 	case DUK_TAG_NULL: {
 		/* Note: unconditional throw */
-		DUK_DDD(DUK_DDDPRINT("base object is undefined or null -> reject (object=%!iT)",
-		                     (duk_tval *) tv_obj));
+		DUK_DDD(DUK_DDDPRINT("base object is undefined or null -> reject (object=%!iT)", (duk_tval *) tv_obj));
 #if defined(DUK_USE_PARANOID_ERRORS)
 		DUK_ERROR_TYPE(thr, DUK_STR_INVALID_BASE);
 #else
-		DUK_ERROR_FMT2(thr, DUK_ERR_TYPE_ERROR, "cannot write property %s of %s",
-		               duk_push_string_tval_readable(thr, tv_key), duk_push_string_tval_readable(thr, tv_obj));
+		DUK_ERROR_FMT2(thr,
+		               DUK_ERR_TYPE_ERROR,
+		               "cannot write property %s of %s",
+		               duk_push_string_tval_readable(thr, tv_key),
+		               duk_push_string_tval_readable(thr, tv_obj));
 #endif
 		DUK_WO_NORETURN(return 0;);
 		break;
 	}
 
 	case DUK_TAG_BOOLEAN: {
 		DUK_DDD(DUK_DDDPRINT("base object is a boolean, start lookup from boolean prototype"));
@@ -60543,37 +61709,36 @@
 			goto lookup;
 		}
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			goto fail_not_writable;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
 			goto fail_not_writable;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("base object is a string, start lookup from string prototype"));
 		curr = thr->builtins[DUK_BIDX_STRING_PROTOTYPE];
-		goto lookup;  /* avoid double coercion */
+		goto lookup; /* avoid double coercion */
 	}
 
 	case DUK_TAG_OBJECT: {
 		orig = DUK_TVAL_GET_OBJECT(tv_obj);
 		DUK_ASSERT(orig != NULL);
 
 #if defined(DUK_USE_ROM_OBJECTS)
 		/* With this check in place fast paths won't need read-only
 		 * object checks.  This is technically incorrect if there are
 		 * setters that cause no writes to ROM objects, but current
 		 * built-ins don't have such setters.
 		 */
 		if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) orig)) {
 			DUK_DD(DUK_DDPRINT("attempt to putprop on read-only target object"));
-			goto fail_not_writable_no_pop;  /* Must avoid duk_pop() in exit path */
+			goto fail_not_writable_no_pop; /* Must avoid duk_pop() in exit path */
 		}
 #endif
 
 		/* The fast path for array property put is not fully compliant:
 		 * If one places conflicting number-indexed properties into
 		 * Array.prototype (for example, a non-writable Array.prototype[7])
 		 * the fast path will incorrectly ignore them.
@@ -60611,18 +61776,18 @@
 			duk_hobject *h_target;
 			duk_bool_t tmp_bool;
 
 			if (duk__proxy_check_prop(thr, orig, DUK_STRIDX_SET, tv_key, &h_target)) {
 				/* -> [ ... trap handler ] */
 				DUK_DDD(DUK_DDDPRINT("-> proxy object 'set' for key %!T", (duk_tval *) tv_key));
 				DUK_STATS_INC(thr->heap, stats_putprop_proxy);
-				duk_push_hobject(thr, h_target);  /* target */
-				duk_push_tval(thr, tv_key);       /* P */
-				duk_push_tval(thr, tv_val);       /* V */
-				duk_push_tval(thr, tv_obj);       /* Receiver: Proxy object */
+				duk_push_hobject(thr, h_target); /* target */
+				duk_push_tval(thr, tv_key); /* P */
+				duk_push_tval(thr, tv_val); /* V */
+				duk_push_tval(thr, tv_obj); /* Receiver: Proxy object */
 				duk_call_method(thr, 4 /*nargs*/);
 				tmp_bool = duk_to_boolean_top_pop(thr);
 				if (!tmp_bool) {
 					goto fail_proxy_rejected;
 				}
 
 				/* Target object must be checked for a conflicting
@@ -60635,41 +61800,43 @@
 					duk_tval *tv_targ = duk_require_tval(thr, -1);
 					duk_bool_t datadesc_reject;
 					duk_bool_t accdesc_reject;
 
 					DUK_DDD(DUK_DDDPRINT("proxy 'set': target has matching property %!O, check for "
 					                     "conflicting property; tv_val=%!T, tv_targ=%!T, desc.flags=0x%08lx, "
 					                     "desc.get=%p, desc.set=%p",
-					                     (duk_heaphdr *) key, (duk_tval *) tv_val, (duk_tval *) tv_targ,
+					                     (duk_heaphdr *) key,
+					                     (duk_tval *) tv_val,
+					                     (duk_tval *) tv_targ,
 					                     (unsigned long) desc.flags,
-					                     (void *) desc.get, (void *) desc.set));
+					                     (void *) desc.get,
+					                     (void *) desc.set));
 
 					datadesc_reject = !(desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) &&
 					                  !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) &&
 					                  !(desc.flags & DUK_PROPDESC_FLAG_WRITABLE) &&
 					                  !duk_js_samevalue(tv_val, tv_targ);
 					accdesc_reject = (desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) &&
-					                 !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) &&
-					                 (desc.set == NULL);
+					                 !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && (desc.set == NULL);
 					if (datadesc_reject || accdesc_reject) {
 						DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 						DUK_WO_NORETURN(return 0;);
 					}
 
 					duk_pop_2_unsafe(thr);
 				} else {
 					duk_pop_unsafe(thr);
 				}
-				return 1;  /* success */
+				return 1; /* success */
 			}
 
-			orig = h_target;  /* resume write to target */
+			orig = h_target; /* resume write to target */
 			DUK_TVAL_SET_OBJECT(tv_obj, orig);
 		}
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 		curr = orig;
 		break;
 	}
 
 	case DUK_TAG_BUFFER: {
 		duk_hbuffer *h = DUK_TVAL_GET_BUFFER(tv_obj);
@@ -60683,42 +61850,41 @@
 #if defined(DUK_USE_FASTINT)
 		if (DUK_TVAL_IS_FASTINT(tv_key)) {
 			arr_idx = duk__tval_fastint_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a fast-path fastint; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
 		} else
 #endif
-		if (DUK_TVAL_IS_NUMBER(tv_key)) {
+		    if (DUK_TVAL_IS_NUMBER(tv_key)) {
 			arr_idx = duk__tval_number_to_arr_idx(tv_key);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a fast-path number; arr_idx %ld", (long) arr_idx));
 			pop_count = 0;
 		} else {
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 			pop_count = 1;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
 			duk_uint8_t *data;
 			DUK_DDD(DUK_DDDPRINT("writing to buffer data at index %ld", (long) arr_idx));
 			data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h);
 
 			/* XXX: duk_to_int() ensures we'll get 8 lowest bits as
 			 * as input is within duk_int_t range (capped outside it).
 			 */
 #if defined(DUK_USE_FASTINT)
 			/* Buffer writes are often integers. */
 			if (DUK_TVAL_IS_FASTINT(tv_val)) {
 				data[arr_idx] = (duk_uint8_t) DUK_TVAL_GET_FASTINT_U32(tv_val);
-			}
-			else
+			} else
 #endif
 			{
 				duk_push_tval(thr, tv_val);
 				data[arr_idx] = (duk_uint8_t) duk_to_uint32(thr, -1);
 				pop_count++;
 			}
 
@@ -60732,24 +61898,25 @@
 			/* This is a pretty awkward control flow, but we need to recheck the
 			 * key coercion here.
 			 */
 			arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 			DUK_ASSERT(key != NULL);
 			DUK_DDD(DUK_DDDPRINT("base object buffer, key is a non-fast-path number; after "
 			                     "coercion key is %!T, arr_idx %ld",
-			                     (duk_tval *) duk_get_tval(thr, -1), (long) arr_idx));
+			                     (duk_tval *) duk_get_tval(thr, -1),
+			                     (long) arr_idx));
 		}
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			goto fail_not_writable;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("base object is a buffer, start lookup from Uint8Array prototype"));
 		curr = thr->builtins[DUK_BIDX_UINT8ARRAY_PROTOTYPE];
-		goto lookup;  /* avoid double coercion */
+		goto lookup; /* avoid double coercion */
 	}
 
 	case DUK_TAG_POINTER: {
 		DUK_DDD(DUK_DDDPRINT("base object is a pointer, start lookup from pointer prototype"));
 		curr = thr->builtins[DUK_BIDX_POINTER_PROTOTYPE];
 		break;
 	}
@@ -60776,28 +61943,28 @@
 	}
 	}
 
 	DUK_ASSERT(key == NULL);
 	arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 	DUK_ASSERT(key != NULL);
 
- lookup:
+lookup:
 
 	/*
 	 *  Check whether the property already exists in the prototype chain.
 	 *  Note that the actual write goes into the original base object
 	 *  (except if an accessor property captures the write).
 	 */
 
 	/* [key] */
 
 	DUK_ASSERT(curr != NULL);
 	sanity = DUK_HOBJECT_PROTOTYPE_CHAIN_SANITY;
 	do {
-		if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, 0 /*flags*/)) {  /* don't push value */
+		if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, 0 /*flags*/)) { /* don't push value */
 			goto next_in_chain;
 		}
 
 		if (desc.flags & DUK_PROPDESC_FLAG_ACCESSOR) {
 			/*
 			 *  Found existing accessor property (own or inherited).
 			 *  Call setter with 'this' set to orig, and value as the only argument.
@@ -60812,23 +61979,23 @@
 			DUK_DD(DUK_DDPRINT("put to an own or inherited accessor, calling setter"));
 
 			setter = DUK_HOBJECT_E_GET_VALUE_SETTER(thr->heap, curr, desc.e_idx);
 			if (!setter) {
 				goto fail_no_setter;
 			}
 			duk_push_hobject(thr, setter);
-			duk_push_tval(thr, tv_obj);  /* note: original, uncoerced base */
-			duk_push_tval(thr, tv_val);  /* [key setter this val] */
+			duk_push_tval(thr, tv_obj); /* note: original, uncoerced base */
+			duk_push_tval(thr, tv_val); /* [key setter this val] */
 #if defined(DUK_USE_NONSTD_SETTER_KEY_ARGUMENT)
 			duk_dup_m4(thr);
-			duk_call_method(thr, 2);     /* [key setter this val key] -> [key retval] */
+			duk_call_method(thr, 2); /* [key setter this val key] -> [key retval] */
 #else
-			duk_call_method(thr, 1);     /* [key setter this val] -> [key retval] */
+			duk_call_method(thr, 1); /* [key setter this val] -> [key retval] */
 #endif
-			duk_pop_unsafe(thr);         /* ignore retval -> [key] */
+			duk_pop_unsafe(thr); /* ignore retval -> [key] */
 			goto success_no_arguments_exotic;
 		}
 
 		if (orig == NULL) {
 			/*
 			 *  Found existing own or inherited plain property, but original
 			 *  base is a primitive value.
@@ -60840,31 +62007,34 @@
 		if (curr != orig) {
 			/*
 			 *  Found existing inherited plain property.
 			 *  Do an access control check, and if OK, write
 			 *  new property to 'orig'.
 			 */
 			if (!DUK_HOBJECT_HAS_EXTENSIBLE(orig)) {
-				DUK_DD(DUK_DDPRINT("found existing inherited plain property, but original object is not extensible"));
+				DUK_DD(
+				    DUK_DDPRINT("found existing inherited plain property, but original object is not extensible"));
 				goto fail_not_extensible;
 			}
 			if (!(desc.flags & DUK_PROPDESC_FLAG_WRITABLE)) {
-				DUK_DD(DUK_DDPRINT("found existing inherited plain property, original object is extensible, but inherited property is not writable"));
+				DUK_DD(DUK_DDPRINT("found existing inherited plain property, original object is extensible, but "
+				                   "inherited property is not writable"));
 				goto fail_not_writable;
 			}
 			DUK_DD(DUK_DDPRINT("put to new property, object extensible, inherited property found and is writable"));
 			goto create_new;
 		} else {
 			/*
 			 *  Found existing own (non-inherited) plain property.
 			 *  Do an access control check and update in place.
 			 */
 
 			if (!(desc.flags & DUK_PROPDESC_FLAG_WRITABLE)) {
-				DUK_DD(DUK_DDPRINT("found existing own (non-inherited) plain property, but property is not writable"));
+				DUK_DD(
+				    DUK_DDPRINT("found existing own (non-inherited) plain property, but property is not writable"));
 				goto fail_not_writable;
 			}
 			if (desc.flags & DUK_PROPDESC_FLAG_VIRTUAL) {
 				DUK_DD(DUK_DDPRINT("found existing own (non-inherited) virtual property, property is writable"));
 
 				if (DUK_HOBJECT_IS_ARRAY(curr)) {
 					/*
@@ -60873,26 +62043,27 @@
 					 *  and writes the new 'length'.  The write may result in an
 					 *  unconditional RangeError or a partial write (indicated
 					 *  by a return code).
 					 *
 					 *  Note: the helper has an unnecessary writability check
 					 *  for 'length', we already know it is writable.
 					 */
-					DUK_ASSERT(key == DUK_HTHREAD_STRING_LENGTH(thr));  /* only virtual array property */
+					DUK_ASSERT(key == DUK_HTHREAD_STRING_LENGTH(thr)); /* only virtual array property */
 
-					DUK_DDD(DUK_DDDPRINT("writing existing 'length' property to array exotic, invoke complex helper"));
+					DUK_DDD(DUK_DDDPRINT(
+					    "writing existing 'length' property to array exotic, invoke complex helper"));
 
 					/* XXX: the helper currently assumes stack top contains new
 					 * 'length' value and the whole calling convention is not very
 					 * compatible with what we need.
 					 */
 
-					duk_push_tval(thr, tv_val);  /* [key val] */
+					duk_push_tval(thr, tv_val); /* [key val] */
 					rc = duk__handle_put_array_length(thr, orig);
-					duk_pop_unsafe(thr);  /* [key val] -> [key] */
+					duk_pop_unsafe(thr); /* [key val] -> [key] */
 					if (!rc) {
 						goto fail_array_length_partial;
 					}
 
 					/* key is 'length', cannot match argument exotic behavior */
 					goto success_no_arguments_exotic;
 				}
@@ -60906,51 +62077,56 @@
 					DUK_HBUFOBJ_ASSERT_VALID(h_bufobj);
 
 					DUK_DD(DUK_DDPRINT("writable virtual property is in buffer object"));
 
 					/* Careful with wrapping: arr_idx upshift may easily wrap, whereas
 					 * length downshift won't.
 					 */
-					if (arr_idx < (h_bufobj->length >> h_bufobj->shift) && DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h_bufobj)) {
+					if (arr_idx < (h_bufobj->length >> h_bufobj->shift) &&
+					    DUK_HBUFOBJ_HAS_VIRTUAL_INDICES(h_bufobj)) {
 						duk_uint8_t *data;
 						DUK_DDD(DUK_DDDPRINT("writing to buffer data at index %ld", (long) arr_idx));
 
-						DUK_ASSERT(arr_idx != DUK__NO_ARRAY_INDEX);  /* index/length check guarantees */
-						byte_off = arr_idx << h_bufobj->shift;       /* no wrap assuming h_bufobj->length is valid */
+						DUK_ASSERT(arr_idx != DUK__NO_ARRAY_INDEX); /* index/length check guarantees */
+						byte_off = arr_idx
+						           << h_bufobj->shift; /* no wrap assuming h_bufobj->length is valid */
 						elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
 
 						/* Coerce to number before validating pointers etc so that the
 						 * number coercions in duk_hbufobj_validated_write() are
 						 * guaranteed to be side effect free and not invalidate the
 						 * pointer checks we do here.
 						 */
 						duk_push_tval(thr, tv_val);
 						(void) duk_to_number_m1(thr);
 
-						if (h_bufobj->buf != NULL && DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufobj, byte_off + elem_size)) {
-							data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf) + h_bufobj->offset + byte_off;
+						if (h_bufobj->buf != NULL &&
+						    DUK_HBUFOBJ_VALID_BYTEOFFSET_EXCL(h_bufobj, byte_off + elem_size)) {
+							data = (duk_uint8_t *) DUK_HBUFFER_GET_DATA_PTR(thr->heap, h_bufobj->buf) +
+							       h_bufobj->offset + byte_off;
 							duk_hbufobj_validated_write(thr, h_bufobj, data, elem_size);
 						} else {
-							DUK_D(DUK_DPRINT("bufobj access out of underlying buffer, ignoring (write skipped)"));
+							DUK_D(DUK_DPRINT(
+							    "bufobj access out of underlying buffer, ignoring (write skipped)"));
 						}
 						duk_pop_unsafe(thr);
 						goto success_no_arguments_exotic;
 					}
 				}
-#endif  /* DUK_USE_BUFFEROBJECT_SUPPORT */
+#endif /* DUK_USE_BUFFEROBJECT_SUPPORT */
 
 				DUK_D(DUK_DPRINT("should not happen, key %!O", key));
-				goto fail_internal;  /* should not happen */
+				goto fail_internal; /* should not happen */
 			}
 			DUK_DD(DUK_DDPRINT("put to existing own plain property, property is writable"));
 			goto update_old;
 		}
 		DUK_UNREACHABLE();
 
-	 next_in_chain:
+	next_in_chain:
 		/* XXX: option to pretend property doesn't exist if sanity limit is
 		 * hit might be useful.
 		 */
 		if (DUK_UNLIKELY(sanity-- == 0)) {
 			DUK_ERROR_RANGE(thr, DUK_STR_PROTOTYPE_CHAIN_LIMIT);
 			DUK_WO_NORETURN(return 0;);
 		}
@@ -60971,15 +62147,15 @@
 	if (!DUK_HOBJECT_HAS_EXTENSIBLE(orig)) {
 		DUK_DD(DUK_DDPRINT("put to a new property (not found in prototype chain), but original object not extensible"));
 		goto fail_not_extensible;
 	}
 
 	goto create_new;
 
- update_old:
+update_old:
 
 	/*
 	 *  Update an existing property of the base object.
 	 */
 
 	/* [key] */
 
@@ -61004,39 +62180,39 @@
 
 	/* Array own property .length is handled above. */
 	DUK_ASSERT(!(DUK_HOBJECT_IS_ARRAY(orig) && key == DUK_HTHREAD_STRING_LENGTH(thr)));
 
 	if (desc.e_idx >= 0) {
 		tv = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, orig, desc.e_idx);
 		DUK_DDD(DUK_DDDPRINT("previous entry value: %!iT", (duk_tval *) tv));
-		DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val);  /* side effects; e_idx may be invalidated */
+		DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val); /* side effects; e_idx may be invalidated */
 		/* don't touch property attributes or hash part */
-		DUK_DD(DUK_DDPRINT("put to an existing entry at index %ld -> new value %!iT",
-		                   (long) desc.e_idx, (duk_tval *) tv));
+		DUK_DD(DUK_DDPRINT("put to an existing entry at index %ld -> new value %!iT", (long) desc.e_idx, (duk_tval *) tv));
 	} else {
 		/* Note: array entries are always writable, so the writability check
 		 * above is pointless for them.  The check could be avoided with some
 		 * refactoring but is probably not worth it.
 		 */
 
 		DUK_ASSERT(desc.a_idx >= 0);
 		tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, orig, desc.a_idx);
 		DUK_DDD(DUK_DDDPRINT("previous array value: %!iT", (duk_tval *) tv));
-		DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val);  /* side effects; a_idx may be invalidated */
+		DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv_val); /* side effects; a_idx may be invalidated */
 		DUK_DD(DUK_DDPRINT("put to an existing array entry at index %ld -> new value %!iT",
-		                   (long) desc.a_idx, (duk_tval *) tv));
+		                   (long) desc.a_idx,
+		                   (duk_tval *) tv));
 	}
 
 	/* Regardless of whether property is found in entry or array part,
 	 * it may have arguments exotic behavior (array indices may reside
 	 * in entry part for abandoned / non-existent array parts).
 	 */
 	goto success_with_arguments_exotic;
 
- create_new:
+create_new:
 
 	/*
 	 *  Create a new property in the original object.
 	 *
 	 *  Exotic properties need to be reconsidered here from a write
 	 *  perspective (not just property attributes perspective).
 	 *  However, the property does not exist in the object already,
@@ -61061,54 +62237,54 @@
 	}
 #endif
 
 	/* Not possible because array object 'length' is present
 	 * from its creation and cannot be deleted, and is thus
 	 * caught as an existing property above.
 	 */
-	DUK_ASSERT(!(DUK_HOBJECT_HAS_EXOTIC_ARRAY(orig) &&
-	             key == DUK_HTHREAD_STRING_LENGTH(thr)));
+	DUK_ASSERT(!(DUK_HOBJECT_HAS_EXOTIC_ARRAY(orig) && key == DUK_HTHREAD_STRING_LENGTH(thr)));
 
-	if (DUK_HOBJECT_HAS_EXOTIC_ARRAY(orig) &&
-	    arr_idx != DUK__NO_ARRAY_INDEX) {
+	if (DUK_HOBJECT_HAS_EXOTIC_ARRAY(orig) && arr_idx != DUK__NO_ARRAY_INDEX) {
 		/* automatic length update */
 		duk_uint32_t old_len;
 		duk_harray *a;
 
 		a = (duk_harray *) orig;
 		DUK_HARRAY_ASSERT_VALID(a);
 
 		old_len = a->length;
 
 		if (arr_idx >= old_len) {
 			DUK_DDD(DUK_DDDPRINT("write new array entry requires length update "
 			                     "(arr_idx=%ld, old_len=%ld)",
-			                     (long) arr_idx, (long) old_len));
+			                     (long) arr_idx,
+			                     (long) old_len));
 
 			if (DUK_HARRAY_LENGTH_NONWRITABLE(a)) {
 				DUK_DD(DUK_DDPRINT("attempt to extend array, but array 'length' is not writable"));
 				goto fail_not_writable;
 			}
 
 			/* Note: actual update happens once write has been completed
 			 * without error below.  The write should always succeed
 			 * from a specification viewpoint, but we may e.g. run out
 			 * of memory.  It's safer in this order.
 			 */
 
 			DUK_ASSERT(arr_idx != 0xffffffffUL);
-			new_array_length = arr_idx + 1;  /* flag for later write */
+			new_array_length = arr_idx + 1; /* flag for later write */
 		} else {
 			DUK_DDD(DUK_DDDPRINT("write new array entry does not require length update "
 			                     "(arr_idx=%ld, old_len=%ld)",
-			                     (long) arr_idx, (long) old_len));
+			                     (long) arr_idx,
+			                     (long) old_len));
 		}
 	}
 
- /* write_to_array_part: */
+	/* write_to_array_part: */
 
 	/*
 	 *  Write to array part?
 	 *
 	 *  Note: array abandonding requires a property resize which uses
 	 *  'rechecks' valstack for temporaries and may cause any existing
 	 *  valstack pointers to be invalidated.  To protect against this,
@@ -61122,25 +62298,24 @@
 			goto write_to_entry_part;
 		}
 
 		/* prev value must be unused, no decref */
 		DUK_ASSERT(DUK_TVAL_IS_UNUSED(tv));
 		DUK_TVAL_SET_TVAL(tv, tv_val);
 		DUK_TVAL_INCREF(thr, tv);
-		DUK_DD(DUK_DDPRINT("put to new array entry: %ld -> %!T",
-		                   (long) arr_idx, (duk_tval *) tv));
+		DUK_DD(DUK_DDPRINT("put to new array entry: %ld -> %!T", (long) arr_idx, (duk_tval *) tv));
 
 		/* Note: array part values are [[Writable]], [[Enumerable]],
 		 * and [[Configurable]] which matches the required attributes
 		 * here.
 		 */
 		goto entry_updated;
 	}
 
- write_to_entry_part:
+write_to_entry_part:
 
 	/*
 	 *  Write to entry part
 	 */
 
 	/* entry allocation updates hash part and increases the key
 	 * refcount; may need a props allocation resize but doesn't
@@ -61152,60 +62327,58 @@
 	tv = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, orig, e_idx);
 	/* prev value can be garbage, no decref */
 	DUK_TVAL_SET_TVAL(tv, tv_val);
 	DUK_TVAL_INCREF(thr, tv);
 	DUK_HOBJECT_E_SET_FLAGS(thr->heap, orig, e_idx, DUK_PROPDESC_FLAGS_WEC);
 	goto entry_updated;
 
- entry_updated:
+entry_updated:
 
 	/*
 	 *  Possible pending array length update, which must only be done
 	 *  if the actual entry write succeeded.
 	 */
 
 	if (new_array_length > 0) {
 		/* Note: zero works as a "no update" marker because the new length
 		 * can never be zero after a new property is written.
 		 */
 
 		DUK_ASSERT(DUK_HOBJECT_HAS_EXOTIC_ARRAY(orig));
 
-		DUK_DDD(DUK_DDDPRINT("write successful, pending array length update to: %ld",
-		                     (long) new_array_length));
+		DUK_DDD(DUK_DDDPRINT("write successful, pending array length update to: %ld", (long) new_array_length));
 
 		((duk_harray *) orig)->length = new_array_length;
 	}
 
 	/*
 	 *  Arguments exotic behavior not possible for new properties: all
 	 *  magically bound properties are initially present in the arguments
 	 *  object, and if they are deleted, the binding is also removed from
 	 *  parameter map.
 	 */
 
 	goto success_no_arguments_exotic;
 
- success_with_arguments_exotic:
+success_with_arguments_exotic:
 
 	/*
 	 *  Arguments objects have exotic [[DefineOwnProperty]] which updates
 	 *  the internal 'map' of arguments for writes to currently mapped
 	 *  arguments.  More conretely, writes to mapped arguments generate
 	 *  a write to a bound variable.
 	 *
 	 *  The [[Put]] algorithm invokes [[DefineOwnProperty]] for existing
 	 *  data properties and new properties, but not for existing accessors.
 	 *  Hence, in E5 Section 10.6 ([[DefinedOwnProperty]] algorithm), we
 	 *  have a Desc with 'Value' (and possibly other properties too), and
 	 *  we end up in step 5.b.i.
 	 */
 
-	if (arr_idx != DUK__NO_ARRAY_INDEX &&
-	    DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(orig)) {
+	if (arr_idx != DUK__NO_ARRAY_INDEX && DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(orig)) {
 		/* Note: only numbered indices are relevant, so arr_idx fast reject
 		 * is good (this is valid unless there are more than 4**32-1 arguments).
 		 */
 
 		DUK_DDD(DUK_DDDPRINT("putprop successful, arguments exotic behavior needed"));
 
 		/* Note: we can reuse 'desc' here */
@@ -61216,98 +62389,101 @@
 
 		duk_push_tval(thr, tv_val);
 		(void) duk__check_arguments_map_for_put(thr, orig, key, &desc, throw_flag);
 		duk_pop_unsafe(thr);
 	}
 	/* fall thru */
 
- success_no_arguments_exotic:
+success_no_arguments_exotic:
 	/* shared exit path now */
 	DUK_DDD(DUK_DDDPRINT("result: success"));
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 1;
 
 #if defined(DUK_USE_ES6_PROXY)
- fail_proxy_rejected:
+fail_proxy_rejected:
 	DUK_DDD(DUK_DDDPRINT("result: error, proxy rejects"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 		DUK_WO_NORETURN(return 0;);
 	}
 	/* Note: no key on stack */
 	return 0;
 #endif
 
- fail_base_primitive:
+fail_base_primitive:
 	DUK_DDD(DUK_DDDPRINT("result: error, base primitive"));
 	if (throw_flag) {
 #if defined(DUK_USE_PARANOID_ERRORS)
 		DUK_ERROR_TYPE(thr, DUK_STR_INVALID_BASE);
 #else
-		DUK_ERROR_FMT2(thr, DUK_ERR_TYPE_ERROR, "cannot write property %s of %s",
-		               duk_push_string_tval_readable(thr, tv_key), duk_push_string_tval_readable(thr, tv_obj));
+		DUK_ERROR_FMT2(thr,
+		               DUK_ERR_TYPE_ERROR,
+		               "cannot write property %s of %s",
+		               duk_push_string_tval_readable(thr, tv_key),
+		               duk_push_string_tval_readable(thr, tv_obj));
 #endif
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 
- fail_not_extensible:
+fail_not_extensible:
 	DUK_DDD(DUK_DDDPRINT("result: error, not extensible"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_EXTENSIBLE);
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 
- fail_not_writable:
+fail_not_writable:
 	DUK_DDD(DUK_DDDPRINT("result: error, not writable"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_WRITABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 
 #if defined(DUK_USE_ROM_OBJECTS)
- fail_not_writable_no_pop:
+fail_not_writable_no_pop:
 	DUK_DDD(DUK_DDDPRINT("result: error, not writable"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_WRITABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
 	return 0;
 #endif
 
- fail_array_length_partial:
+fail_array_length_partial:
 	DUK_DD(DUK_DDPRINT("result: error, array length write only partially successful"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 
- fail_no_setter:
+fail_no_setter:
 	DUK_DDD(DUK_DDDPRINT("result: error, accessor property without setter"));
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_SETTER_UNDEFINED);
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 
- fail_internal:
+fail_internal:
 	DUK_DDD(DUK_DDDPRINT("result: error, internal"));
 	if (throw_flag) {
 		DUK_ERROR_INTERNAL(thr);
 		DUK_WO_NORETURN(return 0;);
 	}
-	duk_pop_unsafe(thr);  /* remove key */
+	duk_pop_unsafe(thr); /* remove key */
 	return 0;
 }
 
 /*
  *  ECMAScript compliant [[Delete]](P, Throw).
  */
 
@@ -61318,28 +62494,33 @@
 	duk_bool_t throw_flag;
 	duk_bool_t force_flag;
 
 	throw_flag = (flags & DUK_DELPROP_FLAG_THROW);
 	force_flag = (flags & DUK_DELPROP_FLAG_FORCE);
 
 	DUK_DDD(DUK_DDDPRINT("delprop_raw: thr=%p, obj=%p, key=%p, throw=%ld, force=%ld (obj -> %!O, key -> %!O)",
-	                     (void *) thr, (void *) obj, (void *) key, (long) throw_flag, (long) force_flag,
-	                     (duk_heaphdr *) obj, (duk_heaphdr *) key));
+	                     (void *) thr,
+	                     (void *) obj,
+	                     (void *) key,
+	                     (long) throw_flag,
+	                     (long) force_flag,
+	                     (duk_heaphdr *) obj,
+	                     (duk_heaphdr *) key));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	arr_idx = DUK_HSTRING_GET_ARRIDX_FAST(key);
 
 	/* 0 = don't push current value */
-	if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 /*flags*/)) {  /* don't push value */
+	if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 /*flags*/)) { /* don't push value */
 		DUK_DDD(DUK_DDDPRINT("property not found, succeed always"));
 		goto success;
 	}
 
 #if defined(DUK_USE_ROM_OBJECTS)
 	if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj)) {
 		DUK_DD(DUK_DDPRINT("attempt to delprop on read-only target object"));
@@ -61358,15 +62539,15 @@
 		goto fail_virtual;
 	}
 
 	if (desc.a_idx >= 0) {
 		DUK_ASSERT(desc.e_idx < 0);
 
 		tv = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, desc.a_idx);
-		DUK_TVAL_SET_UNUSED_UPDREF(thr, tv);  /* side effects */
+		DUK_TVAL_SET_UNUSED_UPDREF(thr, tv); /* side effects */
 		goto success;
 	} else {
 		DUK_ASSERT(desc.a_idx < 0);
 
 		/* remove hash entry (no decref) */
 #if defined(DUK_USE_HOBJECT_HASH_PART)
 		if (desc.h_idx >= 0) {
@@ -61384,15 +62565,17 @@
 #endif
 
 		/* Remove value.  This requires multiple writes so avoid side
 		 * effects via no-refzero macros so that e_idx is not
 		 * invalidated.
 		 */
 		DUK_DDD(DUK_DDDPRINT("before removing value, e_idx %ld, key %p, key at slot %p",
-		                     (long) desc.e_idx, (void *) key, (void *) DUK_HOBJECT_E_GET_KEY(thr->heap, obj, desc.e_idx)));
+		                     (long) desc.e_idx,
+		                     (void *) key,
+		                     (void *) DUK_HOBJECT_E_GET_KEY(thr->heap, obj, desc.e_idx)));
 		DUK_DDD(DUK_DDDPRINT("removing value at e_idx %ld", (long) desc.e_idx));
 		if (DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, desc.e_idx)) {
 			duk_hobject *tmp;
 
 			tmp = DUK_HOBJECT_E_GET_VALUE_GETTER(thr->heap, obj, desc.e_idx);
 			DUK_HOBJECT_E_SET_VALUE_GETTER(thr->heap, obj, desc.e_idx, NULL);
 			DUK_UNREF(tmp);
@@ -61409,15 +62592,17 @@
 #if 0
 		/* Not strictly necessary because if key == NULL, flag MUST be ignored. */
 		DUK_HOBJECT_E_SET_FLAGS(thr->heap, obj, desc.e_idx, 0);
 #endif
 
 		/* Remove key. */
 		DUK_DDD(DUK_DDDPRINT("before removing key, e_idx %ld, key %p, key at slot %p",
-		                     (long) desc.e_idx, (void *) key, (void *) DUK_HOBJECT_E_GET_KEY(thr->heap, obj, desc.e_idx)));
+		                     (long) desc.e_idx,
+		                     (void *) key,
+		                     (void *) DUK_HOBJECT_E_GET_KEY(thr->heap, obj, desc.e_idx)));
 		DUK_DDD(DUK_DDDPRINT("removing key at e_idx %ld", (long) desc.e_idx));
 		DUK_ASSERT(key == DUK_HOBJECT_E_GET_KEY(thr->heap, obj, desc.e_idx));
 		DUK_HOBJECT_E_SET_KEY(thr->heap, obj, desc.e_idx, NULL);
 		DUK_HSTRING_DECREF_NORZ(thr, key);
 
 		/* Trigger refzero side effects only when we're done as a
 		 * finalizer might operate on the object and affect the
@@ -61425,15 +62610,15 @@
 		 */
 		DUK_REFZERO_CHECK_SLOW(thr);
 		goto success;
 	}
 
 	DUK_UNREACHABLE();
 
- success:
+success:
 	/*
 	 *  Argument exotic [[Delete]] behavior (E5 Section 10.6) is
 	 *  a post-check, keeping arguments internal 'map' in sync with
 	 *  any successful deletes (note that property does not need to
 	 *  exist for delete to 'succeed').
 	 *
 	 *  Delete key from 'map'.  Since 'map' only contains array index
@@ -61452,16 +62637,16 @@
 		/* Note: we can reuse 'desc' here */
 		(void) duk__check_arguments_map_for_delete(thr, obj, key, &desc);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("delete successful"));
 	return 1;
 
- fail_virtual:  /* just use the same "not configurable" error message */
- fail_not_configurable:
+fail_virtual: /* just use the same "not configurable" error message */
+fail_not_configurable:
 	DUK_DDD(DUK_DDDPRINT("delete failed: property found, not configurable"));
 
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
 	return 0;
@@ -61477,31 +62662,33 @@
 	duk_propdesc desc;
 #endif
 	duk_int_t entry_top;
 	duk_uint32_t arr_idx = DUK__NO_ARRAY_INDEX;
 	duk_bool_t rc;
 
 	DUK_DDD(DUK_DDDPRINT("delprop: thr=%p, obj=%p, key=%p (obj -> %!T, key -> %!T)",
-	                     (void *) thr, (void *) tv_obj, (void *) tv_key,
-	                     (duk_tval *) tv_obj, (duk_tval *) tv_key));
+	                     (void *) thr,
+	                     (void *) tv_obj,
+	                     (void *) tv_key,
+	                     (duk_tval *) tv_obj,
+	                     (duk_tval *) tv_key));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(tv_obj != NULL);
 	DUK_ASSERT(tv_key != NULL);
 
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
 
 	/* Storing the entry top is cheaper here to ensure stack is correct at exit,
 	 * as there are several paths out.
 	 */
 	entry_top = duk_get_top(thr);
 
-	if (DUK_TVAL_IS_UNDEFINED(tv_obj) ||
-	    DUK_TVAL_IS_NULL(tv_obj)) {
+	if (DUK_TVAL_IS_UNDEFINED(tv_obj) || DUK_TVAL_IS_NULL(tv_obj)) {
 		DUK_DDD(DUK_DDDPRINT("base object is undefined or null -> reject"));
 		goto fail_invalid_base_uncond;
 	}
 
 	duk_push_tval(thr, tv_obj);
 	duk_push_tval(thr, tv_key);
 
@@ -61516,52 +62703,55 @@
 			duk_bool_t tmp_bool;
 
 			/* Note: proxy handling must happen before key is string coerced. */
 
 			if (duk__proxy_check_prop(thr, obj, DUK_STRIDX_DELETE_PROPERTY, tv_key, &h_target)) {
 				/* -> [ ... obj key trap handler ] */
 				DUK_DDD(DUK_DDDPRINT("-> proxy object 'deleteProperty' for key %!T", (duk_tval *) tv_key));
-				duk_push_hobject(thr, h_target);  /* target */
-				duk_dup_m4(thr);  /* P */
+				duk_push_hobject(thr, h_target); /* target */
+				duk_dup_m4(thr); /* P */
 				duk_call_method(thr, 2 /*nargs*/);
 				tmp_bool = duk_to_boolean_top_pop(thr);
 				if (!tmp_bool) {
-					goto fail_proxy_rejected;  /* retval indicates delete failed */
+					goto fail_proxy_rejected; /* retval indicates delete failed */
 				}
 
 				/* Target object must be checked for a conflicting
 				 * non-configurable property.
 				 */
 				tv_key = DUK_GET_TVAL_NEGIDX(thr, -1);
 				arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 				DUK_ASSERT(key != NULL);
 
-				if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 /*flags*/)) {  /* don't push value */
+				if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 /*flags*/)) { /* don't push
+					                                                                             value */
 					duk_small_int_t desc_reject;
 
 					DUK_DDD(DUK_DDDPRINT("proxy 'deleteProperty': target has matching property %!O, check for "
 					                     "conflicting property; desc.flags=0x%08lx, "
 					                     "desc.get=%p, desc.set=%p",
-					                     (duk_heaphdr *) key, (unsigned long) desc.flags,
-					                     (void *) desc.get, (void *) desc.set));
+					                     (duk_heaphdr *) key,
+					                     (unsigned long) desc.flags,
+					                     (void *) desc.get,
+					                     (void *) desc.set));
 
 					desc_reject = !(desc.flags & DUK_PROPDESC_FLAG_CONFIGURABLE);
 					if (desc_reject) {
 						/* unconditional */
 						DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 						DUK_WO_NORETURN(return 0;);
 					}
 				}
-				rc = 1;  /* success */
+				rc = 1; /* success */
 				goto done_rc;
 			}
 
-			obj = h_target;  /* resume delete to target */
+			obj = h_target; /* resume delete to target */
 		}
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 		arr_idx = duk__to_property_key(thr, -1, &key);
 		DUK_ASSERT(key != NULL);
 
 		rc = duk_hobject_delprop_raw(thr, obj, key, throw_flag ? DUK_DELPROP_FLAG_THROW : 0);
 		goto done_rc;
 	} else if (DUK_TVAL_IS_STRING(tv_obj)) {
@@ -61578,16 +62768,15 @@
 		arr_idx = duk__to_property_key(thr, -1, &key);
 		DUK_ASSERT(key != NULL);
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			goto fail_not_configurable;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HSTRING_GET_CHARLEN(h)) {
 			goto fail_not_configurable;
 		}
 	} else if (DUK_TVAL_IS_BUFFER(tv_obj)) {
 		/* XXX: unnecessary string coercion for array indices,
 		 * intentional to keep small; some overlap with string
 		 * handling.
 		 */
@@ -61597,16 +62786,15 @@
 		arr_idx = duk__to_property_key(thr, -1, &key);
 		DUK_ASSERT(key != NULL);
 
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr)) {
 			goto fail_not_configurable;
 		}
 
-		if (arr_idx != DUK__NO_ARRAY_INDEX &&
-		    arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
+		if (arr_idx != DUK__NO_ARRAY_INDEX && arr_idx < DUK_HBUFFER_GET_SIZE(h)) {
 			goto fail_not_configurable;
 		}
 	} else if (DUK_TVAL_IS_LIGHTFUNC(tv_obj)) {
 		/* Lightfunc has no virtual properties since Duktape 2.2
 		 * so success.  Still must coerce key for side effects.
 		 */
 
@@ -61615,40 +62803,43 @@
 		DUK_UNREF(key);
 	}
 
 	/* non-object base, no offending virtual property */
 	rc = 1;
 	goto done_rc;
 
- done_rc:
+done_rc:
 	duk_set_top_unsafe(thr, entry_top);
 	return rc;
 
- fail_invalid_base_uncond:
+fail_invalid_base_uncond:
 	/* Note: unconditional throw */
 	DUK_ASSERT(duk_get_top(thr) == entry_top);
 #if defined(DUK_USE_PARANOID_ERRORS)
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_BASE);
 #else
-	DUK_ERROR_FMT2(thr, DUK_ERR_TYPE_ERROR, "cannot delete property %s of %s",
-	               duk_push_string_tval_readable(thr, tv_key), duk_push_string_tval_readable(thr, tv_obj));
+	DUK_ERROR_FMT2(thr,
+	               DUK_ERR_TYPE_ERROR,
+	               "cannot delete property %s of %s",
+	               duk_push_string_tval_readable(thr, tv_key),
+	               duk_push_string_tval_readable(thr, tv_obj));
 #endif
 	DUK_WO_NORETURN(return 0;);
 
 #if defined(DUK_USE_ES6_PROXY)
- fail_proxy_rejected:
+fail_proxy_rejected:
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_PROXY_REJECTED);
 		DUK_WO_NORETURN(return 0;);
 	}
 	duk_set_top_unsafe(thr, entry_top);
 	return 0;
 #endif
 
- fail_not_configurable:
+fail_not_configurable:
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
 	duk_set_top_unsafe(thr, entry_top);
 	return 0;
 }
@@ -61668,37 +62859,43 @@
  *
  *  Stack: [... in_val] -> []
  *
  *  Used for e.g. built-in initialization and environment record
  *  operations.
  */
 
-DUK_INTERNAL void duk_hobject_define_property_internal(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags) {
+DUK_INTERNAL void duk_hobject_define_property_internal(duk_hthread *thr,
+                                                       duk_hobject *obj,
+                                                       duk_hstring *key,
+                                                       duk_small_uint_t flags) {
 	duk_propdesc desc;
 	duk_uint32_t arr_idx;
 	duk_int_t e_idx;
 	duk_tval *tv1 = NULL;
 	duk_tval *tv2 = NULL;
-	duk_small_uint_t propflags = flags & DUK_PROPDESC_FLAGS_MASK;  /* mask out flags not actually stored */
+	duk_small_uint_t propflags = flags & DUK_PROPDESC_FLAGS_MASK; /* mask out flags not actually stored */
 
 	DUK_DDD(DUK_DDDPRINT("define new property (internal): thr=%p, obj=%!O, key=%!O, flags=0x%02lx, val=%!T",
-	                     (void *) thr, (duk_heaphdr *) obj, (duk_heaphdr *) key,
-	                     (unsigned long) flags, (duk_tval *) duk_get_tval(thr, -1)));
+	                     (void *) thr,
+	                     (duk_heaphdr *) obj,
+	                     (duk_heaphdr *) key,
+	                     (unsigned long) flags,
+	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(key != NULL);
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj));
 	DUK_ASSERT_VALSTACK_SPACE(thr, DUK__VALSTACK_SPACE);
-	DUK_ASSERT(duk_is_valid_index(thr, -1));  /* contains value */
+	DUK_ASSERT(duk_is_valid_index(thr, -1)); /* contains value */
 
 	arr_idx = DUK_HSTRING_GET_ARRIDX_SLOW(key);
 
-	if (duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 /*flags*/)) {  /* don't push value */
+	if (duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 /*flags*/)) { /* don't push value */
 		if (desc.e_idx >= 0) {
 			if (flags & DUK_PROPDESC_FLAG_NO_OVERWRITE) {
 				DUK_DDD(DUK_DDDPRINT("property already exists in the entry part -> skip as requested"));
 				goto pop_exit;
 			}
 			DUK_DDD(DUK_DDDPRINT("property already exists in the entry part -> update value and attributes"));
 			if (DUK_UNLIKELY(DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, desc.e_idx))) {
@@ -61731,120 +62928,126 @@
 #if defined(DUK_USE_DEBUG)
 				duk_uint32_t prev_len;
 				prev_len = ((duk_harray *) obj)->length;
 #endif
 				new_len = duk__to_new_array_length_checked(thr, DUK_GET_TVAL_NEGIDX(thr, -1));
 				((duk_harray *) obj)->length = new_len;
 				DUK_DD(DUK_DDPRINT("internal define property for array .length: %ld -> %ld",
-				                   (long) prev_len, (long) ((duk_harray *) obj)->length));
+				                   (long) prev_len,
+				                   (long) ((duk_harray *) obj)->length));
 				goto pop_exit;
 			}
 			DUK_DD(DUK_DDPRINT("property already exists but is virtual -> failure"));
 			goto error_virtual;
 		}
 
 		goto write_value;
 	}
 
 	if (DUK_HOBJECT_HAS_ARRAY_PART(obj)) {
 		if (arr_idx != DUK__NO_ARRAY_INDEX) {
-			DUK_DDD(DUK_DDDPRINT("property does not exist, object has array part -> possibly extend array part and write value (assert attributes)"));
+			DUK_DDD(DUK_DDDPRINT("property does not exist, object has array part -> possibly extend array part and "
+			                     "write value (assert attributes)"));
 			DUK_ASSERT(propflags == DUK_PROPDESC_FLAGS_WEC);
 
 			tv1 = duk__obtain_arridx_slot(thr, arr_idx, obj);
 			if (tv1 == NULL) {
 				DUK_ASSERT(!DUK_HOBJECT_HAS_ARRAY_PART(obj));
 				goto write_to_entry_part;
 			}
 
 			tv1 = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, arr_idx);
 			goto write_value;
 		}
 	}
 
- write_to_entry_part:
-	DUK_DDD(DUK_DDDPRINT("property does not exist, object belongs in entry part -> allocate new entry and write value and attributes"));
-	e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);  /* increases key refcount */
+write_to_entry_part:
+	DUK_DDD(DUK_DDDPRINT(
+	    "property does not exist, object belongs in entry part -> allocate new entry and write value and attributes"));
+	e_idx = duk__hobject_alloc_entry_checked(thr, obj, key); /* increases key refcount */
 	DUK_ASSERT(e_idx >= 0);
 	DUK_HOBJECT_E_SET_FLAGS(thr->heap, obj, e_idx, propflags);
 	tv1 = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, obj, e_idx);
 	/* new entry: previous value is garbage; set to undefined to share write_value */
 	DUK_TVAL_SET_UNDEFINED(tv1);
 	goto write_value;
 
- write_value:
+write_value:
 	/* tv1 points to value storage */
 
-	tv2 = duk_require_tval(thr, -1);  /* late lookup, avoid side effects */
-	DUK_DDD(DUK_DDDPRINT("writing/updating value: %!T -> %!T",
-	                     (duk_tval *) tv1, (duk_tval *) tv2));
+	tv2 = duk_require_tval(thr, -1); /* late lookup, avoid side effects */
+	DUK_DDD(DUK_DDDPRINT("writing/updating value: %!T -> %!T", (duk_tval *) tv1, (duk_tval *) tv2));
 
-	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects */
 	goto pop_exit;
 
- pop_exit:
-	duk_pop_unsafe(thr);  /* remove in_val */
+pop_exit:
+	duk_pop_unsafe(thr); /* remove in_val */
 	return;
 
- error_virtual:  /* share error message */
- error_internal:
+error_virtual: /* share error message */
+error_internal:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Fast path for defining array indexed values without interning the key.
  *  This is used by e.g. code for Array prototype and traceback creation so
  *  must avoid interning.
  */
 
-DUK_INTERNAL void duk_hobject_define_property_internal_arridx(duk_hthread *thr, duk_hobject *obj, duk_uarridx_t arr_idx, duk_small_uint_t flags) {
+DUK_INTERNAL void duk_hobject_define_property_internal_arridx(duk_hthread *thr,
+                                                              duk_hobject *obj,
+                                                              duk_uarridx_t arr_idx,
+                                                              duk_small_uint_t flags) {
 	duk_hstring *key;
 	duk_tval *tv1, *tv2;
 
 	DUK_DDD(DUK_DDDPRINT("define new property (internal) arr_idx fast path: thr=%p, obj=%!O, "
 	                     "arr_idx=%ld, flags=0x%02lx, val=%!T",
-	                     (void *) thr, obj, (long) arr_idx, (unsigned long) flags,
+	                     (void *) thr,
+	                     obj,
+	                     (long) arr_idx,
+	                     (unsigned long) flags,
 	                     (duk_tval *) duk_get_tval(thr, -1)));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) obj));
 
-	if (DUK_HOBJECT_HAS_ARRAY_PART(obj) &&
-	    arr_idx != DUK__NO_ARRAY_INDEX &&
-	    flags == DUK_PROPDESC_FLAGS_WEC) {
-		DUK_ASSERT((flags & DUK_PROPDESC_FLAG_NO_OVERWRITE) == 0);  /* covered by comparison */
+	if (DUK_HOBJECT_HAS_ARRAY_PART(obj) && arr_idx != DUK__NO_ARRAY_INDEX && flags == DUK_PROPDESC_FLAGS_WEC) {
+		DUK_ASSERT((flags & DUK_PROPDESC_FLAG_NO_OVERWRITE) == 0); /* covered by comparison */
 
 		DUK_DDD(DUK_DDDPRINT("define property to array part (property may or may not exist yet)"));
 
 		tv1 = duk__obtain_arridx_slot(thr, arr_idx, obj);
 		if (tv1 == NULL) {
 			DUK_ASSERT(!DUK_HOBJECT_HAS_ARRAY_PART(obj));
 			goto write_slow;
 		}
 		tv2 = duk_require_tval(thr, -1);
 
-		DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects */
+		DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects */
 
-		duk_pop_unsafe(thr);  /* [ ...val ] -> [ ... ] */
+		duk_pop_unsafe(thr); /* [ ...val ] -> [ ... ] */
 		return;
 	}
 
- write_slow:
+write_slow:
 	DUK_DDD(DUK_DDDPRINT("define property fast path didn't work, use slow path"));
 
 	key = duk_push_uint_to_hstring(thr, (duk_uint_t) arr_idx);
 	DUK_ASSERT(key != NULL);
-	duk_insert(thr, -2);  /* [ ... val key ] -> [ ... key val ] */
+	duk_insert(thr, -2); /* [ ... val key ] -> [ ... key val ] */
 
 	duk_hobject_define_property_internal(thr, obj, key, flags);
 
-	duk_pop_unsafe(thr);  /* [ ... key ] -> [ ... ] */
+	duk_pop_unsafe(thr); /* [ ... key ] -> [ ... ] */
 }
 
 /*
  *  Internal helpers for managing object 'length'
  */
 
 DUK_INTERNAL duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj) {
@@ -61857,17 +63060,15 @@
 	if (DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj)) {
 		return ((duk_harray *) obj)->length;
 	}
 
 	/* Slow path, .length can be e.g. accessor, obj can be a Proxy, etc. */
 	duk_push_hobject(thr, obj);
 	duk_push_hstring_stridx(thr, DUK_STRIDX_LENGTH);
-	(void) duk_hobject_getprop(thr,
-	                           DUK_GET_TVAL_NEGIDX(thr, -2),
-	                           DUK_GET_TVAL_NEGIDX(thr, -1));
+	(void) duk_hobject_getprop(thr, DUK_GET_TVAL_NEGIDX(thr, -2), DUK_GET_TVAL_NEGIDX(thr, -1));
 	val = duk_to_number_m1(thr);
 	duk_pop_3_unsafe(thr);
 
 	/* This isn't part of ECMAScript semantics; return a value within
 	 * duk_size_t range, or 0 otherwise.
 	 */
 	if (val >= 0.0 && val <= (duk_double_t) DUK_SIZE_MAX) {
@@ -61900,15 +63101,15 @@
 			DUK_D(DUK_DPRINT("prototype loop when checking for finalizer existence; returning false"));
 			return 0;
 		}
 #if defined(DUK_USE_HEAPPTR16)
 		DUK_ASSERT(heap != NULL);
 		obj = DUK_HOBJECT_GET_PROTOTYPE(heap, obj);
 #else
-		obj = DUK_HOBJECT_GET_PROTOTYPE(NULL, obj);  /* 'heap' arg ignored */
+		obj = DUK_HOBJECT_GET_PROTOTYPE(NULL, obj); /* 'heap' arg ignored */
 #endif
 	} while (obj != NULL);
 
 	return 0;
 }
 
 /*
@@ -61967,15 +63168,15 @@
 	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_ENUMERABLE);
 	duk_push_boolean(thr, DUK_PROPDESC_IS_CONFIGURABLE(&pd));
 	duk_put_prop_stridx_short(thr, -2, DUK_STRIDX_CONFIGURABLE);
 
 	/* [ ... key value desc ] */
 
 	duk_replace(thr, -3);
-	duk_pop_unsafe(thr);  /* -> [ ... desc ] */
+	duk_pop_unsafe(thr); /* -> [ ... desc ] */
 }
 
 /*
  *  NormalizePropertyDescriptor() related helper.
  *
  *  Internal helper which validates and normalizes a property descriptor
  *  represented as an ECMAScript object (e.g. argument to defineProperty()).
@@ -62004,15 +63205,15 @@
 	duk_bool_t is_acc_desc = 0;
 	duk_uint_t defprop_flags = 0;
 
 	DUK_ASSERT(out_defprop_flags != NULL);
 	DUK_ASSERT(out_idx_value != NULL);
 	DUK_ASSERT(out_getter != NULL);
 	DUK_ASSERT(out_setter != NULL);
-	DUK_ASSERT(idx_in <= 0x7fffL);  /* short variants would be OK, but not used to avoid shifts */
+	DUK_ASSERT(idx_in <= 0x7fffL); /* short variants would be OK, but not used to avoid shifts */
 
 	/* Must be an object, otherwise TypeError (E5.1 Section 8.10.5, step 1). */
 	idx_in = duk_require_normalize_index(thr, idx_in);
 	(void) duk_require_hobject(thr, idx_in);
 
 	/* The coercion order must match the ToPropertyDescriptor() algorithm
 	 * so that side effects in coercion happen in the correct order.
@@ -62060,15 +63261,15 @@
 	if (duk_get_prop_stridx(thr, idx_in, DUK_STRIDX_SET)) {
 		duk_tval *tv = duk_require_tval(thr, -1);
 		duk_hobject *h_set;
 
 		if (DUK_TVAL_IS_UNDEFINED(tv)) {
 			/* undefined is accepted */
 			DUK_ASSERT(setter == NULL);
-		}  else {
+		} else {
 			/* NOTE: lightfuncs are coerced to full functions because
 			 * lightfuncs don't fit into a property value slot.  This
 			 * has some side effects, see test-dev-lightfunc-accessor.js.
 			 */
 			h_set = duk_get_hobject_promote_lfunc(thr, -1);
 			if (h_set == NULL || !DUK_HOBJECT_IS_CALLABLE(h_set)) {
 				goto type_error;
@@ -62103,15 +63304,15 @@
 	*out_idx_value = idx_value;
 	*out_getter = getter;
 	*out_setter = setter;
 
 	/* [ ... [multiple values] ] */
 	return;
 
- type_error:
+type_error:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_DESCRIPTOR);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Object.defineProperty() related helper (E5 Section 15.2.3.6).
  *  Also handles ES2015 Reflect.defineProperty().
@@ -62151,15 +63352,15 @@
 	duk_bool_t has_set;
 	duk_bool_t is_enumerable;
 	duk_bool_t is_configurable;
 	duk_bool_t is_writable;
 	duk_bool_t force_flag;
 	duk_small_uint_t new_flags;
 	duk_propdesc curr;
-	duk_uint32_t arridx_new_array_length;  /* != 0 => post-update for array 'length' (used when key is an array index) */
+	duk_uint32_t arridx_new_array_length; /* != 0 => post-update for array 'length' (used when key is an array index) */
 	duk_uint32_t arrlen_old_len;
 	duk_uint32_t arrlen_new_len;
 	duk_bool_t pending_write_protect;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(obj != NULL);
@@ -62191,21 +63392,30 @@
 	DUK_DDD(DUK_DDDPRINT("has_enumerable=%ld is_enumerable=%ld "
 	                     "has_configurable=%ld is_configurable=%ld "
 	                     "has_writable=%ld is_writable=%ld "
 	                     "has_value=%ld value=%!T "
 	                     "has_get=%ld get=%p=%!O "
 	                     "has_set=%ld set=%p=%!O "
 	                     "arr_idx=%ld throw_flag=!%ld",
-	                     (long) has_enumerable, (long) is_enumerable,
-	                     (long) has_configurable, (long) is_configurable,
-	                     (long) has_writable, (long) is_writable,
-	                     (long) has_value, (duk_tval *) (idx_value >= 0 ? duk_get_tval(thr, idx_value) : NULL),
-	                     (long) has_get, (void *) get, (duk_heaphdr *) get,
-	                     (long) has_set, (void *) set, (duk_heaphdr *) set,
-	                     (long) arr_idx, (long) throw_flag));
+	                     (long) has_enumerable,
+	                     (long) is_enumerable,
+	                     (long) has_configurable,
+	                     (long) is_configurable,
+	                     (long) has_writable,
+	                     (long) is_writable,
+	                     (long) has_value,
+	                     (duk_tval *) (idx_value >= 0 ? duk_get_tval(thr, idx_value) : NULL),
+	                     (long) has_get,
+	                     (void *) get,
+	                     (duk_heaphdr *) get,
+	                     (long) has_set,
+	                     (void *) set,
+	                     (duk_heaphdr *) set,
+	                     (long) arr_idx,
+	                     (long) throw_flag));
 
 	/*
 	 *  Array exotic behaviors can be implemented at this point.  The local variables
 	 *  are essentially a 'value copy' of the input descriptor (Desc), which is modified
 	 *  by the Array [[DefineOwnProperty]] (E5 Section 15.4.5.1).
 	 */
 
@@ -62231,15 +63441,15 @@
 		a = (duk_harray *) obj;
 		DUK_HARRAY_ASSERT_VALID(a);
 		arrlen_old_len = a->length;
 
 		DUK_ASSERT(idx_value >= 0);
 		arrlen_new_len = duk__to_new_array_length_checked(thr, DUK_GET_TVAL_POSIDX(thr, idx_value));
 		duk_push_u32(thr, arrlen_new_len);
-		duk_replace(thr, idx_value);  /* step 3.e: replace 'Desc.[[Value]]' */
+		duk_replace(thr, idx_value); /* step 3.e: replace 'Desc.[[Value]]' */
 
 		DUK_DDD(DUK_DDDPRINT("old_len=%ld, new_len=%ld", (long) arrlen_old_len, (long) arrlen_new_len));
 
 		if (arrlen_new_len >= arrlen_old_len) {
 			/* standard behavior, step 3.f.i */
 			DUK_DDD(DUK_DDDPRINT("new length is same or higher as previous => standard behavior"));
 			goto skip_array_exotic;
@@ -62273,15 +63483,16 @@
 		DUK_HARRAY_ASSERT_VALID(a);
 
 		old_len = a->length;
 
 		if (arr_idx >= old_len) {
 			DUK_DDD(DUK_DDDPRINT("defineProperty requires array length update "
 			                     "(arr_idx=%ld, old_len=%ld)",
-			                     (long) arr_idx, (long) old_len));
+			                     (long) arr_idx,
+			                     (long) old_len));
 
 			if (DUK_HARRAY_LENGTH_NONWRITABLE(a) && !force_flag) {
 				/* Array .length is always non-configurable, so
 				 * if it's also non-writable, don't allow a value
 				 * write.  With force flag allow writing.
 				 */
 				goto fail_not_configurable;
@@ -62291,18 +63502,19 @@
 			 * error below.
 			 */
 			DUK_ASSERT(arr_idx != 0xffffffffUL);
 			arridx_new_array_length = arr_idx + 1;
 		} else {
 			DUK_DDD(DUK_DDDPRINT("defineProperty does not require length update "
 			                     "(arr_idx=%ld, old_len=%ld) -> standard behavior",
-			                     (long) arr_idx, (long) old_len));
+			                     (long) arr_idx,
+			                     (long) old_len));
 		}
 	}
- skip_array_exotic:
+skip_array_exotic:
 
 	/* XXX: There is currently no support for writing buffer object
 	 * indexed elements here.  Attempt to do so will succeed and
 	 * write a concrete property into the buffer object.  This should
 	 * be fixed at some point but because buffers are a custom feature
 	 * anyway, this is relatively unimportant.
 	 */
@@ -62346,15 +63558,15 @@
 			DUK_DDD(DUK_DDDPRINT("create new accessor property"));
 
 			DUK_ASSERT(has_set || set == NULL);
 			DUK_ASSERT(has_get || get == NULL);
 			DUK_ASSERT(!has_value);
 			DUK_ASSERT(!has_writable);
 
-			new_flags = DUK_PROPDESC_FLAG_ACCESSOR;  /* defaults, E5 Section 8.6.1, Table 7 */
+			new_flags = DUK_PROPDESC_FLAG_ACCESSOR; /* defaults, E5 Section 8.6.1, Table 7 */
 			if (has_enumerable && is_enumerable) {
 				new_flags |= DUK_PROPDESC_FLAG_ENUMERABLE;
 			}
 			if (has_configurable && is_configurable) {
 				new_flags |= DUK_PROPDESC_FLAG_CONFIGURABLE;
 			}
 
@@ -62379,34 +63591,35 @@
 			duk_tval *tv2;
 
 			DUK_DDD(DUK_DDDPRINT("create new data property"));
 
 			DUK_ASSERT(!has_set);
 			DUK_ASSERT(!has_get);
 
-			new_flags = 0;  /* defaults, E5 Section 8.6.1, Table 7 */
+			new_flags = 0; /* defaults, E5 Section 8.6.1, Table 7 */
 			if (has_writable && is_writable) {
 				new_flags |= DUK_PROPDESC_FLAG_WRITABLE;
 			}
 			if (has_enumerable && is_enumerable) {
 				new_flags |= DUK_PROPDESC_FLAG_ENUMERABLE;
 			}
 			if (has_configurable && is_configurable) {
 				new_flags |= DUK_PROPDESC_FLAG_CONFIGURABLE;
 			}
 			if (has_value) {
 				duk_tval *tv_tmp = duk_require_tval(thr, idx_value);
 				DUK_TVAL_SET_TVAL(&tv, tv_tmp);
 			} else {
-				DUK_TVAL_SET_UNDEFINED(&tv);  /* default value */
+				DUK_TVAL_SET_UNDEFINED(&tv); /* default value */
 			}
 
 			if (arr_idx != DUK__NO_ARRAY_INDEX && DUK_HOBJECT_HAS_ARRAY_PART(obj)) {
 				if (new_flags == DUK_PROPDESC_FLAGS_WEC) {
-					DUK_DDD(DUK_DDDPRINT("new data property attributes match array defaults, attempt to write to array part"));
+					DUK_DDD(DUK_DDDPRINT(
+					    "new data property attributes match array defaults, attempt to write to array part"));
 					tv2 = duk__obtain_arridx_slot(thr, arr_idx, obj);
 					if (tv2 == NULL) {
 						DUK_DDD(DUK_DDDPRINT("failed writing to array part, abandoned array"));
 					} else {
 						DUK_DDD(DUK_DDDPRINT("success in writing to array part"));
 						DUK_ASSERT(DUK_HOBJECT_HAS_ARRAY_PART(obj));
 						DUK_ASSERT(DUK_TVAL_IS_UNUSED(tv2));
@@ -62471,16 +63684,16 @@
 		duk_tval *tmp2;
 
 		/* attempt to change from accessor to data property */
 		if (curr.flags & DUK_PROPDESC_FLAG_ACCESSOR) {
 			goto need_check;
 		}
 
-		tmp1 = duk_require_tval(thr, -1);         /* curr value */
-		tmp2 = duk_require_tval(thr, idx_value);  /* new value */
+		tmp1 = duk_require_tval(thr, -1); /* curr value */
+		tmp2 = duk_require_tval(thr, idx_value); /* new value */
 		if (!duk_js_samevalue(tmp1, tmp2)) {
 			goto need_check;
 		}
 	}
 	if (has_writable) {
 		/* attempt to change from accessor to data property */
 		if (curr.flags & DUK_PROPDESC_FLAG_ACCESSOR) {
@@ -62517,15 +63730,15 @@
 	}
 
 	/* property exists, either 'desc' is empty, or all values
 	 * match (SameValue)
 	 */
 	goto success_no_exotics;
 
- need_check:
+need_check:
 
 	/*
 	 *  Some change(s) need to be made.  Steps 7-11.
 	 */
 
 	/* shared checks for all descriptor types */
 	if (!(curr.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && !force_flag) {
@@ -62589,32 +63802,33 @@
 			/* curr is data, desc is accessor */
 			if (!(curr.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && !force_flag) {
 				goto fail_not_configurable;
 			}
 
 			DUK_DDD(DUK_DDDPRINT("convert property to accessor property"));
 			if (curr.a_idx >= 0) {
-				DUK_DDD(DUK_DDDPRINT("property to convert is stored in an array entry, abandon array and re-lookup"));
+				DUK_DDD(
+				    DUK_DDDPRINT("property to convert is stored in an array entry, abandon array and re-lookup"));
 				duk__abandon_array_part(thr, obj);
-				duk_pop_unsafe(thr);  /* remove old value */
+				duk_pop_unsafe(thr); /* remove old value */
 				rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, DUK_GETDESC_FLAG_PUSH_VALUE);
 				DUK_UNREF(rc);
 				DUK_ASSERT(rc != 0);
 				DUK_ASSERT(curr.e_idx >= 0 && curr.a_idx < 0);
 			}
 			if (curr.e_idx < 0) {
 				DUK_ASSERT(curr.a_idx < 0 && curr.e_idx < 0);
-				goto fail_virtual;  /* safeguard for virtual property */
+				goto fail_virtual; /* safeguard for virtual property */
 			}
 
 			DUK_ASSERT(curr.e_idx >= 0);
 			DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, curr.e_idx));
 
 			tv1 = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, obj, curr.e_idx);
-			DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ(thr, tv1);  /* XXX: just decref */
+			DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ(thr, tv1); /* XXX: just decref */
 
 			DUK_HOBJECT_E_SET_VALUE_GETTER(thr->heap, obj, curr.e_idx, NULL);
 			DUK_HOBJECT_E_SET_VALUE_SETTER(thr->heap, obj, curr.e_idx, NULL);
 			DUK_HOBJECT_E_SLOT_CLEAR_WRITABLE(thr->heap, obj, curr.e_idx);
 			DUK_HOBJECT_E_SLOT_SET_ACCESSOR(thr->heap, obj, curr.e_idx);
 
 			DUK_DDD(DUK_DDDPRINT("flags after data->accessor conversion: 0x%02lx",
@@ -62635,15 +63849,15 @@
 			if (!(curr.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && !force_flag) {
 				goto fail_not_configurable;
 			}
 
 			/* curr is accessor -> cannot be in array part. */
 			DUK_ASSERT(curr.a_idx < 0);
 			if (curr.e_idx < 0) {
-				goto fail_virtual;  /* safeguard; no virtual accessors now */
+				goto fail_virtual; /* safeguard; no virtual accessors now */
 			}
 
 			DUK_DDD(DUK_DDDPRINT("convert property to data property"));
 
 			DUK_ASSERT(DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, curr.e_idx));
 			tmp = DUK_HOBJECT_E_GET_VALUE_GETTER(thr->heap, obj, curr.e_idx);
 			DUK_UNREF(tmp);
@@ -62667,16 +63881,16 @@
 			/* curr and desc are data */
 			if (!(curr.flags & DUK_PROPDESC_FLAG_CONFIGURABLE) && !force_flag) {
 				if (!(curr.flags & DUK_PROPDESC_FLAG_WRITABLE) && has_writable && is_writable) {
 					goto fail_not_configurable;
 				}
 				/* Note: changing from writable to non-writable is OK */
 				if (!(curr.flags & DUK_PROPDESC_FLAG_WRITABLE) && has_value) {
-					duk_tval *tmp1 = duk_require_tval(thr, -1);         /* curr value */
-					duk_tval *tmp2 = duk_require_tval(thr, idx_value);  /* new value */
+					duk_tval *tmp1 = duk_require_tval(thr, -1); /* curr value */
+					duk_tval *tmp2 = duk_require_tval(thr, idx_value); /* new value */
 					if (!duk_js_samevalue(tmp1, tmp2)) {
 						goto fail_not_configurable;
 					}
 				}
 			}
 		}
 	} else {
@@ -62717,16 +63931,15 @@
 		} else {
 			new_flags &= ~DUK_PROPDESC_FLAG_WRITABLE;
 		}
 	}
 
 	/* XXX: write protect after flag? -> any chance of handling it here? */
 
-	DUK_DDD(DUK_DDDPRINT("new flags that we want to write: 0x%02lx",
-	                     (unsigned long) new_flags));
+	DUK_DDD(DUK_DDDPRINT("new flags that we want to write: 0x%02lx", (unsigned long) new_flags));
 
 	/*
 	 *  Check whether we need to abandon an array part (if it exists)
 	 */
 
 	if (curr.a_idx >= 0) {
 		duk_bool_t rc;
@@ -62734,28 +63947,31 @@
 		DUK_ASSERT(curr.e_idx < 0);
 
 		if (new_flags == DUK_PROPDESC_FLAGS_WEC) {
 			duk_tval *tv1, *tv2;
 
 			DUK_DDD(DUK_DDDPRINT("array index, new property attributes match array defaults, update in-place"));
 
-			DUK_ASSERT(curr.flags == DUK_PROPDESC_FLAGS_WEC);  /* must have been, since in array part */
+			DUK_ASSERT(curr.flags == DUK_PROPDESC_FLAGS_WEC); /* must have been, since in array part */
 			DUK_ASSERT(!has_set);
 			DUK_ASSERT(!has_get);
-			DUK_ASSERT(idx_value >= 0);  /* must be: if attributes match and we get here the value must differ (otherwise no change) */
+			DUK_ASSERT(
+			    idx_value >=
+			    0); /* must be: if attributes match and we get here the value must differ (otherwise no change) */
 
 			tv2 = duk_require_tval(thr, idx_value);
 			tv1 = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, obj, curr.a_idx);
-			DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects; may invalidate a_idx */
+			DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects; may invalidate a_idx */
 			goto success_exotics;
 		}
 
-		DUK_DDD(DUK_DDDPRINT("array index, new property attributes do not match array defaults, abandon array and re-lookup"));
+		DUK_DDD(
+		    DUK_DDDPRINT("array index, new property attributes do not match array defaults, abandon array and re-lookup"));
 		duk__abandon_array_part(thr, obj);
-		duk_pop_unsafe(thr);  /* remove old value */
+		duk_pop_unsafe(thr); /* remove old value */
 		rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, DUK_GETDESC_FLAG_PUSH_VALUE);
 		DUK_UNREF(rc);
 		DUK_ASSERT(rc != 0);
 		DUK_ASSERT(curr.e_idx >= 0 && curr.a_idx < 0);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("updating existing property in entry part"));
@@ -62771,18 +63987,20 @@
 	} else {
 		/* For Array .length the only allowed transition is for .length
 		 * to become non-writable.
 		 */
 		if (key == DUK_HTHREAD_STRING_LENGTH(thr) && DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj)) {
 			duk_harray *a;
 			a = (duk_harray *) obj;
-			DUK_DD(DUK_DDPRINT("Object.defineProperty() attribute update for duk_harray .length -> %02lx", (unsigned long) new_flags));
+			DUK_DD(DUK_DDPRINT("Object.defineProperty() attribute update for duk_harray .length -> %02lx",
+			                   (unsigned long) new_flags));
 			DUK_HARRAY_ASSERT_VALID(a);
 			if ((new_flags & DUK_PROPDESC_FLAGS_EC) != (curr.flags & DUK_PROPDESC_FLAGS_EC)) {
-				DUK_D(DUK_DPRINT("Object.defineProperty() attempt to change virtual array .length enumerable or configurable attribute, fail"));
+				DUK_D(DUK_DPRINT("Object.defineProperty() attempt to change virtual array .length enumerable or "
+				                 "configurable attribute, fail"));
 				goto fail_virtual;
 			}
 			if (new_flags & DUK_PROPDESC_FLAG_WRITABLE) {
 				DUK_HARRAY_SET_LENGTH_WRITABLE(a);
 			} else {
 				DUK_HARRAY_SET_LENGTH_NONWRITABLE(a);
 			}
@@ -62802,15 +64020,15 @@
 		DUK_DDD(DUK_DDDPRINT("update existing property setter"));
 		DUK_ASSERT(DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, curr.e_idx));
 
 		tmp = DUK_HOBJECT_E_GET_VALUE_SETTER(thr->heap, obj, curr.e_idx);
 		DUK_UNREF(tmp);
 		DUK_HOBJECT_E_SET_VALUE_SETTER(thr->heap, obj, curr.e_idx, set);
 		DUK_HOBJECT_INCREF_ALLOWNULL(thr, set);
-		DUK_HOBJECT_DECREF_ALLOWNULL(thr, tmp);  /* side effects; may invalidate e_idx */
+		DUK_HOBJECT_DECREF_ALLOWNULL(thr, tmp); /* side effects; may invalidate e_idx */
 	}
 	if (has_get) {
 		duk_hobject *tmp;
 
 		if (curr.e_idx < 0) {
 			goto fail_virtual;
 		}
@@ -62818,41 +64036,42 @@
 		DUK_DDD(DUK_DDDPRINT("update existing property getter"));
 		DUK_ASSERT(DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, curr.e_idx));
 
 		tmp = DUK_HOBJECT_E_GET_VALUE_GETTER(thr->heap, obj, curr.e_idx);
 		DUK_UNREF(tmp);
 		DUK_HOBJECT_E_SET_VALUE_GETTER(thr->heap, obj, curr.e_idx, get);
 		DUK_HOBJECT_INCREF_ALLOWNULL(thr, get);
-		DUK_HOBJECT_DECREF_ALLOWNULL(thr, tmp);  /* side effects; may invalidate e_idx */
+		DUK_HOBJECT_DECREF_ALLOWNULL(thr, tmp); /* side effects; may invalidate e_idx */
 	}
 	if (has_value) {
 		duk_tval *tv1, *tv2;
 
 		DUK_DDD(DUK_DDDPRINT("update existing property value"));
 
 		if (curr.e_idx >= 0) {
 			DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, obj, curr.e_idx));
 			tv2 = duk_require_tval(thr, idx_value);
 			tv1 = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, obj, curr.e_idx);
-			DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects; may invalidate e_idx */
+			DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects; may invalidate e_idx */
 		} else {
-			DUK_ASSERT(curr.a_idx < 0);  /* array part case handled comprehensively previously */
+			DUK_ASSERT(curr.a_idx < 0); /* array part case handled comprehensively previously */
 
 			DUK_DD(DUK_DDPRINT("Object.defineProperty(), value update for virtual property"));
 			/* XXX: Uint8Array and other typed array virtual writes not currently
 			 * handled.
 			 */
 			if (key == DUK_HTHREAD_STRING_LENGTH(thr) && DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj)) {
 				duk_harray *a;
 				a = (duk_harray *) obj;
-				DUK_DD(DUK_DDPRINT("Object.defineProperty() value update for duk_harray .length -> %ld", (long) arrlen_new_len));
+				DUK_DD(DUK_DDPRINT("Object.defineProperty() value update for duk_harray .length -> %ld",
+				                   (long) arrlen_new_len));
 				DUK_HARRAY_ASSERT_VALID(a);
 				a->length = arrlen_new_len;
 			} else {
-				goto fail_virtual;  /* should not happen */
+				goto fail_virtual; /* should not happen */
 			}
 		}
 	}
 
 	/*
 	 *  Standard algorithm succeeded without errors, check for exotic post-behaviors.
 	 *
@@ -62861,15 +64080,15 @@
 	 *
 	 *  Array exotic behavior in E5 Section 15.4.5.1 is implemented partly
 	 *  prior to the default [[DefineOwnProperty]], but:
 	 *    - for an array index key (e.g. "10") the final 'length' update occurs here
 	 *    - for 'length' key the element deletion and 'length' update occurs here
 	 */
 
- success_exotics:
+success_exotics:
 
 	/* curr.a_idx or curr.e_idx may have been invalidated by side effects
 	 * above.
 	 */
 
 	/* [obj key desc value get set curr_value] */
 
@@ -62905,15 +64124,16 @@
 
 			duk_uint32_t result_len;
 			duk_bool_t rc;
 
 			DUK_DDD(DUK_DDDPRINT("defineProperty successful, key is 'length', exotic array behavior, "
 			                     "doing array element deletion and length update"));
 
-			rc = duk__handle_put_array_length_smaller(thr, obj, arrlen_old_len, arrlen_new_len, force_flag, &result_len);
+			rc =
+			    duk__handle_put_array_length_smaller(thr, obj, arrlen_old_len, arrlen_new_len, force_flag, &result_len);
 
 			/* update length (curr points to length, and we assume it's still valid) */
 			DUK_ASSERT(result_len >= arrlen_new_len && result_len <= arrlen_old_len);
 
 			a->length = result_len;
 
 			if (pending_write_protect) {
@@ -62928,15 +64148,15 @@
 			}
 		}
 	} else if (arr_idx != DUK__NO_ARRAY_INDEX && DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(obj)) {
 		duk_hobject *map;
 		duk_hobject *varenv;
 
 		DUK_ASSERT(arridx_new_array_length == 0);
-		DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj));  /* traits are separate; in particular, arguments not an array */
+		DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARRAY(obj)); /* traits are separate; in particular, arguments not an array */
 
 		map = NULL;
 		varenv = NULL;
 		if (!duk__lookup_arguments_map(thr, obj, key, &curr, &map, &varenv)) {
 			goto success_no_exotics;
 		}
 		DUK_ASSERT(map != NULL);
@@ -62945,15 +64165,15 @@
 		/* [obj key desc value get set curr_value varname] */
 
 		if (has_set || has_get) {
 			/* = IsAccessorDescriptor(Desc) */
 			DUK_DDD(DUK_DDDPRINT("defineProperty successful, key mapped to arguments 'map' "
 			                     "changed to an accessor, delete arguments binding"));
 
-			(void) duk_hobject_delprop_raw(thr, map, key, 0);  /* ignore result */
+			(void) duk_hobject_delprop_raw(thr, map, key, 0); /* ignore result */
 		} else {
 			/* Note: this order matters (final value before deleting map entry must be done) */
 			DUK_DDD(DUK_DDDPRINT("defineProperty successful, key mapped to arguments 'map', "
 			                     "check for value update / binding deletion"));
 
 			if (has_value) {
 				duk_hstring *varname;
@@ -62973,39 +64193,39 @@
 				/* strict flag for putvar comes from our caller (currently: fixed) */
 				duk_js_putvar_envrec(thr, varenv, varname, duk_require_tval(thr, idx_value), 1 /*throw_flag*/);
 			}
 			if (has_writable && !is_writable) {
 				DUK_DDD(DUK_DDDPRINT("defineProperty successful, key mapped to arguments 'map', "
 				                     "changed to non-writable, delete arguments binding"));
 
-				(void) duk_hobject_delprop_raw(thr, map, key, 0);  /* ignore result */
+				(void) duk_hobject_delprop_raw(thr, map, key, 0); /* ignore result */
 			}
 		}
 
 		/* 'varname' is in stack in this else branch, leaving an unbalanced stack below,
 		 * but this doesn't matter now.
 		 */
 	}
 
- success_no_exotics:
+success_no_exotics:
 	/* Some code paths use NORZ macros for simplicity, ensure refzero
 	 * handling is completed.
 	 */
 	DUK_REFZERO_CHECK_SLOW(thr);
 	return 1;
 
- fail_not_extensible:
+fail_not_extensible:
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_EXTENSIBLE);
 		DUK_WO_NORETURN(return 0;);
 	}
 	return 0;
 
- fail_virtual:  /* just use the same "not configurable" error message" */
- fail_not_configurable:
+fail_virtual: /* just use the same "not configurable" error message" */
+fail_not_configurable:
 	if (throw_flag) {
 		DUK_ERROR_TYPE(thr, DUK_STR_NOT_CONFIGURABLE);
 		DUK_WO_NORETURN(return 0;);
 	}
 	return 0;
 }
 
@@ -63022,15 +64242,15 @@
 	/* coercion order matters */
 	h_v = duk_to_hstring_acceptsymbol(thr, 0);
 	DUK_ASSERT(h_v != NULL);
 
 	h_obj = duk_push_this_coercible_to_object(thr);
 	DUK_ASSERT(h_obj != NULL);
 
-	ret = duk_hobject_get_own_propdesc(thr, h_obj, h_v, &desc, 0 /*flags*/);  /* don't push value */
+	ret = duk_hobject_get_own_propdesc(thr, h_obj, h_v, &desc, 0 /*flags*/); /* don't push value */
 
 	duk_push_boolean(thr, ret && ((desc.flags & required_desc_flags) == required_desc_flags));
 	return 1;
 }
 
 /*
  *  Object.seal() and Object.freeze()  (E5 Sections 15.2.3.8 and 15.2.3.9)
@@ -63136,17 +64356,15 @@
 
 		/* avoid multiple computations of flags address; bypasses macros */
 		flags = (duk_small_uint_t) DUK_HOBJECT_E_GET_FLAGS(thr->heap, obj, i);
 
 		if (flags & DUK_PROPDESC_FLAG_CONFIGURABLE) {
 			return 0;
 		}
-		if (is_frozen &&
-		    !(flags & DUK_PROPDESC_FLAG_ACCESSOR) &&
-		    (flags & DUK_PROPDESC_FLAG_WRITABLE)) {
+		if (is_frozen && !(flags & DUK_PROPDESC_FLAG_ACCESSOR) && (flags & DUK_PROPDESC_FLAG_WRITABLE)) {
 			return 0;
 		}
 	}
 
 	/* array part must not contain any non-unused properties, as they would
 	 * be configurable and writable.
 	 */
@@ -63182,61 +64400,61 @@
 
 #if defined(DUK_USE_ASSERTIONS)
 
 DUK_INTERNAL void duk_hstring_assert_valid(duk_hstring *h) {
 	DUK_ASSERT(h != NULL);
 }
 
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 #line 1 "duk_hstring_misc.c"
 /*
  *  Misc support functions
  */
 
 /* #include duk_internal.h -> already included */
 
 /*
  *  duk_hstring charCodeAt, with and without surrogate awareness
  */
 
-DUK_INTERNAL duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr, duk_hstring *h, duk_uint_t pos, duk_bool_t surrogate_aware) {
+DUK_INTERNAL duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr,
+                                                           duk_hstring *h,
+                                                           duk_uint_t pos,
+                                                           duk_bool_t surrogate_aware) {
 	duk_uint32_t boff;
 	const duk_uint8_t *p, *p_start, *p_end;
 	duk_ucodepoint_t cp1;
 	duk_ucodepoint_t cp2;
 
 	/* Caller must check character offset to be inside the string. */
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(h != NULL);
-	DUK_ASSERT_DISABLE(pos >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(pos >= 0); /* unsigned */
 	DUK_ASSERT(pos < (duk_uint_t) DUK_HSTRING_GET_CHARLEN(h));
 
 	boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint32_t) pos);
-	DUK_DDD(DUK_DDDPRINT("charCodeAt: pos=%ld -> boff=%ld, str=%!O",
-	                     (long) pos, (long) boff, (duk_heaphdr *) h));
+	DUK_DDD(DUK_DDDPRINT("charCodeAt: pos=%ld -> boff=%ld, str=%!O", (long) pos, (long) boff, (duk_heaphdr *) h));
 	DUK_ASSERT_DISABLE(boff >= 0);
 	DUK_ASSERT(boff < DUK_HSTRING_GET_BYTELEN(h));
 
 	p_start = DUK_HSTRING_GET_DATA(h);
 	p_end = p_start + DUK_HSTRING_GET_BYTELEN(h);
 	p = p_start + boff;
-	DUK_DDD(DUK_DDDPRINT("p_start=%p, p_end=%p, p=%p",
-	                     (const void *) p_start, (const void *) p_end,
-	                     (const void *) p));
+	DUK_DDD(DUK_DDDPRINT("p_start=%p, p_end=%p, p=%p", (const void *) p_start, (const void *) p_end, (const void *) p));
 
 	/* For invalid UTF-8 (never happens for standard ECMAScript strings)
 	 * return U+FFFD replacement character.
 	 */
 	if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp1)) {
 		if (surrogate_aware && cp1 >= 0xd800UL && cp1 <= 0xdbffUL) {
 			/* The decode helper is memory safe even if 'cp1' was
 			 * decoded at the end of the string and 'p' is no longer
 			 * within string memory range.
 			 */
-			cp2 = 0;  /* If call fails, this is left untouched and won't match cp2 check. */
+			cp2 = 0; /* If call fails, this is left untouched and won't match cp2 check. */
 			(void) duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp2);
 			if (cp2 >= 0xdc00UL && cp2 <= 0xdfffUL) {
 				cp1 = (duk_ucodepoint_t) (((cp1 - 0xd800UL) << 10) + (cp2 - 0xdc00UL) + 0x10000UL);
 			}
 		}
 	} else {
 		cp1 = DUK_UNICODE_CP_REPLACEMENT_CHARACTER;
@@ -63258,15 +64476,15 @@
 
 	DUK_ASSERT(h != NULL);
 	DUK_ASSERT(!DUK_HSTRING_HAS_ASCII(h));
 	DUK_ASSERT(!DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) h));
 
 	clen = duk_unicode_unvalidated_utf8_length(DUK_HSTRING_GET_DATA(h), DUK_HSTRING_GET_BYTELEN(h));
 #if defined(DUK_USE_STRLEN16)
-	DUK_ASSERT(clen <= 0xffffUL);  /* Bytelength checked during interning. */
+	DUK_ASSERT(clen <= 0xffffUL); /* Bytelength checked during interning. */
 	h->clen16 = (duk_uint16_t) clen;
 #else
 	h->clen = (duk_uint32_t) clen;
 #endif
 	if (DUK_LIKELY(clen == DUK_HSTRING_GET_BYTELEN(h))) {
 		DUK_HSTRING_SET_ASCII(h);
 	}
@@ -63275,49 +64493,49 @@
 DUK_INTERNAL DUK_HOT duk_size_t duk_hstring_get_charlen(duk_hstring *h) {
 #if defined(DUK_USE_STRLEN16)
 	return h->clen16;
 #else
 	return h->clen;
 #endif
 }
-#endif  /* !DUK_USE_HSTRING_LAZY_CLEN */
+#endif /* !DUK_USE_HSTRING_LAZY_CLEN */
 
 /*
  *  duk_hstring charlen, when lazy charlen enabled
  */
 
 #if defined(DUK_USE_HSTRING_LAZY_CLEN)
 #if defined(DUK_USE_HSTRING_CLEN)
 DUK_LOCAL DUK_COLD duk_size_t duk__hstring_get_charlen_slowpath(duk_hstring *h) {
 	duk_size_t res;
 
-	DUK_ASSERT(h->clen == 0);  /* Checked by caller. */
+	DUK_ASSERT(h->clen == 0); /* Checked by caller. */
 
 #if defined(DUK_USE_ROM_STRINGS)
 	/* ROM strings have precomputed clen, but if the computed clen is zero
 	 * we can still come here and can't write anything.
 	 */
 	if (DUK_HEAPHDR_HAS_READONLY((duk_heaphdr *) h)) {
 		return 0;
 	}
 #endif
 
 	res = duk_unicode_unvalidated_utf8_length(DUK_HSTRING_GET_DATA(h), DUK_HSTRING_GET_BYTELEN(h));
 #if defined(DUK_USE_STRLEN16)
-	DUK_ASSERT(res <= 0xffffUL);  /* Bytelength checked during interning. */
+	DUK_ASSERT(res <= 0xffffUL); /* Bytelength checked during interning. */
 	h->clen16 = (duk_uint16_t) res;
 #else
 	h->clen = (duk_uint32_t) res;
 #endif
 	if (DUK_LIKELY(res == DUK_HSTRING_GET_BYTELEN(h))) {
 		DUK_HSTRING_SET_ASCII(h);
 	}
 	return res;
 }
-#else  /* DUK_USE_HSTRING_CLEN */
+#else /* DUK_USE_HSTRING_CLEN */
 DUK_LOCAL duk_size_t duk__hstring_get_charlen_slowpath(duk_hstring *h) {
 	if (DUK_LIKELY(DUK_HSTRING_HAS_ASCII(h))) {
 		/* Most practical strings will go here. */
 		return DUK_HSTRING_GET_BYTELEN(h);
 	} else {
 		/* ASCII flag is lazy, so set it here. */
 		duk_size_t res;
@@ -63338,36 +64556,36 @@
 #endif
 		if (DUK_LIKELY(res == DUK_HSTRING_GET_BYTELEN(h))) {
 			DUK_HSTRING_SET_ASCII(h);
 		}
 		return res;
 	}
 }
-#endif  /* DUK_USE_HSTRING_CLEN */
+#endif /* DUK_USE_HSTRING_CLEN */
 
 #if defined(DUK_USE_HSTRING_CLEN)
 DUK_INTERNAL DUK_HOT duk_size_t duk_hstring_get_charlen(duk_hstring *h) {
 #if defined(DUK_USE_STRLEN16)
 	if (DUK_LIKELY(h->clen16 != 0)) {
 		return h->clen16;
 	}
 #else
 	if (DUK_LIKELY(h->clen != 0)) {
 		return h->clen;
 	}
 #endif
 	return duk__hstring_get_charlen_slowpath(h);
 }
-#else  /* DUK_USE_HSTRING_CLEN */
+#else /* DUK_USE_HSTRING_CLEN */
 DUK_INTERNAL DUK_HOT duk_size_t duk_hstring_get_charlen(duk_hstring *h) {
 	/* Always use slow path. */
 	return duk__hstring_get_charlen_slowpath(h);
 }
-#endif  /* DUK_USE_HSTRING_CLEN */
-#endif  /* DUK_USE_HSTRING_LAZY_CLEN */
+#endif /* DUK_USE_HSTRING_CLEN */
+#endif /* DUK_USE_HSTRING_LAZY_CLEN */
 
 /*
  *  Compare duk_hstring to an ASCII cstring.
  */
 
 DUK_INTERNAL duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr) {
 	duk_size_t len;
@@ -63425,15 +64643,15 @@
 
 	for (i = 0; i < DUK_VALSTACK_INITIAL_SIZE; i++) {
 		DUK_TVAL_SET_UNDEFINED(&thr->valstack[i]);
 	}
 
 	return 1;
 
- fail:
+fail:
 	DUK_FREE(heap, thr->valstack);
 	DUK_ASSERT(thr->callstack_curr == NULL);
 
 	thr->valstack = NULL;
 	return 0;
 }
 
@@ -63453,29 +64671,29 @@
 
 /* #include duk_internal.h -> already included */
 
 /*
  *  Encoding constants, must match genbuiltins.py
  */
 
-#define DUK__PROP_FLAGS_BITS             3
-#define DUK__LENGTH_PROP_BITS            3
-#define DUK__NARGS_BITS                  3
-#define DUK__PROP_TYPE_BITS              3
-
-#define DUK__NARGS_VARARGS_MARKER        0x07
-
-#define DUK__PROP_TYPE_DOUBLE            0
-#define DUK__PROP_TYPE_STRING            1
-#define DUK__PROP_TYPE_STRIDX            2
-#define DUK__PROP_TYPE_BUILTIN           3
-#define DUK__PROP_TYPE_UNDEFINED         4
-#define DUK__PROP_TYPE_BOOLEAN_TRUE      5
-#define DUK__PROP_TYPE_BOOLEAN_FALSE     6
-#define DUK__PROP_TYPE_ACCESSOR          7
+#define DUK__PROP_FLAGS_BITS  3
+#define DUK__LENGTH_PROP_BITS 3
+#define DUK__NARGS_BITS       3
+#define DUK__PROP_TYPE_BITS   3
+
+#define DUK__NARGS_VARARGS_MARKER 0x07
+
+#define DUK__PROP_TYPE_DOUBLE        0
+#define DUK__PROP_TYPE_STRING        1
+#define DUK__PROP_TYPE_STRIDX        2
+#define DUK__PROP_TYPE_BUILTIN       3
+#define DUK__PROP_TYPE_UNDEFINED     4
+#define DUK__PROP_TYPE_BOOLEAN_TRUE  5
+#define DUK__PROP_TYPE_BOOLEAN_FALSE 6
+#define DUK__PROP_TYPE_ACCESSOR      7
 
 /*
  *  Create built-in objects by parsing an init bitstream generated
  *  by genbuiltins.py.
  */
 
 #if defined(DUK_USE_ROM_OBJECTS)
@@ -63490,28 +64708,26 @@
 	duk_hobject *h_objenv;
 
 	/* XXX: refactor into internal helper, duk_clone_hobject() */
 
 #if defined(DUK_USE_ROM_GLOBAL_INHERIT)
 	/* Inherit from ROM-based global object: less RAM usage, less transparent. */
 	h_global = duk_push_object_helper(thr,
-	                                  DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                  DUK_HOBJECT_FLAG_FASTREFS |
-	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_GLOBAL),
+	                                  DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                      DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_GLOBAL),
 	                                  DUK_BIDX_GLOBAL);
 	DUK_ASSERT(h_global != NULL);
 #elif defined(DUK_USE_ROM_GLOBAL_CLONE)
 	/* Clone the properties of the ROM-based global object to create a
 	 * fully RAM-based global object.  Uses more memory than the inherit
 	 * model but more compliant.
 	 */
 	h_global = duk_push_object_helper(thr,
-	                                  DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                  DUK_HOBJECT_FLAG_FASTREFS |
-	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_GLOBAL),
+	                                  DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                      DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_GLOBAL),
 	                                  DUK_BIDX_OBJECT_PROTOTYPE);
 	DUK_ASSERT(h_global != NULL);
 	h_oldglobal = thr->builtins[DUK_BIDX_GLOBAL];
 	DUK_ASSERT(h_oldglobal != NULL);
 
 	/* Copy the property table verbatim; this handles attributes etc.
 	 * For ROM objects it's not necessary (or possible) to update
@@ -63537,46 +64753,48 @@
 	DUK_HOBJECT_SET_HSIZE(h_global, DUK_HOBJECT_GET_HSIZE(h_oldglobal));
 #else
 #error internal error in config defines
 #endif
 
 	duk_hobject_compact_props(thr, h_global);
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL] != NULL);
-	DUK_ASSERT(!DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE((duk_heaphdr *) thr->builtins[DUK_BIDX_GLOBAL]));  /* no need to decref: ROM object */
+	DUK_ASSERT(
+	    !DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE((duk_heaphdr *) thr->builtins[DUK_BIDX_GLOBAL])); /* no need to decref: ROM object */
 	thr->builtins[DUK_BIDX_GLOBAL] = h_global;
 	DUK_HOBJECT_INCREF(thr, h_global);
 	DUK_D(DUK_DPRINT("duplicated global object: %!O", h_global));
 
 	/* Create a fresh object environment for the global scope.  This is
 	 * needed so that the global scope points to the newly created RAM-based
 	 * global object.
 	 */
-	h_objenv = (duk_hobject *) duk_hobjenv_alloc(thr,
-	                                             DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                             DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
+	h_objenv =
+	    (duk_hobject *) duk_hobjenv_alloc(thr,
+	                                      DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
 	DUK_ASSERT(h_objenv != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, h_objenv) == NULL);
 	duk_push_hobject(thr, h_objenv);
 
 	DUK_ASSERT(h_global != NULL);
 	((duk_hobjenv *) h_objenv)->target = h_global;
 	DUK_HOBJECT_INCREF(thr, h_global);
 	DUK_ASSERT(((duk_hobjenv *) h_objenv)->has_this == 0);
 
 	DUK_ASSERT(thr->builtins[DUK_BIDX_GLOBAL_ENV] != NULL);
-	DUK_ASSERT(!DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE((duk_heaphdr *) thr->builtins[DUK_BIDX_GLOBAL_ENV]));  /* no need to decref: ROM object */
+	DUK_ASSERT(!DUK_HEAPHDR_NEEDS_REFCOUNT_UPDATE(
+	    (duk_heaphdr *) thr->builtins[DUK_BIDX_GLOBAL_ENV])); /* no need to decref: ROM object */
 	thr->builtins[DUK_BIDX_GLOBAL_ENV] = h_objenv;
 	DUK_HOBJECT_INCREF(thr, h_objenv);
 	DUK_D(DUK_DPRINT("duplicated global env: %!O", h_objenv));
 
 	DUK_HOBJENV_ASSERT_VALID((duk_hobjenv *) h_objenv);
 
-	duk_pop_2(thr);  /* Pop global object and global env. */
+	duk_pop_2(thr); /* Pop global object and global env. */
 }
-#endif  /* DUK_USE_ROM_GLOBAL_CLONE || DUK_USE_ROM_GLOBAL_INHERIT */
+#endif /* DUK_USE_ROM_GLOBAL_CLONE || DUK_USE_ROM_GLOBAL_INHERIT */
 
 DUK_INTERNAL void duk_hthread_create_builtin_objects(duk_hthread *thr) {
 	/* Setup builtins from ROM objects.  All heaps/threads will share
 	 * the same readonly objects.
 	 */
 	duk_small_uint_t i;
 
@@ -63592,20 +64810,20 @@
 	 * more of an issue than having read-only built-in objects (like
 	 * RegExp, Date, etc).  Use a RAM-based copy of the global object
 	 * and the global environment object for convenience.
 	 */
 	duk__duplicate_ram_global_object(thr);
 #endif
 }
-#else  /* DUK_USE_ROM_OBJECTS */
+#else /* DUK_USE_ROM_OBJECTS */
 DUK_LOCAL void duk__push_stridx(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 	duk_small_uint_t n;
 
 	n = (duk_small_uint_t) duk_bd_decode_varuint(bd);
-	DUK_ASSERT_DISABLE(n >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(n >= 0); /* unsigned */
 	DUK_ASSERT(n < DUK_HEAP_NUM_STRINGS);
 	duk_push_hstring_stridx(thr, n);
 }
 DUK_LOCAL void duk__push_string(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 	/* XXX: built-ins data could provide a maximum length that is
 	 * actually needed; bitpacked max length is now 256 bytes.
 	 */
@@ -63634,24 +64852,26 @@
 	for (i = 0; i < 8; i++) {
 		/* Encoding endianness must match target memory layout,
 		 * build scripts and genbuiltins.py must ensure this.
 		 */
 		du.uc[i] = (duk_uint8_t) duk_bd_decode(bd, 8);
 	}
 
-	duk_push_number(thr, du.d);  /* push operation normalizes NaNs */
+	duk_push_number(thr, du.d); /* push operation normalizes NaNs */
 }
 
 DUK_INTERNAL void duk_hthread_create_builtin_objects(duk_hthread *thr) {
 	duk_bitdecoder_ctx bd_ctx;
-	duk_bitdecoder_ctx *bd = &bd_ctx;  /* convenience */
+	duk_bitdecoder_ctx *bd = &bd_ctx; /* convenience */
 	duk_hobject *h;
 	duk_small_uint_t i, j;
 
-	DUK_D(DUK_DPRINT("INITBUILTINS BEGIN: DUK_NUM_BUILTINS=%d, DUK_NUM_BUILTINS_ALL=%d", (int) DUK_NUM_BUILTINS, (int) DUK_NUM_ALL_BUILTINS));
+	DUK_D(DUK_DPRINT("INITBUILTINS BEGIN: DUK_NUM_BUILTINS=%d, DUK_NUM_BUILTINS_ALL=%d",
+	                 (int) DUK_NUM_BUILTINS,
+	                 (int) DUK_NUM_ALL_BUILTINS));
 
 	duk_memzero(&bd_ctx, sizeof(bd_ctx));
 	bd->data = (const duk_uint8_t *) duk_builtins_data;
 	bd->length = (duk_size_t) DUK_BUILTINS_DATA_LENGTH;
 
 	/*
 	 *  First create all built-in bare objects on the empty valstack.
@@ -63670,22 +64890,22 @@
 
 	duk_require_stack(thr, DUK_NUM_ALL_BUILTINS);
 
 	DUK_DD(DUK_DDPRINT("create empty built-ins"));
 	DUK_ASSERT_TOP(thr, 0);
 	for (i = 0; i < DUK_NUM_ALL_BUILTINS; i++) {
 		duk_small_uint_t class_num;
-		duk_small_int_t len = -1;  /* must be signed */
+		duk_small_int_t len = -1; /* must be signed */
 
 		class_num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 		len = (duk_small_int_t) duk_bd_decode_flagged_signed(bd, DUK__LENGTH_PROP_BITS, (duk_int32_t) -1 /*def_value*/);
 
 		if (class_num == DUK_HOBJECT_CLASS_FUNCTION) {
 			duk_small_uint_t natidx;
-			duk_small_int_t c_nargs;  /* must hold DUK_VARARGS */
+			duk_small_int_t c_nargs; /* must hold DUK_VARARGS */
 			duk_c_function c_func;
 			duk_int16_t magic;
 
 			DUK_DDD(DUK_DDDPRINT("len=%ld", (long) len));
 			DUK_ASSERT(len >= 0);
 
 			natidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);
@@ -63708,20 +64928,17 @@
 			 */
 			DUK_ASSERT(DUK_HOBJECT_HAS_STRICT(h));
 
 			/* XXX: function properties */
 
 			duk__push_stridx_or_string(thr, bd);
 #if defined(DUK_USE_FUNC_NAME_PROPERTY)
-			duk_xdef_prop_stridx_short(thr,
-			                           -2,
-			                           DUK_STRIDX_NAME,
-			                           DUK_PROPDESC_FLAGS_C);
+			duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_C);
 #else
-			duk_pop(thr);  /* Not very ideal but good enough for now. */
+			duk_pop(thr); /* Not very ideal but good enough for now. */
 #endif
 
 			/* Almost all global level Function objects are constructable
 			 * but not all: Function.prototype is a non-constructable,
 			 * callable Function.
 			 */
 			if (duk_bd_decode_flag(bd)) {
@@ -63739,34 +64956,31 @@
 			duk_hobjenv *env;
 			duk_hobject *global;
 
 			DUK_ASSERT(i == DUK_BIDX_GLOBAL_ENV);
 			DUK_ASSERT(DUK_BIDX_GLOBAL_ENV > DUK_BIDX_GLOBAL);
 
 			env = duk_hobjenv_alloc(thr,
-	                                        DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
+			                        DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
 			DUK_ASSERT(env->target == NULL);
 			duk_push_hobject(thr, (duk_hobject *) env);
 
 			global = duk_known_hobject(thr, DUK_BIDX_GLOBAL);
 			DUK_ASSERT(global != NULL);
 			env->target = global;
 			DUK_HOBJECT_INCREF(thr, global);
 			DUK_ASSERT(env->has_this == 0);
 
 			DUK_HOBJENV_ASSERT_VALID(env);
 		} else {
 			DUK_ASSERT(class_num != DUK_HOBJECT_CLASS_DECENV);
 
 			(void) duk_push_object_helper(thr,
-			                              DUK_HOBJECT_FLAG_FASTREFS |
-			                              DUK_HOBJECT_FLAG_EXTENSIBLE,
-			                              -1);  /* no prototype or class yet */
-
+			                              DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_EXTENSIBLE,
+			                              -1); /* no prototype or class yet */
 		}
 
 		h = duk_known_hobject(thr, -1);
 		DUK_HOBJECT_SET_CLASS_NUMBER(h, class_num);
 
 		if (i < DUK_NUM_BUILTINS) {
 			thr->builtins[i] = h;
@@ -63780,26 +64994,23 @@
 			 *
 			 * Array.prototype remains an Array instance in ES2015+
 			 * and its length has attributes W (writable only).
 			 * Because .length is now virtual for duk_harray, it is
 			 * not encoded explicitly in init data.
 			 */
 
-			DUK_ASSERT(class_num != DUK_HOBJECT_CLASS_ARRAY);  /* .length is virtual */
+			DUK_ASSERT(class_num != DUK_HOBJECT_CLASS_ARRAY); /* .length is virtual */
 			duk_push_int(thr, len);
-			duk_xdef_prop_stridx_short(thr,
-			                           -2,
-			                           DUK_STRIDX_LENGTH,
-			                           DUK_PROPDESC_FLAGS_C);
+			duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_C);
 		}
 
 		/* enable exotic behaviors last */
 
 		if (class_num == DUK_HOBJECT_CLASS_ARRAY) {
-			DUK_ASSERT(DUK_HOBJECT_HAS_EXOTIC_ARRAY(h));  /* set by duk_push_array() */
+			DUK_ASSERT(DUK_HOBJECT_HAS_EXOTIC_ARRAY(h)); /* set by duk_push_array() */
 		}
 		if (class_num == DUK_HOBJECT_CLASS_STRING) {
 			DUK_HOBJECT_SET_EXOTIC_STRINGOBJ(h);
 		}
 
 		/* some assertions */
 
@@ -63808,15 +65019,15 @@
 		DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(h));
 		DUK_ASSERT(!DUK_HOBJECT_HAS_COMPFUNC(h));
 		/* DUK_HOBJECT_FLAG_NATFUNC varies */
 		DUK_ASSERT(!DUK_HOBJECT_IS_THREAD(h));
 		DUK_ASSERT(!DUK_HOBJECT_IS_PROXY(h));
 		DUK_ASSERT(!DUK_HOBJECT_HAS_ARRAY_PART(h) || class_num == DUK_HOBJECT_CLASS_ARRAY);
 		/* DUK_HOBJECT_FLAG_STRICT varies */
-		DUK_ASSERT(!DUK_HOBJECT_HAS_NATFUNC(h) ||  /* all native functions have NEWENV */
+		DUK_ASSERT(!DUK_HOBJECT_HAS_NATFUNC(h) || /* all native functions have NEWENV */
 		           DUK_HOBJECT_HAS_NEWENV(h));
 		DUK_ASSERT(!DUK_HOBJECT_HAS_NAMEBINDING(h));
 		DUK_ASSERT(!DUK_HOBJECT_HAS_CREATEARGS(h));
 		/* DUK_HOBJECT_FLAG_EXOTIC_ARRAY varies */
 		/* DUK_HOBJECT_FLAG_EXOTIC_STRINGOBJ varies */
 		DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARGUMENTS(h));
 
@@ -63891,31 +65102,33 @@
 			 *  default for 'length' properties.  Variation from the defaults is
 			 *  signaled using a single flag bit in the bitstream.
 			 */
 
 			defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
 			                                                         DUK__PROP_FLAGS_BITS,
 			                                                         (duk_uint32_t) DUK_PROPDESC_FLAGS_WC);
-			defprop_flags |= DUK_DEFPROP_FORCE |
-			                 DUK_DEFPROP_HAVE_VALUE |
-			                 DUK_DEFPROP_HAVE_WRITABLE |
+			defprop_flags |= DUK_DEFPROP_FORCE | DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_HAVE_WRITABLE |
 			                 DUK_DEFPROP_HAVE_ENUMERABLE |
-			                 DUK_DEFPROP_HAVE_CONFIGURABLE;  /* Defaults for data properties. */
+			                 DUK_DEFPROP_HAVE_CONFIGURABLE; /* Defaults for data properties. */
 
 			/* The writable, enumerable, configurable flags in prop_flags
 			 * match both duk_def_prop() and internal property flags.
 			 */
 			DUK_ASSERT(DUK_PROPDESC_FLAG_WRITABLE == DUK_DEFPROP_WRITABLE);
 			DUK_ASSERT(DUK_PROPDESC_FLAG_ENUMERABLE == DUK_DEFPROP_ENUMERABLE);
 			DUK_ASSERT(DUK_PROPDESC_FLAG_CONFIGURABLE == DUK_DEFPROP_CONFIGURABLE);
 
 			t = (duk_small_uint_t) duk_bd_decode(bd, DUK__PROP_TYPE_BITS);
 
 			DUK_DDD(DUK_DDDPRINT("built-in %ld, normal-valued property %ld, key %!T, flags 0x%02lx, type %ld",
-			                     (long) i, (long) j, duk_get_tval(thr, -1), (unsigned long) defprop_flags, (long) t));
+			                     (long) i,
+			                     (long) j,
+			                     duk_get_tval(thr, -1),
+			                     (unsigned long) defprop_flags,
+			                     (long) t));
 
 			switch (t) {
 			case DUK__PROP_TYPE_DOUBLE: {
 				duk__push_double(thr, bd);
 				break;
 			}
 			case DUK__PROP_TYPE_STRING: {
@@ -63948,32 +65161,37 @@
 			case DUK__PROP_TYPE_ACCESSOR: {
 				duk_small_uint_t natidx_getter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 				duk_small_uint_t natidx_setter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 				duk_small_uint_t accessor_magic = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 				duk_c_function c_func_getter;
 				duk_c_function c_func_setter;
 
-				DUK_DDD(DUK_DDDPRINT("built-in accessor property: objidx=%ld, key=%!T, getteridx=%ld, setteridx=%ld, flags=0x%04lx",
-				                     (long) i, duk_get_tval(thr, -1), (long) natidx_getter, (long) natidx_setter, (unsigned long) defprop_flags));
+				DUK_DDD(DUK_DDDPRINT(
+				    "built-in accessor property: objidx=%ld, key=%!T, getteridx=%ld, setteridx=%ld, flags=0x%04lx",
+				    (long) i,
+				    duk_get_tval(thr, -1),
+				    (long) natidx_getter,
+				    (long) natidx_setter,
+				    (unsigned long) defprop_flags));
 
 				c_func_getter = duk_bi_native_functions[natidx_getter];
 				if (c_func_getter != NULL) {
-					duk_push_c_function_builtin_noconstruct(thr, c_func_getter, 0);  /* always 0 args */
+					duk_push_c_function_builtin_noconstruct(thr, c_func_getter, 0); /* always 0 args */
 					duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
 					defprop_flags |= DUK_DEFPROP_HAVE_GETTER;
 				}
 				c_func_setter = duk_bi_native_functions[natidx_setter];
 				if (c_func_setter != NULL) {
-					duk_push_c_function_builtin_noconstruct(thr, c_func_setter, 1);  /* always 1 arg */
+					duk_push_c_function_builtin_noconstruct(thr, c_func_setter, 1); /* always 1 arg */
 					duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
 					defprop_flags |= DUK_DEFPROP_HAVE_SETTER;
 				}
 
 				/* Writable flag doesn't make sense for an accessor. */
-				DUK_ASSERT((defprop_flags & DUK_PROPDESC_FLAG_WRITABLE) == 0);  /* genbuiltins.py ensures */
+				DUK_ASSERT((defprop_flags & DUK_PROPDESC_FLAG_WRITABLE) == 0); /* genbuiltins.py ensures */
 
 				defprop_flags &= ~(DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_HAVE_WRITABLE);
 				defprop_flags |= DUK_DEFPROP_HAVE_ENUMERABLE | DUK_DEFPROP_HAVE_CONFIGURABLE;
 				break;
 			}
 			default: {
 				/* exhaustive */
@@ -63987,15 +65205,15 @@
 
 		/* native function properties */
 		num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 		DUK_DDD(DUK_DDDPRINT("built-in object %ld, %ld function valued properties", (long) i, (long) num));
 		for (j = 0; j < num; j++) {
 			duk_hstring *h_key;
 			duk_small_uint_t natidx;
-			duk_int_t c_nargs;  /* must hold DUK_VARARGS */
+			duk_int_t c_nargs; /* must hold DUK_VARARGS */
 			duk_small_uint_t c_length;
 			duk_int16_t magic;
 			duk_c_function c_func;
 			duk_hnatfunc *h_func;
 #if defined(DUK_USE_LIGHTFUNC_BUILTINS)
 			duk_small_int_t lightfunc_eligible;
 #endif
@@ -64010,73 +65228,86 @@
 			c_nargs = (duk_int_t) duk_bd_decode_flagged(bd, DUK__NARGS_BITS, (duk_uint32_t) c_length /*def_value*/);
 			if (c_nargs == DUK__NARGS_VARARGS_MARKER) {
 				c_nargs = DUK_VARARGS;
 			}
 
 			c_func = duk_bi_native_functions[natidx];
 
-			DUK_DDD(DUK_DDDPRINT("built-in %ld, function-valued property %ld, key %!O, natidx %ld, length %ld, nargs %ld",
-			                     (long) i, (long) j, (duk_heaphdr *) h_key, (long) natidx, (long) c_length,
-			                     (c_nargs == DUK_VARARGS ? (long) -1 : (long) c_nargs)));
+			DUK_DDD(
+			    DUK_DDDPRINT("built-in %ld, function-valued property %ld, key %!O, natidx %ld, length %ld, nargs %ld",
+			                 (long) i,
+			                 (long) j,
+			                 (duk_heaphdr *) h_key,
+			                 (long) natidx,
+			                 (long) c_length,
+			                 (c_nargs == DUK_VARARGS ? (long) -1 : (long) c_nargs)));
 
 			/* Cast converts magic to 16-bit signed value */
 			magic = (duk_int16_t) duk_bd_decode_varuint(bd);
 
 #if defined(DUK_USE_LIGHTFUNC_BUILTINS)
 			lightfunc_eligible =
-				((c_nargs >= DUK_LFUNC_NARGS_MIN && c_nargs <= DUK_LFUNC_NARGS_MAX) || (c_nargs == DUK_VARARGS)) &&
-				(c_length <= DUK_LFUNC_LENGTH_MAX) &&
-				(magic >= DUK_LFUNC_MAGIC_MIN && magic <= DUK_LFUNC_MAGIC_MAX);
+			    ((c_nargs >= DUK_LFUNC_NARGS_MIN && c_nargs <= DUK_LFUNC_NARGS_MAX) || (c_nargs == DUK_VARARGS)) &&
+			    (c_length <= DUK_LFUNC_LENGTH_MAX) && (magic >= DUK_LFUNC_MAGIC_MIN && magic <= DUK_LFUNC_MAGIC_MAX);
 
 			/* These functions have trouble working as lightfuncs.
 			 * Some of them have specific asserts and some may have
-		         * additional properties (e.g. 'require.id' may be written).
+			 * additional properties (e.g. 'require.id' may be written).
 			 */
 			if (c_func == duk_bi_global_object_eval) {
 				lightfunc_eligible = 0;
 			}
 #if defined(DUK_USE_COROUTINE_SUPPORT)
-			if (c_func == duk_bi_thread_yield ||
-			    c_func == duk_bi_thread_resume) {
+			if (c_func == duk_bi_thread_yield || c_func == duk_bi_thread_resume) {
 				lightfunc_eligible = 0;
 			}
 #endif
-			if (c_func == duk_bi_function_prototype_call ||
-			    c_func == duk_bi_function_prototype_apply ||
-			    c_func == duk_bi_reflect_apply ||
-			    c_func == duk_bi_reflect_construct) {
+			if (c_func == duk_bi_function_prototype_call || c_func == duk_bi_function_prototype_apply ||
+			    c_func == duk_bi_reflect_apply || c_func == duk_bi_reflect_construct) {
 				lightfunc_eligible = 0;
 			}
 
 			if (lightfunc_eligible) {
 				duk_tval tv_lfunc;
-				duk_small_uint_t lf_nargs = (duk_small_uint_t) (c_nargs == DUK_VARARGS ? DUK_LFUNC_NARGS_VARARGS : c_nargs);
+				duk_small_uint_t lf_nargs =
+				    (duk_small_uint_t) (c_nargs == DUK_VARARGS ? DUK_LFUNC_NARGS_VARARGS : c_nargs);
 				duk_small_uint_t lf_flags = DUK_LFUNC_FLAGS_PACK(magic, c_length, lf_nargs);
 				DUK_TVAL_SET_LIGHTFUNC(&tv_lfunc, c_func, lf_flags);
 				duk_push_tval(thr, &tv_lfunc);
-				DUK_D(DUK_DPRINT("built-in function eligible as light function: i=%d, j=%d c_length=%ld, c_nargs=%ld, magic=%ld -> %!iT", (int) i, (int) j, (long) c_length, (long) c_nargs, (long) magic, duk_get_tval(thr, -1)));
+				DUK_D(DUK_DPRINT("built-in function eligible as light function: i=%d, j=%d c_length=%ld, "
+				                 "c_nargs=%ld, magic=%ld -> %!iT",
+				                 (int) i,
+				                 (int) j,
+				                 (long) c_length,
+				                 (long) c_nargs,
+				                 (long) magic,
+				                 duk_get_tval(thr, -1)));
 				goto lightfunc_skip;
 			}
 
-			DUK_D(DUK_DPRINT("built-in function NOT ELIGIBLE as light function: i=%d, j=%d c_length=%ld, c_nargs=%ld, magic=%ld", (int) i, (int) j, (long) c_length, (long) c_nargs, (long) magic));
-#endif  /* DUK_USE_LIGHTFUNC_BUILTINS */
+			DUK_D(DUK_DPRINT(
+			    "built-in function NOT ELIGIBLE as light function: i=%d, j=%d c_length=%ld, c_nargs=%ld, magic=%ld",
+			    (int) i,
+			    (int) j,
+			    (long) c_length,
+			    (long) c_nargs,
+			    (long) magic));
+#endif /* DUK_USE_LIGHTFUNC_BUILTINS */
 
 			/* [ (builtin objects) name ] */
 
 			duk_push_c_function_builtin_noconstruct(thr, c_func, c_nargs);
 			h_func = duk_known_hnatfunc(thr, -1);
 			DUK_UNREF(h_func);
 
 			/* XXX: add into init data? */
 
 			/* Special call handling, not described in init data. */
-			if (c_func == duk_bi_global_object_eval ||
-			    c_func == duk_bi_function_prototype_call ||
-			    c_func == duk_bi_function_prototype_apply ||
-			    c_func == duk_bi_reflect_apply ||
+			if (c_func == duk_bi_global_object_eval || c_func == duk_bi_function_prototype_call ||
+			    c_func == duk_bi_function_prototype_apply || c_func == duk_bi_reflect_apply ||
 			    c_func == duk_bi_reflect_construct) {
 				DUK_HOBJECT_SET_SPECIAL_CALL((duk_hobject *) h_func);
 			}
 
 			/* Currently all built-in native functions are strict.
 			 * This doesn't matter for many functions, but e.g.
 			 * String.prototype.charAt (and other string functions)
@@ -64102,35 +65333,34 @@
 
 			duk_dup_m2(thr);
 			duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_C);
 
 			/* XXX: other properties of function instances; 'arguments', 'caller'. */
 
 			DUK_DD(DUK_DDPRINT("built-in object %ld, function property %ld -> %!T",
-			                   (long) i, (long) j, (duk_tval *) duk_get_tval(thr, -1)));
+			                   (long) i,
+			                   (long) j,
+			                   (duk_tval *) duk_get_tval(thr, -1)));
 
 			/* [ (builtin objects) name func ] */
 
 			/*
 			 *  The default property attributes are correct for all
 			 *  function valued properties of built-in objects now.
 			 */
 
 #if defined(DUK_USE_LIGHTFUNC_BUILTINS)
-		 lightfunc_skip:
+		lightfunc_skip:
 #endif
 
 			defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
 			                                                         DUK__PROP_FLAGS_BITS,
 			                                                         (duk_uint32_t) DUK_PROPDESC_FLAGS_WC);
-			defprop_flags |= DUK_DEFPROP_FORCE |
-			                 DUK_DEFPROP_HAVE_VALUE |
-			                 DUK_DEFPROP_HAVE_WRITABLE |
-			                 DUK_DEFPROP_HAVE_ENUMERABLE |
-			                 DUK_DEFPROP_HAVE_CONFIGURABLE;
+			defprop_flags |= DUK_DEFPROP_FORCE | DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_HAVE_WRITABLE |
+			                 DUK_DEFPROP_HAVE_ENUMERABLE | DUK_DEFPROP_HAVE_CONFIGURABLE;
 			DUK_ASSERT(DUK_PROPDESC_FLAG_WRITABLE == DUK_DEFPROP_WRITABLE);
 			DUK_ASSERT(DUK_PROPDESC_FLAG_ENUMERABLE == DUK_DEFPROP_ENUMERABLE);
 			DUK_ASSERT(DUK_PROPDESC_FLAG_CONFIGURABLE == DUK_DEFPROP_CONFIGURABLE);
 
 			duk_def_prop(thr, (duk_idx_t) i, defprop_flags);
 
 			/* [ (builtin objects) ] */
@@ -64160,127 +65390,129 @@
 #endif
 
 	h = duk_known_hobject(thr, DUK_BIDX_DOUBLE_ERROR);
 	DUK_HOBJECT_CLEAR_EXTENSIBLE(h);
 
 #if !defined(DUK_USE_ES6_OBJECT_PROTO_PROPERTY)
 	DUK_DD(DUK_DDPRINT("delete Object.prototype.__proto__ built-in which is not enabled in features"));
-	(void) duk_hobject_delprop_raw(thr, thr->builtins[DUK_BIDX_OBJECT_PROTOTYPE], DUK_HTHREAD_STRING___PROTO__(thr), DUK_DELPROP_FLAG_THROW);
+	(void) duk_hobject_delprop_raw(thr,
+	                               thr->builtins[DUK_BIDX_OBJECT_PROTOTYPE],
+	                               DUK_HTHREAD_STRING___PROTO__(thr),
+	                               DUK_DELPROP_FLAG_THROW);
 #endif
 
 #if !defined(DUK_USE_ES6_OBJECT_SETPROTOTYPEOF)
 	DUK_DD(DUK_DDPRINT("delete Object.setPrototypeOf built-in which is not enabled in features"));
-	(void) duk_hobject_delprop_raw(thr, thr->builtins[DUK_BIDX_OBJECT_CONSTRUCTOR], DUK_HTHREAD_STRING_SET_PROTOTYPE_OF(thr), DUK_DELPROP_FLAG_THROW);
+	(void) duk_hobject_delprop_raw(thr,
+	                               thr->builtins[DUK_BIDX_OBJECT_CONSTRUCTOR],
+	                               DUK_HTHREAD_STRING_SET_PROTOTYPE_OF(thr),
+	                               DUK_DELPROP_FLAG_THROW);
 #endif
 
 	/* XXX: relocate */
 	duk_push_string(thr,
-			/* Endianness indicator */
+	/* Endianness indicator */
 #if defined(DUK_USE_INTEGER_LE)
 	                "l"
 #elif defined(DUK_USE_INTEGER_BE)
 	                "b"
-#elif defined(DUK_USE_INTEGER_ME)  /* integer mixed endian not really used now */
+#elif defined(DUK_USE_INTEGER_ME) /* integer mixed endian not really used now */
 	                "m"
 #else
 	                "?"
 #endif
 #if defined(DUK_USE_DOUBLE_LE)
 	                "l"
 #elif defined(DUK_USE_DOUBLE_BE)
 	                "b"
 #elif defined(DUK_USE_DOUBLE_ME)
 	                "m"
 #else
 	                "?"
 #endif
 	                " "
-			/* Packed or unpacked tval */
+	/* Packed or unpacked tval */
 #if defined(DUK_USE_PACKED_TVAL)
 	                "p"
 #else
 	                "u"
 #endif
 #if defined(DUK_USE_FASTINT)
-			"f"
+	                "f"
 #endif
-			" "
-			/* Low memory/performance options */
+	                " "
+	/* Low memory/performance options */
 #if defined(DUK_USE_STRTAB_PTRCOMP)
-			"s"
+	                "s"
 #endif
 #if !defined(DUK_USE_HEAPPTR16) && !defined(DUK_DATAPTR16) && !defined(DUK_FUNCPTR16)
-			"n"
+	                "n"
 #endif
 #if defined(DUK_USE_HEAPPTR16)
-			"h"
+	                "h"
 #endif
 #if defined(DUK_USE_DATAPTR16)
-			"d"
+	                "d"
 #endif
 #if defined(DUK_USE_FUNCPTR16)
-			"f"
+	                "f"
 #endif
 #if defined(DUK_USE_REFCOUNT16)
-			"R"
+	                "R"
 #endif
 #if defined(DUK_USE_STRHASH16)
-			"H"
+	                "H"
 #endif
 #if defined(DUK_USE_STRLEN16)
-			"S"
+	                "S"
 #endif
 #if defined(DUK_USE_BUFLEN16)
-			"B"
+	                "B"
 #endif
 #if defined(DUK_USE_OBJSIZES16)
-			"O"
+	                "O"
 #endif
 #if defined(DUK_USE_LIGHTFUNC_BUILTINS)
-			"L"
+	                "L"
 #endif
 #if defined(DUK_USE_ROM_STRINGS) || defined(DUK_USE_ROM_OBJECTS)
-			/* XXX: This won't be shown in practice now
-			 * because this code is not run when builtins
-			 * are in ROM.
-			 */
-			"Z"
+	                /* XXX: This won't be shown in practice now
+	                 * because this code is not run when builtins
+	                 * are in ROM.
+	                 */
+	                "Z"
 #endif
 #if defined(DUK_USE_LITCACHE_SIZE)
-			"l"
+	                "l"
 #endif
 	                " "
-			/* Object property allocation layout */
+	/* Object property allocation layout */
 #if defined(DUK_USE_HOBJECT_LAYOUT_1)
-			"p1"
+	                "p1"
 #elif defined(DUK_USE_HOBJECT_LAYOUT_2)
-			"p2"
+	                "p2"
 #elif defined(DUK_USE_HOBJECT_LAYOUT_3)
-			"p3"
+	                "p3"
 #else
-			"p?"
+	                "p?"
 #endif
-			" "
-			/* Alignment guarantee */
+	                " "
+	/* Alignment guarantee */
 #if (DUK_USE_ALIGN_BY == 4)
-			"a4"
+	                "a4"
 #elif (DUK_USE_ALIGN_BY == 8)
-			"a8"
+	                "a8"
 #elif (DUK_USE_ALIGN_BY == 1)
-			"a1"
+	                "a1"
 #else
 #error invalid DUK_USE_ALIGN_BY
 #endif
-			" "
-			/* Architecture, OS, and compiler strings */
-	                DUK_USE_ARCH_STRING
-			" "
-	                DUK_USE_OS_STRING
-			" "
-	                DUK_USE_COMPILER_STRING);
+	                " "
+	                /* Architecture, OS, and compiler strings */
+	                DUK_USE_ARCH_STRING " " DUK_USE_OS_STRING " " DUK_USE_COMPILER_STRING);
 	duk_xdef_prop_stridx_short(thr, DUK_BIDX_DUKTAPE, DUK_STRIDX_ENV, DUK_PROPDESC_FLAGS_WC);
 
 	/*
 	 *  Since built-ins are not often extended, compact them.
 	 */
 
 	DUK_DD(DUK_DDPRINT("compact built-ins"));
@@ -64289,35 +65521,36 @@
 	}
 
 	DUK_D(DUK_DPRINT("INITBUILTINS END"));
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 1)
 	for (i = 0; i < DUK_NUM_ALL_BUILTINS; i++) {
 		DUK_DD(DUK_DDPRINT("built-in object %ld after initialization and compacting: %!@iO",
-		                   (long) i, (duk_heaphdr *) duk_require_hobject(thr, (duk_idx_t) i)));
+		                   (long) i,
+		                   (duk_heaphdr *) duk_require_hobject(thr, (duk_idx_t) i)));
 	}
 #endif
 
 	/*
 	 *  Pop built-ins from stack: they are now INCREF'd and
 	 *  reachable from the builtins[] array or indirectly
 	 *  through builtins[].
 	 */
 
 	duk_set_top(thr, 0);
 	DUK_ASSERT_TOP(thr, 0);
 }
-#endif  /* DUK_USE_ROM_OBJECTS */
+#endif /* DUK_USE_ROM_OBJECTS */
 
 DUK_INTERNAL void duk_hthread_copy_builtin_objects(duk_hthread *thr_from, duk_hthread *thr_to) {
 	duk_small_uint_t i;
 
 	for (i = 0; i < DUK_NUM_BUILTINS; i++) {
 		thr_to->builtins[i] = thr_from->builtins[i];
-		DUK_HOBJECT_INCREF_ALLOWNULL(thr_to, thr_to->builtins[i]);  /* side effect free */
+		DUK_HOBJECT_INCREF_ALLOWNULL(thr_to, thr_to->builtins[i]); /* side effect free */
 	}
 }
 
 /* automatic undefs */
 #undef DUK__LENGTH_PROP_BITS
 #undef DUK__NARGS_BITS
 #undef DUK__NARGS_VARARGS_MARKER
@@ -64342,15 +65575,15 @@
 	DUK_ASSERT(thr != NULL);
 
 	while (thr->callstack_curr != NULL) {
 		duk_hthread_activation_unwind_norz(thr);
 	}
 
 	thr->valstack_bottom = thr->valstack;
-	duk_set_top(thr, 0);  /* unwinds valstack, updating refcounts */
+	duk_set_top(thr, 0); /* unwinds valstack, updating refcounts */
 
 	thr->state = DUK_HTHREAD_STATE_TERMINATED;
 
 	/* Here we could remove references to built-ins, but it may not be
 	 * worth the effort because built-ins are quite likely to be shared
 	 * with another (unterminated) thread, and terminated threads are also
 	 * usually garbage collected quite quickly.
@@ -64373,15 +65606,15 @@
 	/* XXX: store 'bcode' pointer to activation for faster lookup? */
 	if (act->func && DUK_HOBJECT_IS_COMPFUNC(act->func)) {
 		bcode = DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, (duk_hcompfunc *) (act->func));
 		return (duk_uint_fast32_t) (act->curr_pc - bcode);
 	}
 	return 0;
 }
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 DUK_INTERNAL duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act) {
 	duk_instr_t *bcode;
 	duk_uint_fast32_t ret;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(act != NULL);
@@ -64443,26 +65676,26 @@
  * both exist) without side effects.
  */
 DUK_INTERNAL void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act) {
 	duk_catcher *cat;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(act != NULL);
-	DUK_ASSERT(act->cat != NULL);  /* caller must check */
+	DUK_ASSERT(act->cat != NULL); /* caller must check */
 	cat = act->cat;
 	DUK_ASSERT(cat != NULL);
 
 	DUK_DDD(DUK_DDDPRINT("unwinding catch stack entry %p (lexenv check is done)", (void *) cat));
 
 	if (DUK_CAT_HAS_LEXENV_ACTIVE(cat)) {
 		duk_hobject *env;
 
-		env = act->lex_env;             /* current lex_env of the activation (created for catcher) */
-		DUK_ASSERT(env != NULL);        /* must be, since env was created when catcher was created */
-		act->lex_env = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, env);  /* prototype is lex_env before catcher created */
+		env = act->lex_env; /* current lex_env of the activation (created for catcher) */
+		DUK_ASSERT(env != NULL); /* must be, since env was created when catcher was created */
+		act->lex_env = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, env); /* prototype is lex_env before catcher created */
 		DUK_HOBJECT_INCREF(thr, act->lex_env);
 		DUK_HOBJECT_DECREF_NORZ(thr, env);
 
 		/* There is no need to decref anything else than 'env': if 'env'
 		 * becomes unreachable, refzero will handle decref'ing its prototype.
 		 */
 	}
@@ -64473,15 +65706,15 @@
 
 /* Same as above, but caller is certain no catcher-related lexenv may exist. */
 DUK_INTERNAL void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act) {
 	duk_catcher *cat;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(act != NULL);
-	DUK_ASSERT(act->cat != NULL);  /* caller must check */
+	DUK_ASSERT(act->cat != NULL); /* caller must check */
 	cat = act->cat;
 	DUK_ASSERT(cat != NULL);
 
 	DUK_DDD(DUK_DDDPRINT("unwinding catch stack entry %p (lexenv check is not done)", (void *) cat));
 
 	DUK_ASSERT(!DUK_CAT_HAS_LEXENV_ACTIVE(cat));
 
@@ -64511,19 +65744,19 @@
 	if (DUK_LIKELY(cat != NULL)) {
 		thr->heap->catcher_free = cat->parent;
 		return cat;
 	}
 
 	return duk__hthread_catcher_alloc_slow(thr);
 }
-#else  /* DUK_USE_CACHE_CATCHER */
+#else /* DUK_USE_CACHE_CATCHER */
 DUK_INTERNAL duk_catcher *duk_hthread_catcher_alloc(duk_hthread *thr) {
 	return duk__hthread_catcher_alloc_slow(thr);
 }
-#endif  /* DUK_USE_CACHE_CATCHER */
+#endif /* DUK_USE_CACHE_CATCHER */
 
 DUK_INTERNAL void duk_hthread_catcher_free(duk_hthread *thr, duk_catcher *cat) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(cat != NULL);
 
 #if defined(DUK_USE_CACHE_CATCHER)
 	/* Unconditional caching for now; freed in mark-and-sweep. */
@@ -64556,20 +65789,19 @@
 	if (DUK_LIKELY(act != NULL)) {
 		thr->heap->activation_free = act->parent;
 		return act;
 	}
 
 	return duk__hthread_activation_alloc_slow(thr);
 }
-#else  /* DUK_USE_CACHE_ACTIVATION */
+#else /* DUK_USE_CACHE_ACTIVATION */
 DUK_INTERNAL duk_activation *duk_hthread_activation_alloc(duk_hthread *thr) {
 	return duk__hthread_activation_alloc_slow(thr);
 }
-#endif  /* DUK_USE_CACHE_ACTIVATION */
-
+#endif /* DUK_USE_CACHE_ACTIVATION */
 
 DUK_INTERNAL void duk_hthread_activation_free(duk_hthread *thr, duk_activation *act) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(act != NULL);
 
 #if defined(DUK_USE_CACHE_ACTIVATION)
 	/* Unconditional caching for now; freed in mark-and-sweep. */
@@ -64588,15 +65820,15 @@
 	duk_heap *heap;
 #endif
 	duk_activation *act;
 	duk_hobject *func;
 	duk_hobject *tmp;
 
 	DUK_ASSERT(thr != NULL);
-	DUK_ASSERT(thr->callstack_curr != NULL);  /* caller must check */
+	DUK_ASSERT(thr->callstack_curr != NULL); /* caller must check */
 	DUK_ASSERT(thr->callstack_top > 0);
 	act = thr->callstack_curr;
 	DUK_ASSERT(act != NULL);
 	/* With lightfuncs, act 'func' may be NULL. */
 
 	/* With duk_activation records allocated separately, 'act' is a stable
 	 * pointer and not affected by side effects.
@@ -64625,15 +65857,15 @@
 			if (act->prev_caller) {
 				/* Just transfer the refcount from act->prev_caller to tv_caller,
 				 * so no need for a refcount update.  This is the expected case.
 				 */
 				DUK_TVAL_SET_OBJECT(tv_caller, act->prev_caller);
 				act->prev_caller = NULL;
 			} else {
-				DUK_TVAL_SET_NULL(tv_caller);   /* no incref needed */
+				DUK_TVAL_SET_NULL(tv_caller); /* no incref needed */
 				DUK_ASSERT(act->prev_caller == NULL);
 			}
 			DUK_TVAL_DECREF_NORZ(thr, &tv_tmp);
 		} else {
 			h_tmp = act->prev_caller;
 			if (h_tmp) {
 				act->prev_caller = NULL;
@@ -64654,15 +65886,15 @@
 	heap = thr->heap;
 	if (heap->dbg_pause_act == thr->callstack_curr) {
 		if (heap->dbg_pause_flags & DUK_PAUSE_FLAG_FUNC_EXIT) {
 			DUK_D(DUK_DPRINT("PAUSE TRIGGERED by function exit"));
 			duk_debug_set_paused(heap);
 		} else {
 			DUK_D(DUK_DPRINT("unwound past dbg_pause_act, set to NULL"));
-			heap->dbg_pause_act = NULL;  /* avoid stale pointers */
+			heap->dbg_pause_act = NULL; /* avoid stale pointers */
 		}
 		DUK_ASSERT(heap->dbg_pause_act == NULL);
 	}
 #endif
 
 	/*
 	 *  Unwind catchers.
@@ -64703,20 +65935,19 @@
 	/* XXX: Closing the environment record copies values from registers
 	 * into the scope object.  It's side effect free as such, but may
 	 * currently run out of memory which causes an error throw.  This is
 	 * an actual sandboxing problem for error unwinds, and needs to be
 	 * fixed e.g. by preallocating the scope property slots.
 	 */
 	if (act->var_env != NULL) {
-		DUK_DDD(DUK_DDDPRINT("closing var_env record %p -> %!O",
-		                     (void *) act->var_env, (duk_heaphdr *) act->var_env));
+		DUK_DDD(DUK_DDDPRINT("closing var_env record %p -> %!O", (void *) act->var_env, (duk_heaphdr *) act->var_env));
 		duk_js_close_environment_record(thr, act->var_env);
 	}
 
- skip_env_close:
+skip_env_close:
 
 	/*
 	 *  Update preventcount
 	 */
 
 	if (act->flags & DUK_ACT_FLAG_PREVENT_YIELD) {
 		DUK_ASSERT(thr->callstack_preventcount >= 1);
@@ -64832,15 +66063,15 @@
 		thr->valstack_end = (duk_tval *) ((duk_uint8_t *) new_ptr + end_off);
 		thr->valstack_bottom = (duk_tval *) ((duk_uint8_t *) new_ptr + bottom_off);
 		thr->valstack_top = (duk_tval *) ((duk_uint8_t *) new_ptr + top_off);
 	} else {
 		DUK_D(DUK_DPRINT("failed to realloc valstack for torture, ignore"));
 	}
 }
-#endif  /* DUK_USE_FINALIZER_TORTURE */
+#endif /* DUK_USE_FINALIZER_TORTURE */
 #line 1 "duk_js_arith.c"
 /*
  *  Shared helpers for arithmetic operations
  */
 
 /* #include duk_internal.h -> already included */
 
@@ -64877,18 +66108,22 @@
 	DUK_ASSERT(duk_double_equals(DUK_FMOD(-1.0, -DUK_DOUBLE_INFINITY), -1.0));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(DUK_DOUBLE_INFINITY, DUK_DOUBLE_INFINITY)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(DUK_DOUBLE_INFINITY, -DUK_DOUBLE_INFINITY)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(-DUK_DOUBLE_INFINITY, DUK_DOUBLE_INFINITY)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(-DUK_DOUBLE_INFINITY, -DUK_DOUBLE_INFINITY)));
 	DUK_ASSERT(duk_double_equals(DUK_FMOD(0.0, 1.0), 0.0) && DUK_SIGNBIT(DUK_FMOD(0.0, 1.0)) == 0);
 	DUK_ASSERT(duk_double_equals(DUK_FMOD(-0.0, 1.0), 0.0) && DUK_SIGNBIT(DUK_FMOD(-0.0, 1.0)) != 0);
-	DUK_ASSERT(duk_double_equals(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY), 0.0) && DUK_SIGNBIT(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY)) == 0);
-	DUK_ASSERT(duk_double_equals(DUK_FMOD(-0.0, DUK_DOUBLE_INFINITY), 0.0) && DUK_SIGNBIT(DUK_FMOD(-0.0, DUK_DOUBLE_INFINITY)) != 0);
-	DUK_ASSERT(duk_double_equals(DUK_FMOD(0.0, -DUK_DOUBLE_INFINITY), 0.0) && DUK_SIGNBIT(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY)) == 0);
-	DUK_ASSERT(duk_double_equals(DUK_FMOD(-0.0, -DUK_DOUBLE_INFINITY), 0.0) && DUK_SIGNBIT(DUK_FMOD(-0.0, -DUK_DOUBLE_INFINITY)) != 0);
+	DUK_ASSERT(duk_double_equals(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY), 0.0) &&
+	           DUK_SIGNBIT(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY)) == 0);
+	DUK_ASSERT(duk_double_equals(DUK_FMOD(-0.0, DUK_DOUBLE_INFINITY), 0.0) &&
+	           DUK_SIGNBIT(DUK_FMOD(-0.0, DUK_DOUBLE_INFINITY)) != 0);
+	DUK_ASSERT(duk_double_equals(DUK_FMOD(0.0, -DUK_DOUBLE_INFINITY), 0.0) &&
+	           DUK_SIGNBIT(DUK_FMOD(0.0, DUK_DOUBLE_INFINITY)) == 0);
+	DUK_ASSERT(duk_double_equals(DUK_FMOD(-0.0, -DUK_DOUBLE_INFINITY), 0.0) &&
+	           DUK_SIGNBIT(DUK_FMOD(-0.0, -DUK_DOUBLE_INFINITY)) != 0);
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(0.0, 0.0)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(-0.0, 0.0)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(0.0, -0.0)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(-0.0, -0.0)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(0.0, DUK_DOUBLE_NAN)));
 	DUK_ASSERT(DUK_ISNAN(DUK_FMOD(-0.0, DUK_DOUBLE_NAN)));
 #endif
@@ -64968,15 +66203,15 @@
 	DUK_ASSERT(DUK_ISINF(DUK_POW(0.0, -1.0)) && DUK_SIGNBIT(DUK_POW(0.0, -1.0)) == 0);
 	DUK_ASSERT(DUK_ISINF(DUK_POW(-0.0, -2.0)) && DUK_SIGNBIT(DUK_POW(-0.0, -2.0)) == 0);
 	DUK_ASSERT(DUK_ISINF(DUK_POW(-0.0, -3.0)) && DUK_SIGNBIT(DUK_POW(-0.0, -3.0)) != 0);
 #endif
 
 	return DUK_POW(x, y);
 
- ret_nan:
+ret_nan:
 	return DUK_DOUBLE_NAN;
 }
 #line 1 "duk_js_call.c"
 /*
  *  Call handling.
  *
  *  duk_handle_call_unprotected():
@@ -65025,18 +66260,18 @@
 }
 
 /* Allow headroom for calls during error augmentation (see GH-191).
  * We allow space for 10 additional recursions, with one extra
  * for, e.g. a print() call at the deepest level, and an extra
  * +1 for protected call wrapping.
  */
-#define DUK__AUGMENT_CALL_RELAX_COUNT  (10 + 2)
+#define DUK__AUGMENT_CALL_RELAX_COUNT (10 + 2)
 
 /* Stack space required by call handling entry. */
-#define DUK__CALL_HANDLING_REQUIRE_STACK  8
+#define DUK__CALL_HANDLING_REQUIRE_STACK 8
 
 DUK_LOCAL DUK_NOINLINE void duk__call_c_recursion_limit_check_slowpath(duk_hthread *thr) {
 	/* When augmenting an error, the effective limit is a bit higher.
 	 * Check for it only if the fast path check fails.
 	 */
 #if defined(DUK_USE_AUGMENT_ERROR_THROW) || defined(DUK_USE_AUGMENT_ERROR_CREATE)
 	if (thr->heap->augmenting_error) {
@@ -65122,15 +66357,16 @@
 
 #if defined(DUK_USE_INTERRUPT_DEBUG_FIXUP)
 	if (entry_curr_thread == NULL) {
 		thr->interrupt_init = thr->interrupt_init - thr->interrupt_counter;
 		thr->heap->inst_count_interrupt += thr->interrupt_init;
 		DUK_DD(DUK_DDPRINT("debug test: updated interrupt count on exit to "
 		                   "user code, instruction counts: executor=%ld, interrupt=%ld",
-		                   (long) thr->heap->inst_count_exec, (long) thr->heap->inst_count_interrupt));
+		                   (long) thr->heap->inst_count_exec,
+		                   (long) thr->heap->inst_count_interrupt));
 		DUK_ASSERT(thr->heap->inst_count_exec == thr->heap->inst_count_interrupt);
 	}
 #else
 	DUK_UNREF(thr);
 	DUK_UNREF(entry_curr_thread);
 #endif
 }
@@ -65141,20 +66377,17 @@
  *
  *  Creating arguments objects involves many small details, see E5 Section
  *  10.6 for the specific requirements.  Much of the arguments object exotic
  *  behavior is implemented in duk_hobject_props.c, and is enabled by the
  *  object flag DUK_HOBJECT_FLAG_EXOTIC_ARGUMENTS.
  */
 
-DUK_LOCAL void duk__create_arguments_object(duk_hthread *thr,
-                                            duk_hobject *func,
-                                            duk_hobject *varenv,
-                                            duk_idx_t idx_args) {
-	duk_hobject *arg;          /* 'arguments' */
-	duk_hobject *formals;      /* formals for 'func' (may be NULL if func is a C function) */
+DUK_LOCAL void duk__create_arguments_object(duk_hthread *thr, duk_hobject *func, duk_hobject *varenv, duk_idx_t idx_args) {
+	duk_hobject *arg; /* 'arguments' */
+	duk_hobject *formals; /* formals for 'func' (may be NULL if func is a C function) */
 	duk_idx_t i_arg;
 	duk_idx_t i_map;
 	duk_idx_t i_mappednames;
 	duk_idx_t i_formals;
 	duk_idx_t i_argbase;
 	duk_idx_t n_formals;
 	duk_idx_t idx;
@@ -65192,60 +66425,58 @@
 		duk_push_undefined(thr);
 	}
 	i_formals = duk_require_top_index(thr);
 
 	DUK_ASSERT(n_formals >= 0);
 	DUK_ASSERT(formals != NULL || n_formals == 0);
 
-	DUK_DDD(DUK_DDDPRINT("func=%!O, formals=%!O, n_formals=%ld",
-	                     (duk_heaphdr *) func, (duk_heaphdr *) formals,
-	                     (long) n_formals));
+	DUK_DDD(
+	    DUK_DDDPRINT("func=%!O, formals=%!O, n_formals=%ld", (duk_heaphdr *) func, (duk_heaphdr *) formals, (long) n_formals));
 
 	/* [ ... formals ] */
 
 	/*
 	 *  Create required objects:
 	 *    - 'arguments' object: array-like, but not an array
 	 *    - 'map' object: internal object, tied to 'arguments' (bare)
 	 *    - 'mappedNames' object: temporary value used during construction (bare)
 	 */
 
 	arg = duk_push_object_helper(thr,
-	                             DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                             DUK_HOBJECT_FLAG_FASTREFS |
-	                             DUK_HOBJECT_FLAG_ARRAY_PART |
-	                             DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARGUMENTS),
+	                             DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS | DUK_HOBJECT_FLAG_ARRAY_PART |
+	                                 DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_ARGUMENTS),
 	                             DUK_BIDX_OBJECT_PROTOTYPE);
 	DUK_ASSERT(arg != NULL);
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
-	                              -1);  /* no prototype */
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                              -1); /* no prototype */
 	(void) duk_push_object_helper(thr,
-	                              DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                              DUK_HOBJECT_FLAG_FASTREFS |
-	                              DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
-	                              -1);  /* no prototype */
+	                              DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_FLAG_FASTREFS |
+	                                  DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJECT),
+	                              -1); /* no prototype */
 	i_arg = duk_get_top(thr) - 3;
 	i_map = i_arg + 1;
 	i_mappednames = i_arg + 2;
-	DUK_ASSERT(!duk_is_bare_object(thr, -3));  /* arguments */
-	DUK_ASSERT(duk_is_bare_object(thr, -2));  /* map */
-	DUK_ASSERT(duk_is_bare_object(thr, -1));  /* mappedNames */
+	DUK_ASSERT(!duk_is_bare_object(thr, -3)); /* arguments */
+	DUK_ASSERT(duk_is_bare_object(thr, -2)); /* map */
+	DUK_ASSERT(duk_is_bare_object(thr, -1)); /* mappedNames */
 
 	/* [ ... formals arguments map mappedNames ] */
 
 	DUK_DDD(DUK_DDDPRINT("created arguments related objects: "
 	                     "arguments at index %ld -> %!O "
 	                     "map at index %ld -> %!O "
 	                     "mappednames at index %ld -> %!O",
-	                     (long) i_arg, (duk_heaphdr *) duk_get_hobject(thr, i_arg),
-	                     (long) i_map, (duk_heaphdr *) duk_get_hobject(thr, i_map),
-	                     (long) i_mappednames, (duk_heaphdr *) duk_get_hobject(thr, i_mappednames)));
+	                     (long) i_arg,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_arg),
+	                     (long) i_map,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_map),
+	                     (long) i_mappednames,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_mappednames)));
 
 	/*
 	 *  Init arguments properties, map, etc.
 	 */
 
 	duk_push_int(thr, num_stack_args);
 	duk_xdef_prop_stridx(thr, i_arg, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_WC);
@@ -65253,61 +66484,57 @@
 	/*
 	 *  Init argument related properties.
 	 */
 
 	/* step 11 */
 	idx = num_stack_args - 1;
 	while (idx >= 0) {
-		DUK_DDD(DUK_DDDPRINT("arg idx %ld, argbase=%ld, argidx=%ld",
-		                     (long) idx, (long) i_argbase, (long) (i_argbase + idx)));
+		DUK_DDD(
+		    DUK_DDDPRINT("arg idx %ld, argbase=%ld, argidx=%ld", (long) idx, (long) i_argbase, (long) (i_argbase + idx)));
 
 		DUK_DDD(DUK_DDDPRINT("define arguments[%ld]=arg", (long) idx));
 		duk_dup(thr, i_argbase + idx);
 		duk_xdef_prop_index_wec(thr, i_arg, (duk_uarridx_t) idx);
 		DUK_DDD(DUK_DDDPRINT("defined arguments[%ld]=arg", (long) idx));
 
 		/* step 11.c is relevant only if non-strict (checked in 11.c.ii) */
 		if (!DUK_HOBJECT_HAS_STRICT(func) && idx < n_formals) {
 			DUK_ASSERT(formals != NULL);
 
-			DUK_DDD(DUK_DDDPRINT("strict function, index within formals (%ld < %ld)",
-			                     (long) idx, (long) n_formals));
+			DUK_DDD(DUK_DDDPRINT("strict function, index within formals (%ld < %ld)", (long) idx, (long) n_formals));
 
 			duk_get_prop_index(thr, i_formals, (duk_uarridx_t) idx);
 			DUK_ASSERT(duk_is_string(thr, -1));
 
-			duk_dup_top(thr);  /* [ ... name name ] */
+			duk_dup_top(thr); /* [ ... name name ] */
 
 			if (!duk_has_prop(thr, i_mappednames)) {
 				/* steps 11.c.ii.1 - 11.c.ii.4, but our internal book-keeping
 				 * differs from the reference model
 				 */
 
 				/* [ ... name ] */
 
 				need_map = 1;
 
-				DUK_DDD(DUK_DDDPRINT("set mappednames[%s]=%ld",
-				                     (const char *) duk_get_string(thr, -1),
-				                     (long) idx));
-				duk_dup_top(thr);                      /* name */
-				(void) duk_push_uint_to_hstring(thr, (duk_uint_t) idx);  /* index */
-				duk_xdef_prop_wec(thr, i_mappednames);  /* out of spec, must be configurable */
-
-				DUK_DDD(DUK_DDDPRINT("set map[%ld]=%s",
-				                     (long) idx,
-				                     duk_get_string(thr, -1)));
-				duk_dup_top(thr);         /* name */
-				duk_xdef_prop_index_wec(thr, i_map, (duk_uarridx_t) idx);  /* out of spec, must be configurable */
+				DUK_DDD(
+				    DUK_DDDPRINT("set mappednames[%s]=%ld", (const char *) duk_get_string(thr, -1), (long) idx));
+				duk_dup_top(thr); /* name */
+				(void) duk_push_uint_to_hstring(thr, (duk_uint_t) idx); /* index */
+				duk_xdef_prop_wec(thr, i_mappednames); /* out of spec, must be configurable */
+
+				DUK_DDD(DUK_DDDPRINT("set map[%ld]=%s", (long) idx, duk_get_string(thr, -1)));
+				duk_dup_top(thr); /* name */
+				duk_xdef_prop_index_wec(thr, i_map, (duk_uarridx_t) idx); /* out of spec, must be configurable */
 			} else {
 				/* duk_has_prop() popped the second 'name' */
 			}
 
 			/* [ ... name ] */
-			duk_pop(thr);  /* pop 'name' */
+			duk_pop(thr); /* pop 'name' */
 		}
 
 		idx--;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("actual arguments processed"));
 
@@ -65315,27 +66542,27 @@
 	if (need_map) {
 		DUK_DDD(DUK_DDDPRINT("adding 'map' and 'varenv' to arguments object"));
 
 		/* should never happen for a strict callee */
 		DUK_ASSERT(!DUK_HOBJECT_HAS_STRICT(func));
 
 		duk_dup(thr, i_map);
-		duk_xdef_prop_stridx(thr, i_arg, DUK_STRIDX_INT_MAP, DUK_PROPDESC_FLAGS_NONE);  /* out of spec, don't care */
+		duk_xdef_prop_stridx(thr, i_arg, DUK_STRIDX_INT_MAP, DUK_PROPDESC_FLAGS_NONE); /* out of spec, don't care */
 
 		/* The variable environment for magic variable bindings needs to be
 		 * given by the caller and recorded in the arguments object.
 		 *
 		 * See E5 Section 10.6, the creation of setters/getters.
 		 *
 		 * The variable environment also provides access to the callee, so
 		 * an explicit (internal) callee property is not needed.
 		 */
 
 		duk_push_hobject(thr, varenv);
-		duk_xdef_prop_stridx(thr, i_arg, DUK_STRIDX_INT_VARENV, DUK_PROPDESC_FLAGS_NONE);  /* out of spec, don't care */
+		duk_xdef_prop_stridx(thr, i_arg, DUK_STRIDX_INT_VARENV, DUK_PROPDESC_FLAGS_NONE); /* out of spec, don't care */
 	}
 
 	/* steps 13-14 */
 	if (DUK_HOBJECT_HAS_STRICT(func)) {
 		/* Callee/caller are throwers and are not deletable etc.  They
 		 * could be implemented as virtual properties, but currently
 		 * there is no support for virtual properties which are accessors
@@ -65380,54 +66607,51 @@
 		DUK_DDD(DUK_DDDPRINT("not enabling exotic behavior for arguments object"));
 	}
 
 	DUK_DDD(DUK_DDDPRINT("final arguments related objects: "
 	                     "arguments at index %ld -> %!O "
 	                     "map at index %ld -> %!O "
 	                     "mappednames at index %ld -> %!O",
-	                     (long) i_arg, (duk_heaphdr *) duk_get_hobject(thr, i_arg),
-	                     (long) i_map, (duk_heaphdr *) duk_get_hobject(thr, i_map),
-	                     (long) i_mappednames, (duk_heaphdr *) duk_get_hobject(thr, i_mappednames)));
+	                     (long) i_arg,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_arg),
+	                     (long) i_map,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_map),
+	                     (long) i_mappednames,
+	                     (duk_heaphdr *) duk_get_hobject(thr, i_mappednames)));
 
 	/* [ args(n) envobj formals arguments map mappednames ] */
 
 	duk_pop_2(thr);
 	duk_remove_m2(thr);
 
 	/* [ args(n) envobj arguments ] */
 }
 
 /* Helper for creating the arguments object and adding it to the env record
  * on top of the value stack.
  */
-DUK_LOCAL void duk__handle_createargs_for_call(duk_hthread *thr,
-                                               duk_hobject *func,
-                                               duk_hobject *env,
-                                               duk_idx_t idx_args) {
+DUK_LOCAL void duk__handle_createargs_for_call(duk_hthread *thr, duk_hobject *func, duk_hobject *env, duk_idx_t idx_args) {
 	DUK_DDD(DUK_DDDPRINT("creating arguments object for function call"));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(func != NULL);
 	DUK_ASSERT(env != NULL);
 	DUK_ASSERT(DUK_HOBJECT_HAS_CREATEARGS(func));
 
 	/* [ ... arg1 ... argN envobj ] */
 
-	duk__create_arguments_object(thr,
-	                             func,
-	                             env,
-	                             idx_args);
+	duk__create_arguments_object(thr, func, env, idx_args);
 
 	/* [ ... arg1 ... argN envobj argobj ] */
 
 	duk_xdef_prop_stridx_short(thr,
 	                           -2,
 	                           DUK_STRIDX_LC_ARGUMENTS,
-	                           DUK_HOBJECT_HAS_STRICT(func) ? DUK_PROPDESC_FLAGS_E :   /* strict: non-deletable, non-writable */
-	                                                          DUK_PROPDESC_FLAGS_WE);  /* non-strict: non-deletable, writable */
+	                           DUK_HOBJECT_HAS_STRICT(func) ? DUK_PROPDESC_FLAGS_E : /* strict: non-deletable, non-writable */
+                                                                  DUK_PROPDESC_FLAGS_WE); /* non-strict: non-deletable, writable */
 	/* [ ... arg1 ... argN envobj ] */
 }
 
 /*
  *  Helpers for constructor call handling.
  *
  *  There are two [[Construct]] operations in the specification:
@@ -65469,15 +66693,16 @@
 	duk_get_prop_stridx_short(thr, idx_func, DUK_STRIDX_PROTOTYPE);
 	proto = duk_get_hobject(thr, -1);
 	if (proto == NULL) {
 		DUK_DDD(DUK_DDDPRINT("constructor has no 'prototype' property, or value not an object "
 		                     "-> leave standard Object prototype as fallback prototype"));
 	} else {
 		DUK_DDD(DUK_DDDPRINT("constructor has 'prototype' property with object value "
-		                     "-> set fallback prototype to that value: %!iO", (duk_heaphdr *) proto));
+		                     "-> set fallback prototype to that value: %!iO",
+		                     (duk_heaphdr *) proto));
 		/* Original fallback (default instance) is untouched when
 		 * resolving bound functions etc.
 		 */
 		fallback = duk_known_hobject(thr, idx_func + 1);
 		DUK_ASSERT(fallback != NULL);
 		DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, fallback, proto);
 	}
@@ -65491,17 +66716,15 @@
 	 * the default instance is read from the current (immutable)
 	 * 'this' binding.
 	 *
 	 * For Proxy 'construct' calls the return value must be an
 	 * Object (we accept object-like values like buffers and
 	 * lightfuncs too).  If not, TypeError.
 	 */
-	if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT |
-	                                 DUK_TYPE_MASK_BUFFER |
-	                                 DUK_TYPE_MASK_LIGHTFUNC)) {
+	if (duk_check_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_BUFFER | DUK_TYPE_MASK_LIGHTFUNC)) {
 		DUK_DDD(DUK_DDDPRINT("replacement value"));
 	} else {
 		if (DUK_UNLIKELY(proxy_invariant != 0U)) {
 			/* Proxy 'construct' return value invariant violated. */
 			DUK_ERROR_TYPE_INVALID_TRAP_RESULT(thr);
 			DUK_WO_NORETURN(return;);
 		}
@@ -65515,16 +66738,15 @@
 	 * rethrown.  __FILE__ and __LINE__ are not desirable here; the call
 	 * stack reflects the caller which is correct.  Skip topmost, unwound
 	 * activation when creating a traceback.  If thr->ptr_curr_pc was !=
 	 * NULL we'd need to sync the current PC so that the traceback comes
 	 * out right; however it is always synced here so just assert for it.
 	 */
 	DUK_ASSERT(thr->ptr_curr_pc == NULL);
-	duk_err_augment_error_create(thr, thr, NULL, 0, DUK_AUGMENT_FLAG_NOBLAME_FILELINE |
-	                                                DUK_AUGMENT_FLAG_SKIP_ONE);
+	duk_err_augment_error_create(thr, thr, NULL, 0, DUK_AUGMENT_FLAG_NOBLAME_FILELINE | DUK_AUGMENT_FLAG_SKIP_ONE);
 #endif
 }
 
 /*
  *  Helper for handling a bound function when a call is being made.
  *
  *  Assumes that bound function chains have been "collapsed" so that either
@@ -65533,17 +66755,15 @@
  *
  *  Prepends the bound arguments to the value stack (at idx_func + 2).
  *  The 'this' binding is also updated if necessary (at idx_func + 1).
  *  Note that for constructor calls the 'this' binding is never updated by
  *  [[BoundThis]].
  */
 
-DUK_LOCAL void duk__handle_bound_chain_for_call(duk_hthread *thr,
-                                                duk_idx_t idx_func,
-                                                duk_bool_t is_constructor_call) {
+DUK_LOCAL void duk__handle_bound_chain_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_bool_t is_constructor_call) {
 	duk_tval *tv_func;
 	duk_hobject *func;
 	duk_idx_t len;
 
 	DUK_ASSERT(thr != NULL);
 
 	/* On entry, item at idx_func is a bound, non-lightweight function,
@@ -65566,41 +66786,43 @@
 
 			h_bound = (duk_hboundfunc *) (void *) func;
 			tv_args = h_bound->args;
 			len = h_bound->nargs;
 			DUK_ASSERT(len == 0 || tv_args != NULL);
 
 			DUK_DDD(DUK_DDDPRINT("bound function encountered, ptr=%p: %!T",
-			                     (void *) DUK_TVAL_GET_OBJECT(tv_func), tv_func));
+			                     (void *) DUK_TVAL_GET_OBJECT(tv_func),
+			                     tv_func));
 
 			/* [ ... func this arg1 ... argN ] */
 
 			if (is_constructor_call) {
 				/* See: tests/ecmascript/test-spec-bound-constructor.js */
 				DUK_DDD(DUK_DDDPRINT("constructor call: don't update this binding"));
 			} else {
 				/* XXX: duk_replace_tval */
 				duk_push_tval(thr, &h_bound->this_binding);
-				duk_replace(thr, idx_func + 1);  /* idx_this = idx_func + 1 */
+				duk_replace(thr, idx_func + 1); /* idx_this = idx_func + 1 */
 			}
 
 			/* [ ... func this arg1 ... argN ] */
 
 			duk_require_stack(thr, len);
 
 			tv_gap = duk_reserve_gap(thr, idx_func + 2, len);
 			duk_copy_tvals_incref(thr, tv_gap, tv_args, (duk_size_t) len);
 
 			/* [ ... func this <bound args> arg1 ... argN ] */
 
 			duk_push_tval(thr, &h_bound->target);
-			duk_replace(thr, idx_func);  /* replace in stack */
+			duk_replace(thr, idx_func); /* replace in stack */
 
 			DUK_DDD(DUK_DDDPRINT("bound function handled, idx_func=%ld, curr func=%!T",
-			                     (long) idx_func, duk_get_tval(thr, idx_func)));
+			                     (long) idx_func,
+			                     duk_get_tval(thr, idx_func)));
 		}
 	} else if (DUK_TVAL_IS_LIGHTFUNC(tv_func)) {
 		/* Lightweight function: never bound, so terminate. */
 		;
 	} else {
 		/* Shouldn't happen, so ugly error is enough. */
 		DUK_ERROR_INTERNAL(thr);
@@ -65614,33 +66836,35 @@
 #if defined(DUK_USE_ASSERTIONS)
 	tv_func = duk_require_tval(thr, idx_func);
 	DUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv_func) || DUK_TVAL_IS_OBJECT(tv_func));
 	if (DUK_TVAL_IS_OBJECT(tv_func)) {
 		func = DUK_TVAL_GET_OBJECT(tv_func);
 		DUK_ASSERT(func != NULL);
 		DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func));
-		DUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func) ||
-		           DUK_HOBJECT_HAS_NATFUNC(func) ||
-		           DUK_HOBJECT_IS_PROXY(func));
+		DUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func) || DUK_HOBJECT_HAS_NATFUNC(func) || DUK_HOBJECT_IS_PROXY(func));
 	}
 #endif
 }
 
 /*
  *  Helper for inline handling of .call(), .apply(), and .construct().
  */
 
-DUK_LOCAL duk_bool_t duk__handle_specialfuncs_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_hobject *func, duk_small_uint_t *call_flags, duk_bool_t first) {
+DUK_LOCAL duk_bool_t duk__handle_specialfuncs_for_call(duk_hthread *thr,
+                                                       duk_idx_t idx_func,
+                                                       duk_hobject *func,
+                                                       duk_small_uint_t *call_flags,
+                                                       duk_bool_t first) {
 #if defined(DUK_USE_ASSERTIONS)
 	duk_c_function natfunc;
 #endif
 	duk_tval *tv_args;
 
 	DUK_ASSERT(func != NULL);
-	DUK_ASSERT((*call_flags & DUK_CALL_FLAG_CONSTRUCT) == 0);  /* Caller. */
+	DUK_ASSERT((*call_flags & DUK_CALL_FLAG_CONSTRUCT) == 0); /* Caller. */
 
 #if defined(DUK_USE_ASSERTIONS)
 	natfunc = ((duk_hnatfunc *) func)->func;
 	DUK_ASSERT(natfunc != NULL);
 #endif
 
 	/* On every round of function resolution at least target function and
@@ -65660,25 +66884,25 @@
 		 * detection.
 		 */
 		DUK_ASSERT(((duk_hnatfunc *) func)->func == duk_bi_global_object_eval);
 		if (first && (*call_flags & DUK_CALL_FLAG_CALLED_AS_EVAL)) {
 			*call_flags = (*call_flags & ~DUK_CALL_FLAG_CALLED_AS_EVAL) | DUK_CALL_FLAG_DIRECT_EVAL;
 		}
 		DUK_ASSERT(duk_get_top(thr) >= idx_func + 2);
-		return 1;  /* stop resolving */
+		return 1; /* stop resolving */
 	}
 
 	/* Handle special functions based on the DUK_HOBJECT_FLAG_SPECIAL_CALL
 	 * flag; their magic value is used for switch-case.
 	 *
 	 * NOTE: duk_unpack_array_like() reserves value stack space
 	 * for the result values (unlike most other value stack calls).
 	 */
 	switch (((duk_hnatfunc *) func)->magic) {
-	case 0: {  /* 0=Function.prototype.call() */
+	case 0: { /* 0=Function.prototype.call() */
 		/* Value stack:
 		 * idx_func + 0: Function.prototype.call()  [removed]
 		 * idx_func + 1: this binding for .call (target function)
 		 * idx_func + 2: 1st argument to .call, desired 'this' binding
 		 * idx_func + 3: 2nd argument to .call, desired 1st argument for ultimate target
 		 * ...
 		 *
@@ -65689,19 +66913,19 @@
 		 * ...
 		 */
 		DUK_ASSERT(natfunc == duk_bi_function_prototype_call);
 		duk_remove_unsafe(thr, idx_func);
 		tv_args = thr->valstack_bottom + idx_func + 2;
 		if (thr->valstack_top < tv_args) {
 			DUK_ASSERT(tv_args <= thr->valstack_end);
-			thr->valstack_top = tv_args;  /* at least target function and 'this' binding present */
+			thr->valstack_top = tv_args; /* at least target function and 'this' binding present */
 		}
 		break;
 	}
-	case 1: {  /* 1=Function.prototype.apply() */
+	case 1: { /* 1=Function.prototype.apply() */
 		/* Value stack:
 		 * idx_func + 0: Function.prototype.apply()  [removed]
 		 * idx_func + 1: this binding for .apply (target function)
 		 * idx_func + 2: 1st argument to .apply, desired 'this' binding
 		 * idx_func + 3: 2nd argument to .apply, argArray
 		 * [anything after this MUST be ignored]
 		 *
@@ -65712,15 +66936,15 @@
 		 * ...
 		 */
 		DUK_ASSERT(natfunc == duk_bi_function_prototype_apply);
 		duk_remove_unsafe(thr, idx_func);
 		goto apply_shared;
 	}
 #if defined(DUK_USE_REFLECT_BUILTIN)
-	case 2: {  /* 2=Reflect.apply() */
+	case 2: { /* 2=Reflect.apply() */
 		/* Value stack:
 		 * idx_func + 0: Reflect.apply()  [removed]
 		 * idx_func + 1: this binding for .apply (ignored, usually Reflect)  [removed]
 		 * idx_func + 2: 1st argument to .apply, target function
 		 * idx_func + 3: 2nd argument to .apply, desired 'this' binding
 		 * idx_func + 4: 3rd argument to .apply, argArray
 		 * [anything after this MUST be ignored]
@@ -65731,15 +66955,15 @@
 		 * idx_func + 2: call arguments
 		 * ...
 		 */
 		DUK_ASSERT(natfunc == duk_bi_reflect_apply);
 		duk_remove_n_unsafe(thr, idx_func, 2);
 		goto apply_shared;
 	}
-	case 3: {  /* 3=Reflect.construct() */
+	case 3: { /* 3=Reflect.construct() */
 		/* Value stack:
 		 * idx_func + 0: Reflect.construct()  [removed]
 		 * idx_func + 1: this binding for .construct (ignored, usually Reflect)  [removed]
 		 * idx_func + 2: 1st argument to .construct, target function
 		 * idx_func + 3: 2nd argument to .construct, argArray
 		 * idx_func + 4: 3rd argument to .construct, newTarget
 		 * [anything after this MUST be ignored]
@@ -65765,19 +66989,19 @@
 		duk_remove_n_unsafe(thr, idx_func, 2);
 		top = duk_get_top(thr);
 		if (!duk_is_constructable(thr, idx_func)) {
 			/* Target constructability must be checked before
 			 * unpacking argArray (which may cause side effects).
 			 * Just return; caller will throw the error.
 			 */
-			duk_set_top_unsafe(thr, idx_func + 2);  /* satisfy asserts */
+			duk_set_top_unsafe(thr, idx_func + 2); /* satisfy asserts */
 			break;
 		}
 		duk_push_object(thr);
-		duk_insert(thr, idx_func + 1);  /* default instance */
+		duk_insert(thr, idx_func + 1); /* default instance */
 
 		/* [ ... func default_instance argArray newTarget? ] */
 
 		top = duk_get_top(thr);
 		if (top < idx_func + 3) {
 			/* argArray is a mandatory argument for Reflect.construct(). */
 			DUK_ERROR_TYPE_INVALID_ARGS(thr);
@@ -65785,56 +67009,57 @@
 		}
 		if (top > idx_func + 3) {
 			if (!duk_strict_equals(thr, idx_func, idx_func + 3)) {
 				/* XXX: [[Construct]] newTarget currently unsupported */
 				DUK_ERROR_UNSUPPORTED(thr);
 				DUK_WO_NORETURN(return 0;);
 			}
-			duk_set_top_unsafe(thr, idx_func + 3);  /* remove any args beyond argArray */
+			duk_set_top_unsafe(thr, idx_func + 3); /* remove any args beyond argArray */
 		}
 		DUK_ASSERT(duk_get_top(thr) == idx_func + 3);
 		DUK_ASSERT(duk_is_valid_index(thr, idx_func + 2));
-		(void) duk_unpack_array_like(thr, idx_func + 2);  /* XXX: should also remove target to be symmetric with duk_pack()? */
+		(void) duk_unpack_array_like(thr,
+		                             idx_func + 2); /* XXX: should also remove target to be symmetric with duk_pack()? */
 		duk_remove(thr, idx_func + 2);
 		DUK_ASSERT(duk_get_top(thr) >= idx_func + 2);
 		break;
 	}
-#endif  /* DUK_USE_REFLECT_BUILTIN */
+#endif /* DUK_USE_REFLECT_BUILTIN */
 	default: {
 		DUK_ASSERT(0);
 		DUK_UNREACHABLE();
 	}
 	}
 
 	DUK_ASSERT(duk_get_top(thr) >= idx_func + 2);
-	return 0;  /* keep resolving */
+	return 0; /* keep resolving */
 
- apply_shared:
+apply_shared:
 	tv_args = thr->valstack_bottom + idx_func + 2;
 	if (thr->valstack_top <= tv_args) {
 		DUK_ASSERT(tv_args <= thr->valstack_end);
-		thr->valstack_top = tv_args;  /* at least target func and 'this' binding present */
+		thr->valstack_top = tv_args; /* at least target func and 'this' binding present */
 		/* No need to check for argArray. */
 	} else {
-		DUK_ASSERT(duk_get_top(thr) >= idx_func + 3);  /* idx_func + 2 covered above */
+		DUK_ASSERT(duk_get_top(thr) >= idx_func + 3); /* idx_func + 2 covered above */
 		if (thr->valstack_top > tv_args + 1) {
-			duk_set_top_unsafe(thr, idx_func + 3);  /* remove any args beyond argArray */
+			duk_set_top_unsafe(thr, idx_func + 3); /* remove any args beyond argArray */
 		}
 		DUK_ASSERT(duk_is_valid_index(thr, idx_func + 2));
 		if (!duk_is_callable(thr, idx_func)) {
 			/* Avoid unpack side effects if the target isn't callable.
 			 * Calling code will throw the actual error.
 			 */
 		} else {
 			(void) duk_unpack_array_like(thr, idx_func + 2);
 			duk_remove(thr, idx_func + 2);
 		}
 	}
 	DUK_ASSERT(duk_get_top(thr) >= idx_func + 2);
-	return 0;  /* keep resolving */
+	return 0; /* keep resolving */
 }
 
 /*
  *  Helper for Proxy handling.
  */
 
 #if defined(DUK_USE_ES6_PROXY)
@@ -65924,39 +67149,37 @@
 	 * idx_func + 3: Proxy's target
 	 * idx_func + 4: this binding for call
 	 * idx_func + 5: arguments array
 	 */
 	DUK_ASSERT(duk_get_top(thr) == idx_func + 6);
 
 	if (*call_flags & DUK_CALL_FLAG_CONSTRUCT) {
-		*call_flags |= DUK_CALL_FLAG_CONSTRUCT_PROXY;  /* Enable 'construct' trap return invariant check. */
-		*call_flags &= ~(DUK_CALL_FLAG_CONSTRUCT);     /* Resume as non-constructor call to the trap. */
+		*call_flags |= DUK_CALL_FLAG_CONSTRUCT_PROXY; /* Enable 'construct' trap return invariant check. */
+		*call_flags &= ~(DUK_CALL_FLAG_CONSTRUCT); /* Resume as non-constructor call to the trap. */
 
 		/* 'apply' args: target, thisArg, argArray
 		 * 'construct' args: target, argArray, newTarget
 		 */
 		duk_remove(thr, idx_func + 4);
 		duk_push_hobject(thr, (duk_hobject *) h_proxy);
 	}
 
 	/* Finalize value stack layout by removing Proxy reference. */
 	duk_remove(thr, idx_func);
-	h_proxy = NULL;  /* invalidated */
+	h_proxy = NULL; /* invalidated */
 	DUK_ASSERT(duk_get_top(thr) == idx_func + 5);
 }
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 
 /*
  *  Helper for setting up var_env and lex_env of an activation,
  *  assuming it does NOT have the DUK_HOBJECT_FLAG_NEWENV flag.
  */
 
-DUK_LOCAL void duk__handle_oldenv_for_call(duk_hthread *thr,
-                                           duk_hobject *func,
-                                           duk_activation *act) {
+DUK_LOCAL void duk__handle_oldenv_for_call(duk_hthread *thr, duk_hobject *func, duk_activation *act) {
 	duk_hcompfunc *f;
 	duk_hobject *h_lex;
 	duk_hobject *h_var;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(func != NULL);
 	DUK_ASSERT(act != NULL);
@@ -65964,15 +67187,15 @@
 	DUK_ASSERT(!DUK_HOBJECT_HAS_CREATEARGS(func));
 	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(func));
 	DUK_UNREF(thr);
 
 	f = (duk_hcompfunc *) func;
 	h_lex = DUK_HCOMPFUNC_GET_LEXENV(thr->heap, f);
 	h_var = DUK_HCOMPFUNC_GET_VARENV(thr->heap, f);
-	DUK_ASSERT(h_lex != NULL);  /* Always true for closures (not for templates) */
+	DUK_ASSERT(h_lex != NULL); /* Always true for closures (not for templates) */
 	DUK_ASSERT(h_var != NULL);
 	act->lex_env = h_lex;
 	act->var_env = h_var;
 	DUK_HOBJECT_INCREF(thr, h_lex);
 	DUK_HOBJECT_INCREF(thr, h_var);
 }
 
@@ -65985,15 +67208,15 @@
 	duk_tval *tv_caller;
 	duk_hobject *h_tmp;
 	duk_activation *act_callee;
 	duk_activation *act_caller;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(func != NULL);
-	DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func));  /* bound chain resolved */
+	DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func)); /* bound chain resolved */
 	DUK_ASSERT(thr->callstack_top >= 1);
 
 	if (DUK_HOBJECT_HAS_STRICT(func)) {
 		/* Strict functions don't get their 'caller' updated. */
 		return;
 	}
 
@@ -66039,33 +67262,33 @@
 			 */
 
 			if (act_caller != NULL) {
 				DUK_ASSERT(act_caller->func != NULL);
 				DUK_TVAL_SET_OBJECT(tv_caller, act_caller->func);
 				DUK_TVAL_INCREF(thr, tv_caller);
 			} else {
-				DUK_TVAL_SET_NULL(tv_caller);  /* no incref */
+				DUK_TVAL_SET_NULL(tv_caller); /* no incref */
 			}
 		} else {
 			/* 'caller' must only take on 'null' or function value */
 			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv_caller));
 			DUK_ASSERT(act_callee->prev_caller == NULL);
 			if (act_caller != NULL && act_caller->func) {
 				/* Tolerate act_caller->func == NULL which happens in
 				 * some finalization cases; treat like unknown caller.
 				 */
 				DUK_TVAL_SET_OBJECT(tv_caller, act_caller->func);
 				DUK_TVAL_INCREF(thr, tv_caller);
 			} else {
-				DUK_TVAL_SET_NULL(tv_caller);  /* no incref */
+				DUK_TVAL_SET_NULL(tv_caller); /* no incref */
 			}
 		}
 	}
 }
-#endif  /* DUK_USE_NONSTD_FUNC_CALLER_PROPERTY */
+#endif /* DUK_USE_NONSTD_FUNC_CALLER_PROPERTY */
 
 /*
  *  Shared helpers for resolving the final, non-bound target function of the
  *  call and the effective 'this' binding.  Resolves bound functions and
  *  applies .call(), .apply(), and .construct() inline.
  *
  *  Proxy traps are also handled inline so that if the target is a Proxy with
@@ -66103,61 +67326,62 @@
 		break;
 	case DUK_TAG_UNDEFINED:
 	case DUK_TAG_NULL:
 		DUK_DDD(DUK_DDDPRINT("this binding: non-strict, undefined/null -> use global object"));
 		obj_global = thr->builtins[DUK_BIDX_GLOBAL];
 		/* XXX: avoid this check somehow */
 		if (DUK_LIKELY(obj_global != NULL)) {
-			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv_this));  /* no need to decref previous value */
+			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv_this)); /* no need to decref previous value */
 			DUK_TVAL_SET_OBJECT(tv_this, obj_global);
 			DUK_HOBJECT_INCREF(thr, obj_global);
 		} else {
 			/* This may only happen if built-ins are being "torn down".
 			 * This behavior is out of specification scope.
 			 */
 			DUK_D(DUK_DPRINT("this binding: wanted to use global object, but it is NULL -> using undefined instead"));
-			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv_this));  /* no need to decref previous value */
-			DUK_TVAL_SET_UNDEFINED(tv_this);  /* nothing to incref */
+			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv_this)); /* no need to decref previous value */
+			DUK_TVAL_SET_UNDEFINED(tv_this); /* nothing to incref */
 		}
 		break;
 	default:
 		/* Plain buffers and lightfuncs are object coerced.  Lightfuncs
 		 * very rarely come here however, because the call target would
 		 * need to be a non-strict non-lightfunc (lightfuncs are considered
 		 * strict) with an explicit lightfunc 'this' binding.
 		 */
 		DUK_ASSERT(!DUK_TVAL_IS_UNUSED(tv_this));
 		DUK_DDD(DUK_DDDPRINT("this binding: non-strict, not object/undefined/null -> use ToObject(value)"));
-		duk_to_object(thr, idx_this);  /* may have side effects */
+		duk_to_object(thr, idx_this); /* may have side effects */
 		break;
 	}
 }
 
-DUK_LOCAL DUK_ALWAYS_INLINE duk_bool_t duk__resolve_target_fastpath_check(duk_hthread *thr, duk_idx_t idx_func, duk_hobject **out_func, duk_small_uint_t call_flags) {
+DUK_LOCAL DUK_ALWAYS_INLINE duk_bool_t duk__resolve_target_fastpath_check(duk_hthread *thr,
+                                                                          duk_idx_t idx_func,
+                                                                          duk_hobject **out_func,
+                                                                          duk_small_uint_t call_flags) {
 #if defined(DUK_USE_PREFER_SIZE)
 	DUK_UNREF(thr);
 	DUK_UNREF(idx_func);
 	DUK_UNREF(out_func);
 	DUK_UNREF(call_flags);
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	duk_tval *tv_func;
 	duk_hobject *func;
 
 	if (DUK_UNLIKELY(call_flags & DUK_CALL_FLAG_CONSTRUCT)) {
 		return 0;
 	}
 
 	tv_func = DUK_GET_TVAL_POSIDX(thr, idx_func);
 	DUK_ASSERT(tv_func != NULL);
 
 	if (DUK_LIKELY(DUK_TVAL_IS_OBJECT(tv_func))) {
 		func = DUK_TVAL_GET_OBJECT(tv_func);
-		if (DUK_HOBJECT_IS_CALLABLE(func) &&
-		    !DUK_HOBJECT_HAS_BOUNDFUNC(func) &&
-		    !DUK_HOBJECT_HAS_SPECIAL_CALL(func)) {
+		if (DUK_HOBJECT_IS_CALLABLE(func) && !DUK_HOBJECT_HAS_BOUNDFUNC(func) && !DUK_HOBJECT_HAS_SPECIAL_CALL(func)) {
 			*out_func = func;
 
 			if (DUK_HOBJECT_HAS_STRICT(func)) {
 				/* Strict function: no 'this' coercion. */
 				return 1;
 			}
 
@@ -66169,16 +67393,16 @@
 
 		/* Lightfuncs are considered strict, so 'this' binding is
 		 * used as is.  They're never bound, always constructable,
 		 * and never special functions.
 		 */
 		return 1;
 	}
-#endif  /* DUK_USE_PREFER_SIZE */
-	return 0;  /* let slow path deal with it */
+#endif /* DUK_USE_PREFER_SIZE */
+	return 0; /* let slow path deal with it */
 }
 
 DUK_LOCAL duk_hobject *duk__resolve_target_func_and_this_binding(duk_hthread *thr,
                                                                  duk_idx_t idx_func,
                                                                  duk_small_uint_t *call_flags) {
 	duk_tval *tv_func;
 	duk_hobject *func;
@@ -66203,16 +67427,15 @@
 				}
 			} else {
 				if (DUK_UNLIKELY(!DUK_HOBJECT_IS_CALLABLE(func))) {
 					goto not_callable;
 				}
 			}
 
-			if (DUK_LIKELY(!DUK_HOBJECT_HAS_BOUNDFUNC(func) &&
-			               !DUK_HOBJECT_HAS_SPECIAL_CALL(func) &&
+			if (DUK_LIKELY(!DUK_HOBJECT_HAS_BOUNDFUNC(func) && !DUK_HOBJECT_HAS_SPECIAL_CALL(func) &&
 			               !DUK_HOBJECT_HAS_EXOTIC_PROXYOBJ(func))) {
 				/* Common case, so test for using a single bitfield test.
 				 * Break out to handle this coercion etc.
 				 */
 				break;
 			}
 
@@ -66240,16 +67463,15 @@
 					 * If trap exists, helper converts call into a trap
 					 * call; this may change a constructor call into a
 					 * normal (non-constructor) trap call.  We must
 					 * continue processing even when a trap is found as
 					 * the trap may be bound.
 					 */
 					duk__handle_proxy_for_call(thr, idx_func, (duk_hproxy *) func, call_flags);
-				}
-				else
+				} else
 #endif
 				{
 					DUK_ASSERT(DUK_HOBJECT_IS_NATFUNC(func));
 					DUK_ASSERT(DUK_HOBJECT_HAS_CALLABLE(func));
 					DUK_ASSERT(!DUK_HOBJECT_HAS_CONSTRUCTABLE(func));
 					/* Constructable check already done above. */
 
@@ -66288,48 +67510,46 @@
 	if (*call_flags & DUK_CALL_FLAG_CONSTRUCT) {
 		if (!(*call_flags & DUK_CALL_FLAG_DEFAULT_INSTANCE_UPDATED)) {
 			*call_flags |= DUK_CALL_FLAG_DEFAULT_INSTANCE_UPDATED;
 			duk__update_default_instance_proto(thr, idx_func);
 		}
 	}
 
- finished:
-
+finished :
 #if defined(DUK_USE_ASSERTIONS)
-	{
-		duk_tval *tv_tmp;
+{
+	duk_tval *tv_tmp;
 
-		tv_tmp = duk_get_tval(thr, idx_func);
-		DUK_ASSERT(tv_tmp != NULL);
+	tv_tmp = duk_get_tval(thr, idx_func);
+	DUK_ASSERT(tv_tmp != NULL);
 
-		DUK_ASSERT((DUK_TVAL_IS_OBJECT(tv_tmp) && DUK_HOBJECT_IS_CALLABLE(DUK_TVAL_GET_OBJECT(tv_tmp))) ||
-		           DUK_TVAL_IS_LIGHTFUNC(tv_tmp));
-		DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));
-		DUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) ||
-		                            DUK_HOBJECT_IS_NATFUNC(func)));
-		DUK_ASSERT(func == NULL || (DUK_HOBJECT_HAS_CONSTRUCTABLE(func) ||
-		                            (*call_flags & DUK_CALL_FLAG_CONSTRUCT) == 0));
-	}
+	DUK_ASSERT((DUK_TVAL_IS_OBJECT(tv_tmp) && DUK_HOBJECT_IS_CALLABLE(DUK_TVAL_GET_OBJECT(tv_tmp))) ||
+	           DUK_TVAL_IS_LIGHTFUNC(tv_tmp));
+	DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));
+	DUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) || DUK_HOBJECT_IS_NATFUNC(func)));
+	DUK_ASSERT(func == NULL || (DUK_HOBJECT_HAS_CONSTRUCTABLE(func) || (*call_flags & DUK_CALL_FLAG_CONSTRUCT) == 0));
+}
 #endif
 
 	return func;
 
- not_callable:
+not_callable:
 	DUK_ASSERT(tv_func != NULL);
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
 	/* GETPROPC delayed error handling: when target is not callable,
 	 * GETPROPC replaces idx_func+0 with a non-callable wrapper object
 	 * with a hidden Symbol to signify it's to be handled here.  If
 	 * found, unwrap the original Error and throw it as is here.  The
 	 * hidden Symbol is only checked as an own property, not inherited
 	 * (which would be dangerous).
 	 */
 	if (DUK_TVAL_IS_OBJECT(tv_func)) {
-		duk_tval *tv_wrap = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, DUK_TVAL_GET_OBJECT(tv_func), DUK_STRIDX_INT_TARGET);
+		duk_tval *tv_wrap =
+		    duk_hobject_find_entry_tval_ptr_stridx(thr->heap, DUK_TVAL_GET_OBJECT(tv_func), DUK_STRIDX_INT_TARGET);
 		if (tv_wrap != NULL) {
 			DUK_DD(DUK_DDPRINT("delayed error from GETPROPC: %!T", tv_wrap));
 			duk_push_tval(thr, tv_wrap);
 			(void) duk_throw(thr);
 			DUK_WO_NORETURN(return NULL;);
 		}
 	}
@@ -66342,15 +67562,15 @@
 	DUK_ERROR_FMT1(thr, DUK_ERR_TYPE_ERROR, "%s not callable", duk_push_string_tval_readable(thr, tv_func));
 #endif
 #else
 	DUK_ERROR_TYPE(thr, DUK_STR_NOT_CALLABLE);
 #endif
 	DUK_WO_NORETURN(return NULL;);
 
- not_constructable:
+not_constructable:
 	/* For now GETPROPC delayed error not needed for constructor calls. */
 #if defined(DUK_USE_VERBOSE_ERRORS)
 #if defined(DUK_USE_PARANOID_ERRORS)
 	DUK_ERROR_FMT1(thr, DUK_ERR_TYPE_ERROR, "%s not constructable", duk_get_type_name(thr, idx_func));
 #else
 	DUK_ERROR_FMT1(thr, DUK_ERR_TYPE_ERROR, "%s not constructable", duk_push_string_tval_readable(thr, tv_func));
 #endif
@@ -66366,66 +67586,76 @@
  *  'rc' return values on top of stack.
  *
  *  This is a bit tricky, because the called C function operates in
  *  the same activation record and may have e.g. popped the stack
  *  empty (below idx_retbase).
  */
 
-DUK_LOCAL void duk__safe_call_adjust_valstack(duk_hthread *thr, duk_idx_t idx_retbase, duk_idx_t num_stack_rets, duk_idx_t num_actual_rets) {
+DUK_LOCAL void duk__safe_call_adjust_valstack(duk_hthread *thr,
+                                              duk_idx_t idx_retbase,
+                                              duk_idx_t num_stack_rets,
+                                              duk_idx_t num_actual_rets) {
 	duk_idx_t idx_rcbase;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(idx_retbase >= 0);
 	DUK_ASSERT(num_stack_rets >= 0);
 	DUK_ASSERT(num_actual_rets >= 0);
 
-	idx_rcbase = duk_get_top(thr) - num_actual_rets;  /* base of known return values */
+	idx_rcbase = duk_get_top(thr) - num_actual_rets; /* base of known return values */
 	if (DUK_UNLIKELY(idx_rcbase < 0)) {
 		DUK_ERROR_TYPE(thr, DUK_STR_INVALID_CFUNC_RC);
 		DUK_WO_NORETURN(return;);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("adjust valstack after func call: "
 	                     "num_stack_rets=%ld, num_actual_rets=%ld, stack_top=%ld, idx_retbase=%ld, idx_rcbase=%ld",
-	                     (long) num_stack_rets, (long) num_actual_rets, (long) duk_get_top(thr),
-	                     (long) idx_retbase, (long) idx_rcbase));
+	                     (long) num_stack_rets,
+	                     (long) num_actual_rets,
+	                     (long) duk_get_top(thr),
+	                     (long) idx_retbase,
+	                     (long) idx_rcbase));
 
-	DUK_ASSERT(idx_rcbase >= 0);  /* caller must check */
+	DUK_ASSERT(idx_rcbase >= 0); /* caller must check */
 
 	/* Space for num_stack_rets was reserved before the safe call.
 	 * Because value stack reserve cannot shrink except in call returns,
 	 * the reserve is still in place.  Adjust valstack, carefully
 	 * ensuring we don't overstep the reserve.
 	 */
 
 	/* Match idx_rcbase with idx_retbase so that the return values
 	 * start at the correct index.
 	 */
 	if (idx_rcbase > idx_retbase) {
 		duk_idx_t count = idx_rcbase - idx_retbase;
 
 		DUK_DDD(DUK_DDDPRINT("elements at/after idx_retbase have enough to cover func retvals "
-		                     "(idx_retbase=%ld, idx_rcbase=%ld)", (long) idx_retbase, (long) idx_rcbase));
+		                     "(idx_retbase=%ld, idx_rcbase=%ld)",
+		                     (long) idx_retbase,
+		                     (long) idx_rcbase));
 
 		/* Remove values between irc_rcbase (start of intended return
 		 * values) and idx_retbase to lower return values to idx_retbase.
 		 */
 		DUK_ASSERT(count > 0);
-		duk_remove_n(thr, idx_retbase, count);  /* may be NORZ */
+		duk_remove_n(thr, idx_retbase, count); /* may be NORZ */
 	} else {
 		duk_idx_t count = idx_retbase - idx_rcbase;
 
 		DUK_DDD(DUK_DDDPRINT("not enough elements at/after idx_retbase to cover func retvals "
-		                     "(idx_retbase=%ld, idx_rcbase=%ld)", (long) idx_retbase, (long) idx_rcbase));
+		                     "(idx_retbase=%ld, idx_rcbase=%ld)",
+		                     (long) idx_retbase,
+		                     (long) idx_rcbase));
 
 		/* Insert 'undefined' at idx_rcbase (start of intended return
 		 * values) to lift return values to idx_retbase.
 		 */
 		DUK_ASSERT(count >= 0);
-		DUK_ASSERT(thr->valstack_end - thr->valstack_top >= count);  /* reserve cannot shrink */
+		DUK_ASSERT(thr->valstack_end - thr->valstack_top >= count); /* reserve cannot shrink */
 		duk_insert_undefined_n(thr, idx_rcbase, count);
 	}
 
 	/* Chop extra retvals away / extend with undefined. */
 	duk_set_top_unsafe(thr, idx_retbase + num_stack_rets);
 }
 
@@ -66478,20 +67708,20 @@
 	 *   2. Constructor call, return value replacement object check.
 	 *   3. Proxy 'construct' trap call, return value invariant check.
 	 */
 	flags1 = (duk_small_uint_t) ((act->flags & DUK_ACT_FLAG_CONSTRUCT) ? 1 : 0)
 #if defined(DUK_USE_ES6_PROXY)
 	         | (duk_small_uint_t) ((act->flags & DUK_ACT_FLAG_CONSTRUCT_PROXY) ? 2 : 0)
 #endif
-	         ;
+	    ;
 	flags2 = (duk_small_uint_t) ((call_flags & DUK_CALL_FLAG_CONSTRUCT) ? 1 : 0)
 #if defined(DUK_USE_ES6_PROXY)
 	         | (duk_small_uint_t) ((call_flags & DUK_CALL_FLAG_CONSTRUCT_PROXY) ? 2 : 0);
 #endif
-	         ;
+	;
 	if (flags1 != flags2) {
 		DUK_DDD(DUK_DDDPRINT("tail call prevented by incompatible return value handling"));
 		return 0;
 	}
 	DUK_ASSERT(((act->flags & DUK_ACT_FLAG_CONSTRUCT) && (call_flags & DUK_CALL_FLAG_CONSTRUCT)) ||
 	           (!(act->flags & DUK_ACT_FLAG_CONSTRUCT) && !(call_flags & DUK_CALL_FLAG_CONSTRUCT)));
 	DUK_ASSERT(((act->flags & DUK_ACT_FLAG_CONSTRUCT_PROXY) && (call_flags & DUK_CALL_FLAG_CONSTRUCT_PROXY)) ||
@@ -66521,16 +67751,15 @@
 	 *      https://github.com/svaarala/duktape/issues/1726,
 	 *      https://github.com/svaarala/duktape/issues/1786.
 	 *    - Check for function entry (e.g. StepInto) pause flag here, because
 	 *      the executor pause check won't trigger due to shared activation, see:
 	 *      https://github.com/svaarala/duktape/issues/1726.
 	 */
 
-	DUK_DDD(DUK_DDDPRINT("is tail call, reusing activation at callstack top, at index %ld",
-                             (long) (thr->callstack_top - 1)));
+	DUK_DDD(DUK_DDDPRINT("is tail call, reusing activation at callstack top, at index %ld", (long) (thr->callstack_top - 1)));
 
 	DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func));
 	DUK_ASSERT(!DUK_HOBJECT_HAS_NATFUNC(func));
 	DUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func));
 	DUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);
 	DUK_ASSERT(call_flags & DUK_CALL_FLAG_ALLOW_ECMATOECMA);
 
@@ -66566,24 +67795,24 @@
 
 	/* Then reuse the unwound activation. */
 	act->cat = NULL;
 	act->var_env = NULL;
 	act->lex_env = NULL;
 	DUK_ASSERT(func != NULL);
 	DUK_ASSERT(DUK_HOBJECT_HAS_COMPFUNC(func));
-	act->func = func;  /* don't want an intermediate exposed state with func == NULL */
+	act->func = func; /* don't want an intermediate exposed state with func == NULL */
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 	act->prev_caller = NULL;
 #endif
 	/* don't want an intermediate exposed state with invalid pc */
 	act->curr_pc = DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, (duk_hcompfunc *) func);
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	act->prev_line = 0;
 #endif
-	DUK_TVAL_SET_OBJECT(&act->tv_func, func);  /* borrowed, no refcount */
+	DUK_TVAL_SET_OBJECT(&act->tv_func, func); /* borrowed, no refcount */
 	DUK_HOBJECT_INCREF(thr, func);
 
 	act->flags = DUK_ACT_FLAG_TAILCALLED;
 	if (DUK_HOBJECT_HAS_STRICT(func)) {
 		act->flags |= DUK_ACT_FLAG_STRICT;
 	}
 	if (call_flags & DUK_CALL_FLAG_CONSTRUCT) {
@@ -66591,18 +67820,18 @@
 	}
 #if defined(DUK_USE_ES6_PROXY)
 	if (call_flags & DUK_CALL_FLAG_CONSTRUCT_PROXY) {
 		act->flags |= DUK_ACT_FLAG_CONSTRUCT_PROXY;
 	}
 #endif
 
-	DUK_ASSERT(DUK_ACT_GET_FUNC(act) == func);      /* already updated */
+	DUK_ASSERT(DUK_ACT_GET_FUNC(act) == func); /* already updated */
 	DUK_ASSERT(act->var_env == NULL);
 	DUK_ASSERT(act->lex_env == NULL);
-	act->bottom_byteoff = entry_valstack_bottom_byteoff;  /* tail call -> reuse current "frame" */
+	act->bottom_byteoff = entry_valstack_bottom_byteoff; /* tail call -> reuse current "frame" */
 #if 0
 	/* Topmost activation retval_byteoff is considered garbage, no need to init. */
 	act->retval_byteoff = 0;
 #endif
 	/* Filled in when final reserve is known, dummy value doesn't matter
 	 * even in error unwind because reserve_byteoff is only used when
 	 * returning to -this- activation.
@@ -66619,30 +67848,31 @@
 	 *
 	 *  For tail calling to work properly, the valstack bottom must not grow
 	 *  here; otherwise crud would accumulate on the valstack.
 	 */
 
 	tv1 = thr->valstack_bottom - 1;
 	tv2 = thr->valstack_bottom + idx_func + 1;
-	DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top);  /* tv1 is -below- valstack_bottom */
+	DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top); /* tv1 is -below- valstack_bottom */
 	DUK_ASSERT(tv2 >= thr->valstack_bottom && tv2 < thr->valstack_top);
-	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects */
 
 	idx_args = idx_func + 2;
-	duk_remove_n(thr, 0, idx_args);  /* may be NORZ */
+	duk_remove_n(thr, 0, idx_args); /* may be NORZ */
 
-	idx_func = 0; DUK_UNREF(idx_func);  /* really 'not applicable' anymore, should not be referenced after this */
+	idx_func = 0;
+	DUK_UNREF(idx_func); /* really 'not applicable' anymore, should not be referenced after this */
 	idx_args = 0;
 
 	*out_nargs = ((duk_hcompfunc *) func)->nargs;
 	*out_nregs = ((duk_hcompfunc *) func)->nregs;
 	DUK_ASSERT(*out_nregs >= 0);
 	DUK_ASSERT(*out_nregs >= *out_nargs);
-	*out_vs_min_bytes = entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) *out_nregs + DUK_VALSTACK_INTERNAL_EXTRA);
-
+	*out_vs_min_bytes =
+	    entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) *out_nregs + DUK_VALSTACK_INTERNAL_EXTRA);
 
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 #if defined(DUK_USE_TAILCALL)
 #error incorrect options: tail calls enabled with function caller property
 #endif
 	/* XXX: This doesn't actually work properly for tail calls, so
 	 * tail calls are disabled when DUK_USE_NONSTD_FUNC_CALLER_PROPERTY
@@ -66651,15 +67881,15 @@
 	duk__update_func_caller_prop(thr, func);
 #endif
 
 	/* [ ... this_new | arg1 ... argN ] */
 
 	return 1;
 }
-#endif  /* DUK_USE_TAILCALL */
+#endif /* DUK_USE_TAILCALL */
 
 DUK_LOCAL void duk__call_setup_act_not_tailcall(duk_hthread *thr,
                                                 duk_small_uint_t call_flags,
                                                 duk_idx_t idx_func,
                                                 duk_hobject *func,
                                                 duk_size_t entry_valstack_bottom_byteoff,
                                                 duk_size_t entry_valstack_end_byteoff,
@@ -66668,16 +67898,15 @@
                                                 duk_size_t *out_vs_min_bytes,
                                                 duk_activation **out_act) {
 	duk_activation *act;
 	duk_activation *new_act;
 
 	DUK_UNREF(entry_valstack_end_byteoff);
 
-	DUK_DDD(DUK_DDDPRINT("not a tail call, pushing a new activation to callstack, to index %ld",
-	                     (long) (thr->callstack_top)));
+	DUK_DDD(DUK_DDDPRINT("not a tail call, pushing a new activation to callstack, to index %ld", (long) (thr->callstack_top)));
 
 	duk__call_callstack_limit_check(thr);
 	new_act = duk_hthread_activation_alloc(thr);
 	DUK_ASSERT(new_act != NULL);
 
 	act = thr->callstack_curr;
 	if (act != NULL) {
@@ -66696,15 +67925,15 @@
 
 	new_act->parent = act;
 	thr->callstack_curr = new_act;
 	thr->callstack_top++;
 	act = new_act;
 	*out_act = act;
 
-	DUK_ASSERT(thr->valstack_top > thr->valstack_bottom);  /* at least effective 'this' */
+	DUK_ASSERT(thr->valstack_top > thr->valstack_bottom); /* at least effective 'this' */
 	DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));
 
 	act->cat = NULL;
 
 	act->flags = 0;
 	if (call_flags & DUK_CALL_FLAG_CONSTRUCT) {
 		act->flags |= DUK_ACT_FLAG_CONSTRUCT;
@@ -66715,63 +67944,69 @@
 	}
 #endif
 	if (call_flags & DUK_CALL_FLAG_DIRECT_EVAL) {
 		act->flags |= DUK_ACT_FLAG_DIRECT_EVAL;
 	}
 
 	/* start of arguments: idx_func + 2. */
-	act->func = func;  /* NULL for lightfunc */
+	act->func = func; /* NULL for lightfunc */
 	if (DUK_LIKELY(func != NULL)) {
-		DUK_TVAL_SET_OBJECT(&act->tv_func, func);  /* borrowed, no refcount */
+		DUK_TVAL_SET_OBJECT(&act->tv_func, func); /* borrowed, no refcount */
 		if (DUK_HOBJECT_HAS_STRICT(func)) {
 			act->flags |= DUK_ACT_FLAG_STRICT;
 		}
 		if (DUK_HOBJECT_IS_COMPFUNC(func)) {
 			*out_nargs = ((duk_hcompfunc *) func)->nargs;
 			*out_nregs = ((duk_hcompfunc *) func)->nregs;
 			DUK_ASSERT(*out_nregs >= 0);
 			DUK_ASSERT(*out_nregs >= *out_nargs);
-			*out_vs_min_bytes = entry_valstack_bottom_byteoff +
-				sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + DUK_VALSTACK_INTERNAL_EXTRA);
+			*out_vs_min_bytes =
+			    entry_valstack_bottom_byteoff +
+			    sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + DUK_VALSTACK_INTERNAL_EXTRA);
 		} else {
 			/* True because of call target lookup checks. */
 			DUK_ASSERT(DUK_HOBJECT_IS_NATFUNC(func));
 
 			*out_nargs = ((duk_hnatfunc *) func)->nargs;
 			*out_nregs = *out_nargs;
 			if (*out_nargs >= 0) {
-				*out_vs_min_bytes = entry_valstack_bottom_byteoff +
-					sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
+				*out_vs_min_bytes =
+				    entry_valstack_bottom_byteoff +
+				    sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs +
+				                        DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
 			} else {
 				/* Vararg function. */
-				duk_size_t valstack_top_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
-				*out_vs_min_bytes = valstack_top_byteoff +
-					sizeof(duk_tval) * (DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
+				duk_size_t valstack_top_byteoff =
+				    (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
+				*out_vs_min_bytes = valstack_top_byteoff + sizeof(duk_tval) * (DUK_VALSTACK_API_ENTRY_MINIMUM +
+				                                                               DUK_VALSTACK_INTERNAL_EXTRA);
 			}
 		}
 	} else {
 		duk_small_uint_t lf_flags;
 		duk_tval *tv_func;
 
 		act->flags |= DUK_ACT_FLAG_STRICT;
 
 		tv_func = DUK_GET_TVAL_POSIDX(thr, idx_func);
 		DUK_ASSERT(DUK_TVAL_IS_LIGHTFUNC(tv_func));
-		DUK_TVAL_SET_TVAL(&act->tv_func, tv_func);  /* borrowed, no refcount */
+		DUK_TVAL_SET_TVAL(&act->tv_func, tv_func); /* borrowed, no refcount */
 
 		lf_flags = DUK_TVAL_GET_LIGHTFUNC_FLAGS(tv_func);
 		*out_nargs = DUK_LFUNC_FLAGS_GET_NARGS(lf_flags);
 		if (*out_nargs != DUK_LFUNC_NARGS_VARARGS) {
 			*out_vs_min_bytes = entry_valstack_bottom_byteoff +
-				sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nargs + DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
+			                    sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nargs +
+			                                        DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
 		} else {
-			duk_size_t valstack_top_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
+			duk_size_t valstack_top_byteoff =
+			    (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
 			*out_vs_min_bytes = valstack_top_byteoff +
-				sizeof(duk_tval) * (DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
-			*out_nargs = -1;  /* vararg */
+			                    sizeof(duk_tval) * (DUK_VALSTACK_API_ENTRY_MINIMUM + DUK_VALSTACK_INTERNAL_EXTRA);
+			*out_nargs = -1; /* vararg */
 		}
 		*out_nregs = *out_nargs;
 	}
 
 	act->var_env = NULL;
 	act->lex_env = NULL;
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
@@ -66785,21 +68020,21 @@
 #if 0
 	act->retval_byteoff = 0;   /* topmost activation retval_byteoff is considered garbage, no need to init */
 #endif
 	/* Filled in when final reserve is known, dummy value doesn't matter
 	 * even in error unwind because reserve_byteoff is only used when
 	 * returning to -this- activation.
 	 */
-	act->reserve_byteoff = 0;  /* filled in by caller */
+	act->reserve_byteoff = 0; /* filled in by caller */
 
 	/* XXX: Is this INCREF necessary? 'func' is always a borrowed
 	 * reference reachable through the value stack?  If changed, stack
 	 * unwind code also needs to be fixed to match.
 	 */
-	DUK_HOBJECT_INCREF_ALLOWNULL(thr, func);  /* act->func */
+	DUK_HOBJECT_INCREF_ALLOWNULL(thr, func); /* act->func */
 
 #if defined(DUK_USE_NONSTD_FUNC_CALLER_PROPERTY)
 	if (func) {
 		duk__update_func_caller_prop(thr, func);
 	}
 #endif
 }
@@ -66807,15 +68042,15 @@
 /*
  *  Environment setup.
  */
 
 DUK_LOCAL void duk__call_env_setup(duk_hthread *thr, duk_hobject *func, duk_activation *act, duk_idx_t idx_args) {
 	duk_hobject *env;
 
-	DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));  /* bound function has already been resolved */
+	DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func)); /* bound function has already been resolved */
 
 	if (DUK_LIKELY(func != NULL)) {
 		if (DUK_LIKELY(DUK_HOBJECT_HAS_NEWENV(func))) {
 			DUK_STATS_INC(thr->heap, stats_envrec_newenv);
 			if (DUK_LIKELY(!DUK_HOBJECT_HAS_CREATEARGS(func))) {
 				/* Use a new environment but there's no 'arguments' object;
 				 * delayed environment initialization.  This is the most
@@ -66838,15 +68073,15 @@
 				duk__handle_createargs_for_call(thr, func, env, idx_args);
 
 				/* [ ... func this arg1 ... argN envobj ] */
 
 				act->lex_env = env;
 				act->var_env = env;
 				DUK_HOBJECT_INCREF(thr, env);
-				DUK_HOBJECT_INCREF(thr, env);  /* XXX: incref by count (2) directly */
+				DUK_HOBJECT_INCREF(thr, env); /* XXX: incref by count (2) directly */
 				duk_pop(thr);
 			}
 		} else {
 			/* Use existing env (e.g. for non-strict eval); cannot have
 			 * an own 'arguments' object (but can refer to an existing one).
 			 */
 
@@ -66876,31 +68111,30 @@
 
 	if (DUK_LIKELY(thr == thr->heap->curr_thread)) {
 		if (DUK_UNLIKELY(thr->state != DUK_HTHREAD_STATE_RUNNING)) {
 			/* Should actually never happen, but check anyway. */
 			goto thread_state_error;
 		}
 	} else {
-		DUK_ASSERT(thr->heap->curr_thread == NULL ||
-		           thr->heap->curr_thread->state == DUK_HTHREAD_STATE_RUNNING);
+		DUK_ASSERT(thr->heap->curr_thread == NULL || thr->heap->curr_thread->state == DUK_HTHREAD_STATE_RUNNING);
 		if (DUK_UNLIKELY(thr->state != DUK_HTHREAD_STATE_INACTIVE)) {
 			goto thread_state_error;
 		}
 		DUK_HEAP_SWITCH_THREAD(thr->heap, thr);
 		thr->state = DUK_HTHREAD_STATE_RUNNING;
 
 		/* Multiple threads may be simultaneously in the RUNNING
 		 * state, but not in the same "resume chain".
 		 */
 	}
 	DUK_ASSERT(thr->heap->curr_thread == thr);
 	DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING);
 	return;
 
- thread_state_error:
+thread_state_error:
 	DUK_ERROR_FMT1(thr, DUK_ERR_TYPE_ERROR, "invalid thread state (%ld)", (long) thr->state);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Main unprotected call handler, handles:
  *
@@ -66918,32 +68152,30 @@
  *
  *  The call handler doesn't provide any protection guarantees, protected calls
  *  must be implemented e.g. by wrapping the call in a duk_safe_call().
  *  Call setup may fail at any stage, even when the new activation is in
  *  place; the only guarantee is that the state is consistent for unwinding.
  */
 
-DUK_LOCAL duk_int_t duk__handle_call_raw(duk_hthread *thr,
-                                         duk_idx_t idx_func,
-                                         duk_small_uint_t call_flags) {
+DUK_LOCAL duk_int_t duk__handle_call_raw(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {
 #if defined(DUK_USE_ASSERTIONS)
 	duk_activation *entry_act;
 	duk_size_t entry_callstack_top;
 #endif
 	duk_size_t entry_valstack_bottom_byteoff;
 	duk_size_t entry_valstack_end_byteoff;
 	duk_int_t entry_call_recursion_depth;
 	duk_hthread *entry_curr_thread;
 	duk_uint_fast8_t entry_thread_state;
 	duk_instr_t **entry_ptr_curr_pc;
 	duk_idx_t idx_args;
-	duk_idx_t nargs;            /* # argument registers target function wants (< 0 => "as is") */
-	duk_idx_t nregs;            /* # total registers target function wants on entry (< 0 => "as is") */
-	duk_size_t vs_min_bytes;    /* minimum value stack size (bytes) for handling call */
-	duk_hobject *func;          /* 'func' on stack (borrowed reference) */
+	duk_idx_t nargs; /* # argument registers target function wants (< 0 => "as is") */
+	duk_idx_t nregs; /* # total registers target function wants on entry (< 0 => "as is") */
+	duk_size_t vs_min_bytes; /* minimum value stack size (bytes) for handling call */
+	duk_hobject *func; /* 'func' on stack (borrowed reference) */
 	duk_activation *act;
 	duk_ret_t rc;
 	duk_small_uint_t use_tailcall;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(thr->heap != NULL);
 	/* Asserts for heap->curr_thread omitted: it may be NULL, 'thr', or
@@ -66976,30 +68208,30 @@
 		 */
 
 		tmp_act = thr->callstack_curr;
 		for (tmp_cat = tmp_act->cat; tmp_cat != NULL; tmp_cat = tmp_cat->parent) {
 			DUK_ASSERT(DUK_CAT_GET_TYPE(tmp_cat) == DUK_CAT_TYPE_LABEL); /* a non-catching entry */
 		}
 	}
-#endif  /* DUK_USE_ASSERTIONS */
+#endif /* DUK_USE_ASSERTIONS */
 
 	/*
 	 *  Store entry state.
 	 */
 
 #if defined(DUK_USE_ASSERTIONS)
 	entry_act = thr->callstack_curr;
 	entry_callstack_top = thr->callstack_top;
 #endif
 	entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);
 	entry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 	entry_call_recursion_depth = thr->heap->call_recursion_depth;
-	entry_curr_thread = thr->heap->curr_thread;  /* may be NULL if first call */
+	entry_curr_thread = thr->heap->curr_thread; /* may be NULL if first call */
 	entry_thread_state = thr->state;
-	entry_ptr_curr_pc = thr->ptr_curr_pc;  /* may be NULL */
+	entry_ptr_curr_pc = thr->ptr_curr_pc; /* may be NULL */
 
 	/* If thr->ptr_curr_pc is set, sync curr_pc to act->pc.  Then NULL
 	 * thr->ptr_curr_pc so that it's not accidentally used with an incorrect
 	 * activation when side effects occur.
 	 */
 	duk_hthread_sync_and_null_currpc(thr);
 	DUK_ASSERT(thr->ptr_curr_pc == NULL);
@@ -67059,19 +68291,18 @@
 
 	if (DUK_LIKELY(duk__resolve_target_fastpath_check(thr, idx_func, &func, call_flags) != 0U)) {
 		DUK_DDD(DUK_DDDPRINT("fast path target resolve"));
 	} else {
 		DUK_DDD(DUK_DDDPRINT("slow path target resolve"));
 		func = duk__resolve_target_func_and_this_binding(thr, idx_func, &call_flags);
 	}
-	DUK_ASSERT(duk_get_top(thr) - idx_func >= 2);  /* at least func and this present */
+	DUK_ASSERT(duk_get_top(thr) - idx_func >= 2); /* at least func and this present */
 
 	DUK_ASSERT(func == NULL || !DUK_HOBJECT_HAS_BOUNDFUNC(func));
-	DUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) ||
-	                            DUK_HOBJECT_IS_NATFUNC(func)));
+	DUK_ASSERT(func == NULL || (DUK_HOBJECT_IS_COMPFUNC(func) || DUK_HOBJECT_IS_NATFUNC(func)));
 
 	/* [ ... func this arg1 ... argN ] */
 
 	/*
 	 *  Setup a preliminary activation and figure out nargs/nregs and
 	 *  value stack minimum size.
 	 *
@@ -67098,15 +68329,15 @@
 		                                                    entry_valstack_end_byteoff,
 		                                                    &nargs,
 		                                                    &nregs,
 		                                                    &vs_min_bytes,
 		                                                    &act);
 	}
 #else
-	DUK_ASSERT((call_flags & DUK_CALL_FLAG_TAILCALL) == 0);  /* compiler ensures this */
+	DUK_ASSERT((call_flags & DUK_CALL_FLAG_TAILCALL) == 0); /* compiler ensures this */
 	use_tailcall = 0;
 #endif
 
 	if (use_tailcall) {
 		idx_args = 0;
 		DUK_STATS_INC(thr->heap, stats_call_tailcall);
 	} else {
@@ -67125,14 +68356,23 @@
 	/* After this point idx_func is no longer valid for tailcalls. */
 
 	DUK_ASSERT(act != NULL);
 
 	/* [ ... func this arg1 ... argN ] */
 
 	/*
+	 *  Grow value stack to required size before env setup.  This
+	 *  must happen before env setup to handle some corner cases
+	 *  correctly, e.g. test-bug-scope-segv-gh2448.js.
+	 */
+
+	duk_valstack_grow_check_throw(thr, vs_min_bytes);
+	act->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
+
+	/*
 	 *  Environment record creation and 'arguments' object creation.
 	 *  Named function expression name binding is handled by the
 	 *  compiler; the compiled function's parent env will contain
 	 *  the (immutable) binding already.
 	 *
 	 *  This handling is now identical for C and ECMAScript functions.
 	 *  C functions always have the 'NEWENV' flag set, so their
@@ -67145,21 +68385,16 @@
 
 	/* [ ... func this arg1 ... argN ] */
 
 	/*
 	 *  Setup value stack: clamp to 'nargs', fill up to 'nregs',
 	 *  ensure value stack size matches target requirements, and
 	 *  switch value stack bottom.  Valstack top is kept.
-	 *
-	 *  Value stack can only grow here.
 	 */
 
-	duk_valstack_grow_check_throw(thr, vs_min_bytes);
-	act->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
-
 	if (use_tailcall) {
 		DUK_ASSERT(nregs >= 0);
 		DUK_ASSERT(nregs >= nargs);
 		duk_set_top_and_wipe(thr, nregs, nargs);
 	} else {
 		if (nregs >= 0) {
 			DUK_ASSERT(nregs >= nargs);
@@ -67190,16 +68425,16 @@
 
 		if (call_flags & DUK_CALL_FLAG_ALLOW_ECMATOECMA) {
 			DUK_DD(DUK_DDPRINT("avoid native call, use existing executor"));
 			DUK_STATS_INC(thr->heap, stats_call_ecmatoecma);
 			DUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);
 			DUK_REFZERO_CHECK_FAST(thr);
 			DUK_ASSERT(thr->ptr_curr_pc == NULL);
-			thr->heap->call_recursion_depth--;  /* No recursion increase for this case. */
-			return 1;  /* 1=reuse executor */
+			thr->heap->call_recursion_depth--; /* No recursion increase for this case. */
+			return 1; /* 1=reuse executor */
 		}
 		DUK_ASSERT(use_tailcall == 0);
 
 		/* duk_hthread_activation_unwind_norz() will decrease this on unwind */
 		DUK_ASSERT((act->flags & DUK_ACT_FLAG_PREVENT_YIELD) == 0);
 		act->flags |= DUK_ACT_FLAG_PREVENT_YIELD;
 		thr->callstack_preventcount++;
@@ -67315,15 +68550,15 @@
 
 		tv_ret = thr->valstack_bottom + idx_func;
 		tv_funret = thr->valstack_top - 1;
 #if defined(DUK_USE_FASTINT)
 		/* Explicit check for fastint downgrade. */
 		DUK_TVAL_CHKFAST_INPLACE_FAST(tv_funret);
 #endif
-		DUK_TVAL_SET_TVAL_UPDREF(thr, tv_ret, tv_funret);  /* side effects */
+		DUK_TVAL_SET_TVAL_UPDREF(thr, tv_ret, tv_funret); /* side effects */
 	}
 
 	duk_set_top_unsafe(thr, idx_func + 1);
 
 	/* [ ... retval ] */
 
 	/* Restore caller's value stack reserve (cannot fail). */
@@ -67334,15 +68569,15 @@
 	/* XXX: Trial value stack shrink would be OK here, but we'd need
 	 * to prevent side effects of the potential realloc.
 	 */
 
 	/* Restore entry thread executor curr_pc stack frame pointer. */
 	thr->ptr_curr_pc = entry_ptr_curr_pc;
 
-	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread);  /* may be NULL */
+	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread); /* may be NULL */
 	thr->state = (duk_uint8_t) entry_thread_state;
 
 	/* Disabled assert: triggered with some torture tests. */
 #if 0
 	DUK_ASSERT((thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread == NULL) ||  /* first call */
 	           (thr->state == DUK_HTHREAD_STATE_INACTIVE && thr->heap->curr_thread != NULL) ||  /* other call */
 	           (thr->state == DUK_HTHREAD_STATE_RUNNING && thr->heap->curr_thread == thr));     /* current thread */
@@ -67375,30 +68610,26 @@
 	/* Restored by success path. */
 	DUK_ASSERT(thr->heap->call_recursion_depth == entry_call_recursion_depth);
 	DUK_ASSERT(thr->ptr_curr_pc == entry_ptr_curr_pc);
 	DUK_ASSERT_LJSTATE_UNSET(thr->heap);
 
 	DUK_REFZERO_CHECK_FAST(thr);
 
-	return 0;  /* 0=call handled inline */
+	return 0; /* 0=call handled inline */
 }
 
-DUK_INTERNAL duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr,
-                                                         duk_idx_t nargs,
-                                                         duk_small_uint_t call_flags) {
+DUK_INTERNAL duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags) {
 	duk_idx_t idx_func;
 	DUK_ASSERT(duk_get_top(thr) >= nargs + 2);
 	idx_func = duk_get_top(thr) - (nargs + 2);
 	DUK_ASSERT(idx_func >= 0);
 	return duk_handle_call_unprotected(thr, idx_func, call_flags);
 }
 
-DUK_INTERNAL duk_int_t duk_handle_call_unprotected(duk_hthread *thr,
-                                                   duk_idx_t idx_func,
-                                                   duk_small_uint_t call_flags) {
+DUK_INTERNAL duk_int_t duk_handle_call_unprotected(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {
 	DUK_ASSERT(duk_is_valid_index(thr, idx_func));
 	DUK_ASSERT(idx_func >= 0);
 	return duk__handle_call_raw(thr, idx_func, call_flags);
 }
 
 /*
  *  duk_handle_safe_call(): make a "C protected call" within the
@@ -67457,27 +68688,28 @@
 	/*
 	 *  Valstack manipulation for results.
 	 */
 
 	/* we're running inside the caller's activation, so no change in call/catch stack or valstack bottom */
 	DUK_ASSERT(thr->callstack_top == entry_callstack_top);
 	DUK_ASSERT(thr->valstack_bottom >= thr->valstack);
-	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) == entry_valstack_bottom_byteoff);
+	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) ==
+	           entry_valstack_bottom_byteoff);
 	DUK_ASSERT(thr->valstack_top >= thr->valstack_bottom);
 	DUK_ASSERT(thr->valstack_end >= thr->valstack_top);
 
 	if (DUK_UNLIKELY(rc < 0)) {
 		duk_error_throw_from_negative_rc(thr, rc);
 		DUK_WO_NORETURN(return;);
 	}
 	DUK_ASSERT(rc >= 0);
 
-	duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, rc);  /* throws for insane rc */
+	duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, rc); /* throws for insane rc */
 
-	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread);  /* may be NULL */
+	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread); /* may be NULL */
 	thr->state = (duk_uint8_t) entry_thread_state;
 }
 
 DUK_LOCAL void duk__handle_safe_call_error(duk_hthread *thr,
                                            duk_activation *entry_act,
 #if defined(DUK_USE_ASSERTIONS)
                                            duk_size_t entry_callstack_top,
@@ -67522,15 +68754,15 @@
 		duk_hthread_activation_unwind_norz(thr);
 	}
 	DUK_ASSERT(thr->callstack_top == entry_callstack_top);
 
 	/* Switch active thread before any side effects to avoid a
 	 * dangling curr_thread pointer.
 	 */
-	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread);  /* may be NULL */
+	DUK_HEAP_SWITCH_THREAD(thr->heap, entry_curr_thread); /* may be NULL */
 	thr->state = (duk_uint8_t) entry_thread_state;
 
 	DUK_ASSERT(thr->heap->curr_thread == entry_curr_thread);
 	DUK_ASSERT(thr->state == entry_thread_state);
 
 	/* Restore valstack bottom. */
 	thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);
@@ -67538,17 +68770,17 @@
 	/* [ ... | (crud) ] */
 
 	/* XXX: ensure space in valstack (now relies on internal reserve)? */
 	duk_push_tval(thr, &thr->heap->lj.value1);
 
 	/* [ ... | (crud) errobj ] */
 
-	DUK_ASSERT(duk_get_top(thr) >= 1);  /* at least errobj must be on stack */
+	DUK_ASSERT(duk_get_top(thr) >= 1); /* at least errobj must be on stack */
 
-	duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, 1);  /* 1 = num actual 'return values' */
+	duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, 1); /* 1 = num actual 'return values' */
 
 	/* [ ... | ] or [ ... | errobj (M * undefined)] where M = num_stack_rets - 1 */
 
 	/* Reset longjmp state. */
 	thr->heap->lj.type = DUK_LJ_TYPE_UNKNOWN;
 	thr->heap->lj.iserror = 0;
 	DUK_TVAL_SET_UNDEFINED_UPDREF_NORZ(thr, &thr->heap->lj.value1);
@@ -67626,15 +68858,15 @@
 	duk_instr_t **entry_ptr_curr_pc;
 	duk_jmpbuf *old_jmpbuf_ptr = NULL;
 	duk_jmpbuf our_jmpbuf;
 	duk_idx_t idx_retbase;
 	duk_int_t retval;
 
 	DUK_ASSERT(thr != NULL);
-	DUK_ASSERT(duk_get_top(thr) >= num_stack_args);  /* Caller ensures. */
+	DUK_ASSERT(duk_get_top(thr) >= num_stack_args); /* Caller ensures. */
 
 	DUK_STATS_INC(thr->heap, stats_safecall_all);
 
 	/* Value stack reserve handling: safe call assumes caller has reserved
 	 * space for nrets (assuming optimal unwind processing).  Value stack
 	 * reserve is not stored/restored as for normal calls because a safe
 	 * call conceptually happens in the same activation.
@@ -67645,22 +68877,22 @@
 	entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);
 #if defined(DUK_USE_ASSERTIONS)
 	entry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 	entry_callstack_top = thr->callstack_top;
 	entry_callstack_preventcount = thr->callstack_preventcount;
 #endif
 	entry_call_recursion_depth = thr->heap->call_recursion_depth;
-	entry_curr_thread = thr->heap->curr_thread;  /* may be NULL if first call */
+	entry_curr_thread = thr->heap->curr_thread; /* may be NULL if first call */
 	entry_thread_state = thr->state;
-	entry_ptr_curr_pc = thr->ptr_curr_pc;  /* may be NULL */
-	idx_retbase = duk_get_top(thr) - num_stack_args;  /* not a valid stack index if num_stack_args == 0 */
+	entry_ptr_curr_pc = thr->ptr_curr_pc; /* may be NULL */
+	idx_retbase = duk_get_top(thr) - num_stack_args; /* not a valid stack index if num_stack_args == 0 */
 	DUK_ASSERT(idx_retbase >= 0);
 
-	DUK_ASSERT((duk_idx_t) (thr->valstack_top - thr->valstack_bottom) >= num_stack_args);  /* Caller ensures. */
-	DUK_ASSERT((duk_idx_t) (thr->valstack_end - (thr->valstack_bottom + idx_retbase)) >= num_stack_rets);  /* Caller ensures. */
+	DUK_ASSERT((duk_idx_t) (thr->valstack_top - thr->valstack_bottom) >= num_stack_args); /* Caller ensures. */
+	DUK_ASSERT((duk_idx_t) (thr->valstack_end - (thr->valstack_bottom + idx_retbase)) >= num_stack_rets); /* Caller ensures. */
 
 	/* Cannot portably debug print a function pointer, hence 'func' not printed! */
 	DUK_DD(DUK_DDPRINT("duk_handle_safe_call: thr=%p, num_stack_args=%ld, num_stack_rets=%ld, "
 	                   "valstack_top=%ld, idx_retbase=%ld, rec_depth=%ld/%ld, "
 	                   "entry_act=%p, entry_valstack_bottom_byteoff=%ld, entry_call_recursion_depth=%ld, "
 	                   "entry_curr_thread=%p, entry_thread_state=%ld",
 	                   (void *) thr,
@@ -67712,25 +68944,27 @@
 		/* Either pointer may be NULL (at entry), so don't assert */
 		thr->heap->lj.jmpbuf_ptr = old_jmpbuf_ptr;
 
 		/* If calls happen inside the safe call, these are restored by
 		 * whatever calls are made.  Reserve cannot decrease.
 		 */
 		DUK_ASSERT(thr->callstack_curr == entry_act);
-		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
+		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >=
+		           entry_valstack_end_byteoff);
 
 		retval = DUK_EXEC_SUCCESS;
 #if defined(DUK_USE_CPP_EXCEPTIONS)
 	} catch (duk_internal_exception &exc) {
 		DUK_UNREF(exc);
 #else
 	} else {
 		/* Error path. */
 #endif
-		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
+		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >=
+		           entry_valstack_end_byteoff);
 
 		DUK_STATS_INC(thr->heap, stats_safecall_throw);
 
 		duk__handle_safe_call_error(thr,
 		                            entry_act,
 #if defined(DUK_USE_ASSERTIONS)
 		                            entry_callstack_top,
@@ -67747,22 +68981,26 @@
 #if defined(DUK_USE_CPP_EXCEPTIONS)
 	catch (duk_fatal_exception &exc) {
 		DUK_D(DUK_DPRINT("rethrow duk_fatal_exception"));
 		DUK_UNREF(exc);
 		throw;
 	} catch (std::exception &exc) {
 		const char *what = exc.what();
-		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
+		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >=
+		           entry_valstack_end_byteoff);
 		DUK_STATS_INC(thr->heap, stats_safecall_throw);
 		if (!what) {
 			what = "unknown";
 		}
 		DUK_D(DUK_DPRINT("unexpected c++ std::exception (perhaps thrown by user code)"));
 		try {
-			DUK_ERROR_FMT1(thr, DUK_ERR_TYPE_ERROR, "caught invalid c++ std::exception '%s' (perhaps thrown by user code)", what);
+			DUK_ERROR_FMT1(thr,
+			               DUK_ERR_TYPE_ERROR,
+			               "caught invalid c++ std::exception '%s' (perhaps thrown by user code)",
+			               what);
 			DUK_WO_NORETURN(return 0;);
 		} catch (duk_internal_exception exc) {
 			DUK_D(DUK_DPRINT("caught api error thrown from unexpected c++ std::exception"));
 			DUK_UNREF(exc);
 			duk__handle_safe_call_error(thr,
 			                            entry_act,
 #if defined(DUK_USE_ASSERTIONS)
@@ -67774,15 +69012,16 @@
 			                            num_stack_rets,
 			                            entry_valstack_bottom_byteoff,
 			                            old_jmpbuf_ptr);
 			retval = DUK_EXEC_ERROR;
 		}
 	} catch (...) {
 		DUK_D(DUK_DPRINT("unexpected c++ exception (perhaps thrown by user code)"));
-		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
+		DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >=
+		           entry_valstack_end_byteoff);
 		DUK_STATS_INC(thr->heap, stats_safecall_throw);
 		try {
 			DUK_ERROR_TYPE(thr, "caught invalid c++ exception (perhaps thrown by user code)");
 			DUK_WO_NORETURN(return 0;);
 		} catch (duk_internal_exception exc) {
 			DUK_D(DUK_DPRINT("caught api error thrown from unexpected c++ exception"));
 			DUK_UNREF(exc);
@@ -67798,15 +69037,15 @@
 			                            entry_valstack_bottom_byteoff,
 			                            old_jmpbuf_ptr);
 			retval = DUK_EXEC_ERROR;
 		}
 	}
 #endif
 
-	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr == old_jmpbuf_ptr);  /* success/error path both do this */
+	DUK_ASSERT(thr->heap->lj.jmpbuf_ptr == old_jmpbuf_ptr); /* success/error path both do this */
 
 	DUK_ASSERT_LJSTATE_UNSET(thr->heap);
 
 	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
 	duk__handle_safe_call_shared_unwind(thr,
 	                                    idx_retbase,
 	                                    num_stack_rets,
@@ -67819,15 +69058,16 @@
 
 	/* Restore preventcount. */
 	thr->callstack_preventcount--;
 	DUK_ASSERT(thr->callstack_preventcount == entry_callstack_preventcount);
 
 	/* Final asserts. */
 	DUK_ASSERT(thr->callstack_curr == entry_act);
-	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) == entry_valstack_bottom_byteoff);
+	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) ==
+	           entry_valstack_bottom_byteoff);
 	DUK_ASSERT((duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack) >= entry_valstack_end_byteoff);
 	DUK_ASSERT(thr->callstack_top == entry_callstack_top);
 	DUK_ASSERT(thr->heap->call_recursion_depth == entry_call_recursion_depth);
 	DUK_ASSERT(thr->heap->curr_thread == entry_curr_thread);
 	DUK_ASSERT(thr->state == entry_thread_state);
 	DUK_ASSERT(thr->ptr_curr_pc == entry_ptr_curr_pc);
 	DUK_ASSERT(duk_get_top(thr) == idx_retbase + num_stack_rets);
@@ -67880,39 +69120,45 @@
 
 #if defined(DUK_USE_PARANOID_ERRORS)
 	str_targ = duk_get_type_name(thr, -4);
 	str_key = duk_get_type_name(thr, -2);
 	str_base = duk_get_type_name(thr, -3);
 	duk_push_error_object(thr,
 	                      DUK_ERR_TYPE_ERROR | DUK_ERRCODE_FLAG_NOBLAME_FILELINE,
-	                      "%s not callable (property %s of %s)", str_targ, str_key, str_base);
-	duk_xdef_prop_stridx(thr, -2, DUK_STRIDX_INT_TARGET, DUK_PROPDESC_FLAGS_NONE);  /* Marker property, reuse _Target. */
+	                      "%s not callable (property %s of %s)",
+	                      str_targ,
+	                      str_key,
+	                      str_base);
+	duk_xdef_prop_stridx(thr, -2, DUK_STRIDX_INT_TARGET, DUK_PROPDESC_FLAGS_NONE); /* Marker property, reuse _Target. */
 	/* [ <nargs> target base key { _Target: error } ] */
 	duk_replace(thr, entry_top - 1);
 #else
 	str_targ = duk_push_string_readable(thr, -4);
 	str_key = duk_push_string_readable(thr, -3);
 	str_base = duk_push_string_readable(thr, -5);
 	duk_push_error_object(thr,
 	                      DUK_ERR_TYPE_ERROR | DUK_ERRCODE_FLAG_NOBLAME_FILELINE,
-	                      "%s not callable (property %s of %s)", str_targ, str_key, str_base);
+	                      "%s not callable (property %s of %s)",
+	                      str_targ,
+	                      str_key,
+	                      str_base);
 	/* [ <nargs> target base key {} str_targ str_key str_base error ] */
-	duk_xdef_prop_stridx(thr, -5, DUK_STRIDX_INT_TARGET, DUK_PROPDESC_FLAGS_NONE);  /* Marker property, reuse _Target. */
+	duk_xdef_prop_stridx(thr, -5, DUK_STRIDX_INT_TARGET, DUK_PROPDESC_FLAGS_NONE); /* Marker property, reuse _Target. */
 	/* [ <nargs> target base key { _Target: error } str_targ str_key str_base ] */
 	duk_swap(thr, -4, entry_top - 1);
 	/* [ <nargs> { _Target: error } base key target str_targ str_key str_base ] */
 #endif
 
 	/* [ <nregs> { _Target: error } <variable> */
 	duk_set_top(thr, entry_top);
 
 	/* [ <nregs> { _Target: error } */
-	DUK_ASSERT(!duk_is_callable(thr, -1));  /* Critical so that call handling will throw the error. */
+	DUK_ASSERT(!duk_is_callable(thr, -1)); /* Critical so that call handling will throw the error. */
 }
-#endif  /* DUK_USE_VERBOSE_ERRORS */
+#endif /* DUK_USE_VERBOSE_ERRORS */
 
 /* automatic undefs */
 #undef DUK__AUGMENT_CALL_RELAX_COUNT
 #undef DUK__CALL_HANDLING_REQUIRE_STACK
 #line 1 "duk_js_compiler.c"
 /*
  *  ECMAScript compiler.
@@ -67946,65 +69192,71 @@
 
 /* If highest bit of a register number is set, it refers to a constant instead.
  * When interpreted as a signed value, this means const values are always
  * negative (when interpreted as two's complement).  For example DUK__ISREG_TEMP()
  * uses this approach to avoid an explicit DUK__ISREG() check (the condition is
  * logically "'x' is a register AND 'x' >= temp_first").
  */
-#define DUK__CONST_MARKER                   DUK_REGCONST_CONST_MARKER
-#define DUK__REMOVECONST(x)                 ((x) & ~DUK__CONST_MARKER)
-#define DUK__ISREG(x)                       ((x) >= 0)
-#define DUK__ISCONST(x)                     ((x) < 0)
-#define DUK__ISREG_TEMP(comp_ctx,x)         ((duk_int32_t) (x) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))   /* Check for x >= temp_first && x >= 0 by comparing as signed. */
-#define DUK__ISREG_NOTTEMP(comp_ctx,x)      ((duk_uint32_t) (x) < (duk_uint32_t) ((comp_ctx)->curr_func.temp_first))  /* Check for x >= 0 && x < temp_first by interpreting as unsigned. */
-#define DUK__GETTEMP(comp_ctx)              ((comp_ctx)->curr_func.temp_next)
-#define DUK__SETTEMP(comp_ctx,x)            ((comp_ctx)->curr_func.temp_next = (x))  /* dangerous: must only lower (temp_max not updated) */
-#define DUK__SETTEMP_CHECKMAX(comp_ctx,x)   duk__settemp_checkmax((comp_ctx),(x))
-#define DUK__ALLOCTEMP(comp_ctx)            duk__alloctemp((comp_ctx))
-#define DUK__ALLOCTEMPS(comp_ctx,count)     duk__alloctemps((comp_ctx),(count))
+#define DUK__CONST_MARKER   DUK_REGCONST_CONST_MARKER
+#define DUK__REMOVECONST(x) ((x) & ~DUK__CONST_MARKER)
+#define DUK__ISREG(x)       ((x) >= 0)
+#define DUK__ISCONST(x)     ((x) < 0)
+#define DUK__ISREG_TEMP(comp_ctx, x) \
+	((duk_int32_t) (x) >= \
+	 (duk_int32_t) ((comp_ctx)->curr_func.temp_first)) /* Check for x >= temp_first && x >= 0 by comparing as signed. */
+#define DUK__ISREG_NOTTEMP(comp_ctx, x) \
+	((duk_uint32_t) (x) < \
+	 (duk_uint32_t) ((comp_ctx)->curr_func.temp_first)) /* Check for x >= 0 && x < temp_first by interpreting as unsigned. */
+#define DUK__GETTEMP(comp_ctx)             ((comp_ctx)->curr_func.temp_next)
+#define DUK__SETTEMP(comp_ctx, x)          ((comp_ctx)->curr_func.temp_next = (x)) /* dangerous: must only lower (temp_max not updated) */
+#define DUK__SETTEMP_CHECKMAX(comp_ctx, x) duk__settemp_checkmax((comp_ctx), (x))
+#define DUK__ALLOCTEMP(comp_ctx)           duk__alloctemp((comp_ctx))
+#define DUK__ALLOCTEMPS(comp_ctx, count)   duk__alloctemps((comp_ctx), (count))
 
 /* Init value set size for array and object literals. */
-#define DUK__MAX_ARRAY_INIT_VALUES        20
-#define DUK__MAX_OBJECT_INIT_PAIRS        10
+#define DUK__MAX_ARRAY_INIT_VALUES 20
+#define DUK__MAX_OBJECT_INIT_PAIRS 10
 
 /* XXX: hack, remove when const lookup is not O(n) */
-#define DUK__GETCONST_MAX_CONSTS_CHECK    256
+#define DUK__GETCONST_MAX_CONSTS_CHECK 256
 
 /* These limits are based on bytecode limits.  Max temps is limited
  * by duk_hcompfunc nargs/nregs fields being 16 bits.
  */
-#define DUK__MAX_CONSTS                   DUK_BC_BC_MAX
-#define DUK__MAX_FUNCS                    DUK_BC_BC_MAX
-#define DUK__MAX_TEMPS                    0xffffL
+#define DUK__MAX_CONSTS DUK_BC_BC_MAX
+#define DUK__MAX_FUNCS  DUK_BC_BC_MAX
+#define DUK__MAX_TEMPS  0xffffL
 
 /* Initial bytecode size allocation. */
 #if defined(DUK_USE_PREFER_SIZE)
-#define DUK__BC_INITIAL_INSTS             16
+#define DUK__BC_INITIAL_INSTS 16
 #else
-#define DUK__BC_INITIAL_INSTS             256
+#define DUK__BC_INITIAL_INSTS 256
 #endif
 
-#define DUK__RECURSION_INCREASE(comp_ctx,thr)  do { \
+#define DUK__RECURSION_INCREASE(comp_ctx, thr) \
+	do { \
 		DUK_DDD(DUK_DDDPRINT("RECURSION INCREASE: %s:%ld", (const char *) DUK_FILE_MACRO, (long) DUK_LINE_MACRO)); \
 		duk__comp_recursion_increase((comp_ctx)); \
 	} while (0)
 
-#define DUK__RECURSION_DECREASE(comp_ctx,thr)  do { \
+#define DUK__RECURSION_DECREASE(comp_ctx, thr) \
+	do { \
 		DUK_DDD(DUK_DDDPRINT("RECURSION DECREASE: %s:%ld", (const char *) DUK_FILE_MACRO, (long) DUK_LINE_MACRO)); \
 		duk__comp_recursion_decrease((comp_ctx)); \
 	} while (0)
 
 /* Value stack slot limits: these are quite approximate right now, and
  * because they overlap in control flow, some could be eliminated.
  */
-#define DUK__COMPILE_ENTRY_SLOTS          8
-#define DUK__FUNCTION_INIT_REQUIRE_SLOTS  16
-#define DUK__FUNCTION_BODY_REQUIRE_SLOTS  16
-#define DUK__PARSE_STATEMENTS_SLOTS       16
-#define DUK__PARSE_EXPR_SLOTS             16
+#define DUK__COMPILE_ENTRY_SLOTS         8
+#define DUK__FUNCTION_INIT_REQUIRE_SLOTS 16
+#define DUK__FUNCTION_BODY_REQUIRE_SLOTS 16
+#define DUK__PARSE_STATEMENTS_SLOTS      16
+#define DUK__PARSE_EXPR_SLOTS            16
 
 /* Temporary structure used to pass a stack allocated region through
  * duk_safe_call().
  */
 typedef struct {
 	duk_small_uint_t flags;
 	duk_compiler_ctx comp_ctx_alloc;
@@ -68028,32 +69280,41 @@
 DUK_LOCAL_DECL duk_int_t duk__cleanup_varmap(duk_compiler_ctx *comp_ctx);
 
 /* code emission */
 DUK_LOCAL_DECL duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx);
 DUK_LOCAL_DECL duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc);
 DUK_LOCAL_DECL void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins);
 DUK_LOCAL_DECL void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op);
-DUK_LOCAL_DECL void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b, duk_regconst_t c);
+DUK_LOCAL_DECL void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx,
+                                    duk_small_uint_t op_flags,
+                                    duk_regconst_t a,
+                                    duk_regconst_t b,
+                                    duk_regconst_t c);
 DUK_LOCAL_DECL void duk__emit_a_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b);
 DUK_LOCAL_DECL void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL void duk__emit_a(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a);
 DUK_LOCAL_DECL void duk__emit_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b);
 #endif
 DUK_LOCAL_DECL void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc);
 DUK_LOCAL_DECL void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc);
 DUK_LOCAL_DECL void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc);
 DUK_LOCAL_DECL void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
 DUK_LOCAL_DECL void duk__emit_load_int32_noshuffle(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
 DUK_LOCAL_DECL void duk__emit_jump(duk_compiler_ctx *comp_ctx, duk_int_t target_pc);
 DUK_LOCAL_DECL duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx);
 DUK_LOCAL_DECL void duk__insert_jump_entry(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
 DUK_LOCAL_DECL void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc);
 DUK_LOCAL_DECL void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
-DUK_LOCAL_DECL void duk__patch_trycatch(duk_compiler_ctx *comp_ctx, duk_int_t ldconst_pc, duk_int_t trycatch_pc, duk_regconst_t reg_catch, duk_regconst_t const_varname, duk_small_uint_t flags);
+DUK_LOCAL_DECL void duk__patch_trycatch(duk_compiler_ctx *comp_ctx,
+                                        duk_int_t ldconst_pc,
+                                        duk_int_t trycatch_pc,
+                                        duk_regconst_t reg_catch,
+                                        duk_regconst_t const_varname,
+                                        duk_small_uint_t flags);
 DUK_LOCAL_DECL void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
 DUK_LOCAL_DECL void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
 DUK_LOCAL_DECL void duk__emit_invalid(duk_compiler_ctx *comp_ctx);
 
 /* ivalue/ispec helpers */
 DUK_LOCAL_DECL void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst);
 DUK_LOCAL_DECL void duk__ivalue_plain_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
@@ -68076,97 +69337,120 @@
 DUK_LOCAL_DECL void duk__ivalue_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
 DUK_LOCAL_DECL
 duk_regconst_t duk__ivalue_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                           duk_ivalue *x,
                                           duk_regconst_t forced_reg,
                                           duk_small_uint_t flags);
 DUK_LOCAL_DECL duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL duk_regconst_t duk__ivalue_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
 #endif
 DUK_LOCAL_DECL void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg);
 DUK_LOCAL_DECL duk_regconst_t duk__ivalue_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
 DUK_LOCAL_DECL duk_regconst_t duk__ivalue_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
 
 /* identifier handling */
 DUK_LOCAL_DECL duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx);
 DUK_LOCAL_DECL duk_bool_t duk__lookup_lhs(duk_compiler_ctx *ctx, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname);
 
 /* label handling */
 DUK_LOCAL_DECL void duk__add_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_int_t pc_label, duk_int_t label_id);
 DUK_LOCAL_DECL void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags);
-DUK_LOCAL_DECL void duk__lookup_active_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_bool_t is_break, duk_int_t *out_label_id, duk_int_t *out_label_catch_depth, duk_int_t *out_label_pc, duk_bool_t *out_is_closest);
+DUK_LOCAL_DECL void duk__lookup_active_label(duk_compiler_ctx *comp_ctx,
+                                             duk_hstring *h_label,
+                                             duk_bool_t is_break,
+                                             duk_int_t *out_label_id,
+                                             duk_int_t *out_label_catch_depth,
+                                             duk_int_t *out_label_pc,
+                                             duk_bool_t *out_is_closest);
 DUK_LOCAL_DECL void duk__reset_labels_to_length(duk_compiler_ctx *comp_ctx, duk_size_t len);
 
 /* top-down expression parser */
 DUK_LOCAL_DECL void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res);
 DUK_LOCAL_DECL duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx);
 DUK_LOCAL_DECL duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx);
 
 /* exprtop is the top level variant which resets nud/led counts */
 DUK_LOCAL_DECL void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 DUK_LOCAL_DECL void duk__exprtop(duk_compiler_ctx *ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 
 /* convenience helpers */
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL duk_regconst_t duk__expr_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 #endif
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL duk_regconst_t duk__expr_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 #endif
-DUK_LOCAL_DECL void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg);
+DUK_LOCAL_DECL void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx,
+                                          duk_ivalue *res,
+                                          duk_small_uint_t rbp_flags,
+                                          duk_regconst_t forced_reg);
 DUK_LOCAL_DECL duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL duk_regconst_t duk__expr_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 #endif
 DUK_LOCAL_DECL void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 DUK_LOCAL_DECL void duk__expr_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 DUK_LOCAL_DECL duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL duk_regconst_t duk__exprtop_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 #endif
-DUK_LOCAL_DECL void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg);
+DUK_LOCAL_DECL void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx,
+                                             duk_ivalue *res,
+                                             duk_small_uint_t rbp_flags,
+                                             duk_regconst_t forced_reg);
 DUK_LOCAL_DECL duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL_DECL void duk__exprtop_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
 #endif
 
 /* expression parsing helpers */
 DUK_LOCAL_DECL duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 
 /* statement parsing */
-DUK_LOCAL_DECL void duk__parse_var_decl(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname);
+DUK_LOCAL_DECL void duk__parse_var_decl(duk_compiler_ctx *comp_ctx,
+                                        duk_ivalue *res,
+                                        duk_small_uint_t expr_flags,
+                                        duk_regconst_t *out_reg_varbind,
+                                        duk_regconst_t *out_rc_varname);
 DUK_LOCAL_DECL void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags);
 DUK_LOCAL_DECL void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
 DUK_LOCAL_DECL void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
 DUK_LOCAL_DECL void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
 DUK_LOCAL_DECL void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
 DUK_LOCAL_DECL void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
 DUK_LOCAL_DECL void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem);
 DUK_LOCAL_DECL duk_int_t duk__stmt_label_site(duk_compiler_ctx *comp_ctx, duk_int_t label_id);
-DUK_LOCAL_DECL void duk__parse_stmts(duk_compiler_ctx *comp_ctx, duk_bool_t allow_source_elem, duk_bool_t expect_eof, duk_bool_t regexp_after);
-
-DUK_LOCAL_DECL void duk__parse_func_body(duk_compiler_ctx *comp_ctx, duk_bool_t expect_eof, duk_bool_t implicit_return_value, duk_bool_t regexp_after, duk_small_int_t expect_token);
+DUK_LOCAL_DECL void duk__parse_stmts(duk_compiler_ctx *comp_ctx,
+                                     duk_bool_t allow_source_elem,
+                                     duk_bool_t expect_eof,
+                                     duk_bool_t regexp_after);
+
+DUK_LOCAL_DECL void duk__parse_func_body(duk_compiler_ctx *comp_ctx,
+                                         duk_bool_t expect_eof,
+                                         duk_bool_t implicit_return_value,
+                                         duk_bool_t regexp_after,
+                                         duk_small_int_t expect_token);
 DUK_LOCAL_DECL void duk__parse_func_formals(duk_compiler_ctx *comp_ctx);
 DUK_LOCAL_DECL void duk__parse_func_like_raw(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
 DUK_LOCAL_DECL duk_int_t duk__parse_func_like_fnum(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
 
-#define DUK__FUNC_FLAG_DECL            (1 << 0)   /* Parsing a function declaration. */
-#define DUK__FUNC_FLAG_GETSET          (1 << 1)   /* Parsing an object literal getter/setter. */
-#define DUK__FUNC_FLAG_METDEF          (1 << 2)   /* Parsing an object literal method definition shorthand. */
-#define DUK__FUNC_FLAG_PUSHNAME_PASS1  (1 << 3)   /* Push function name when creating template (first pass only). */
-#define DUK__FUNC_FLAG_USE_PREVTOKEN   (1 << 4)   /* Use prev_token to start function parsing (workaround for object literal). */
+#define DUK__FUNC_FLAG_DECL           (1 << 0) /* Parsing a function declaration. */
+#define DUK__FUNC_FLAG_GETSET         (1 << 1) /* Parsing an object literal getter/setter. */
+#define DUK__FUNC_FLAG_METDEF         (1 << 2) /* Parsing an object literal method definition shorthand. */
+#define DUK__FUNC_FLAG_PUSHNAME_PASS1 (1 << 3) /* Push function name when creating template (first pass only). */
+#define DUK__FUNC_FLAG_USE_PREVTOKEN  (1 << 4) /* Use prev_token to start function parsing (workaround for object literal). */
 
 /*
  *  Parser control values for tokens.  The token table is ordered by the
  *  DUK_TOK_XXX defines.
  *
  *  The binding powers are for lbp() use (i.e. for use in led() context).
  *  Binding powers are positive for typing convenience, and bits at the
@@ -68175,149 +69459,149 @@
  *  operators.  Currently a step of 2 is used (which frees one more bit for
  *  flags).
  */
 
 /* XXX: actually single step levels would work just fine, clean up */
 
 /* binding power "levels" (see doc/compiler.rst) */
-#define DUK__BP_INVALID                0             /* always terminates led() */
-#define DUK__BP_EOF                    2
-#define DUK__BP_CLOSING                4             /* token closes expression, e.g. ')', ']' */
-#define DUK__BP_FOR_EXPR               DUK__BP_CLOSING    /* bp to use when parsing a top level Expression */
-#define DUK__BP_COMMA                  6
-#define DUK__BP_ASSIGNMENT             8
-#define DUK__BP_CONDITIONAL            10
-#define DUK__BP_LOR                    12
-#define DUK__BP_LAND                   14
-#define DUK__BP_BOR                    16
-#define DUK__BP_BXOR                   18
-#define DUK__BP_BAND                   20
-#define DUK__BP_EQUALITY               22
-#define DUK__BP_RELATIONAL             24
-#define DUK__BP_SHIFT                  26
-#define DUK__BP_ADDITIVE               28
-#define DUK__BP_MULTIPLICATIVE         30
-#define DUK__BP_EXPONENTIATION         32
-#define DUK__BP_POSTFIX                34
-#define DUK__BP_CALL                   36
-#define DUK__BP_MEMBER                 38
+#define DUK__BP_INVALID        0 /* always terminates led() */
+#define DUK__BP_EOF            2
+#define DUK__BP_CLOSING        4 /* token closes expression, e.g. ')', ']' */
+#define DUK__BP_FOR_EXPR       DUK__BP_CLOSING /* bp to use when parsing a top level Expression */
+#define DUK__BP_COMMA          6
+#define DUK__BP_ASSIGNMENT     8
+#define DUK__BP_CONDITIONAL    10
+#define DUK__BP_LOR            12
+#define DUK__BP_LAND           14
+#define DUK__BP_BOR            16
+#define DUK__BP_BXOR           18
+#define DUK__BP_BAND           20
+#define DUK__BP_EQUALITY       22
+#define DUK__BP_RELATIONAL     24
+#define DUK__BP_SHIFT          26
+#define DUK__BP_ADDITIVE       28
+#define DUK__BP_MULTIPLICATIVE 30
+#define DUK__BP_EXPONENTIATION 32
+#define DUK__BP_POSTFIX        34
+#define DUK__BP_CALL           36
+#define DUK__BP_MEMBER         38
 
 #define DUK__TOKEN_LBP_BP_MASK         0x1f
-#define DUK__TOKEN_LBP_FLAG_NO_REGEXP  (1 << 5)   /* regexp literal must not follow this token */
-#define DUK__TOKEN_LBP_FLAG_TERMINATES (1 << 6)   /* terminates expression; e.g. post-increment/-decrement */
-#define DUK__TOKEN_LBP_FLAG_UNUSED     (1 << 7)   /* unused */
+#define DUK__TOKEN_LBP_FLAG_NO_REGEXP  (1 << 5) /* regexp literal must not follow this token */
+#define DUK__TOKEN_LBP_FLAG_TERMINATES (1 << 6) /* terminates expression; e.g. post-increment/-decrement */
+#define DUK__TOKEN_LBP_FLAG_UNUSED     (1 << 7) /* unused */
 
-#define DUK__TOKEN_LBP_GET_BP(x)       ((duk_small_uint_t) (((x) & DUK__TOKEN_LBP_BP_MASK) * 2))
+#define DUK__TOKEN_LBP_GET_BP(x) ((duk_small_uint_t) (((x) &DUK__TOKEN_LBP_BP_MASK) * 2))
 
-#define DUK__MK_LBP(bp)                ((bp) >> 1)    /* bp is assumed to be even */
-#define DUK__MK_LBP_FLAGS(bp,flags)    (((bp) >> 1) | (flags))
+#define DUK__MK_LBP(bp)              ((bp) >> 1) /* bp is assumed to be even */
+#define DUK__MK_LBP_FLAGS(bp, flags) (((bp) >> 1) | (flags))
 
 DUK_LOCAL const duk_uint8_t duk__token_lbp[] = {
-	DUK__MK_LBP(DUK__BP_EOF),                                 /* DUK_TOK_EOF */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_IDENTIFIER */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_BREAK */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_CASE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_CATCH */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_CONTINUE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_DEBUGGER */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_DEFAULT */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_DELETE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_DO */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_ELSE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_FINALLY */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_FOR */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_FUNCTION */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_IF */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_IN */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_INSTANCEOF */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_NEW */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_RETURN */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_SWITCH */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_THIS */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_THROW */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_TRY */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_TYPEOF */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_VAR */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_CONST */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_VOID */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_WHILE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_WITH */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_CLASS */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_ENUM */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_EXPORT */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_EXTENDS */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_IMPORT */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_SUPER */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_NULL */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_TRUE */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_FALSE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_GET */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_SET */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_IMPLEMENTS */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_INTERFACE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_LET */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_PACKAGE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_PRIVATE */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_PROTECTED */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_PUBLIC */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_STATIC */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_YIELD */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_LCURLY */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_RCURLY */
-	DUK__MK_LBP(DUK__BP_MEMBER),                              /* DUK_TOK_LBRACKET */
-	DUK__MK_LBP_FLAGS(DUK__BP_CLOSING, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_RBRACKET */
-	DUK__MK_LBP(DUK__BP_CALL),                                /* DUK_TOK_LPAREN */
-	DUK__MK_LBP_FLAGS(DUK__BP_CLOSING, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_RPAREN */
-	DUK__MK_LBP(DUK__BP_MEMBER),                              /* DUK_TOK_PERIOD */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_SEMICOLON */
-	DUK__MK_LBP(DUK__BP_COMMA),                               /* DUK_TOK_COMMA */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_LT */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_GT */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_LE */
-	DUK__MK_LBP(DUK__BP_RELATIONAL),                          /* DUK_TOK_GE */
-	DUK__MK_LBP(DUK__BP_EQUALITY),                            /* DUK_TOK_EQ */
-	DUK__MK_LBP(DUK__BP_EQUALITY),                            /* DUK_TOK_NEQ */
-	DUK__MK_LBP(DUK__BP_EQUALITY),                            /* DUK_TOK_SEQ */
-	DUK__MK_LBP(DUK__BP_EQUALITY),                            /* DUK_TOK_SNEQ */
-	DUK__MK_LBP(DUK__BP_ADDITIVE),                            /* DUK_TOK_ADD */
-	DUK__MK_LBP(DUK__BP_ADDITIVE),                            /* DUK_TOK_SUB */
-	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE),                      /* DUK_TOK_MUL */
-	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE),                      /* DUK_TOK_DIV */
-	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE),                      /* DUK_TOK_MOD */
-	DUK__MK_LBP(DUK__BP_EXPONENTIATION),                      /* DUK_TOK_EXP */
-	DUK__MK_LBP_FLAGS(DUK__BP_POSTFIX, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_INCREMENT */
-	DUK__MK_LBP_FLAGS(DUK__BP_POSTFIX, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_DECREMENT */
-	DUK__MK_LBP(DUK__BP_SHIFT),                               /* DUK_TOK_ALSHIFT */
-	DUK__MK_LBP(DUK__BP_SHIFT),                               /* DUK_TOK_ARSHIFT */
-	DUK__MK_LBP(DUK__BP_SHIFT),                               /* DUK_TOK_RSHIFT */
-	DUK__MK_LBP(DUK__BP_BAND),                                /* DUK_TOK_BAND */
-	DUK__MK_LBP(DUK__BP_BOR),                                 /* DUK_TOK_BOR */
-	DUK__MK_LBP(DUK__BP_BXOR),                                /* DUK_TOK_BXOR */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_LNOT */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_BNOT */
-	DUK__MK_LBP(DUK__BP_LAND),                                /* DUK_TOK_LAND */
-	DUK__MK_LBP(DUK__BP_LOR),                                 /* DUK_TOK_LOR */
-	DUK__MK_LBP(DUK__BP_CONDITIONAL),                         /* DUK_TOK_QUESTION */
-	DUK__MK_LBP(DUK__BP_INVALID),                             /* DUK_TOK_COLON */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_EQUALSIGN */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_ADD_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_SUB_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_MUL_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_DIV_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_MOD_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_EXP_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_ALSHIFT_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_ARSHIFT_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_RSHIFT_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_BAND_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_BOR_EQ */
-	DUK__MK_LBP(DUK__BP_ASSIGNMENT),                          /* DUK_TOK_BXOR_EQ */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_NUMBER */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_STRING */
-	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP),  /* DUK_TOK_REGEXP */
+	DUK__MK_LBP(DUK__BP_EOF), /* DUK_TOK_EOF */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_IDENTIFIER */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_BREAK */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_CASE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_CATCH */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_CONTINUE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_DEBUGGER */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_DEFAULT */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_DELETE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_DO */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_ELSE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_FINALLY */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_FOR */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_FUNCTION */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_IF */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_IN */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_INSTANCEOF */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_NEW */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_RETURN */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_SWITCH */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_THIS */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_THROW */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_TRY */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_TYPEOF */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_VAR */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_CONST */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_VOID */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_WHILE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_WITH */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_CLASS */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_ENUM */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_EXPORT */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_EXTENDS */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_IMPORT */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_SUPER */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_NULL */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_TRUE */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_FALSE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_GET */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_SET */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_IMPLEMENTS */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_INTERFACE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_LET */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_PACKAGE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_PRIVATE */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_PROTECTED */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_PUBLIC */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_STATIC */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_YIELD */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_LCURLY */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_RCURLY */
+	DUK__MK_LBP(DUK__BP_MEMBER), /* DUK_TOK_LBRACKET */
+	DUK__MK_LBP_FLAGS(DUK__BP_CLOSING, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_RBRACKET */
+	DUK__MK_LBP(DUK__BP_CALL), /* DUK_TOK_LPAREN */
+	DUK__MK_LBP_FLAGS(DUK__BP_CLOSING, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_RPAREN */
+	DUK__MK_LBP(DUK__BP_MEMBER), /* DUK_TOK_PERIOD */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_SEMICOLON */
+	DUK__MK_LBP(DUK__BP_COMMA), /* DUK_TOK_COMMA */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_LT */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_GT */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_LE */
+	DUK__MK_LBP(DUK__BP_RELATIONAL), /* DUK_TOK_GE */
+	DUK__MK_LBP(DUK__BP_EQUALITY), /* DUK_TOK_EQ */
+	DUK__MK_LBP(DUK__BP_EQUALITY), /* DUK_TOK_NEQ */
+	DUK__MK_LBP(DUK__BP_EQUALITY), /* DUK_TOK_SEQ */
+	DUK__MK_LBP(DUK__BP_EQUALITY), /* DUK_TOK_SNEQ */
+	DUK__MK_LBP(DUK__BP_ADDITIVE), /* DUK_TOK_ADD */
+	DUK__MK_LBP(DUK__BP_ADDITIVE), /* DUK_TOK_SUB */
+	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE), /* DUK_TOK_MUL */
+	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE), /* DUK_TOK_DIV */
+	DUK__MK_LBP(DUK__BP_MULTIPLICATIVE), /* DUK_TOK_MOD */
+	DUK__MK_LBP(DUK__BP_EXPONENTIATION), /* DUK_TOK_EXP */
+	DUK__MK_LBP_FLAGS(DUK__BP_POSTFIX, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_INCREMENT */
+	DUK__MK_LBP_FLAGS(DUK__BP_POSTFIX, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_DECREMENT */
+	DUK__MK_LBP(DUK__BP_SHIFT), /* DUK_TOK_ALSHIFT */
+	DUK__MK_LBP(DUK__BP_SHIFT), /* DUK_TOK_ARSHIFT */
+	DUK__MK_LBP(DUK__BP_SHIFT), /* DUK_TOK_RSHIFT */
+	DUK__MK_LBP(DUK__BP_BAND), /* DUK_TOK_BAND */
+	DUK__MK_LBP(DUK__BP_BOR), /* DUK_TOK_BOR */
+	DUK__MK_LBP(DUK__BP_BXOR), /* DUK_TOK_BXOR */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_LNOT */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_BNOT */
+	DUK__MK_LBP(DUK__BP_LAND), /* DUK_TOK_LAND */
+	DUK__MK_LBP(DUK__BP_LOR), /* DUK_TOK_LOR */
+	DUK__MK_LBP(DUK__BP_CONDITIONAL), /* DUK_TOK_QUESTION */
+	DUK__MK_LBP(DUK__BP_INVALID), /* DUK_TOK_COLON */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_EQUALSIGN */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_ADD_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_SUB_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_MUL_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_DIV_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_MOD_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_EXP_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_ALSHIFT_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_ARSHIFT_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_RSHIFT_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_BAND_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_BOR_EQ */
+	DUK__MK_LBP(DUK__BP_ASSIGNMENT), /* DUK_TOK_BXOR_EQ */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_NUMBER */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_STRING */
+	DUK__MK_LBP_FLAGS(DUK__BP_INVALID, DUK__TOKEN_LBP_FLAG_NO_REGEXP), /* DUK_TOK_REGEXP */
 };
 
 /*
  *  Misc helpers
  */
 
 DUK_LOCAL void duk__comp_recursion_increase(duk_compiler_ctx *comp_ctx) {
@@ -68340,32 +69624,31 @@
 	DUK_UNREF(comp_ctx);
 	DUK_ASSERT(h != NULL);
 	return DUK_HSTRING_HAS_EVAL_OR_ARGUMENTS(h);
 }
 
 DUK_LOCAL duk_bool_t duk__hstring_is_eval_or_arguments_in_strict_mode(duk_compiler_ctx *comp_ctx, duk_hstring *h) {
 	DUK_ASSERT(h != NULL);
-	return (comp_ctx->curr_func.is_strict &&
-	        DUK_HSTRING_HAS_EVAL_OR_ARGUMENTS(h));
+	return (comp_ctx->curr_func.is_strict && DUK_HSTRING_HAS_EVAL_OR_ARGUMENTS(h));
 }
 
 /*
  *  Parser duk__advance() token eating functions
  */
 
 /* XXX: valstack handling is awkward.  Add a valstack helper which
  * avoids dup():ing; valstack_copy(src, dst)?
  */
 
 DUK_LOCAL void duk__advance_helper(duk_compiler_ctx *comp_ctx, duk_small_int_t expect) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_bool_t regexp;
 
-	DUK_ASSERT_DISABLE(comp_ctx->curr_token.t >= 0);  /* unsigned */
-	DUK_ASSERT(comp_ctx->curr_token.t <= DUK_TOK_MAXVAL);  /* MAXVAL is inclusive */
+	DUK_ASSERT_DISABLE(comp_ctx->curr_token.t >= 0); /* unsigned */
+	DUK_ASSERT(comp_ctx->curr_token.t <= DUK_TOK_MAXVAL); /* MAXVAL is inclusive */
 
 	/*
 	 *  Use current token to decide whether a RegExp can follow.
 	 *
 	 *  We can use either 't' or 't_nores'; the latter would not
 	 *  recognize keywords.  Some keywords can be followed by a
 	 *  RegExp (e.g. "return"), so using 't' is better.  This is
@@ -68382,30 +69665,26 @@
 	}
 	if (comp_ctx->curr_func.allow_regexp_in_adv) {
 		comp_ctx->curr_func.allow_regexp_in_adv = 0;
 		regexp = 1;
 	}
 
 	if (expect >= 0 && comp_ctx->curr_token.t != (duk_small_uint_t) expect) {
-		DUK_D(DUK_DPRINT("parse error: expect=%ld, got=%ld",
-		                 (long) expect, (long) comp_ctx->curr_token.t));
+		DUK_D(DUK_DPRINT("parse error: expect=%ld, got=%ld", (long) expect, (long) comp_ctx->curr_token.t));
 		DUK_ERROR_SYNTAX(thr, DUK_STR_PARSE_ERROR);
 		DUK_WO_NORETURN(return;);
 	}
 
 	/* make current token the previous; need to fiddle with valstack "backing store" */
 	duk_memcpy(&comp_ctx->prev_token, &comp_ctx->curr_token, sizeof(duk_token));
 	duk_copy(thr, comp_ctx->tok11_idx, comp_ctx->tok21_idx);
 	duk_copy(thr, comp_ctx->tok12_idx, comp_ctx->tok22_idx);
 
 	/* parse new token */
-	duk_lexer_parse_js_input_element(&comp_ctx->lex,
-	                                 &comp_ctx->curr_token,
-	                                 comp_ctx->curr_func.is_strict,
-	                                 regexp);
+	duk_lexer_parse_js_input_element(&comp_ctx->lex, &comp_ctx->curr_token, comp_ctx->curr_func.is_strict, regexp);
 
 	DUK_DDD(DUK_DDDPRINT("advance: curr: tok=%ld/%ld,%ld,term=%ld,%!T,%!T "
 	                     "prev: tok=%ld/%ld,%ld,term=%ld,%!T,%!T",
 	                     (long) comp_ctx->curr_token.t,
 	                     (long) comp_ctx->curr_token.t_nores,
 	                     (long) comp_ctx->curr_token.start_line,
 	                     (long) comp_ctx->curr_token.lineterm,
@@ -68437,15 +69716,15 @@
 DUK_LOCAL void duk__init_func_valstack_slots(duk_compiler_ctx *comp_ctx) {
 	duk_compiler_func *func = &comp_ctx->curr_func;
 	duk_hthread *thr = comp_ctx->thr;
 	duk_idx_t entry_top;
 
 	entry_top = duk_get_top(thr);
 
-	duk_memzero(func, sizeof(*func));  /* intentional overlap with earlier memzero */
+	duk_memzero(func, sizeof(*func)); /* intentional overlap with earlier memzero */
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 	func->h_name = NULL;
 	func->h_consts = NULL;
 	func->h_funcs = NULL;
 	func->h_decls = NULL;
 	func->h_labelnames = NULL;
 	func->h_labelinfos = NULL;
@@ -68603,15 +69882,15 @@
 	 */
 
 	/* Valstack should suffice here, required on function valstack init */
 
 	h_res = duk_push_hcompfunc(thr);
 	DUK_ASSERT(h_res != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) h_res) == thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE]);
-	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, (duk_hobject *) h_res, NULL);  /* Function templates are "bare objects". */
+	DUK_HOBJECT_SET_PROTOTYPE_UPDREF(thr, (duk_hobject *) h_res, NULL); /* Function templates are "bare objects". */
 
 	if (func->is_function) {
 		DUK_DDD(DUK_DDDPRINT("function -> set NEWENV"));
 		DUK_HOBJECT_SET_NEWENV((duk_hobject *) h_res);
 
 		if (!func->is_arguments_shadowed) {
 			/* arguments object would be accessible; note that shadowing
@@ -68672,89 +69951,91 @@
 	 */
 
 	consts_count = duk_hobject_get_length(thr, func->h_consts);
 	funcs_count = duk_hobject_get_length(thr, func->h_funcs) / 3;
 	code_count = DUK_BW_GET_SIZE(thr, &func->bw_code) / sizeof(duk_compiler_instr);
 	code_size = code_count * sizeof(duk_instr_t);
 
-	data_size = consts_count * sizeof(duk_tval) +
-	            funcs_count * sizeof(duk_hobject *) +
-	            code_size;
+	data_size = consts_count * sizeof(duk_tval) + funcs_count * sizeof(duk_hobject *) + code_size;
 
 	DUK_DDD(DUK_DDDPRINT("consts_count=%ld, funcs_count=%ld, code_size=%ld -> "
 	                     "data_size=%ld*%ld + %ld*%ld + %ld = %ld",
-	                     (long) consts_count, (long) funcs_count, (long) code_size,
-	                     (long) consts_count, (long) sizeof(duk_tval),
-	                     (long) funcs_count, (long) sizeof(duk_hobject *),
-	                     (long) code_size, (long) data_size));
+	                     (long) consts_count,
+	                     (long) funcs_count,
+	                     (long) code_size,
+	                     (long) consts_count,
+	                     (long) sizeof(duk_tval),
+	                     (long) funcs_count,
+	                     (long) sizeof(duk_hobject *),
+	                     (long) code_size,
+	                     (long) data_size));
 
 	duk_push_fixed_buffer_nozero(thr, data_size);
 	h_data = (duk_hbuffer_fixed *) (void *) duk_known_hbuffer(thr, -1);
 
 	DUK_HCOMPFUNC_SET_DATA(thr->heap, h_res, (duk_hbuffer *) h_data);
 	DUK_HEAPHDR_INCREF(thr, h_data);
 
 	p_const = (duk_tval *) (void *) DUK_HBUFFER_FIXED_GET_DATA_PTR(thr->heap, h_data);
 	for (i = 0; i < consts_count; i++) {
-		DUK_ASSERT(i <= DUK_UARRIDX_MAX);  /* const limits */
+		DUK_ASSERT(i <= DUK_UARRIDX_MAX); /* const limits */
 		tv = duk_hobject_find_array_entry_tval_ptr(thr->heap, func->h_consts, (duk_uarridx_t) i);
 		DUK_ASSERT(tv != NULL);
 		DUK_TVAL_SET_TVAL(p_const, tv);
 		p_const++;
-		DUK_TVAL_INCREF(thr, tv);  /* may be a string constant */
+		DUK_TVAL_INCREF(thr, tv); /* may be a string constant */
 
 		DUK_DDD(DUK_DDDPRINT("constant: %!T", (duk_tval *) tv));
 	}
 
 	p_func = (duk_hobject **) p_const;
 	DUK_HCOMPFUNC_SET_FUNCS(thr->heap, h_res, p_func);
 	for (i = 0; i < funcs_count; i++) {
 		duk_hobject *h;
-		DUK_ASSERT(i * 3 <= DUK_UARRIDX_MAX);  /* func limits */
+		DUK_ASSERT(i * 3 <= DUK_UARRIDX_MAX); /* func limits */
 		tv = duk_hobject_find_array_entry_tval_ptr(thr->heap, func->h_funcs, (duk_uarridx_t) (i * 3));
 		DUK_ASSERT(tv != NULL);
 		DUK_ASSERT(DUK_TVAL_IS_OBJECT(tv));
 		h = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(h != NULL);
 		DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(h));
 		*p_func++ = h;
 		DUK_HOBJECT_INCREF(thr, h);
 
-		DUK_DDD(DUK_DDDPRINT("inner function: %p -> %!iO",
-		                     (void *) h, (duk_heaphdr *) h));
+		DUK_DDD(DUK_DDDPRINT("inner function: %p -> %!iO", (void *) h, (duk_heaphdr *) h));
 	}
 
 	p_instr = (duk_instr_t *) p_func;
 	DUK_HCOMPFUNC_SET_BYTECODE(thr->heap, h_res, p_instr);
 
 	/* copy bytecode instructions one at a time */
 	q_instr = (duk_compiler_instr *) (void *) DUK_BW_GET_BASEPTR(thr, &func->bw_code);
 	for (i = 0; i < code_count; i++) {
 		p_instr[i] = q_instr[i].ins;
 	}
 	/* Note: 'q_instr' is still used below */
 
 	DUK_ASSERT((duk_uint8_t *) (p_instr + code_count) == DUK_HBUFFER_FIXED_GET_DATA_PTR(thr->heap, h_data) + data_size);
 
-	duk_pop(thr);  /* 'data' (and everything in it) is reachable through h_res now */
+	duk_pop(thr); /* 'data' (and everything in it) is reachable through h_res now */
 
 	/*
 	 *  Init non-property result fields
 	 *
 	 *  'nregs' controls how large a register frame is allocated.
 	 *
 	 *  'nargs' controls how many formal arguments are written to registers:
 	 *  r0, ... r(nargs-1).  The remaining registers are initialized to
 	 *  undefined.
 	 */
 
 	DUK_ASSERT(func->temp_max >= 0);
 	h_res->nregs = (duk_uint16_t) func->temp_max;
 	h_res->nargs = (duk_uint16_t) duk_hobject_get_length(thr, func->h_argnames);
-	DUK_ASSERT(h_res->nregs >= h_res->nargs);  /* pass2 allocation handles this */
+	DUK_ASSERT(h_res->nregs >= h_res->nargs); /* pass2 allocation handles this */
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	h_res->start_line = (duk_uint32_t) func->min_line;
 	h_res->end_line = (duk_uint32_t) func->max_line;
 #endif
 
 	/*
 	 *  Init object properties
@@ -68774,32 +70055,33 @@
 	 * always need the varmap to be able to lookup variables at any point.
 	 */
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 	DUK_DD(DUK_DDPRINT("keeping _Varmap because debugger support is enabled"));
 	keep_varmap = 1;
 #else
-	if (func->id_access_slow_own ||   /* directly uses slow accesses that may match own variables */
-	    func->id_access_arguments ||  /* accesses 'arguments' directly */
-	    func->may_direct_eval ||      /* may indirectly slow access through a direct eval */
-	    funcs_count > 0) {            /* has inner functions which may slow access (XXX: this can be optimized by looking at the inner functions) */
-		DUK_DD(DUK_DDPRINT("keeping _Varmap because of direct eval, slow path access that may match local variables, or presence of inner functions"));
+	if (func->id_access_slow_own || /* directly uses slow accesses that may match own variables */
+	    func->id_access_arguments || /* accesses 'arguments' directly */
+	    func->may_direct_eval || /* may indirectly slow access through a direct eval */
+	    funcs_count >
+	        0) { /* has inner functions which may slow access (XXX: this can be optimized by looking at the inner functions) */
+		DUK_DD(DUK_DDPRINT("keeping _Varmap because of direct eval, slow path access that may match local variables, or "
+		                   "presence of inner functions"));
 		keep_varmap = 1;
 	} else {
 		DUK_DD(DUK_DDPRINT("dropping _Varmap"));
 		keep_varmap = 0;
 	}
 #endif
 
 	if (keep_varmap) {
 		duk_int_t num_used;
 		duk_dup(thr, func->varmap_idx);
 		num_used = duk__cleanup_varmap(comp_ctx);
-		DUK_DDD(DUK_DDDPRINT("cleaned up varmap: %!T (num_used=%ld)",
-		                     (duk_tval *) duk_get_tval(thr, -1), (long) num_used));
+		DUK_DDD(DUK_DDDPRINT("cleaned up varmap: %!T (num_used=%ld)", (duk_tval *) duk_get_tval(thr, -1), (long) num_used));
 
 		if (num_used > 0) {
 			duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_VARMAP, DUK_PROPDESC_FLAGS_NONE);
 		} else {
 			DUK_DD(DUK_DDPRINT("varmap is empty after cleanup -> no need to add"));
 			duk_pop(thr);
 		}
@@ -68820,20 +70102,20 @@
 	formals_length = duk_get_length(thr, func->argnames_idx);
 	if (formals_length != (duk_size_t) h_res->nargs) {
 		/* Nargs not enough for closure .length: keep _Formals regardless
 		 * of its length.  Shouldn't happen in practice at the moment.
 		 */
 		DUK_DD(DUK_DDPRINT("keeping _Formals because _Formals.length != nargs"));
 		keep_formals = 1;
-	} else if ((func->id_access_arguments || func->may_direct_eval) &&
-	           (formals_length > 0)) {
+	} else if ((func->id_access_arguments || func->may_direct_eval) && (formals_length > 0)) {
 		/* Direct eval (may access 'arguments') or accesses 'arguments'
 		 * explicitly: keep _Formals unless it is zero length.
 		 */
-		DUK_DD(DUK_DDPRINT("keeping _Formals because of direct eval or explicit access to 'arguments', and _Formals.length != 0"));
+		DUK_DD(DUK_DDPRINT(
+		    "keeping _Formals because of direct eval or explicit access to 'arguments', and _Formals.length != 0"));
 		keep_formals = 1;
 	} else {
 		DUK_DD(DUK_DDPRINT("omitting _Formals, nargs matches _Formals.length, so no properties added"));
 		keep_formals = 0;
 	}
 #endif
 
@@ -68845,15 +70127,15 @@
 	/* name */
 #if defined(DUK_USE_FUNC_NAME_PROPERTY)
 	if (func->h_name) {
 		duk_push_hstring(thr, func->h_name);
 		DUK_DD(DUK_DDPRINT("setting function template .name to %!T", duk_get_tval(thr, -1)));
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_NONE);
 	}
-#endif  /* DUK_USE_FUNC_NAME_PROPERTY */
+#endif /* DUK_USE_FUNC_NAME_PROPERTY */
 
 	/* _Source */
 #if defined(DUK_USE_NONSTD_FUNC_SOURCE_PROPERTY)
 	if (0) {
 		/* XXX: Currently function source code is not stored, as it is not
 		 * required by the standard.  Source code should not be stored by
 		 * default (user should enable it explicitly), and the source should
@@ -68893,47 +70175,46 @@
 		 */
 
 #if 0
 		duk_push_literal(thr, "XXX");
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_SOURCE, DUK_PROPDESC_FLAGS_NONE);
 #endif
 	}
-#endif  /* DUK_USE_NONSTD_FUNC_SOURCE_PROPERTY */
+#endif /* DUK_USE_NONSTD_FUNC_SOURCE_PROPERTY */
 
 	/* _Pc2line */
 #if defined(DUK_USE_PC2LINE)
 	if (1) {
 		/*
 		 *  Size-optimized pc->line mapping.
 		 */
 
 		DUK_ASSERT(code_count <= DUK_COMPILER_MAX_BYTECODE_LENGTH);
-		duk_hobject_pc2line_pack(thr, q_instr, (duk_uint_fast32_t) code_count);  /* -> pushes fixed buffer */
+		duk_hobject_pc2line_pack(thr, q_instr, (duk_uint_fast32_t) code_count); /* -> pushes fixed buffer */
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_INT_PC2LINE, DUK_PROPDESC_FLAGS_NONE);
 
 		/* XXX: if assertions enabled, walk through all valid PCs
 		 * and check line mapping.
 		 */
 	}
-#endif  /* DUK_USE_PC2LINE */
+#endif /* DUK_USE_PC2LINE */
 
 	/* fileName */
 #if defined(DUK_USE_FUNC_FILENAME_PROPERTY)
 	if (comp_ctx->h_filename) {
 		/*
 		 *  Source filename (or equivalent), for identifying thrown errors.
 		 */
 
 		duk_push_hstring(thr, comp_ctx->h_filename);
 		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_FILE_NAME, DUK_PROPDESC_FLAGS_NONE);
 	}
 #endif
 
-	DUK_DD(DUK_DDPRINT("converted function: %!ixT",
-	                   (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DD(DUK_DDPRINT("converted function: %!ixT", (duk_tval *) duk_get_tval(thr, -1)));
 
 	/*
 	 *  Compact the function template.
 	 */
 
 	duk_compact_m1(thr);
 
@@ -68997,33 +70278,34 @@
  *  There is call handling specific understanding in the A-B-C emitter to
  *  convert call setup and call instructions into indirect ones if necessary.
  */
 
 /* Code emission flags, passed in the 'opcode' field.  Opcode + flags
  * fit into 16 bits for now, so use duk_small_uint_t.
  */
-#define DUK__EMIT_FLAG_NO_SHUFFLE_A      (1 << 8)
-#define DUK__EMIT_FLAG_NO_SHUFFLE_B      (1 << 9)
-#define DUK__EMIT_FLAG_NO_SHUFFLE_C      (1 << 10)
-#define DUK__EMIT_FLAG_A_IS_SOURCE       (1 << 11)  /* slot A is a source (default: target) */
-#define DUK__EMIT_FLAG_B_IS_TARGET       (1 << 12)  /* slot B is a target (default: source) */
-#define DUK__EMIT_FLAG_C_IS_TARGET       (1 << 13)  /* slot C is a target (default: source) */
-#define DUK__EMIT_FLAG_BC_REGCONST       (1 << 14)  /* slots B and C are reg/const */
-#define DUK__EMIT_FLAG_RESERVE_JUMPSLOT  (1 << 15)  /* reserve a jumpslot after instr before target spilling, used for NEXTENUM */
+#define DUK__EMIT_FLAG_NO_SHUFFLE_A     (1 << 8)
+#define DUK__EMIT_FLAG_NO_SHUFFLE_B     (1 << 9)
+#define DUK__EMIT_FLAG_NO_SHUFFLE_C     (1 << 10)
+#define DUK__EMIT_FLAG_A_IS_SOURCE      (1 << 11) /* slot A is a source (default: target) */
+#define DUK__EMIT_FLAG_B_IS_TARGET      (1 << 12) /* slot B is a target (default: source) */
+#define DUK__EMIT_FLAG_C_IS_TARGET      (1 << 13) /* slot C is a target (default: source) */
+#define DUK__EMIT_FLAG_BC_REGCONST      (1 << 14) /* slots B and C are reg/const */
+#define DUK__EMIT_FLAG_RESERVE_JUMPSLOT (1 << 15) /* reserve a jumpslot after instr before target spilling, used for NEXTENUM */
 
 /* XXX: macro smaller than call? */
 DUK_LOCAL duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx) {
 	duk_compiler_func *func;
 	func = &comp_ctx->curr_func;
 	return (duk_int_t) (DUK_BW_GET_SIZE(comp_ctx->thr, &func->bw_code) / sizeof(duk_compiler_instr));
 }
 
 DUK_LOCAL duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc) {
 	DUK_ASSERT(pc >= 0);
-	DUK_ASSERT((duk_size_t) pc < (duk_size_t) (DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) / sizeof(duk_compiler_instr)));
+	DUK_ASSERT((duk_size_t) pc <
+	           (duk_size_t) (DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) / sizeof(duk_compiler_instr)));
 	return ((duk_compiler_instr *) (void *) DUK_BW_GET_BASEPTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code)) + pc;
 }
 
 /* emit instruction; could return PC but that's not needed in the majority
  * of cases.
  */
 DUK_LOCAL void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins) {
@@ -69035,15 +70317,17 @@
 	DUK_DDD(DUK_DDDPRINT("duk__emit: 0x%08lx curr_token.start_line=%ld prev_token.start_line=%ld pc=%ld --> %!I",
 	                     (unsigned long) ins,
 	                     (long) comp_ctx->curr_token.start_line,
 	                     (long) comp_ctx->prev_token.start_line,
 	                     (long) duk__get_current_pc(comp_ctx),
 	                     (duk_instr_t) ins));
 
-	instr = (duk_compiler_instr *) (void *) DUK_BW_ENSURE_GETPTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code, sizeof(duk_compiler_instr));
+	instr = (duk_compiler_instr *) (void *) DUK_BW_ENSURE_GETPTR(comp_ctx->thr,
+	                                                             &comp_ctx->curr_func.bw_code,
+	                                                             sizeof(duk_compiler_instr));
 	DUK_BW_ADD_PTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code, sizeof(duk_compiler_instr));
 
 #if defined(DUK_USE_PC2LINE)
 	/* The line number tracking is a bit inconsistent right now, which
 	 * affects debugger accuracy.  Mostly call sites emit opcodes when
 	 * they have parsed a token (say a terminating semicolon) and called
 	 * duk__advance().  In this case the line number of the previous
@@ -69086,15 +70370,15 @@
 		goto fail_bc_limit;
 	}
 #endif
 #endif
 
 	return;
 
-  fail_bc_limit:
+fail_bc_limit:
 	DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_BYTECODE_LIMIT);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Update function min/max line from current token.  Needed to improve
  * function line range information for debugging, so that e.g. opening
  * curly brace is covered by line range even when no opcodes are emitted
@@ -69120,37 +70404,40 @@
 }
 
 DUK_LOCAL void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op) {
 	duk__emit(comp_ctx, DUK_ENC_OP_ABC(op, 0));
 }
 
 /* Important main primitive. */
-DUK_LOCAL void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b, duk_regconst_t c) {
+DUK_LOCAL void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx,
+                               duk_small_uint_t op_flags,
+                               duk_regconst_t a,
+                               duk_regconst_t b,
+                               duk_regconst_t c) {
 	duk_instr_t ins = 0;
 	duk_int_t a_out = -1;
 	duk_int_t b_out = -1;
 	duk_int_t c_out = -1;
 	duk_int_t tmp;
 	duk_small_uint_t op = op_flags & 0xffU;
 
-	DUK_DDD(DUK_DDDPRINT("emit: op_flags=%04lx, a=%ld, b=%ld, c=%ld",
-	                     (unsigned long) op_flags, (long) a, (long) b, (long) c));
+	DUK_DDD(DUK_DDDPRINT("emit: op_flags=%04lx, a=%ld, b=%ld, c=%ld", (unsigned long) op_flags, (long) a, (long) b, (long) c));
 
 	/* We could rely on max temp/const checks: if they don't exceed BC
 	 * limit, nothing here can either (just asserts would be enough).
 	 * Currently we check for the limits, which provides additional
 	 * protection against creating invalid bytecode due to compiler
 	 * bugs.
 	 */
 
-	DUK_ASSERT_DISABLE((op_flags & 0xff) >= DUK_BC_OP_MIN);  /* unsigned */
+	DUK_ASSERT_DISABLE((op_flags & 0xff) >= DUK_BC_OP_MIN); /* unsigned */
 	DUK_ASSERT((op_flags & 0xff) <= DUK_BC_OP_MAX);
 	DUK_ASSERT(DUK__ISREG(a));
-	DUK_ASSERT(b != -1);  /* Not 'none'. */
-	DUK_ASSERT(c != -1);  /* Not 'none'. */
+	DUK_ASSERT(b != -1); /* Not 'none'. */
+	DUK_ASSERT(c != -1); /* Not 'none'. */
 
 	/* Input shuffling happens before the actual operation, while output
 	 * shuffling happens afterwards.  Output shuffling decisions are still
 	 * made at the same time to reduce branch clutter; output shuffle decisions
 	 * are recorded into X_out variables.
 	 */
 
@@ -69204,15 +70491,15 @@
 		if (0) {
 #else
 		if (b <= 0xff) {
 #endif
 			if (op_flags & DUK__EMIT_FLAG_BC_REGCONST) {
 				/* Opcode follows B/C reg/const convention. */
 				DUK_ASSERT((op & 0x01) == 0);
-				ins |= DUK_ENC_OP_A_B_C(0x01, 0, 0, 0);  /* const flag for B */
+				ins |= DUK_ENC_OP_A_B_C(0x01, 0, 0, 0); /* const flag for B */
 			} else {
 				DUK_D(DUK_DPRINT("B is const, opcode is not B/C reg/const: %x", op_flags));
 			}
 		} else if (b <= DUK_BC_BC_MAX) {
 			comp_ctx->curr_func.needs_shuffle = 1;
 			tmp = comp_ctx->curr_func.shuffle2;
 			duk__emit(comp_ctx, DUK_ENC_OP_A_BC(DUK_OP_LDCONST, tmp, b));
@@ -69227,15 +70514,16 @@
 #else
 		if (b <= 0xff) {
 #endif
 			;
 		} else if (op_flags & DUK__EMIT_FLAG_NO_SHUFFLE_B) {
 			if (b > DUK_BC_B_MAX) {
 				/* Note: 0xff != DUK_BC_B_MAX */
-				DUK_D(DUK_DPRINT("out of regs: 'b' (reg) needs shuffling but shuffle prohibited, b: %ld", (long) b));
+				DUK_D(
+				    DUK_DPRINT("out of regs: 'b' (reg) needs shuffling but shuffle prohibited, b: %ld", (long) b));
 				goto error_outofregs;
 			}
 		} else if (b <= DUK_BC_BC_MAX) {
 			comp_ctx->curr_func.needs_shuffle = 1;
 			tmp = comp_ctx->curr_func.shuffle2;
 			if (op_flags & DUK__EMIT_FLAG_B_IS_TARGET) {
 				/* Output shuffle needed after main operation */
@@ -69248,15 +70536,15 @@
 					 * of registers, so normal shuffling won't work.  Instead,
 					 * an indirect version of the opcode is used.
 					 */
 					DUK_ASSERT((op_flags & DUK__EMIT_FLAG_B_IS_TARGET) == 0);
 					duk__emit_load_int32_noshuffle(comp_ctx, tmp, b);
 					DUK_ASSERT(DUK_OP_MPUTOBJI == DUK_OP_MPUTOBJ + 1);
 					DUK_ASSERT(DUK_OP_MPUTARRI == DUK_OP_MPUTARR + 1);
-					op_flags++;  /* indirect opcode follows direct */
+					op_flags++; /* indirect opcode follows direct */
 				} else {
 					duk__emit(comp_ctx, DUK_ENC_OP_A_BC(DUK_OP_LDREG, tmp, b));
 				}
 			}
 			b = tmp;
 		} else {
 			DUK_D(DUK_DPRINT("out of regs: 'b' (reg) needs shuffling but does not fit into BC, b: %ld", (long) b));
@@ -69274,15 +70562,15 @@
 		if (0) {
 #else
 		if (c <= 0xff) {
 #endif
 			if (op_flags & DUK__EMIT_FLAG_BC_REGCONST) {
 				/* Opcode follows B/C reg/const convention. */
 				DUK_ASSERT((op & 0x02) == 0);
-				ins |= DUK_ENC_OP_A_B_C(0x02, 0, 0, 0);  /* const flag for C */
+				ins |= DUK_ENC_OP_A_B_C(0x02, 0, 0, 0); /* const flag for C */
 			} else {
 				DUK_D(DUK_DPRINT("C is const, opcode is not B/C reg/const: %x", op_flags));
 			}
 		} else if (c <= DUK_BC_BC_MAX) {
 			comp_ctx->curr_func.needs_shuffle = 1;
 			tmp = comp_ctx->curr_func.shuffle3;
 			duk__emit(comp_ctx, DUK_ENC_OP_A_BC(DUK_OP_LDCONST, tmp, c));
@@ -69297,15 +70585,16 @@
 #else
 		if (c <= 0xff) {
 #endif
 			;
 		} else if (op_flags & DUK__EMIT_FLAG_NO_SHUFFLE_C) {
 			if (c > DUK_BC_C_MAX) {
 				/* Note: 0xff != DUK_BC_C_MAX */
-				DUK_D(DUK_DPRINT("out of regs: 'c' (reg) needs shuffling but shuffle prohibited, c: %ld", (long) c));
+				DUK_D(
+				    DUK_DPRINT("out of regs: 'c' (reg) needs shuffling but shuffle prohibited, c: %ld", (long) c));
 				goto error_outofregs;
 			}
 		} else if (c <= DUK_BC_BC_MAX) {
 			comp_ctx->curr_func.needs_shuffle = 1;
 			tmp = comp_ctx->curr_func.shuffle3;
 			if (op_flags & DUK__EMIT_FLAG_C_IS_TARGET) {
 				/* Output shuffle needed after main operation */
@@ -69371,15 +70660,15 @@
 		DUK_ASSERT(b_out < 0);
 		DUK_ASSERT(c_out < 0);
 		duk__emit(comp_ctx, DUK_ENC_OP_A_BC(DUK_OP_STREG, c, c_out));
 	}
 
 	return;
 
- error_outofregs:
+error_outofregs:
 	DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_REG_LIMIT);
 	DUK_WO_NORETURN(return;);
 }
 
 /* For many of the helpers below it'd be technically correct to add
  * "no shuffle" flags for parameters passed in as zero.  For example,
  * duk__emit_a_b() should call duk__emit_a_b_c() with C set to 0, and
@@ -69399,41 +70688,41 @@
 DUK_LOCAL void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c) {
 #if defined(DUK_USE_SHUFFLE_TORTURE)
 	op_flags |= DUK__EMIT_FLAG_NO_SHUFFLE_A;
 #endif
 	duk__emit_a_b_c(comp_ctx, op_flags, 0, b, c);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL void duk__emit_a(duk_compiler_ctx *comp_ctx, int op_flags, int a) {
 #if defined(DUK_USE_SHUFFLE_TORTURE)
 	op_flags |= DUK__EMIT_FLAG_NO_SHUFFLE_B | DUK__EMIT_FLAG_NO_SHUFFLE_C;
 #endif
 	duk__emit_a_b_c(comp_ctx, op_flags, a, 0, 0);
 }
 #endif
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL void duk__emit_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b) {
 #if defined(DUK_USE_SHUFFLE_TORTURE)
 	op_flags |= DUK__EMIT_FLAG_NO_SHUFFLE_A | DUK__EMIT_FLAG_NO_SHUFFLE_C;
 #endif
 	duk__emit_a_b_c(comp_ctx, op_flags, 0, b, 0);
 }
 #endif
 
 DUK_LOCAL void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc) {
 	duk_instr_t ins;
 	duk_int_t tmp;
 
 	/* allow caller to give a const number with the DUK__CONST_MARKER */
-	DUK_ASSERT(bc != -1);  /* Not 'none'. */
+	DUK_ASSERT(bc != -1); /* Not 'none'. */
 	bc = bc & (~DUK__CONST_MARKER);
 
-	DUK_ASSERT_DISABLE((op_flags & 0xff) >= DUK_BC_OP_MIN);  /* unsigned */
+	DUK_ASSERT_DISABLE((op_flags & 0xff) >= DUK_BC_OP_MIN); /* unsigned */
 	DUK_ASSERT((op_flags & 0xff) <= DUK_BC_OP_MAX);
 	DUK_ASSERT(bc >= DUK_BC_BC_MIN);
 	DUK_ASSERT(bc <= DUK_BC_BC_MAX);
 	DUK_ASSERT((bc & DUK__CONST_MARKER) == 0);
 
 	if (bc <= DUK_BC_BC_MAX) {
 		;
@@ -69470,70 +70759,80 @@
 			duk__emit(comp_ctx, DUK_ENC_OP_A_BC(DUK_OP_STREG, tmp, a));
 		}
 	} else {
 		goto error_outofregs;
 	}
 	return;
 
- error_outofregs:
+error_outofregs:
 	DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_REG_LIMIT);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc) {
 #if defined(DUK_USE_SHUFFLE_TORTURE)
 	op |= DUK__EMIT_FLAG_NO_SHUFFLE_A;
 #endif
 	duk__emit_a_bc(comp_ctx, op, 0, bc);
 }
 
 DUK_LOCAL void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc) {
 	duk_instr_t ins;
 
-	DUK_ASSERT_DISABLE(op >= DUK_BC_OP_MIN);  /* unsigned */
+	DUK_ASSERT_DISABLE(op >= DUK_BC_OP_MIN); /* unsigned */
 	DUK_ASSERT(op <= DUK_BC_OP_MAX);
-	DUK_ASSERT_DISABLE(abc >= DUK_BC_ABC_MIN);  /* unsigned */
+	DUK_ASSERT_DISABLE(abc >= DUK_BC_ABC_MIN); /* unsigned */
 	DUK_ASSERT(abc <= DUK_BC_ABC_MAX);
 	DUK_ASSERT((abc & DUK__CONST_MARKER) == 0);
-	DUK_ASSERT(abc != -1);  /* Not 'none'. */
+	DUK_ASSERT(abc != -1); /* Not 'none'. */
 
 	if (abc <= DUK_BC_ABC_MAX) {
 		;
 	} else {
 		goto error_outofregs;
 	}
 	ins = DUK_ENC_OP_ABC(op, abc);
 	DUK_DDD(DUK_DDDPRINT("duk__emit_abc: 0x%08lx line=%ld pc=%ld op=%ld (%!X) abc=%ld (%!I)",
-	                     (unsigned long) ins, (long) comp_ctx->curr_token.start_line,
-	                     (long) duk__get_current_pc(comp_ctx), (long) op, (long) op,
-	                     (long) abc, (duk_instr_t) ins));
+	                     (unsigned long) ins,
+	                     (long) comp_ctx->curr_token.start_line,
+	                     (long) duk__get_current_pc(comp_ctx),
+	                     (long) op,
+	                     (long) op,
+	                     (long) abc,
+	                     (duk_instr_t) ins));
 	duk__emit(comp_ctx, ins);
 	return;
 
- error_outofregs:
+error_outofregs:
 	DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_REG_LIMIT);
 	DUK_WO_NORETURN(return;);
 }
 
-DUK_LOCAL void duk__emit_load_int32_raw(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val, duk_small_uint_t op_flags) {
+DUK_LOCAL void duk__emit_load_int32_raw(duk_compiler_ctx *comp_ctx,
+                                        duk_regconst_t reg,
+                                        duk_int32_t val,
+                                        duk_small_uint_t op_flags) {
 	/* XXX: Shuffling support could be implemented here so that LDINT+LDINTX
 	 * would only shuffle once (instead of twice).  The current code works
 	 * though, and has a smaller compiler footprint.
 	 */
 
 	if ((val >= (duk_int32_t) DUK_BC_BC_MIN - (duk_int32_t) DUK_BC_LDINT_BIAS) &&
 	    (val <= (duk_int32_t) DUK_BC_BC_MAX - (duk_int32_t) DUK_BC_LDINT_BIAS)) {
 		DUK_DDD(DUK_DDDPRINT("emit LDINT to reg %ld for %ld", (long) reg, (long) val));
 		duk__emit_a_bc(comp_ctx, DUK_OP_LDINT | op_flags, reg, (duk_regconst_t) (val + (duk_int32_t) DUK_BC_LDINT_BIAS));
 	} else {
 		duk_int32_t hi = val >> DUK_BC_LDINTX_SHIFT;
 		duk_int32_t lo = val & ((((duk_int32_t) 1) << DUK_BC_LDINTX_SHIFT) - 1);
 		DUK_ASSERT(lo >= 0);
 		DUK_DDD(DUK_DDDPRINT("emit LDINT+LDINTX to reg %ld for %ld -> hi %ld, lo %ld",
-		                     (long) reg, (long) val, (long) hi, (long) lo));
+		                     (long) reg,
+		                     (long) val,
+		                     (long) hi,
+		                     (long) lo));
 		duk__emit_a_bc(comp_ctx, DUK_OP_LDINT | op_flags, reg, (duk_regconst_t) (hi + (duk_int32_t) DUK_BC_LDINT_BIAS));
 		duk__emit_a_bc(comp_ctx, DUK_OP_LDINTX | op_flags, reg, (duk_regconst_t) lo);
 	}
 }
 
 DUK_LOCAL void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val) {
 	duk__emit_load_int32_raw(comp_ctx, reg, val, 0 /*op_flags*/);
@@ -69566,15 +70865,15 @@
 	DUK_ASSERT(offset + DUK_BC_JUMP_BIAS <= DUK_BC_ABC_MAX);
 	duk__emit_abc(comp_ctx, DUK_OP_JUMP, (duk_regconst_t) (offset + DUK_BC_JUMP_BIAS));
 }
 
 DUK_LOCAL duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx) {
 	duk_int_t ret;
 
-	ret = duk__get_current_pc(comp_ctx);  /* useful for patching jumps later */
+	ret = duk__get_current_pc(comp_ctx); /* useful for patching jumps later */
 	duk__emit_op_only(comp_ctx, DUK_OP_JUMP);
 	return ret;
 }
 
 /* Insert an empty jump in the middle of code emitted earlier.  This is
  * currently needed for compiling for-in.
  */
@@ -69584,70 +70883,74 @@
 #endif
 	duk_compiler_instr *instr;
 	duk_size_t offset;
 
 	DUK_ASSERT(jump_pc >= 0);
 	offset = (duk_size_t) jump_pc * sizeof(duk_compiler_instr);
 	instr = (duk_compiler_instr *) (void *)
-	        DUK_BW_INSERT_ENSURE_AREA(comp_ctx->thr,
-	                                  &comp_ctx->curr_func.bw_code,
-	                                  offset,
-	                                  sizeof(duk_compiler_instr));
+	    DUK_BW_INSERT_ENSURE_AREA(comp_ctx->thr, &comp_ctx->curr_func.bw_code, offset, sizeof(duk_compiler_instr));
 
 #if defined(DUK_USE_PC2LINE)
-	line = comp_ctx->curr_token.start_line;  /* approximation, close enough */
+	line = comp_ctx->curr_token.start_line; /* approximation, close enough */
 #endif
 	instr->ins = DUK_ENC_OP_ABC(DUK_OP_JUMP, 0);
 #if defined(DUK_USE_PC2LINE)
 	instr->line = (duk_uint32_t) line;
 #endif
 
 	DUK_BW_ADD_PTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code, sizeof(duk_compiler_instr));
 	if (DUK_UNLIKELY(DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) > DUK_USE_ESBC_MAX_BYTES)) {
 		goto fail_bc_limit;
 	}
 	return;
 
-  fail_bc_limit:
+fail_bc_limit:
 	DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_BYTECODE_LIMIT);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Does not assume that jump_pc contains a DUK_OP_JUMP previously; this is intentional
  * to allow e.g. an INVALID opcode be overwritten with a JUMP (label management uses this).
  */
 DUK_LOCAL void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc) {
 	duk_compiler_instr *instr;
 	duk_int_t offset;
 
 	/* allow negative PCs, behave as a no-op */
 	if (jump_pc < 0) {
-		DUK_DDD(DUK_DDDPRINT("duk__patch_jump(): nop call, jump_pc=%ld (<0), target_pc=%ld",
-		                     (long) jump_pc, (long) target_pc));
+		DUK_DDD(
+		    DUK_DDDPRINT("duk__patch_jump(): nop call, jump_pc=%ld (<0), target_pc=%ld", (long) jump_pc, (long) target_pc));
 		return;
 	}
 	DUK_ASSERT(jump_pc >= 0);
 
 	/* XXX: range assert */
 	instr = duk__get_instr_ptr(comp_ctx, jump_pc);
 	DUK_ASSERT(instr != NULL);
 
 	/* XXX: range assert */
 	offset = target_pc - jump_pc - 1;
 
 	instr->ins = DUK_ENC_OP_ABC(DUK_OP_JUMP, offset + DUK_BC_JUMP_BIAS);
 	DUK_DDD(DUK_DDDPRINT("duk__patch_jump(): jump_pc=%ld, target_pc=%ld, offset=%ld",
-	                     (long) jump_pc, (long) target_pc, (long) offset));
+	                     (long) jump_pc,
+	                     (long) target_pc,
+	                     (long) offset));
 }
 
 DUK_LOCAL void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc) {
 	duk__patch_jump(comp_ctx, jump_pc, duk__get_current_pc(comp_ctx));
 }
 
-DUK_LOCAL void duk__patch_trycatch(duk_compiler_ctx *comp_ctx, duk_int_t ldconst_pc, duk_int_t trycatch_pc, duk_regconst_t reg_catch, duk_regconst_t const_varname, duk_small_uint_t flags) {
+DUK_LOCAL void duk__patch_trycatch(duk_compiler_ctx *comp_ctx,
+                                   duk_int_t ldconst_pc,
+                                   duk_int_t trycatch_pc,
+                                   duk_regconst_t reg_catch,
+                                   duk_regconst_t const_varname,
+                                   duk_small_uint_t flags) {
 	duk_compiler_instr *instr;
 
 	DUK_ASSERT(DUK__ISREG(reg_catch));
 
 	instr = duk__get_instr_ptr(comp_ctx, ldconst_pc);
 	DUK_ASSERT(DUK_DEC_OP(instr->ins) == DUK_OP_LDCONST);
 	DUK_ASSERT(instr != NULL);
@@ -69659,15 +70962,18 @@
 			 * check Duktape 0.12.0 could generate invalid code which caused
 			 * an assert failure on execution.  This error is triggered e.g.
 			 * for functions with a lot of constants and a try-catch statement.
 			 * Shuffling or opcode semantics change is needed to fix the issue.
 			 * See: test-bug-trycatch-many-constants.js.
 			 */
 			DUK_D(DUK_DPRINT("failed to patch trycatch: flags=%ld, reg_catch=%ld, const_varname=%ld (0x%08lx)",
-			                 (long) flags, (long) reg_catch, (long) const_varname, (long) const_varname));
+			                 (long) flags,
+			                 (long) reg_catch,
+			                 (long) const_varname,
+			                 (long) const_varname));
 			DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_REG_LIMIT);
 			DUK_WO_NORETURN(return;);
 		}
 		instr->ins |= DUK_ENC_OP_A_BC(0, 0, const_varname);
 	} else {
 		/* No catch variable, e.g. a try-finally; replace LDCONST with
 		 * NOP to avoid a bogus LDCONST.
@@ -69682,22 +70988,22 @@
 	instr->ins = DUK_ENC_OP_A_BC(DUK_OP_TRYCATCH, flags, reg_catch);
 }
 
 DUK_LOCAL void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 	duk_small_uint_t op;
 
 	op = DUK__ISREG(regconst) ? DUK_OP_IFFALSE_R : DUK_OP_IFFALSE_C;
-	duk__emit_bc(comp_ctx, op, regconst);  /* helper will remove const flag */
+	duk__emit_bc(comp_ctx, op, regconst); /* helper will remove const flag */
 }
 
 DUK_LOCAL void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 	duk_small_uint_t op;
 
 	op = DUK__ISREG(regconst) ? DUK_OP_IFTRUE_R : DUK_OP_IFTRUE_C;
-	duk__emit_bc(comp_ctx, op, regconst);  /* helper will remove const flag */
+	duk__emit_bc(comp_ctx, op, regconst); /* helper will remove const flag */
 }
 
 DUK_LOCAL void duk__emit_invalid(duk_compiler_ctx *comp_ctx) {
 	duk__emit_op_only(comp_ctx, DUK_OP_INVALID);
 }
 
 /*
@@ -69713,15 +71019,16 @@
 	duk_int_t i, n;
 	duk_int_t count_opt;
 
 	bc = (duk_compiler_instr *) (void *) DUK_BW_GET_BASEPTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code);
 #if defined(DUK_USE_BUFLEN16)
 	/* No need to assert, buffer size maximum is 0xffff. */
 #else
-	DUK_ASSERT((duk_size_t) DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) / sizeof(duk_compiler_instr) <= (duk_size_t) DUK_INT_MAX);  /* bytecode limits */
+	DUK_ASSERT((duk_size_t) DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) / sizeof(duk_compiler_instr) <=
+	           (duk_size_t) DUK_INT_MAX); /* bytecode limits */
 #endif
 	n = (duk_int_t) (DUK_BW_GET_SIZE(comp_ctx->thr, &comp_ctx->curr_func.bw_code) / sizeof(duk_compiler_instr));
 
 	for (iter = 0; iter < DUK_COMPILER_PEEPHOLE_MAXITER; iter++) {
 		count_opt = 0;
 
 		for (i = 0; i < n; i++) {
@@ -69748,15 +71055,17 @@
 			if (DUK_DEC_OP(ins) != DUK_OP_JUMP) {
 				continue;
 			}
 
 			target_pc2 = target_pc1 + 1 + (duk_int_t) DUK_DEC_ABC(ins) - (duk_int_t) DUK_BC_JUMP_BIAS;
 
 			DUK_DDD(DUK_DDDPRINT("optimizing jump at pc %ld; old target is %ld -> new target is %ld",
-			                     (long) i, (long) target_pc1, (long) target_pc2));
+			                     (long) i,
+			                     (long) target_pc1,
+			                     (long) target_pc2));
 
 			bc[i].ins = DUK_ENC_OP_ABC(DUK_OP_JUMP, target_pc2 - (i + 1) + DUK_BC_JUMP_BIAS);
 
 			count_opt++;
 		}
 
 		DUK_DD(DUK_DDPRINT("optimized %ld jumps on peephole round %ld", (long) count_opt, (long) (iter + 1)));
@@ -69774,23 +71083,29 @@
 /* Flags for intermediate value coercions.  A flag for using a forced reg
  * is not needed, the forced_reg argument suffices and generates better
  * code (it is checked as it is used).
  */
 /* XXX: DUK__IVAL_FLAG_REQUIRE_SHORT is passed but not currently implemented
  * by ispec/ivalue operations.
  */
-#define DUK__IVAL_FLAG_ALLOW_CONST          (1 << 0)  /* allow a constant to be returned */
-#define DUK__IVAL_FLAG_REQUIRE_TEMP         (1 << 1)  /* require a (mutable) temporary as a result (or a const if allowed) */
-#define DUK__IVAL_FLAG_REQUIRE_SHORT        (1 << 2)  /* require a short (8-bit) reg/const which fits into bytecode B/C slot */
+#define DUK__IVAL_FLAG_ALLOW_CONST   (1 << 0) /* allow a constant to be returned */
+#define DUK__IVAL_FLAG_REQUIRE_TEMP  (1 << 1) /* require a (mutable) temporary as a result (or a const if allowed) */
+#define DUK__IVAL_FLAG_REQUIRE_SHORT (1 << 2) /* require a short (8-bit) reg/const which fits into bytecode B/C slot */
 
 /* XXX: some code might benefit from DUK__SETTEMP_IFTEMP(thr,x) */
 
-#if 0  /* enable manually for dumping */
-#define DUK__DUMP_ISPEC(compctx,ispec) do { duk__dump_ispec((compctx), (ispec)); } while (0)
-#define DUK__DUMP_IVALUE(compctx,ivalue) do { duk__dump_ivalue((compctx), (ivalue)); } while (0)
+#if 0 /* enable manually for dumping */
+#define DUK__DUMP_ISPEC(compctx, ispec) \
+	do { \
+		duk__dump_ispec((compctx), (ispec)); \
+	} while (0)
+#define DUK__DUMP_IVALUE(compctx, ivalue) \
+	do { \
+		duk__dump_ivalue((compctx), (ivalue)); \
+	} while (0)
 
 DUK_LOCAL void duk__dump_ispec(duk_compiler_ctx *comp_ctx, duk_ispec *x) {
 	DUK_D(DUK_DPRINT("ispec dump: t=%ld regconst=0x%08lx, valstack_idx=%ld, value=%!T",
 	                 (long) x->t, (unsigned long) x->regconst, (long) x->valstack_idx,
 	                 duk_get_tval(comp_ctx->thr, x->valstack_idx)));
 }
 DUK_LOCAL void duk__dump_ivalue(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
@@ -69800,16 +71115,20 @@
 		         (long) x->t, (long) x->op,
 	                 (long) x->x1.t, (unsigned long) x->x1.regconst, (long) x->x1.valstack_idx,
 	                 duk_get_tval(comp_ctx->thr, x->x1.valstack_idx),
 	                 (long) x->x2.t, (unsigned long) x->x2.regconst, (long) x->x2.valstack_idx,
 	                 duk_get_tval(comp_ctx->thr, x->x2.valstack_idx)));
 }
 #else
-#define DUK__DUMP_ISPEC(comp_ctx,x) do {} while (0)
-#define DUK__DUMP_IVALUE(comp_ctx,x) do {} while (0)
+#define DUK__DUMP_ISPEC(comp_ctx, x) \
+	do { \
+	} while (0)
+#define DUK__DUMP_IVALUE(comp_ctx, x) \
+	do { \
+	} while (0)
 #endif
 
 DUK_LOCAL void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst) {
 	x->t = DUK_IVAL_PLAIN;
 	x->x1.t = DUK_ISPEC_REGCONST;
 	x->x1.regconst = regconst;
 }
@@ -69851,15 +71170,15 @@
 
 DUK_LOCAL duk_regconst_t duk__alloctemps(duk_compiler_ctx *comp_ctx, duk_small_int_t num) {
 	duk_regconst_t res;
 
 	res = comp_ctx->curr_func.temp_next;
 	comp_ctx->curr_func.temp_next += num;
 
-	if (comp_ctx->curr_func.temp_next > DUK__MAX_TEMPS) {  /* == DUK__MAX_TEMPS is OK */
+	if (comp_ctx->curr_func.temp_next > DUK__MAX_TEMPS) { /* == DUK__MAX_TEMPS is OK */
 		DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_TEMP_LIMIT);
 		DUK_WO_NORETURN(return 0;);
 	}
 
 	/* maintain highest 'used' temporary, needed to figure out nregs of function */
 	if (comp_ctx->curr_func.temp_next > comp_ctx->curr_func.temp_max) {
 		comp_ctx->curr_func.temp_max = comp_ctx->curr_func.temp_next;
@@ -69904,46 +71223,44 @@
 	for (i = 0; i < n_check; i++) {
 		duk_tval *tv2 = DUK_HOBJECT_A_GET_VALUE_PTR(thr->heap, f->h_consts, i);
 
 		/* Strict equality is NOT enough, because we cannot use the same
 		 * constant for e.g. +0 and -0.
 		 */
 		if (duk_js_samevalue(tv1, tv2)) {
-			DUK_DDD(DUK_DDDPRINT("reused existing constant for %!T -> const index %ld",
-			                     (duk_tval *) tv1, (long) i));
+			DUK_DDD(DUK_DDDPRINT("reused existing constant for %!T -> const index %ld", (duk_tval *) tv1, (long) i));
 			duk_pop(thr);
 			return (duk_regconst_t) i | (duk_regconst_t) DUK__CONST_MARKER;
 		}
 	}
 
 	if (n > DUK__MAX_CONSTS) {
 		DUK_ERROR_RANGE(comp_ctx->thr, DUK_STR_CONST_LIMIT);
 		DUK_WO_NORETURN(return 0;);
 	}
 
-	DUK_DDD(DUK_DDDPRINT("allocating new constant for %!T -> const index %ld",
-	                     (duk_tval *) tv1, (long) n));
-	(void) duk_put_prop_index(thr, f->consts_idx, (duk_uarridx_t) n);  /* invalidates tv1, tv2 */
+	DUK_DDD(DUK_DDDPRINT("allocating new constant for %!T -> const index %ld", (duk_tval *) tv1, (long) n));
+	(void) duk_put_prop_index(thr, f->consts_idx, (duk_uarridx_t) n); /* invalidates tv1, tv2 */
 	return (duk_regconst_t) n | (duk_regconst_t) DUK__CONST_MARKER;
 }
 
 DUK_LOCAL duk_bool_t duk__const_needs_refcount(duk_compiler_ctx *comp_ctx, duk_regconst_t rc) {
 #if defined(DUK_USE_REFERENCE_COUNTING)
 	duk_compiler_func *f = &comp_ctx->curr_func;
 	duk_bool_t ret;
 
-	DUK_ASSERT((rc & DUK__CONST_MARKER) == 0);  /* caller removes const marker */
+	DUK_ASSERT((rc & DUK__CONST_MARKER) == 0); /* caller removes const marker */
 	(void) duk_get_prop_index(comp_ctx->thr, f->consts_idx, (duk_uarridx_t) rc);
-	ret = !duk_is_number(comp_ctx->thr, -1);  /* now only number/string, so conservative check */
+	ret = !duk_is_number(comp_ctx->thr, -1); /* now only number/string, so conservative check */
 	duk_pop(comp_ctx->thr);
 	return ret;
 #else
 	DUK_UNREF(comp_ctx);
 	DUK_UNREF(rc);
-	DUK_ASSERT((rc & DUK__CONST_MARKER) == 0);  /* caller removes const marker */
+	DUK_ASSERT((rc & DUK__CONST_MARKER) == 0); /* caller removes const marker */
 	return 0;
 #endif
 }
 
 /* Get the value represented by an duk_ispec to a register or constant.
  * The caller can control the result by indicating whether or not:
  *
@@ -69998,17 +71315,15 @@
 		case DUK_TAG_NULL: {
 			duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : DUK__ALLOCTEMP(comp_ctx));
 			duk__emit_bc(comp_ctx, DUK_OP_LDNULL, dest);
 			return dest;
 		}
 		case DUK_TAG_BOOLEAN: {
 			duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : DUK__ALLOCTEMP(comp_ctx));
-			duk__emit_bc(comp_ctx,
-			             (DUK_TVAL_GET_BOOLEAN(tv) ? DUK_OP_LDTRUE : DUK_OP_LDFALSE),
-			             dest);
+			duk__emit_bc(comp_ctx, (DUK_TVAL_GET_BOOLEAN(tv) ? DUK_OP_LDTRUE : DUK_OP_LDFALSE), dest);
 			return dest;
 		}
 		case DUK_TAG_POINTER: {
 			DUK_UNREACHABLE();
 			break;
 		}
 		case DUK_TAG_STRING: {
@@ -70016,15 +71331,15 @@
 			duk_regconst_t dest;
 			duk_regconst_t constidx;
 
 			h = DUK_TVAL_GET_STRING(tv);
 			DUK_UNREF(h);
 			DUK_ASSERT(h != NULL);
 
-#if 0  /* XXX: to be implemented? */
+#if 0 /* XXX: to be implemented? */
 			/* Use special opcodes to load short strings */
 			if (DUK_HSTRING_GET_BYTELEN(h) <= 2) {
 				/* Encode into a single opcode (18 bits can encode 1-2 bytes + length indicator) */
 			} else if (DUK_HSTRING_GET_BYTELEN(h) <= 6) {
 				/* Encode into a double constant (53 bits can encode 6*8 = 48 bits + 3-bit length */
 			}
 #endif
@@ -70086,16 +71401,16 @@
 				return constidx;
 			} else {
 				dest = (forced_reg >= 0 ? forced_reg : DUK__ALLOCTEMP(comp_ctx));
 				duk__emit_a_bc(comp_ctx, DUK_OP_LDCONST, dest, constidx);
 				return dest;
 			}
 		}
-		}  /* end switch */
-		goto fail_internal;  /* never here */
+		} /* end switch */
+		goto fail_internal; /* never here */
 	}
 	case DUK_ISPEC_REGCONST: {
 		if (forced_reg >= 0) {
 			if (DUK__ISCONST(x->regconst)) {
 				duk__emit_a_bc(comp_ctx, DUK_OP_LDCONST, forced_reg, x->regconst);
 			} else if (x->regconst != forced_reg) {
 				duk__emit_a_bc(comp_ctx, DUK_OP_LDREG, forced_reg, x->regconst);
@@ -70120,19 +71435,19 @@
 			duk_regconst_t dest = DUK__ALLOCTEMP(comp_ctx);
 			duk__emit_a_bc(comp_ctx, DUK_OP_LDREG, dest, x->regconst);
 			return dest;
 		}
 		return x->regconst;
 	}
 	default: {
-		break;  /* never here */
+		break; /* never here */
 	}
 	}
 
- fail_internal:
+fail_internal:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_LOCAL void duk__ispec_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ispec *x, duk_regconst_t forced_reg) {
 	DUK_ASSERT(forced_reg >= 0);
 	(void) duk__ispec_toregconst_raw(comp_ctx, x, forced_reg, 0 /*flags*/);
@@ -70144,18 +71459,21 @@
  * side effect.
  */
 DUK_LOCAL void duk__ivalue_toplain_raw(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_regconst_t forced_reg) {
 	duk_hthread *thr = comp_ctx->thr;
 
 	DUK_DDD(DUK_DDDPRINT("duk__ivalue_toplain_raw(): x={t=%ld,op=%ld,x1={%ld:%ld:%!T},x2={%ld:%ld:%!T}}, "
 	                     "forced_reg=%ld",
-	                     (long) x->t, (long) x->op,
-	                     (long) x->x1.t, (long) x->x1.regconst,
+	                     (long) x->t,
+	                     (long) x->op,
+	                     (long) x->x1.t,
+	                     (long) x->x1.regconst,
 	                     (duk_tval *) duk_get_tval(thr, x->x1.valstack_idx),
-	                     (long) x->x2.t, (long) x->x2.regconst,
+	                     (long) x->x2.t,
+	                     (long) x->x2.regconst,
 	                     (duk_tval *) duk_get_tval(thr, x->x2.valstack_idx),
 	                     (long) forced_reg));
 
 	switch (x->t) {
 	case DUK_IVAL_PLAIN: {
 		return;
 	}
@@ -70173,26 +71491,26 @@
 		/* XXX: use the exactly same arithmetic function here as in executor */
 		if (x->x1.t == DUK_ISPEC_VALUE && x->x2.t == DUK_ISPEC_VALUE && x->t == DUK_IVAL_ARITH) {
 			tv1 = DUK_GET_TVAL_POSIDX(thr, x->x1.valstack_idx);
 			tv2 = DUK_GET_TVAL_POSIDX(thr, x->x2.valstack_idx);
 			DUK_ASSERT(tv1 != NULL);
 			DUK_ASSERT(tv2 != NULL);
 
-			DUK_DDD(DUK_DDDPRINT("arith: tv1=%!T, tv2=%!T",
-			                     (duk_tval *) tv1,
-			                     (duk_tval *) tv2));
+			DUK_DDD(DUK_DDDPRINT("arith: tv1=%!T, tv2=%!T", (duk_tval *) tv1, (duk_tval *) tv2));
 
 			if (DUK_TVAL_IS_NUMBER(tv1) && DUK_TVAL_IS_NUMBER(tv2)) {
 				duk_double_t d1 = DUK_TVAL_GET_NUMBER(tv1);
 				duk_double_t d2 = DUK_TVAL_GET_NUMBER(tv2);
 				duk_double_t d3;
 				duk_bool_t accept_fold = 1;
 
 				DUK_DDD(DUK_DDDPRINT("arith inline check: d1=%lf, d2=%lf, op=%ld",
-				                     (double) d1, (double) d2, (long) x->op));
+				                     (double) d1,
+				                     (double) d2,
+				                     (long) x->op));
 				switch (x->op) {
 				case DUK_OP_ADD: {
 					d3 = d1 + d2;
 					break;
 				}
 				case DUK_OP_SUB: {
 					d3 = d1 - d2;
@@ -70210,29 +71528,29 @@
 					break;
 				}
 				case DUK_OP_EXP: {
 					d3 = (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
 					break;
 				}
 				default: {
-					d3 = 0.0;  /* Won't be used, but silence MSVC /W4 warning. */
+					d3 = 0.0; /* Won't be used, but silence MSVC /W4 warning. */
 					accept_fold = 0;
 					break;
 				}
 				}
 
 				if (accept_fold) {
 					duk_double_union du;
 					du.d = d3;
 					DUK_DBLUNION_NORMALIZE_NAN_CHECK(&du);
 					d3 = du.d;
 
 					x->t = DUK_IVAL_PLAIN;
 					DUK_ASSERT(x->x1.t == DUK_ISPEC_VALUE);
-					DUK_TVAL_SET_NUMBER(tv1, d3);  /* old value is number: no refcount */
+					DUK_TVAL_SET_NUMBER(tv1, d3); /* old value is number: no refcount */
 					return;
 				}
 			} else if (x->op == DUK_OP_ADD && DUK_TVAL_IS_STRING(tv1) && DUK_TVAL_IS_STRING(tv2)) {
 				/* Inline string concatenation.  No need to check for
 				 * symbols, as all inputs are valid ECMAScript strings.
 				 */
 				duk_dup(thr, x->x1.valstack_idx);
@@ -70241,16 +71559,22 @@
 				duk_replace(thr, x->x1.valstack_idx);
 				x->t = DUK_IVAL_PLAIN;
 				DUK_ASSERT(x->x1.t == DUK_ISPEC_VALUE);
 				return;
 			}
 		}
 
-		arg1 = duk__ispec_toregconst_raw(comp_ctx, &x->x1, -1, DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
-		arg2 = duk__ispec_toregconst_raw(comp_ctx, &x->x2, -1, DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
+		arg1 = duk__ispec_toregconst_raw(comp_ctx,
+		                                 &x->x1,
+		                                 -1,
+		                                 DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
+		arg2 = duk__ispec_toregconst_raw(comp_ctx,
+		                                 &x->x2,
+		                                 -1,
+		                                 DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
 
 		/* If forced reg, use it as destination.  Otherwise try to
 		 * use either coerced ispec if it is a temporary.
 		 */
 		if (forced_reg >= 0) {
 			dest = forced_reg;
 		} else if (DUK__ISREG_TEMP(comp_ctx, arg1)) {
@@ -70270,16 +71594,22 @@
 	case DUK_IVAL_PROP: {
 		/* XXX: very similar to DUK_IVAL_ARITH - merge? */
 		duk_regconst_t arg1;
 		duk_regconst_t arg2;
 		duk_regconst_t dest;
 
 		/* Need a short reg/const, does not have to be a mutable temp. */
-		arg1 = duk__ispec_toregconst_raw(comp_ctx, &x->x1, -1, DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
-		arg2 = duk__ispec_toregconst_raw(comp_ctx, &x->x2, -1, DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
+		arg1 = duk__ispec_toregconst_raw(comp_ctx,
+		                                 &x->x1,
+		                                 -1,
+		                                 DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
+		arg2 = duk__ispec_toregconst_raw(comp_ctx,
+		                                 &x->x2,
+		                                 -1,
+		                                 DUK__IVAL_FLAG_ALLOW_CONST | DUK__IVAL_FLAG_REQUIRE_SHORT /*flags*/);
 
 		/* Pick a destination register.  If either base value or key
 		 * happens to be a temp value, reuse it as the destination.
 		 *
 		 * XXX: The temp must be a "mutable" one, i.e. such that no
 		 * other expression is using it anymore.  Here this should be
 		 * the case because the value of a property access expression
@@ -70292,19 +71622,15 @@
 			dest = arg1;
 		} else if (DUK__ISREG_TEMP(comp_ctx, arg2)) {
 			dest = arg2;
 		} else {
 			dest = DUK__ALLOCTEMP(comp_ctx);
 		}
 
-		duk__emit_a_b_c(comp_ctx,
-		                DUK_OP_GETPROP | DUK__EMIT_FLAG_BC_REGCONST,
-		                dest,
-		                arg1,
-		                arg2);
+		duk__emit_a_b_c(comp_ctx, DUK_OP_GETPROP | DUK__EMIT_FLAG_BC_REGCONST, dest, arg1, arg2);
 
 		duk__ivalue_regconst(x, dest);
 		return;
 	}
 	case DUK_IVAL_VAR: {
 		/* x1 must be a string */
 		duk_regconst_t dest;
@@ -70364,18 +71690,21 @@
                                           duk_small_uint_t flags) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_regconst_t reg;
 	DUK_UNREF(thr);
 
 	DUK_DDD(DUK_DDDPRINT("duk__ivalue_toregconst_raw(): x={t=%ld,op=%ld,x1={%ld:%ld:%!T},x2={%ld:%ld:%!T}}, "
 	                     "forced_reg=%ld, flags 0x%08lx: allow_const=%ld require_temp=%ld require_short=%ld",
-	                     (long) x->t, (long) x->op,
-	                     (long) x->x1.t, (long) x->x1.regconst,
+	                     (long) x->t,
+	                     (long) x->op,
+	                     (long) x->x1.t,
+	                     (long) x->x1.regconst,
 	                     (duk_tval *) duk_get_tval(thr, x->x1.valstack_idx),
-	                     (long) x->x2.t, (long) x->x2.regconst,
+	                     (long) x->x2.t,
+	                     (long) x->x2.regconst,
 	                     (duk_tval *) duk_get_tval(thr, x->x2.valstack_idx),
 	                     (long) forced_reg,
 	                     (unsigned long) flags,
 	                     (long) ((flags & DUK__IVAL_FLAG_ALLOW_CONST) ? 1 : 0),
 	                     (long) ((flags & DUK__IVAL_FLAG_REQUIRE_TEMP) ? 1 : 0),
 	                     (long) ((flags & DUK__IVAL_FLAG_REQUIRE_SHORT) ? 1 : 0)));
 
@@ -70390,15 +71719,15 @@
 	return reg;
 }
 
 DUK_LOCAL duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 	return duk__ivalue_toregconst_raw(comp_ctx, x, -1, 0 /*flags*/);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL duk_regconst_t duk__ivalue_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 	return duk__ivalue_toregconst_raw(comp_ctx, x, -1, DUK__IVAL_FLAG_REQUIRE_TEMP /*flags*/);
 }
 #endif
 
 DUK_LOCAL void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg) {
 	DUK_ASSERT(forced_reg >= 0);
@@ -70426,16 +71755,15 @@
  */
 
 DUK_LOCAL duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_hstring *h_varname;
 	duk_regconst_t ret;
 
-	DUK_DDD(DUK_DDDPRINT("resolving identifier reference to '%!T'",
-	                     (duk_tval *) duk_get_tval(thr, -1)));
+	DUK_DDD(DUK_DDDPRINT("resolving identifier reference to '%!T'", (duk_tval *) duk_get_tval(thr, -1)));
 
 	/*
 	 *  Special name handling
 	 */
 
 	h_varname = duk_known_hstring(thr, -1);
 
@@ -70480,21 +71808,21 @@
 			goto slow_path_notown;
 		}
 	}
 
 	DUK_DDD(DUK_DDDPRINT("identifier lookup -> reg %ld", (long) ret));
 	return ret;
 
- slow_path_notown:
+slow_path_notown:
 	DUK_DDD(DUK_DDDPRINT("identifier lookup -> slow path, not own variable"));
 
 	comp_ctx->curr_func.id_access_slow = 1;
 	return (duk_regconst_t) -1;
 
- slow_path_own:
+slow_path_own:
 	DUK_DDD(DUK_DDDPRINT("identifier lookup -> slow path, may be own variable"));
 
 	comp_ctx->curr_func.id_access_slow = 1;
 	comp_ctx->curr_func.id_access_slow_own = 1;
 	return (duk_regconst_t) -1;
 }
 
@@ -70514,15 +71842,15 @@
 	/* [ ... varname ] */
 
 	duk_dup_top(thr);
 	reg_varbind = duk__lookup_active_register_binding(comp_ctx);
 
 	if (reg_varbind >= 0) {
 		*out_reg_varbind = reg_varbind;
-		*out_rc_varname = 0;  /* duk_regconst_t is unsigned, so use 0 as dummy value (ignored by caller) */
+		*out_rc_varname = 0; /* duk_regconst_t is unsigned, so use 0 as dummy value (ignored by caller) */
 		duk_pop(thr);
 		return 1;
 	} else {
 		rc_varname = duk__getconst(comp_ctx);
 		*out_reg_varbind = -1;
 		*out_rc_varname = rc_varname;
 		return 0;
@@ -70564,44 +71892,47 @@
 		if (li->h_label == h_label && h_label != DUK_HTHREAD_STRING_EMPTY_STRING(thr)) {
 			DUK_ERROR_SYNTAX(thr, DUK_STR_DUPLICATE_LABEL);
 			DUK_WO_NORETURN(return;);
 		}
 	}
 
 	duk_push_hstring(thr, h_label);
-	DUK_ASSERT(n <= DUK_UARRIDX_MAX);  /* label limits */
+	DUK_ASSERT(n <= DUK_UARRIDX_MAX); /* label limits */
 	(void) duk_put_prop_index(thr, comp_ctx->curr_func.labelnames_idx, (duk_uarridx_t) n);
 
 	new_size = (n + 1) * sizeof(duk_labelinfo);
 	duk_hbuffer_resize(thr, comp_ctx->curr_func.h_labelinfos, new_size);
 	/* XXX: slack handling, slow now */
 
 	/* relookup after possible realloc */
 	p = (duk_uint8_t *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(thr->heap, comp_ctx->curr_func.h_labelinfos);
 	li_start = (duk_labelinfo *) (void *) p;
-	DUK_UNREF(li_start);  /* silence scan-build warning */
+	DUK_UNREF(li_start); /* silence scan-build warning */
 	li = (duk_labelinfo *) (void *) (p + DUK_HBUFFER_GET_SIZE(comp_ctx->curr_func.h_labelinfos));
 	li--;
 
 	/* Labels can be used for iteration statements but also for other statements,
 	 * in particular a label can be used for a block statement.  All cases of a
 	 * named label accept a 'break' so that flag is set here.  Iteration statements
 	 * also allow 'continue', so that flag is updated when we figure out the
 	 * statement type.
 	 */
 
 	li->flags = DUK_LABEL_FLAG_ALLOW_BREAK;
 	li->label_id = label_id;
 	li->h_label = h_label;
-	li->catch_depth = comp_ctx->curr_func.catch_depth;   /* catch depth from current func */
+	li->catch_depth = comp_ctx->curr_func.catch_depth; /* catch depth from current func */
 	li->pc_label = pc_label;
 
 	DUK_DDD(DUK_DDDPRINT("registered label: flags=0x%08lx, id=%ld, name=%!O, catch_depth=%ld, pc_label=%ld",
-	                     (unsigned long) li->flags, (long) li->label_id, (duk_heaphdr *) li->h_label,
-	                     (long) li->catch_depth, (long) li->pc_label));
+	                     (unsigned long) li->flags,
+	                     (long) li->label_id,
+	                     (duk_heaphdr *) li->h_label,
+	                     (long) li->catch_depth,
+	                     (long) li->pc_label));
 }
 
 /* Update all labels with matching label_id. */
 DUK_LOCAL void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags) {
 	duk_uint8_t *p;
 	duk_labelinfo *li_start, *li;
 
@@ -70617,15 +71948,17 @@
 		li--;
 
 		if (li->label_id != label_id) {
 			break;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("updating (overwriting) label flags for li=%p, label_id=%ld, flags=%ld",
-		                     (void *) li, (long) label_id, (long) flags));
+		                     (void *) li,
+		                     (long) label_id,
+		                     (long) flags));
 
 		li->flags = flags;
 	}
 }
 
 /* Lookup active label information.  Break/continue distinction is necessary to handle switch
  * statement related labels correctly: a switch will only catch a 'break', not a 'continue'.
@@ -70638,22 +71971,27 @@
  *
  * A side effect of these rules is that a LABEL statement related to a switch should never actually
  * catch a continue abrupt completion at run-time.  Hence an INVALID opcode can be placed in the
  * continue slot of the switch's LABEL statement.
  */
 
 /* XXX: awkward, especially the bunch of separate output values -> output struct? */
-DUK_LOCAL void duk__lookup_active_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_bool_t is_break, duk_int_t *out_label_id, duk_int_t *out_label_catch_depth, duk_int_t *out_label_pc, duk_bool_t *out_is_closest) {
+DUK_LOCAL void duk__lookup_active_label(duk_compiler_ctx *comp_ctx,
+                                        duk_hstring *h_label,
+                                        duk_bool_t is_break,
+                                        duk_int_t *out_label_id,
+                                        duk_int_t *out_label_catch_depth,
+                                        duk_int_t *out_label_pc,
+                                        duk_bool_t *out_is_closest) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_uint8_t *p;
 	duk_labelinfo *li_start, *li_end, *li;
 	duk_bool_t match = 0;
 
-	DUK_DDD(DUK_DDDPRINT("looking up active label: label='%!O', is_break=%ld",
-	                     (duk_heaphdr *) h_label, (long) is_break));
+	DUK_DDD(DUK_DDDPRINT("looking up active label: label='%!O', is_break=%ld", (duk_heaphdr *) h_label, (long) is_break));
 
 	DUK_UNREF(thr);
 
 	p = (duk_uint8_t *) DUK_HBUFFER_DYNAMIC_GET_DATA_PTR(thr->heap, comp_ctx->curr_func.h_labelinfos);
 	li_start = (duk_labelinfo *) (void *) p;
 	li_end = (duk_labelinfo *) (void *) (p + DUK_HBUFFER_GET_SIZE(comp_ctx->curr_func.h_labelinfos));
 	li = li_end;
@@ -70669,15 +72007,16 @@
 			                     (long) (li - li_start),
 			                     (duk_heaphdr *) li->h_label,
 			                     (duk_heaphdr *) h_label));
 			continue;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("labelinfo[%ld] -> '%!O' label name matches (still need to check type)",
-		                     (long) (li - li_start), (duk_heaphdr *) h_label));
+		                     (long) (li - li_start),
+		                     (duk_heaphdr *) h_label));
 
 		/* currently all labels accept a break, so no explicit check for it now */
 		DUK_ASSERT(li->flags & DUK_LABEL_FLAG_ALLOW_BREAK);
 
 		if (is_break) {
 			/* break matches always */
 			match = 1;
@@ -70703,16 +72042,18 @@
 	/* XXX: match flag is awkward, rework */
 	if (!match) {
 		DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_LABEL);
 		DUK_WO_NORETURN(return;);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("label match: %!O -> label_id %ld, catch_depth=%ld, pc_label=%ld",
-	                     (duk_heaphdr *) h_label, (long) li->label_id,
-	                     (long) li->catch_depth, (long) li->pc_label));
+	                     (duk_heaphdr *) h_label,
+	                     (long) li->label_id,
+	                     (long) li->catch_depth,
+	                     (long) li->pc_label));
 
 	*out_label_id = li->label_id;
 	*out_label_catch_depth = li->catch_depth;
 	*out_label_pc = li->pc_label;
 	*out_is_closest = (li == li_end - 1);
 }
 
@@ -70728,44 +72069,44 @@
  *
  *  - duk__expr_nud(): ("null denotation"): process prev_token as a "start" of an expression (e.g. literal)
  *  - duk__expr_led(): ("left denotation"): process prev_token in the "middle" of an expression (e.g. operator)
  *  - duk__expr_lbp(): ("left-binding power"): return left-binding power of curr_token
  */
 
 /* object literal key tracking flags */
-#define DUK__OBJ_LIT_KEY_PLAIN  (1 << 0)  /* key encountered as a plain property */
-#define DUK__OBJ_LIT_KEY_GET    (1 << 1)  /* key encountered as a getter */
-#define DUK__OBJ_LIT_KEY_SET    (1 << 2)  /* key encountered as a setter */
+#define DUK__OBJ_LIT_KEY_PLAIN (1 << 0) /* key encountered as a plain property */
+#define DUK__OBJ_LIT_KEY_GET   (1 << 1) /* key encountered as a getter */
+#define DUK__OBJ_LIT_KEY_SET   (1 << 2) /* key encountered as a setter */
 
 DUK_LOCAL void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
-	duk_regconst_t reg_obj;                 /* result reg */
-	duk_regconst_t reg_temp;                /* temp reg */
-	duk_regconst_t temp_start;              /* temp reg value for start of loop */
-	duk_small_uint_t max_init_values;  /* max # of values initialized in one MPUTARR set */
-	duk_small_uint_t num_values;       /* number of values in current MPUTARR set */
-	duk_uarridx_t curr_idx;            /* current (next) array index */
-	duk_uarridx_t start_idx;           /* start array index of current MPUTARR set */
-	duk_uarridx_t init_idx;            /* last array index explicitly initialized, +1 */
-	duk_bool_t require_comma;          /* next loop requires a comma */
+	duk_regconst_t reg_obj; /* result reg */
+	duk_regconst_t reg_temp; /* temp reg */
+	duk_regconst_t temp_start; /* temp reg value for start of loop */
+	duk_small_uint_t max_init_values; /* max # of values initialized in one MPUTARR set */
+	duk_small_uint_t num_values; /* number of values in current MPUTARR set */
+	duk_uarridx_t curr_idx; /* current (next) array index */
+	duk_uarridx_t start_idx; /* start array index of current MPUTARR set */
+	duk_uarridx_t init_idx; /* last array index explicitly initialized, +1 */
+	duk_bool_t require_comma; /* next loop requires a comma */
 #if !defined(DUK_USE_PREFER_SIZE)
 	duk_int_t pc_newarr;
 	duk_compiler_instr *instr;
 #endif
 
 	/* DUK_TOK_LBRACKET already eaten, current token is right after that */
 	DUK_ASSERT(comp_ctx->prev_token.t == DUK_TOK_LBRACKET);
 
-	max_init_values = DUK__MAX_ARRAY_INIT_VALUES;  /* XXX: depend on available temps? */
+	max_init_values = DUK__MAX_ARRAY_INIT_VALUES; /* XXX: depend on available temps? */
 
 	reg_obj = DUK__ALLOCTEMP(comp_ctx);
 #if !defined(DUK_USE_PREFER_SIZE)
 	pc_newarr = duk__get_current_pc(comp_ctx);
 #endif
-	duk__emit_bc(comp_ctx, DUK_OP_NEWARR, reg_obj);  /* XXX: patch initial size hint afterwards? */
+	duk__emit_bc(comp_ctx, DUK_OP_NEWARR, reg_obj); /* XXX: patch initial size hint afterwards? */
 	temp_start = DUK__GETTEMP(comp_ctx);
 
 	/*
 	 *  Emit initializers in sets of maximum max_init_values.
 	 *  Corner cases such as single value initializers do not have
 	 *  special handling now.
 	 *
@@ -70773,15 +72114,15 @@
 	 *  because such values would be enumerable (which is incorrect).
 	 *  Also note that trailing elisions must be reflected in the
 	 *  length of the final array but cause no elements to be actually
 	 *  inserted.
 	 */
 
 	curr_idx = 0;
-	init_idx = 0;         /* tracks maximum initialized index + 1 */
+	init_idx = 0; /* tracks maximum initialized index + 1 */
 	start_idx = 0;
 	require_comma = 0;
 
 	for (;;) {
 		num_values = 0;
 		DUK__SETTEMP(comp_ctx, temp_start);
 
@@ -70819,15 +72160,15 @@
 			/* initial index */
 			if (num_values == 0) {
 				start_idx = curr_idx;
 				reg_temp = DUK__ALLOCTEMP(comp_ctx);
 				duk__emit_load_int32(comp_ctx, reg_temp, (duk_int32_t) start_idx);
 			}
 
-			reg_temp = DUK__ALLOCTEMP(comp_ctx);   /* alloc temp just in case, to update max temp */
+			reg_temp = DUK__ALLOCTEMP(comp_ctx); /* alloc temp just in case, to update max temp */
 			DUK__SETTEMP(comp_ctx, reg_temp);
 			duk__expr_toforcedreg(comp_ctx, res, DUK__BP_COMMA /*rbp_flags*/, reg_temp /*forced_reg*/);
 			DUK__SETTEMP(comp_ctx, reg_temp + 1);
 
 			num_values++;
 			curr_idx++;
 			require_comma = 1;
@@ -70844,17 +72185,15 @@
 			 * - B cannot be shuffled normally because it identifies a range
 			 *   of registers, the emitter has special handling for this
 			 *   (the "no shuffle" flag must not be set).
 			 * - C is a non-register number and cannot be shuffled, but
 			 *   never needs to be.
 			 */
 			duk__emit_a_b_c(comp_ctx,
-			                DUK_OP_MPUTARR |
-			                    DUK__EMIT_FLAG_NO_SHUFFLE_C |
-			                    DUK__EMIT_FLAG_A_IS_SOURCE,
+			                DUK_OP_MPUTARR | DUK__EMIT_FLAG_NO_SHUFFLE_C | DUK__EMIT_FLAG_A_IS_SOURCE,
 			                reg_obj,
 			                temp_start,
 			                (duk_regconst_t) (num_values + 1));
 			init_idx = start_idx + num_values;
 
 			/* num_values and temp_start reset at top of outer loop */
 		}
@@ -70867,35 +72206,31 @@
 	instr = duk__get_instr_ptr(comp_ctx, pc_newarr);
 	instr->ins |= DUK_ENC_OP_A(0, curr_idx > DUK_BC_A_MAX ? DUK_BC_A_MAX : curr_idx);
 #endif
 
 	DUK_ASSERT(comp_ctx->curr_token.t == DUK_TOK_RBRACKET);
 	duk__advance(comp_ctx);
 
-	DUK_DDD(DUK_DDDPRINT("array literal done, curridx=%ld, initidx=%ld",
-	                     (long) curr_idx, (long) init_idx));
+	DUK_DDD(DUK_DDDPRINT("array literal done, curridx=%ld, initidx=%ld", (long) curr_idx, (long) init_idx));
 
 	/* trailing elisions? */
 	if (curr_idx > init_idx) {
 		/* yes, must set array length explicitly */
 		DUK_DDD(DUK_DDDPRINT("array literal has trailing elisions which affect its length"));
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
 		duk__emit_load_int32(comp_ctx, reg_temp, (duk_int_t) curr_idx);
-		duk__emit_a_bc(comp_ctx,
-		               DUK_OP_SETALEN | DUK__EMIT_FLAG_A_IS_SOURCE,
-		               reg_obj,
-		               reg_temp);
+		duk__emit_a_bc(comp_ctx, DUK_OP_SETALEN | DUK__EMIT_FLAG_A_IS_SOURCE, reg_obj, reg_temp);
 	}
 
 	DUK__SETTEMP(comp_ctx, temp_start);
 
 	duk__ivalue_regconst(res, reg_obj);
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_ARRAY_LITERAL);
 	DUK_WO_NORETURN(return;);
 }
 
 typedef struct {
 	duk_regconst_t reg_obj;
 	duk_regconst_t temp_start;
@@ -70911,17 +72246,15 @@
 		 *   of registers, the emitter has special handling for this
 		 *   (the "no shuffle" flag must not be set).
 		 * - C is a non-register number and cannot be shuffled, but
 		 *   never needs to be.
 		 */
 		DUK_ASSERT(st->num_pairs > 0);
 		duk__emit_a_b_c(comp_ctx,
-		                DUK_OP_MPUTOBJ |
-		                    DUK__EMIT_FLAG_NO_SHUFFLE_C |
-		                    DUK__EMIT_FLAG_A_IS_SOURCE,
+		                DUK_OP_MPUTOBJ | DUK__EMIT_FLAG_NO_SHUFFLE_C | DUK__EMIT_FLAG_A_IS_SOURCE,
 		                st->reg_obj,
 		                st->temp_start,
 		                (duk_regconst_t) (st->num_pairs * 2));
 		st->num_total_pairs += st->num_pairs;
 		st->num_pairs = 0;
 	}
 	DUK__SETTEMP(comp_ctx, st->temp_start);
@@ -70932,44 +72265,44 @@
 		/* same handling for identifiers and strings */
 		DUK_ASSERT(tok->str1 != NULL);
 		duk_push_hstring(comp_ctx->thr, tok->str1);
 	} else if (tok->t == DUK_TOK_NUMBER) {
 		/* numbers can be loaded as numbers and coerced on the fly */
 		duk_push_number(comp_ctx->thr, tok->num);
 	} else {
-		return 1;  /* error */
+		return 1; /* error */
 	}
 
 	duk__ivalue_plain_fromstack(comp_ctx, res);
 	DUK__SETTEMP(comp_ctx, reg_temp + 1);
 	duk__ivalue_toforcedreg(comp_ctx, res, reg_temp);
 	DUK__SETTEMP(comp_ctx, reg_temp + 1);
 	return 0;
 }
 
 DUK_LOCAL void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk__objlit_state st;
-	duk_regconst_t reg_temp;          /* temp reg */
-	duk_small_uint_t max_init_pairs;  /* max # of key-value pairs initialized in one MPUTOBJ set */
-	duk_bool_t first;                 /* first value: comma must not precede the value */
-	duk_bool_t is_set, is_get;        /* temps */
+	duk_regconst_t reg_temp; /* temp reg */
+	duk_small_uint_t max_init_pairs; /* max # of key-value pairs initialized in one MPUTOBJ set */
+	duk_bool_t first; /* first value: comma must not precede the value */
+	duk_bool_t is_set, is_get; /* temps */
 #if !defined(DUK_USE_PREFER_SIZE)
 	duk_int_t pc_newobj;
 	duk_compiler_instr *instr;
 #endif
 
 	DUK_ASSERT(comp_ctx->prev_token.t == DUK_TOK_LCURLY);
 
-	max_init_pairs = DUK__MAX_OBJECT_INIT_PAIRS;  /* XXX: depend on available temps? */
+	max_init_pairs = DUK__MAX_OBJECT_INIT_PAIRS; /* XXX: depend on available temps? */
 
-	st.reg_obj = DUK__ALLOCTEMP(comp_ctx);    /* target object */
-	st.temp_start = DUK__GETTEMP(comp_ctx);   /* start of MPUTOBJ argument list */
-	st.num_pairs = 0;                         /* number of key/value pairs emitted for current MPUTOBJ set */
-	st.num_total_pairs = 0;                   /* number of key/value pairs emitted overall */
+	st.reg_obj = DUK__ALLOCTEMP(comp_ctx); /* target object */
+	st.temp_start = DUK__GETTEMP(comp_ctx); /* start of MPUTOBJ argument list */
+	st.num_pairs = 0; /* number of key/value pairs emitted for current MPUTOBJ set */
+	st.num_total_pairs = 0; /* number of key/value pairs emitted overall */
 
 #if !defined(DUK_USE_PREFER_SIZE)
 	pc_newobj = duk__get_current_pc(comp_ctx);
 #endif
 	duk__emit_bc(comp_ctx, DUK_OP_NEWOBJ, st.reg_obj);
 
 	/*
@@ -71000,16 +72333,15 @@
 		 *
 		 *  Key name is coerced to string at compile time (and ends up as a
 		 *  a string constant) even for numeric keys (e.g. "{1:'foo'}").
 		 *  These could be emitted using e.g. LDINT, but that seems hardly
 		 *  worth the effort and would increase code size.
 		 */
 
-		DUK_DDD(DUK_DDDPRINT("object literal loop, curr_token->t = %ld",
-		                     (long) comp_ctx->curr_token.t));
+		DUK_DDD(DUK_DDDPRINT("object literal loop, curr_token->t = %ld", (long) comp_ctx->curr_token.t));
 
 		if (comp_ctx->curr_token.t == DUK_TOK_RCURLY) {
 			break;
 		}
 
 		if (first) {
 			first = 0;
@@ -71041,64 +72373,59 @@
 
 		/* NOTE: "get" and "set" are not officially ReservedWords and the lexer
 		 * currently treats them always like ordinary identifiers (DUK_TOK_GET
 		 * and DUK_TOK_SET are unused).  They need to be detected based on the
 		 * identifier string content.
 		 */
 
-		is_get = (comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER &&
-		          comp_ctx->prev_token.str1 == DUK_HTHREAD_STRING_GET(thr));
-		is_set = (comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER &&
-		          comp_ctx->prev_token.str1 == DUK_HTHREAD_STRING_SET(thr));
+		is_get = (comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER && comp_ctx->prev_token.str1 == DUK_HTHREAD_STRING_GET(thr));
+		is_set = (comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER && comp_ctx->prev_token.str1 == DUK_HTHREAD_STRING_SET(thr));
 		if ((is_get || is_set) && comp_ctx->curr_token.t != DUK_TOK_COLON) {
 			/* getter/setter */
 			duk_int_t fnum;
 
 			duk__objlit_flush_keys(comp_ctx, &st);
-			DUK_ASSERT(DUK__GETTEMP(comp_ctx) == st.temp_start);  /* 2 regs are guaranteed to be allocated w.r.t. temp_max */
+			DUK_ASSERT(DUK__GETTEMP(comp_ctx) ==
+			           st.temp_start); /* 2 regs are guaranteed to be allocated w.r.t. temp_max */
 			reg_temp = DUK__ALLOCTEMPS(comp_ctx, 2);
 
 			if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->curr_token, reg_temp) != 0) {
 				goto syntax_error;
 			}
 
 			/* curr_token = get/set name */
 			fnum = duk__parse_func_like_fnum(comp_ctx, DUK__FUNC_FLAG_GETSET);
 
-			duk__emit_a_bc(comp_ctx,
-			               DUK_OP_CLOSURE,
-			               st.temp_start + 1,
-			               (duk_regconst_t) fnum);
+			duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, st.temp_start + 1, (duk_regconst_t) fnum);
 
 			/* Slot C is used in a non-standard fashion (range of regs),
 			 * emitter code has special handling for it (must not set the
 			 * "no shuffle" flag).
 			 */
 			duk__emit_a_bc(comp_ctx,
-			              (is_get ? DUK_OP_INITGET : DUK_OP_INITSET) | DUK__EMIT_FLAG_A_IS_SOURCE,
-			              st.reg_obj,
-			              st.temp_start);   /* temp_start+0 = key, temp_start+1 = closure */
+			               (is_get ? DUK_OP_INITGET : DUK_OP_INITSET) | DUK__EMIT_FLAG_A_IS_SOURCE,
+			               st.reg_obj,
+			               st.temp_start); /* temp_start+0 = key, temp_start+1 = closure */
 
-			DUK_ASSERT(st.num_pairs == 0);  /* temp state is reset on next loop */
+			DUK_ASSERT(st.num_pairs == 0); /* temp state is reset on next loop */
 #if defined(DUK_USE_ES6)
 		} else if (comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER &&
 		           (comp_ctx->curr_token.t == DUK_TOK_COMMA || comp_ctx->curr_token.t == DUK_TOK_RCURLY)) {
 			duk_bool_t load_rc;
 
 			load_rc = duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp);
 			DUK_UNREF(load_rc);
-			DUK_ASSERT(load_rc == 0);  /* always succeeds because token is identifier */
+			DUK_ASSERT(load_rc == 0); /* always succeeds because token is identifier */
 
 			duk__ivalue_var_hstring(comp_ctx, res, comp_ctx->prev_token.str1);
 			DUK_ASSERT(DUK__GETTEMP(comp_ctx) == reg_temp + 1);
 			duk__ivalue_toforcedreg(comp_ctx, res, reg_temp + 1);
 
 			st.num_pairs++;
-		} else if ((comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER ||
-		            comp_ctx->prev_token.t == DUK_TOK_STRING ||
+		} else if ((comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER || comp_ctx->prev_token.t == DUK_TOK_STRING ||
 		            comp_ctx->prev_token.t == DUK_TOK_NUMBER) &&
 		           comp_ctx->curr_token.t == DUK_TOK_LPAREN) {
 			duk_int_t fnum;
 
 			/* Parsing-wise there's a small hickup here: the token parsing
 			 * state is one step too advanced for the function parse helper
 			 * compared to other cases.  The current solution is an extra
@@ -71108,21 +72435,18 @@
 
 			if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
 				goto syntax_error;
 			}
 
 			fnum = duk__parse_func_like_fnum(comp_ctx, DUK__FUNC_FLAG_USE_PREVTOKEN | DUK__FUNC_FLAG_METDEF);
 
-			duk__emit_a_bc(comp_ctx,
-			               DUK_OP_CLOSURE,
-			               reg_temp + 1,
-			               (duk_regconst_t) fnum);
+			duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, reg_temp + 1, (duk_regconst_t) fnum);
 
 			st.num_pairs++;
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 		} else {
 #if defined(DUK_USE_ES6)
 			if (comp_ctx->prev_token.t == DUK_TOK_LBRACKET) {
 				/* ES2015 computed property name.  Executor ToPropertyKey()
 				 * coerces the key at runtime.
 				 */
 				DUK__SETTEMP(comp_ctx, reg_temp);
@@ -71131,31 +72455,30 @@
 
 				/* XXX: If next token is '(' we're dealing with
 				 * the method shorthand with a computed name,
 				 * e.g. { [Symbol.for('foo')](a,b) {} }.  This
 				 * form is not yet supported and causes a
 				 * SyntaxError on the DUK_TOK_COLON check below.
 				 */
-			}
-			else
-#endif  /* DUK_USE_ES6 */
+			} else
+#endif /* DUK_USE_ES6 */
 			{
 				if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
 					goto syntax_error;
 				}
 			}
 
 			duk__advance_expect(comp_ctx, DUK_TOK_COLON);
 
 			DUK__SETTEMP(comp_ctx, reg_temp + 1);
 			duk__expr_toforcedreg(comp_ctx, res, DUK__BP_COMMA /*rbp_flags*/, reg_temp + 1 /*forced_reg*/);
 
 			st.num_pairs++;
 		}
-	}  /* property loop */
+	} /* property loop */
 
 	/* Flush remaining properties. */
 	duk__objlit_flush_keys(comp_ctx, &st);
 	DUK_ASSERT(st.num_pairs == 0);
 	DUK_ASSERT(DUK__GETTEMP(comp_ctx) == st.temp_start);
 
 	/* Update initial size for NEWOBJ.  The init size doesn't need to be
@@ -71166,20 +72489,20 @@
 	 */
 #if !defined(DUK_USE_PREFER_SIZE)
 	instr = duk__get_instr_ptr(comp_ctx, pc_newobj);
 	instr->ins |= DUK_ENC_OP_A(0, st.num_total_pairs > DUK_BC_A_MAX ? DUK_BC_A_MAX : st.num_total_pairs);
 #endif
 
 	DUK_ASSERT(comp_ctx->curr_token.t == DUK_TOK_RCURLY);
-	duk__advance(comp_ctx);  /* No RegExp after object literal. */
+	duk__advance(comp_ctx); /* No RegExp after object literal. */
 
 	duk__ivalue_regconst(res, st.reg_obj);
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_OBJECT_LITERAL);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Parse argument list.  Arguments are written to temps starting from
  * "next temp".  Returns number of arguments parsed.  Expects left paren
  * to be already eaten, and eats the right paren before returning.
@@ -71187,15 +72510,16 @@
 DUK_LOCAL duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_int_t nargs = 0;
 	duk_regconst_t reg_temp;
 
 	/* Note: expect that caller has already eaten the left paren */
 
 	DUK_DDD(DUK_DDDPRINT("start parsing arguments, prev_token.t=%ld, curr_token.t=%ld",
-	                     (long) comp_ctx->prev_token.t, (long) comp_ctx->curr_token.t));
+	                     (long) comp_ctx->prev_token.t,
+	                     (long) comp_ctx->curr_token.t));
 
 	for (;;) {
 		if (comp_ctx->curr_token.t == DUK_TOK_RPAREN) {
 			break;
 		}
 		if (nargs > 0) {
 			duk__advance_expect(comp_ctx, DUK_TOK_COMMA);
@@ -71204,46 +72528,48 @@
 		/* We want the argument expression value to go to "next temp"
 		 * without additional moves.  That should almost always be the
 		 * case, but we double check after expression parsing.
 		 *
 		 * This is not the cleanest possible approach.
 		 */
 
-		reg_temp = DUK__ALLOCTEMP(comp_ctx);  /* bump up "allocated" reg count, just in case */
+		reg_temp = DUK__ALLOCTEMP(comp_ctx); /* bump up "allocated" reg count, just in case */
 		DUK__SETTEMP(comp_ctx, reg_temp);
 
 		/* binding power must be high enough to NOT allow comma expressions directly */
-		duk__expr_toforcedreg(comp_ctx, res, DUK__BP_COMMA /*rbp_flags*/, reg_temp);  /* always allow 'in', coerce to 'tr' just in case */
+		duk__expr_toforcedreg(comp_ctx,
+		                      res,
+		                      DUK__BP_COMMA /*rbp_flags*/,
+		                      reg_temp); /* always allow 'in', coerce to 'tr' just in case */
 
 		DUK__SETTEMP(comp_ctx, reg_temp + 1);
 		nargs++;
 
 		DUK_DDD(DUK_DDDPRINT("argument #%ld written into reg %ld", (long) nargs, (long) reg_temp));
 	}
 
 	/* eat the right paren */
-	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* RegExp mode does not matter. */
+	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* RegExp mode does not matter. */
 
 	DUK_DDD(DUK_DDDPRINT("end parsing arguments"));
 
 	return nargs;
 }
 
 DUK_LOCAL duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx) {
 	/* empty expressions can be detected conveniently with nud/led counts */
-	return (comp_ctx->curr_func.nud_count == 0) &&
-	       (comp_ctx->curr_func.led_count == 0);
+	return (comp_ctx->curr_func.nud_count == 0) && (comp_ctx->curr_func.led_count == 0);
 }
 
 DUK_LOCAL void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_token *tk;
 	duk_regconst_t temp_at_entry;
 	duk_small_uint_t tok;
-	duk_uint32_t args;  /* temp variable to pass constants and flags to shared code */
+	duk_uint32_t args; /* temp variable to pass constants and flags to shared code */
 
 	/*
 	 *  ctx->prev_token     token to process with duk__expr_nud()
 	 *  ctx->curr_token     updated by caller
 	 *
 	 *  Note: the token in the switch below has already been eaten.
 	 */
@@ -71253,26 +72579,25 @@
 	comp_ctx->curr_func.nud_count++;
 
 	tk = &comp_ctx->prev_token;
 	tok = tk->t;
 	res->t = DUK_IVAL_NONE;
 
 	DUK_DDD(DUK_DDDPRINT("duk__expr_nud(), prev_token.t=%ld, allow_in=%ld, paren_level=%ld",
-	                     (long) tk->t, (long) comp_ctx->curr_func.allow_in, (long) comp_ctx->curr_func.paren_level));
+	                     (long) tk->t,
+	                     (long) comp_ctx->curr_func.allow_in,
+	                     (long) comp_ctx->curr_func.paren_level));
 
 	switch (tok) {
-
-	/* PRIMARY EXPRESSIONS */
+		/* PRIMARY EXPRESSIONS */
 
 	case DUK_TOK_THIS: {
 		duk_regconst_t reg_temp;
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
-		duk__emit_bc(comp_ctx,
-		             DUK_OP_LDTHIS,
-		             reg_temp);
+		duk__emit_bc(comp_ctx, DUK_OP_LDTHIS, reg_temp);
 		duk__ivalue_regconst(res, reg_temp);
 		return;
 	}
 	case DUK_TOK_IDENTIFIER: {
 		duk__ivalue_var_hstring(comp_ctx, res, tk->str1);
 		return;
 	}
@@ -71296,23 +72621,21 @@
 		DUK_ASSERT(tk->str1 != NULL);
 		duk_push_hstring(thr, tk->str1);
 		goto plain_value;
 	}
 	case DUK_TOK_REGEXP: {
 #if defined(DUK_USE_REGEXP_SUPPORT)
 		duk_regconst_t reg_temp;
-		duk_regconst_t rc_re_bytecode;  /* const */
-		duk_regconst_t rc_re_source;    /* const */
+		duk_regconst_t rc_re_bytecode; /* const */
+		duk_regconst_t rc_re_source; /* const */
 
 		DUK_ASSERT(tk->str1 != NULL);
 		DUK_ASSERT(tk->str2 != NULL);
 
-		DUK_DDD(DUK_DDDPRINT("emitting regexp op, str1=%!O, str2=%!O",
-		                     (duk_heaphdr *) tk->str1,
-		                     (duk_heaphdr *) tk->str2));
+		DUK_DDD(DUK_DDDPRINT("emitting regexp op, str1=%!O, str2=%!O", (duk_heaphdr *) tk->str1, (duk_heaphdr *) tk->str2));
 
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
 		duk_push_hstring(thr, tk->str1);
 		duk_push_hstring(thr, tk->str2);
 
 		/* [ ... pattern flags ] */
 
@@ -71327,17 +72650,17 @@
 		                DUK_OP_REGEXP | DUK__EMIT_FLAG_BC_REGCONST,
 		                reg_temp /*a*/,
 		                rc_re_bytecode /*b*/,
 		                rc_re_source /*c*/);
 
 		duk__ivalue_regconst(res, reg_temp);
 		return;
-#else  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
 		goto syntax_error;
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 	}
 	case DUK_TOK_LBRACKET: {
 		DUK_DDD(DUK_DDDPRINT("parsing array literal"));
 		duk__nud_array_literal(comp_ctx, res);
 		return;
 	}
 	case DUK_TOK_LCURLY: {
@@ -71348,23 +72671,23 @@
 	case DUK_TOK_LPAREN: {
 		duk_bool_t prev_allow_in;
 
 		comp_ctx->curr_func.paren_level++;
 		prev_allow_in = comp_ctx->curr_func.allow_in;
 		comp_ctx->curr_func.allow_in = 1; /* reset 'allow_in' for parenthesized expression */
 
-		duk__expr(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);  /* Expression, terminates at a ')' */
+		duk__expr(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/); /* Expression, terminates at a ')' */
 
-		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* No RegExp after parenthesized expression. */
+		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* No RegExp after parenthesized expression. */
 		comp_ctx->curr_func.allow_in = prev_allow_in;
 		comp_ctx->curr_func.paren_level--;
 		return;
 	}
 
-	/* MEMBER/NEW/CALL EXPRESSIONS */
+		/* MEMBER/NEW/CALL EXPRESSIONS */
 
 	case DUK_TOK_NEW: {
 		/*
 		 *  Parsing an expression starting with 'new' is tricky because
 		 *  there are multiple possible productions deriving from
 		 *  LeftHandSideExpression which begin with 'new'.
 		 *
@@ -71393,54 +72716,49 @@
 			    !duk_hstring_equals_ascii_cstring(comp_ctx->curr_token.str1, "target")) {
 				goto syntax_error_newtarget;
 			}
 			if (comp_ctx->curr_func.is_global) {
 				goto syntax_error_newtarget;
 			}
 			duk__advance(comp_ctx);
-			duk__emit_bc(comp_ctx,
-			             DUK_OP_NEWTARGET,
-			             reg_target);
+			duk__emit_bc(comp_ctx, DUK_OP_NEWTARGET, reg_target);
 			duk__ivalue_regconst(res, reg_target);
 			return;
 		}
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 		duk__expr_toforcedreg(comp_ctx, res, DUK__BP_CALL /*rbp_flags*/, reg_target /*forced_reg*/);
-		duk__emit_bc(comp_ctx, DUK_OP_NEWOBJ, reg_target + 1);  /* default instance */
+		duk__emit_bc(comp_ctx, DUK_OP_NEWOBJ, reg_target + 1); /* default instance */
 		DUK__SETTEMP(comp_ctx, reg_target + 2);
 
 		/* XXX: 'new obj.noSuch()' doesn't use GETPROPC now which
 		 * makes the error message worse than for obj.noSuch().
 		 */
 
 		if (comp_ctx->curr_token.t == DUK_TOK_LPAREN) {
 			/* 'new' MemberExpression Arguments */
 			DUK_DDD(DUK_DDDPRINT("new expression has argument list"));
 			duk__advance(comp_ctx);
-			nargs = duk__parse_arguments(comp_ctx, res);  /* parse args starting from "next temp", reg_target + 1 */
+			nargs = duk__parse_arguments(comp_ctx, res); /* parse args starting from "next temp", reg_target + 1 */
 			/* right paren eaten */
 		} else {
 			/* 'new' MemberExpression */
 			DUK_DDD(DUK_DDDPRINT("new expression has no argument list"));
 			nargs = 0;
 		}
 
-		duk__emit_a_bc(comp_ctx,
-		              DUK_OP_CALL0 | DUK_BC_CALL_FLAG_CONSTRUCT,
-		              nargs /*num_args*/,
-		              reg_target /*target*/);
+		duk__emit_a_bc(comp_ctx, DUK_OP_CALL0 | DUK_BC_CALL_FLAG_CONSTRUCT, nargs /*num_args*/, reg_target /*target*/);
 
 		DUK_DDD(DUK_DDDPRINT("end parsing new expression"));
 
 		duk__ivalue_regconst(res, reg_target);
 		return;
 	}
 
-	/* FUNCTION EXPRESSIONS */
+		/* FUNCTION EXPRESSIONS */
 
 	case DUK_TOK_FUNCTION: {
 		/* Function expression.  Note that any statement beginning with 'function'
 		 * is handled by the statement parser as a function declaration, or a
 		 * non-standard function expression/statement (or a SyntaxError).  We only
 		 * handle actual function expressions (occurring inside an expression) here.
 		 *
@@ -71455,32 +72773,29 @@
 
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
 
 		/* curr_token follows 'function' */
 		fnum = duk__parse_func_like_fnum(comp_ctx, 0 /*flags*/);
 		DUK_DDD(DUK_DDDPRINT("parsed inner function -> fnum %ld", (long) fnum));
 
-		duk__emit_a_bc(comp_ctx,
-		               DUK_OP_CLOSURE,
-		               reg_temp /*a*/,
-		               (duk_regconst_t) fnum /*bc*/);
+		duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, reg_temp /*a*/, (duk_regconst_t) fnum /*bc*/);
 
 		duk__ivalue_regconst(res, reg_temp);
 		return;
 	}
 
-	/* UNARY EXPRESSIONS */
+		/* UNARY EXPRESSIONS */
 
 	case DUK_TOK_DELETE: {
 		/* Delete semantics are a bit tricky.  The description in E5 specification
 		 * is kind of confusing, because it distinguishes between resolvability of
 		 * a reference (which is only known at runtime) seemingly at compile time
 		 * (= SyntaxError throwing).
 		 */
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
 		if (res->t == DUK_IVAL_VAR) {
 			/* not allowed in strict mode, regardless of whether resolves;
 			 * in non-strict mode DELVAR handles both non-resolving and
 			 * resolving cases (the specification description is a bit confusing).
 			 */
 
 			duk_regconst_t reg_temp;
@@ -71494,76 +72809,66 @@
 
 			DUK__SETTEMP(comp_ctx, temp_at_entry);
 			reg_temp = DUK__ALLOCTEMP(comp_ctx);
 
 			duk_dup(thr, res->x1.valstack_idx);
 			if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
 				/* register bound variables are non-configurable -> always false */
-				duk__emit_bc(comp_ctx,
-				             DUK_OP_LDFALSE,
-				             reg_temp);
+				duk__emit_bc(comp_ctx, DUK_OP_LDFALSE, reg_temp);
 			} else {
 				duk_dup(thr, res->x1.valstack_idx);
 				rc_varname = duk__getconst(comp_ctx);
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_DELVAR,
-				               reg_temp,
-				               rc_varname);
+				duk__emit_a_bc(comp_ctx, DUK_OP_DELVAR, reg_temp, rc_varname);
 			}
 			duk__ivalue_regconst(res, reg_temp);
 		} else if (res->t == DUK_IVAL_PROP) {
 			duk_regconst_t reg_temp;
 			duk_regconst_t reg_obj;
 			duk_regconst_t rc_key;
 
 			DUK__SETTEMP(comp_ctx, temp_at_entry);
 			reg_temp = DUK__ALLOCTEMP(comp_ctx);
-			reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 /*forced_reg*/, 0 /*flags*/);  /* don't allow const */
-			rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
-			duk__emit_a_b_c(comp_ctx,
-			                DUK_OP_DELPROP | DUK__EMIT_FLAG_BC_REGCONST,
-			                reg_temp,
-			                reg_obj,
-			                rc_key);
+			reg_obj =
+			    duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 /*forced_reg*/, 0 /*flags*/); /* don't allow const */
+			rc_key =
+			    duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
+			duk__emit_a_b_c(comp_ctx, DUK_OP_DELPROP | DUK__EMIT_FLAG_BC_REGCONST, reg_temp, reg_obj, rc_key);
 
 			duk__ivalue_regconst(res, reg_temp);
 		} else {
 			/* non-Reference deletion is always 'true', even in strict mode */
 			duk_push_true(thr);
 			goto plain_value;
 		}
 		return;
 	}
 	case DUK_TOK_VOID: {
-		duk__expr_toplain_ignore(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
+		duk__expr_toplain_ignore(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
 		duk_push_undefined(thr);
 		goto plain_value;
 	}
 	case DUK_TOK_TYPEOF: {
 		/* 'typeof' must handle unresolvable references without throwing
 		 * a ReferenceError (E5 Section 11.4.3).  Register mapped values
 		 * will never be unresolvable so special handling is only required
 		 * when an identifier is a "slow path" one.
 		 */
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
 
 		if (res->t == DUK_IVAL_VAR) {
 			duk_regconst_t reg_varbind;
 			duk_regconst_t rc_varname;
 			duk_regconst_t reg_temp;
 
 			duk_dup(thr, res->x1.valstack_idx);
 			if (!duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
 				DUK_DDD(DUK_DDDPRINT("typeof for an identifier name which could not be resolved "
 				                     "at compile time, need to use special run-time handling"));
 				reg_temp = DUK__ALLOCTEMP(comp_ctx);
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_TYPEOFID,
-				               reg_temp,
-				               rc_varname);
+				duk__emit_a_bc(comp_ctx, DUK_OP_TYPEOFID, reg_temp, rc_varname);
 				duk__ivalue_regconst(res, reg_temp);
 				return;
 			}
 		}
 
 		args = DUK_OP_TYPEOF;
 		goto unary;
@@ -71574,28 +72879,26 @@
 	}
 	case DUK_TOK_DECREMENT: {
 		args = (DUK_OP_PREDECP << 8) + DUK_OP_PREDECR;
 		goto preincdec;
 	}
 	case DUK_TOK_ADD: {
 		/* unary plus */
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
-		if (res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_VALUE &&
-		    duk_is_number(thr, res->x1.valstack_idx)) {
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
+		if (res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_VALUE && duk_is_number(thr, res->x1.valstack_idx)) {
 			/* unary plus of a number is identity */
 			return;
 		}
 		args = DUK_OP_UNP;
 		goto unary;
 	}
 	case DUK_TOK_SUB: {
 		/* unary minus */
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
-		if (res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_VALUE &&
-		    duk_is_number(thr, res->x1.valstack_idx)) {
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
+		if (res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_VALUE && duk_is_number(thr, res->x1.valstack_idx)) {
 			/* this optimization is important to handle negative literals
 			 * (which are not directly provided by the lexical grammar)
 			 */
 			duk_tval *tv_num;
 			duk_double_union du;
 
 			tv_num = DUK_GET_TVAL_POSIDX(thr, res->x1.valstack_idx);
@@ -71607,20 +72910,20 @@
 			DUK_TVAL_SET_NUMBER(tv_num, du.d);
 			return;
 		}
 		args = DUK_OP_UNM;
 		goto unary;
 	}
 	case DUK_TOK_BNOT: {
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
 		args = DUK_OP_BNOT;
 		goto unary;
 	}
 	case DUK_TOK_LNOT: {
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
+		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
 		if (res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_VALUE) {
 			/* Very minimal inlining to handle common idioms '!0' and '!1',
 			 * and also boolean arguments like '!false' and '!true'.
 			 */
 			duk_tval *tv_val;
 
 			tv_val = DUK_GET_TVAL_POSIDX(thr, res->x1.valstack_idx);
@@ -71647,158 +72950,152 @@
 				return;
 			}
 		}
 		args = DUK_OP_LNOT;
 		goto unary;
 	}
 
-	}  /* end switch */
+	} /* end switch */
 
 	DUK_ERROR_SYNTAX(thr, DUK_STR_PARSE_ERROR);
 	DUK_WO_NORETURN(return;);
 
- unary:
-	{
-		/* Unary opcodes use just the 'BC' register source because it
-		 * matches current shuffle limits, and maps cleanly to 16 high
-		 * bits of the opcode.
-		 */
-
-		duk_regconst_t reg_src, reg_res;
-
-		reg_src = duk__ivalue_toregconst_raw(comp_ctx, res, -1 /*forced_reg*/, 0 /*flags*/);
-		if (DUK__ISREG_TEMP(comp_ctx, reg_src)) {
-			reg_res = reg_src;
-		} else {
-			reg_res = DUK__ALLOCTEMP(comp_ctx);
-		}
-		duk__emit_a_bc(comp_ctx,
-		             args,
-		             reg_res,
-		             reg_src);
-		duk__ivalue_regconst(res, reg_res);
-		return;
-	}
+unary : {
+	/* Unary opcodes use just the 'BC' register source because it
+	 * matches current shuffle limits, and maps cleanly to 16 high
+	 * bits of the opcode.
+	 */
 
- preincdec:
-	{
-		/* preincrement and predecrement */
-		duk_regconst_t reg_res;
-		duk_small_uint_t args_op1 = args & 0xff;  /* DUK_OP_PREINCR/DUK_OP_PREDECR */
-		duk_small_uint_t args_op2 = args >> 8;    /* DUK_OP_PREINCP_RR/DUK_OP_PREDECP_RR */
-
-		/* Specific assumptions for opcode numbering. */
-		DUK_ASSERT(DUK_OP_PREINCR + 4 == DUK_OP_PREINCV);
-		DUK_ASSERT(DUK_OP_PREDECR + 4 == DUK_OP_PREDECV);
+	duk_regconst_t reg_src, reg_res;
 
+	reg_src = duk__ivalue_toregconst_raw(comp_ctx, res, -1 /*forced_reg*/, 0 /*flags*/);
+	if (DUK__ISREG_TEMP(comp_ctx, reg_src)) {
+		reg_res = reg_src;
+	} else {
 		reg_res = DUK__ALLOCTEMP(comp_ctx);
+	}
+	duk__emit_a_bc(comp_ctx, args, reg_res, reg_src);
+	duk__ivalue_regconst(res, reg_res);
+	return;
+}
 
-		duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/);  /* UnaryExpression */
-		if (res->t == DUK_IVAL_VAR) {
-			duk_hstring *h_varname;
-			duk_regconst_t reg_varbind;
-			duk_regconst_t rc_varname;
-
-			h_varname = duk_known_hstring(thr, res->x1.valstack_idx);
+preincdec : {
+	/* preincrement and predecrement */
+	duk_regconst_t reg_res;
+	duk_small_uint_t args_op1 = args & 0xff; /* DUK_OP_PREINCR/DUK_OP_PREDECR */
+	duk_small_uint_t args_op2 = args >> 8; /* DUK_OP_PREINCP_RR/DUK_OP_PREDECP_RR */
+
+	/* Specific assumptions for opcode numbering. */
+	DUK_ASSERT(DUK_OP_PREINCR + 4 == DUK_OP_PREINCV);
+	DUK_ASSERT(DUK_OP_PREDECR + 4 == DUK_OP_PREDECV);
+
+	reg_res = DUK__ALLOCTEMP(comp_ctx);
+
+	duk__expr(comp_ctx, res, DUK__BP_MULTIPLICATIVE /*rbp_flags*/); /* UnaryExpression */
+	if (res->t == DUK_IVAL_VAR) {
+		duk_hstring *h_varname;
+		duk_regconst_t reg_varbind;
+		duk_regconst_t rc_varname;
 
-			if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
-				goto syntax_error;
-			}
+		h_varname = duk_known_hstring(thr, res->x1.valstack_idx);
 
-			duk_dup(thr, res->x1.valstack_idx);
-			if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
-				duk__emit_a_bc(comp_ctx,
-				               args_op1,  /* e.g. DUK_OP_PREINCR */
-				               reg_res,
-				               reg_varbind);
-			} else {
-				duk__emit_a_bc(comp_ctx,
-				                args_op1 + 4,  /* e.g. DUK_OP_PREINCV */
-				                reg_res,
-				                rc_varname);
-			}
+		if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
+			goto syntax_error;
+		}
 
-			DUK_DDD(DUK_DDDPRINT("preincdec to '%!O' -> reg_varbind=%ld, rc_varname=%ld",
-			                     (duk_heaphdr *) h_varname, (long) reg_varbind, (long) rc_varname));
-		} else if (res->t == DUK_IVAL_PROP) {
-			duk_regconst_t reg_obj;  /* allocate to reg only (not const) */
-			duk_regconst_t rc_key;
-			reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 /*forced_reg*/, 0 /*flags*/);  /* don't allow const */
-			rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
-			duk__emit_a_b_c(comp_ctx,
-			                args_op2 | DUK__EMIT_FLAG_BC_REGCONST,  /* e.g. DUK_OP_PREINCP */
-			                reg_res,
-			                reg_obj,
-			                rc_key);
+		duk_dup(thr, res->x1.valstack_idx);
+		if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
+			duk__emit_a_bc(comp_ctx,
+			               args_op1, /* e.g. DUK_OP_PREINCR */
+			               reg_res,
+			               reg_varbind);
 		} else {
-			/* Technically return value is not needed because INVLHS will
-			 * unconditially throw a ReferenceError.  Coercion is necessary
-			 * for proper semantics (consider ToNumber() called for an object).
-			 * Use DUK_OP_UNP with a dummy register to get ToNumber().
-			 */
-
-			duk__ivalue_toforcedreg(comp_ctx, res, reg_res);
-			duk__emit_bc(comp_ctx,
-			             DUK_OP_UNP,
-			             reg_res);  /* for side effects, result ignored */
-			duk__emit_op_only(comp_ctx,
-			                  DUK_OP_INVLHS);
+			duk__emit_a_bc(comp_ctx,
+			               args_op1 + 4, /* e.g. DUK_OP_PREINCV */
+			               reg_res,
+			               rc_varname);
 		}
-		DUK__SETTEMP(comp_ctx, reg_res + 1);
-		duk__ivalue_regconst(res, reg_res);
-		return;
-	}
 
- plain_value:
-	{
-		/* Stack top contains plain value */
-		duk__ivalue_plain_fromstack(comp_ctx, res);
-		return;
+		DUK_DDD(DUK_DDDPRINT("preincdec to '%!O' -> reg_varbind=%ld, rc_varname=%ld",
+		                     (duk_heaphdr *) h_varname,
+		                     (long) reg_varbind,
+		                     (long) rc_varname));
+	} else if (res->t == DUK_IVAL_PROP) {
+		duk_regconst_t reg_obj; /* allocate to reg only (not const) */
+		duk_regconst_t rc_key;
+		reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 /*forced_reg*/, 0 /*flags*/); /* don't allow const */
+		rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
+		duk__emit_a_b_c(comp_ctx,
+		                args_op2 | DUK__EMIT_FLAG_BC_REGCONST, /* e.g. DUK_OP_PREINCP */
+		                reg_res,
+		                reg_obj,
+		                rc_key);
+	} else {
+		/* Technically return value is not needed because INVLHS will
+		 * unconditially throw a ReferenceError.  Coercion is necessary
+		 * for proper semantics (consider ToNumber() called for an object).
+		 * Use DUK_OP_UNP with a dummy register to get ToNumber().
+		 */
+
+		duk__ivalue_toforcedreg(comp_ctx, res, reg_res);
+		duk__emit_bc(comp_ctx, DUK_OP_UNP, reg_res); /* for side effects, result ignored */
+		duk__emit_op_only(comp_ctx, DUK_OP_INVLHS);
 	}
+	DUK__SETTEMP(comp_ctx, reg_res + 1);
+	duk__ivalue_regconst(res, reg_res);
+	return;
+}
+
+plain_value : {
+	/* Stack top contains plain value */
+	duk__ivalue_plain_fromstack(comp_ctx, res);
+	return;
+}
 
 #if defined(DUK_USE_ES6)
- syntax_error_newtarget:
+syntax_error_newtarget:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_NEWTARGET);
 	DUK_WO_NORETURN(return;);
 #endif
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_EXPRESSION);
 	DUK_WO_NORETURN(return;);
 }
 
 /* XXX: add flag to indicate whether caller cares about return value; this
  * affects e.g. handling of assignment expressions.  This change needs API
  * changes elsewhere too.
  */
 DUK_LOCAL void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_token *tk;
 	duk_small_uint_t tok;
-	duk_uint32_t args;  /* temp variable to pass constants and flags to shared code */
+	duk_uint32_t args; /* temp variable to pass constants and flags to shared code */
 
 	/*
 	 *  ctx->prev_token     token to process with duk__expr_led()
 	 *  ctx->curr_token     updated by caller
 	 */
 
 	comp_ctx->curr_func.led_count++;
 
 	/* The token in the switch has already been eaten here */
 	tk = &comp_ctx->prev_token;
 	tok = tk->t;
 
 	DUK_DDD(DUK_DDDPRINT("duk__expr_led(), prev_token.t=%ld, allow_in=%ld, paren_level=%ld",
-	                     (long) tk->t, (long) comp_ctx->curr_func.allow_in, (long) comp_ctx->curr_func.paren_level));
+	                     (long) tk->t,
+	                     (long) comp_ctx->curr_func.allow_in,
+	                     (long) comp_ctx->curr_func.paren_level));
 
 	/* XXX: default priority for infix operators is duk__expr_lbp(tok) -> get it here? */
 
 	switch (tok) {
-
-	/* PRIMARY EXPRESSIONS */
+		/* PRIMARY EXPRESSIONS */
 
 	case DUK_TOK_PERIOD: {
 		/* Property access expressions are critical for correct LHS ordering,
 		 * see comments in duk__expr()!
 		 *
 		 * A conservative approach would be to use duk__ivalue_totempconst()
 		 * for 'left'.  However, allowing a reg-bound variable seems safe here
@@ -71818,15 +73115,15 @@
 		/* NB: must accept reserved words as property name */
 		if (comp_ctx->curr_token.t_nores != DUK_TOK_IDENTIFIER) {
 			DUK_ERROR_SYNTAX(thr, DUK_STR_EXPECTED_IDENTIFIER);
 			DUK_WO_NORETURN(return;);
 		}
 
 		res->t = DUK_IVAL_PROP;
-		duk__copy_ispec(comp_ctx, &left->x1, &res->x1);  /* left.x1 -> res.x1 */
+		duk__copy_ispec(comp_ctx, &left->x1, &res->x1); /* left.x1 -> res.x1 */
 		DUK_ASSERT(comp_ctx->curr_token.str1 != NULL);
 		duk_push_hstring(thr, comp_ctx->curr_token.str1);
 		duk_replace(thr, res->x2.valstack_idx);
 		res->x2.t = DUK_ISPEC_VALUE;
 
 		/* special RegExp literal handling after IdentifierName */
 		comp_ctx->curr_func.reject_regexp_in_adv = 1;
@@ -71853,20 +73150,20 @@
 		/* The 'left' value must not be a register bound variable
 		 * because it may be mutated during the rest of the expression
 		 * and E5.1 Section 11.2.1 specifies the order of evaluation
 		 * so that the base value is evaluated first.
 		 * See: test-bug-nested-prop-mutate.js.
 		 */
 		duk__ivalue_totempconst(comp_ctx, left);
-		duk__expr_toplain(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);  /* Expression, ']' terminates */
+		duk__expr_toplain(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/); /* Expression, ']' terminates */
 		duk__advance_expect(comp_ctx, DUK_TOK_RBRACKET);
 
 		res->t = DUK_IVAL_PROP;
-		duk__copy_ispec(comp_ctx, &res->x1, &res->x2);   /* res.x1 -> res.x2 */
-		duk__copy_ispec(comp_ctx, &left->x1, &res->x1);  /* left.x1 -> res.x1 */
+		duk__copy_ispec(comp_ctx, &res->x1, &res->x2); /* res.x1 -> res.x2 */
+		duk__copy_ispec(comp_ctx, &left->x1, &res->x1); /* left.x1 -> res.x1 */
 		return;
 	}
 	case DUK_TOK_LPAREN: {
 		/* function call */
 		duk_regconst_t reg_cs = DUK__ALLOCTEMPS(comp_ctx, 2);
 		duk_int_t nargs;
 		duk_small_uint_t call_op = DUK_OP_CALL0;
@@ -71902,27 +73199,21 @@
 				                     "as may_direct_eval"));
 				call_op |= DUK_BC_CALL_FLAG_CALLED_AS_EVAL;
 				comp_ctx->curr_func.may_direct_eval = 1;
 			}
 
 			duk_dup(thr, left->x1.valstack_idx);
 			if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
-				duk__emit_a_bc(comp_ctx,
-				              DUK_OP_CSREG | DUK__EMIT_FLAG_A_IS_SOURCE,
-				              reg_varbind,
-				              reg_cs + 0);
+				duk__emit_a_bc(comp_ctx, DUK_OP_CSREG | DUK__EMIT_FLAG_A_IS_SOURCE, reg_varbind, reg_cs + 0);
 			} else {
 				/* XXX: expand target register or constant field to
 				 * reduce shuffling.
 				 */
 				DUK_ASSERT(DUK__ISCONST(rc_varname));
-				duk__emit_a_b(comp_ctx,
-				              DUK_OP_CSVAR | DUK__EMIT_FLAG_BC_REGCONST,
-				              reg_cs + 0,
-				              rc_varname);
+				duk__emit_a_b(comp_ctx, DUK_OP_CSVAR | DUK__EMIT_FLAG_BC_REGCONST, reg_cs + 0, rc_varname);
 			}
 		} else if (left->t == DUK_IVAL_PROP) {
 			/* Call through a property lookup, E5 Section 11.2.3, step 6.a.i,
 			 * E5 Section 10.4.3.  There used to be a separate CSPROP opcode
 			 * but a typical call setup took 3 opcodes (e.g. LDREG, LDCONST,
 			 * CSPROP) and the same can be achieved with ordinary loads.
 			 */
@@ -71936,24 +73227,20 @@
 			 * GETPROPC + call.  The LDREG is unnecessary because LDCONST
 			 * could be loaded directly into reg_cs + 1.  This doesn't
 			 * happen now because a variable cannot be in left->x1 of a
 			 * DUK_IVAL_PROP.  We could notice that left->x1 is a temp
 			 * and reuse, but it would still be in the wrong position
 			 * (reg_cs + 0 rather than reg_cs + 1).
 			 */
-			duk__ispec_toforcedreg(comp_ctx, &left->x1, reg_cs + 1);  /* base */
+			duk__ispec_toforcedreg(comp_ctx, &left->x1, reg_cs + 1); /* base */
 #if defined(DUK_USE_VERBOSE_ERRORS)
 			reg_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
-			duk__emit_a_b_c(comp_ctx,
-			                DUK_OP_GETPROPC | DUK__EMIT_FLAG_BC_REGCONST,
-			                reg_cs + 0,
-			                reg_cs + 1,
-			                reg_key);
+			duk__emit_a_b_c(comp_ctx, DUK_OP_GETPROPC | DUK__EMIT_FLAG_BC_REGCONST, reg_cs + 0, reg_cs + 1, reg_key);
 #else
-			duk__ivalue_toforcedreg(comp_ctx, left, reg_cs + 0);  /* base[key] */
+			duk__ivalue_toforcedreg(comp_ctx, left, reg_cs + 0); /* base[key] */
 #endif
 		} else {
 			DUK_DDD(DUK_DDDPRINT("function call with register base"));
 
 			duk__ivalue_toforcedreg(comp_ctx, left, reg_cs + 0);
 #if 0
 			duk__emit_a_bc(comp_ctx,
@@ -71964,77 +73251,74 @@
 			/* Because of in-place setup, REGCS is equivalent to
 			 * just this LDUNDEF.
 			 */
 			duk__emit_bc(comp_ctx, DUK_OP_LDUNDEF, reg_cs + 1);
 		}
 
 		DUK__SETTEMP(comp_ctx, reg_cs + 2);
-		nargs = duk__parse_arguments(comp_ctx, res);  /* parse args starting from "next temp" */
+		nargs = duk__parse_arguments(comp_ctx, res); /* parse args starting from "next temp" */
 
 		/* Tailcalls are handled by back-patching the already emitted opcode
 		 * later in return statement parser.
 		 */
 
-		duk__emit_a_bc(comp_ctx,
-		               call_op,
-		               (duk_regconst_t) nargs /*numargs*/,
-		               reg_cs /*basereg*/);
-		DUK__SETTEMP(comp_ctx, reg_cs + 1);    /* result in csreg */
+		duk__emit_a_bc(comp_ctx, call_op, (duk_regconst_t) nargs /*numargs*/, reg_cs /*basereg*/);
+		DUK__SETTEMP(comp_ctx, reg_cs + 1); /* result in csreg */
 
 		duk__ivalue_regconst(res, reg_cs);
 		return;
 	}
 
-	/* POSTFIX EXPRESSION */
+		/* POSTFIX EXPRESSION */
 
 	case DUK_TOK_INCREMENT: {
 		args = (DUK_OP_POSTINCP_RR << 16) + (DUK_OP_POSTINCR << 8) + 0;
 		goto postincdec;
 	}
 	case DUK_TOK_DECREMENT: {
 		args = (DUK_OP_POSTDECP_RR << 16) + (DUK_OP_POSTDECR << 8) + 0;
 		goto postincdec;
 	}
 
 	/* EXPONENTIATION EXPRESSION */
 
 #if defined(DUK_USE_ES7_EXP_OPERATOR)
 	case DUK_TOK_EXP: {
-		args = (DUK_OP_EXP << 8) + DUK__BP_EXPONENTIATION - 1;  /* UnaryExpression */
+		args = (DUK_OP_EXP << 8) + DUK__BP_EXPONENTIATION - 1; /* UnaryExpression */
 		goto binary;
 	}
 #endif
 
-	/* MULTIPLICATIVE EXPRESSION */
+		/* MULTIPLICATIVE EXPRESSION */
 
 	case DUK_TOK_MUL: {
-		args = (DUK_OP_MUL << 8) + DUK__BP_MULTIPLICATIVE;  /* ExponentiationExpression */
+		args = (DUK_OP_MUL << 8) + DUK__BP_MULTIPLICATIVE; /* ExponentiationExpression */
 		goto binary;
 	}
 	case DUK_TOK_DIV: {
-		args = (DUK_OP_DIV << 8) + DUK__BP_MULTIPLICATIVE;  /* ExponentiationExpression */
+		args = (DUK_OP_DIV << 8) + DUK__BP_MULTIPLICATIVE; /* ExponentiationExpression */
 		goto binary;
 	}
 	case DUK_TOK_MOD: {
-		args = (DUK_OP_MOD << 8) + DUK__BP_MULTIPLICATIVE;  /* ExponentiationExpression */
+		args = (DUK_OP_MOD << 8) + DUK__BP_MULTIPLICATIVE; /* ExponentiationExpression */
 		goto binary;
 	}
 
-	/* ADDITIVE EXPRESSION */
+		/* ADDITIVE EXPRESSION */
 
 	case DUK_TOK_ADD: {
-		args = (DUK_OP_ADD << 8) + DUK__BP_ADDITIVE;  /* MultiplicativeExpression */
+		args = (DUK_OP_ADD << 8) + DUK__BP_ADDITIVE; /* MultiplicativeExpression */
 		goto binary;
 	}
 	case DUK_TOK_SUB: {
-		args = (DUK_OP_SUB << 8) + DUK__BP_ADDITIVE;  /* MultiplicativeExpression */
+		args = (DUK_OP_SUB << 8) + DUK__BP_ADDITIVE; /* MultiplicativeExpression */
 		goto binary;
 	}
 
-	/* SHIFT EXPRESSION */
+		/* SHIFT EXPRESSION */
 
 	case DUK_TOK_ALSHIFT: {
 		/* << */
 		args = (DUK_OP_BASL << 8) + DUK__BP_SHIFT;
 		goto binary;
 	}
 	case DUK_TOK_ARSHIFT: {
@@ -72044,15 +73328,15 @@
 	}
 	case DUK_TOK_RSHIFT: {
 		/* >>> */
 		args = (DUK_OP_BLSR << 8) + DUK__BP_SHIFT;
 		goto binary;
 	}
 
-	/* RELATIONAL EXPRESSION */
+		/* RELATIONAL EXPRESSION */
 
 	case DUK_TOK_LT: {
 		/* < */
 		args = (DUK_OP_LT << 8) + DUK__BP_RELATIONAL;
 		goto binary;
 	}
 	case DUK_TOK_GT: {
@@ -72072,15 +73356,15 @@
 		goto binary;
 	}
 	case DUK_TOK_IN: {
 		args = (DUK_OP_IN << 8) + DUK__BP_RELATIONAL;
 		goto binary;
 	}
 
-	/* EQUALITY EXPRESSION */
+		/* EQUALITY EXPRESSION */
 
 	case DUK_TOK_EQ: {
 		args = (DUK_OP_EQ << 8) + DUK__BP_EQUALITY;
 		goto binary;
 	}
 	case DUK_TOK_NEQ: {
 		args = (DUK_OP_NEQ << 8) + DUK__BP_EQUALITY;
@@ -72091,83 +73375,89 @@
 		goto binary;
 	}
 	case DUK_TOK_SNEQ: {
 		args = (DUK_OP_SNEQ << 8) + DUK__BP_EQUALITY;
 		goto binary;
 	}
 
-	/* BITWISE EXPRESSIONS */
+		/* BITWISE EXPRESSIONS */
 
 	case DUK_TOK_BAND: {
 		args = (DUK_OP_BAND << 8) + DUK__BP_BAND;
 		goto binary;
 	}
 	case DUK_TOK_BXOR: {
 		args = (DUK_OP_BXOR << 8) + DUK__BP_BXOR;
 		goto binary;
 	}
 	case DUK_TOK_BOR: {
 		args = (DUK_OP_BOR << 8) + DUK__BP_BOR;
 		goto binary;
 	}
 
-	/* LOGICAL EXPRESSIONS */
+		/* LOGICAL EXPRESSIONS */
 
 	case DUK_TOK_LAND: {
 		/* syntactically left-associative but parsed as right-associative */
 		args = (1 << 8) + DUK__BP_LAND - 1;
 		goto binary_logical;
 	}
 	case DUK_TOK_LOR: {
 		/* syntactically left-associative but parsed as right-associative */
 		args = (0 << 8) + DUK__BP_LOR - 1;
 		goto binary_logical;
 	}
 
-	/* CONDITIONAL EXPRESSION */
+		/* CONDITIONAL EXPRESSION */
 
 	case DUK_TOK_QUESTION: {
 		/* XXX: common reg allocation need is to reuse a sub-expression's temp reg,
 		 * but only if it really is a temp.  Nothing fancy here now.
 		 */
 		duk_regconst_t reg_temp;
 		duk_int_t pc_jump1;
 		duk_int_t pc_jump2;
 
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
 		duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
 		duk__emit_if_true_skip(comp_ctx, reg_temp);
-		pc_jump1 = duk__emit_jump_empty(comp_ctx);  /* jump to false */
-		duk__expr_toforcedreg(comp_ctx, res, DUK__BP_COMMA /*rbp_flags*/, reg_temp /*forced_reg*/);  /* AssignmentExpression */
+		pc_jump1 = duk__emit_jump_empty(comp_ctx); /* jump to false */
+		duk__expr_toforcedreg(comp_ctx,
+		                      res,
+		                      DUK__BP_COMMA /*rbp_flags*/,
+		                      reg_temp /*forced_reg*/); /* AssignmentExpression */
 		duk__advance_expect(comp_ctx, DUK_TOK_COLON);
-		pc_jump2 = duk__emit_jump_empty(comp_ctx);  /* jump to end */
+		pc_jump2 = duk__emit_jump_empty(comp_ctx); /* jump to end */
 		duk__patch_jump_here(comp_ctx, pc_jump1);
-		duk__expr_toforcedreg(comp_ctx, res, DUK__BP_COMMA /*rbp_flags*/, reg_temp /*forced_reg*/);  /* AssignmentExpression */
+		duk__expr_toforcedreg(comp_ctx,
+		                      res,
+		                      DUK__BP_COMMA /*rbp_flags*/,
+		                      reg_temp /*forced_reg*/); /* AssignmentExpression */
 		duk__patch_jump_here(comp_ctx, pc_jump2);
 
 		DUK__SETTEMP(comp_ctx, reg_temp + 1);
 		duk__ivalue_regconst(res, reg_temp);
 		return;
 	}
 
-	/* ASSIGNMENT EXPRESSION */
+		/* ASSIGNMENT EXPRESSION */
 
 	case DUK_TOK_EQUALSIGN: {
 		/*
 		 *  Assignments are right associative, allows e.g.
 		 *    a = 5;
 		 *    a += b = 9;   // same as a += (b = 9)
 		 *  -> expression value 14, a = 14, b = 9
 		 *
 		 *  Right associativiness is reflected in the BP for recursion,
 		 *  "-1" ensures assignment operations are allowed.
 		 *
 		 *  XXX: just use DUK__BP_COMMA (i.e. no need for 2-step bp levels)?
 		 */
-		args = (DUK_OP_NONE << 8) + DUK__BP_ASSIGNMENT - 1;   /* DUK_OP_NONE marks a 'plain' assignment */
+		args = (DUK_OP_NONE << 8) + DUK__BP_ASSIGNMENT - 1; /* DUK_OP_NONE marks a 'plain' assignment */
 		goto assign;
 	}
 	case DUK_TOK_ADD_EQ: {
 		/* right associative */
 		args = (DUK_OP_ADD << 8) + DUK__BP_ASSIGNMENT - 1;
 		goto assign;
 	}
@@ -72225,20 +73515,20 @@
 	}
 	case DUK_TOK_BXOR_EQ: {
 		/* right associative */
 		args = (DUK_OP_BXOR << 8) + DUK__BP_ASSIGNMENT - 1;
 		goto assign;
 	}
 
-	/* COMMA */
+		/* COMMA */
 
 	case DUK_TOK_COMMA: {
 		/* right associative */
 
-		duk__ivalue_toplain_ignore(comp_ctx, left);  /* need side effects, not value */
+		duk__ivalue_toplain_ignore(comp_ctx, left); /* need side effects, not value */
 		duk__expr_toplain(comp_ctx, res, DUK__BP_COMMA - 1 /*rbp_flags*/);
 
 		/* return 'res' (of right part) as our result */
 		return;
 	}
 
 	default: {
@@ -72253,15 +73543,15 @@
 #if 0
 	/* XXX: shared handling for 'duk__expr_lhs'? */
 	if (comp_ctx->curr_func.paren_level == 0 && XXX) {
 		comp_ctx->curr_func.duk__expr_lhs = 0;
 	}
 #endif
 
- binary:
+binary:
 	/*
 	 *  Shared handling of binary operations
 	 *
 	 *  args = (opcode << 8) + rbp
 	 */
 	{
 		duk__ivalue_toplain(comp_ctx, left);
@@ -72279,19 +73569,23 @@
 		duk_copy(thr, res->x1.valstack_idx, res->x2.valstack_idx);
 
 		res->x1.t = left->x1.t;
 		res->x1.regconst = left->x1.regconst;
 		duk_copy(thr, left->x1.valstack_idx, res->x1.valstack_idx);
 
 		DUK_DDD(DUK_DDDPRINT("binary op, res: t=%ld, x1.t=%ld, x1.regconst=0x%08lx, x2.t=%ld, x2.regconst=0x%08lx",
-		                     (long) res->t, (long) res->x1.t, (unsigned long) res->x1.regconst, (long) res->x2.t, (unsigned long) res->x2.regconst));
+		                     (long) res->t,
+		                     (long) res->x1.t,
+		                     (unsigned long) res->x1.regconst,
+		                     (long) res->x2.t,
+		                     (unsigned long) res->x2.regconst));
 		return;
 	}
 
- binary_logical:
+binary_logical:
 	/*
 	 *  Shared handling for logical AND and logical OR.
 	 *
 	 *  args = (truthval << 8) + rbp
 	 *
 	 *  Truthval determines when to skip right-hand-side.
 	 *  For logical AND truthval=1, for logical OR truthval=0.
@@ -72316,25 +73610,25 @@
 		/* XXX: unoptimal use of temps, resetting */
 
 		reg_temp = DUK__ALLOCTEMP(comp_ctx);
 
 		duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
 		DUK_ASSERT(DUK__ISREG(reg_temp));
 		duk__emit_bc(comp_ctx,
-		            (args_truthval ? DUK_OP_IFTRUE_R : DUK_OP_IFFALSE_R),
-		            reg_temp);  /* skip jump conditionally */
+		             (args_truthval ? DUK_OP_IFTRUE_R : DUK_OP_IFFALSE_R),
+		             reg_temp); /* skip jump conditionally */
 		pc_jump = duk__emit_jump_empty(comp_ctx);
 		duk__expr_toforcedreg(comp_ctx, res, args_rbp /*rbp_flags*/, reg_temp /*forced_reg*/);
 		duk__patch_jump_here(comp_ctx, pc_jump);
 
 		duk__ivalue_regconst(res, reg_temp);
 		return;
 	}
 
- assign:
+assign:
 	/*
 	 *  Shared assignment expression handling
 	 *
 	 *  args = (opcode << 8) + rbp
 	 *
 	 *  If 'opcode' is DUK_OP_NONE, plain assignment without arithmetic.
 	 *  Syntactically valid left-hand-side forms which are not accepted as
@@ -72379,26 +73673,26 @@
 		 * so it has consumed all other assignment level operations; the
 		 * only relevant lower binding power construct is comma operator
 		 * which will ignore the expression value provided here.  Usually
 		 * the top level assignment expression value is ignored, but it
 		 * is relevant for e.g. eval code.
 		 */
 		toplevel_assign = (comp_ctx->curr_func.nud_count == 1 && /* one token before */
-		                   comp_ctx->curr_func.led_count == 1);  /* one operator (= assign) */
+		                   comp_ctx->curr_func.led_count == 1); /* one operator (= assign) */
 		DUK_DDD(DUK_DDDPRINT("assignment: nud_count=%ld, led_count=%ld, toplevel_assign=%ld",
 		                     (long) comp_ctx->curr_func.nud_count,
 		                     (long) comp_ctx->curr_func.led_count,
 		                     (long) toplevel_assign));
 
 		if (left->t == DUK_IVAL_VAR) {
 			duk_hstring *h_varname;
 			duk_regconst_t reg_varbind;
 			duk_regconst_t rc_varname;
 
-			DUK_ASSERT(left->x1.t == DUK_ISPEC_VALUE);  /* LHS is already side effect free */
+			DUK_ASSERT(left->x1.t == DUK_ISPEC_VALUE); /* LHS is already side effect free */
 
 			h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
 			if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
 				/* E5 Section 11.13.1 (and others for other assignments), step 4. */
 				goto syntax_error_lvalue;
 			}
 			duk_dup(thr, left->x1.valstack_idx);
@@ -72407,17 +73701,18 @@
 			if (args_op == DUK_OP_NONE) {
 				duk__expr(comp_ctx, res, args_rbp /*rbp_flags*/);
 				if (toplevel_assign) {
 					/* Any 'res' will do. */
 					DUK_DDD(DUK_DDDPRINT("plain assignment, toplevel assign, use as is"));
 				} else {
 					/* 'res' must be a plain ivalue, and not register-bound variable. */
-					DUK_DDD(DUK_DDDPRINT("plain assignment, not toplevel assign, ensure not a reg-bound identifier"));
-					if (res->t != DUK_IVAL_PLAIN || (res->x1.t == DUK_ISPEC_REGCONST &&
-					                                 DUK__ISREG_NOTTEMP(comp_ctx, res->x1.regconst))) {
+					DUK_DDD(DUK_DDDPRINT(
+					    "plain assignment, not toplevel assign, ensure not a reg-bound identifier"));
+					if (res->t != DUK_IVAL_PLAIN ||
+					    (res->x1.t == DUK_ISPEC_REGCONST && DUK__ISREG_NOTTEMP(comp_ctx, res->x1.regconst))) {
 						duk__ivalue_totempconst(comp_ctx, res);
 					}
 				}
 			} else {
 				/* For X <op>= Y we need to evaluate the pre-op
 				 * value of X before evaluating the RHS: the RHS
 				 * can change X, but when we do <op> we must use
@@ -72442,50 +73737,53 @@
 						DUK_DD(DUK_DDPRINT("<op>= expression is top level, write directly to reg_varbind"));
 						reg_res = reg_varbind;
 					} else {
 						/* Not safe to use 'reg_varbind' as assignment expression
 						 * value, so go through a temp.
 						 */
 						DUK_DD(DUK_DDPRINT("<op>= expression is not top level, write to reg_temp"));
-						reg_res = reg_temp;  /* reg_res should be smallest possible */
+						reg_res = reg_temp; /* reg_res should be smallest possible */
 						reg_temp = DUK__ALLOCTEMP(comp_ctx);
 					}
 
 					/* Try to optimize X <op>= Y for reg-bound
 					 * variables.  Detect side-effect free RHS
 					 * narrowly by seeing whether it emits code.
 					 * If not, rewind the code emitter and overwrite
 					 * the unnecessary temp reg load.
 					 */
 
 					pc_temp_load = duk__get_current_pc(comp_ctx);
-					duk__emit_a_bc(comp_ctx,
-					               DUK_OP_LDREG,
-					               reg_temp,
-					               reg_varbind);
+					duk__emit_a_bc(comp_ctx, DUK_OP_LDREG, reg_temp, reg_varbind);
 
 					pc_before_rhs = duk__get_current_pc(comp_ctx);
 					duk__expr_toregconst(comp_ctx, res, args_rbp /*rbp_flags*/);
 					DUK_ASSERT(res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_REGCONST);
 					pc_after_rhs = duk__get_current_pc(comp_ctx);
 
 					DUK_DD(DUK_DDPRINT("pc_temp_load=%ld, pc_before_rhs=%ld, pc_after_rhs=%ld",
-					                   (long) pc_temp_load, (long) pc_before_rhs,
+					                   (long) pc_temp_load,
+					                   (long) pc_before_rhs,
 					                   (long) pc_after_rhs));
 
 					if (pc_after_rhs == pc_before_rhs) {
 						/* Note: if the reg_temp load generated shuffling
 						 * instructions, we may need to rewind more than
 						 * one instruction, so use explicit PC computation.
 						 */
-						DUK_DD(DUK_DDPRINT("rhs is side effect free, rewind and avoid unnecessary temp for reg-based <op>="));
-						DUK_BW_ADD_PTR(comp_ctx->thr, &comp_ctx->curr_func.bw_code, (pc_temp_load - pc_before_rhs) * (duk_int_t) sizeof(duk_compiler_instr));
+						DUK_DD(DUK_DDPRINT("rhs is side effect free, rewind and avoid unnecessary temp for "
+						                   "reg-based <op>="));
+						DUK_BW_ADD_PTR(comp_ctx->thr,
+						               &comp_ctx->curr_func.bw_code,
+						               (pc_temp_load - pc_before_rhs) *
+						                   (duk_int_t) sizeof(duk_compiler_instr));
 						reg_src = reg_varbind;
 					} else {
-						DUK_DD(DUK_DDPRINT("rhs evaluation emitted code, not sure if rhs is side effect free; use temp reg for LHS"));
+						DUK_DD(DUK_DDPRINT("rhs evaluation emitted code, not sure if rhs is side effect "
+						                   "free; use temp reg for LHS"));
 						reg_src = reg_temp;
 					}
 
 					duk__emit_a_b_c(comp_ctx,
 					                args_op | DUK__EMIT_FLAG_BC_REGCONST,
 					                reg_res,
 					                reg_src,
@@ -72498,18 +73796,15 @@
 						DUK__SETTEMP(comp_ctx, reg_res + 1);
 					}
 				} else {
 					/* When LHS is not register bound, always go through a
 					 * temporary.  No optimization for top level assignment.
 					 */
 
-					duk__emit_a_bc(comp_ctx,
-					               DUK_OP_GETVAR,
-					               reg_temp,
-					               rc_varname);
+					duk__emit_a_bc(comp_ctx, DUK_OP_GETVAR, reg_temp, rc_varname);
 
 					duk__expr_toregconst(comp_ctx, res, args_rbp /*rbp_flags*/);
 					DUK_ASSERT(res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_REGCONST);
 
 					duk__emit_a_b_c(comp_ctx,
 					                args_op | DUK__EMIT_FLAG_BC_REGCONST,
 					                reg_temp,
@@ -72534,39 +73829,36 @@
 					 * that as the expression value if safe.  If not safe,
 					 * resolve to a temp/const and copy to LHS.
 					 */
 					if (toplevel_assign) {
 						duk__ivalue_toforcedreg(comp_ctx, res, (duk_int_t) reg_varbind);
 					} else {
 						duk__ivalue_totempconst(comp_ctx, res);
-						duk__copy_ivalue(comp_ctx, res, left);  /* use 'left' as a temp */
+						duk__copy_ivalue(comp_ctx, res, left); /* use 'left' as a temp */
 						duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
 					}
 				} else {
 					/* Use 'res' as the expression value (it's side effect
 					 * free and may be a plain value, a register, or a
 					 * constant) and write it to the LHS binding too.
 					 */
-					duk__copy_ivalue(comp_ctx, res, left);  /* use 'left' as a temp */
+					duk__copy_ivalue(comp_ctx, res, left); /* use 'left' as a temp */
 					duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
 				}
 			} else {
 				/* Only a reg fits into 'A' so coerce 'res' into a register
 				 * for PUTVAR.
 				 *
 				 * XXX: here the current A/B/C split is suboptimal: we could
 				 * just use 9 bits for reg_res (and support constants) and 17
 				 * instead of 18 bits for the varname const index.
 				 */
 
 				duk__ivalue_toreg(comp_ctx, res);
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE,
-				               res->x1.regconst,
-				               rc_varname);
+				duk__emit_a_bc(comp_ctx, DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE, res->x1.regconst, rc_varname);
 			}
 
 			/* 'res' contains expression value */
 		} else if (left->t == DUK_IVAL_PROP) {
 			/* E5 Section 11.13.1 (and others) step 4 never matches for prop writes -> no check */
 			duk_regconst_t reg_obj;
 			duk_regconst_t rc_key;
@@ -72598,19 +73890,15 @@
 
 			if (args_op == DUK_OP_NONE) {
 				duk__expr_toregconst(comp_ctx, res, args_rbp /*rbp_flags*/);
 				DUK_ASSERT(res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_REGCONST);
 				rc_res = res->x1.regconst;
 			} else {
 				reg_temp = DUK__ALLOCTEMP(comp_ctx);
-				duk__emit_a_b_c(comp_ctx,
-				                DUK_OP_GETPROP | DUK__EMIT_FLAG_BC_REGCONST,
-				                reg_temp,
-				                reg_obj,
-				                rc_key);
+				duk__emit_a_b_c(comp_ctx, DUK_OP_GETPROP | DUK__EMIT_FLAG_BC_REGCONST, reg_temp, reg_obj, rc_key);
 
 				duk__expr_toregconst(comp_ctx, res, args_rbp /*rbp_flags*/);
 				DUK_ASSERT(res->t == DUK_IVAL_PLAIN && res->x1.t == DUK_ISPEC_REGCONST);
 
 				duk__emit_a_b_c(comp_ctx,
 				                args_op | DUK__EMIT_FLAG_BC_REGCONST,
 				                reg_temp,
@@ -72653,162 +73941,161 @@
 
 			duk__ivalue_regconst(res, rc_res);
 		}
 
 		return;
 	}
 
- postincdec:
-	{
-		/*
-		 *  Post-increment/decrement will return the original value as its
-		 *  result value.  However, even that value will be coerced using
-		 *  ToNumber() which is quite awkward.  Specific bytecode opcodes
-		 *  are used to handle these semantics.
-		 *
-		 *  Note that post increment/decrement has a "no LineTerminator here"
-		 *  restriction.  This is handled by duk__expr_lbp(), which forcibly terminates
-		 *  the previous expression if a LineTerminator occurs before '++'/'--'.
-		 */
-
-		duk_regconst_t reg_res;
-		duk_small_uint_t args_op1 = (args >> 8) & 0xff;  /* DUK_OP_POSTINCR/DUK_OP_POSTDECR */
-		duk_small_uint_t args_op2 = args >> 16;          /* DUK_OP_POSTINCP_RR/DUK_OP_POSTDECP_RR */
-
-		/* Specific assumptions for opcode numbering. */
-		DUK_ASSERT(DUK_OP_POSTINCR + 4 == DUK_OP_POSTINCV);
-		DUK_ASSERT(DUK_OP_POSTDECR + 4 == DUK_OP_POSTDECV);
+postincdec : {
+	/*
+	 *  Post-increment/decrement will return the original value as its
+	 *  result value.  However, even that value will be coerced using
+	 *  ToNumber() which is quite awkward.  Specific bytecode opcodes
+	 *  are used to handle these semantics.
+	 *
+	 *  Note that post increment/decrement has a "no LineTerminator here"
+	 *  restriction.  This is handled by duk__expr_lbp(), which forcibly terminates
+	 *  the previous expression if a LineTerminator occurs before '++'/'--'.
+	 */
 
-		reg_res = DUK__ALLOCTEMP(comp_ctx);
+	duk_regconst_t reg_res;
+	duk_small_uint_t args_op1 = (args >> 8) & 0xff; /* DUK_OP_POSTINCR/DUK_OP_POSTDECR */
+	duk_small_uint_t args_op2 = args >> 16; /* DUK_OP_POSTINCP_RR/DUK_OP_POSTDECP_RR */
 
-		if (left->t == DUK_IVAL_VAR) {
-			duk_hstring *h_varname;
-			duk_regconst_t reg_varbind;
-			duk_regconst_t rc_varname;
+	/* Specific assumptions for opcode numbering. */
+	DUK_ASSERT(DUK_OP_POSTINCR + 4 == DUK_OP_POSTINCV);
+	DUK_ASSERT(DUK_OP_POSTDECR + 4 == DUK_OP_POSTDECV);
 
-			h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
+	reg_res = DUK__ALLOCTEMP(comp_ctx);
 
-			if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
-				goto syntax_error;
-			}
+	if (left->t == DUK_IVAL_VAR) {
+		duk_hstring *h_varname;
+		duk_regconst_t reg_varbind;
+		duk_regconst_t rc_varname;
 
-			duk_dup(thr, left->x1.valstack_idx);
-			if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
-				duk__emit_a_bc(comp_ctx,
-				               args_op1,  /* e.g. DUK_OP_POSTINCR */
-				               reg_res,
-				               reg_varbind);
-			} else {
-				duk__emit_a_bc(comp_ctx,
-				               args_op1 + 4,  /* e.g. DUK_OP_POSTINCV */
-				               reg_res,
-				               rc_varname);
-			}
+		h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
 
-			DUK_DDD(DUK_DDDPRINT("postincdec to '%!O' -> reg_varbind=%ld, rc_varname=%ld",
-			                     (duk_heaphdr *) h_varname, (long) reg_varbind, (long) rc_varname));
-		} else if (left->t == DUK_IVAL_PROP) {
-			duk_regconst_t reg_obj;  /* allocate to reg only (not const) */
-			duk_regconst_t rc_key;
+		if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
+			goto syntax_error;
+		}
 
-			reg_obj = duk__ispec_toregconst_raw(comp_ctx, &left->x1, -1 /*forced_reg*/, 0 /*flags*/);  /* don't allow const */
-			rc_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
-			duk__emit_a_b_c(comp_ctx,
-			                args_op2 | DUK__EMIT_FLAG_BC_REGCONST,  /* e.g. DUK_OP_POSTINCP */
-			                reg_res,
-			                reg_obj,
-			                rc_key);
+		duk_dup(thr, left->x1.valstack_idx);
+		if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
+			duk__emit_a_bc(comp_ctx,
+			               args_op1, /* e.g. DUK_OP_POSTINCR */
+			               reg_res,
+			               reg_varbind);
 		} else {
-			/* Technically return value is not needed because INVLHS will
-			 * unconditially throw a ReferenceError.  Coercion is necessary
-			 * for proper semantics (consider ToNumber() called for an object).
-			 * Use DUK_OP_UNP with a dummy register to get ToNumber().
-			 */
-			duk__ivalue_toforcedreg(comp_ctx, left, reg_res);
-			duk__emit_bc(comp_ctx,
-			             DUK_OP_UNP,
-			             reg_res);  /* for side effects, result ignored */
-			duk__emit_op_only(comp_ctx,
-			                  DUK_OP_INVLHS);
+			duk__emit_a_bc(comp_ctx,
+			               args_op1 + 4, /* e.g. DUK_OP_POSTINCV */
+			               reg_res,
+			               rc_varname);
 		}
 
-		DUK__SETTEMP(comp_ctx, reg_res + 1);
-		duk__ivalue_regconst(res, reg_res);
-		return;
+		DUK_DDD(DUK_DDDPRINT("postincdec to '%!O' -> reg_varbind=%ld, rc_varname=%ld",
+		                     (duk_heaphdr *) h_varname,
+		                     (long) reg_varbind,
+		                     (long) rc_varname));
+	} else if (left->t == DUK_IVAL_PROP) {
+		duk_regconst_t reg_obj; /* allocate to reg only (not const) */
+		duk_regconst_t rc_key;
+
+		reg_obj = duk__ispec_toregconst_raw(comp_ctx, &left->x1, -1 /*forced_reg*/, 0 /*flags*/); /* don't allow const */
+		rc_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
+		duk__emit_a_b_c(comp_ctx,
+		                args_op2 | DUK__EMIT_FLAG_BC_REGCONST, /* e.g. DUK_OP_POSTINCP */
+		                reg_res,
+		                reg_obj,
+		                rc_key);
+	} else {
+		/* Technically return value is not needed because INVLHS will
+		 * unconditially throw a ReferenceError.  Coercion is necessary
+		 * for proper semantics (consider ToNumber() called for an object).
+		 * Use DUK_OP_UNP with a dummy register to get ToNumber().
+		 */
+		duk__ivalue_toforcedreg(comp_ctx, left, reg_res);
+		duk__emit_bc(comp_ctx, DUK_OP_UNP, reg_res); /* for side effects, result ignored */
+		duk__emit_op_only(comp_ctx, DUK_OP_INVLHS);
 	}
 
- syntax_error:
+	DUK__SETTEMP(comp_ctx, reg_res + 1);
+	duk__ivalue_regconst(res, reg_res);
+	return;
+}
+
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_EXPRESSION);
 	DUK_WO_NORETURN(return;);
 
- syntax_error_lvalue:
+syntax_error_lvalue:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_LVALUE);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx) {
 	duk_small_uint_t tok = comp_ctx->curr_token.t;
 
-	DUK_ASSERT_DISABLE(tok >= DUK_TOK_MINVAL);  /* unsigned */
+	DUK_ASSERT_DISABLE(tok >= DUK_TOK_MINVAL); /* unsigned */
 	DUK_ASSERT(tok <= DUK_TOK_MAXVAL);
 	DUK_ASSERT(sizeof(duk__token_lbp) == DUK_TOK_MAXVAL + 1);
 
 	/* XXX: integrate support for this into led() instead?
 	 * Similar issue as post-increment/post-decrement.
 	 */
 
 	/* prevent duk__expr_led() by using a binding power less than anything valid */
 	if (tok == DUK_TOK_IN && !comp_ctx->curr_func.allow_in) {
 		return 0;
 	}
 
-	if ((tok == DUK_TOK_DECREMENT || tok == DUK_TOK_INCREMENT) &&
-	    (comp_ctx->curr_token.lineterm)) {
+	if ((tok == DUK_TOK_DECREMENT || tok == DUK_TOK_INCREMENT) && (comp_ctx->curr_token.lineterm)) {
 		/* '++' or '--' in a post-increment/decrement position,
 		 * and a LineTerminator occurs between the operator and
 		 * the preceding expression.  Force the previous expr
 		 * to terminate, in effect treating e.g. "a,b\n++" as
 		 * "a,b;++" (= SyntaxError).
 		 */
 		return 0;
 	}
 
-	return DUK__TOKEN_LBP_GET_BP(duk__token_lbp[tok]);  /* format is bit packed */
+	return DUK__TOKEN_LBP_GET_BP(duk__token_lbp[tok]); /* format is bit packed */
 }
 
 /*
  *  Expression parsing.
  *
  *  Upon entry to 'expr' and its variants, 'curr_tok' is assumed to be the
  *  first token of the expression.  Upon exit, 'curr_tok' will be the first
  *  token not part of the expression (e.g. semicolon terminating an expression
  *  statement).
  */
 
-#define DUK__EXPR_RBP_MASK           0xff
-#define DUK__EXPR_FLAG_REJECT_IN     (1 << 8)   /* reject 'in' token (used for for-in) */
-#define DUK__EXPR_FLAG_ALLOW_EMPTY   (1 << 9)   /* allow empty expression */
-#define DUK__EXPR_FLAG_REQUIRE_INIT  (1 << 10)  /* require initializer for var/const */
+#define DUK__EXPR_RBP_MASK          0xff
+#define DUK__EXPR_FLAG_REJECT_IN    (1 << 8) /* reject 'in' token (used for for-in) */
+#define DUK__EXPR_FLAG_ALLOW_EMPTY  (1 << 9) /* allow empty expression */
+#define DUK__EXPR_FLAG_REQUIRE_INIT (1 << 10) /* require initializer for var/const */
 
 /* main expression parser function */
 DUK_LOCAL void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk_hthread *thr = comp_ctx->thr;
-	duk_ivalue tmp_alloc;   /* 'res' is used for "left", and 'tmp' for "right" */
+	duk_ivalue tmp_alloc; /* 'res' is used for "left", and 'tmp' for "right" */
 	duk_ivalue *tmp = &tmp_alloc;
 	duk_small_uint_t rbp;
 
 	DUK__RECURSION_INCREASE(comp_ctx, thr);
 
 	duk_require_stack(thr, DUK__PARSE_EXPR_SLOTS);
 
 	/* filter out flags from exprtop rbp_flags here to save space */
 	rbp = rbp_flags & DUK__EXPR_RBP_MASK;
 
 	DUK_DDD(DUK_DDDPRINT("duk__expr(), rbp_flags=%ld, rbp=%ld, allow_in=%ld, paren_level=%ld",
-	                     (long) rbp_flags, (long) rbp, (long) comp_ctx->curr_func.allow_in,
+	                     (long) rbp_flags,
+	                     (long) rbp,
+	                     (long) comp_ctx->curr_func.allow_in,
 	                     (long) comp_ctx->curr_func.paren_level));
 
 	duk_memzero(&tmp_alloc, sizeof(tmp_alloc));
 	tmp->x1.valstack_idx = duk_get_top(thr);
 	tmp->x2.valstack_idx = tmp->x1.valstack_idx + 1;
 	duk_push_undefined(thr);
 	duk_push_undefined(thr);
@@ -72831,22 +74118,22 @@
 		}
 		duk_push_undefined(thr);
 		duk__ivalue_plain_fromstack(comp_ctx, res);
 		goto cleanup;
 	}
 
 	duk__advance(comp_ctx);
-	duk__expr_nud(comp_ctx, res);  /* reuse 'res' as 'left' */
+	duk__expr_nud(comp_ctx, res); /* reuse 'res' as 'left' */
 	while (rbp < duk__expr_lbp(comp_ctx)) {
 		duk__advance(comp_ctx);
 		duk__expr_led(comp_ctx, res, tmp);
-		duk__copy_ivalue(comp_ctx, tmp, res);  /* tmp -> res */
+		duk__copy_ivalue(comp_ctx, tmp, res); /* tmp -> res */
 	}
 
- cleanup:
+cleanup:
 	/* final result is already in 'res' */
 
 	duk_pop_2(thr);
 
 	DUK__RECURSION_DECREASE(comp_ctx, thr);
 }
 
@@ -72872,40 +74159,43 @@
 
 /* A bunch of helpers (for size optimization) that combine duk__expr()/duk__exprtop()
  * and result conversions.
  *
  * Each helper needs at least 2-3 calls to make it worth while to wrap.
  */
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL duk_regconst_t duk__expr_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__expr(comp_ctx, res, rbp_flags);
 	return duk__ivalue_toreg(comp_ctx, res);
 }
 #endif
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL duk_regconst_t duk__expr_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__expr(comp_ctx, res, rbp_flags);
 	return duk__ivalue_totemp(comp_ctx, res);
 }
 #endif
 
-DUK_LOCAL void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg) {
+DUK_LOCAL void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx,
+                                     duk_ivalue *res,
+                                     duk_small_uint_t rbp_flags,
+                                     duk_regconst_t forced_reg) {
 	DUK_ASSERT(forced_reg >= 0);
 	duk__expr(comp_ctx, res, rbp_flags);
 	duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
 }
 
 DUK_LOCAL duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__expr(comp_ctx, res, rbp_flags);
 	return duk__ivalue_toregconst(comp_ctx, res);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL duk_regconst_t duk__expr_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__expr(comp_ctx, res, rbp_flags);
 	return duk__ivalue_totempconst(comp_ctx, res);
 }
 #endif
 
 DUK_LOCAL void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
@@ -72919,33 +74209,36 @@
 }
 
 DUK_LOCAL duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__exprtop(comp_ctx, res, rbp_flags);
 	return duk__ivalue_toreg(comp_ctx, res);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL duk_regconst_t duk__exprtop_totemp(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__exprtop(comp_ctx, res, rbp_flags);
 	return duk__ivalue_totemp(comp_ctx, res);
 }
 #endif
 
-DUK_LOCAL void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags, duk_regconst_t forced_reg) {
+DUK_LOCAL void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx,
+                                        duk_ivalue *res,
+                                        duk_small_uint_t rbp_flags,
+                                        duk_regconst_t forced_reg) {
 	DUK_ASSERT(forced_reg >= 0);
 	duk__exprtop(comp_ctx, res, rbp_flags);
 	duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
 }
 
 DUK_LOCAL duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 	duk__exprtop(comp_ctx, res, rbp_flags);
 	return duk__ivalue_toregconst(comp_ctx, res);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL void duk__exprtop_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, int rbp_flags) {
 	duk__exprtop(comp_ctx, res, rbp_flags);
 	duk__ivalue_toplain_ignore(comp_ctx, res);
 }
 #endif
 
 /*
@@ -72956,19 +74249,19 @@
  *
  *  Upon entry, 'curr_tok' contains the first token of the statement (parsed
  *  in "allow regexp literal" mode).  Upon exit, 'curr_tok' contains the first
  *  token following the statement (if the statement has a terminator, this is
  *  the token after the terminator).
  */
 
-#define DUK__HAS_VAL                  (1 << 0)  /* stmt has non-empty value */
-#define DUK__HAS_TERM                 (1 << 1)  /* stmt has explicit/implicit semicolon terminator */
-#define DUK__ALLOW_AUTO_SEMI_ALWAYS   (1 << 2)  /* allow automatic semicolon even without lineterm (compatibility) */
-#define DUK__STILL_PROLOGUE           (1 << 3)  /* statement does not terminate directive prologue */
-#define DUK__IS_TERMINAL              (1 << 4)  /* statement is guaranteed to be terminal (control doesn't flow to next statement) */
+#define DUK__HAS_VAL                (1 << 0) /* stmt has non-empty value */
+#define DUK__HAS_TERM               (1 << 1) /* stmt has explicit/implicit semicolon terminator */
+#define DUK__ALLOW_AUTO_SEMI_ALWAYS (1 << 2) /* allow automatic semicolon even without lineterm (compatibility) */
+#define DUK__STILL_PROLOGUE         (1 << 3) /* statement does not terminate directive prologue */
+#define DUK__IS_TERMINAL            (1 << 4) /* statement is guaranteed to be terminal (control doesn't flow to next statement) */
 
 /* Parse a single variable declaration (e.g. "i" or "i=10").  A leading 'var'
  * has already been eaten.  These is no return value in 'res', it is used only
  * as a temporary.
  *
  * When called from 'for-in' statement parser, the initializer expression must
  * not allow the 'in' token.  The caller supply additional expression parsing
@@ -72980,15 +74273,19 @@
  *    If register bound:      out_reg_varbind >= 0, out_rc_varname == 0 (ignore)
  *    If not register bound:  out_reg_varbind < 0, out_rc_varname >= 0
  *
  * These allow the caller to use the variable for further assignment, e.g.
  * as is done in 'for-in' parsing.
  */
 
-DUK_LOCAL void duk__parse_var_decl(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname) {
+DUK_LOCAL void duk__parse_var_decl(duk_compiler_ctx *comp_ctx,
+                                   duk_ivalue *res,
+                                   duk_small_uint_t expr_flags,
+                                   duk_regconst_t *out_reg_varbind,
+                                   duk_regconst_t *out_rc_varname) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_hstring *h_varname;
 	duk_regconst_t reg_varbind;
 	duk_regconst_t rc_varname;
 
 	/* assume 'var' has been eaten */
 
@@ -73004,90 +74301,88 @@
 	if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
 		goto syntax_error;
 	}
 
 	/* register declarations in first pass */
 	if (comp_ctx->curr_func.in_scanning) {
 		duk_uarridx_t n;
-		DUK_DDD(DUK_DDDPRINT("register variable declaration %!O in pass 1",
-		                     (duk_heaphdr *) h_varname));
+		DUK_DDD(DUK_DDDPRINT("register variable declaration %!O in pass 1", (duk_heaphdr *) h_varname));
 		n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
 		duk_push_hstring(thr, h_varname);
 		duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
 		duk_push_int(thr, DUK_DECL_TYPE_VAR + (0 << 8));
 		duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
 	}
 
-	duk_push_hstring(thr, h_varname);  /* push before advancing to keep reachable */
+	duk_push_hstring(thr, h_varname); /* push before advancing to keep reachable */
 
 	/* register binding lookup is based on varmap (even in first pass) */
 	duk_dup_top(thr);
 	(void) duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname);
 
-	duk__advance(comp_ctx);  /* eat identifier */
+	duk__advance(comp_ctx); /* eat identifier */
 
 	if (comp_ctx->curr_token.t == DUK_TOK_EQUALSIGN) {
 		duk__advance(comp_ctx);
 
 		DUK_DDD(DUK_DDDPRINT("vardecl, assign to '%!O' -> reg_varbind=%ld, rc_varname=%ld",
-		                     (duk_heaphdr *) h_varname, (long) reg_varbind, (long) rc_varname));
+		                     (duk_heaphdr *) h_varname,
+		                     (long) reg_varbind,
+		                     (long) rc_varname));
 
-		duk__exprtop(comp_ctx, res, DUK__BP_COMMA | expr_flags /*rbp_flags*/);  /* AssignmentExpression */
+		duk__exprtop(comp_ctx, res, DUK__BP_COMMA | expr_flags /*rbp_flags*/); /* AssignmentExpression */
 
 		if (reg_varbind >= 0) {
 			duk__ivalue_toforcedreg(comp_ctx, res, reg_varbind);
 		} else {
 			duk_regconst_t reg_val;
 			reg_val = duk__ivalue_toreg(comp_ctx, res);
-			duk__emit_a_bc(comp_ctx,
-			               DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE,
-			               reg_val,
-			               rc_varname);
+			duk__emit_a_bc(comp_ctx, DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE, reg_val, rc_varname);
 		}
 	} else {
 		if (expr_flags & DUK__EXPR_FLAG_REQUIRE_INIT) {
 			/* Used for minimal 'const': initializer required. */
 			goto syntax_error;
 		}
 	}
 
-	duk_pop(thr);  /* pop varname */
+	duk_pop(thr); /* pop varname */
 
 	*out_rc_varname = rc_varname;
 	*out_reg_varbind = reg_varbind;
 
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_VAR_DECLARATION);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags) {
 	duk_regconst_t reg_varbind;
 	duk_regconst_t rc_varname;
 
-	duk__advance(comp_ctx);  /* eat 'var' */
+	duk__advance(comp_ctx); /* eat 'var' */
 
 	for (;;) {
 		/* rc_varname and reg_varbind are ignored here */
 		duk__parse_var_decl(comp_ctx, res, 0 | expr_flags, &reg_varbind, &rc_varname);
 
 		if (comp_ctx->curr_token.t != DUK_TOK_COMMA) {
 			break;
 		}
 		duk__advance(comp_ctx);
 	}
 }
 
 DUK_LOCAL void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 	duk_hthread *thr = comp_ctx->thr;
-	duk_int_t pc_v34_lhs;         /* start variant 3/4 left-hand-side code (L1 in doc/compiler.rst example) */
-	duk_regconst_t temp_reset;    /* knock back "next temp" to this whenever possible */
-	duk_regconst_t reg_temps;     /* preallocated temporaries (2) for variants 3 and 4 */
+	duk_int_t pc_v34_lhs; /* start variant 3/4 left-hand-side code (L1 in doc/compiler.rst example) */
+	duk_regconst_t temp_reset; /* knock back "next temp" to this whenever possible */
+	duk_regconst_t reg_temps; /* preallocated temporaries (2) for variants 3 and 4 */
 
 	DUK_DDD(DUK_DDDPRINT("start parsing a for/for-in statement"));
 
 	/* Two temporaries are preallocated here for variants 3 and 4 which need
 	 * registers which are never clobbered by expressions in the loop
 	 * (concretely: for the enumerator object and the next enumerated value).
 	 * Variants 1 and 2 "release" these temps.
@@ -73108,143 +74403,144 @@
 	 *  Parsing these without arbitrary lookahead or backtracking is relatively
 	 *  tricky but we manage to do so for now.
 	 *
 	 *  See doc/compiler.rst for a detailed discussion of control flow
 	 *  issues, evaluation order issues, etc.
 	 */
 
-	duk__advance(comp_ctx);  /* eat 'for' */
+	duk__advance(comp_ctx); /* eat 'for' */
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 
 	DUK_DDD(DUK_DDDPRINT("detecting for/for-in loop variant, pc=%ld", (long) duk__get_current_pc(comp_ctx)));
 
 	/* a label site has been emitted by duk__parse_stmt() automatically
 	 * (it will also emit the ENDLABEL).
 	 */
 
 	if (comp_ctx->curr_token.t == DUK_TOK_VAR) {
 		/*
 		 *  Variant 2 or 4
 		 */
 
-		duk_regconst_t reg_varbind;  /* variable binding register if register-bound (otherwise < 0) */
-		duk_regconst_t rc_varname;   /* variable name reg/const, if variable not register-bound */
+		duk_regconst_t reg_varbind; /* variable binding register if register-bound (otherwise < 0) */
+		duk_regconst_t rc_varname; /* variable name reg/const, if variable not register-bound */
 
-		duk__advance(comp_ctx);  /* eat 'var' */
+		duk__advance(comp_ctx); /* eat 'var' */
 		duk__parse_var_decl(comp_ctx, res, DUK__EXPR_FLAG_REJECT_IN, &reg_varbind, &rc_varname);
 		DUK__SETTEMP(comp_ctx, temp_reset);
 
 		if (comp_ctx->curr_token.t == DUK_TOK_IN) {
 			/*
 			 *  Variant 4
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("detected for variant 4: for (var VariableDeclarationNoIn in Expression) Statement"));
-			pc_v34_lhs = duk__get_current_pc(comp_ctx);  /* jump is inserted here */
+			pc_v34_lhs = duk__get_current_pc(comp_ctx); /* jump is inserted here */
 			if (reg_varbind >= 0) {
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_LDREG,
-				               reg_varbind,
-				               reg_temps + 0);
+				duk__emit_a_bc(comp_ctx, DUK_OP_LDREG, reg_varbind, reg_temps + 0);
 			} else {
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE,
-				               reg_temps + 0,
-				               rc_varname);
+				duk__emit_a_bc(comp_ctx, DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE, reg_temps + 0, rc_varname);
 			}
 			goto parse_3_or_4;
 		} else {
 			/*
 			 *  Variant 2
 			 */
 
-			DUK_DDD(DUK_DDDPRINT("detected for variant 2: for (var VariableDeclarationNoIn; Expression_opt; Expression_opt) Statement"));
+			DUK_DDD(DUK_DDDPRINT(
+			    "detected for variant 2: for (var VariableDeclarationNoIn; Expression_opt; Expression_opt) Statement"));
 			for (;;) {
 				/* more initializers */
 				if (comp_ctx->curr_token.t != DUK_TOK_COMMA) {
 					break;
 				}
 				DUK_DDD(DUK_DDDPRINT("variant 2 has another variable initializer"));
 
-				duk__advance(comp_ctx);  /* eat comma */
+				duk__advance(comp_ctx); /* eat comma */
 				duk__parse_var_decl(comp_ctx, res, DUK__EXPR_FLAG_REJECT_IN, &reg_varbind, &rc_varname);
 			}
 			goto parse_1_or_2;
 		}
 	} else {
 		/*
 		 *  Variant 1 or 3
 		 */
 
-		pc_v34_lhs = duk__get_current_pc(comp_ctx);  /* jump is inserted here (variant 3) */
+		pc_v34_lhs = duk__get_current_pc(comp_ctx); /* jump is inserted here (variant 3) */
 
 		/* Note that duk__exprtop() here can clobber any reg above current temp_next,
 		 * so any loop variables (e.g. enumerator) must be "preallocated".
 		 */
 
 		/* don't coerce yet to a plain value (variant 3 needs special handling) */
-		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_REJECT_IN | DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/);  /* Expression */
+		duk__exprtop(comp_ctx,
+		             res,
+		             DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_REJECT_IN |
+		                 DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/); /* Expression */
 		if (comp_ctx->curr_token.t == DUK_TOK_IN) {
 			/*
 			 *  Variant 3
 			 */
 
 			/* XXX: need to determine LHS type, and check that it is LHS compatible */
 			DUK_DDD(DUK_DDDPRINT("detected for variant 3: for (LeftHandSideExpression in Expression) Statement"));
 			if (duk__expr_is_empty(comp_ctx)) {
-				goto syntax_error;  /* LeftHandSideExpression does not allow empty expression */
+				goto syntax_error; /* LeftHandSideExpression does not allow empty expression */
 			}
 
 			if (res->t == DUK_IVAL_VAR) {
 				duk_regconst_t reg_varbind;
 				duk_regconst_t rc_varname;
 
 				duk_dup(thr, res->x1.valstack_idx);
 				if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
-					duk__emit_a_bc(comp_ctx,
-					               DUK_OP_LDREG,
-					               reg_varbind,
-					               reg_temps + 0);
+					duk__emit_a_bc(comp_ctx, DUK_OP_LDREG, reg_varbind, reg_temps + 0);
 				} else {
 					duk__emit_a_bc(comp_ctx,
 					               DUK_OP_PUTVAR | DUK__EMIT_FLAG_A_IS_SOURCE,
 					               reg_temps + 0,
 					               rc_varname);
 				}
 			} else if (res->t == DUK_IVAL_PROP) {
 				/* Don't allow a constant for the object (even for a number etc), as
 				 * it goes into the 'A' field of the opcode.
 				 */
 				duk_regconst_t reg_obj;
 				duk_regconst_t rc_key;
-				reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 /*forced_reg*/, 0 /*flags*/);  /* don't allow const */
-				rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 /*forced_reg*/, DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
+				reg_obj = duk__ispec_toregconst_raw(comp_ctx,
+				                                    &res->x1,
+				                                    -1 /*forced_reg*/,
+				                                    0 /*flags*/); /* don't allow const */
+				rc_key = duk__ispec_toregconst_raw(comp_ctx,
+				                                   &res->x2,
+				                                   -1 /*forced_reg*/,
+				                                   DUK__IVAL_FLAG_ALLOW_CONST /*flags*/);
 				duk__emit_a_b_c(comp_ctx,
 				                DUK_OP_PUTPROP | DUK__EMIT_FLAG_A_IS_SOURCE | DUK__EMIT_FLAG_BC_REGCONST,
 				                reg_obj,
 				                rc_key,
 				                reg_temps + 0);
 			} else {
-				duk__ivalue_toplain_ignore(comp_ctx, res);  /* just in case */
-				duk__emit_op_only(comp_ctx,
-				                  DUK_OP_INVLHS);
+				duk__ivalue_toplain_ignore(comp_ctx, res); /* just in case */
+				duk__emit_op_only(comp_ctx, DUK_OP_INVLHS);
 			}
 			goto parse_3_or_4;
 		} else {
 			/*
 			 *  Variant 1
 			 */
 
-			DUK_DDD(DUK_DDDPRINT("detected for variant 1: for (ExpressionNoIn_opt; Expression_opt; Expression_opt) Statement"));
+			DUK_DDD(DUK_DDDPRINT(
+			    "detected for variant 1: for (ExpressionNoIn_opt; Expression_opt; Expression_opt) Statement"));
 			duk__ivalue_toplain_ignore(comp_ctx, res);
 			goto parse_1_or_2;
 		}
 	}
 
- parse_1_or_2:
+parse_1_or_2:
 	/*
 	 *  Parse variant 1 or 2.  The first part expression (which differs
 	 *  in the variants) has already been parsed and its code emitted.
 	 *
 	 *  reg_temps + 0: unused
 	 *  reg_temps + 1: unused
 	 */
@@ -73259,73 +74555,75 @@
 		/* "release" preallocated temps since we won't need them */
 		temp_reset = reg_temps + 0;
 		DUK__SETTEMP(comp_ctx, temp_reset);
 
 		duk__advance_expect(comp_ctx, DUK_TOK_SEMICOLON);
 
 		pc_l1 = duk__get_current_pc(comp_ctx);
-		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/);  /* Expression_opt */
+		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/); /* Expression_opt */
 		if (duk__expr_is_empty(comp_ctx)) {
 			/* no need to coerce */
-			pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);  /* to body */
-			pc_jumpto_l4 = -1;  /* omitted */
+			pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx); /* to body */
+			pc_jumpto_l4 = -1; /* omitted */
 		} else {
 			rc_cond = duk__ivalue_toregconst(comp_ctx, res);
 			duk__emit_if_false_skip(comp_ctx, rc_cond);
-			pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);  /* to body */
-			pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);  /* to exit */
+			pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx); /* to body */
+			pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx); /* to exit */
 		}
 		DUK__SETTEMP(comp_ctx, temp_reset);
 
 		duk__advance_expect(comp_ctx, DUK_TOK_SEMICOLON);
 
 		pc_l2 = duk__get_current_pc(comp_ctx);
-		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/);  /* Expression_opt */
+		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR | DUK__EXPR_FLAG_ALLOW_EMPTY /*rbp_flags*/); /* Expression_opt */
 		if (duk__expr_is_empty(comp_ctx)) {
 			/* no need to coerce */
 			expr_c_empty = 1;
 			/* JUMP L1 omitted */
 		} else {
 			duk__ivalue_toplain_ignore(comp_ctx, res);
 			expr_c_empty = 0;
 			duk__emit_jump(comp_ctx, pc_l1);
 		}
 		DUK__SETTEMP(comp_ctx, temp_reset);
 
 		comp_ctx->curr_func.allow_regexp_in_adv = 1;
-		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* Allow RegExp as part of next stmt. */
+		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* Allow RegExp as part of next stmt. */
 
 		pc_l3 = duk__get_current_pc(comp_ctx);
 		duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 		if (expr_c_empty) {
 			duk__emit_jump(comp_ctx, pc_l1);
 		} else {
 			duk__emit_jump(comp_ctx, pc_l2);
 		}
 		/* temp reset is not necessary after duk__parse_stmt(), which already does it */
 
 		pc_l4 = duk__get_current_pc(comp_ctx);
 
 		DUK_DDD(DUK_DDDPRINT("patching jumps: jumpto_l3: %ld->%ld, jumpto_l4: %ld->%ld, "
 		                     "break: %ld->%ld, continue: %ld->%ld",
-			             (long) pc_jumpto_l3, (long) pc_l3, (long) pc_jumpto_l4, (long) pc_l4,
-		                     (long) (pc_label_site + 1), (long) pc_l4, (long) (pc_label_site + 2), (long) pc_l2));
+		                     (long) pc_jumpto_l3,
+		                     (long) pc_l3,
+		                     (long) pc_jumpto_l4,
+		                     (long) pc_l4,
+		                     (long) (pc_label_site + 1),
+		                     (long) pc_l4,
+		                     (long) (pc_label_site + 2),
+		                     (long) pc_l2));
 
 		duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
 		duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
-		duk__patch_jump(comp_ctx,
-		                pc_label_site + 1,
-		                pc_l4);                         /* break jump */
-		duk__patch_jump(comp_ctx,
-		                pc_label_site + 2,
-		                expr_c_empty ? pc_l1 : pc_l2);  /* continue jump */
+		duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l4); /* break jump */
+		duk__patch_jump(comp_ctx, pc_label_site + 2, expr_c_empty ? pc_l1 : pc_l2); /* continue jump */
 	}
 	goto finished;
 
- parse_3_or_4:
+parse_3_or_4:
 	/*
 	 *  Parse variant 3 or 4.
 	 *
 	 *  For variant 3 (e.g. "for (A in C) D;") the code for A (except the
 	 *  final property/variable write) has already been emitted.  The first
 	 *  instruction of that code is at pc_v34_lhs; a JUMP needs to be inserted
 	 *  there to satisfy control flow needs.
@@ -73353,42 +74651,39 @@
 		 * emitted code to get the control flow right.  No jumps can
 		 * cross the position where the jump is inserted.  See doc/compiler.rst
 		 * for discussion on the intricacies of control flow and side effects
 		 * for variants 3 and 4.
 		 */
 
 		duk__insert_jump_entry(comp_ctx, pc_v34_lhs);
-		pc_jumpto_l2 = pc_v34_lhs;  /* inserted jump */
-		pc_l1 = pc_v34_lhs + 1;     /* +1, right after inserted jump */
+		pc_jumpto_l2 = pc_v34_lhs; /* inserted jump */
+		pc_l1 = pc_v34_lhs + 1; /* +1, right after inserted jump */
 
 		/* The code for writing reg_temps + 0 to the left hand side has already
 		 * been emitted.
 		 */
 
-		pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);  /* -> loop body */
+		pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx); /* -> loop body */
 
-		duk__advance(comp_ctx);  /* eat 'in' */
+		duk__advance(comp_ctx); /* eat 'in' */
 
 		/* Parse enumeration target and initialize enumerator.  For 'null' and 'undefined',
 		 * INITENUM will creates a 'null' enumerator which works like an empty enumerator
 		 * (E5 Section 12.6.4, step 3).  Note that INITENUM requires the value to be in a
 		 * register (constant not allowed).
 		 */
 
 		pc_l2 = duk__get_current_pc(comp_ctx);
-		reg_target = duk__exprtop_toreg(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);  /* Expression */
-		duk__emit_b_c(comp_ctx,
-		              DUK_OP_INITENUM | DUK__EMIT_FLAG_B_IS_TARGET,
-		              reg_temps + 1,
-		              reg_target);
+		reg_target = duk__exprtop_toreg(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/); /* Expression */
+		duk__emit_b_c(comp_ctx, DUK_OP_INITENUM | DUK__EMIT_FLAG_B_IS_TARGET, reg_temps + 1, reg_target);
 		pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);
 		DUK__SETTEMP(comp_ctx, temp_reset);
 
 		comp_ctx->curr_func.allow_regexp_in_adv = 1;
-		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* Allow RegExp as part of next stmt. */
+		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* Allow RegExp as part of next stmt. */
 
 		pc_l3 = duk__get_current_pc(comp_ctx);
 		duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 		/* temp reset is not necessary after duk__parse_stmt(), which already does it */
 
 		/* NEXTENUM needs a jump slot right after the main opcode.
 		 * We need the code emitter to reserve the slot: if there's
@@ -73397,58 +74692,67 @@
 		 * not needed if the enum is finished).
 		 */
 		pc_l4 = duk__get_current_pc(comp_ctx);
 		duk__emit_b_c(comp_ctx,
 		              DUK_OP_NEXTENUM | DUK__EMIT_FLAG_B_IS_TARGET | DUK__EMIT_FLAG_RESERVE_JUMPSLOT,
 		              reg_temps + 0,
 		              reg_temps + 1);
-		pc_jumpto_l5 = comp_ctx->emit_jumpslot_pc;  /* NEXTENUM jump slot: executed when enum finished */
-		duk__emit_jump(comp_ctx, pc_l1);  /* jump to next loop, using reg_v34_iter as iterated value */
+		pc_jumpto_l5 = comp_ctx->emit_jumpslot_pc; /* NEXTENUM jump slot: executed when enum finished */
+		duk__emit_jump(comp_ctx, pc_l1); /* jump to next loop, using reg_v34_iter as iterated value */
 
 		pc_l5 = duk__get_current_pc(comp_ctx);
 
 		/* XXX: since the enumerator may be a memory expensive object,
 		 * perhaps clear it explicitly here?  If so, break jump must
 		 * go through this clearing operation.
 		 */
 
 		DUK_DDD(DUK_DDDPRINT("patching jumps: jumpto_l2: %ld->%ld, jumpto_l3: %ld->%ld, "
 		                     "jumpto_l4: %ld->%ld, jumpto_l5: %ld->%ld, "
 		                     "break: %ld->%ld, continue: %ld->%ld",
-			             (long) pc_jumpto_l2, (long) pc_l2, (long) pc_jumpto_l3, (long) pc_l3,
-			             (long) pc_jumpto_l4, (long) pc_l4, (long) pc_jumpto_l5, (long) pc_l5,
-		                     (long) (pc_label_site + 1), (long) pc_l5, (long) (pc_label_site + 2), (long) pc_l4));
+		                     (long) pc_jumpto_l2,
+		                     (long) pc_l2,
+		                     (long) pc_jumpto_l3,
+		                     (long) pc_l3,
+		                     (long) pc_jumpto_l4,
+		                     (long) pc_l4,
+		                     (long) pc_jumpto_l5,
+		                     (long) pc_l5,
+		                     (long) (pc_label_site + 1),
+		                     (long) pc_l5,
+		                     (long) (pc_label_site + 2),
+		                     (long) pc_l4));
 
 		duk__patch_jump(comp_ctx, pc_jumpto_l2, pc_l2);
 		duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
 		duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
 		duk__patch_jump(comp_ctx, pc_jumpto_l5, pc_l5);
-		duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l5);  /* break jump */
-		duk__patch_jump(comp_ctx, pc_label_site + 2, pc_l4);  /* continue jump */
+		duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l5); /* break jump */
+		duk__patch_jump(comp_ctx, pc_label_site + 2, pc_l4); /* continue jump */
 	}
 	goto finished;
 
- finished:
+finished:
 	DUK_DDD(DUK_DDDPRINT("end parsing a for/for-in statement"));
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_FOR);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_regconst_t temp_at_loop;
-	duk_regconst_t rc_switch;    /* reg/const for switch value */
-	duk_regconst_t rc_case;      /* reg/const for case value */
-	duk_regconst_t reg_temp;     /* general temp register */
+	duk_regconst_t rc_switch; /* reg/const for switch value */
+	duk_regconst_t rc_case; /* reg/const for case value */
+	duk_regconst_t reg_temp; /* general temp register */
 	duk_int_t pc_prevcase = -1;
 	duk_int_t pc_prevstmt = -1;
-	duk_int_t pc_default = -1;   /* -1 == not set, -2 == pending (next statement list) */
+	duk_int_t pc_default = -1; /* -1 == not set, -2 == pending (next statement list) */
 
 	/* Note: negative pc values are ignored when patching jumps, so no explicit checks needed */
 
 	/*
 	 *  Switch is pretty complicated because of several conflicting concerns:
 	 *
 	 *    - Want to generate code without an intermediate representation,
@@ -73471,15 +74775,15 @@
 	 *  See E5 Section 12.11.  Also see doc/compiler.rst for compilation
 	 *  discussion.
 	 */
 
 	duk__advance(comp_ctx);
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 	rc_switch = duk__exprtop_toregconst(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
-	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* RegExp mode does not matter. */
+	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* RegExp mode does not matter. */
 	duk__advance_expect(comp_ctx, DUK_TOK_LCURLY);
 
 	DUK_DDD(DUK_DDDPRINT("switch value in register %ld", (long) rc_switch));
 
 	temp_at_loop = DUK__GETTEMP(comp_ctx);
 
 	for (;;) {
@@ -73501,32 +74805,28 @@
 			/*
 			 *  Case clause.
 			 *
 			 *  Note: cannot use reg_case as a temp register (for SEQ target)
 			 *  because it may be a constant.
 			 */
 
-			duk__patch_jump_here(comp_ctx, pc_prevcase);  /* chain jumps for case
-			                                               * evaluation and checking
-			                                               */
+			duk__patch_jump_here(comp_ctx, pc_prevcase); /* chain jumps for case
+			                                              * evaluation and checking
+			                                              */
 
 			duk__advance(comp_ctx);
 			rc_case = duk__exprtop_toregconst(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
 			duk__advance_expect(comp_ctx, DUK_TOK_COLON);
 
 			reg_temp = DUK__ALLOCTEMP(comp_ctx);
-			duk__emit_a_b_c(comp_ctx,
-			                DUK_OP_SEQ | DUK__EMIT_FLAG_BC_REGCONST,
-			                reg_temp,
-			                rc_switch,
-			                rc_case);
+			duk__emit_a_b_c(comp_ctx, DUK_OP_SEQ | DUK__EMIT_FLAG_BC_REGCONST, reg_temp, rc_switch, rc_case);
 			duk__emit_if_true_skip(comp_ctx, reg_temp);
 
 			/* jump to next case clause */
-			pc_prevcase = duk__emit_jump_empty(comp_ctx);  /* no match, next case */
+			pc_prevcase = duk__emit_jump_empty(comp_ctx); /* no match, next case */
 
 			/* statements go here (if any) on next loop */
 		} else if (comp_ctx->curr_token.t == DUK_TOK_DEFAULT) {
 			/*
 			 *  Default clause.
 			 */
 
@@ -73567,22 +74867,21 @@
 			pc_default = duk__get_current_pc(comp_ctx);
 		}
 
 		/* Note: this is correct even for default clause statements:
 		 * they participate in 'fall-through' behavior even if the
 		 * default clause is in the middle.
 		 */
-		duk__patch_jump_here(comp_ctx, pc_prevstmt);  /* chain jumps for 'fall-through'
-		                                               * after a case matches.
-		                                               */
+		duk__patch_jump_here(comp_ctx, pc_prevstmt); /* chain jumps for 'fall-through'
+		                                              * after a case matches.
+		                                              */
 
 		for (;;) {
 			tok = comp_ctx->curr_token.t;
-			if (tok == DUK_TOK_CASE || tok == DUK_TOK_DEFAULT ||
-			    tok == DUK_TOK_RCURLY) {
+			if (tok == DUK_TOK_CASE || tok == DUK_TOK_DEFAULT || tok == DUK_TOK_RCURLY) {
 				break;
 			}
 			num_stmts++;
 			duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 		}
 
 		/* fall-through jump to next code of next case (backpatched) */
@@ -73597,15 +74896,15 @@
 		 *
 		 * If implemented, just set pc_prevstmt to -1 when not needed.
 		 */
 	}
 
 	DUK_ASSERT(comp_ctx->curr_token.t == DUK_TOK_RCURLY);
 	comp_ctx->curr_func.allow_regexp_in_adv = 1;
-	duk__advance(comp_ctx);  /* Allow RegExp as part of next stmt. */
+	duk__advance(comp_ctx); /* Allow RegExp as part of next stmt. */
 
 	/* default case control flow patchup; note that if pc_prevcase < 0
 	 * (i.e. no case clauses), control enters default case automatically.
 	 */
 	if (pc_default >= 0) {
 		/* default case exists: go there if no case matches */
 		duk__patch_jump(comp_ctx, pc_prevcase, pc_default);
@@ -73618,63 +74917,63 @@
 
 	/* fall-through control flow patchup; note that pc_prevstmt may be
 	 * < 0 (i.e. no case clauses), in which case this is a no-op.
 	 */
 	duk__patch_jump_here(comp_ctx, pc_prevstmt);
 
 	/* continue jump not patched, an INVALID opcode remains there */
-	duk__patch_jump_here(comp_ctx, pc_label_site + 1);  /* break jump */
+	duk__patch_jump_here(comp_ctx, pc_label_site + 1); /* break jump */
 
 	/* Note: 'fast' breaks will jump to pc_label_site + 1, which will
 	 * then jump here.  The double jump will be eliminated by a
 	 * peephole pass, resulting in an optimal jump here.  The label
 	 * site jumps will remain in bytecode and will waste code size.
 	 */
 
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_SWITCH);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_regconst_t temp_reset;
 	duk_regconst_t rc_cond;
 	duk_int_t pc_jump_false;
 
 	DUK_DDD(DUK_DDDPRINT("begin parsing if statement"));
 
 	temp_reset = DUK__GETTEMP(comp_ctx);
 
-	duk__advance(comp_ctx);  /* eat 'if' */
+	duk__advance(comp_ctx); /* eat 'if' */
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 
 	rc_cond = duk__exprtop_toregconst(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
 	duk__emit_if_true_skip(comp_ctx, rc_cond);
-	pc_jump_false = duk__emit_jump_empty(comp_ctx);  /* jump to end or else part */
+	pc_jump_false = duk__emit_jump_empty(comp_ctx); /* jump to end or else part */
 	DUK__SETTEMP(comp_ctx, temp_reset);
 
 	comp_ctx->curr_func.allow_regexp_in_adv = 1;
-	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* Allow RegExp as part of next stmt. */
+	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* Allow RegExp as part of next stmt. */
 
 	duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 
 	/* The 'else' ambiguity is resolved by 'else' binding to the innermost
 	 * construct, so greedy matching is correct here.
 	 */
 
 	if (comp_ctx->curr_token.t == DUK_TOK_ELSE) {
 		duk_int_t pc_jump_end;
 
 		DUK_DDD(DUK_DDDPRINT("if has else part"));
 
 		duk__advance(comp_ctx);
 
-		pc_jump_end = duk__emit_jump_empty(comp_ctx);  /* jump from true part to end */
+		pc_jump_end = duk__emit_jump_empty(comp_ctx); /* jump from true part to end */
 		duk__patch_jump_here(comp_ctx, pc_jump_false);
 
 		duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 
 		duk__patch_jump_here(comp_ctx, pc_jump_end);
 	} else {
 		DUK_DDD(DUK_DDDPRINT("if does not have else part"));
@@ -73687,143 +74986,158 @@
 
 DUK_LOCAL void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 	duk_regconst_t rc_cond;
 	duk_int_t pc_start;
 
 	DUK_DDD(DUK_DDDPRINT("begin parsing do statement"));
 
-	duk__advance(comp_ctx);  /* Eat 'do'; allow RegExp as part of next stmt. */
+	duk__advance(comp_ctx); /* Eat 'do'; allow RegExp as part of next stmt. */
 
 	pc_start = duk__get_current_pc(comp_ctx);
 	duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
-	duk__patch_jump_here(comp_ctx, pc_label_site + 2);  /* continue jump */
+	duk__patch_jump_here(comp_ctx, pc_label_site + 2); /* continue jump */
 
 	duk__advance_expect(comp_ctx, DUK_TOK_WHILE);
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 
 	rc_cond = duk__exprtop_toregconst(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
 	duk__emit_if_false_skip(comp_ctx, rc_cond);
 	duk__emit_jump(comp_ctx, pc_start);
 	/* no need to reset temps, as we're finished emitting code */
 
-	comp_ctx->curr_func.allow_regexp_in_adv = 1;  /* Allow RegExp as part of next stmt. */
+	comp_ctx->curr_func.allow_regexp_in_adv = 1; /* Allow RegExp as part of next stmt. */
 	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);
 
-	duk__patch_jump_here(comp_ctx, pc_label_site + 1);  /* break jump */
+	duk__patch_jump_here(comp_ctx, pc_label_site + 1); /* break jump */
 
 	DUK_DDD(DUK_DDDPRINT("end parsing do statement"));
 }
 
 DUK_LOCAL void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 	duk_regconst_t temp_reset;
 	duk_regconst_t rc_cond;
 	duk_int_t pc_start;
 	duk_int_t pc_jump_false;
 
 	DUK_DDD(DUK_DDDPRINT("begin parsing while statement"));
 
 	temp_reset = DUK__GETTEMP(comp_ctx);
 
-	duk__advance(comp_ctx);  /* eat 'while' */
+	duk__advance(comp_ctx); /* eat 'while' */
 
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 
 	pc_start = duk__get_current_pc(comp_ctx);
-	duk__patch_jump_here(comp_ctx, pc_label_site + 2);  /* continue jump */
+	duk__patch_jump_here(comp_ctx, pc_label_site + 2); /* continue jump */
 
 	rc_cond = duk__exprtop_toregconst(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
 	duk__emit_if_true_skip(comp_ctx, rc_cond);
 	pc_jump_false = duk__emit_jump_empty(comp_ctx);
 	DUK__SETTEMP(comp_ctx, temp_reset);
 
 	comp_ctx->curr_func.allow_regexp_in_adv = 1;
-	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* Allow RegExp as part of next stmt. */
+	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* Allow RegExp as part of next stmt. */
 
 	duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 	duk__emit_jump(comp_ctx, pc_start);
 
 	duk__patch_jump_here(comp_ctx, pc_jump_false);
-	duk__patch_jump_here(comp_ctx, pc_label_site + 1);  /* break jump */
+	duk__patch_jump_here(comp_ctx, pc_label_site + 1); /* break jump */
 
 	DUK_DDD(DUK_DDDPRINT("end parsing while statement"));
 }
 
 DUK_LOCAL void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_bool_t is_break = (comp_ctx->curr_token.t == DUK_TOK_BREAK);
 	duk_int_t label_id;
 	duk_int_t label_catch_depth;
-	duk_int_t label_pc;  /* points to LABEL; pc+1 = jump site for break; pc+2 = jump site for continue */
+	duk_int_t label_pc; /* points to LABEL; pc+1 = jump site for break; pc+2 = jump site for continue */
 	duk_bool_t label_is_closest;
 
 	DUK_UNREF(res);
 
-	duk__advance(comp_ctx);  /* eat 'break' or 'continue' */
+	duk__advance(comp_ctx); /* eat 'break' or 'continue' */
 
-	if (comp_ctx->curr_token.t == DUK_TOK_SEMICOLON ||  /* explicit semi follows */
-	    comp_ctx->curr_token.lineterm ||                /* automatic semi will be inserted */
-	    comp_ctx->curr_token.allow_auto_semi) {         /* automatic semi will be inserted */
+	if (comp_ctx->curr_token.t == DUK_TOK_SEMICOLON || /* explicit semi follows */
+	    comp_ctx->curr_token.lineterm || /* automatic semi will be inserted */
+	    comp_ctx->curr_token.allow_auto_semi) { /* automatic semi will be inserted */
 		/* break/continue without label */
 
-		duk__lookup_active_label(comp_ctx, DUK_HTHREAD_STRING_EMPTY_STRING(thr), is_break, &label_id, &label_catch_depth, &label_pc, &label_is_closest);
+		duk__lookup_active_label(comp_ctx,
+		                         DUK_HTHREAD_STRING_EMPTY_STRING(thr),
+		                         is_break,
+		                         &label_id,
+		                         &label_catch_depth,
+		                         &label_pc,
+		                         &label_is_closest);
 	} else if (comp_ctx->curr_token.t == DUK_TOK_IDENTIFIER) {
 		/* break/continue with label (label cannot be a reserved word, production is 'Identifier' */
 		DUK_ASSERT(comp_ctx->curr_token.str1 != NULL);
-		duk__lookup_active_label(comp_ctx, comp_ctx->curr_token.str1, is_break, &label_id, &label_catch_depth, &label_pc, &label_is_closest);
+		duk__lookup_active_label(comp_ctx,
+		                         comp_ctx->curr_token.str1,
+		                         is_break,
+		                         &label_id,
+		                         &label_catch_depth,
+		                         &label_pc,
+		                         &label_is_closest);
 		duk__advance(comp_ctx);
 	} else {
 		DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_BREAK_CONT_LABEL);
 		DUK_WO_NORETURN(return;);
 	}
 
 	/* Use a fast break/continue when possible.  A fast break/continue is
 	 * just a jump to the LABEL break/continue jump slot, which then jumps
 	 * to an appropriate place (for break, going through ENDLABEL correctly).
 	 * The peephole optimizer will optimize the jump to a direct one.
 	 */
 
-	if (label_catch_depth == comp_ctx->curr_func.catch_depth &&
-	    label_is_closest) {
+	if (label_catch_depth == comp_ctx->curr_func.catch_depth && label_is_closest) {
 		DUK_DDD(DUK_DDDPRINT("break/continue: is_break=%ld, label_id=%ld, label_is_closest=%ld, "
 		                     "label_catch_depth=%ld, catch_depth=%ld "
 		                     "-> use fast variant (direct jump)",
-		                     (long) is_break, (long) label_id, (long) label_is_closest,
-		                     (long) label_catch_depth, (long) comp_ctx->curr_func.catch_depth));
+		                     (long) is_break,
+		                     (long) label_id,
+		                     (long) label_is_closest,
+		                     (long) label_catch_depth,
+		                     (long) comp_ctx->curr_func.catch_depth));
 
 		duk__emit_jump(comp_ctx, label_pc + (is_break ? 1 : 2));
 	} else {
 		DUK_DDD(DUK_DDDPRINT("break/continue: is_break=%ld, label_id=%ld, label_is_closest=%ld, "
 		                     "label_catch_depth=%ld, catch_depth=%ld "
 		                     "-> use slow variant (longjmp)",
-		                     (long) is_break, (long) label_id, (long) label_is_closest,
-		                     (long) label_catch_depth, (long) comp_ctx->curr_func.catch_depth));
+		                     (long) is_break,
+		                     (long) label_id,
+		                     (long) label_is_closest,
+		                     (long) label_catch_depth,
+		                     (long) comp_ctx->curr_func.catch_depth));
 
-		duk__emit_bc(comp_ctx,
-		             is_break ? DUK_OP_BREAK : DUK_OP_CONTINUE,
-		             (duk_regconst_t) label_id);
+		duk__emit_bc(comp_ctx, is_break ? DUK_OP_BREAK : DUK_OP_CONTINUE, (duk_regconst_t) label_id);
 	}
 }
 
 DUK_LOCAL void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_regconst_t rc_val;
 
-	duk__advance(comp_ctx);  /* eat 'return' */
+	duk__advance(comp_ctx); /* eat 'return' */
 
 	/* A 'return' statement is only allowed inside an actual function body,
 	 * not as part of eval or global code.
 	 */
 	if (!comp_ctx->curr_func.is_function) {
 		DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_RETURN);
 		DUK_WO_NORETURN(return;);
 	}
 
-	if (comp_ctx->curr_token.t == DUK_TOK_SEMICOLON ||  /* explicit semi follows */
-	    comp_ctx->curr_token.lineterm ||                /* automatic semi will be inserted */
-	    comp_ctx->curr_token.allow_auto_semi) {         /* automatic semi will be inserted */
+	if (comp_ctx->curr_token.t == DUK_TOK_SEMICOLON || /* explicit semi follows */
+	    comp_ctx->curr_token.lineterm || /* automatic semi will be inserted */
+	    comp_ctx->curr_token.allow_auto_semi) { /* automatic semi will be inserted */
 		DUK_DDD(DUK_DDDPRINT("empty return value -> undefined"));
 		duk__emit_op_only(comp_ctx, DUK_OP_RETUNDEF);
 	} else {
 		duk_int_t pc_before_expr;
 		duk_int_t pc_after_expr;
 
 		DUK_DDD(DUK_DDDPRINT("return with a value"));
@@ -73867,36 +75181,35 @@
 		 *
 		 * The non-standard 'caller' property disables tail calls
 		 * because they pose some special cases which haven't been
 		 * fixed yet.
 		 */
 
 #if defined(DUK_USE_TAILCALL)
-		if (comp_ctx->curr_func.catch_depth == 0 &&   /* no catchers */
-		    pc_after_expr > pc_before_expr) {         /* at least one opcode emitted */
+		if (comp_ctx->curr_func.catch_depth == 0 && /* no catchers */
+		    pc_after_expr > pc_before_expr) { /* at least one opcode emitted */
 			duk_compiler_instr *instr;
 			duk_instr_t ins;
 			duk_small_uint_t op;
 
 			instr = duk__get_instr_ptr(comp_ctx, pc_after_expr - 1);
 			DUK_ASSERT(instr != NULL);
 
 			ins = instr->ins;
 			op = (duk_small_uint_t) DUK_DEC_OP(ins);
-			if ((op & ~0x0fU) == DUK_OP_CALL0 &&
-			    DUK__ISREG_TEMP(comp_ctx, rc_val) /* see above */) {
+			if ((op & ~0x0fU) == DUK_OP_CALL0 && DUK__ISREG_TEMP(comp_ctx, rc_val) /* see above */) {
 				DUK_DDD(DUK_DDDPRINT("return statement detected a tail call opportunity: "
 				                     "catch depth is 0, duk__exprtop() emitted >= 1 instructions, "
 				                     "and last instruction is a CALL "
 				                     "-> change to TAILCALL"));
 				ins |= DUK_ENC_OP(DUK_BC_CALL_FLAG_TAILCALL);
 				instr->ins = ins;
 			}
 		}
-#endif  /* DUK_USE_TAILCALL */
+#endif /* DUK_USE_TAILCALL */
 
 		if (DUK__ISREG(rc_val)) {
 			duk__emit_bc(comp_ctx, DUK_OP_RETREG, rc_val);
 		} else {
 			rc_val = DUK__REMOVECONST(rc_val);
 			if (duk__const_needs_refcount(comp_ctx, rc_val)) {
 				duk__emit_bc(comp_ctx, DUK_OP_RETCONST, rc_val);
@@ -73906,32 +75219,30 @@
 		}
 	}
 }
 
 DUK_LOCAL void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_regconst_t reg_val;
 
-	duk__advance(comp_ctx);  /* eat 'throw' */
+	duk__advance(comp_ctx); /* eat 'throw' */
 
 	/* Unlike break/continue, throw statement does not allow an empty value. */
 
 	if (comp_ctx->curr_token.lineterm) {
 		DUK_ERROR_SYNTAX(comp_ctx->thr, DUK_STR_INVALID_THROW);
 		DUK_WO_NORETURN(return;);
 	}
 
 	reg_val = duk__exprtop_toreg(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
-	duk__emit_bc(comp_ctx,
-	             DUK_OP_THROW,
-	             reg_val);
+	duk__emit_bc(comp_ctx, DUK_OP_THROW, reg_val);
 }
 
 DUK_LOCAL void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_hthread *thr = comp_ctx->thr;
-	duk_regconst_t reg_catch;      /* reg_catch+0 and reg_catch+1 are reserved for TRYCATCH */
+	duk_regconst_t reg_catch; /* reg_catch+0 and reg_catch+1 are reserved for TRYCATCH */
 	duk_regconst_t rc_varname = 0;
 	duk_small_uint_t trycatch_flags = 0;
 	duk_int_t pc_ldconst = -1;
 	duk_int_t pc_trycatch = -1;
 	duk_int_t pc_catch = -1;
 	duk_int_t pc_finally = -1;
 
@@ -73950,30 +75261,30 @@
 	 *
 	 *  Finally part has a 'let scoped' variable, which requires a few kinks
 	 *  here.
 	 */
 
 	comp_ctx->curr_func.catch_depth++;
 
-	duk__advance(comp_ctx);  /* eat 'try' */
+	duk__advance(comp_ctx); /* eat 'try' */
 
 	reg_catch = DUK__ALLOCTEMPS(comp_ctx, 2);
 
 	/* The target for this LDCONST may need output shuffling, but we assume
 	 * that 'pc_ldconst' will be the LDCONST that we can patch later.  This
 	 * should be the case because there's no input shuffling.  (If there's
 	 * no catch clause, this LDCONST will be replaced with a NOP.)
 	 */
 	pc_ldconst = duk__get_current_pc(comp_ctx);
 	duk__emit_a_bc(comp_ctx, DUK_OP_LDCONST, reg_catch, 0 /*patched later*/);
 
 	pc_trycatch = duk__get_current_pc(comp_ctx);
-	duk__emit_invalid(comp_ctx);  /* TRYCATCH, cannot emit now (not enough info) */
-	duk__emit_invalid(comp_ctx);  /* jump for 'catch' case */
-	duk__emit_invalid(comp_ctx);  /* jump for 'finally' case or end (if no finally) */
+	duk__emit_invalid(comp_ctx); /* TRYCATCH, cannot emit now (not enough info) */
+	duk__emit_invalid(comp_ctx); /* jump for 'catch' case */
+	duk__emit_invalid(comp_ctx); /* jump for 'finally' case or end (if no finally) */
 
 	/* try part */
 	duk__advance_expect(comp_ctx, DUK_TOK_LCURLY);
 	duk__parse_stmts(comp_ctx, 0 /*allow_source_elem*/, 0 /*expect_eof*/, 1 /*regexp_after*/);
 	/* the DUK_TOK_RCURLY is eaten by duk__parse_stmts() */
 	duk__emit_op_only(comp_ctx, DUK_OP_ENDTRY);
 
@@ -73994,15 +75305,15 @@
 		 *
 		 *  See: test-bug-catch-binding-2.js.
 		 *
 		 *  XXX: improve to get fast path access to most catch clauses.
 		 */
 
 		duk_hstring *h_var;
-		duk_int_t varmap_value;  /* for storing/restoring the varmap binding for catch variable */
+		duk_int_t varmap_value; /* for storing/restoring the varmap binding for catch variable */
 
 		DUK_DDD(DUK_DDDPRINT("stack top at start of catch clause: %ld", (long) duk_get_top(thr)));
 
 		trycatch_flags |= DUK_BC_TRYCATCH_FLAG_HAVE_CATCH;
 
 		pc_catch = duk__get_current_pc(comp_ctx);
 
@@ -74012,27 +75323,25 @@
 		if (comp_ctx->curr_token.t != DUK_TOK_IDENTIFIER) {
 			/* Identifier, i.e. don't allow reserved words */
 			goto syntax_error;
 		}
 		h_var = comp_ctx->curr_token.str1;
 		DUK_ASSERT(h_var != NULL);
 
-		duk_push_hstring(thr, h_var);  /* keep in on valstack, use borrowed ref below */
+		duk_push_hstring(thr, h_var); /* keep in on valstack, use borrowed ref below */
 
 		if (comp_ctx->curr_func.is_strict &&
-		    ((h_var == DUK_HTHREAD_STRING_EVAL(thr)) ||
-		     (h_var == DUK_HTHREAD_STRING_LC_ARGUMENTS(thr)))) {
+		    ((h_var == DUK_HTHREAD_STRING_EVAL(thr)) || (h_var == DUK_HTHREAD_STRING_LC_ARGUMENTS(thr)))) {
 			DUK_DDD(DUK_DDDPRINT("catch identifier 'eval' or 'arguments' in strict mode -> SyntaxError"));
 			goto syntax_error;
 		}
 
 		duk_dup_top(thr);
 		rc_varname = duk__getconst(comp_ctx);
-		DUK_DDD(DUK_DDDPRINT("catch clause, rc_varname=0x%08lx (%ld)",
-		                     (unsigned long) rc_varname, (long) rc_varname));
+		DUK_DDD(DUK_DDDPRINT("catch clause, rc_varname=0x%08lx (%ld)", (unsigned long) rc_varname, (long) rc_varname));
 
 		duk__advance(comp_ctx);
 		duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);
 
 		duk__advance_expect(comp_ctx, DUK_TOK_LCURLY);
 
 		DUK_DDD(DUK_DDDPRINT("varmap before modifying for catch clause: %!iT",
@@ -74087,16 +75396,15 @@
 			duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
 		}
 		/* varname is popped by above code */
 
 		DUK_DDD(DUK_DDDPRINT("varmap after restore catch clause: %!iT",
 		                     (duk_tval *) duk_get_tval(thr, comp_ctx->curr_func.varmap_idx)));
 
-		duk__emit_op_only(comp_ctx,
-		                  DUK_OP_ENDCATCH);
+		duk__emit_op_only(comp_ctx, DUK_OP_ENDCATCH);
 
 		/*
 		 *  XXX: for now, indicate that an expensive catch binding
 		 *  declarative environment is always needed.  If we don't
 		 *  need it, we don't need the const_varname either.
 		 */
 
@@ -74111,36 +75419,28 @@
 		pc_finally = duk__get_current_pc(comp_ctx);
 
 		duk__advance(comp_ctx);
 
 		duk__advance_expect(comp_ctx, DUK_TOK_LCURLY);
 		duk__parse_stmts(comp_ctx, 0 /*allow_source_elem*/, 0 /*expect_eof*/, 1 /*regexp_after*/);
 		/* the DUK_TOK_RCURLY is eaten by duk__parse_stmts() */
-		duk__emit_abc(comp_ctx,
-		              DUK_OP_ENDFIN,
-		              reg_catch);  /* rethrow */
+		duk__emit_abc(comp_ctx, DUK_OP_ENDFIN, reg_catch); /* rethrow */
 	}
 
-	if (!(trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_CATCH) &&
-	    !(trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_FINALLY)) {
+	if (!(trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_CATCH) && !(trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_FINALLY)) {
 		/* must have catch and/or finally */
 		goto syntax_error;
 	}
 
 	/* If there's no catch block, rc_varname will be 0 and duk__patch_trycatch()
 	 * will replace the LDCONST with a NOP.  For any actual constant (including
 	 * constant 0) the DUK__CONST_MARKER flag will be set in rc_varname.
 	 */
 
-	duk__patch_trycatch(comp_ctx,
-	                    pc_ldconst,
-	                    pc_trycatch,
-	                    reg_catch,
-	                    rc_varname,
-	                    trycatch_flags);
+	duk__patch_trycatch(comp_ctx, pc_ldconst, pc_trycatch, reg_catch, rc_varname, trycatch_flags);
 
 	if (trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_CATCH) {
 		DUK_ASSERT(pc_catch >= 0);
 		duk__patch_jump(comp_ctx, pc_trycatch + 1, pc_catch);
 	}
 
 	if (trycatch_flags & DUK_BC_TRYCATCH_FLAG_HAVE_FINALLY) {
@@ -74150,15 +75450,15 @@
 		/* without finally, the second jump slot is used to jump to end of stmt */
 		duk__patch_jump_here(comp_ctx, pc_trycatch + 2);
 	}
 
 	comp_ctx->curr_func.catch_depth--;
 	return;
 
- syntax_error:
+syntax_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_TRY);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 	duk_int_t pc_trycatch;
 	duk_int_t pc_finished;
@@ -74168,31 +75468,31 @@
 	if (comp_ctx->curr_func.is_strict) {
 		DUK_ERROR_SYNTAX(comp_ctx->thr, DUK_STR_WITH_IN_STRICT_MODE);
 		DUK_WO_NORETURN(return;);
 	}
 
 	comp_ctx->curr_func.catch_depth++;
 
-	duk__advance(comp_ctx);  /* eat 'with' */
+	duk__advance(comp_ctx); /* eat 'with' */
 
 	reg_catch = DUK__ALLOCTEMPS(comp_ctx, 2);
 
 	duk__advance_expect(comp_ctx, DUK_TOK_LPAREN);
 	duk__exprtop_toforcedreg(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/, reg_catch);
 	comp_ctx->curr_func.allow_regexp_in_adv = 1;
-	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN);  /* Allow RegExp as part of next stmt. */
+	duk__advance_expect(comp_ctx, DUK_TOK_RPAREN); /* Allow RegExp as part of next stmt. */
 
 	pc_trycatch = duk__get_current_pc(comp_ctx);
 	trycatch_flags = DUK_BC_TRYCATCH_FLAG_WITH_BINDING;
 	duk__emit_a_bc(comp_ctx,
-	                DUK_OP_TRYCATCH | DUK__EMIT_FLAG_NO_SHUFFLE_A,
-	                (duk_regconst_t) trycatch_flags /*a*/,
-	                reg_catch /*bc*/);
-	duk__emit_invalid(comp_ctx);  /* catch jump */
-	duk__emit_invalid(comp_ctx);  /* finished jump */
+	               DUK_OP_TRYCATCH | DUK__EMIT_FLAG_NO_SHUFFLE_A,
+	               (duk_regconst_t) trycatch_flags /*a*/,
+	               reg_catch /*bc*/);
+	duk__emit_invalid(comp_ctx); /* catch jump */
+	duk__emit_invalid(comp_ctx); /* finished jump */
 
 	duk__parse_stmt(comp_ctx, res, 0 /*allow_source_elem*/);
 	duk__emit_op_only(comp_ctx, DUK_OP_ENDTRY);
 
 	pc_finished = duk__get_current_pc(comp_ctx);
 
 	duk__patch_jump(comp_ctx, pc_trycatch + 2, pc_finished);
@@ -74205,34 +75505,32 @@
 	if (label_id >= 0) {
 		return label_id;
 	}
 
 	label_id = comp_ctx->curr_func.label_next++;
 	DUK_DDD(DUK_DDDPRINT("allocated new label id for label site: %ld", (long) label_id));
 
-	duk__emit_bc(comp_ctx,
-	             DUK_OP_LABEL,
-	             (duk_regconst_t) label_id);
+	duk__emit_bc(comp_ctx, DUK_OP_LABEL, (duk_regconst_t) label_id);
 	duk__emit_invalid(comp_ctx);
 	duk__emit_invalid(comp_ctx);
 
 	return label_id;
 }
 
 /* Parse a single statement.
  *
  * Creates a label site (with an empty label) automatically for iteration
  * statements.  Also "peels off" any label statements for explicit labels.
  */
 DUK_LOCAL void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem) {
 	duk_hthread *thr = comp_ctx->thr;
-	duk_bool_t dir_prol_at_entry;    /* directive prologue status at entry */
+	duk_bool_t dir_prol_at_entry; /* directive prologue status at entry */
 	duk_regconst_t temp_at_entry;
 	duk_size_t labels_len_at_entry;
-	duk_int_t pc_at_entry;           /* assumed to also be PC of "LABEL" */
+	duk_int_t pc_at_entry; /* assumed to also be PC of "LABEL" */
 	duk_int_t stmt_id;
 	duk_small_uint_t stmt_flags = 0;
 	duk_int_t label_id = -1;
 	duk_small_uint_t tok;
 	duk_bool_t test_func_decl;
 
 	DUK__RECURSION_INCREASE(comp_ctx, thr);
@@ -74243,46 +75541,47 @@
 	stmt_id = comp_ctx->curr_func.stmt_next++;
 	dir_prol_at_entry = comp_ctx->curr_func.in_directive_prologue;
 
 	DUK_UNREF(stmt_id);
 
 	DUK_DDD(DUK_DDDPRINT("parsing a statement, stmt_id=%ld, temp_at_entry=%ld, labels_len_at_entry=%ld, "
 	                     "is_strict=%ld, in_directive_prologue=%ld, catch_depth=%ld",
-	                     (long) stmt_id, (long) temp_at_entry, (long) labels_len_at_entry,
-	                     (long) comp_ctx->curr_func.is_strict, (long) comp_ctx->curr_func.in_directive_prologue,
+	                     (long) stmt_id,
+	                     (long) temp_at_entry,
+	                     (long) labels_len_at_entry,
+	                     (long) comp_ctx->curr_func.is_strict,
+	                     (long) comp_ctx->curr_func.in_directive_prologue,
 	                     (long) comp_ctx->curr_func.catch_depth));
 
 	/* The directive prologue flag is cleared by default so that it is
 	 * unset for any recursive statement parsing.  It is only "revived"
 	 * if a directive is detected.  (We could also make directives only
 	 * allowed if 'allow_source_elem' was true.)
 	 */
 	comp_ctx->curr_func.in_directive_prologue = 0;
 
- retry_parse:
+retry_parse:
 
 	DUK_DDD(DUK_DDDPRINT("try stmt parse, stmt_id=%ld, label_id=%ld, allow_source_elem=%ld, catch_depth=%ld",
-	                     (long) stmt_id, (long) label_id, (long) allow_source_elem,
+	                     (long) stmt_id,
+	                     (long) label_id,
+	                     (long) allow_source_elem,
 	                     (long) comp_ctx->curr_func.catch_depth));
 
 	/*
 	 *  Detect iteration statements; if encountered, establish an
 	 *  empty label.
 	 */
 
 	tok = comp_ctx->curr_token.t;
-	if (tok == DUK_TOK_FOR || tok == DUK_TOK_DO || tok == DUK_TOK_WHILE ||
-	    tok == DUK_TOK_SWITCH) {
+	if (tok == DUK_TOK_FOR || tok == DUK_TOK_DO || tok == DUK_TOK_WHILE || tok == DUK_TOK_SWITCH) {
 		DUK_DDD(DUK_DDDPRINT("iteration/switch statement -> add empty label"));
 
 		label_id = duk__stmt_label_site(comp_ctx, label_id);
-		duk__add_label(comp_ctx,
-		               DUK_HTHREAD_STRING_EMPTY_STRING(thr),
-		               pc_at_entry /*pc_label*/,
-		               label_id);
+		duk__add_label(comp_ctx, DUK_HTHREAD_STRING_EMPTY_STRING(thr), pc_at_entry /*pc_label*/, label_id);
 	}
 
 	/*
 	 *  Main switch for statement / source element type.
 	 */
 
 	switch (comp_ctx->curr_token.t) {
@@ -74301,18 +75600,16 @@
 		 */
 		test_func_decl = allow_source_elem;
 #if defined(DUK_USE_NONSTD_FUNC_STMT)
 		/* Lenient: allow function declarations outside top level in both
 		 * strict and non-strict modes.  However, don't allow labelled
 		 * function declarations in strict mode.
 		 */
-		test_func_decl = test_func_decl ||
-		                 !comp_ctx->curr_func.is_strict ||
-		                 label_id < 0;
-#endif  /* DUK_USE_NONSTD_FUNC_STMT */
+		test_func_decl = test_func_decl || !comp_ctx->curr_func.is_strict || label_id < 0;
+#endif /* DUK_USE_NONSTD_FUNC_STMT */
 		/* Strict: never allow function declarations outside top level. */
 		if (test_func_decl) {
 			/* FunctionDeclaration: not strictly a statement but handled as such.
 			 *
 			 * O(depth^2) parse count for inner functions is handled by recording a
 			 * lexer offset on the first compilation pass, so that the function can
 			 * be efficiently skipped on the second pass.  This is encapsulated into
@@ -74326,29 +75623,30 @@
 
 			DUK_DDD(DUK_DDDPRINT("function declaration statement"));
 
 #if defined(DUK_USE_ASSERTIONS)
 			top_before = duk_get_top(thr);
 #endif
 
-			duk__advance(comp_ctx);  /* eat 'function' */
+			duk__advance(comp_ctx); /* eat 'function' */
 			fnum = duk__parse_func_like_fnum(comp_ctx, DUK__FUNC_FLAG_DECL | DUK__FUNC_FLAG_PUSHNAME_PASS1);
 
 			/* The value stack convention here is a bit odd: the function
 			 * name is only pushed on pass 1 (in_scanning), and is needed
 			 * to process function declarations.
 			 */
 			if (comp_ctx->curr_func.in_scanning) {
 				duk_uarridx_t n;
 
 #if defined(DUK_USE_ASSERTIONS)
 				DUK_ASSERT(duk_get_top(thr) == top_before + 1);
 #endif
 				DUK_DDD(DUK_DDDPRINT("register function declaration %!T in pass 1, fnum %ld",
-				                     duk_get_tval(thr, -1), (long) fnum));
+				                     duk_get_tval(thr, -1),
+				                     (long) fnum));
 				n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
 				/* funcname is at index -1 */
 				duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
 				duk_push_int(thr, (duk_int_t) (DUK_DECL_TYPE_FUNC + (fnum << 8)));
 				duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
 			} else {
 #if defined(DUK_USE_ASSERTIONS)
@@ -74367,15 +75665,15 @@
 	}
 	case DUK_TOK_LCURLY: {
 		DUK_DDD(DUK_DDDPRINT("block statement"));
 		duk__advance(comp_ctx);
 		duk__parse_stmts(comp_ctx, 0 /*allow_source_elem*/, 0 /*expect_eof*/, 1 /*regexp_after*/);
 		/* the DUK_TOK_RCURLY is eaten by duk__parse_stmts() */
 		if (label_id >= 0) {
-			duk__patch_jump_here(comp_ctx, pc_at_entry + 1);  /* break jump */
+			duk__patch_jump_here(comp_ctx, pc_at_entry + 1); /* break jump */
 		}
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_CONST: {
 		DUK_DDD(DUK_DDDPRINT("constant declaration statement"));
 		duk__parse_var_stmt(comp_ctx, res, DUK__EXPR_FLAG_REQUIRE_INIT /*expr_flags*/);
@@ -74394,15 +75692,15 @@
 		stmt_flags = DUK__HAS_TERM;
 		break;
 	}
 	case DUK_TOK_IF: {
 		DUK_DDD(DUK_DDDPRINT("if statement"));
 		duk__parse_if_stmt(comp_ctx, res);
 		if (label_id >= 0) {
-			duk__patch_jump_here(comp_ctx, pc_at_entry + 1);  /* break jump */
+			duk__patch_jump_here(comp_ctx, pc_at_entry + 1); /* break jump */
 		}
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_DO: {
 		/*
 		 *  Do-while statement is mostly trivial, but there is special
@@ -74411,44 +75709,38 @@
 		 *
 		 *    https://bugs.ecmascript.org/show_bug.cgi?id=8
 		 *
 		 *  See doc/compiler.rst for details.
 		 */
 		DUK_DDD(DUK_DDDPRINT("do statement"));
 		DUK_ASSERT(label_id >= 0);
-		duk__update_label_flags(comp_ctx,
-		                        label_id,
-		                        DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
+		duk__update_label_flags(comp_ctx, label_id, DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
 		duk__parse_do_stmt(comp_ctx, res, pc_at_entry);
-		stmt_flags = DUK__HAS_TERM | DUK__ALLOW_AUTO_SEMI_ALWAYS;  /* DUK__ALLOW_AUTO_SEMI_ALWAYS workaround */
+		stmt_flags = DUK__HAS_TERM | DUK__ALLOW_AUTO_SEMI_ALWAYS; /* DUK__ALLOW_AUTO_SEMI_ALWAYS workaround */
 		break;
 	}
 	case DUK_TOK_WHILE: {
 		DUK_DDD(DUK_DDDPRINT("while statement"));
 		DUK_ASSERT(label_id >= 0);
-		duk__update_label_flags(comp_ctx,
-		                        label_id,
-		                        DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
+		duk__update_label_flags(comp_ctx, label_id, DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
 		duk__parse_while_stmt(comp_ctx, res, pc_at_entry);
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_FOR: {
 		/*
 		 *  For/for-in statement is complicated to parse because
 		 *  determining the statement type (three-part for vs. a
 		 *  for-in) requires potential backtracking.
 		 *
 		 *  See the helper for the messy stuff.
 		 */
 		DUK_DDD(DUK_DDDPRINT("for/for-in statement"));
 		DUK_ASSERT(label_id >= 0);
-		duk__update_label_flags(comp_ctx,
-		                        label_id,
-		                        DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
+		duk__update_label_flags(comp_ctx, label_id, DUK_LABEL_FLAG_ALLOW_BREAK | DUK_LABEL_FLAG_ALLOW_CONTINUE);
 		duk__parse_for_stmt(comp_ctx, res, pc_at_entry);
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_CONTINUE:
 	case DUK_TOK_BREAK: {
 		DUK_DDD(DUK_DDDPRINT("break/continue statement"));
@@ -74463,30 +75755,28 @@
 		break;
 	}
 	case DUK_TOK_WITH: {
 		DUK_DDD(DUK_DDDPRINT("with statement"));
 		comp_ctx->curr_func.with_depth++;
 		duk__parse_with_stmt(comp_ctx, res);
 		if (label_id >= 0) {
-			duk__patch_jump_here(comp_ctx, pc_at_entry + 1);  /* break jump */
+			duk__patch_jump_here(comp_ctx, pc_at_entry + 1); /* break jump */
 		}
 		comp_ctx->curr_func.with_depth--;
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_SWITCH: {
 		/*
 		 *  The switch statement is pretty messy to compile.
 		 *  See the helper for details.
 		 */
 		DUK_DDD(DUK_DDDPRINT("switch statement"));
 		DUK_ASSERT(label_id >= 0);
-		duk__update_label_flags(comp_ctx,
-		                        label_id,
-		                        DUK_LABEL_FLAG_ALLOW_BREAK);  /* don't allow continue */
+		duk__update_label_flags(comp_ctx, label_id, DUK_LABEL_FLAG_ALLOW_BREAK); /* don't allow continue */
 		duk__parse_switch_stmt(comp_ctx, res, pc_at_entry);
 		stmt_flags = 0;
 		break;
 	}
 	case DUK_TOK_THROW: {
 		DUK_DDD(DUK_DDDPRINT("throw statement"));
 		duk__parse_throw_stmt(comp_ctx, res);
@@ -74545,58 +75835,52 @@
 		 */
 
 		duk_bool_t single_token;
 
 		DUK_DDD(DUK_DDDPRINT("expression statement"));
 		duk__exprtop(comp_ctx, res, DUK__BP_FOR_EXPR /*rbp_flags*/);
 
-		single_token = (comp_ctx->curr_func.nud_count == 1 &&  /* one token */
-		                comp_ctx->curr_func.led_count == 0);   /* no operators */
+		single_token = (comp_ctx->curr_func.nud_count == 1 && /* one token */
+		                comp_ctx->curr_func.led_count == 0); /* no operators */
 
-		if (single_token &&
-		    comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER &&
-		    comp_ctx->curr_token.t == DUK_TOK_COLON) {
+		if (single_token && comp_ctx->prev_token.t == DUK_TOK_IDENTIFIER && comp_ctx->curr_token.t == DUK_TOK_COLON) {
 			/*
 			 *  Detected label
 			 */
 
 			duk_hstring *h_lab;
 
 			/* expected ival */
 			DUK_ASSERT(res->t == DUK_IVAL_VAR);
 			DUK_ASSERT(res->x1.t == DUK_ISPEC_VALUE);
 			DUK_ASSERT(DUK_TVAL_IS_STRING(duk_get_tval(thr, res->x1.valstack_idx)));
 			h_lab = comp_ctx->prev_token.str1;
 			DUK_ASSERT(h_lab != NULL);
 
-			DUK_DDD(DUK_DDDPRINT("explicit label site for label '%!O'",
-			                     (duk_heaphdr *) h_lab));
+			DUK_DDD(DUK_DDDPRINT("explicit label site for label '%!O'", (duk_heaphdr *) h_lab));
 
-			duk__advance(comp_ctx);  /* eat colon */
+			duk__advance(comp_ctx); /* eat colon */
 
 			label_id = duk__stmt_label_site(comp_ctx, label_id);
 
-			duk__add_label(comp_ctx,
-			               h_lab,
-			               pc_at_entry /*pc_label*/,
-			               label_id);
+			duk__add_label(comp_ctx, h_lab, pc_at_entry /*pc_label*/, label_id);
 
 			/* a statement following a label cannot be a source element
 			 * (a function declaration).
 			 */
 			allow_source_elem = 0;
 
 			DUK_DDD(DUK_DDDPRINT("label handled, retry statement parsing"));
 			goto retry_parse;
 		}
 
 		stmt_flags = 0;
 
-		if (dir_prol_at_entry &&                           /* still in prologue */
-		    single_token &&                                /* single string token */
+		if (dir_prol_at_entry && /* still in prologue */
+		    single_token && /* single string token */
 		    comp_ctx->prev_token.t == DUK_TOK_STRING) {
 			/*
 			 *  Detected a directive
 			 */
 			duk_hstring *h_dir;
 
 			/* expected ival */
@@ -74621,37 +75905,40 @@
 				 * strings like "use strict\u0000foo" as required.
 				 */
 
 				if (DUK_HSTRING_GET_BYTELEN(h_dir) == 10 &&
 				    DUK_STRCMP((const char *) DUK_HSTRING_GET_DATA(h_dir), "use strict") == 0) {
 #if defined(DUK_USE_STRICT_DECL)
 					DUK_DDD(DUK_DDDPRINT("use strict directive detected: strict flag %ld -> %ld",
-					                     (long) comp_ctx->curr_func.is_strict, (long) 1));
+					                     (long) comp_ctx->curr_func.is_strict,
+					                     (long) 1));
 					comp_ctx->curr_func.is_strict = 1;
 #else
 					DUK_DDD(DUK_DDDPRINT("use strict detected but strict declarations disabled, ignoring"));
 #endif
 				} else if (DUK_HSTRING_GET_BYTELEN(h_dir) == 14 &&
 				           DUK_STRCMP((const char *) DUK_HSTRING_GET_DATA(h_dir), "use duk notail") == 0) {
 					DUK_DDD(DUK_DDDPRINT("use duk notail directive detected: notail flag %ld -> %ld",
-					                     (long) comp_ctx->curr_func.is_notail, (long) 1));
+					                     (long) comp_ctx->curr_func.is_notail,
+					                     (long) 1));
 					comp_ctx->curr_func.is_notail = 1;
 				} else {
 					DUK_DD(DUK_DDPRINT("unknown directive: '%!O', ignoring but not terminating "
-					                   "directive prologue", (duk_hobject *) h_dir));
+					                   "directive prologue",
+					                   (duk_hobject *) h_dir));
 				}
 			}
 		} else {
 			DUK_DDD(DUK_DDDPRINT("non-directive expression statement or no longer in prologue; "
 			                     "prologue terminated if still active"));
-                }
+		}
 
 		stmt_flags |= DUK__HAS_VAL | DUK__HAS_TERM;
 	}
-	}  /* end switch (tok) */
+	} /* end switch (tok) */
 
 	/*
 	 *  Statement value handling.
 	 *
 	 *  Global code and eval code has an implicit return value
 	 *  which comes from the last statement with a value
 	 *  (technically a non-"empty" continuation, which is
@@ -74719,17 +76006,15 @@
 	 *  Cleanups (all statement parsing flows through here).
 	 *
 	 *  Pop label site and reset labels.  Reset 'next temp' to value at
 	 *  entry to reuse temps.
 	 */
 
 	if (label_id >= 0) {
-		duk__emit_bc(comp_ctx,
-		             DUK_OP_ENDLABEL,
-		             (duk_regconst_t) label_id);
+		duk__emit_bc(comp_ctx, DUK_OP_ENDLABEL, (duk_regconst_t) label_id);
 	}
 
 	DUK__SETTEMP(comp_ctx, temp_at_entry);
 
 	duk__reset_labels_to_length(comp_ctx, labels_len_at_entry);
 
 	/* XXX: return indication of "terminalness" (e.g. a 'throw' is terminal) */
@@ -74744,15 +76029,18 @@
  *
  *  Upon entry, 'curr_tok' should contain the first token of the first
  *  statement (parsed in the "allow regexp literal" mode).  Upon exit,
  *  'curr_tok' contains the token following the statement list terminator
  *  (EOF or closing brace).
  */
 
-DUK_LOCAL void duk__parse_stmts(duk_compiler_ctx *comp_ctx, duk_bool_t allow_source_elem, duk_bool_t expect_eof, duk_bool_t regexp_after) {
+DUK_LOCAL void duk__parse_stmts(duk_compiler_ctx *comp_ctx,
+                                duk_bool_t allow_source_elem,
+                                duk_bool_t expect_eof,
+                                duk_bool_t regexp_after) {
 	duk_hthread *thr = comp_ctx->thr;
 	duk_ivalue res_alloc;
 	duk_ivalue *res = &res_alloc;
 
 	/* Setup state.  Initial ivalue is 'undefined'. */
 
 	duk_require_stack(thr, DUK__PARSE_STATEMENTS_SLOTS);
@@ -74910,15 +76198,15 @@
 
 		/* overwrite any previous binding of the same name; the effect is
 		 * that last argument of a certain name wins.
 		 */
 
 		/* only functions can have arguments */
 		DUK_ASSERT(comp_ctx->curr_func.is_function);
-		duk_push_uarridx(thr, i);  /* -> [ ... name index ] */
+		duk_push_uarridx(thr, i); /* -> [ ... name index ] */
 		duk_put_prop(thr, comp_ctx->curr_func.varmap_idx); /* -> [ ... ] */
 
 		/* no code needs to be emitted, the regs already have values */
 	}
 
 	/* use temp_next for tracking register allocations */
 	DUK__SETTEMP_CHECKMAX(comp_ctx, (duk_regconst_t) num_args);
@@ -74946,53 +76234,46 @@
 	}
 
 	/*
 	 *  Function declarations
 	 */
 
 	num_decls = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
-	DUK_DDD(DUK_DDDPRINT("num_decls=%ld -> %!T",
-	                     (long) num_decls,
-	                     (duk_tval *) duk_get_tval(thr, comp_ctx->curr_func.decls_idx)));
+	DUK_DDD(
+	    DUK_DDDPRINT("num_decls=%ld -> %!T", (long) num_decls, (duk_tval *) duk_get_tval(thr, comp_ctx->curr_func.decls_idx)));
 	for (i = 0; i < num_decls; i += 2) {
 		duk_int_t decl_type;
 		duk_int_t fnum;
 
-		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);  /* decl type */
+		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1); /* decl type */
 		decl_type = duk_to_int(thr, -1);
-		fnum = decl_type >> 8;  /* XXX: macros */
+		fnum = decl_type >> 8; /* XXX: macros */
 		decl_type = decl_type & 0xff;
 		duk_pop(thr);
 
 		if (decl_type != DUK_DECL_TYPE_FUNC) {
 			continue;
 		}
 
-		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);  /* decl name */
+		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i); /* decl name */
 
 		/* XXX: spilling */
 		if (comp_ctx->curr_func.is_function) {
 			duk_regconst_t reg_bind;
 			duk_dup_top(thr);
 			if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {
 				/* shadowed; update value */
 				duk_dup_top(thr);
 				duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
-				reg_bind = duk_to_int(thr, -1);  /* [ ... name reg_bind ] */
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_CLOSURE,
-				               reg_bind,
-				               (duk_regconst_t) fnum);
+				reg_bind = duk_to_int(thr, -1); /* [ ... name reg_bind ] */
+				duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, reg_bind, (duk_regconst_t) fnum);
 			} else {
 				/* function: always register bound */
 				reg_bind = DUK__ALLOCTEMP(comp_ctx);
-				duk__emit_a_bc(comp_ctx,
-				               DUK_OP_CLOSURE,
-				               reg_bind,
-				               (duk_regconst_t) fnum);
+				duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, reg_bind, (duk_regconst_t) fnum);
 				duk_push_int(thr, (duk_int_t) reg_bind);
 			}
 		} else {
 			/* Function declaration for global/eval code is emitted even
 			 * for duplicates, because of E5 Section 10.5, step 5.e of
 			 * E5.1 (special behavior for variable bound to global object).
 			 *
@@ -75001,44 +76282,39 @@
 			 */
 
 			duk_regconst_t reg_temp = DUK__ALLOCTEMP(comp_ctx);
 			duk_dup_top(thr);
 			rc_name = duk__getconst(comp_ctx);
 			duk_push_null(thr);
 
-			duk__emit_a_bc(comp_ctx,
-			               DUK_OP_CLOSURE,
-			               reg_temp,
-			               (duk_regconst_t) fnum);
-
-			declvar_flags = DUK_PROPDESC_FLAG_WRITABLE |
-			                DUK_PROPDESC_FLAG_ENUMERABLE |
-			                DUK_BC_DECLVAR_FLAG_FUNC_DECL;
+			duk__emit_a_bc(comp_ctx, DUK_OP_CLOSURE, reg_temp, (duk_regconst_t) fnum);
+
+			declvar_flags = DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE | DUK_BC_DECLVAR_FLAG_FUNC_DECL;
 
 			if (configurable_bindings) {
 				declvar_flags |= DUK_PROPDESC_FLAG_CONFIGURABLE;
 			}
 
 			duk__emit_a_b_c(comp_ctx,
 			                DUK_OP_DECLVAR | DUK__EMIT_FLAG_NO_SHUFFLE_A | DUK__EMIT_FLAG_BC_REGCONST,
 			                (duk_regconst_t) declvar_flags /*flags*/,
 			                rc_name /*name*/,
 			                reg_temp /*value*/);
 
-			DUK__SETTEMP(comp_ctx, reg_temp);  /* forget temp */
+			DUK__SETTEMP(comp_ctx, reg_temp); /* forget temp */
 		}
 
 		DUK_DDD(DUK_DDDPRINT("function declaration to varmap: %!T -> %!T",
 		                     (duk_tval *) duk_get_tval(thr, -2),
 		                     (duk_tval *) duk_get_tval(thr, -1)));
 
 #if defined(DUK_USE_FASTINT)
 		DUK_ASSERT(DUK_TVAL_IS_NULL(duk_get_tval(thr, -1)) || DUK_TVAL_IS_FASTINT(duk_get_tval(thr, -1)));
 #endif
-		duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);  /* [ ... name reg/null ] -> [ ... ] */
+		duk_put_prop(thr, comp_ctx->curr_func.varmap_idx); /* [ ... name reg/null ] -> [ ... ] */
 	}
 
 	/*
 	 *  'arguments' binding is special; if a shadowing argument or
 	 *  function declaration exists, an arguments object will
 	 *  definitely not be needed, regardless of whether the identifier
 	 *  'arguments' is referenced inside the function body.
@@ -75057,33 +76333,32 @@
 	 *  assigned on entry.  If a binding of the same name already exists, just
 	 *  ignore it silently.
 	 */
 
 	for (i = 0; i < num_decls; i += 2) {
 		duk_int_t decl_type;
 
-		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);  /* decl type */
+		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1); /* decl type */
 		decl_type = duk_to_int(thr, -1);
 		decl_type = decl_type & 0xff;
 		duk_pop(thr);
 
 		if (decl_type != DUK_DECL_TYPE_VAR) {
 			continue;
 		}
 
-		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);  /* decl name */
+		duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i); /* decl name */
 
 		if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {
 			/* shadowed, ignore */
 		} else {
-			duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);  /* decl name */
+			duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i); /* decl name */
 			h_name = duk_known_hstring(thr, -1);
 
-			if (h_name == DUK_HTHREAD_STRING_LC_ARGUMENTS(thr) &&
-			    !comp_ctx->curr_func.is_arguments_shadowed) {
+			if (h_name == DUK_HTHREAD_STRING_LC_ARGUMENTS(thr) && !comp_ctx->curr_func.is_arguments_shadowed) {
 				/* E5 Section steps 7-8 */
 				DUK_DDD(DUK_DDDPRINT("'arguments' not shadowed by a function declaration, "
 				                     "but appears as a variable declaration -> treat as "
 				                     "a no-op for variable declaration purposes"));
 				duk_pop(thr);
 				continue;
 			}
@@ -75094,47 +76369,46 @@
 				/* no need to init reg, it will be undefined on entry */
 				duk_push_int(thr, (duk_int_t) reg_bind);
 			} else {
 				duk_dup_top(thr);
 				rc_name = duk__getconst(comp_ctx);
 				duk_push_null(thr);
 
-				declvar_flags = DUK_PROPDESC_FLAG_WRITABLE |
-			                        DUK_PROPDESC_FLAG_ENUMERABLE;
+				declvar_flags = DUK_PROPDESC_FLAG_WRITABLE | DUK_PROPDESC_FLAG_ENUMERABLE;
 				if (configurable_bindings) {
 					declvar_flags |= DUK_PROPDESC_FLAG_CONFIGURABLE;
 				}
 
 				duk__emit_a_b_c(comp_ctx,
 				                DUK_OP_DECLVAR | DUK__EMIT_FLAG_NO_SHUFFLE_A | DUK__EMIT_FLAG_BC_REGCONST,
 				                (duk_regconst_t) declvar_flags /*flags*/,
 				                rc_name /*name*/,
 				                0 /*value*/);
 			}
 
-			duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);  /* [ ... name reg/null ] -> [ ... ] */
+			duk_put_prop(thr, comp_ctx->curr_func.varmap_idx); /* [ ... name reg/null ] -> [ ... ] */
 		}
 	}
 
 	/*
 	 *  Wrap up
 	 */
 
 	DUK_DDD(DUK_DDDPRINT("varmap: %!T, is_arguments_shadowed=%ld",
 	                     (duk_tval *) duk_get_tval(thr, comp_ctx->curr_func.varmap_idx),
 	                     (long) comp_ctx->curr_func.is_arguments_shadowed));
 
 	DUK_ASSERT_TOP(thr, entry_top);
 	return;
 
- error_outofregs:
+error_outofregs:
 	DUK_ERROR_RANGE(thr, DUK_STR_REG_LIMIT);
 	DUK_WO_NORETURN(return;);
 
- error_argname:
+error_argname:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_ARG_NAME);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Parse a function-body-like expression (FunctionBody or Program
  *  in E5 grammar) using a two-pass parse.  The productions appear
@@ -75165,15 +76439,19 @@
  *      an EOF, other bodies in a closing brace ('}')
  *
  *  Upon entry, 'curr_tok' is ignored and the function will pull in the
  *  first token on its own.  Upon exit, 'curr_tok' is the terminating
  *  token (EOF or closing brace).
  */
 
-DUK_LOCAL void duk__parse_func_body(duk_compiler_ctx *comp_ctx, duk_bool_t expect_eof, duk_bool_t implicit_return_value, duk_bool_t regexp_after, duk_small_int_t expect_token) {
+DUK_LOCAL void duk__parse_func_body(duk_compiler_ctx *comp_ctx,
+                                    duk_bool_t expect_eof,
+                                    duk_bool_t implicit_return_value,
+                                    duk_bool_t regexp_after,
+                                    duk_small_int_t expect_token) {
 	duk_compiler_func *func;
 	duk_hthread *thr;
 	duk_regconst_t reg_stmt_value = -1;
 	duk_lexer_point lex_pt;
 	duk_regconst_t temp_first;
 	duk_small_int_t compile_round = 1;
 
@@ -75257,16 +76535,16 @@
 		 */
 		comp_ctx->curr_token.t = 0;
 		duk__advance(comp_ctx);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("begin 1st pass"));
 	duk__parse_stmts(comp_ctx,
-	                 1,             /* allow source elements */
-	                 expect_eof,    /* expect EOF instead of } */
+	                 1, /* allow source elements */
+	                 expect_eof, /* expect EOF instead of } */
 	                 regexp_after); /* regexp after */
 	DUK_DDD(DUK_DDDPRINT("end 1st pass"));
 
 	/*
 	 *  Second (and possibly third) pass.
 	 *
 	 *  Generate actual code.  In most cases the need for shuffle
@@ -75287,16 +76565,16 @@
 		 *
 		 *  curr_token line number info should be initialized for pass 2 before
 		 *  generating prologue, to ensure prologue bytecode gets nice line numbers.
 		 */
 
 		DUK_DDD(DUK_DDDPRINT("rewind lexer"));
 		DUK_LEXER_SETPOINT(&comp_ctx->lex, &lex_pt);
-		comp_ctx->curr_token.t = 0;  /* this is needed for regexp mode */
-		comp_ctx->curr_token.start_line = 0;  /* needed for line number tracking (becomes prev_token.start_line) */
+		comp_ctx->curr_token.t = 0; /* this is needed for regexp mode */
+		comp_ctx->curr_token.start_line = 0; /* needed for line number tracking (becomes prev_token.start_line) */
 		duk__advance(comp_ctx);
 
 		/*
 		 *  Reset function state and perform register allocation, which creates
 		 *  'varmap' for second pass.  Function prologue for variable declarations,
 		 *  binding value initializations etc is emitted as a by-product.
 		 *
@@ -75309,16 +76587,15 @@
 
 		duk__reset_func_for_pass2(comp_ctx);
 		func->in_directive_prologue = 1;
 		func->in_scanning = 0;
 
 		/* must be able to emit code, alloc consts, etc. */
 
-		duk__init_varmap_and_prologue_for_pass2(comp_ctx,
-		                                        (implicit_return_value ? &reg_stmt_value : NULL));
+		duk__init_varmap_and_prologue_for_pass2(comp_ctx, (implicit_return_value ? &reg_stmt_value : NULL));
 		func->reg_stmt_value = reg_stmt_value;
 
 		temp_first = DUK__GETTEMP(comp_ctx);
 
 		func->temp_first = temp_first;
 		func->temp_next = temp_first;
 		func->stmt_next = 0;
@@ -75358,23 +76635,21 @@
 
 		/*
 		 *  Second pass parsing.
 		 */
 
 		if (implicit_return_value) {
 			/* Default implicit return value. */
-			duk__emit_bc(comp_ctx,
-			             DUK_OP_LDUNDEF,
-			             0);
+			duk__emit_bc(comp_ctx, DUK_OP_LDUNDEF, 0);
 		}
 
 		DUK_DDD(DUK_DDDPRINT("begin 2nd pass"));
 		duk__parse_stmts(comp_ctx,
-		                 1,             /* allow source elements */
-		                 expect_eof,    /* expect EOF instead of } */
+		                 1, /* allow source elements */
+		                 expect_eof, /* expect EOF instead of } */
 		                 regexp_after); /* regexp after */
 		DUK_DDD(DUK_DDDPRINT("end 2nd pass"));
 
 		duk__update_lineinfo_currtoken(comp_ctx);
 
 		if (needs_shuffle_before == comp_ctx->curr_func.needs_shuffle) {
 			/* Shuffle decision not changed. */
@@ -75422,15 +76697,15 @@
 	 *  comp_ctx->curr_func is now ready to be converted into an actual
 	 *  function template.
 	 */
 
 	DUK__RECURSION_DECREASE(comp_ctx, thr);
 	return;
 
- error_funcname:
+error_funcname:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_FUNC_NAME);
 	DUK_WO_NORETURN(return;);
 }
 
 /*
  *  Parse a function-like expression:
  *
@@ -75477,23 +76752,22 @@
 
 		if (comp_ctx->curr_token.t != DUK_TOK_IDENTIFIER) {
 			DUK_ERROR_SYNTAX(thr, DUK_STR_EXPECTED_IDENTIFIER);
 			DUK_WO_NORETURN(return;);
 		}
 		DUK_ASSERT(comp_ctx->curr_token.t == DUK_TOK_IDENTIFIER);
 		DUK_ASSERT(comp_ctx->curr_token.str1 != NULL);
-		DUK_DDD(DUK_DDDPRINT("formal argument: %!O",
-		                     (duk_heaphdr *) comp_ctx->curr_token.str1));
+		DUK_DDD(DUK_DDDPRINT("formal argument: %!O", (duk_heaphdr *) comp_ctx->curr_token.str1));
 
 		/* XXX: append primitive */
 		duk_push_hstring(thr, comp_ctx->curr_token.str1);
 		n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.argnames_idx);
 		duk_put_prop_index(thr, comp_ctx->curr_func.argnames_idx, n);
 
-		duk__advance(comp_ctx);  /* eat identifier */
+		duk__advance(comp_ctx); /* eat identifier */
 	}
 }
 
 /* Parse a function-like expression, assuming that 'comp_ctx->curr_func' is
  * correctly set up.  Assumes that curr_token is just after 'function' (or
  * 'set'/'get' etc).
  */
@@ -75533,45 +76807,44 @@
 	} else {
 		tok = &comp_ctx->curr_token;
 	}
 
 	if (flags & DUK__FUNC_FLAG_GETSET) {
 		/* PropertyName -> IdentifierName | StringLiteral | NumericLiteral */
 		if (tok->t_nores == DUK_TOK_IDENTIFIER || tok->t == DUK_TOK_STRING) {
-			duk_push_hstring(thr, tok->str1);       /* keep in valstack */
+			duk_push_hstring(thr, tok->str1); /* keep in valstack */
 		} else if (tok->t == DUK_TOK_NUMBER) {
 			duk_push_number(thr, tok->num);
 			duk_to_string(thr, -1);
 		} else {
 			DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_GETSET_NAME);
 			DUK_WO_NORETURN(return;);
 		}
-		comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);  /* borrowed reference */
+		comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1); /* borrowed reference */
 	} else {
 		/* Function name is an Identifier (not IdentifierName), but we get
 		 * the raw name (not recognizing keywords) here and perform the name
 		 * checks only after pass 1.
 		 */
 		if (tok->t_nores == DUK_TOK_IDENTIFIER) {
-			duk_push_hstring(thr, tok->str1);       /* keep in valstack */
-			comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);  /* borrowed reference */
+			duk_push_hstring(thr, tok->str1); /* keep in valstack */
+			comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1); /* borrowed reference */
 		} else {
 			/* valstack will be unbalanced, which is OK */
 			DUK_ASSERT((flags & DUK__FUNC_FLAG_GETSET) == 0);
 			DUK_ASSERT(comp_ctx->curr_func.h_name == NULL);
 			no_advance = 1;
 			if (flags & DUK__FUNC_FLAG_DECL) {
 				DUK_ERROR_SYNTAX(thr, DUK_STR_FUNC_NAME_REQUIRED);
 				DUK_WO_NORETURN(return;);
 			}
 		}
 	}
 
-	DUK_DD(DUK_DDPRINT("function name: %!O",
-	                   (duk_heaphdr *) comp_ctx->curr_func.h_name));
+	DUK_DD(DUK_DDPRINT("function name: %!O", (duk_heaphdr *) comp_ctx->curr_func.h_name));
 
 	if (!no_advance) {
 		duk__advance(comp_ctx);
 	}
 
 	/*
 	 *  Formal argument list
@@ -75589,25 +76862,25 @@
 	duk__advance(comp_ctx);
 
 	/*
 	 *  Parse function body
 	 */
 
 	duk__parse_func_body(comp_ctx,
-	                     0,   /* expect_eof */
-	                     0,   /* implicit_return_value */
+	                     0, /* expect_eof */
+	                     0, /* implicit_return_value */
 	                     flags & DUK__FUNC_FLAG_DECL, /* regexp_after */
-	                     DUK_TOK_LCURLY);  /* expect_token */
+	                     DUK_TOK_LCURLY); /* expect_token */
 
 	/*
 	 *  Convert duk_compiler_func to a function template and add it
 	 *  to the parent function table.
 	 */
 
-	duk__convert_to_func_template(comp_ctx);  /* -> [ ... func ] */
+	duk__convert_to_func_template(comp_ctx); /* -> [ ... func ] */
 }
 
 /* Parse an inner function, adding the function template to the current function's
  * function table.  Return a function number to be used by the outer function.
  *
  * Avoiding O(depth^2) inner function parsing is handled here.  On the first pass,
  * compile and register the function normally into the 'funcs' array, also recording
@@ -75637,20 +76910,22 @@
 		duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 1));
 		lex_pt.offset = (duk_size_t) duk_to_uint(thr, -1);
 		duk_pop(thr);
 		duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 2));
 		lex_pt.line = duk_to_int(thr, -1);
 		duk_pop(thr);
 
-		DUK_DDD(DUK_DDDPRINT("second pass of an inner func, skip the function, reparse closing brace; lex offset=%ld, line=%ld",
-		                     (long) lex_pt.offset, (long) lex_pt.line));
+		DUK_DDD(
+		    DUK_DDDPRINT("second pass of an inner func, skip the function, reparse closing brace; lex offset=%ld, line=%ld",
+		                 (long) lex_pt.offset,
+		                 (long) lex_pt.line));
 
 		DUK_LEXER_SETPOINT(&comp_ctx->lex, &lex_pt);
-		comp_ctx->curr_token.t = 0;  /* this is needed for regexp mode */
-		comp_ctx->curr_token.start_line = 0;  /* needed for line number tracking (becomes prev_token.start_line) */
+		comp_ctx->curr_token.t = 0; /* this is needed for regexp mode */
+		comp_ctx->curr_token.start_line = 0; /* needed for line number tracking (becomes prev_token.start_line) */
 		duk__advance(comp_ctx);
 
 		/* RegExp is not allowed after a function expression, e.g. in
 		 * (function () {} / 123).  A RegExp *is* allowed after a
 		 * function declaration!
 		 */
 		if (flags & DUK__FUNC_FLAG_DECL) {
@@ -75664,15 +76939,16 @@
 	/*
 	 *  On first pass, perform actual parsing.  Remember valstack top on entry
 	 *  to restore it later, and switch to using a new function in comp_ctx.
 	 */
 
 	entry_top = duk_get_top(thr);
 	DUK_DDD(DUK_DDDPRINT("before func: entry_top=%ld, curr_tok.start_offset=%ld",
-	                     (long) entry_top, (long) comp_ctx->curr_token.start_offset));
+	                     (long) entry_top,
+	                     (long) comp_ctx->curr_token.start_offset));
 
 	duk_memcpy(&old_func, &comp_ctx->curr_func, sizeof(duk_compiler_func));
 
 	duk_memzero(&comp_ctx->curr_func, sizeof(duk_compiler_func));
 	duk__init_func_valstack_slots(comp_ctx);
 	DUK_ASSERT(comp_ctx->curr_func.num_formals == 0);
 
@@ -75684,32 +76960,33 @@
 	 * here.
 	 */
 	DUK_ASSERT(comp_ctx->curr_func.is_notail == 0);
 	comp_ctx->curr_func.is_function = 1;
 	DUK_ASSERT(comp_ctx->curr_func.is_eval == 0);
 	DUK_ASSERT(comp_ctx->curr_func.is_global == 0);
 	comp_ctx->curr_func.is_setget = ((flags & DUK__FUNC_FLAG_GETSET) != 0);
-	comp_ctx->curr_func.is_namebinding = !(flags & (DUK__FUNC_FLAG_GETSET |
-	                                                DUK__FUNC_FLAG_METDEF |
-	                                                DUK__FUNC_FLAG_DECL));  /* no name binding for: declarations, objlit getset, objlit method def */
-	comp_ctx->curr_func.is_constructable = !(flags & (DUK__FUNC_FLAG_GETSET |
-	                                                  DUK__FUNC_FLAG_METDEF));  /* not constructable: objlit getset, objlit method def */
+	comp_ctx->curr_func.is_namebinding =
+	    !(flags & (DUK__FUNC_FLAG_GETSET | DUK__FUNC_FLAG_METDEF |
+	               DUK__FUNC_FLAG_DECL)); /* no name binding for: declarations, objlit getset, objlit method def */
+	comp_ctx->curr_func.is_constructable =
+	    !(flags & (DUK__FUNC_FLAG_GETSET | DUK__FUNC_FLAG_METDEF)); /* not constructable: objlit getset, objlit method def */
 
 	/*
 	 *  Parse inner function
 	 */
 
-	duk__parse_func_like_raw(comp_ctx, flags);  /* pushes function template */
+	duk__parse_func_like_raw(comp_ctx, flags); /* pushes function template */
 
 	/* prev_token.start_offset points to the closing brace here; when skipping
 	 * we're going to reparse the closing brace to ensure semicolon insertion
 	 * etc work as expected.
 	 */
 	DUK_DDD(DUK_DDDPRINT("after func: prev_tok.start_offset=%ld, curr_tok.start_offset=%ld",
-	                     (long) comp_ctx->prev_token.start_offset, (long) comp_ctx->curr_token.start_offset));
+	                     (long) comp_ctx->prev_token.start_offset,
+	                     (long) comp_ctx->curr_token.start_offset));
 	DUK_ASSERT(comp_ctx->lex.input[comp_ctx->prev_token.start_offset] == (duk_uint8_t) DUK_ASC_RCURLY);
 
 	/* XXX: append primitive */
 	DUK_ASSERT(duk_get_length(thr, old_func.funcs_idx) == (duk_size_t) (old_func.fnum_next * 3));
 	fnum = old_func.fnum_next++;
 
 	if (fnum > DUK__MAX_FUNCS) {
@@ -75787,15 +77064,15 @@
 	DUK_ASSERT(lex_pt != NULL);
 
 	flags = comp_stk->flags;
 	is_eval = (flags & DUK_COMPILE_EVAL ? 1 : 0);
 	is_strict = (flags & DUK_COMPILE_STRICT ? 1 : 0);
 	is_funcexpr = (flags & DUK_COMPILE_FUNCEXPR ? 1 : 0);
 
-	h_filename = duk_get_hstring(thr, -1);  /* may be undefined */
+	h_filename = duk_get_hstring(thr, -1); /* may be undefined */
 
 	/*
 	 *  Init compiler and lexer contexts
 	 */
 
 	func = &comp_ctx->curr_func;
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
@@ -75805,19 +77082,19 @@
 	comp_ctx->prev_token.str2 = NULL;
 	comp_ctx->curr_token.str1 = NULL;
 	comp_ctx->curr_token.str2 = NULL;
 #endif
 
 	duk_require_stack(thr, DUK__COMPILE_ENTRY_SLOTS);
 
-	duk_push_dynamic_buffer(thr, 0);       /* entry_top + 0 */
-	duk_push_undefined(thr);               /* entry_top + 1 */
-	duk_push_undefined(thr);               /* entry_top + 2 */
-	duk_push_undefined(thr);               /* entry_top + 3 */
-	duk_push_undefined(thr);               /* entry_top + 4 */
+	duk_push_dynamic_buffer(thr, 0); /* entry_top + 0 */
+	duk_push_undefined(thr); /* entry_top + 1 */
+	duk_push_undefined(thr); /* entry_top + 2 */
+	duk_push_undefined(thr); /* entry_top + 3 */
+	duk_push_undefined(thr); /* entry_top + 4 */
 
 	comp_ctx->thr = thr;
 	comp_ctx->h_filename = h_filename;
 	comp_ctx->tok11_idx = entry_top + 1;
 	comp_ctx->tok12_idx = entry_top + 2;
 	comp_ctx->tok21_idx = entry_top + 3;
 	comp_ctx->tok22_idx = entry_top + 4;
@@ -75833,16 +77110,16 @@
 	comp_ctx->lex.buf_idx = entry_top + 0;
 	comp_ctx->lex.buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, entry_top + 0);
 	DUK_ASSERT(DUK_HBUFFER_HAS_DYNAMIC(comp_ctx->lex.buf) && !DUK_HBUFFER_HAS_EXTERNAL(comp_ctx->lex.buf));
 	comp_ctx->lex.token_limit = DUK_COMPILER_TOKEN_LIMIT;
 
 	lex_pt->offset = 0;
 	lex_pt->line = 1;
-	DUK_LEXER_SETPOINT(&comp_ctx->lex, lex_pt);    /* fills window */
-	comp_ctx->curr_token.start_line = 0;  /* needed for line number tracking (becomes prev_token.start_line) */
+	DUK_LEXER_SETPOINT(&comp_ctx->lex, lex_pt); /* fills window */
+	comp_ctx->curr_token.start_line = 0; /* needed for line number tracking (becomes prev_token.start_line) */
 
 	/*
 	 *  Initialize function state for a zero-argument function
 	 */
 
 	duk__init_func_valstack_slots(comp_ctx);
 	DUK_ASSERT(func->num_formals == 0);
@@ -75850,16 +77127,15 @@
 	if (is_funcexpr) {
 		/* Name will be filled from function expression, not by caller.
 		 * This case is used by Function constructor and duk_compile()
 		 * API with the DUK_COMPILE_FUNCTION option.
 		 */
 		DUK_ASSERT(func->h_name == NULL);
 	} else {
-		duk_push_hstring_stridx(thr, (is_eval ? DUK_STRIDX_EVAL :
-		                                        DUK_STRIDX_GLOBAL));
+		duk_push_hstring_stridx(thr, (is_eval ? DUK_STRIDX_EVAL : DUK_STRIDX_GLOBAL));
 		func->h_name = duk_get_hstring(thr, -1);
 	}
 
 	/*
 	 *  Parse a function body or a function-like expression, depending
 	 *  on flags.
 	 */
@@ -75871,30 +77147,30 @@
 	if (is_funcexpr) {
 		func->is_function = 1;
 		DUK_ASSERT(func->is_eval == 0);
 		DUK_ASSERT(func->is_global == 0);
 		func->is_namebinding = 1;
 		func->is_constructable = 1;
 
-		duk__advance(comp_ctx);  /* init 'curr_token' */
+		duk__advance(comp_ctx); /* init 'curr_token' */
 		duk__advance_expect(comp_ctx, DUK_TOK_FUNCTION);
 		(void) duk__parse_func_like_raw(comp_ctx, 0 /*flags*/);
 	} else {
 		DUK_ASSERT(func->is_function == 0);
 		DUK_ASSERT(is_eval == 0 || is_eval == 1);
 		func->is_eval = (duk_uint8_t) is_eval;
 		func->is_global = (duk_uint8_t) !is_eval;
 		DUK_ASSERT(func->is_namebinding == 0);
 		DUK_ASSERT(func->is_constructable == 0);
 
 		duk__parse_func_body(comp_ctx,
-		                     1,             /* expect_eof */
-		                     1,             /* implicit_return_value */
-		                     1,             /* regexp_after (does not matter) */
-		                     -1);           /* expect_token */
+		                     1, /* expect_eof */
+		                     1, /* implicit_return_value */
+		                     1, /* regexp_after (does not matter) */
+		                     -1); /* expect_token */
 	}
 
 	/*
 	 *  Convert duk_compiler_func to a function template
 	 */
 
 	duk__convert_to_func_template(comp_ctx);
@@ -75918,22 +77194,22 @@
 
 	/* preinitialize lexer state partially */
 	duk_memzero(&comp_stk, sizeof(comp_stk));
 	comp_stk.flags = flags;
 	DUK_LEXER_INITCTX(&comp_stk.comp_ctx_alloc.lex);
 	comp_stk.comp_ctx_alloc.lex.input = src_buffer;
 	comp_stk.comp_ctx_alloc.lex.input_length = src_length;
-	comp_stk.comp_ctx_alloc.lex.flags = flags;  /* Forward flags directly for now. */
+	comp_stk.comp_ctx_alloc.lex.flags = flags; /* Forward flags directly for now. */
 
 	/* [ ... filename ] */
 
 	prev_ctx = thr->compile_ctx;
-	thr->compile_ctx = &comp_stk.comp_ctx_alloc;  /* for duk_error_augment.c */
+	thr->compile_ctx = &comp_stk.comp_ctx_alloc; /* for duk_error_augment.c */
 	safe_rc = duk_safe_call(thr, duk__js_compile_raw, (void *) &comp_stk /*udata*/, 1 /*nargs*/, 1 /*nrets*/);
-	thr->compile_ctx = prev_ctx;  /* must restore reliably before returning */
+	thr->compile_ctx = prev_ctx; /* must restore reliably before returning */
 
 	if (safe_rc != DUK_EXEC_SUCCESS) {
 		DUK_D(DUK_DPRINT("compilation failed: %!T", duk_get_tval(thr, -1)));
 		(void) duk_throw(thr);
 		DUK_WO_NORETURN(return;);
 	}
 
@@ -76040,31 +77316,32 @@
 /*
  *  Misc helpers.
  */
 
 /* Replace value stack top to value at 'tv_ptr'.  Optimize for
  * performance by only applying the net refcount change.
  */
-#define DUK__REPLACE_TO_TVPTR(thr,tv_ptr) do { \
+#define DUK__REPLACE_TO_TVPTR(thr, tv_ptr) \
+	do { \
 		duk_hthread *duk__thr; \
 		duk_tval *duk__tvsrc; \
 		duk_tval *duk__tvdst; \
 		duk_tval duk__tvtmp; \
 		duk__thr = (thr); \
 		duk__tvsrc = DUK_GET_TVAL_NEGIDX(duk__thr, -1); \
 		duk__tvdst = (tv_ptr); \
 		DUK_TVAL_SET_TVAL(&duk__tvtmp, duk__tvdst); \
 		DUK_TVAL_SET_TVAL(duk__tvdst, duk__tvsrc); \
-		DUK_TVAL_SET_UNDEFINED(duk__tvsrc);  /* value stack init policy */ \
+		DUK_TVAL_SET_UNDEFINED(duk__tvsrc); /* value stack init policy */ \
 		duk__thr->valstack_top = duk__tvsrc; \
 		DUK_TVAL_DECREF(duk__thr, &duk__tvtmp); \
 	} while (0)
 
 /* XXX: candidate of being an internal shared API call */
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL void duk__push_tvals_incref_only(duk_hthread *thr, duk_tval *tv_src, duk_small_uint_fast_t count) {
 	duk_tval *tv_dst;
 	duk_size_t copy_size;
 	duk_size_t i;
 
 	tv_dst = thr->valstack_top;
 	copy_size = sizeof(duk_tval) * count;
@@ -76098,15 +77375,18 @@
 
 #if defined(DUK_USE_ES7_EXP_OPERATOR)
 DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF duk_double_t duk__compute_exp(duk_double_t d1, duk_double_t d2) {
 	return (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
 }
 #endif
 
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_add(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_fast_t idx_z) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_add(duk_hthread *thr,
+                                                             duk_tval *tv_x,
+                                                             duk_tval *tv_y,
+                                                             duk_small_uint_fast_t idx_z) {
 	/*
 	 *  Addition operator is different from other arithmetic
 	 *  operations in that it also provides string concatenation.
 	 *  Hence it is implemented separately.
 	 *
 	 *  There is a fast path for number addition.  Other cases go
 	 *  through potentially multiple coercions as described in the
@@ -76118,17 +77398,17 @@
 	 *
 	 *  Custom types also have special behavior implemented here.
 	 */
 
 	duk_double_union du;
 
 	DUK_ASSERT(thr != NULL);
-	DUK_ASSERT(tv_x != NULL);  /* may be reg or const */
-	DUK_ASSERT(tv_y != NULL);  /* may be reg or const */
-	DUK_ASSERT_DISABLE(idx_z >= 0);  /* unsigned */
+	DUK_ASSERT(tv_x != NULL); /* may be reg or const */
+	DUK_ASSERT(tv_y != NULL); /* may be reg or const */
+	DUK_ASSERT_DISABLE(idx_z >= 0); /* unsigned */
 	DUK_ASSERT((duk_uint_t) idx_z < (duk_uint_t) duk_get_top(thr));
 
 	/*
 	 *  Fast paths
 	 */
 
 #if defined(DUK_USE_FASTINT)
@@ -76143,77 +77423,81 @@
 
 		v1 = DUK_TVAL_GET_FASTINT(tv_x);
 		v2 = DUK_TVAL_GET_FASTINT(tv_y);
 		v3 = v1 + v2;
 		v3_hi = (duk_int32_t) (v3 >> 32);
 		if (DUK_LIKELY(v3_hi >= DUK_I64_CONSTANT(-0x8000) && v3_hi <= DUK_I64_CONSTANT(0x7fff))) {
 			tv_z = thr->valstack_bottom + idx_z;
-			DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, v3);  /* side effects */
+			DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, v3); /* side effects */
 			return;
 		} else {
 			/* overflow, fall through */
 			;
 		}
 	}
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
 	if (DUK_TVAL_IS_NUMBER(tv_x) && DUK_TVAL_IS_NUMBER(tv_y)) {
 #if !defined(DUK_USE_EXEC_PREFER_SIZE)
 		duk_tval *tv_z;
 #endif
 
 		du.d = DUK_TVAL_GET_NUMBER(tv_x) + DUK_TVAL_GET_NUMBER(tv_y);
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-		duk_push_number(thr, du.d);  /* will NaN normalize result */
+		duk_push_number(thr, du.d); /* will NaN normalize result */
 		duk_replace(thr, (duk_idx_t) idx_z);
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		DUK_DBLUNION_NORMALIZE_NAN_CHECK(&du);
 		DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&du));
 		tv_z = thr->valstack_bottom + idx_z;
-		DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, du.d);  /* side effects */
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+		DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, du.d); /* side effects */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 		return;
 	}
 
 	/*
 	 *  Slow path: potentially requires function calls for coercion
 	 */
 
 	duk_push_tval(thr, tv_x);
 	duk_push_tval(thr, tv_y);
-	duk_to_primitive(thr, -2, DUK_HINT_NONE);  /* side effects -> don't use tv_x, tv_y after */
+	duk_to_primitive(thr, -2, DUK_HINT_NONE); /* side effects -> don't use tv_x, tv_y after */
 	duk_to_primitive(thr, -1, DUK_HINT_NONE);
 
 	/* Since Duktape 2.x plain buffers are treated like ArrayBuffer. */
 	if (duk_is_string(thr, -2) || duk_is_string(thr, -1)) {
 		/* Symbols shouldn't technically be handled here, but should
 		 * go into the default ToNumber() coercion path instead and
 		 * fail there with a TypeError.  However, there's a ToString()
 		 * in duk_concat_2() which also fails with TypeError so no
 		 * explicit check is needed.
 		 */
-		duk_concat_2(thr);  /* [... s1 s2] -> [... s1+s2] */
+		duk_concat_2(thr); /* [... s1 s2] -> [... s1+s2] */
 	} else {
 		duk_double_t d1, d2;
 
 		d1 = duk_to_number_m2(thr);
 		d2 = duk_to_number_m1(thr);
 		DUK_ASSERT(duk_is_number(thr, -2));
 		DUK_ASSERT(duk_is_number(thr, -1));
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(d1);
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(d2);
 
 		du.d = d1 + d2;
 		duk_pop_2_unsafe(thr);
-		duk_push_number(thr, du.d);  /* will NaN normalize result */
+		duk_push_number(thr, du.d); /* will NaN normalize result */
 	}
-	duk_replace(thr, (duk_idx_t) idx_z);  /* side effects */
+	duk_replace(thr, (duk_idx_t) idx_z); /* side effects */
 }
 
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_binary_op(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_uint_fast_t idx_z, duk_small_uint_fast_t opcode) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_binary_op(duk_hthread *thr,
+                                                                   duk_tval *tv_x,
+                                                                   duk_tval *tv_y,
+                                                                   duk_uint_fast_t idx_z,
+                                                                   duk_small_uint_fast_t opcode) {
 	/*
 	 *  Arithmetic operations other than '+' have number-only semantics
 	 *  and are implemented here.  The separate switch-case here means a
 	 *  "double dispatch" of the arithmetic opcode, but saves code space.
 	 *
 	 *  E5 Sections 11.5, 11.5.1, 11.5.2, 11.5.3, 11.6, 11.6.1, 11.6.2, 11.6.3.
 	 */
@@ -76222,20 +77506,20 @@
 	duk_double_union du;
 	duk_small_uint_fast_t opcode_shifted;
 #if defined(DUK_USE_FASTINT) || !defined(DUK_USE_EXEC_PREFER_SIZE)
 	duk_tval *tv_z;
 #endif
 
 	DUK_ASSERT(thr != NULL);
-	DUK_ASSERT(tv_x != NULL);  /* may be reg or const */
-	DUK_ASSERT(tv_y != NULL);  /* may be reg or const */
-	DUK_ASSERT_DISABLE(idx_z >= 0);  /* unsigned */
+	DUK_ASSERT(tv_x != NULL); /* may be reg or const */
+	DUK_ASSERT(tv_y != NULL); /* may be reg or const */
+	DUK_ASSERT_DISABLE(idx_z >= 0); /* unsigned */
 	DUK_ASSERT((duk_uint_t) idx_z < (duk_uint_t) duk_get_top(thr));
 
-	opcode_shifted = opcode >> 2;  /* Get base opcode without reg/const modifiers. */
+	opcode_shifted = opcode >> 2; /* Get base opcode without reg/const modifiers. */
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_x) && DUK_TVAL_IS_FASTINT(tv_y)) {
 		duk_int64_t v1, v2, v3;
 		duk_int32_t v3_hi;
 
 		v1 = DUK_TVAL_GET_FASTINT(tv_x);
@@ -76294,30 +77578,30 @@
 			goto skip_fastint;
 		}
 		}
 
 		v3_hi = (duk_int32_t) (v3 >> 32);
 		if (DUK_LIKELY(v3_hi >= DUK_I64_CONSTANT(-0x8000) && v3_hi <= DUK_I64_CONSTANT(0x7fff))) {
 			tv_z = thr->valstack_bottom + idx_z;
-			DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, v3);  /* side effects */
+			DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, v3); /* side effects */
 			return;
 		}
 		/* fall through if overflow etc */
 	}
- skip_fastint:
-#endif  /* DUK_USE_FASTINT */
+skip_fastint:
+#endif /* DUK_USE_FASTINT */
 
 	if (DUK_TVAL_IS_NUMBER(tv_x) && DUK_TVAL_IS_NUMBER(tv_y)) {
 		/* fast path */
 		d1 = DUK_TVAL_GET_NUMBER(tv_x);
 		d2 = DUK_TVAL_GET_NUMBER(tv_y);
 	} else {
 		duk_push_tval(thr, tv_x);
 		duk_push_tval(thr, tv_y);
-		d1 = duk_to_number_m2(thr);  /* side effects */
+		d1 = duk_to_number_m2(thr); /* side effects */
 		d2 = duk_to_number_m1(thr);
 		DUK_ASSERT(duk_is_number(thr, -2));
 		DUK_ASSERT(duk_is_number(thr, -1));
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(d1);
 		DUK_ASSERT_DOUBLE_IS_NORMALIZED(d2);
 		duk_pop_2_unsafe(thr);
 	}
@@ -76346,32 +77630,36 @@
 	case DUK_OP_EXP >> 2: {
 		du.d = duk__compute_exp(d1, d2);
 		break;
 	}
 #endif
 	default: {
 		DUK_UNREACHABLE();
-		du.d = DUK_DOUBLE_NAN;  /* should not happen */
+		du.d = DUK_DOUBLE_NAN; /* should not happen */
 		break;
 	}
 	}
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-	duk_push_number(thr, du.d);  /* will NaN normalize result */
+	duk_push_number(thr, du.d); /* will NaN normalize result */
 	duk_replace(thr, (duk_idx_t) idx_z);
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 	/* important to use normalized NaN with 8-byte tagged types */
 	DUK_DBLUNION_NORMALIZE_NAN_CHECK(&du);
 	DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&du));
 	tv_z = thr->valstack_bottom + idx_z;
-	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, du.d);  /* side effects */
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, du.d); /* side effects */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 }
 
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_bitwise_binary_op(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_fast_t idx_z, duk_small_uint_fast_t opcode) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_bitwise_binary_op(duk_hthread *thr,
+                                                                     duk_tval *tv_x,
+                                                                     duk_tval *tv_y,
+                                                                     duk_small_uint_fast_t idx_z,
+                                                                     duk_small_uint_fast_t opcode) {
 	/*
 	 *  Binary bitwise operations use different coercions (ToInt32, ToUint32)
 	 *  depending on the operation.  We coerce the arguments first using
 	 *  ToInt32(), and then cast to an 32-bit value if necessary.  Note that
 	 *  such casts must be correct even if there is no native 32-bit type
 	 *  (e.g., duk_int32_t and duk_uint32_t are 64-bit).
 	 *
@@ -76387,28 +77675,27 @@
 #endif
 	duk_small_uint_fast_t opcode_shifted;
 #if defined(DUK_USE_FASTINT) || !defined(DUK_USE_EXEC_PREFER_SIZE)
 	duk_tval *tv_z;
 #endif
 
 	DUK_ASSERT(thr != NULL);
-	DUK_ASSERT(tv_x != NULL);  /* may be reg or const */
-	DUK_ASSERT(tv_y != NULL);  /* may be reg or const */
-	DUK_ASSERT_DISABLE(idx_z >= 0);  /* unsigned */
+	DUK_ASSERT(tv_x != NULL); /* may be reg or const */
+	DUK_ASSERT(tv_y != NULL); /* may be reg or const */
+	DUK_ASSERT_DISABLE(idx_z >= 0); /* unsigned */
 	DUK_ASSERT((duk_uint_t) idx_z < (duk_uint_t) duk_get_top(thr));
 
-	opcode_shifted = opcode >> 2;  /* Get base opcode without reg/const modifiers. */
+	opcode_shifted = opcode >> 2; /* Get base opcode without reg/const modifiers. */
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_x) && DUK_TVAL_IS_FASTINT(tv_y)) {
 		i1 = (duk_int32_t) DUK_TVAL_GET_FASTINT_I32(tv_x);
 		i2 = (duk_int32_t) DUK_TVAL_GET_FASTINT_I32(tv_y);
-	}
-	else
-#endif  /* DUK_USE_FASTINT */
+	} else
+#endif /* DUK_USE_FASTINT */
 	{
 		duk_push_tval(thr, tv_x);
 		duk_push_tval(thr, tv_y);
 		i1 = duk_to_int32(thr, -2);
 		i2 = duk_to_int32(thr, -1);
 		duk_pop_2_unsafe(thr);
 	}
@@ -76429,77 +77716,80 @@
 	case DUK_OP_BASL >> 2: {
 		/* Signed shift, named "arithmetic" (asl) because the result
 		 * is signed, e.g. 4294967295 << 1 -> -2.  Note that result
 		 * must be masked.
 		 */
 
 		u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
-		i3 = (duk_int32_t) (((duk_uint32_t) i1) << (u2 & 0x1fUL));  /* E5 Section 11.7.1, steps 7 and 8 */
-		i3 = i3 & ((duk_int32_t) 0xffffffffUL);                     /* Note: left shift, should mask */
+		i3 = (duk_int32_t) (((duk_uint32_t) i1) << (u2 & 0x1fUL)); /* E5 Section 11.7.1, steps 7 and 8 */
+		i3 = i3 & ((duk_int32_t) 0xffffffffUL); /* Note: left shift, should mask */
 		break;
 	}
 	case DUK_OP_BASR >> 2: {
 		/* signed shift */
 
 		u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
-		i3 = i1 >> (u2 & 0x1fUL);                      /* E5 Section 11.7.2, steps 7 and 8 */
+		i3 = i1 >> (u2 & 0x1fUL); /* E5 Section 11.7.2, steps 7 and 8 */
 		break;
 	}
 	case DUK_OP_BLSR >> 2: {
 		/* unsigned shift */
 
 		u1 = ((duk_uint32_t) i1) & 0xffffffffUL;
 		u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
 
 		/* special result value handling */
-		u3 = u1 >> (u2 & 0x1fUL);     /* E5 Section 11.7.2, steps 7 and 8 */
+		u3 = u1 >> (u2 & 0x1fUL); /* E5 Section 11.7.2, steps 7 and 8 */
 #if defined(DUK_USE_FASTINT)
 		fi3 = (duk_int64_t) u3;
 		goto fastint_result_set;
 #else
 		d3 = (duk_double_t) u3;
 		goto result_set;
 #endif
 	}
 	default: {
 		DUK_UNREACHABLE();
-		i3 = 0;  /* should not happen */
+		i3 = 0; /* should not happen */
 		break;
 	}
 	}
 
 #if defined(DUK_USE_FASTINT)
 	/* Result is always fastint compatible. */
 	/* XXX: Set 32-bit result (but must then handle signed and
 	 * unsigned results separately).
 	 */
 	fi3 = (duk_int64_t) i3;
 
- fastint_result_set:
+fastint_result_set:
 	tv_z = thr->valstack_bottom + idx_z;
-	DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, fi3);  /* side effects */
-#else  /* DUK_USE_FASTINT */
+	DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_z, fi3); /* side effects */
+#else /* DUK_USE_FASTINT */
 	d3 = (duk_double_t) i3;
 
- result_set:
-	DUK_ASSERT(!DUK_ISNAN(d3));            /* 'd3' is never NaN, so no need to normalize */
-	DUK_ASSERT_DOUBLE_IS_NORMALIZED(d3);   /* always normalized */
+result_set:
+	DUK_ASSERT(!DUK_ISNAN(d3)); /* 'd3' is never NaN, so no need to normalize */
+	DUK_ASSERT_DOUBLE_IS_NORMALIZED(d3); /* always normalized */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-	duk_push_number(thr, d3);  /* would NaN normalize result, but unnecessary */
+	duk_push_number(thr, d3); /* would NaN normalize result, but unnecessary */
 	duk_replace(thr, (duk_idx_t) idx_z);
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 	tv_z = thr->valstack_bottom + idx_z;
-	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, d3);  /* side effects */
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
-#endif  /* DUK_USE_FASTINT */
+	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_z, d3); /* side effects */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_FASTINT */
 }
 
 /* In-place unary operation. */
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_unary_op(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst, duk_small_uint_fast_t opcode) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_arith_unary_op(duk_hthread *thr,
+                                                                  duk_uint_fast_t idx_src,
+                                                                  duk_uint_fast_t idx_dst,
+                                                                  duk_small_uint_fast_t opcode) {
 	/*
 	 *  Arithmetic operations other than '+' have number-only semantics
 	 *  and are implemented here.  The separate switch-case here means a
 	 *  "double dispatch" of the arithmetic opcode, but saves code space.
 	 *
 	 *  E5 Sections 11.5, 11.5.1, 11.5.2, 11.5.3, 11.6, 11.6.1, 11.6.2, 11.6.3.
 	 */
@@ -76537,37 +77827,37 @@
 			v2 = v1;
 			tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst);
 			DUK_TVAL_SET_FASTINT_UPDREF(thr, tv, v2);
 			return;
 		}
 		/* fall through if overflow etc */
 	}
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
 	if (DUK_TVAL_IS_NUMBER(tv)) {
 		d1 = DUK_TVAL_GET_NUMBER(tv);
 	} else {
-		d1 = duk_to_number_tval(thr, tv);  /* side effects */
+		d1 = duk_to_number_tval(thr, tv); /* side effects */
 	}
 
 	if (opcode == DUK_OP_UNP) {
 		/* ToNumber() for a double is a no-op, but unary plus is
 		 * used to force a fastint check so do that here.
 		 */
 		du.d = d1;
 		DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&du));
 #if defined(DUK_USE_FASTINT)
 		tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst);
-		DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF(thr, tv, du.d);  /* always 'fast', i.e. inlined */
+		DUK_TVAL_SET_NUMBER_CHKFAST_UPDREF(thr, tv, du.d); /* always 'fast', i.e. inlined */
 		return;
 #endif
 	} else {
 		DUK_ASSERT(opcode == DUK_OP_UNM);
 		du.d = -d1;
-		DUK_DBLUNION_NORMALIZE_NAN_CHECK(&du);  /* mandatory if du.d is a NaN */
+		DUK_DBLUNION_NORMALIZE_NAN_CHECK(&du); /* mandatory if du.d is a NaN */
 		DUK_ASSERT(DUK_DBLUNION_IS_NORMALIZED(&du));
 	}
 
 	/* XXX: size optimize: push+replace? */
 	tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst);
 	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv, du.d);
 }
@@ -76587,27 +77877,26 @@
 	DUK_ASSERT((duk_uint_t) idx_dst < (duk_uint_t) duk_get_top(thr));
 
 	tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_src);
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv)) {
 		i1 = (duk_int32_t) DUK_TVAL_GET_FASTINT_I32(tv);
-	}
-	else
-#endif  /* DUK_USE_FASTINT */
+	} else
+#endif /* DUK_USE_FASTINT */
 	{
 		duk_push_tval(thr, tv);
-		i1 = duk_to_int32(thr, -1);  /* side effects */
+		i1 = duk_to_int32(thr, -1); /* side effects */
 		duk_pop_unsafe(thr);
 	}
 
 	/* Result is always fastint compatible. */
 	i2 = ~i1;
 	tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst);
-	DUK_TVAL_SET_I32_UPDREF(thr, tv, i2);  /* side effects */
+	DUK_TVAL_SET_I32_UPDREF(thr, tv, i2); /* side effects */
 }
 
 DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__vm_logical_not(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst) {
 	/*
 	 *  E5 Section 11.4.9
 	 */
 
@@ -76621,24 +77910,27 @@
 	DUK_ASSERT((duk_uint_t) idx_dst < (duk_uint_t) duk_get_top(thr));
 
 	/* ToBoolean() does not require any operations with side effects so
 	 * we can do it efficiently.  For footprint it would be better to use
 	 * duk_js_toboolean() and then push+replace to the result slot.
 	 */
 	tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_src);
-	res = duk_js_toboolean(tv);  /* does not modify 'tv' */
+	res = duk_js_toboolean(tv); /* does not modify 'tv' */
 	DUK_ASSERT(res == 0 || res == 1);
 	res ^= 1;
 	tv = DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst);
 	/* XXX: size optimize: push+replace? */
-	DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv, res);  /* side effects */
+	DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv, res); /* side effects */
 }
 
 /* XXX: size optimized variant */
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__prepost_incdec_reg_helper(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_small_uint_t op) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__prepost_incdec_reg_helper(duk_hthread *thr,
+                                                                          duk_tval *tv_dst,
+                                                                          duk_tval *tv_src,
+                                                                          duk_small_uint_t op) {
 	duk_double_t x, y, z;
 
 	/* Two lowest bits of opcode are used to distinguish
 	 * variants.  Bit 0 = inc(0)/dec(1), bit 1 = pre(0)/post(1).
 	 */
 	DUK_ASSERT((DUK_OP_PREINCR & 0x03) == 0x00);
 	DUK_ASSERT((DUK_OP_PREDECR & 0x03) == 0x01);
@@ -76657,45 +77949,45 @@
 		} else {
 			if (DUK_UNLIKELY(x_fi == DUK_FASTINT_MAX)) {
 				goto skip_fastint;
 			}
 			y_fi = x_fi + 1;
 		}
 
-		DUK_TVAL_SET_FASTINT(tv_src, y_fi);  /* no need for refcount update */
+		DUK_TVAL_SET_FASTINT(tv_src, y_fi); /* no need for refcount update */
 
 		z_fi = (op & 0x02) ? x_fi : y_fi;
-		DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_dst, z_fi);  /* side effects */
+		DUK_TVAL_SET_FASTINT_UPDREF(thr, tv_dst, z_fi); /* side effects */
 		return;
 	}
- skip_fastint:
+skip_fastint:
 #endif
 	if (DUK_TVAL_IS_NUMBER(tv_src)) {
 		/* Fast path for the case where the register
 		 * is a number (e.g. loop counter).
 		 */
 
 		x = DUK_TVAL_GET_NUMBER(tv_src);
 		if (op & 0x01) {
 			y = x - 1.0;
 		} else {
 			y = x + 1.0;
 		}
 
-		DUK_TVAL_SET_NUMBER(tv_src, y);  /* no need for refcount update */
+		DUK_TVAL_SET_NUMBER(tv_src, y); /* no need for refcount update */
 	} else {
 		/* Preserve duk_tval pointer(s) across a potential valstack
 		 * resize by converting them into offsets temporarily.
 		 */
 		duk_idx_t bc;
 		duk_size_t off_dst;
 
 		off_dst = (duk_size_t) ((duk_uint8_t *) tv_dst - (duk_uint8_t *) thr->valstack_bottom);
-		bc = (duk_idx_t) (tv_src - thr->valstack_bottom);  /* XXX: pass index explicitly? */
-		tv_src = NULL;  /* no longer referenced */
+		bc = (duk_idx_t) (tv_src - thr->valstack_bottom); /* XXX: pass index explicitly? */
+		tv_src = NULL; /* no longer referenced */
 
 		x = duk_to_number(thr, bc);
 		if (op & 0x01) {
 			y = x - 1.0;
 		} else {
 			y = x + 1.0;
 		}
@@ -76703,18 +77995,22 @@
 		duk_push_number(thr, y);
 		duk_replace(thr, bc);
 
 		tv_dst = (duk_tval *) (void *) (((duk_uint8_t *) thr->valstack_bottom) + off_dst);
 	}
 
 	z = (op & 0x02) ? x : y;
-	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_dst, z);  /* side effects */
+	DUK_TVAL_SET_NUMBER_UPDREF(thr, tv_dst, z); /* side effects */
 }
 
-DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__prepost_incdec_var_helper(duk_hthread *thr, duk_small_uint_t idx_dst, duk_tval *tv_id, duk_small_uint_t op, duk_small_uint_t is_strict) {
+DUK_LOCAL DUK_EXEC_ALWAYS_INLINE_PERF void duk__prepost_incdec_var_helper(duk_hthread *thr,
+                                                                          duk_small_uint_t idx_dst,
+                                                                          duk_tval *tv_id,
+                                                                          duk_small_uint_t op,
+                                                                          duk_small_uint_t is_strict) {
 	duk_activation *act;
 	duk_double_t x, y;
 	duk_hstring *name;
 
 	/* XXX: The pre/post inc/dec for an identifier lookup is
 	 * missing the important fast path where the identifier
 	 * has a storage location e.g. in a scope object so that
@@ -76732,15 +78028,15 @@
 	DUK_ASSERT((DUK_OP_POSTINCV & 0x03) == 0x02);
 	DUK_ASSERT((DUK_OP_POSTDECV & 0x03) == 0x03);
 
 	DUK_ASSERT(DUK_TVAL_IS_STRING(tv_id));
 	name = DUK_TVAL_GET_STRING(tv_id);
 	DUK_ASSERT(name != NULL);
 	act = thr->callstack_curr;
-	(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/);  /* -> [ ... val this ] */
+	(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/); /* -> [ ... val this ] */
 
 	/* XXX: Fastint fast path would be useful here.  Also fastints
 	 * now lose their fastint status in current handling which is
 	 * not intuitive.
 	 */
 
 	x = duk_to_number_m2(thr);
@@ -76749,48 +78045,48 @@
 	} else {
 		y = x + 1.0;
 	}
 
 	/* [... x this] */
 
 	if (op & 0x02) {
-		duk_push_number(thr, y);  /* -> [ ... x this y ] */
+		duk_push_number(thr, y); /* -> [ ... x this y ] */
 		DUK_ASSERT(act == thr->callstack_curr);
 		duk_js_putvar_activation(thr, act, name, DUK_GET_TVAL_NEGIDX(thr, -1), is_strict);
-		duk_pop_2_unsafe(thr);  /* -> [ ... x ] */
+		duk_pop_2_unsafe(thr); /* -> [ ... x ] */
 	} else {
-		duk_pop_2_unsafe(thr);  /* -> [ ... ] */
-		duk_push_number(thr, y);  /* -> [ ... y ] */
+		duk_pop_2_unsafe(thr); /* -> [ ... ] */
+		duk_push_number(thr, y); /* -> [ ... y ] */
 		DUK_ASSERT(act == thr->callstack_curr);
 		duk_js_putvar_activation(thr, act, name, DUK_GET_TVAL_NEGIDX(thr, -1), is_strict);
 	}
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 	duk_replace(thr, (duk_idx_t) idx_dst);
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 	DUK__REPLACE_TO_TVPTR(thr, DUK_GET_TVAL_POSIDX(thr, (duk_idx_t) idx_dst));
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 }
 
 /*
  *  Longjmp and other control flow transfer for the bytecode executor.
  *
  *  The longjmp handler can handle all longjmp types: error, yield, and
  *  resume (pseudotypes are never actually thrown).
  *
  *  Error policy for longjmp: should not ordinarily throw errors; if errors
  *  occur (e.g. due to out-of-memory) they bubble outwards rather than being
  *  handled recursively.
  */
 
-#define DUK__LONGJMP_RESTART   0  /* state updated, restart bytecode execution */
-#define DUK__LONGJMP_RETHROW   1  /* exit bytecode executor by rethrowing an error to caller */
+#define DUK__LONGJMP_RESTART 0 /* state updated, restart bytecode execution */
+#define DUK__LONGJMP_RETHROW 1 /* exit bytecode executor by rethrowing an error to caller */
 
-#define DUK__RETHAND_RESTART   0  /* state updated, restart bytecode execution */
-#define DUK__RETHAND_FINISHED  1  /* exit bytecode execution with return value */
+#define DUK__RETHAND_RESTART  0 /* state updated, restart bytecode execution */
+#define DUK__RETHAND_FINISHED 1 /* exit bytecode execution with return value */
 
 /* XXX: optimize reconfig valstack operations so that resize, clamp, and setting
  * top are combined into one pass.
  */
 
 /* Reconfigure value stack for return to an ECMAScript function at
  * callstack top (caller unwinds).
@@ -76811,15 +78107,16 @@
 	 * returning to an ECMAScript function.
 	 */
 
 	h_func = (duk_hcompfunc *) DUK_ACT_GET_FUNC(act);
 
 	thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 	DUK_ASSERT(act->retval_byteoff >= act->bottom_byteoff);
-	clamp_top = (duk_idx_t) ((act->retval_byteoff - act->bottom_byteoff + sizeof(duk_tval)) / sizeof(duk_tval));  /* +1 = one retval */
+	clamp_top =
+	    (duk_idx_t) ((act->retval_byteoff - act->bottom_byteoff + sizeof(duk_tval)) / sizeof(duk_tval)); /* +1 = one retval */
 	duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);
 
 	DUK_ASSERT((duk_uint8_t *) thr->valstack_end >= (duk_uint8_t *) thr->valstack + act->reserve_byteoff);
 	thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);
 
 	/* XXX: a best effort shrink check would be OK here */
 }
@@ -76841,15 +78138,15 @@
 	DUK_ASSERT(cat != NULL);
 
 	h_func = (duk_hcompfunc *) DUK_ACT_GET_FUNC(act);
 
 	thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 	idx_bottom = (duk_size_t) (thr->valstack_bottom - thr->valstack);
 	DUK_ASSERT(cat->idx_base >= idx_bottom);
-	clamp_top = (duk_idx_t) (cat->idx_base - idx_bottom + 2);  /* +2 = catcher value, catcher lj_type */
+	clamp_top = (duk_idx_t) (cat->idx_base - idx_bottom + 2); /* +2 = catcher value, catcher lj_type */
 	duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);
 
 	DUK_ASSERT((duk_uint8_t *) thr->valstack_end >= (duk_uint8_t *) thr->valstack + act->reserve_byteoff);
 	thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);
 
 	/* XXX: a best effort shrink check would be OK here */
 }
@@ -76869,15 +78166,18 @@
 
 	tv1++;
 	DUK_ASSERT(tv1 == thr->valstack + cat->idx_base + 1);
 	DUK_ASSERT(tv1 < thr->valstack_top);
 	DUK_TVAL_SET_U32_UPDREF_NORZ(thr, tv1, (duk_uint32_t) lj_type);
 }
 
-DUK_LOCAL void duk__handle_catch_part1(duk_hthread *thr, duk_tval *tv_val_unstable, duk_small_uint_t lj_type, volatile duk_bool_t *out_delayed_catch_setup) {
+DUK_LOCAL void duk__handle_catch_part1(duk_hthread *thr,
+                                       duk_tval *tv_val_unstable,
+                                       duk_small_uint_t lj_type,
+                                       volatile duk_bool_t *out_delayed_catch_setup) {
 	duk_activation *act;
 	duk_catcher *cat;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(tv_val_unstable != NULL);
 
 	act = thr->callstack_curr;
@@ -76907,15 +78207,15 @@
 
 	DUK_ASSERT(thr->callstack_top >= 1);
 	DUK_ASSERT(act == thr->callstack_curr);
 	DUK_ASSERT(act != NULL);
 	cat = act->cat;
 	DUK_ASSERT(cat != NULL);
 
-	act->curr_pc = cat->pc_base + 0;  /* +0 = catch */
+	act->curr_pc = cat->pc_base + 0; /* +0 = catch */
 
 	/*
 	 *  If the catch block has an automatic catch variable binding,
 	 *  we need to create a lexical environment for it which requires
 	 *  allocations.  Move out of "error handling state" before the
 	 *  allocations to avoid e.g. out-of-memory errors (leading to
 	 *  GH-2022 or similar).
@@ -76967,17 +78267,15 @@
 		DUK_ASSERT(act == thr->callstack_curr);
 		DUK_ASSERT(act != NULL);
 	}
 	DUK_ASSERT(act->lex_env != NULL);
 	DUK_ASSERT(act->var_env != NULL);
 	DUK_ASSERT(DUK_ACT_GET_FUNC(act) != NULL);
 
-	new_env = duk_hdecenv_alloc(thr,
-	                            DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                            DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
+	new_env = duk_hdecenv_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
 	DUK_ASSERT(new_env != NULL);
 	duk_push_hobject(thr, (duk_hobject *) new_env);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) new_env) == NULL);
 	DUK_DDD(DUK_DDDPRINT("new_env allocated: %!iO", (duk_heaphdr *) new_env));
 
 	/* Note: currently the catch binding is handled without a register
 	 * binding because we don't support dynamic register bindings (they
@@ -76987,23 +78285,23 @@
 
 	/* [ ...env ] */
 
 	DUK_ASSERT(cat->h_varname != NULL);
 	duk_push_hstring(thr, cat->h_varname);
 	DUK_ASSERT(thr->valstack + cat->idx_base < thr->valstack_top);
 	duk_push_tval(thr, thr->valstack + cat->idx_base);
-	duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_W);  /* writable, not configurable */
+	duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_W); /* writable, not configurable */
 
 	/* [ ... env ] */
 
 	DUK_ASSERT(act == thr->callstack_curr);
 	DUK_ASSERT(act != NULL);
 	DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) new_env, act->lex_env);
 	act->lex_env = (duk_hobject *) new_env;
-	DUK_HOBJECT_INCREF(thr, (duk_hobject *) new_env);  /* reachable through activation */
+	DUK_HOBJECT_INCREF(thr, (duk_hobject *) new_env); /* reachable through activation */
 	/* Net refcount change to act->lex_env is 0: incref for new_env's
 	 * prototype, decref for act->lex_env overwrite.
 	 */
 
 	DUK_CAT_SET_LEXENV_ACTIVE(cat);
 
 	duk_pop_unsafe(thr);
@@ -77037,15 +78335,15 @@
 
 	DUK_ASSERT(thr->callstack_top >= 1);
 	DUK_ASSERT(act == thr->callstack_curr);
 	DUK_ASSERT(act != NULL);
 	cat = act->cat;
 	DUK_ASSERT(cat != NULL);
 
-	act->curr_pc = cat->pc_base + 1;  /* +1 = finally */
+	act->curr_pc = cat->pc_base + 1; /* +1 = finally */
 
 	DUK_CAT_CLEAR_FINALLY_ENABLED(cat);
 }
 
 DUK_LOCAL void duk__handle_label(duk_hthread *thr, duk_small_uint_t lj_type) {
 	duk_activation *act;
 	duk_catcher *cat;
@@ -77086,26 +78384,29 @@
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(resumer != NULL);
 	DUK_ASSERT(tv_val_unstable != NULL);
 	act_resumer = resumer->callstack_curr;
 	DUK_ASSERT(act_resumer != NULL);
 	DUK_ASSERT(DUK_ACT_GET_FUNC(act_resumer) != NULL);
-	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(act_resumer)));  /* resume caller must be an ECMAScript func */
+	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(act_resumer))); /* resume caller must be an ECMAScript func */
 
-	tv1 = (duk_tval *) (void *) ((duk_uint8_t *) resumer->valstack + act_resumer->retval_byteoff);  /* return value from Duktape.Thread.resume() */
-	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv_val_unstable);  /* side effects */  /* XXX: avoid side effects */
+	tv1 = (duk_tval *) (void *) ((duk_uint8_t *) resumer->valstack +
+	                             act_resumer->retval_byteoff); /* return value from Duktape.Thread.resume() */
+	DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv_val_unstable); /* side effects */ /* XXX: avoid side effects */
 
 	duk__reconfig_valstack_ecma_return(resumer);
 
 	/* caller must change active thread, and set thr->resumer to NULL */
 }
-#endif  /* DUK_USE_COROUTINE_SUPPORT */
+#endif /* DUK_USE_COROUTINE_SUPPORT */
 
-DUK_LOCAL duk_small_uint_t duk__handle_longjmp(duk_hthread *thr, duk_activation *entry_act, volatile duk_bool_t *out_delayed_catch_setup) {
+DUK_LOCAL duk_small_uint_t duk__handle_longjmp(duk_hthread *thr,
+                                               duk_activation *entry_act,
+                                               volatile duk_bool_t *out_delayed_catch_setup) {
 	duk_small_uint_t retval = DUK__LONGJMP_RESTART;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(entry_act != NULL);
 
 	/* 'thr' is the current thread, as no-one resumes except us and we
 	 * switch 'thr' in that case.
@@ -77118,64 +78419,63 @@
 	 *  A longjmp handler may convert the longjmp to a different type and
 	 *  "virtually" rethrow by goto'ing to 'check_longjmp'.  Before the goto,
 	 *  the following must be updated:
 	 *    - the heap 'lj' state
 	 *    - 'thr' must reflect the "throwing" thread
 	 */
 
- check_longjmp:
+check_longjmp:
 
 	DUK_DD(DUK_DDPRINT("handling longjmp: type=%ld, value1=%!T, value2=%!T, iserror=%ld, top=%ld",
 	                   (long) thr->heap->lj.type,
 	                   (duk_tval *) &thr->heap->lj.value1,
 	                   (duk_tval *) &thr->heap->lj.value2,
 	                   (long) thr->heap->lj.iserror,
-			   (long) duk_get_top(thr)));
+	                   (long) duk_get_top(thr)));
 
 	switch (thr->heap->lj.type) {
-
 #if defined(DUK_USE_COROUTINE_SUPPORT)
 	case DUK_LJ_TYPE_RESUME: {
 		/*
 		 *  Note: lj.value1 is 'value', lj.value2 is 'resumee'.
 		 *  This differs from YIELD.
 		 */
 
 		duk_tval *tv;
 		duk_tval *tv2;
 		duk_hthread *resumee;
 
 		/* duk_bi_duk_object_yield() and duk_bi_duk_object_resume() ensure all of these are met */
 
-		DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING);                                                         /* unchanged by Duktape.Thread.resume() */
-		DUK_ASSERT(thr->callstack_top >= 2);                                                                         /* ECMAScript activation + Duktape.Thread.resume() activation */
+		DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING); /* unchanged by Duktape.Thread.resume() */
+		DUK_ASSERT(thr->callstack_top >= 2); /* ECMAScript activation + Duktape.Thread.resume() activation */
 		DUK_ASSERT(thr->callstack_curr != NULL);
 		DUK_ASSERT(thr->callstack_curr->parent != NULL);
 		DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL &&
 		           DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)) &&
 		           ((duk_hnatfunc *) DUK_ACT_GET_FUNC(thr->callstack_curr))->func == duk_bi_thread_resume);
 
-		tv = &thr->heap->lj.value2;  /* resumee */
+		tv = &thr->heap->lj.value2; /* resumee */
 		DUK_ASSERT(DUK_TVAL_IS_OBJECT(tv));
 		DUK_ASSERT(DUK_TVAL_GET_OBJECT(tv) != NULL);
 		DUK_ASSERT(DUK_HOBJECT_IS_THREAD(DUK_TVAL_GET_OBJECT(tv)));
 		resumee = (duk_hthread *) DUK_TVAL_GET_OBJECT(tv);
 
 		DUK_ASSERT(resumee != NULL);
 		DUK_ASSERT(resumee->resumer == NULL);
 		DUK_ASSERT(resumee->state == DUK_HTHREAD_STATE_INACTIVE ||
-		           resumee->state == DUK_HTHREAD_STATE_YIELDED);                                                     /* checked by Duktape.Thread.resume() */
+		           resumee->state == DUK_HTHREAD_STATE_YIELDED); /* checked by Duktape.Thread.resume() */
 		DUK_ASSERT(resumee->state != DUK_HTHREAD_STATE_YIELDED ||
-		           resumee->callstack_top >= 2);                                                                     /* YIELDED: ECMAScript activation + Duktape.Thread.yield() activation */
+		           resumee->callstack_top >= 2); /* YIELDED: ECMAScript activation + Duktape.Thread.yield() activation */
 		DUK_ASSERT(resumee->state != DUK_HTHREAD_STATE_YIELDED ||
 		           (DUK_ACT_GET_FUNC(resumee->callstack_curr) != NULL &&
 		            DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(resumee->callstack_curr)) &&
 		            ((duk_hnatfunc *) DUK_ACT_GET_FUNC(resumee->callstack_curr))->func == duk_bi_thread_yield));
 		DUK_ASSERT(resumee->state != DUK_HTHREAD_STATE_INACTIVE ||
-		           resumee->callstack_top == 0);                                                                     /* INACTIVE: no activation, single function value on valstack */
+		           resumee->callstack_top == 0); /* INACTIVE: no activation, single function value on valstack */
 
 		if (thr->heap->lj.iserror) {
 			/*
 			 *  Throw the error in the resumed thread's context; the
 			 *  error value is pushed onto the resumee valstack.
 			 *
 			 *  Note: the callstack of the target may empty in this case
@@ -77193,38 +78493,39 @@
 			thr = resumee;
 
 			thr->heap->lj.type = DUK_LJ_TYPE_THROW;
 
 			/* thr->heap->lj.value1 is already the value to throw */
 			/* thr->heap->lj.value2 is 'thread', will be wiped out at the end */
 
-			DUK_ASSERT(thr->heap->lj.iserror);  /* already set */
+			DUK_ASSERT(thr->heap->lj.iserror); /* already set */
 
 			DUK_DD(DUK_DDPRINT("-> resume with an error, converted to a throw in the resumee, propagate"));
 			goto check_longjmp;
 		} else if (resumee->state == DUK_HTHREAD_STATE_YIELDED) {
 			/* Unwind previous Duktape.Thread.yield() call.  The
 			 * activation remaining must always be an ECMAScript
 			 * call now (yield() accepts calls from ECMAScript
 			 * only).
 			 */
 			duk_activation *act_resumee;
 
 			DUK_ASSERT(resumee->callstack_top >= 2);
-			act_resumee = resumee->callstack_curr;  /* Duktape.Thread.yield() */
+			act_resumee = resumee->callstack_curr; /* Duktape.Thread.yield() */
 			DUK_ASSERT(act_resumee != NULL);
-			act_resumee = act_resumee->parent;      /* ECMAScript call site for yield() */
+			act_resumee = act_resumee->parent; /* ECMAScript call site for yield() */
 			DUK_ASSERT(act_resumee != NULL);
 
-			tv = (duk_tval *) (void *) ((duk_uint8_t *) resumee->valstack + act_resumee->retval_byteoff);  /* return value from Duktape.Thread.yield() */
+			tv = (duk_tval *) (void *) ((duk_uint8_t *) resumee->valstack +
+			                            act_resumee->retval_byteoff); /* return value from Duktape.Thread.yield() */
 			DUK_ASSERT(tv >= resumee->valstack && tv < resumee->valstack_top);
 			tv2 = &thr->heap->lj.value1;
-			DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv2);  /* side effects */  /* XXX: avoid side effects */
+			DUK_TVAL_SET_TVAL_UPDREF(thr, tv, tv2); /* side effects */ /* XXX: avoid side effects */
 
-			duk_hthread_activation_unwind_norz(resumee);  /* unwind to 'yield' caller */
+			duk_hthread_activation_unwind_norz(resumee); /* unwind to 'yield' caller */
 			/* no need to unwind catch stack */
 
 			duk__reconfig_valstack_ecma_return(resumee);
 
 			DUK_ASSERT(resumee->resumer == NULL);
 			resumee->resumer = thr;
 			DUK_HTHREAD_INCREF(thr, thr);
@@ -77246,15 +78547,15 @@
 
 			duk_push_undefined(resumee);
 			tv = &thr->heap->lj.value1;
 			duk_push_tval(resumee, tv);
 
 			/* resumee: [... initial_func undefined(= this) resume_value ] */
 
-			call_flags = DUK_CALL_FLAG_ALLOW_ECMATOECMA;  /* not tailcall, ecma-to-ecma (assumed to succeed) */
+			call_flags = DUK_CALL_FLAG_ALLOW_ECMATOECMA; /* not tailcall, ecma-to-ecma (assumed to succeed) */
 
 			setup_rc = duk_handle_call_unprotected_nargs(resumee, 1 /*nargs*/, call_flags);
 			if (setup_rc == 0) {
 				/* This shouldn't happen; Duktape.Thread.resume()
 				 * should make sure of that.  If it does happen
 				 * this internal error will propagate out of the
 				 * executor which can be quite misleading.
@@ -77273,15 +78574,15 @@
 			thr = resumee;  /* not needed, as we exit right away */
 #endif
 			DUK_DD(DUK_DDPRINT("-> resume with a value, restart execution in resumee"));
 			retval = DUK__LONGJMP_RESTART;
 			goto wipe_and_return;
 		}
 		DUK_UNREACHABLE();
-		break;  /* never here */
+		break; /* never here */
 	}
 
 	case DUK_LJ_TYPE_YIELD: {
 		/*
 		 *  Currently only allowed only if yielding thread has only
 		 *  ECMAScript activations (except for the Duktape.Thread.yield()
 		 *  call at the callstack top) and none of them constructor
@@ -77291,51 +78592,51 @@
 		 *  a preventcount > 0.
 		 */
 
 		duk_hthread *resumer;
 
 		/* duk_bi_duk_object_yield() and duk_bi_duk_object_resume() ensure all of these are met */
 
-#if 0  /* entry_thread not available for assert */
+#if 0 /* entry_thread not available for assert */
 		DUK_ASSERT(thr != entry_thread);                                                                             /* Duktape.Thread.yield() should prevent */
 #endif
-		DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING);                                                         /* unchanged from Duktape.Thread.yield() */
-		DUK_ASSERT(thr->callstack_top >= 2);                                                                         /* ECMAScript activation + Duktape.Thread.yield() activation */
+		DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING); /* unchanged from Duktape.Thread.yield() */
+		DUK_ASSERT(thr->callstack_top >= 2); /* ECMAScript activation + Duktape.Thread.yield() activation */
 		DUK_ASSERT(thr->callstack_curr != NULL);
 		DUK_ASSERT(thr->callstack_curr->parent != NULL);
 		DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr) != NULL &&
 		           DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr)) &&
 		           ((duk_hnatfunc *) DUK_ACT_GET_FUNC(thr->callstack_curr))->func == duk_bi_thread_yield);
 		DUK_ASSERT(DUK_ACT_GET_FUNC(thr->callstack_curr->parent) != NULL &&
-		           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr->parent)));                              /* an ECMAScript function */
+		           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr->parent))); /* an ECMAScript function */
 
 		resumer = thr->resumer;
 
 		DUK_ASSERT(resumer != NULL);
-		DUK_ASSERT(resumer->state == DUK_HTHREAD_STATE_RESUMED);                                                     /* written by a previous RESUME handling */
-		DUK_ASSERT(resumer->callstack_top >= 2);                                                                     /* ECMAScript activation + Duktape.Thread.resume() activation */
+		DUK_ASSERT(resumer->state == DUK_HTHREAD_STATE_RESUMED); /* written by a previous RESUME handling */
+		DUK_ASSERT(resumer->callstack_top >= 2); /* ECMAScript activation + Duktape.Thread.resume() activation */
 		DUK_ASSERT(resumer->callstack_curr != NULL);
 		DUK_ASSERT(resumer->callstack_curr->parent != NULL);
 		DUK_ASSERT(DUK_ACT_GET_FUNC(resumer->callstack_curr) != NULL &&
 		           DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(resumer->callstack_curr)) &&
 		           ((duk_hnatfunc *) DUK_ACT_GET_FUNC(resumer->callstack_curr))->func == duk_bi_thread_resume);
 		DUK_ASSERT(DUK_ACT_GET_FUNC(resumer->callstack_curr->parent) != NULL &&
-		           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(resumer->callstack_curr->parent)));                            /* an ECMAScript function */
+		           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(resumer->callstack_curr->parent))); /* an ECMAScript function */
 
 		if (thr->heap->lj.iserror) {
 			thr->state = DUK_HTHREAD_STATE_YIELDED;
 			thr->resumer = NULL;
 			DUK_HTHREAD_DECREF_NORZ(thr, resumer);
 			resumer->state = DUK_HTHREAD_STATE_RUNNING;
 			DUK_HEAP_SWITCH_THREAD(thr->heap, resumer);
 			thr = resumer;
 
 			thr->heap->lj.type = DUK_LJ_TYPE_THROW;
 			/* lj.value1 is already set */
-			DUK_ASSERT(thr->heap->lj.iserror);  /* already set */
+			DUK_ASSERT(thr->heap->lj.iserror); /* already set */
 
 			DUK_DD(DUK_DDPRINT("-> yield an error, converted to a throw in the resumer, propagate"));
 			goto check_longjmp;
 		} else {
 			/* When handling the yield, the last reference to
 			 * 'thr' may disappear.
 			 */
@@ -77353,17 +78654,17 @@
 			DUK_GC_TORTURE(resumer->heap);
 
 			DUK_DD(DUK_DDPRINT("-> yield a value, restart execution in resumer"));
 			retval = DUK__LONGJMP_RESTART;
 			goto wipe_and_return;
 		}
 		DUK_UNREACHABLE();
-		break;  /* never here */
+		break; /* never here */
 	}
-#endif  /* DUK_USE_COROUTINE_SUPPORT */
+#endif /* DUK_USE_COROUTINE_SUPPORT */
 
 	case DUK_LJ_TYPE_THROW: {
 		/*
 		 *  Three possible outcomes:
 		 *    * A try or finally catcher is found => resume there.
 		 *      (or)
 		 *    * The error propagates to the bytecode executor entry
@@ -77396,32 +78697,32 @@
 					break;
 				}
 
 				if (DUK_CAT_HAS_CATCH_ENABLED(cat)) {
 					DUK_ASSERT(DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF);
 
 					DUK_DDD(DUK_DDDPRINT("before catch part 1: thr=%p, act=%p, cat=%p",
-					                     (void *) thr, (void *) act, (void *) act->cat));
+					                     (void *) thr,
+					                     (void *) act,
+					                     (void *) act->cat));
 					duk__handle_catch_part1(thr,
 					                        &thr->heap->lj.value1,
 					                        DUK_LJ_TYPE_THROW,
-							        out_delayed_catch_setup);
+					                        out_delayed_catch_setup);
 
 					DUK_DD(DUK_DDPRINT("-> throw caught by a 'catch' clause, restart execution"));
 					retval = DUK__LONGJMP_RESTART;
 					goto wipe_and_return;
 				}
 
 				if (DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
 					DUK_ASSERT(DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF);
 					DUK_ASSERT(!DUK_CAT_HAS_CATCH_ENABLED(cat));
 
-					duk__handle_finally(thr,
-					                    &thr->heap->lj.value1,
-					                    DUK_LJ_TYPE_THROW);
+					duk__handle_finally(thr, &thr->heap->lj.value1, DUK_LJ_TYPE_THROW);
 
 					DUK_DD(DUK_DDPRINT("-> throw caught by a 'finally' clause, restart execution"));
 					retval = DUK__LONGJMP_RESTART;
 					goto wipe_and_return;
 				}
 
 				duk_hthread_catcher_unwind_norz(thr, act);
@@ -77443,67 +78744,67 @@
 
 		/* Not caught by current thread, thread terminates (yield error to resumer);
 		 * note that this may cause a cascade if the resumer terminates with an uncaught
 		 * exception etc (this is OK, but needs careful testing).
 		 */
 
 		DUK_ASSERT(thr->resumer != NULL);
-		DUK_ASSERT(thr->resumer->callstack_top >= 2);  /* ECMAScript activation + Duktape.Thread.resume() activation */
+		DUK_ASSERT(thr->resumer->callstack_top >= 2); /* ECMAScript activation + Duktape.Thread.resume() activation */
 		DUK_ASSERT(thr->resumer->callstack_curr != NULL);
 		DUK_ASSERT(thr->resumer->callstack_curr->parent != NULL);
-		DUK_ASSERT(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent) != NULL &&
-		           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent)));  /* an ECMAScript function */
+		DUK_ASSERT(
+		    DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent) != NULL &&
+		    DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent))); /* an ECMAScript function */
 
 		resumer = thr->resumer;
 
 		/* reset longjmp */
 
-		DUK_ASSERT(thr->heap->lj.type == DUK_LJ_TYPE_THROW);  /* already set */
+		DUK_ASSERT(thr->heap->lj.type == DUK_LJ_TYPE_THROW); /* already set */
 		/* lj.value1 already set */
 
-		duk_hthread_terminate(thr);  /* updates thread state, minimizes its allocations */
+		duk_hthread_terminate(thr); /* updates thread state, minimizes its allocations */
 		DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_TERMINATED);
 
 		thr->resumer = NULL;
 		DUK_HTHREAD_DECREF_NORZ(thr, resumer);
 		resumer->state = DUK_HTHREAD_STATE_RUNNING;
 		DUK_HEAP_SWITCH_THREAD(thr->heap, resumer);
 		thr = resumer;
 		goto check_longjmp;
 	}
 
-	case DUK_LJ_TYPE_BREAK:  /* pseudotypes, not used in actual longjmps */
+	case DUK_LJ_TYPE_BREAK: /* pseudotypes, not used in actual longjmps */
 	case DUK_LJ_TYPE_CONTINUE:
 	case DUK_LJ_TYPE_RETURN:
 	case DUK_LJ_TYPE_NORMAL:
 	default: {
 		/* should never happen, but be robust */
 		DUK_D(DUK_DPRINT("caught unknown longjmp type %ld, treat as internal error", (long) thr->heap->lj.type));
 		goto convert_to_internal_error;
 	}
 
-	}  /* end switch */
+	} /* end switch */
 
 	DUK_UNREACHABLE();
 
- wipe_and_return:
-	DUK_DD(DUK_DDPRINT("handling longjmp done, wipe-and-return, top=%ld",
-	                   (long) duk_get_top(thr)));
+wipe_and_return:
+	DUK_DD(DUK_DDPRINT("handling longjmp done, wipe-and-return, top=%ld", (long) duk_get_top(thr)));
 	thr->heap->lj.type = DUK_LJ_TYPE_UNKNOWN;
 	thr->heap->lj.iserror = 0;
 
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, &thr->heap->lj.value1);  /* side effects */
-	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, &thr->heap->lj.value2);  /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, &thr->heap->lj.value1); /* side effects */
+	DUK_TVAL_SET_UNDEFINED_UPDREF(thr, &thr->heap->lj.value2); /* side effects */
 
 	DUK_GC_TORTURE(thr->heap);
 
- just_return:
+just_return:
 	return retval;
 
- convert_to_internal_error:
+convert_to_internal_error:
 	/* This could also be thrown internally (set the error, goto check_longjmp),
 	 * but it's better for internal errors to bubble outwards so that we won't
 	 * infinite loop in this catchpoint.
 	 */
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return 0;);
 }
@@ -77541,37 +78842,37 @@
 		DUK_DDD(DUK_DDDPRINT("considering catcher %p: type=%ld label=%ld",
 		                     (void *) cat,
 		                     (long) DUK_CAT_GET_TYPE(cat),
 		                     (long) DUK_CAT_GET_LABEL(cat)));
 
 		/* XXX: bit mask test; FINALLY <-> TCF, single bit mask would suffice? */
 
-		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF &&
-		    DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
+		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF && DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
 			duk_tval tv_tmp;
 
 			DUK_TVAL_SET_U32(&tv_tmp, (duk_uint32_t) label_id);
 			duk__handle_finally(thr, &tv_tmp, lj_type);
 
 			DUK_DD(DUK_DDPRINT("-> break/continue caught by 'finally', restart execution"));
 			return;
 		}
-		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_LABEL &&
-		    (duk_uint_t) DUK_CAT_GET_LABEL(cat) == label_id) {
+		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_LABEL && (duk_uint_t) DUK_CAT_GET_LABEL(cat) == label_id) {
 			duk__handle_label(thr, lj_type);
 
-			DUK_DD(DUK_DDPRINT("-> break/continue caught by a label catcher (in the same function), restart execution"));
+			DUK_DD(
+			    DUK_DDPRINT("-> break/continue caught by a label catcher (in the same function), restart execution"));
 			return;
 		}
 
 		duk_hthread_catcher_unwind_norz(thr, act);
 	}
 
 	/* Should never happen, but be robust. */
-	DUK_D(DUK_DPRINT("-> break/continue not caught by anything in the current function (should never happen), throw internal error"));
+	DUK_D(DUK_DPRINT(
+	    "-> break/continue not caught by anything in the current function (should never happen), throw internal error"));
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Handle a RETURN opcode.  Avoid using longjmp() for return handling because
  * it has a measurable performance impact in ordinary environments and an extreme
  * impact in Emscripten (GH-342).  Return value is on value stack top.
@@ -77587,15 +78888,15 @@
 
 	/* We can directly access value stack here. */
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(entry_act != NULL);
 	DUK_ASSERT(thr->valstack_top - 1 >= thr->valstack_bottom);
 	tv1 = thr->valstack_top - 1;
-	DUK_TVAL_CHKFAST_INPLACE_FAST(tv1);  /* fastint downgrade check for return values */
+	DUK_TVAL_CHKFAST_INPLACE_FAST(tv1); /* fastint downgrade check for return values */
 
 	/*
 	 *  Four possible outcomes:
 	 *
 	 *    1. A 'finally' in the same function catches the 'return'.
 	 *       It may continue to propagate when 'finally' is finished,
 	 *       or it may be neutralized by 'finally' (both handled by
@@ -77622,16 +78923,15 @@
 
 	for (;;) {
 		cat = act->cat;
 		if (cat == NULL) {
 			break;
 		}
 
-		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF &&
-		    DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
+		if (DUK_CAT_GET_TYPE(cat) == DUK_CAT_TYPE_TCF && DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
 			DUK_ASSERT(thr->valstack_top - 1 >= thr->valstack_bottom);
 			duk__handle_finally(thr, thr->valstack_top - 1, DUK_LJ_TYPE_RETURN);
 
 			DUK_DD(DUK_DDPRINT("-> return caught by 'finally', restart execution"));
 			return DUK__RETHAND_RESTART;
 		}
 
@@ -77654,52 +78954,55 @@
 		 */
 		DUK_DDD(DUK_DDDPRINT("return to ECMAScript caller, retval_byteoff=%ld, lj_value1=%!T",
 		                     (long) (thr->callstack_curr->parent->retval_byteoff),
 		                     (duk_tval *) &thr->heap->lj.value1));
 
 		DUK_ASSERT(thr->callstack_curr != NULL);
 		DUK_ASSERT(thr->callstack_curr->parent != NULL);
-		DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr->parent)));   /* must be ECMAScript */
+		DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->callstack_curr->parent))); /* must be ECMAScript */
 
 #if defined(DUK_USE_ES6_PROXY)
 		if (thr->callstack_curr->flags & (DUK_ACT_FLAG_CONSTRUCT | DUK_ACT_FLAG_CONSTRUCT_PROXY)) {
-			duk_call_construct_postprocess(thr, thr->callstack_curr->flags & DUK_ACT_FLAG_CONSTRUCT_PROXY);  /* side effects */
+			duk_call_construct_postprocess(thr,
+			                               thr->callstack_curr->flags &
+			                                   DUK_ACT_FLAG_CONSTRUCT_PROXY); /* side effects */
 		}
 #else
 		if (thr->callstack_curr->flags & DUK_ACT_FLAG_CONSTRUCT) {
-			duk_call_construct_postprocess(thr, 0);  /* side effects */
+			duk_call_construct_postprocess(thr, 0); /* side effects */
 		}
 #endif
 
 		tv1 = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + thr->callstack_curr->parent->retval_byteoff);
 		DUK_ASSERT(thr->valstack_top - 1 >= thr->valstack_bottom);
 		tv2 = thr->valstack_top - 1;
-		DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2);  /* side effects */
+		DUK_TVAL_SET_TVAL_UPDREF(thr, tv1, tv2); /* side effects */
 
 		/* Catch stack unwind happens inline in callstack unwind. */
 		duk_hthread_activation_unwind_norz(thr);
 
 		duk__reconfig_valstack_ecma_return(thr);
 
 		DUK_DD(DUK_DDPRINT("-> return not intercepted, restart execution in caller"));
 		return DUK__RETHAND_RESTART;
 	}
 
 #if defined(DUK_USE_COROUTINE_SUPPORT)
 	DUK_DD(DUK_DDPRINT("no calling activation, thread finishes (similar to yield)"));
 
 	DUK_ASSERT(thr->resumer != NULL);
-	DUK_ASSERT(thr->resumer->callstack_top >= 2);  /* ECMAScript activation + Duktape.Thread.resume() activation */
+	DUK_ASSERT(thr->resumer->callstack_top >= 2); /* ECMAScript activation + Duktape.Thread.resume() activation */
 	DUK_ASSERT(thr->resumer->callstack_curr != NULL);
 	DUK_ASSERT(thr->resumer->callstack_curr->parent != NULL);
 	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr) != NULL &&
-			DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr)) &&
-			((duk_hnatfunc *) DUK_ACT_GET_FUNC(thr->resumer->callstack_curr))->func == duk_bi_thread_resume);  /* Duktape.Thread.resume() */
+	           DUK_HOBJECT_IS_NATFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr)) &&
+	           ((duk_hnatfunc *) DUK_ACT_GET_FUNC(thr->resumer->callstack_curr))->func ==
+	               duk_bi_thread_resume); /* Duktape.Thread.resume() */
 	DUK_ASSERT(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent) != NULL &&
-			DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent)));  /* an ECMAScript function */
+	           DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(thr->resumer->callstack_curr->parent))); /* an ECMAScript function */
 	DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_RUNNING);
 	DUK_ASSERT(thr->resumer->state == DUK_HTHREAD_STATE_RESUMED);
 
 	resumer = thr->resumer;
 
 	/* Share yield longjmp handler.
 	 *
@@ -77713,29 +79016,29 @@
 	 * Current approach is to capture the 'thr' return value and store
 	 * a reference to 'thr' in the caller value stack temporarily.  This
 	 * keeps 'thr' reachable until final yield/return handling which
 	 * removes the references atomatically.
 	 */
 
 	DUK_ASSERT(thr->valstack_top - 1 >= thr->valstack_bottom);
-	duk_hthread_activation_unwind_norz(resumer);  /* May remove last reference to 'thr', but is NORZ. */
-	duk_push_tval(resumer, thr->valstack_top - 1);  /* Capture return value, side effect free. */
-	duk_push_hthread(resumer, thr);  /* Make 'thr' reachable again, before side effects. */
+	duk_hthread_activation_unwind_norz(resumer); /* May remove last reference to 'thr', but is NORZ. */
+	duk_push_tval(resumer, thr->valstack_top - 1); /* Capture return value, side effect free. */
+	duk_push_hthread(resumer, thr); /* Make 'thr' reachable again, before side effects. */
 
-	duk_hthread_terminate(thr);  /* Updates thread state, minimizes its allocations. */
+	duk_hthread_terminate(thr); /* Updates thread state, minimizes its allocations. */
 	thr->resumer = NULL;
 	DUK_HTHREAD_DECREF(thr, resumer);
 	DUK_ASSERT(thr->state == DUK_HTHREAD_STATE_TERMINATED);
 
 	resumer->state = DUK_HTHREAD_STATE_RUNNING;
 	DUK_HEAP_SWITCH_THREAD(thr->heap, resumer);
 
 	DUK_ASSERT(resumer->valstack_top - 2 >= resumer->valstack_bottom);
 	duk__handle_yield(thr, resumer, resumer->valstack_top - 2);
-	thr = NULL;  /* 'thr' invalidated by call */
+	thr = NULL; /* 'thr' invalidated by call */
 
 #if 0
 	thr = resumer;  /* not needed */
 #endif
 
 	DUK_DD(DUK_DDPRINT("-> return not caught, thread terminated; handle like yield, restart execution in resumer"));
 	return DUK__RETHAND_RESTART;
@@ -77769,27 +79072,27 @@
  *  behavior.  For instance, executor step limit needs a cumulative step
  *  count which is simply computed as a sum of 'init' values.  This must
  *  work accurately even when single stepping.
  */
 
 #if defined(DUK_USE_INTERRUPT_COUNTER)
 
-#define DUK__INT_NOACTION    0    /* no specific action, resume normal execution */
-#define DUK__INT_RESTART     1    /* must "goto restart_execution", e.g. breakpoints changed */
+#define DUK__INT_NOACTION 0 /* no specific action, resume normal execution */
+#define DUK__INT_RESTART  1 /* must "goto restart_execution", e.g. breakpoints changed */
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 DUK_LOCAL void duk__interrupt_handle_debugger(duk_hthread *thr, duk_bool_t *out_immediate, duk_small_uint_t *out_interrupt_retval) {
 	duk_activation *act;
 	duk_breakpoint *bp;
 	duk_breakpoint **bp_active;
 	duk_uint_fast32_t line = 0;
 	duk_bool_t process_messages;
 	duk_bool_t processed_messages = 0;
 
-	DUK_ASSERT(thr->heap->dbg_processing == 0);  /* don't re-enter e.g. during Eval */
+	DUK_ASSERT(thr->heap->dbg_processing == 0); /* don't re-enter e.g. during Eval */
 
 	act = thr->callstack_curr;
 	DUK_ASSERT(act != NULL);
 
 	/* It might seem that replacing 'thr->heap' with just 'heap' below
 	 * might be a good idea, but it increases code size slightly
 	 * (probably due to unnecessary spilling) at least on x64.
@@ -77804,25 +79107,22 @@
 		duk_debug_set_paused(thr->heap);
 	}
 
 	/*
 	 *  Breakpoint and step state checks
 	 */
 
-	if (act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE ||
-	    (thr->heap->dbg_pause_act == thr->callstack_curr)) {
+	if (act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE || (thr->heap->dbg_pause_act == thr->callstack_curr)) {
 		line = duk_debug_curr_line(thr);
 
 		if (act->prev_line != line) {
 			/* Stepped?  Step out is handled by callstack unwind. */
 			if ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_LINE_CHANGE) &&
-			    (thr->heap->dbg_pause_act == thr->callstack_curr) &&
-			    (line != thr->heap->dbg_pause_startline)) {
-				DUK_D(DUK_DPRINT("PAUSE TRIGGERED by line change, at line %ld",
-				                 (long) line));
+			    (thr->heap->dbg_pause_act == thr->callstack_curr) && (line != thr->heap->dbg_pause_startline)) {
+				DUK_D(DUK_DPRINT("PAUSE TRIGGERED by line change, at line %ld", (long) line));
 				duk_debug_set_paused(thr->heap);
 			}
 
 			/* Check for breakpoints only on line transition.
 			 * Breakpoint is triggered when we enter the target
 			 * line from a different line, and the previous line
 			 * was within the same function.
@@ -77840,15 +79140,16 @@
 				if (bp == NULL) {
 					break;
 				}
 
 				DUK_ASSERT(bp->filename != NULL);
 				if (act->prev_line != bp->line && line == bp->line) {
 					DUK_D(DUK_DPRINT("PAUSE TRIGGERED by breakpoint at %!O:%ld",
-					                 (duk_heaphdr *) bp->filename, (long) bp->line));
+					                 (duk_heaphdr *) bp->filename,
+					                 (long) bp->line));
 					duk_debug_set_paused(thr->heap);
 				}
 			}
 		} else {
 			;
 		}
 
@@ -77933,19 +79234,18 @@
 	 * Note that debugger may have detached due to error or explicit request
 	 * above, so we must recheck attach status.
 	 */
 
 	if (duk_debug_is_attached(thr->heap)) {
 		DUK_ASSERT(act == thr->callstack_curr);
 		DUK_ASSERT(act != NULL);
-		if (act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE ||
-		    (thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_ONE_OPCODE) ||
+		if (act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE || (thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_ONE_OPCODE) ||
 		    ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_LINE_CHANGE) &&
 		     thr->heap->dbg_pause_act == thr->callstack_curr) ||
-		     DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap)) {
+		    DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap)) {
 			*out_immediate = 1;
 		}
 
 		/* If we processed any debug messages breakpoints may have
 		 * changed; restart execution to re-check active breakpoints.
 		 */
 		if (processed_messages) {
@@ -77959,15 +79259,15 @@
 				thr->heap->dbg_pause_flags |= DUK_PAUSE_FLAG_ONE_OPCODE_ACTIVE;
 			}
 		}
 	} else {
 		DUK_D(DUK_DPRINT("debugger became detached, resume normal execution"));
 	}
 }
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF DUK_COLD duk_small_uint_t duk__executor_interrupt(duk_hthread *thr) {
 	duk_int_t ctr;
 	duk_activation *act;
 	duk_hcompfunc *fun;
 	duk_bool_t immediate = 0;
 	duk_small_uint_t retval;
@@ -77976,16 +79276,18 @@
 	DUK_ASSERT(thr->heap != NULL);
 	DUK_ASSERT(thr->callstack_top > 0);
 
 #if defined(DUK_USE_DEBUG)
 	thr->heap->inst_count_interrupt += thr->interrupt_init;
 	DUK_DD(DUK_DDPRINT("execution interrupt, counter=%ld, init=%ld, "
 	                   "instruction counts: executor=%ld, interrupt=%ld",
-	                   (long) thr->interrupt_counter, (long) thr->interrupt_init,
-	                   (long) thr->heap->inst_count_exec, (long) thr->heap->inst_count_interrupt));
+	                   (long) thr->interrupt_counter,
+	                   (long) thr->interrupt_init,
+	                   (long) thr->heap->inst_count_exec,
+	                   (long) thr->heap->inst_count_interrupt));
 #endif
 
 	retval = DUK__INT_NOACTION;
 	ctr = DUK_HTHREAD_INTCTR_DEFAULT;
 
 	/*
 	 *  Avoid nested calls.  Concretely this happens during debugging, e.g.
@@ -78039,26 +79341,25 @@
 		DUK_D(DUK_DPRINT("execution timeout, throwing a RangeError"));
 		thr->interrupt_init = 0;
 		thr->interrupt_counter = 0;
 		DUK_HEAP_CLEAR_INTERRUPT_RUNNING(thr->heap);
 		DUK_ERROR_RANGE(thr, "execution timeout");
 		DUK_WO_NORETURN(return 0;);
 	}
-#endif  /* DUK_USE_EXEC_TIMEOUT_CHECK */
+#endif /* DUK_USE_EXEC_TIMEOUT_CHECK */
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
-	if (!thr->heap->dbg_processing &&
-	    (thr->heap->dbg_read_cb != NULL || thr->heap->dbg_detaching)) {
+	if (!thr->heap->dbg_processing && (thr->heap->dbg_read_cb != NULL || thr->heap->dbg_detaching)) {
 		/* Avoid recursive re-entry; enter when we're attached or
 		 * detaching (to finish off the pending detach).
 		 */
 		duk__interrupt_handle_debugger(thr, &immediate, &retval);
 		DUK_ASSERT(act == thr->callstack_curr);
 	}
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 	/*
 	 *  Update the interrupt counter
 	 */
 
 	if (immediate) {
 		/* Cause an interrupt after executing one instruction. */
@@ -78073,15 +79374,15 @@
 	DUK_ASSERT(ctr >= 1);
 	thr->interrupt_init = ctr;
 	thr->interrupt_counter = ctr - 1;
 	DUK_HEAP_CLEAR_INTERRUPT_RUNNING(thr->heap);
 
 	return retval;
 }
-#endif  /* DUK_USE_INTERRUPT_COUNTER */
+#endif /* DUK_USE_INTERRUPT_COUNTER */
 
 /*
  *  Debugger handling for executor restart
  *
  *  Check for breakpoints, stepping, etc, and figure out if we should execute
  *  in checked or normal mode.  Note that we can't do this when an activation
  *  is created, because breakpoint status (and stepping status) may change
@@ -78141,16 +79442,15 @@
 
 		for (bp_idx = 0; bp_idx < heap->dbg_breakpoint_count; bp_idx++) {
 			duk_breakpoint *bp = heap->dbg_breakpoints + bp_idx;
 			duk_hobject **funcs, **funcs_end;
 			duk_hcompfunc *inner_fun;
 			duk_bool_t bp_match;
 
-			if (bp->filename == filename &&
-			    bp->line >= fun->start_line && bp->line <= fun->end_line) {
+			if (bp->filename == filename && bp->line >= fun->start_line && bp->line <= fun->end_line) {
 				bp_match = 1;
 				DUK_DD(DUK_DDPRINT("breakpoint filename and line match: "
 				                   "%s:%ld vs. %s (line %ld vs. %ld-%ld)",
 				                   DUK_HSTRING_GET_DATA(bp->filename),
 				                   (long) bp->line,
 				                   DUK_HSTRING_GET_DATA(filename),
 				                   (long) bp->line,
@@ -78179,43 +79479,40 @@
 					*bp_active = heap->dbg_breakpoints + bp_idx;
 					bp_active++;
 				}
 			}
 		}
 	}
 
-	*bp_active = NULL;  /* terminate */
+	*bp_active = NULL; /* terminate */
 
 	DUK_DD(DUK_DDPRINT("ACTIVE BREAKPOINTS: %ld", (long) (bp_active - thr->heap->dbg_breakpoints_active)));
 
 	/* Force pause if we were doing "step into" in another activation. */
-	if ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_FUNC_ENTRY) &&
-	    thr->heap->dbg_pause_act != thr->callstack_curr) {
+	if ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_FUNC_ENTRY) && thr->heap->dbg_pause_act != thr->callstack_curr) {
 		DUK_D(DUK_DPRINT("PAUSE TRIGGERED by function entry"));
 		duk_debug_set_paused(thr->heap);
 	}
 
 	/* Force interrupt right away if we're paused or in "checked mode".
 	 * Step out is handled by callstack unwind.
 	 */
-	if ((act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE) ||
-	    DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap) ||
-	    ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_LINE_CHANGE) &&
-	     thr->heap->dbg_pause_act == thr->callstack_curr)) {
+	if ((act->flags & DUK_ACT_FLAG_BREAKPOINT_ACTIVE) || DUK_HEAP_HAS_DEBUGGER_PAUSED(thr->heap) ||
+	    ((thr->heap->dbg_pause_flags & DUK_PAUSE_FLAG_LINE_CHANGE) && thr->heap->dbg_pause_act == thr->callstack_curr)) {
 		/* We'll need to interrupt early so recompute the init
 		 * counter to reflect the number of bytecode instructions
 		 * executed so that step counts for e.g. debugger rate
 		 * limiting are accurate.
 		 */
 		DUK_ASSERT(thr->interrupt_counter <= thr->interrupt_init);
 		thr->interrupt_init = thr->interrupt_init - thr->interrupt_counter;
 		thr->interrupt_counter = 0;
 	}
 }
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 /*
  *  Opcode handlers for opcodes with a lot of code and which are relatively
  *  rare; NOINLINE to reduce amount of code in main bytecode dispatcher.
  */
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF void duk__handle_op_initset_initget(duk_hthread *thr, duk_uint_fast32_t ins) {
@@ -78231,26 +79528,22 @@
 	 * There may be a previous propery in ES2015 because duplicate property
 	 * names are allowed.
 	 */
 
 	/* This could be made more optimal by accessing internals directly. */
 
 	idx = (duk_uint_fast_t) DUK_DEC_BC(ins);
-	duk_dup(thr, (duk_idx_t) (idx + 0));  /* key */
-	duk_dup(thr, (duk_idx_t) (idx + 1));  /* getter/setter */
+	duk_dup(thr, (duk_idx_t) (idx + 0)); /* key */
+	duk_dup(thr, (duk_idx_t) (idx + 1)); /* getter/setter */
 	if (is_set) {
-	        defprop_flags = DUK_DEFPROP_HAVE_SETTER |
-	                        DUK_DEFPROP_FORCE |
-	                        DUK_DEFPROP_SET_ENUMERABLE |
-	                        DUK_DEFPROP_SET_CONFIGURABLE;
-	} else {
-	        defprop_flags = DUK_DEFPROP_HAVE_GETTER |
-	                        DUK_DEFPROP_FORCE |
-	                        DUK_DEFPROP_SET_ENUMERABLE |
-	                        DUK_DEFPROP_SET_CONFIGURABLE;
+		defprop_flags =
+		    DUK_DEFPROP_HAVE_SETTER | DUK_DEFPROP_FORCE | DUK_DEFPROP_SET_ENUMERABLE | DUK_DEFPROP_SET_CONFIGURABLE;
+	} else {
+		defprop_flags =
+		    DUK_DEFPROP_HAVE_GETTER | DUK_DEFPROP_FORCE | DUK_DEFPROP_SET_ENUMERABLE | DUK_DEFPROP_SET_CONFIGURABLE;
 	}
 	duk_def_prop(thr, (duk_idx_t) DUK_DEC_A(ins), defprop_flags);
 }
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF void duk__handle_op_trycatch(duk_hthread *thr, duk_uint_fast32_t ins, duk_instr_t *curr_pc) {
 	duk_activation *act;
 	duk_catcher *cat;
@@ -78307,30 +79600,30 @@
 	 * guarantee no finalizer calls in error handling.  Scrubbing also
 	 * ensures finalizers for the previous values run here rather than
 	 * later.  Error handling related values are also written to 'bc'
 	 * and 'bc + 1' but those values never become unreachable during
 	 * error handling, so there's no side effect problem even if the
 	 * error value has a finalizer.
 	 */
-	duk_dup(thr, (duk_idx_t) bc);  /* Stabilize value. */
+	duk_dup(thr, (duk_idx_t) bc); /* Stabilize value. */
 	duk_to_undefined(thr, (duk_idx_t) bc);
 	duk_to_undefined(thr, (duk_idx_t) (bc + 1));
 
 	/* Allocate catcher and populate it.  Doesn't have to
 	 * be fully atomic, but the catcher must be in a
 	 * consistent state if side effects (such as finalizer
 	 * calls) occur.
 	 */
 
 	cat = duk_hthread_catcher_alloc(thr);
 	DUK_ASSERT(cat != NULL);
 
 	cat->flags = DUK_CAT_TYPE_TCF;
 	cat->h_varname = NULL;
-	cat->pc_base = (duk_instr_t *) curr_pc;  /* pre-incremented, points to first jump slot */
+	cat->pc_base = (duk_instr_t *) curr_pc; /* pre-incremented, points to first jump slot */
 	cat->idx_base = (duk_size_t) (thr->valstack_bottom - thr->valstack) + bc;
 
 	act = thr->callstack_curr;
 	DUK_ASSERT(act != NULL);
 	cat->parent = act->cat;
 	act->cat = cat;
 
@@ -78361,61 +79654,61 @@
 		DUK_ASSERT(act != NULL);
 		if (act->lex_env == NULL) {
 			DUK_DDD(DUK_DDDPRINT("delayed environment initialization"));
 			DUK_ASSERT(act->var_env == NULL);
 
 			duk_js_init_activation_environment_records_delayed(thr, act);
 			DUK_ASSERT(act == thr->callstack_curr);
-			DUK_UNREF(act);  /* 'act' is no longer accessed, scanbuild fix */
+			DUK_UNREF(act); /* 'act' is no longer accessed, scanbuild fix */
 		}
 		DUK_ASSERT(act->lex_env != NULL);
 		DUK_ASSERT(act->var_env != NULL);
 
 		/* Coerce 'with' target. */
 		target = duk_to_hobject(thr, -1);
 		DUK_ASSERT(target != NULL);
 
 		/* Create an object environment; it is not pushed
 		 * so avoid side effects very carefully until it is
 		 * referenced.
 		 */
-		env = duk_hobjenv_alloc(thr,
-		                        DUK_HOBJECT_FLAG_EXTENSIBLE |
-		                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
+		env = duk_hobjenv_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_OBJENV));
 		DUK_ASSERT(env != NULL);
 		DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) env) == NULL);
-		env->target = target;  /* always provideThis=true */
+		env->target = target; /* always provideThis=true */
 		DUK_HOBJECT_INCREF(thr, target);
 		env->has_this = 1;
 		DUK_HOBJENV_ASSERT_VALID(env);
 		DUK_DDD(DUK_DDDPRINT("environment for with binding: %!iO", env));
 
 		DUK_ASSERT(act == thr->callstack_curr);
 		DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) env) == NULL);
 		DUK_ASSERT(act->lex_env != NULL);
 		DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) env, act->lex_env);
-		act->lex_env = (duk_hobject *) env;  /* Now reachable. */
+		act->lex_env = (duk_hobject *) env; /* Now reachable. */
 		DUK_HOBJECT_INCREF(thr, (duk_hobject *) env);
 		/* Net refcount change to act->lex_env is 0: incref for env's
 		 * prototype, decref for act->lex_env overwrite.
 		 */
 
 		/* Set catcher lex_env active (affects unwind)
 		 * only when the whole setup is complete.
 		 */
-		cat = act->cat;  /* XXX: better to relookup? not mandatory because 'cat' is stable */
+		cat = act->cat; /* XXX: better to relookup? not mandatory because 'cat' is stable */
 		cat->flags |= DUK_CAT_FLAG_LEXENV_ACTIVE;
 	} else {
 		;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("TRYCATCH catcher: flags=0x%08lx, pc_base=%ld, "
 	                     "idx_base=%ld, h_varname=%!O",
 	                     (unsigned long) cat->flags,
-	                     (long) cat->pc_base, (long) cat->idx_base, (duk_heaphdr *) cat->h_varname));
+	                     (long) cat->pc_base,
+	                     (long) cat->idx_base,
+	                     (duk_heaphdr *) cat->h_varname));
 
 	duk_pop_unsafe(thr);
 }
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF duk_instr_t *duk__handle_op_endtry(duk_hthread *thr, duk_uint_fast32_t ins) {
 	duk_activation *act;
 	duk_catcher *cat;
@@ -78437,31 +79730,32 @@
 	pc_base = cat->pc_base;
 
 	if (DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
 		DUK_DDD(DUK_DDDPRINT("ENDTRY: finally part is active, jump through 2nd jump slot with 'normal continuation'"));
 
 		tv1 = thr->valstack + cat->idx_base;
 		DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top);
-		DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1);  /* side effects */
+		DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1); /* side effects */
 		tv1 = NULL;
 
 		tv1 = thr->valstack + cat->idx_base + 1;
 		DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top);
-		DUK_TVAL_SET_U32_UPDREF(thr, tv1, (duk_uint32_t) DUK_LJ_TYPE_NORMAL);  /* side effects */
+		DUK_TVAL_SET_U32_UPDREF(thr, tv1, (duk_uint32_t) DUK_LJ_TYPE_NORMAL); /* side effects */
 		tv1 = NULL;
 
 		DUK_CAT_CLEAR_FINALLY_ENABLED(cat);
 	} else {
-		DUK_DDD(DUK_DDDPRINT("ENDTRY: no finally part, dismantle catcher, jump through 2nd jump slot (to end of statement)"));
+		DUK_DDD(
+		    DUK_DDDPRINT("ENDTRY: no finally part, dismantle catcher, jump through 2nd jump slot (to end of statement)"));
 
-		duk_hthread_catcher_unwind_norz(thr, act);  /* lexenv may be set for 'with' binding */
+		duk_hthread_catcher_unwind_norz(thr, act); /* lexenv may be set for 'with' binding */
 		/* no need to unwind callstack */
 	}
 
-	return pc_base + 1;  /* new curr_pc value */
+	return pc_base + 1; /* new curr_pc value */
 }
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF duk_instr_t *duk__handle_op_endcatch(duk_hthread *thr, duk_uint_fast32_t ins) {
 	duk_activation *act;
 	duk_catcher *cat;
 	duk_tval *tv1;
 	duk_instr_t *pc_base;
@@ -78469,15 +79763,15 @@
 	DUK_UNREF(ins);
 
 	DUK_ASSERT(thr->callstack_top >= 1);
 	act = thr->callstack_curr;
 	DUK_ASSERT(act != NULL);
 	cat = act->cat;
 	DUK_ASSERT(cat != NULL);
-	DUK_ASSERT(!DUK_CAT_HAS_CATCH_ENABLED(cat));  /* cleared before entering catch part */
+	DUK_ASSERT(!DUK_CAT_HAS_CATCH_ENABLED(cat)); /* cleared before entering catch part */
 
 	if (DUK_CAT_HAS_LEXENV_ACTIVE(cat)) {
 		duk_hobject *prev_env;
 
 		/* 'with' binding has no catch clause, so can't be here unless a normal try-catch */
 		DUK_ASSERT(DUK_CAT_HAS_CATCH_BINDING_ENABLED(cat));
 		DUK_ASSERT(act->lex_env != NULL);
@@ -78485,47 +79779,50 @@
 		DUK_DDD(DUK_DDDPRINT("ENDCATCH: popping catcher part lexical environment"));
 
 		prev_env = act->lex_env;
 		DUK_ASSERT(prev_env != NULL);
 		act->lex_env = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, prev_env);
 		DUK_CAT_CLEAR_LEXENV_ACTIVE(cat);
 		DUK_HOBJECT_INCREF(thr, act->lex_env);
-		DUK_HOBJECT_DECREF(thr, prev_env);  /* side effects */
+		DUK_HOBJECT_DECREF(thr, prev_env); /* side effects */
 
 		DUK_ASSERT(act == thr->callstack_curr);
 		DUK_ASSERT(act != NULL);
 	}
 
 	pc_base = cat->pc_base;
 
 	if (DUK_CAT_HAS_FINALLY_ENABLED(cat)) {
 		DUK_DDD(DUK_DDDPRINT("ENDCATCH: finally part is active, jump through 2nd jump slot with 'normal continuation'"));
 
 		tv1 = thr->valstack + cat->idx_base;
 		DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top);
-		DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1);  /* side effects */
+		DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1); /* side effects */
 		tv1 = NULL;
 
 		tv1 = thr->valstack + cat->idx_base + 1;
 		DUK_ASSERT(tv1 >= thr->valstack && tv1 < thr->valstack_top);
-		DUK_TVAL_SET_U32_UPDREF(thr, tv1, (duk_uint32_t) DUK_LJ_TYPE_NORMAL);  /* side effects */
+		DUK_TVAL_SET_U32_UPDREF(thr, tv1, (duk_uint32_t) DUK_LJ_TYPE_NORMAL); /* side effects */
 		tv1 = NULL;
 
 		DUK_CAT_CLEAR_FINALLY_ENABLED(cat);
 	} else {
-		DUK_DDD(DUK_DDDPRINT("ENDCATCH: no finally part, dismantle catcher, jump through 2nd jump slot (to end of statement)"));
+		DUK_DDD(
+		    DUK_DDDPRINT("ENDCATCH: no finally part, dismantle catcher, jump through 2nd jump slot (to end of statement)"));
 
 		duk_hthread_catcher_unwind_norz(thr, act);
 		/* no need to unwind callstack */
 	}
 
-	return pc_base + 1;  /* new curr_pc value */
+	return pc_base + 1; /* new curr_pc value */
 }
 
-DUK_LOCAL DUK_EXEC_NOINLINE_PERF duk_small_uint_t duk__handle_op_endfin(duk_hthread *thr, duk_uint_fast32_t ins, duk_activation *entry_act) {
+DUK_LOCAL DUK_EXEC_NOINLINE_PERF duk_small_uint_t duk__handle_op_endfin(duk_hthread *thr,
+                                                                        duk_uint_fast32_t ins,
+                                                                        duk_activation *entry_act) {
 	duk_activation *act;
 	duk_tval *tv1;
 	duk_uint_t reg_catch;
 	duk_small_uint_t cont_type;
 	duk_small_uint_t ret_result;
 
 	DUK_ASSERT(thr->ptr_curr_pc == NULL);
@@ -78539,52 +79836,53 @@
 	 * an error.
 	 */
 
 	DUK_DDD(DUK_DDDPRINT("ENDFIN: completion value=%!T, type=%!T",
 	                     (duk_tval *) (thr->valstack_bottom + reg_catch + 0),
 	                     (duk_tval *) (thr->valstack_bottom + reg_catch + 1)));
 
-	tv1 = thr->valstack_bottom + reg_catch + 1;  /* type */
+	tv1 = thr->valstack_bottom + reg_catch + 1; /* type */
 	DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv1));
 #if defined(DUK_USE_FASTINT)
 	DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv1));
 	cont_type = (duk_small_uint_t) DUK_TVAL_GET_FASTINT_U32(tv1);
 #else
 	cont_type = (duk_small_uint_t) DUK_TVAL_GET_NUMBER(tv1);
 #endif
 
-	tv1--;  /* value */
+	tv1--; /* value */
 
 	switch (cont_type) {
 	case DUK_LJ_TYPE_NORMAL: {
 		DUK_DDD(DUK_DDDPRINT("ENDFIN: finally part finishing with 'normal' (non-abrupt) completion -> "
 		                     "dismantle catcher, resume execution after ENDFIN"));
 
 		duk_hthread_catcher_unwind_norz(thr, act);
 		/* no need to unwind callstack */
-		return 0;  /* restart execution */
+		return 0; /* restart execution */
 	}
 	case DUK_LJ_TYPE_RETURN: {
 		DUK_DDD(DUK_DDDPRINT("ENDFIN: finally part finishing with 'return' complation -> dismantle "
-		                     "catcher, handle return, lj.value1=%!T", tv1));
+		                     "catcher, handle return, lj.value1=%!T",
+		                     tv1));
 
 		/* Not necessary to unwind catch stack: return handling will
 		 * do it.  The finally flag of 'cat' is no longer set.  The
 		 * catch flag may be set, but it's not checked by return handling.
 		 */
 
 		duk_push_tval(thr, tv1);
 		ret_result = duk__handle_return(thr, entry_act);
 		if (ret_result == DUK__RETHAND_RESTART) {
-			return 0;  /* restart execution */
+			return 0; /* restart execution */
 		}
 		DUK_ASSERT(ret_result == DUK__RETHAND_FINISHED);
 
 		DUK_DDD(DUK_DDDPRINT("exiting executor after ENDFIN and RETURN (pseudo) longjmp type"));
-		return 1;  /* exit executor */
+		return 1; /* exit executor */
 	}
 	case DUK_LJ_TYPE_BREAK:
 	case DUK_LJ_TYPE_CONTINUE: {
 		duk_uint_t label_id;
 		duk_small_uint_t lj_type;
 
 		/* Not necessary to unwind catch stack: break/continue
@@ -78598,25 +79896,25 @@
 		DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv1));
 		label_id = (duk_small_uint_t) DUK_TVAL_GET_FASTINT_U32(tv1);
 #else
 		label_id = (duk_small_uint_t) DUK_TVAL_GET_NUMBER(tv1);
 #endif
 		lj_type = cont_type;
 		duk__handle_break_or_continue(thr, label_id, lj_type);
-		return 0;  /* restart execution */
+		return 0; /* restart execution */
 	}
 	default: {
 		DUK_DDD(DUK_DDDPRINT("ENDFIN: finally part finishing with abrupt completion, lj_type=%ld -> "
 		                     "dismantle catcher, re-throw error",
 		                     (long) cont_type));
 
 		duk_err_setup_ljstate1(thr, (duk_small_uint_t) cont_type, tv1);
 		/* No debugger Throw notify check on purpose (rethrow). */
 
-		DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL);  /* always in executor */
+		DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL); /* always in executor */
 		duk_err_longjmp(thr);
 		DUK_UNREACHABLE();
 	}
 	}
 
 	DUK_UNREACHABLE();
 	return 0;
@@ -78641,15 +79939,15 @@
 
 	if (duk_is_null_or_undefined(thr, (duk_idx_t) c)) {
 		duk_push_null(thr);
 		duk_replace(thr, (duk_idx_t) b);
 	} else {
 		duk_dup(thr, (duk_idx_t) c);
 		duk_to_object(thr, -1);
-		duk_hobject_enumerator_create(thr, 0 /*enum_flags*/);  /* [ ... val ] --> [ ... enum ] */
+		duk_hobject_enumerator_create(thr, 0 /*enum_flags*/); /* [ ... val ] --> [ ... enum ] */
 		duk_replace(thr, (duk_idx_t) b);
 	}
 }
 
 DUK_LOCAL DUK_EXEC_NOINLINE_PERF duk_small_uint_t duk__handle_op_nextenum(duk_hthread *thr, duk_uint_fast32_t ins) {
 	duk_small_uint_t b;
 	duk_small_uint_t c;
@@ -78673,21 +79971,20 @@
 	                     (duk_tval *) duk_get_tval(thr, (duk_idx_t) c)));
 
 	if (duk_is_object(thr, (duk_idx_t) c)) {
 		/* XXX: assert 'c' is an enumerator */
 		duk_dup(thr, (duk_idx_t) c);
 		if (duk_hobject_enumerator_next(thr, 0 /*get_value*/)) {
 			/* [ ... enum ] -> [ ... next_key ] */
-			DUK_DDD(DUK_DDDPRINT("enum active, next key is %!T, skip jump slot ",
-			                     (duk_tval *) duk_get_tval(thr, -1)));
+			DUK_DDD(DUK_DDDPRINT("enum active, next key is %!T, skip jump slot ", (duk_tval *) duk_get_tval(thr, -1)));
 			pc_skip = 1;
 		} else {
 			/* [ ... enum ] -> [ ... ] */
 			DUK_DDD(DUK_DDDPRINT("enum finished, execute jump slot"));
-			DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));  /* valstack policy */
+			DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top)); /* valstack policy */
 			thr->valstack_top++;
 		}
 		duk_replace(thr, (duk_idx_t) b);
 	} else {
 		/* 'null' enumerator case -> behave as with an empty enumerator */
 		DUK_ASSERT(duk_is_null(thr, (duk_idx_t) c));
 		DUK_DDD(DUK_DDDPRINT("enum is null, execute jump slot"));
@@ -78699,15 +79996,15 @@
 /*
  *  Call handling helpers.
  */
 
 DUK_LOCAL duk_bool_t duk__executor_handle_call(duk_hthread *thr, duk_idx_t idx, duk_idx_t nargs, duk_small_uint_t call_flags) {
 	duk_bool_t rc;
 
-	duk_set_top_unsafe(thr, (duk_idx_t) (idx + nargs + 2));   /* [ ... func this arg1 ... argN ] */
+	duk_set_top_unsafe(thr, (duk_idx_t) (idx + nargs + 2)); /* [ ... func this arg1 ... argN ] */
 
 	/* Attempt an Ecma-to-Ecma call setup.  If the call
 	 * target is (directly or indirectly) Reflect.construct(),
 	 * the call may change into a constructor call on the fly.
 	 */
 	rc = (duk_bool_t) duk_handle_call_unprotected(thr, idx, call_flags);
 	if (rc != 0) {
@@ -78753,120 +80050,129 @@
  *  and volatile.
  */
 
 /* Presence of 'fun' is config based, there's a marginal performance
  * difference and the best option is architecture dependent.
  */
 #if defined(DUK_USE_EXEC_FUN_LOCAL)
-#define DUK__FUN()          fun
+#define DUK__FUN() fun
 #else
-#define DUK__FUN()          ((duk_hcompfunc *) DUK_ACT_GET_FUNC((thr)->callstack_curr))
+#define DUK__FUN() ((duk_hcompfunc *) DUK_ACT_GET_FUNC((thr)->callstack_curr))
 #endif
 
 /* Strict flag. */
-#define DUK__STRICT()       ((duk_small_uint_t) DUK_HOBJECT_HAS_STRICT((duk_hobject *) DUK__FUN()))
+#define DUK__STRICT() ((duk_small_uint_t) DUK_HOBJECT_HAS_STRICT((duk_hobject *) DUK__FUN()))
 
 /* Reg/const access macros: these are very footprint and performance sensitive
  * so modify with care.  Arguments are sometimes evaluated multiple times which
  * is not ideal.
  */
-#define DUK__REG(x)         (*(thr->valstack_bottom + (x)))
-#define DUK__REGP(x)        (thr->valstack_bottom + (x))
-#define DUK__CONST(x)       (*(consts + (x)))
-#define DUK__CONSTP(x)      (consts + (x))
+#define DUK__REG(x)    (*(thr->valstack_bottom + (x)))
+#define DUK__REGP(x)   (thr->valstack_bottom + (x))
+#define DUK__CONST(x)  (*(consts + (x)))
+#define DUK__CONSTP(x) (consts + (x))
 
 /* Reg/const access macros which take the 32-bit instruction and avoid an
  * explicit field decoding step by using shifts and masks.  These must be
  * kept in sync with duk_js_bytecode.h.  The shift/mask values are chosen
  * so that 'ins' can be shifted and masked and used as a -byte- offset
  * instead of a duk_tval offset which needs further shifting (which is an
  * issue on some, but not all, CPUs).
  */
-#define DUK__RCBIT_B           DUK_BC_REGCONST_B
-#define DUK__RCBIT_C           DUK_BC_REGCONST_C
+#define DUK__RCBIT_B DUK_BC_REGCONST_B
+#define DUK__RCBIT_C DUK_BC_REGCONST_C
 #if defined(DUK_USE_EXEC_REGCONST_OPTIMIZE)
 #if defined(DUK_USE_PACKED_TVAL)
-#define DUK__TVAL_SHIFT        3  /* sizeof(duk_tval) == 8 */
+#define DUK__TVAL_SHIFT 3 /* sizeof(duk_tval) == 8 */
 #else
-#define DUK__TVAL_SHIFT        4  /* sizeof(duk_tval) == 16; not always the case so also asserted for */
+#define DUK__TVAL_SHIFT 4 /* sizeof(duk_tval) == 16; not always the case so also asserted for */
 #endif
-#define DUK__SHIFT_A           (DUK_BC_SHIFT_A - DUK__TVAL_SHIFT)
-#define DUK__SHIFT_B           (DUK_BC_SHIFT_B - DUK__TVAL_SHIFT)
-#define DUK__SHIFT_C           (DUK_BC_SHIFT_C - DUK__TVAL_SHIFT)
-#define DUK__SHIFT_BC          (DUK_BC_SHIFT_BC - DUK__TVAL_SHIFT)
-#define DUK__MASK_A            (DUK_BC_UNSHIFTED_MASK_A << DUK__TVAL_SHIFT)
-#define DUK__MASK_B            (DUK_BC_UNSHIFTED_MASK_B << DUK__TVAL_SHIFT)
-#define DUK__MASK_C            (DUK_BC_UNSHIFTED_MASK_C << DUK__TVAL_SHIFT)
-#define DUK__MASK_BC           (DUK_BC_UNSHIFTED_MASK_BC << DUK__TVAL_SHIFT)
-#define DUK__BYTEOFF_A(ins)    (((ins) >> DUK__SHIFT_A) & DUK__MASK_A)
-#define DUK__BYTEOFF_B(ins)    (((ins) >> DUK__SHIFT_B) & DUK__MASK_B)
-#define DUK__BYTEOFF_C(ins)    (((ins) >> DUK__SHIFT_C) & DUK__MASK_C)
-#define DUK__BYTEOFF_BC(ins)   (((ins) >> DUK__SHIFT_BC) & DUK__MASK_BC)
-
-#define DUK__REGP_A(ins)       ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_A((ins))))
-#define DUK__REGP_B(ins)       ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_B((ins))))
-#define DUK__REGP_C(ins)       ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_C((ins))))
-#define DUK__REGP_BC(ins)      ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_BC((ins))))
-#define DUK__CONSTP_A(ins)     ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_A((ins))))
-#define DUK__CONSTP_B(ins)     ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_B((ins))))
-#define DUK__CONSTP_C(ins)     ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_C((ins))))
-#define DUK__CONSTP_BC(ins)    ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_BC((ins))))
-#define DUK__REGCONSTP_B(ins)  ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & DUK__RCBIT_B) ? consts : thr->valstack_bottom) + DUK__BYTEOFF_B((ins))))
-#define DUK__REGCONSTP_C(ins)  ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) & DUK__RCBIT_C) ? consts : thr->valstack_bottom) + DUK__BYTEOFF_C((ins))))
-#else  /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
+#define DUK__SHIFT_A         (DUK_BC_SHIFT_A - DUK__TVAL_SHIFT)
+#define DUK__SHIFT_B         (DUK_BC_SHIFT_B - DUK__TVAL_SHIFT)
+#define DUK__SHIFT_C         (DUK_BC_SHIFT_C - DUK__TVAL_SHIFT)
+#define DUK__SHIFT_BC        (DUK_BC_SHIFT_BC - DUK__TVAL_SHIFT)
+#define DUK__MASK_A          (DUK_BC_UNSHIFTED_MASK_A << DUK__TVAL_SHIFT)
+#define DUK__MASK_B          (DUK_BC_UNSHIFTED_MASK_B << DUK__TVAL_SHIFT)
+#define DUK__MASK_C          (DUK_BC_UNSHIFTED_MASK_C << DUK__TVAL_SHIFT)
+#define DUK__MASK_BC         (DUK_BC_UNSHIFTED_MASK_BC << DUK__TVAL_SHIFT)
+#define DUK__BYTEOFF_A(ins)  (((ins) >> DUK__SHIFT_A) & DUK__MASK_A)
+#define DUK__BYTEOFF_B(ins)  (((ins) >> DUK__SHIFT_B) & DUK__MASK_B)
+#define DUK__BYTEOFF_C(ins)  (((ins) >> DUK__SHIFT_C) & DUK__MASK_C)
+#define DUK__BYTEOFF_BC(ins) (((ins) >> DUK__SHIFT_BC) & DUK__MASK_BC)
+
+#define DUK__REGP_A(ins)    ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_A((ins))))
+#define DUK__REGP_B(ins)    ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_B((ins))))
+#define DUK__REGP_C(ins)    ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_C((ins))))
+#define DUK__REGP_BC(ins)   ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + DUK__BYTEOFF_BC((ins))))
+#define DUK__CONSTP_A(ins)  ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_A((ins))))
+#define DUK__CONSTP_B(ins)  ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_B((ins))))
+#define DUK__CONSTP_C(ins)  ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_C((ins))))
+#define DUK__CONSTP_BC(ins) ((duk_tval *) (void *) ((duk_uint8_t *) consts + DUK__BYTEOFF_BC((ins))))
+#define DUK__REGCONSTP_B(ins) \
+	((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &DUK__RCBIT_B) ? consts : thr->valstack_bottom) + DUK__BYTEOFF_B((ins))))
+#define DUK__REGCONSTP_C(ins) \
+	((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &DUK__RCBIT_C) ? consts : thr->valstack_bottom) + DUK__BYTEOFF_C((ins))))
+#else /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
 /* Safe alternatives, no assumption about duk_tval size. */
-#define DUK__REGP_A(ins)       DUK__REGP(DUK_DEC_A((ins)))
-#define DUK__REGP_B(ins)       DUK__REGP(DUK_DEC_B((ins)))
-#define DUK__REGP_C(ins)       DUK__REGP(DUK_DEC_C((ins)))
-#define DUK__REGP_BC(ins)      DUK__REGP(DUK_DEC_BC((ins)))
-#define DUK__CONSTP_A(ins)     DUK__CONSTP(DUK_DEC_A((ins)))
-#define DUK__CONSTP_B(ins)     DUK__CONSTP(DUK_DEC_B((ins)))
-#define DUK__CONSTP_C(ins)     DUK__CONSTP(DUK_DEC_C((ins)))
-#define DUK__CONSTP_BC(ins)    DUK__CONSTP(DUK_DEC_BC((ins)))
-#define DUK__REGCONSTP_B(ins)  ((((ins) & DUK__RCBIT_B) ? consts : thr->valstack_bottom) + DUK_DEC_B((ins)))
-#define DUK__REGCONSTP_C(ins)  ((((ins) & DUK__RCBIT_C) ? consts : thr->valstack_bottom) + DUK_DEC_C((ins)))
-#endif  /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
+#define DUK__REGP_A(ins)      DUK__REGP(DUK_DEC_A((ins)))
+#define DUK__REGP_B(ins)      DUK__REGP(DUK_DEC_B((ins)))
+#define DUK__REGP_C(ins)      DUK__REGP(DUK_DEC_C((ins)))
+#define DUK__REGP_BC(ins)     DUK__REGP(DUK_DEC_BC((ins)))
+#define DUK__CONSTP_A(ins)    DUK__CONSTP(DUK_DEC_A((ins)))
+#define DUK__CONSTP_B(ins)    DUK__CONSTP(DUK_DEC_B((ins)))
+#define DUK__CONSTP_C(ins)    DUK__CONSTP(DUK_DEC_C((ins)))
+#define DUK__CONSTP_BC(ins)   DUK__CONSTP(DUK_DEC_BC((ins)))
+#define DUK__REGCONSTP_B(ins) ((((ins) &DUK__RCBIT_B) ? consts : thr->valstack_bottom) + DUK_DEC_B((ins)))
+#define DUK__REGCONSTP_C(ins) ((((ins) &DUK__RCBIT_C) ? consts : thr->valstack_bottom) + DUK_DEC_C((ins)))
+#endif /* DUK_USE_EXEC_REGCONST_OPTIMIZE */
 
 #if defined(DUK_USE_VERBOSE_EXECUTOR_ERRORS)
-#define DUK__INTERNAL_ERROR(msg)  do { \
+#define DUK__INTERNAL_ERROR(msg) \
+	do { \
 		DUK_ERROR_ERROR(thr, (msg)); \
 		DUK_WO_NORETURN(return;); \
 	} while (0)
 #else
-#define DUK__INTERNAL_ERROR(msg)  do { \
+#define DUK__INTERNAL_ERROR(msg) \
+	do { \
 		goto internal_error; \
 	} while (0)
 #endif
 
-#define DUK__SYNC_CURR_PC()  do { \
+#define DUK__SYNC_CURR_PC() \
+	do { \
 		duk_activation *duk__act; \
 		duk__act = thr->callstack_curr; \
 		duk__act->curr_pc = curr_pc; \
 	} while (0)
-#define DUK__SYNC_AND_NULL_CURR_PC()  do { \
+#define DUK__SYNC_AND_NULL_CURR_PC() \
+	do { \
 		duk_activation *duk__act; \
 		duk__act = thr->callstack_curr; \
 		duk__act->curr_pc = curr_pc; \
 		thr->ptr_curr_pc = NULL; \
 	} while (0)
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-#define DUK__LOOKUP_INDIRECT(idx) do { \
+#define DUK__LOOKUP_INDIRECT(idx) \
+	do { \
 		(idx) = (duk_uint_fast_t) duk_get_uint(thr, (duk_idx_t) (idx)); \
 	} while (0)
 #elif defined(DUK_USE_FASTINT)
-#define DUK__LOOKUP_INDIRECT(idx) do { \
+#define DUK__LOOKUP_INDIRECT(idx) \
+	do { \
 		duk_tval *tv_ind; \
 		tv_ind = DUK__REGP((idx)); \
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv_ind)); \
-		DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv_ind));  /* compiler guarantees */ \
+		DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv_ind)); /* compiler guarantees */ \
 		(idx) = (duk_uint_fast_t) DUK_TVAL_GET_FASTINT_U32(tv_ind); \
 	} while (0)
 #else
-#define DUK__LOOKUP_INDIRECT(idx) do { \
+#define DUK__LOOKUP_INDIRECT(idx) \
+	do { \
 		duk_tval *tv_ind; \
 		tv_ind = DUK__REGP(idx); \
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv_ind)); \
 		idx = (duk_uint_fast_t) DUK_TVAL_GET_NUMBER(tv_ind); \
 	} while (0)
 #endif
 
@@ -78911,16 +80217,16 @@
 		DUK_REFZERO_CHECK_SLOW(heap->curr_thread);
 	} else {
 		/* If an error is propagated, don't run refzero checks here.
 		 * The next catcher will deal with that.  Pf_prevent_count
 		 * will be re-bumped by the longjmp.
 		 */
 
-		DUK_ASSERT(lj_ret == DUK__LONGJMP_RETHROW);  /* Rethrow error to calling state. */
-		DUK_ASSERT(heap->lj.jmpbuf_ptr == entry_jmpbuf_ptr);  /* Longjmp handling has restored jmpbuf_ptr. */
+		DUK_ASSERT(lj_ret == DUK__LONGJMP_RETHROW); /* Rethrow error to calling state. */
+		DUK_ASSERT(heap->lj.jmpbuf_ptr == entry_jmpbuf_ptr); /* Longjmp handling has restored jmpbuf_ptr. */
 
 		/* Thread may have changed, e.g. YIELD converted to THROW. */
 		duk_err_longjmp(heap->curr_thread);
 		DUK_UNREACHABLE();
 	}
 }
 
@@ -78935,15 +80241,15 @@
 	duk_heap *heap;
 	volatile duk_bool_t delayed_catch_setup = 0;
 
 	DUK_ASSERT(exec_thr != NULL);
 	DUK_ASSERT(exec_thr->heap != NULL);
 	DUK_ASSERT(exec_thr->heap->curr_thread != NULL);
 	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR((duk_heaphdr *) exec_thr);
-	DUK_ASSERT(exec_thr->callstack_top >= 1);  /* at least one activation, ours */
+	DUK_ASSERT(exec_thr->callstack_top >= 1); /* at least one activation, ours */
 	DUK_ASSERT(exec_thr->callstack_curr != NULL);
 	DUK_ASSERT(DUK_ACT_GET_FUNC(exec_thr->callstack_curr) != NULL);
 	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(DUK_ACT_GET_FUNC(exec_thr->callstack_curr)));
 
 	DUK_GC_TORTURE(exec_thr->heap);
 
 	entry_thread = exec_thr;
@@ -79001,15 +80307,15 @@
 			DUK_DDD(DUK_DDDPRINT("longjmp caught by bytecode executor"));
 			DUK_STATS_INC(exec_thr->heap, stats_exec_throw);
 
 			duk__handle_executor_error(heap,
 			                           entry_act,
 			                           entry_call_recursion_depth,
 			                           entry_jmpbuf_ptr,
-						   &delayed_catch_setup);
+			                           &delayed_catch_setup);
 		}
 #if defined(DUK_USE_CPP_EXCEPTIONS)
 		catch (duk_fatal_exception &exc) {
 			DUK_D(DUK_DPRINT("rethrow duk_fatal_exception"));
 			DUK_UNREF(exc);
 			throw;
 		} catch (std::exception &exc) {
@@ -79017,24 +80323,27 @@
 			if (!what) {
 				what = "unknown";
 			}
 			DUK_D(DUK_DPRINT("unexpected c++ std::exception (perhaps thrown by user code)"));
 			DUK_STATS_INC(exec_thr->heap, stats_exec_throw);
 			try {
 				DUK_ASSERT(heap->curr_thread != NULL);
-				DUK_ERROR_FMT1(heap->curr_thread, DUK_ERR_TYPE_ERROR, "caught invalid c++ std::exception '%s' (perhaps thrown by user code)", what);
+				DUK_ERROR_FMT1(heap->curr_thread,
+				               DUK_ERR_TYPE_ERROR,
+				               "caught invalid c++ std::exception '%s' (perhaps thrown by user code)",
+				               what);
 				DUK_WO_NORETURN(return;);
 			} catch (duk_internal_exception exc) {
 				DUK_D(DUK_DPRINT("caught api error thrown from unexpected c++ std::exception"));
 				DUK_UNREF(exc);
 				duk__handle_executor_error(heap,
 				                           entry_act,
 				                           entry_call_recursion_depth,
 				                           entry_jmpbuf_ptr,
-							   &delayed_catch_setup);
+				                           &delayed_catch_setup);
 			}
 		} catch (...) {
 			DUK_D(DUK_DPRINT("unexpected c++ exception (perhaps thrown by user code)"));
 			DUK_STATS_INC(exec_thr->heap, stats_exec_throw);
 			try {
 				DUK_ASSERT(heap->curr_thread != NULL);
 				DUK_ERROR_TYPE(heap->curr_thread, "caught invalid c++ exception (perhaps thrown by user code)");
@@ -79042,15 +80351,15 @@
 			} catch (duk_internal_exception exc) {
 				DUK_D(DUK_DPRINT("caught api error thrown from unexpected c++ exception"));
 				DUK_UNREF(exc);
 				duk__handle_executor_error(heap,
 				                           entry_act,
 				                           entry_call_recursion_depth,
 				                           entry_jmpbuf_ptr,
-							   &delayed_catch_setup);
+				                           &delayed_catch_setup);
 			}
 		}
 #endif
 	}
 
 	DUK_WO_NORETURN(return;);
 }
@@ -79058,35 +80367,35 @@
 /* Inner executor, performance critical. */
 DUK_LOCAL DUK_NOINLINE DUK_HOT void duk__js_execute_bytecode_inner(duk_hthread *entry_thread, duk_activation *entry_act) {
 	/* Current PC, accessed by other functions through thr->ptr_to_curr_pc.
 	 * Critical for performance.  It would be safest to make this volatile,
 	 * but that eliminates performance benefits; aliasing guarantees
 	 * should be enough though.
 	 */
-	duk_instr_t *curr_pc;         /* bytecode has a stable pointer */
+	duk_instr_t *curr_pc; /* bytecode has a stable pointer */
 
 	/* Hot variables for interpretation.  Critical for performance,
 	 * but must add sparingly to minimize register shuffling.
 	 */
-	duk_hthread *thr;             /* stable */
-	duk_tval *consts;             /* stable */
+	duk_hthread *thr; /* stable */
+	duk_tval *consts; /* stable */
 	duk_uint_fast32_t ins;
 	/* 'funcs' is quite rarely used, so no local for it */
 #if defined(DUK_USE_EXEC_FUN_LOCAL)
 	duk_hcompfunc *fun;
 #else
 	/* 'fun' is quite rarely used, so no local for it */
 #endif
 
 #if defined(DUK_USE_INTERRUPT_COUNTER)
 	duk_int_t int_ctr;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
-	duk_size_t valstack_top_base;    /* valstack top, should match before interpreting each op (no leftovers) */
+	duk_size_t valstack_top_base; /* valstack top, should match before interpreting each op (no leftovers) */
 #endif
 
 	/* Optimized reg/const access macros assume sizeof(duk_tval) to be
 	 * either 8 or 16.  Heap allocation checks this even without asserts
 	 * enabled now because it can't be autodetected in duk_config.h.
 	 */
 #if 1
@@ -79134,15 +80443,15 @@
 	 *
 	 *  The following are not assumed to have stable pointers at all:
 	 *    - the value stack (registers) of the current thread
 	 *
 	 *  See execution.rst for discussion.
 	 */
 
- restart_execution:
+restart_execution:
 
 	/* Lookup current thread; use the stable 'entry_thread' for this to
 	 * avoid clobber warnings.  Any valid, reachable 'thr' value would be
 	 * fine for this, so using 'entry_thread' is just to silence warnings.
 	 */
 	thr = entry_thread->heap->curr_thread;
 	DUK_ASSERT(thr != NULL);
@@ -79175,15 +80484,15 @@
 
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 		if (DUK_UNLIKELY(duk_debug_is_attached(thr->heap) && !thr->heap->dbg_processing)) {
 			duk__executor_recheck_debugger(thr, act, fun);
 			DUK_ASSERT(act == thr->callstack_curr);
 			DUK_ASSERT(act != NULL);
 		}
-#endif  /* DUK_USE_DEBUGGER_SUPPORT */
+#endif /* DUK_USE_DEBUGGER_SUPPORT */
 
 #if defined(DUK_USE_ASSERTIONS)
 		valstack_top_base = (duk_size_t) (thr->valstack_top - thr->valstack);
 #endif
 
 		/* Set up curr_pc for opcode dispatch. */
 		curr_pc = act->curr_pc;
@@ -79239,50 +80548,51 @@
 			/* Forced restart caused by a function return; must recheck
 			 * debugger breakpoints before checking line transitions,
 			 * see GH-303.  Restart and then handle interrupt_counter
 			 * zero again.
 			 */
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 			if (thr->heap->dbg_force_restart) {
-				DUK_DD(DUK_DDPRINT("dbg_force_restart flag forced restart execution"));  /* GH-303 */
+				DUK_DD(DUK_DDPRINT("dbg_force_restart flag forced restart execution")); /* GH-303 */
 				thr->heap->dbg_force_restart = 0;
 				goto restart_execution;
 			}
 #endif
 
 			exec_int_ret = duk__executor_interrupt(thr);
 			if (exec_int_ret == DUK__INT_RESTART) {
 				/* curr_pc synced back above */
 				goto restart_execution;
 			}
 		}
-#endif  /* DUK_USE_INTERRUPT_COUNTER */
+#endif /* DUK_USE_INTERRUPT_COUNTER */
 #if defined(DUK_USE_INTERRUPT_COUNTER) && defined(DUK_USE_DEBUG)
 		/* For cross-checking during development: ensure dispatch count
 		 * matches cumulative interrupt counter init value sums.
 		 */
 		thr->heap->inst_count_exec++;
 #endif
 
 #if defined(DUK_USE_ASSERTIONS) || defined(DUK_USE_DEBUG)
 		{
 			duk_activation *act;
 			act = thr->callstack_curr;
 			DUK_ASSERT(curr_pc >= DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, DUK__FUN()));
 			DUK_ASSERT(curr_pc < DUK_HCOMPFUNC_GET_CODE_END(thr->heap, DUK__FUN()));
-			DUK_UNREF(act);  /* if debugging disabled */
+			DUK_UNREF(act); /* if debugging disabled */
 
-			DUK_DDD(DUK_DDDPRINT("executing bytecode: pc=%ld, ins=0x%08lx, op=%ld, valstack_top=%ld/%ld, nregs=%ld  -->  %!I",
-			                     (long) (curr_pc - DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, DUK__FUN())),
-			                     (unsigned long) *curr_pc,
-			                     (long) DUK_DEC_OP(*curr_pc),
-			                     (long) (thr->valstack_top - thr->valstack),
-			                     (long) (thr->valstack_end - thr->valstack),
-			                     (long) (DUK__FUN() ? DUK__FUN()->nregs : -1),
-			                     (duk_instr_t) *curr_pc));
+			DUK_DDD(DUK_DDDPRINT(
+			    "executing bytecode: pc=%ld, ins=0x%08lx, op=%ld, valstack_top=%ld/%ld, nregs=%ld  -->  %!I",
+			    (long) (curr_pc - DUK_HCOMPFUNC_GET_CODE_BASE(thr->heap, DUK__FUN())),
+			    (unsigned long) *curr_pc,
+			    (long) DUK_DEC_OP(*curr_pc),
+			    (long) (thr->valstack_top - thr->valstack),
+			    (long) (thr->valstack_end - thr->valstack),
+			    (long) (DUK__FUN() ? DUK__FUN()->nregs : -1),
+			    (duk_instr_t) *curr_pc));
 		}
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 		/* Quite heavy assert: check valstack policy.  Improper
 		 * shuffle instructions can write beyond valstack_top/end
 		 * so this check catches them in the act.
@@ -79311,32 +80621,43 @@
 
 		/* Switch based on opcode.  Cast to 8-bit unsigned value and
 		 * use a fully populated case clauses so that the compiler
 		 * will (at least usually) omit a bounds check.
 		 */
 		op = (duk_uint8_t) DUK_DEC_OP(ins);
 		switch (op) {
-
-		/* Some useful macros.  These access inner executor variables
-		 * directly so they only apply within the executor.
-		 */
+			/* Some useful macros.  These access inner executor variables
+			 * directly so they only apply within the executor.
+			 */
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-#define DUK__REPLACE_TOP_A_BREAK() { goto replace_top_a; }
-#define DUK__REPLACE_TOP_BC_BREAK() { goto replace_top_bc; }
-#define DUK__REPLACE_BOOL_A_BREAK(bval) { \
+#define DUK__REPLACE_TOP_A_BREAK() \
+	{ goto replace_top_a; }
+#define DUK__REPLACE_TOP_BC_BREAK() \
+	{ goto replace_top_bc; }
+#define DUK__REPLACE_BOOL_A_BREAK(bval) \
+	{ \
 		duk_bool_t duk__bval; \
 		duk__bval = (bval); \
 		DUK_ASSERT(duk__bval == 0 || duk__bval == 1); \
 		duk_push_boolean(thr, duk__bval); \
 		DUK__REPLACE_TOP_A_BREAK(); \
 	}
 #else
-#define DUK__REPLACE_TOP_A_BREAK() { DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_A(ins)); break; }
-#define DUK__REPLACE_TOP_BC_BREAK() { DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_BC(ins)); break; }
-#define DUK__REPLACE_BOOL_A_BREAK(bval) { \
+#define DUK__REPLACE_TOP_A_BREAK() \
+	{ \
+		DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_A(ins)); \
+		break; \
+	}
+#define DUK__REPLACE_TOP_BC_BREAK() \
+	{ \
+		DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_BC(ins)); \
+		break; \
+	}
+#define DUK__REPLACE_BOOL_A_BREAK(bval) \
+	{ \
 		duk_bool_t duk__bval; \
 		duk_tval *duk__tvdst; \
 		duk__bval = (bval); \
 		DUK_ASSERT(duk__bval == 0 || duk__bval == 1); \
 		duk__tvdst = DUK__REGP_A(ins); \
 		DUK_TVAL_SET_BOOLEAN_UPDREF(thr, duk__tvdst, duk__bval); \
 		break; \
@@ -79352,33 +80673,33 @@
 		 * they're currently intentionally not size optimized.
 		 */
 		case DUK_OP_LDREG: {
 			duk_tval *tv1, *tv2;
 
 			tv1 = DUK__REGP_A(ins);
 			tv2 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2);  /* side effects */
+			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2); /* side effects */
 			break;
 		}
 
 		case DUK_OP_STREG: {
 			duk_tval *tv1, *tv2;
 
 			tv1 = DUK__REGP_A(ins);
 			tv2 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv2, tv1);  /* side effects */
+			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv2, tv1); /* side effects */
 			break;
 		}
 
 		case DUK_OP_LDCONST: {
 			duk_tval *tv1, *tv2;
 
 			tv1 = DUK__REGP_A(ins);
 			tv2 = DUK__CONSTP_BC(ins);
-			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2);  /* side effects */
+			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2); /* side effects */
 			break;
 		}
 
 		/* LDINT and LDINTX are intended to load an arbitrary signed
 		 * 32-bit value.  Only an LDINT+LDINTX sequence is supported.
 		 * This also guarantees all values remain fastints.
 		 */
@@ -79390,26 +80711,26 @@
 			duk_push_int(thr, val);
 			DUK__REPLACE_TOP_A_BREAK();
 		}
 		case DUK_OP_LDINTX: {
 			duk_int32_t val;
 
 			val = (duk_int32_t) duk_get_int(thr, DUK_DEC_A(ins));
-			val = (val << DUK_BC_LDINTX_SHIFT) + (duk_int32_t) DUK_DEC_BC(ins);  /* no bias */
+			val = (val << DUK_BC_LDINTX_SHIFT) + (duk_int32_t) DUK_DEC_BC(ins); /* no bias */
 			duk_push_int(thr, val);
 			DUK__REPLACE_TOP_A_BREAK();
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_LDINT: {
 			duk_tval *tv1;
 			duk_int32_t val;
 
 			val = (duk_int32_t) DUK_DEC_BC(ins) - (duk_int32_t) DUK_BC_LDINT_BIAS;
 			tv1 = DUK__REGP_A(ins);
-			DUK_TVAL_SET_I32_UPDREF(thr, tv1, val);  /* side effects */
+			DUK_TVAL_SET_I32_UPDREF(thr, tv1, val); /* side effects */
 			break;
 		}
 		case DUK_OP_LDINTX: {
 			duk_tval *tv1;
 			duk_int32_t val;
 
 			tv1 = DUK__REGP_A(ins);
@@ -79417,19 +80738,20 @@
 #if defined(DUK_USE_FASTINT)
 			DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv1));
 			val = DUK_TVAL_GET_FASTINT_I32(tv1);
 #else
 			/* XXX: fast double-to-int conversion, we know number is integer in [-0x80000000,0xffffffff]. */
 			val = (duk_int32_t) DUK_TVAL_GET_NUMBER(tv1);
 #endif
-			val = (duk_int32_t) ((duk_uint32_t) val << DUK_BC_LDINTX_SHIFT) + (duk_int32_t) DUK_DEC_BC(ins);  /* no bias */
-			DUK_TVAL_SET_I32_UPDREF(thr, tv1, val);  /* side effects */
+			val =
+			    (duk_int32_t) ((duk_uint32_t) val << DUK_BC_LDINTX_SHIFT) + (duk_int32_t) DUK_DEC_BC(ins); /* no bias */
+			DUK_TVAL_SET_I32_UPDREF(thr, tv1, val); /* side effects */
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_LDTHIS: {
 			duk_push_this(thr);
 			DUK__REPLACE_TOP_BC_BREAK();
 		}
 		case DUK_OP_LDUNDEF: {
@@ -79444,54 +80766,54 @@
 			duk_push_true(thr);
 			DUK__REPLACE_TOP_BC_BREAK();
 		}
 		case DUK_OP_LDFALSE: {
 			duk_push_false(thr);
 			DUK__REPLACE_TOP_BC_BREAK();
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_LDTHIS: {
 			/* Note: 'this' may be bound to any value, not just an object */
 			duk_tval *tv1, *tv2;
 
 			tv1 = DUK__REGP_BC(ins);
-			tv2 = thr->valstack_bottom - 1;  /* 'this binding' is just under bottom */
+			tv2 = thr->valstack_bottom - 1; /* 'this binding' is just under bottom */
 			DUK_ASSERT(tv2 >= thr->valstack);
-			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2);  /* side effects */
+			DUK_TVAL_SET_TVAL_UPDREF_FAST(thr, tv1, tv2); /* side effects */
 			break;
 		}
 		case DUK_OP_LDUNDEF: {
 			duk_tval *tv1;
 
 			tv1 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1);  /* side effects */
+			DUK_TVAL_SET_UNDEFINED_UPDREF(thr, tv1); /* side effects */
 			break;
 		}
 		case DUK_OP_LDNULL: {
 			duk_tval *tv1;
 
 			tv1 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_NULL_UPDREF(thr, tv1);  /* side effects */
+			DUK_TVAL_SET_NULL_UPDREF(thr, tv1); /* side effects */
 			break;
 		}
 		case DUK_OP_LDTRUE: {
 			duk_tval *tv1;
 
 			tv1 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv1, 1);  /* side effects */
+			DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv1, 1); /* side effects */
 			break;
 		}
 		case DUK_OP_LDFALSE: {
 			duk_tval *tv1;
 
 			tv1 = DUK__REGP_BC(ins);
-			DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv1, 0);  /* side effects */
+			DUK_TVAL_SET_BOOLEAN_UPDREF(thr, tv1, 0); /* side effects */
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		case DUK_OP_BNOT: {
 			duk__vm_bitwise_not(thr, DUK_DEC_BC(ins), DUK_DEC_A(ins));
 			break;
 		}
 
 		case DUK_OP_LNOT: {
@@ -79501,49 +80823,49 @@
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_UNM:
 		case DUK_OP_UNP: {
 			duk__vm_arith_unary_op(thr, DUK_DEC_BC(ins), DUK_DEC_A(ins), op);
 			break;
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_UNM: {
 			duk__vm_arith_unary_op(thr, DUK_DEC_BC(ins), DUK_DEC_A(ins), DUK_OP_UNM);
 			break;
 		}
 		case DUK_OP_UNP: {
 			duk__vm_arith_unary_op(thr, DUK_DEC_BC(ins), DUK_DEC_A(ins), DUK_OP_UNP);
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_TYPEOF: {
 			duk_small_uint_t stridx;
 
 			stridx = duk_js_typeof_stridx(DUK__REGP_BC(ins));
 			DUK_ASSERT_STRIDX_VALID(stridx);
 			duk_push_hstring_stridx(thr, stridx);
 			DUK__REPLACE_TOP_A_BREAK();
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_TYPEOF: {
 			duk_tval *tv;
 			duk_small_uint_t stridx;
 			duk_hstring *h_str;
 
 			tv = DUK__REGP_BC(ins);
 			stridx = duk_js_typeof_stridx(tv);
 			DUK_ASSERT_STRIDX_VALID(stridx);
 			h_str = DUK_HTHREAD_GET_STRING(thr, stridx);
 			tv = DUK__REGP_A(ins);
 			DUK_TVAL_SET_STRING_UPDREF(thr, tv, h_str);
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		case DUK_OP_TYPEOFID: {
 			duk_small_uint_t stridx;
 #if !defined(DUK_USE_EXEC_PREFER_SIZE)
 			duk_hstring *h_str;
 #endif
 			duk_activation *act;
@@ -79553,60 +80875,64 @@
 			/* A -> target register
 			 * BC -> constant index of identifier name
 			 */
 
 			tv = DUK__CONSTP_BC(ins);
 			DUK_ASSERT(DUK_TVAL_IS_STRING(tv));
 			name = DUK_TVAL_GET_STRING(tv);
-			tv = NULL;  /* lookup has side effects */
+			tv = NULL; /* lookup has side effects */
 			act = thr->callstack_curr;
 			if (duk_js_getvar_activation(thr, act, name, 0 /*throw*/)) {
 				/* -> [... val this] */
 				tv = DUK_GET_TVAL_NEGIDX(thr, -2);
 				stridx = duk_js_typeof_stridx(tv);
-				tv = NULL;  /* no longer needed */
+				tv = NULL; /* no longer needed */
 				duk_pop_2_unsafe(thr);
 			} else {
 				/* unresolvable, no stack changes */
 				stridx = DUK_STRIDX_LC_UNDEFINED;
 			}
 			DUK_ASSERT_STRIDX_VALID(stridx);
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 			duk_push_hstring_stridx(thr, stridx);
 			DUK__REPLACE_TOP_A_BREAK();
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 			h_str = DUK_HTHREAD_GET_STRING(thr, stridx);
 			tv = DUK__REGP_A(ins);
 			DUK_TVAL_SET_STRING_UPDREF(thr, tv, h_str);
 			break;
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 		}
 
 		/* Equality: E5 Sections 11.9.1, 11.9.3 */
 
-#define DUK__EQ_BODY(barg,carg) { \
+#define DUK__EQ_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_equals(thr, (barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
-#define DUK__NEQ_BODY(barg,carg) { \
+#define DUK__NEQ_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_equals(thr, (barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		tmp ^= 1; \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
-#define DUK__SEQ_BODY(barg,carg) { \
+#define DUK__SEQ_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_strict_equals((barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
-#define DUK__SNEQ_BODY(barg,carg) { \
+#define DUK__SNEQ_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_strict_equals((barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		tmp ^= 1; \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
@@ -79626,15 +80952,15 @@
 		case DUK_OP_SEQ_CC:
 			DUK__SEQ_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
 		case DUK_OP_SNEQ_RR:
 		case DUK_OP_SNEQ_CR:
 		case DUK_OP_SNEQ_RC:
 		case DUK_OP_SNEQ_CC:
 			DUK__SNEQ_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_EQ_RR:
 			DUK__EQ_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_EQ_CR:
 			DUK__EQ_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_EQ_RC:
 			DUK__EQ_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_EQ_CC:
@@ -79659,26 +80985,27 @@
 			DUK__SNEQ_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_SNEQ_CR:
 			DUK__SNEQ_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_SNEQ_RC:
 			DUK__SNEQ_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_SNEQ_CC:
 			DUK__SNEQ_BODY(DUK__CONSTP_B(ins), DUK__CONSTP_C(ins));
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
-#define DUK__COMPARE_BODY(arg1,arg2,flags) { \
+#define DUK__COMPARE_BODY(arg1, arg2, flags) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_compare_helper(thr, (arg1), (arg2), (flags)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
-#define DUK__GT_BODY(barg,carg) DUK__COMPARE_BODY((carg), (barg), 0)
-#define DUK__GE_BODY(barg,carg) DUK__COMPARE_BODY((barg), (carg), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST | DUK_COMPARE_FLAG_NEGATE)
-#define DUK__LT_BODY(barg,carg) DUK__COMPARE_BODY((barg), (carg), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST)
-#define DUK__LE_BODY(barg,carg) DUK__COMPARE_BODY((carg), (barg), DUK_COMPARE_FLAG_NEGATE)
+#define DUK__GT_BODY(barg, carg) DUK__COMPARE_BODY((carg), (barg), 0)
+#define DUK__GE_BODY(barg, carg) DUK__COMPARE_BODY((barg), (carg), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST | DUK_COMPARE_FLAG_NEGATE)
+#define DUK__LT_BODY(barg, carg) DUK__COMPARE_BODY((barg), (carg), DUK_COMPARE_FLAG_EVAL_LEFT_FIRST)
+#define DUK__LE_BODY(barg, carg) DUK__COMPARE_BODY((carg), (barg), DUK_COMPARE_FLAG_NEGATE)
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_GT_RR:
 		case DUK_OP_GT_CR:
 		case DUK_OP_GT_RC:
 		case DUK_OP_GT_CC:
 			DUK__GT_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
 		case DUK_OP_GE_RR:
@@ -79692,15 +81019,15 @@
 		case DUK_OP_LT_CC:
 			DUK__LT_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
 		case DUK_OP_LE_RR:
 		case DUK_OP_LE_CR:
 		case DUK_OP_LE_RC:
 		case DUK_OP_LE_CC:
 			DUK__LE_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_GT_RR:
 			DUK__GT_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_GT_CR:
 			DUK__GT_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_GT_RC:
 			DUK__GT_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_GT_CC:
@@ -79725,15 +81052,15 @@
 			DUK__LE_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_LE_CR:
 			DUK__LE_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_LE_RC:
 			DUK__LE_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_LE_CC:
 			DUK__LE_BODY(DUK__CONSTP_B(ins), DUK__CONSTP_C(ins));
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		/* No size optimized variant at present for IF. */
 		case DUK_OP_IFTRUE_R: {
 			if (duk_js_toboolean(DUK__REGP_BC(ins)) != 0) {
 				curr_pc++;
 			}
 			break;
@@ -79762,15 +81089,15 @@
 		case DUK_OP_ADD_CR:
 		case DUK_OP_ADD_RC:
 		case DUK_OP_ADD_CC: {
 			/* XXX: could leave value on stack top and goto replace_top_a; */
 			duk__vm_arith_add(thr, DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins), DUK_DEC_A(ins));
 			break;
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_ADD_RR: {
 			duk__vm_arith_add(thr, DUK__REGP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins));
 			break;
 		}
 		case DUK_OP_ADD_CR: {
 			duk__vm_arith_add(thr, DUK__CONSTP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins));
 			break;
@@ -79779,15 +81106,15 @@
 			duk__vm_arith_add(thr, DUK__REGP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins));
 			break;
 		}
 		case DUK_OP_ADD_CC: {
 			duk__vm_arith_add(thr, DUK__CONSTP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins));
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_SUB_RR:
 		case DUK_OP_SUB_CR:
 		case DUK_OP_SUB_RC:
 		case DUK_OP_SUB_CC:
 		case DUK_OP_MUL_RR:
@@ -79803,21 +81130,21 @@
 		case DUK_OP_MOD_RC:
 		case DUK_OP_MOD_CC:
 #if defined(DUK_USE_ES7_EXP_OPERATOR)
 		case DUK_OP_EXP_RR:
 		case DUK_OP_EXP_CR:
 		case DUK_OP_EXP_RC:
 		case DUK_OP_EXP_CC:
-#endif  /* DUK_USE_ES7_EXP_OPERATOR */
+#endif /* DUK_USE_ES7_EXP_OPERATOR */
 		{
 			/* XXX: could leave value on stack top and goto replace_top_a; */
 			duk__vm_arith_binary_op(thr, DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins), DUK_DEC_A(ins), op);
 			break;
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_SUB_RR: {
 			duk__vm_arith_binary_op(thr, DUK__REGP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins), DUK_OP_SUB);
 			break;
 		}
 		case DUK_OP_SUB_CR: {
 			duk__vm_arith_binary_op(thr, DUK__CONSTP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins), DUK_OP_SUB);
 			break;
@@ -79891,16 +81218,16 @@
 			duk__vm_arith_binary_op(thr, DUK__REGP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins), DUK_OP_EXP);
 			break;
 		}
 		case DUK_OP_EXP_CC: {
 			duk__vm_arith_binary_op(thr, DUK__CONSTP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins), DUK_OP_EXP);
 			break;
 		}
-#endif  /* DUK_USE_ES7_EXP_OPERATOR */
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_ES7_EXP_OPERATOR */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_BAND_RR:
 		case DUK_OP_BAND_CR:
 		case DUK_OP_BAND_RC:
 		case DUK_OP_BAND_CC:
 		case DUK_OP_BOR_RR:
@@ -79923,15 +81250,15 @@
 		case DUK_OP_BASR_CR:
 		case DUK_OP_BASR_RC:
 		case DUK_OP_BASR_CC: {
 			/* XXX: could leave value on stack top and goto replace_top_a; */
 			duk__vm_bitwise_binary_op(thr, DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins), DUK_DEC_A(ins), op);
 			break;
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_BAND_RR: {
 			duk__vm_bitwise_binary_op(thr, DUK__REGP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins), DUK_OP_BAND);
 			break;
 		}
 		case DUK_OP_BAND_CR: {
 			duk__vm_bitwise_binary_op(thr, DUK__CONSTP_B(ins), DUK__REGP_C(ins), DUK_DEC_A(ins), DUK_OP_BAND);
 			break;
@@ -80020,24 +81347,26 @@
 			duk__vm_bitwise_binary_op(thr, DUK__REGP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins), DUK_OP_BASR);
 			break;
 		}
 		case DUK_OP_BASR_CC: {
 			duk__vm_bitwise_binary_op(thr, DUK__CONSTP_B(ins), DUK__CONSTP_C(ins), DUK_DEC_A(ins), DUK_OP_BASR);
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		/* For INSTOF and IN, B is always a register. */
-#define DUK__INSTOF_BODY(barg,carg) { \
+#define DUK__INSTOF_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_instanceof(thr, (barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
-#define DUK__IN_BODY(barg,carg) { \
+#define DUK__IN_BODY(barg, carg) \
+	{ \
 		duk_bool_t tmp; \
 		tmp = duk_js_in(thr, (barg), (carg)); \
 		DUK_ASSERT(tmp == 0 || tmp == 1); \
 		DUK__REPLACE_BOOL_A_BREAK(tmp); \
 	}
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_INSTOF_RR:
@@ -80046,15 +81375,15 @@
 		case DUK_OP_INSTOF_CC:
 			DUK__INSTOF_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
 		case DUK_OP_IN_RR:
 		case DUK_OP_IN_CR:
 		case DUK_OP_IN_RC:
 		case DUK_OP_IN_CC:
 			DUK__IN_BODY(DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_INSTOF_RR:
 			DUK__INSTOF_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_INSTOF_CR:
 			DUK__INSTOF_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_INSTOF_RC:
 			DUK__INSTOF_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_INSTOF_CC:
@@ -80063,17 +81392,17 @@
 			DUK__IN_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_IN_CR:
 			DUK__IN_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_IN_RC:
 			DUK__IN_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_IN_CC:
 			DUK__IN_BODY(DUK__CONSTP_B(ins), DUK__CONSTP_C(ins));
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
-		/* Pre/post inc/dec for register variables, important for loops. */
+			/* Pre/post inc/dec for register variables, important for loops. */
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_PREINCR:
 		case DUK_OP_PREDECR:
 		case DUK_OP_POSTINCR:
 		case DUK_OP_POSTDECR: {
 			duk__prepost_incdec_reg_helper(thr, DUK__REGP_A(ins), DUK__REGP_BC(ins), op);
 			break;
@@ -80081,15 +81410,15 @@
 		case DUK_OP_PREINCV:
 		case DUK_OP_PREDECV:
 		case DUK_OP_POSTINCV:
 		case DUK_OP_POSTDECV: {
 			duk__prepost_incdec_var_helper(thr, DUK_DEC_A(ins), DUK__CONSTP_BC(ins), op, DUK__STRICT());
 			break;
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_PREINCR: {
 			duk__prepost_incdec_reg_helper(thr, DUK__REGP_A(ins), DUK__REGP_BC(ins), DUK_OP_PREINCR);
 			break;
 		}
 		case DUK_OP_PREDECR: {
 			duk__prepost_incdec_reg_helper(thr, DUK__REGP_A(ins), DUK__REGP_BC(ins), DUK_OP_PREDECR);
 			break;
@@ -80114,15 +81443,15 @@
 			duk__prepost_incdec_var_helper(thr, DUK_DEC_A(ins), DUK__CONSTP_BC(ins), DUK_OP_POSTINCV, DUK__STRICT());
 			break;
 		}
 		case DUK_OP_POSTDECV: {
 			duk__prepost_incdec_var_helper(thr, DUK_DEC_A(ins), DUK__CONSTP_BC(ins), DUK_OP_POSTDECV, DUK__STRICT());
 			break;
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		/* XXX: Move to separate helper, optimize for perf/size separately. */
 		/* Preinc/predec for object properties. */
 		case DUK_OP_PREINCP_RR:
 		case DUK_OP_PREINCP_CR:
 		case DUK_OP_PREINCP_RC:
 		case DUK_OP_PREINCP_CC:
@@ -80141,15 +81470,15 @@
 			duk_tval *tv_obj;
 			duk_tval *tv_key;
 			duk_tval *tv_val;
 			duk_bool_t rc;
 			duk_double_t x, y, z;
 #if !defined(DUK_USE_EXEC_PREFER_SIZE)
 			duk_tval *tv_dst;
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 			/* A -> target reg
 			 * B -> object reg/const (may be const e.g. in "'foo'[1]")
 			 * C -> key reg/const
 			 */
 
 			/* Opcode bits 0-1 are used to distinguish reg/const variants.
@@ -80159,18 +81488,18 @@
 			DUK_ASSERT((DUK_OP_PREINCP_RR & 0x0c) == 0x00);
 			DUK_ASSERT((DUK_OP_PREDECP_RR & 0x0c) == 0x04);
 			DUK_ASSERT((DUK_OP_POSTINCP_RR & 0x0c) == 0x08);
 			DUK_ASSERT((DUK_OP_POSTDECP_RR & 0x0c) == 0x0c);
 
 			tv_obj = DUK__REGCONSTP_B(ins);
 			tv_key = DUK__REGCONSTP_C(ins);
-			rc = duk_hobject_getprop(thr, tv_obj, tv_key);  /* -> [val] */
-			DUK_UNREF(rc);  /* ignore */
-			tv_obj = NULL;  /* invalidated */
-			tv_key = NULL;  /* invalidated */
+			rc = duk_hobject_getprop(thr, tv_obj, tv_key); /* -> [val] */
+			DUK_UNREF(rc); /* ignore */
+			tv_obj = NULL; /* invalidated */
+			tv_key = NULL; /* invalidated */
 
 			/* XXX: Fastint fast path would be useful here.  Also fastints
 			 * now lose their fastint status in current handling which is
 			 * not intuitive.
 			 */
 
 			x = duk_to_number_m1(thr);
@@ -80183,17 +81512,17 @@
 
 			duk_push_number(thr, y);
 			tv_val = DUK_GET_TVAL_NEGIDX(thr, -1);
 			DUK_ASSERT(tv_val != NULL);
 			tv_obj = DUK__REGCONSTP_B(ins);
 			tv_key = DUK__REGCONSTP_C(ins);
 			rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, DUK__STRICT());
-			DUK_UNREF(rc);  /* ignore */
-			tv_obj = NULL;  /* invalidated */
-			tv_key = NULL;  /* invalidated */
+			DUK_UNREF(rc); /* ignore */
+			tv_obj = NULL; /* invalidated */
+			tv_key = NULL; /* invalidated */
 			duk_pop_unsafe(thr);
 
 			z = (ins & DUK_BC_INCDECP_FLAG_POST) ? x : y;
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 			duk_push_number(thr, z);
 			DUK__REPLACE_TOP_A_BREAK();
 #else
@@ -80203,49 +81532,53 @@
 #endif
 		}
 
 		/* XXX: GETPROP where object is 'this', GETPROPT?
 		 * Occurs relatively often in object oriented code.
 		 */
 
-#define DUK__GETPROP_BODY(barg,carg) { \
+#define DUK__GETPROP_BODY(barg, carg) \
+	{ \
 		/* A -> target reg \
 		 * B -> object reg/const (may be const e.g. in "'foo'[1]") \
 		 * C -> key reg/const \
 		 */ \
 		(void) duk_hobject_getprop(thr, (barg), (carg)); \
 		DUK__REPLACE_TOP_A_BREAK(); \
 	}
-#define DUK__GETPROPC_BODY(barg,carg) { \
+#define DUK__GETPROPC_BODY(barg, carg) \
+	{ \
 		/* Same as GETPROP but callability check for property-based calls. */ \
 		duk_tval *tv__targ; \
 		(void) duk_hobject_getprop(thr, (barg), (carg)); \
 		DUK_GC_TORTURE(thr->heap); \
 		tv__targ = DUK_GET_TVAL_NEGIDX(thr, -1); \
 		if (DUK_UNLIKELY(!duk_is_callable_tval(thr, tv__targ))) { \
 			/* Here we intentionally re-evaluate the macro \
 			 * arguments to deal with potentially changed \
 			 * valstack base pointer! \
 			 */ \
 			duk_call_setup_propcall_error(thr, (barg), (carg)); \
 		} \
 		DUK__REPLACE_TOP_A_BREAK(); \
 	}
-#define DUK__PUTPROP_BODY(aarg,barg,carg) { \
+#define DUK__PUTPROP_BODY(aarg, barg, carg) \
+	{ \
 		/* A -> object reg \
 		 * B -> key reg/const \
 		 * C -> value reg/const \
 		 * \
 		 * Note: intentional difference to register arrangement \
 		 * of e.g. GETPROP; 'A' must contain a register-only value. \
 		 */ \
 		(void) duk_hobject_putprop(thr, (aarg), (barg), (carg), DUK__STRICT()); \
 		break; \
 	}
-#define DUK__DELPROP_BODY(barg,carg) { \
+#define DUK__DELPROP_BODY(barg, carg) \
+	{ \
 		/* A -> result reg \
 		 * B -> object reg \
 		 * C -> key reg/const \
 		 */ \
 		duk_bool_t rc; \
 		rc = duk_hobject_delprop(thr, (barg), (carg), DUK__STRICT()); \
 		DUK_ASSERT(rc == 0 || rc == 1); \
@@ -80266,17 +81599,17 @@
 #endif
 		case DUK_OP_PUTPROP_RR:
 		case DUK_OP_PUTPROP_CR:
 		case DUK_OP_PUTPROP_RC:
 		case DUK_OP_PUTPROP_CC:
 			DUK__PUTPROP_BODY(DUK__REGP_A(ins), DUK__REGCONSTP_B(ins), DUK__REGCONSTP_C(ins));
 		case DUK_OP_DELPROP_RR:
-		case DUK_OP_DELPROP_RC:  /* B is always reg */
+		case DUK_OP_DELPROP_RC: /* B is always reg */
 			DUK__DELPROP_BODY(DUK__REGP_B(ins), DUK__REGCONSTP_C(ins));
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_GETPROP_RR:
 			DUK__GETPROP_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_GETPROP_CR:
 			DUK__GETPROP_BODY(DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_GETPROP_RC:
 			DUK__GETPROP_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_GETPROP_CC:
@@ -80295,19 +81628,19 @@
 			DUK__PUTPROP_BODY(DUK__REGP_A(ins), DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_PUTPROP_CR:
 			DUK__PUTPROP_BODY(DUK__REGP_A(ins), DUK__CONSTP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_PUTPROP_RC:
 			DUK__PUTPROP_BODY(DUK__REGP_A(ins), DUK__REGP_B(ins), DUK__CONSTP_C(ins));
 		case DUK_OP_PUTPROP_CC:
 			DUK__PUTPROP_BODY(DUK__REGP_A(ins), DUK__CONSTP_B(ins), DUK__CONSTP_C(ins));
-		case DUK_OP_DELPROP_RR:  /* B is always reg */
+		case DUK_OP_DELPROP_RR: /* B is always reg */
 			DUK__DELPROP_BODY(DUK__REGP_B(ins), DUK__REGP_C(ins));
 		case DUK_OP_DELPROP_RC:
 			DUK__DELPROP_BODY(DUK__REGP_B(ins), DUK__CONSTP_C(ins));
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		/* No fast path for DECLVAR now, it's quite a rare instruction. */
 		case DUK_OP_DECLVAR_RR:
 		case DUK_OP_DECLVAR_CR:
 		case DUK_OP_DECLVAR_RC:
 		case DUK_OP_DECLVAR_CC: {
 			duk_activation *act;
@@ -80332,15 +81665,15 @@
 			 * writability, etc).
 			 */
 			prop_flags = a & DUK_PROPDESC_FLAGS_MASK;
 
 			if (is_func_decl) {
 				duk_push_tval(thr, DUK__REGCONSTP_C(ins));
 			} else {
-				DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));  /* valstack policy */
+				DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top)); /* valstack policy */
 				thr->valstack_top++;
 			}
 			tv1 = DUK_GET_TVAL_NEGIDX(thr, -1);
 
 			act = thr->callstack_curr;
 			if (duk_js_declvar_activation(thr, act, name, tv1, prop_flags, is_func_decl)) {
 				if (is_func_decl) {
@@ -80368,19 +81701,19 @@
 		case DUK_OP_REGEXP_CC: {
 			/* A -> target register
 			 * B -> bytecode (also contains flags)
 			 * C -> escaped source
 			 */
 
 			duk_push_tval(thr, DUK__REGCONSTP_C(ins));
-			duk_push_tval(thr, DUK__REGCONSTP_B(ins));  /* -> [ ... escaped_source bytecode ] */
-			duk_regexp_create_instance(thr);   /* -> [ ... regexp_instance ] */
+			duk_push_tval(thr, DUK__REGCONSTP_B(ins)); /* -> [ ... escaped_source bytecode ] */
+			duk_regexp_create_instance(thr); /* -> [ ... regexp_instance ] */
 			DUK__REPLACE_TOP_A_BREAK();
 		}
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 		/* XXX: 'c' is unused, use whole BC, etc. */
 		case DUK_OP_CSVAR_RR:
 		case DUK_OP_CSVAR_CR:
 		case DUK_OP_CSVAR_RC:
 		case DUK_OP_CSVAR_CC: {
 			/* The speciality of calling through a variable binding is that the
@@ -80401,82 +81734,80 @@
 			 */
 
 			tv1 = DUK__REGCONSTP_B(ins);
 			DUK_ASSERT(DUK_TVAL_IS_STRING(tv1));
 			name = DUK_TVAL_GET_STRING(tv1);
 			DUK_ASSERT(name != NULL);
 			act = thr->callstack_curr;
-			(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/);  /* -> [... val this] */
+			(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/); /* -> [... val this] */
 
 			idx = (duk_uint_fast_t) DUK_DEC_A(ins);
 
 			/* Could add direct value stack handling. */
-			duk_replace(thr, (duk_idx_t) (idx + 1));  /* 'this' binding */
-			duk_replace(thr, (duk_idx_t) idx);        /* variable value (function, we hope, not checked here) */
+			duk_replace(thr, (duk_idx_t) (idx + 1)); /* 'this' binding */
+			duk_replace(thr, (duk_idx_t) idx); /* variable value (function, we hope, not checked here) */
 			break;
 		}
 
 		case DUK_OP_CLOSURE: {
 			duk_activation *act;
 			duk_hcompfunc *fun_act;
 			duk_small_uint_fast_t bc = DUK_DEC_BC(ins);
 			duk_hobject *fun_temp;
 
 			/* A -> target reg
 			 * BC -> inner function index
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("CLOSURE to target register %ld, fnum %ld (count %ld)",
-			                     (long) DUK_DEC_A(ins), (long) DUK_DEC_BC(ins), (long) DUK_HCOMPFUNC_GET_FUNCS_COUNT(thr->heap, DUK__FUN())));
+			                     (long) DUK_DEC_A(ins),
+			                     (long) DUK_DEC_BC(ins),
+			                     (long) DUK_HCOMPFUNC_GET_FUNCS_COUNT(thr->heap, DUK__FUN())));
 
 			DUK_ASSERT_DISABLE(bc >= 0); /* unsigned */
 			DUK_ASSERT((duk_uint_t) bc < (duk_uint_t) DUK_HCOMPFUNC_GET_FUNCS_COUNT(thr->heap, DUK__FUN()));
 
 			act = thr->callstack_curr;
 			fun_act = (duk_hcompfunc *) DUK_ACT_GET_FUNC(act);
 			fun_temp = DUK_HCOMPFUNC_GET_FUNCS_BASE(thr->heap, fun_act)[bc];
 			DUK_ASSERT(fun_temp != NULL);
 			DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC(fun_temp));
 
-			DUK_DDD(DUK_DDDPRINT("CLOSURE: function template is: %p -> %!O",
-			                     (void *) fun_temp, (duk_heaphdr *) fun_temp));
+			DUK_DDD(
+			    DUK_DDDPRINT("CLOSURE: function template is: %p -> %!O", (void *) fun_temp, (duk_heaphdr *) fun_temp));
 
 			if (act->lex_env == NULL) {
 				DUK_ASSERT(act->var_env == NULL);
 				duk_js_init_activation_environment_records_delayed(thr, act);
 				act = thr->callstack_curr;
 			}
 			DUK_ASSERT(act->lex_env != NULL);
 			DUK_ASSERT(act->var_env != NULL);
 
 			/* functions always have a NEWENV flag, i.e. they get a
 			 * new variable declaration environment, so only lex_env
 			 * matters here.
 			 */
-			duk_js_push_closure(thr,
-			                    (duk_hcompfunc *) fun_temp,
-			                    act->var_env,
-			                    act->lex_env,
-			                    1 /*add_auto_proto*/);
+			duk_js_push_closure(thr, (duk_hcompfunc *) fun_temp, act->var_env, act->lex_env, 1 /*add_auto_proto*/);
 			DUK__REPLACE_TOP_A_BREAK();
 		}
 
 		case DUK_OP_GETVAR: {
 			duk_activation *act;
 			duk_tval *tv1;
 			duk_hstring *name;
 
 			tv1 = DUK__CONSTP_BC(ins);
 			DUK_ASSERT(DUK_TVAL_IS_STRING(tv1));
 			name = DUK_TVAL_GET_STRING(tv1);
 			DUK_ASSERT(name != NULL);
 			act = thr->callstack_curr;
 			DUK_ASSERT(act != NULL);
-			(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/);  /* -> [... val this] */
-			duk_pop_unsafe(thr);  /* 'this' binding is not needed here */
+			(void) duk_js_getvar_activation(thr, act, name, 1 /*throw*/); /* -> [... val this] */
+			duk_pop_unsafe(thr); /* 'this' binding is not needed here */
 			DUK__REPLACE_TOP_A_BREAK();
 		}
 
 		case DUK_OP_PUTVAR: {
 			duk_activation *act;
 			duk_tval *tv1;
 			duk_hstring *name;
@@ -80486,15 +81817,15 @@
 			name = DUK_TVAL_GET_STRING(tv1);
 			DUK_ASSERT(name != NULL);
 
 			/* XXX: putvar takes a duk_tval pointer, which is awkward and
 			 * should be reworked.
 			 */
 
-			tv1 = DUK__REGP_A(ins);  /* val */
+			tv1 = DUK__REGP_A(ins); /* val */
 			act = thr->callstack_curr;
 			duk_js_putvar_activation(thr, act, name, tv1, DUK__STRICT());
 			break;
 		}
 
 		case DUK_OP_DELVAR: {
 			duk_activation *act;
@@ -80516,15 +81847,16 @@
 			 * apparently generate a large positive jump when the
 			 * bias-corrected value would normally be negative.
 			 */
 			curr_pc += (duk_int_fast_t) DUK_DEC_ABC(ins) - (duk_int_fast_t) DUK_BC_JUMP_BIAS;
 			break;
 		}
 
-#define DUK__RETURN_SHARED() do { \
+#define DUK__RETURN_SHARED() \
+	do { \
 		duk_small_uint_t ret_result; \
 		/* duk__handle_return() is guaranteed never to throw, except \
 		 * for potential out-of-memory situations which will then \
 		 * propagate out of the executor longjmp handler. \
 		 */ \
 		DUK_ASSERT(thr->ptr_curr_pc == NULL); \
 		ret_result = duk__handle_return(thr, entry_act); \
@@ -80535,31 +81867,31 @@
 		return; \
 	} while (0)
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
 		case DUK_OP_RETREG:
 		case DUK_OP_RETCONST:
 		case DUK_OP_RETCONSTN:
 		case DUK_OP_RETUNDEF: {
-			 /* BC -> return value reg/const */
+			/* BC -> return value reg/const */
 
 			DUK__SYNC_AND_NULL_CURR_PC();
 
 			if (op == DUK_OP_RETREG) {
 				duk_push_tval(thr, DUK__REGP_BC(ins));
 			} else if (op == DUK_OP_RETUNDEF) {
-				DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));  /* valstack policy */
+				DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top)); /* valstack policy */
 				thr->valstack_top++;
 			} else {
 				DUK_ASSERT(op == DUK_OP_RETCONST || op == DUK_OP_RETCONSTN);
 				duk_push_tval(thr, DUK__CONSTP_BC(ins));
 			}
 
 			DUK__RETURN_SHARED();
 		}
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		case DUK_OP_RETREG: {
 			duk_tval *tv;
 
 			DUK__SYNC_AND_NULL_CURR_PC();
 			tv = DUK__REGP_BC(ins);
 			DUK_TVAL_SET_TVAL(thr->valstack_top, tv);
 			DUK_TVAL_INCREF(thr, tv);
@@ -80581,53 +81913,56 @@
 			duk_tval *tv;
 
 			DUK__SYNC_AND_NULL_CURR_PC();
 			tv = DUK__CONSTP_BC(ins);
 			DUK_TVAL_SET_TVAL(thr->valstack_top, tv);
 #if defined(DUK_USE_REFERENCE_COUNTING)
 			/* Without refcounting only RETCONSTN is used. */
-			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv));  /* no INCREF for this constant */
+			DUK_ASSERT(!DUK_TVAL_IS_HEAP_ALLOCATED(tv)); /* no INCREF for this constant */
 #endif
 			thr->valstack_top++;
 			DUK__RETURN_SHARED();
 		}
 		case DUK_OP_RETUNDEF: {
 			DUK__SYNC_AND_NULL_CURR_PC();
-			thr->valstack_top++;  /* value at valstack top is already undefined by valstack policy */
+			thr->valstack_top++; /* value at valstack top is already undefined by valstack policy */
 			DUK_ASSERT(DUK_TVAL_IS_UNDEFINED(thr->valstack_top));
 			DUK__RETURN_SHARED();
 		}
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 
 		case DUK_OP_LABEL: {
 			duk_activation *act;
 			duk_catcher *cat;
 			duk_small_uint_fast_t bc = DUK_DEC_BC(ins);
 
 			/* Allocate catcher and populate it (must be atomic). */
 
 			cat = duk_hthread_catcher_alloc(thr);
 			DUK_ASSERT(cat != NULL);
 
 			cat->flags = (duk_uint32_t) (DUK_CAT_TYPE_LABEL | (bc << DUK_CAT_LABEL_SHIFT));
-			cat->pc_base = (duk_instr_t *) curr_pc;  /* pre-incremented, points to first jump slot */
-			cat->idx_base = 0;  /* unused for label */
+			cat->pc_base = (duk_instr_t *) curr_pc; /* pre-incremented, points to first jump slot */
+			cat->idx_base = 0; /* unused for label */
 			cat->h_varname = NULL;
 
 			act = thr->callstack_curr;
 			DUK_ASSERT(act != NULL);
 			cat->parent = act->cat;
 			act->cat = cat;
 
 			DUK_DDD(DUK_DDDPRINT("LABEL catcher: flags=0x%08lx, pc_base=%ld, "
 			                     "idx_base=%ld, h_varname=%!O, label_id=%ld",
-			                     (long) cat->flags, (long) cat->pc_base,
-			                     (long) cat->idx_base, (duk_heaphdr *) cat->h_varname, (long) DUK_CAT_GET_LABEL(cat)));
+			                     (long) cat->flags,
+			                     (long) cat->pc_base,
+			                     (long) cat->idx_base,
+			                     (duk_heaphdr *) cat->h_varname,
+			                     (long) DUK_CAT_GET_LABEL(cat)));
 
-			curr_pc += 2;  /* skip jump slots */
+			curr_pc += 2; /* skip jump slots */
 			break;
 		}
 
 		case DUK_OP_ENDLABEL: {
 			duk_activation *act;
 #if (defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)) || defined(DUK_USE_ASSERTIONS)
 			duk_small_uint_fast_t bc = DUK_DEC_BC(ins);
@@ -80661,15 +81996,15 @@
 			duk__handle_break_or_continue(thr, (duk_uint_t) bc, DUK_LJ_TYPE_CONTINUE);
 			goto restart_execution;
 		}
 
 		/* XXX: move to helper, too large to be inline here */
 		case DUK_OP_TRYCATCH: {
 			duk__handle_op_trycatch(thr, ins, curr_pc);
-			curr_pc += 2;  /* skip jump slots */
+			curr_pc += 2; /* skip jump slots */
 			break;
 		}
 
 		case DUK_OP_ENDTRY: {
 			curr_pc = duk__handle_op_endtry(thr, ins);
 			break;
 		}
@@ -80706,24 +82041,24 @@
 			DUK__SYNC_AND_NULL_CURR_PC();
 
 			duk_dup(thr, (duk_idx_t) bc);
 			DUK_DDD(DUK_DDDPRINT("THROW ERROR (BYTECODE): %!dT (before throw augment)",
 			                     (duk_tval *) duk_get_tval(thr, -1)));
 #if defined(DUK_USE_AUGMENT_ERROR_THROW)
 			duk_err_augment_error_throw(thr);
-			DUK_DDD(DUK_DDDPRINT("THROW ERROR (BYTECODE): %!dT (after throw augment)",
-			                     (duk_tval *) duk_get_tval(thr, -1)));
+			DUK_DDD(
+			    DUK_DDDPRINT("THROW ERROR (BYTECODE): %!dT (after throw augment)", (duk_tval *) duk_get_tval(thr, -1)));
 #endif
 
 			duk_err_setup_ljstate1(thr, DUK_LJ_TYPE_THROW, DUK_GET_TVAL_NEGIDX(thr, -1));
 #if defined(DUK_USE_DEBUGGER_SUPPORT)
 			duk_err_check_debugger_integration(thr);
 #endif
 
-			DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL);  /* always in executor */
+			DUK_ASSERT(thr->heap->lj.jmpbuf_ptr != NULL); /* always in executor */
 			duk_err_longjmp(thr);
 			DUK_UNREACHABLE();
 			break;
 		}
 
 		case DUK_OP_CSREG: {
 			/*
@@ -80752,28 +82087,27 @@
 
 			tv1 = DUK__REGP(bc);
 			tv2 = tv1 + 1;
 			DUK_TVAL_SET_TVAL(&tv_tmp1, tv1);
 			DUK_TVAL_SET_TVAL(&tv_tmp2, tv2);
 			tv3 = DUK__REGP(a);
 			DUK_TVAL_SET_TVAL(tv1, tv3);
-			DUK_TVAL_INCREF(thr, tv1);  /* no side effects */
-			DUK_TVAL_SET_UNDEFINED(tv2);  /* no need for incref */
+			DUK_TVAL_INCREF(thr, tv1); /* no side effects */
+			DUK_TVAL_SET_UNDEFINED(tv2); /* no need for incref */
 			DUK_TVAL_DECREF(thr, &tv_tmp1);
 			DUK_TVAL_DECREF(thr, &tv_tmp2);
 #endif
 			break;
 		}
 
-
-		/* XXX: in some cases it's faster NOT to reuse the value
-		 * stack but rather copy the arguments on top of the stack
-		 * (mainly when the calling value stack is large and the value
-		 * stack resize would be large).
-		 */
+			/* XXX: in some cases it's faster NOT to reuse the value
+			 * stack but rather copy the arguments on top of the stack
+			 * (mainly when the calling value stack is large and the value
+			 * stack resize would be large).
+			 */
 
 		case DUK_OP_CALL0:
 		case DUK_OP_CALL1:
 		case DUK_OP_CALL2:
 		case DUK_OP_CALL3:
 		case DUK_OP_CALL4:
 		case DUK_OP_CALL5:
@@ -80926,15 +82260,15 @@
 
 			idx = (duk_uint_fast_t) DUK_DEC_B(ins);
 			if (DUK_DEC_OP(ins) == DUK_OP_MPUTOBJI) {
 				DUK__LOOKUP_INDIRECT(idx);
 			}
 
 			count = (duk_small_uint_fast_t) DUK_DEC_C(ins);
-			DUK_ASSERT(count > 0);  /* compiler guarantees */
+			DUK_ASSERT(count > 0); /* compiler guarantees */
 			idx_end = idx + count;
 
 #if defined(DUK_USE_EXEC_INDIRECT_BOUND_CHECK)
 			if (DUK_UNLIKELY(idx_end > (duk_uint_fast_t) duk_get_top(thr))) {
 				/* XXX: use duk_is_valid_index() instead? */
 				/* XXX: improve check; check against nregs, not against top */
 				DUK__INTERNAL_ERROR("MPUTOBJ out of bounds");
@@ -80950,19 +82284,18 @@
 			 * may be arbitrary values and need to be ToPropertyKey()
 			 * coerced at runtime.
 			 */
 			do {
 				/* XXX: faster initialization (direct access or better primitives) */
 				duk_dup(thr, (duk_idx_t) idx);
 				duk_dup(thr, (duk_idx_t) (idx + 1));
-				duk_def_prop(thr, obj_idx, DUK_DEFPROP_HAVE_VALUE |
-				                           DUK_DEFPROP_FORCE |
-				                           DUK_DEFPROP_SET_WRITABLE |
-				                           DUK_DEFPROP_SET_ENUMERABLE |
-				                           DUK_DEFPROP_SET_CONFIGURABLE);
+				duk_def_prop(thr,
+				             obj_idx,
+				             DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_FORCE | DUK_DEFPROP_SET_WRITABLE |
+				                 DUK_DEFPROP_SET_ENUMERABLE | DUK_DEFPROP_SET_CONFIGURABLE);
 				idx += 2;
 			} while (idx < idx_end);
 			break;
 		}
 
 		case DUK_OP_INITSET:
 		case DUK_OP_INITGET: {
@@ -80989,15 +82322,15 @@
 
 			idx = (duk_uint_fast_t) DUK_DEC_B(ins);
 			if (DUK_DEC_OP(ins) == DUK_OP_MPUTARRI) {
 				DUK__LOOKUP_INDIRECT(idx);
 			}
 
 			count = (duk_small_uint_fast_t) DUK_DEC_C(ins);
-			DUK_ASSERT(count > 0 + 1);  /* compiler guarantees */
+			DUK_ASSERT(count > 0 + 1); /* compiler guarantees */
 			idx_end = idx + count;
 
 #if defined(DUK_USE_EXEC_INDIRECT_BOUND_CHECK)
 			if (idx_end > (duk_uint_fast_t) duk_get_top(thr)) {
 				/* XXX: use duk_is_valid_index() instead? */
 				/* XXX: improve check; check against nregs, not against top */
 				DUK__INTERNAL_ERROR("MPUTARR out of bounds");
@@ -81116,15 +82449,15 @@
 		}
 
 #if defined(DUK_USE_ES6)
 		case DUK_OP_NEWTARGET: {
 			duk_push_new_target(thr);
 			DUK__REPLACE_TOP_BC_BREAK();
 		}
-#endif  /* DUK_USE_ES6 */
+#endif /* DUK_USE_ES6 */
 
 #if !defined(DUK_USE_EXEC_PREFER_SIZE)
 #if !defined(DUK_USE_ES7_EXP_OPERATOR)
 		case DUK_OP_EXP_RR:
 		case DUK_OP_EXP_CR:
 		case DUK_OP_EXP_RC:
 		case DUK_OP_EXP_CC:
@@ -81179,54 +82512,54 @@
 		case DUK_OP_UNUSED249:
 		case DUK_OP_UNUSED250:
 		case DUK_OP_UNUSED251:
 		case DUK_OP_UNUSED252:
 		case DUK_OP_UNUSED253:
 		case DUK_OP_UNUSED254:
 		case DUK_OP_UNUSED255:
-		/* Force all case clauses to map to an actual handler
-		 * so that the compiler can emit a jump without a bounds
-		 * check: the switch argument is a duk_uint8_t so that
-		 * the compiler may be able to figure it out.  This is
-		 * a small detail and obviously compiler dependent.
-		 */
-		/* default: clause omitted on purpose */
-#else  /* DUK_USE_EXEC_PREFER_SIZE */
+			/* Force all case clauses to map to an actual handler
+			 * so that the compiler can emit a jump without a bounds
+			 * check: the switch argument is a duk_uint8_t so that
+			 * the compiler may be able to figure it out.  This is
+			 * a small detail and obviously compiler dependent.
+			 */
+			/* default: clause omitted on purpose */
+#else /* DUK_USE_EXEC_PREFER_SIZE */
 		default:
-#endif  /* DUK_USE_EXEC_PREFER_SIZE */
+#endif /* DUK_USE_EXEC_PREFER_SIZE */
 		{
 			/* Default case catches invalid/unsupported opcodes. */
 			DUK_D(DUK_DPRINT("invalid opcode: %ld - %!I", (long) op, ins));
 			DUK__INTERNAL_ERROR("invalid opcode");
 			break;
 		}
 
-		}  /* end switch */
+		} /* end switch */
 
 		continue;
 
 		/* Some shared exit paths for opcode handling below.  These
 		 * are mostly useful to reduce code footprint when multiple
 		 * opcodes have a similar epilogue (like replacing stack top
 		 * with index 'a').
 		 */
 
 #if defined(DUK_USE_EXEC_PREFER_SIZE)
-	 replace_top_a:
+	replace_top_a:
 		DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_A(ins));
 		continue;
-	 replace_top_bc:
+	replace_top_bc:
 		DUK__REPLACE_TO_TVPTR(thr, DUK__REGP_BC(ins));
 		continue;
 #endif
 	}
 	DUK_WO_NORETURN(return;);
 
 #if !defined(DUK_USE_VERBOSE_EXECUTOR_ERRORS)
- internal_error:
+internal_error:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return;);
 #endif
 }
 
 /* automatic undefs */
 #undef DUK__BYTEOFF_A
@@ -81450,39 +82783,30 @@
 	duk_double_t d;
 
 	DUK_ASSERT(duk_is_string(thr, -1));
 
 	/* Quite lenient, e.g. allow empty as zero, but don't allow trailing
 	 * garbage.
 	 */
-	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE |
-	            DUK_S2N_FLAG_ALLOW_EXP |
-	            DUK_S2N_FLAG_ALLOW_PLUS |
-	            DUK_S2N_FLAG_ALLOW_MINUS |
-	            DUK_S2N_FLAG_ALLOW_INF |
-	            DUK_S2N_FLAG_ALLOW_FRAC |
-	            DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
-	            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC |
-	            DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO |
-	            DUK_S2N_FLAG_ALLOW_LEADING_ZERO |
-	            DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT |
-	            DUK_S2N_FLAG_ALLOW_AUTO_OCT_INT |
-	            DUK_S2N_FLAG_ALLOW_AUTO_BIN_INT;
+	s2n_flags = DUK_S2N_FLAG_TRIM_WHITE | DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_PLUS | DUK_S2N_FLAG_ALLOW_MINUS |
+	            DUK_S2N_FLAG_ALLOW_INF | DUK_S2N_FLAG_ALLOW_FRAC | DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
+	            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC | DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO | DUK_S2N_FLAG_ALLOW_LEADING_ZERO |
+	            DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT | DUK_S2N_FLAG_ALLOW_AUTO_OCT_INT | DUK_S2N_FLAG_ALLOW_AUTO_BIN_INT;
 
 	duk_numconv_parse(thr, 10 /*radix*/, s2n_flags);
 
 #if defined(DUK_USE_PREFER_SIZE)
 	d = duk_get_number(thr, -1);
 	duk_pop_unsafe(thr);
 #else
 	thr->valstack_top--;
 	DUK_ASSERT(DUK_TVAL_IS_NUMBER(thr->valstack_top));
-	DUK_ASSERT(DUK_TVAL_IS_DOUBLE(thr->valstack_top));  /* no fastint conversion in numconv now */
+	DUK_ASSERT(DUK_TVAL_IS_DOUBLE(thr->valstack_top)); /* no fastint conversion in numconv now */
 	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(thr->valstack_top));
-	d = DUK_TVAL_GET_DOUBLE(thr->valstack_top);  /* assumes not a fastint */
+	d = DUK_TVAL_GET_DOUBLE(thr->valstack_top); /* assumes not a fastint */
 	DUK_TVAL_SET_UNDEFINED(thr->valstack_top);
 #endif
 
 	return d;
 }
 
 DUK_INTERNAL duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv) {
@@ -81513,19 +82837,19 @@
 		if (DUK_UNLIKELY(DUK_HSTRING_HAS_SYMBOL(h))) {
 			DUK_ERROR_TYPE(thr, DUK_STR_CANNOT_NUMBER_COERCE_SYMBOL);
 			DUK_WO_NORETURN(return 0.0;);
 		}
 		duk_push_hstring(thr, h);
 		return duk__tonumber_string_raw(thr);
 	}
-	case DUK_TAG_BUFFER:  /* plain buffer treated like object */
+	case DUK_TAG_BUFFER: /* plain buffer treated like object */
 	case DUK_TAG_OBJECT: {
 		duk_double_t d;
 		duk_push_tval(thr, tv);
-		duk_to_primitive(thr, -1, DUK_HINT_NUMBER);  /* 'tv' becomes invalid */
+		duk_to_primitive(thr, -1, DUK_HINT_NUMBER); /* 'tv' becomes invalid */
 
 		/* recursive call for a primitive value (guaranteed not to cause second
 		 * recursion).
 		 */
 		DUK_ASSERT(duk_get_tval(thr, -1) != NULL);
 		d = duk_js_tonumber(thr, duk_get_tval(thr, -1));
 
@@ -81572,47 +82896,47 @@
 		return x;
 	} else {
 		/* Finite, including neg/pos zero.  Neg zero sign must be
 		 * preserved.
 		 */
 		return duk_double_trunc_towards_zero(x);
 	}
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	/* NaN and Infinity have the same exponent so it's a cheap
 	 * initial check for the rare path.
 	 */
 	if (DUK_UNLIKELY(duk_double_is_nan_or_inf(x) != 0U)) {
 		if (duk_double_is_nan(x)) {
 			return 0.0;
 		} else {
 			return x;
 		}
 	} else {
 		return duk_double_trunc_towards_zero(x);
 	}
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 }
 
 DUK_INTERNAL duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv) {
 	/* XXX: fastint */
-	duk_double_t d = duk_js_tonumber(thr, tv);  /* invalidates tv */
+	duk_double_t d = duk_js_tonumber(thr, tv); /* invalidates tv */
 	return duk_js_tointeger_number(d);
 }
 
 /*
  *  ToInt32(), ToUint32(), ToUint16()  (E5 Sections 9.5, 9.6, 9.7)
  */
 
 /* combined algorithm matching E5 Sections 9.5 and 9.6 */
 DUK_LOCAL duk_double_t duk__toint32_touint32_helper(duk_double_t x, duk_bool_t is_toint32) {
-#if defined (DUK_USE_PREFER_SIZE)
+#if defined(DUK_USE_PREFER_SIZE)
 	duk_small_int_t c;
 #endif
 
-#if defined (DUK_USE_PREFER_SIZE)
+#if defined(DUK_USE_PREFER_SIZE)
 	c = (duk_small_int_t) DUK_FPCLASSIFY(x);
 	if (c == DUK_FP_NAN || c == DUK_FP_ZERO || c == DUK_FP_INFINITE) {
 		return 0.0;
 	}
 #else
 	if (duk_double_is_nan_zero_inf(x)) {
 		return 0.0;
@@ -81622,26 +82946,26 @@
 	/* x = sign(x) * floor(abs(x)), i.e. truncate towards zero, keep sign */
 	x = duk_double_trunc_towards_zero(x);
 
 	/* NOTE: fmod(x) result sign is same as sign of x, which
 	 * differs from what Javascript wants (see Section 9.6).
 	 */
 
-	x = DUK_FMOD(x, DUK_DOUBLE_2TO32);    /* -> x in ]-2**32, 2**32[ */
+	x = DUK_FMOD(x, DUK_DOUBLE_2TO32); /* -> x in ]-2**32, 2**32[ */
 
 	if (x < 0.0) {
 		x += DUK_DOUBLE_2TO32;
 	}
-	DUK_ASSERT(x >= 0 && x < DUK_DOUBLE_2TO32);  /* -> x in [0, 2**32[ */
+	DUK_ASSERT(x >= 0 && x < DUK_DOUBLE_2TO32); /* -> x in [0, 2**32[ */
 
 	if (is_toint32) {
 		if (x >= DUK_DOUBLE_2TO31) {
 			/* x in [2**31, 2**32[ */
 
-			x -= DUK_DOUBLE_2TO32;  /* -> x in [-2**31,2**31[ */
+			x -= DUK_DOUBLE_2TO32; /* -> x in [-2**31,2**31[ */
 		}
 	}
 
 	return x;
 }
 
 DUK_INTERNAL duk_int32_t duk_js_toint32(duk_hthread *thr, duk_tval *tv) {
@@ -81649,39 +82973,37 @@
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv)) {
 		return DUK_TVAL_GET_FASTINT_I32(tv);
 	}
 #endif
 
-	d = duk_js_tonumber(thr, tv);  /* invalidates tv */
+	d = duk_js_tonumber(thr, tv); /* invalidates tv */
 	d = duk__toint32_touint32_helper(d, 1);
 	DUK_ASSERT(DUK_FPCLASSIFY(d) == DUK_FP_ZERO || DUK_FPCLASSIFY(d) == DUK_FP_NORMAL);
-	DUK_ASSERT(d >= -2147483648.0 && d <= 2147483647.0);  /* [-0x80000000,0x7fffffff] */
-	DUK_ASSERT(duk_double_equals(d, (duk_double_t) ((duk_int32_t) d)));  /* whole, won't clip */
+	DUK_ASSERT(d >= -2147483648.0 && d <= 2147483647.0); /* [-0x80000000,0x7fffffff] */
+	DUK_ASSERT(duk_double_equals(d, (duk_double_t) ((duk_int32_t) d))); /* whole, won't clip */
 	return (duk_int32_t) d;
 }
 
-
 DUK_INTERNAL duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv) {
 	duk_double_t d;
 
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv)) {
 		return DUK_TVAL_GET_FASTINT_U32(tv);
 	}
 #endif
 
-	d = duk_js_tonumber(thr, tv);  /* invalidates tv */
+	d = duk_js_tonumber(thr, tv); /* invalidates tv */
 	d = duk__toint32_touint32_helper(d, 0);
 	DUK_ASSERT(DUK_FPCLASSIFY(d) == DUK_FP_ZERO || DUK_FPCLASSIFY(d) == DUK_FP_NORMAL);
-	DUK_ASSERT(d >= 0.0 && d <= 4294967295.0);  /* [0x00000000, 0xffffffff] */
-	DUK_ASSERT(duk_double_equals(d, (duk_double_t) ((duk_uint32_t) d)));  /* whole, won't clip */
+	DUK_ASSERT(d >= 0.0 && d <= 4294967295.0); /* [0x00000000, 0xffffffff] */
+	DUK_ASSERT(duk_double_equals(d, (duk_double_t) ((duk_uint32_t) d))); /* whole, won't clip */
 	return (duk_uint32_t) d;
-
 }
 
 DUK_INTERNAL duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv) {
 	/* should be a safe way to compute this */
 	return (duk_uint16_t) (duk_js_touint32(thr, tv) & 0x0000ffffU);
 }
 
@@ -81723,15 +83045,15 @@
 	if (cx == DUK_FP_ZERO && cy == DUK_FP_ZERO) {
 		return 1;
 	}
 	if (x == y) {
 		return 1;
 	}
 	return 0;
-#else  /* DUK_USE_PARANOID_MATH */
+#else /* DUK_USE_PARANOID_MATH */
 	/* Better equivalent algorithm.  If the compiler is compliant, C and
 	 * ECMAScript semantics are identical for this particular comparison.
 	 * In particular, NaNs must never compare equal and zeroes must compare
 	 * equal regardless of sign.  Could also use a macro, but this inlines
 	 * already nicely (no difference on gcc, for instance).
 	 */
 	if (duk_double_equals(x, y)) {
@@ -81743,15 +83065,15 @@
 		/* IEEE requires that zeros compare the same regardless
 		 * of their signed, so if both x and y are zeroes, they
 		 * are caught above.
 		 */
 		DUK_ASSERT(!(DUK_FPCLASSIFY(x) == DUK_FP_ZERO && DUK_FPCLASSIFY(y) == DUK_FP_ZERO));
 		return 0;
 	}
-#endif  /* DUK_USE_PARANOID_MATH */
+#endif /* DUK_USE_PARANOID_MATH */
 }
 
 DUK_LOCAL duk_bool_t duk__js_samevalue_number(duk_double_t x, duk_double_t y) {
 #if defined(DUK_USE_PARANOID_MATH)
 	duk_small_int_t cx = (duk_small_int_t) DUK_FPCLASSIFY(x);
 	duk_small_int_t cy = (duk_small_int_t) DUK_FPCLASSIFY(y);
 
@@ -81773,15 +83095,15 @@
 	/* normal comparison; known:
 	 *   - both x and y are not NaNs (but one of them can be)
 	 *   - both x and y are not zero (but one of them can be)
 	 *   - x and y may be denormal or infinite
 	 */
 
 	return (x == y);
-#else  /* DUK_USE_PARANOID_MATH */
+#else /* DUK_USE_PARANOID_MATH */
 	duk_small_int_t cx = (duk_small_int_t) DUK_FPCLASSIFY(x);
 	duk_small_int_t cy = (duk_small_int_t) DUK_FPCLASSIFY(y);
 
 	if (duk_double_equals(x, y)) {
 		/* IEEE requires that NaNs compare false */
 		DUK_ASSERT(DUK_FPCLASSIFY(x) != DUK_FP_NAN);
 		DUK_ASSERT(DUK_FPCLASSIFY(y) != DUK_FP_NAN);
@@ -81808,15 +83130,15 @@
 		 */
 		if (DUK_UNLIKELY(cx == DUK_FP_NAN && cy == DUK_FP_NAN)) {
 			/* SameValue(NaN, NaN) = true, regardless of NaN sign or extra bits */
 			return 1;
 		}
 		return 0;
 	}
-#endif  /* DUK_USE_PARANOID_MATH */
+#endif /* DUK_USE_PARANOID_MATH */
 }
 
 DUK_INTERNAL duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 	duk_uint_t type_mask_x;
 	duk_uint_t type_mask_y;
 
 	/* If flags != 0 (strict or SameValue), thr can be NULL.  For loose
@@ -81834,18 +83156,17 @@
 #if defined(DUK_USE_FASTINT)
 	if (DUK_TVAL_IS_FASTINT(tv_x) && DUK_TVAL_IS_FASTINT(tv_y)) {
 		if (DUK_TVAL_GET_FASTINT(tv_x) == DUK_TVAL_GET_FASTINT(tv_y)) {
 			return 1;
 		} else {
 			return 0;
 		}
-	}
-	else
+	} else
 #endif
-	if (DUK_TVAL_IS_NUMBER(tv_x) && DUK_TVAL_IS_NUMBER(tv_y)) {
+	    if (DUK_TVAL_IS_NUMBER(tv_x) && DUK_TVAL_IS_NUMBER(tv_y)) {
 		duk_double_t d1, d2;
 
 		/* Catches both doubles and cases where only one argument is
 		 * a fastint so can't assume a double.
 		 */
 		d1 = DUK_TVAL_GET_NUMBER(tv_x);
 		d2 = DUK_TVAL_GET_NUMBER(tv_y);
@@ -81911,15 +83232,15 @@
 		}
 	}
 
 	if ((flags & (DUK_EQUALS_FLAG_STRICT | DUK_EQUALS_FLAG_SAMEVALUE)) != 0) {
 		return 0;
 	}
 
-	DUK_ASSERT(flags == 0);  /* non-strict equality from here on */
+	DUK_ASSERT(flags == 0); /* non-strict equality from here on */
 
 	/*
 	 *  Types are different; various cases for non-strict comparison
 	 *
 	 *  Since comparison is symmetric, we use a "swap trick" to reduce
 	 *  code size.
 	 */
@@ -81968,42 +83289,37 @@
 		DUK_ASSERT(DUK_TVAL_GET_BOOLEAN(tv_y) == 0 || DUK_TVAL_GET_BOOLEAN(tv_y) == 1);
 		duk_push_tval(thr, tv_x);
 		duk_push_uint(thr, DUK_TVAL_GET_BOOLEAN(tv_y));
 		goto recursive_call;
 	}
 
 	/* String-number-symbol/object -> coerce object to primitive (apparently without hint), then try again. */
-	if ((type_mask_x & (DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_NUMBER)) &&
-	    (type_mask_y & DUK_TYPE_MASK_OBJECT)) {
+	if ((type_mask_x & (DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_NUMBER)) && (type_mask_y & DUK_TYPE_MASK_OBJECT)) {
 		/* No symbol check needed because symbols and strings are accepted. */
 		duk_push_tval(thr, tv_x);
 		duk_push_tval(thr, tv_y);
-		duk_to_primitive(thr, -1, DUK_HINT_NONE);  /* apparently no hint? */
+		duk_to_primitive(thr, -1, DUK_HINT_NONE); /* apparently no hint? */
 		goto recursive_call;
 	}
-	if ((type_mask_x & DUK_TYPE_MASK_OBJECT) &&
-	    (type_mask_y & (DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_NUMBER))) {
+	if ((type_mask_x & DUK_TYPE_MASK_OBJECT) && (type_mask_y & (DUK_TYPE_MASK_STRING | DUK_TYPE_MASK_NUMBER))) {
 		/* No symbol check needed because symbols and strings are accepted. */
 		duk_push_tval(thr, tv_x);
 		duk_push_tval(thr, tv_y);
-		duk_to_primitive(thr, -2, DUK_HINT_NONE);  /* apparently no hint? */
+		duk_to_primitive(thr, -2, DUK_HINT_NONE); /* apparently no hint? */
 		goto recursive_call;
 	}
 
 	/* Nothing worked -> not equal. */
 	return 0;
 
- recursive_call:
+recursive_call:
 	/* Shared code path to call the helper again with arguments on stack top. */
 	{
 		duk_bool_t rc;
-		rc = duk_js_equals_helper(thr,
-		                          DUK_GET_TVAL_NEGIDX(thr, -2),
-		                          DUK_GET_TVAL_NEGIDX(thr, -1),
-		                          0 /*flags:nonstrict*/);
+		rc = duk_js_equals_helper(thr, DUK_GET_TVAL_NEGIDX(thr, -2), DUK_GET_TVAL_NEGIDX(thr, -1), 0 /*flags:nonstrict*/);
 		duk_pop_2_unsafe(thr);
 		return rc;
 	}
 }
 
 /*
  *  Comparisons (x >= y, x > y, x <= y, x < y)
@@ -82012,26 +83328,27 @@
  *  flags to get the rest.
  */
 
 /* XXX: this should probably just operate on the stack top, because it
  * needs to push stuff on the stack anyway...
  */
 
-DUK_INTERNAL duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1, const duk_uint8_t *buf2, duk_size_t len1, duk_size_t len2) {
+DUK_INTERNAL duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1,
+                                                 const duk_uint8_t *buf2,
+                                                 duk_size_t len1,
+                                                 duk_size_t len2) {
 	duk_size_t prefix_len;
 	duk_small_int_t rc;
 
 	prefix_len = (len1 <= len2 ? len1 : len2);
 
 	/* duk_memcmp() is guaranteed to return zero (equal) for zero length
 	 * inputs.
 	 */
-	rc = duk_memcmp_unsafe((const void *) buf1,
-	                       (const void *) buf2,
-	                       (size_t) prefix_len);
+	rc = duk_memcmp_unsafe((const void *) buf1, (const void *) buf2, (size_t) prefix_len);
 
 	if (rc < 0) {
 		return -1;
 	} else if (rc > 0) {
 		return 1;
 	}
 
@@ -82065,15 +83382,15 @@
 
 	return duk_js_data_compare((const duk_uint8_t *) DUK_HSTRING_GET_DATA(h1),
 	                           (const duk_uint8_t *) DUK_HSTRING_GET_DATA(h2),
 	                           (duk_size_t) DUK_HSTRING_GET_BYTELEN(h1),
 	                           (duk_size_t) DUK_HSTRING_GET_BYTELEN(h2));
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_INTERNAL duk_small_int_t duk_js_buffer_compare(duk_heap *heap, duk_hbuffer *h1, duk_hbuffer *h2) {
 	/* Similar to String comparison. */
 
 	DUK_ASSERT(h1 != NULL);
 	DUK_ASSERT(h2 != NULL);
 	DUK_UNREF(heap);
 
@@ -82102,55 +83419,55 @@
 	DUK_ASSERT(retval == 0 || retval == 1);
 	c1 = (duk_small_int_t) DUK_FPCLASSIFY(d1);
 	s1 = (duk_small_int_t) DUK_SIGNBIT(d1);
 	c2 = (duk_small_int_t) DUK_FPCLASSIFY(d2);
 	s2 = (duk_small_int_t) DUK_SIGNBIT(d2);
 
 	if (c1 == DUK_FP_NAN || c2 == DUK_FP_NAN) {
-		return 0;  /* Always false, regardless of negation. */
+		return 0; /* Always false, regardless of negation. */
 	}
 
 	if (c1 == DUK_FP_ZERO && c2 == DUK_FP_ZERO) {
 		/* For all combinations: +0 < +0, +0 < -0, -0 < +0, -0 < -0,
 		 * steps e, f, and g.
 		 */
-		return retval;  /* false */
+		return retval; /* false */
 	}
 
 	if (d1 == d2) {
-		return retval;  /* false */
+		return retval; /* false */
 	}
 
 	if (c1 == DUK_FP_INFINITE && s1 == 0) {
 		/* x == +Infinity */
-		return retval;  /* false */
+		return retval; /* false */
 	}
 
 	if (c2 == DUK_FP_INFINITE && s2 == 0) {
 		/* y == +Infinity */
-		return retval ^ 1;  /* true */
+		return retval ^ 1; /* true */
 	}
 
 	if (c2 == DUK_FP_INFINITE && s2 != 0) {
 		/* y == -Infinity */
-		return retval;  /* false */
+		return retval; /* false */
 	}
 
 	if (c1 == DUK_FP_INFINITE && s1 != 0) {
 		/* x == -Infinity */
-		return retval ^ 1;  /* true */
+		return retval ^ 1; /* true */
 	}
 
 	if (d1 < d2) {
-		return retval ^ 1;  /* true */
+		return retval ^ 1; /* true */
 	}
 
-	return retval;  /* false */
+	return retval; /* false */
 }
-#else  /* DUK_USE_PARANOID_MATH */
+#else /* DUK_USE_PARANOID_MATH */
 DUK_LOCAL duk_bool_t duk__compare_number(duk_bool_t retval, duk_double_t d1, duk_double_t d2) {
 	/* This comparison tree relies doesn't match the exact steps in
 	 * E5 Section 11.8.5 but should produce the same results.  The
 	 * steps rely on exact IEEE semantics for NaNs, etc.
 	 */
 
 	DUK_ASSERT(retval == 0 || retval == 1);
@@ -82179,47 +83496,43 @@
 			 * - d1 == d2 (including infinities)
 			 */
 			if (duk_double_is_nan(d1) || duk_double_is_nan(d2)) {
 				/* Note: undefined from Section 11.8.5 always
 				 * results in false return (see e.g. Section
 				 * 11.8.3) - hence special treatment here.
 				 */
-				return 0;  /* zero regardless of negation */
+				return 0; /* zero regardless of negation */
 			} else {
 				return retval;
 			}
 		}
 	}
 }
-#endif  /* DUK_USE_PARANOID_MATH */
+#endif /* DUK_USE_PARANOID_MATH */
 
 DUK_INTERNAL duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 	duk_double_t d1, d2;
 	duk_small_int_t rc;
 	duk_bool_t retval;
 
-	DUK_ASSERT(DUK_COMPARE_FLAG_NEGATE == 1);  /* Rely on this flag being lowest. */
+	DUK_ASSERT(DUK_COMPARE_FLAG_NEGATE == 1); /* Rely on this flag being lowest. */
 	retval = flags & DUK_COMPARE_FLAG_NEGATE;
 	DUK_ASSERT(retval == 0 || retval == 1);
 
 	/* Fast path for fastints */
 #if defined(DUK_USE_FASTINT)
 	if (DUK_LIKELY(DUK_TVAL_IS_FASTINT(tv_x) && DUK_TVAL_IS_FASTINT(tv_y))) {
-		return duk__compare_fastint(retval,
-		                            DUK_TVAL_GET_FASTINT(tv_x),
-		                            DUK_TVAL_GET_FASTINT(tv_y));
+		return duk__compare_fastint(retval, DUK_TVAL_GET_FASTINT(tv_x), DUK_TVAL_GET_FASTINT(tv_y));
 	}
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
 	/* Fast path for numbers (one of which may be a fastint) */
 #if !defined(DUK_USE_PREFER_SIZE)
 	if (DUK_LIKELY(DUK_TVAL_IS_NUMBER(tv_x) && DUK_TVAL_IS_NUMBER(tv_y))) {
-		return duk__compare_number(retval,
-		                           DUK_TVAL_GET_NUMBER(tv_x),
-		                           DUK_TVAL_GET_NUMBER(tv_y));
+		return duk__compare_number(retval, DUK_TVAL_GET_NUMBER(tv_x), DUK_TVAL_GET_NUMBER(tv_y));
 	}
 #endif
 
 	/* Slow path */
 
 	duk_push_tval(thr, tv_x);
 	duk_push_tval(thr, tv_y);
@@ -82278,15 +83591,15 @@
 #else
 	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(duk_get_tval(thr, -2)));
 	DUK_ASSERT(!DUK_TVAL_NEEDS_REFCOUNT_UPDATE(duk_get_tval(thr, -1)));
 	DUK_ASSERT(duk_get_top(thr) >= 2);
 	thr->valstack_top -= 2;
 	tv_x = thr->valstack_top;
 	tv_y = tv_x + 1;
-	DUK_TVAL_SET_UNDEFINED(tv_x);  /* Value stack policy */
+	DUK_TVAL_SET_UNDEFINED(tv_x); /* Value stack policy */
 	DUK_TVAL_SET_UNDEFINED(tv_y);
 #endif
 
 	return duk__compare_number(retval, d1, d2);
 }
 
 /*
@@ -82332,16 +83645,16 @@
 #if defined(DUK_USE_SYMBOL_BUILTIN)
 	/*
 	 *  @@hasInstance check, ES2015 Section 12.9.4, Steps 2-4.
 	 */
 	if (!skip_sym_check) {
 		if (duk_get_method_stridx(thr, -1, DUK_STRIDX_WELLKNOWN_SYMBOL_HAS_INSTANCE)) {
 			/* [ ... lhs rhs func ] */
-			duk_insert(thr, -3);    /* -> [ ... func lhs rhs ] */
-			duk_swap_top(thr, -2);  /* -> [ ... func rhs(this) lhs ] */
+			duk_insert(thr, -3); /* -> [ ... func lhs rhs ] */
+			duk_swap_top(thr, -2); /* -> [ ... func rhs(this) lhs ] */
 			duk_call_method(thr, 1);
 			return duk_to_boolean_top_pop(thr);
 		}
 	}
 #else
 	DUK_UNREF(skip_sym_check);
 #endif
@@ -82365,15 +83678,15 @@
 		 */
 		goto error_invalid_rval;
 	}
 
 	if (DUK_HOBJECT_HAS_BOUNDFUNC(func)) {
 		duk_push_tval(thr, &((duk_hboundfunc *) (void *) func)->target);
 		duk_replace(thr, -2);
-		func = duk_require_hobject(thr, -1);  /* lightfunc throws */
+		func = duk_require_hobject(thr, -1); /* lightfunc throws */
 
 		/* Rely on Function.prototype.bind() never creating bound
 		 * functions whose target is not proper.
 		 */
 		DUK_ASSERT(func != NULL);
 		DUK_ASSERT(DUK_HOBJECT_IS_CALLABLE(func));
 	}
@@ -82405,27 +83718,27 @@
 		DUK_ASSERT(val != NULL);
 		break;
 	case DUK_TAG_POINTER:
 		val = thr->builtins[DUK_BIDX_POINTER_PROTOTYPE];
 		DUK_ASSERT(val != NULL);
 		break;
 	case DUK_TAG_OBJECT:
-		skip_first = 1;  /* Ignore object itself on first round. */
+		skip_first = 1; /* Ignore object itself on first round. */
 		val = DUK_TVAL_GET_OBJECT(tv);
 		DUK_ASSERT(val != NULL);
 		break;
 	default:
 		goto pop2_and_false;
 	}
-	DUK_ASSERT(val != NULL);  /* Loop doesn't actually rely on this. */
+	DUK_ASSERT(val != NULL); /* Loop doesn't actually rely on this. */
 
 	/* Look up .prototype of rval.  Leave it on the value stack in case it
 	 * has been virtualized (e.g. getter, Proxy trap).
 	 */
-	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_PROTOTYPE);  /* -> [ ... lval rval rval.prototype ] */
+	duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_PROTOTYPE); /* -> [ ... lval rval rval.prototype ] */
 #if defined(DUK_USE_VERBOSE_ERRORS)
 	proto = duk_get_hobject(thr, -1);
 	if (proto == NULL) {
 		goto error_invalid_rval_noproto;
 	}
 #else
 	proto = duk_require_hobject(thr, -1);
@@ -82470,32 +83783,32 @@
 		val = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, val);
 	} while (--sanity > 0);
 
 	DUK_ASSERT(sanity == 0);
 	DUK_ERROR_RANGE(thr, DUK_STR_PROTOTYPE_CHAIN_LIMIT);
 	DUK_WO_NORETURN(return 0;);
 
- pop2_and_false:
+pop2_and_false:
 	duk_pop_2_unsafe(thr);
 	return 0;
 
- pop3_and_false:
+pop3_and_false:
 	duk_pop_3_unsafe(thr);
 	return 0;
 
- pop3_and_true:
+pop3_and_true:
 	duk_pop_3_unsafe(thr);
 	return 1;
 
- error_invalid_rval:
+error_invalid_rval:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_INSTANCEOF_RVAL);
 	DUK_WO_NORETURN(return 0;);
 
 #if defined(DUK_USE_VERBOSE_ERRORS)
- error_invalid_rval_noproto:
+error_invalid_rval_noproto:
 	DUK_ERROR_TYPE(thr, DUK_STR_INVALID_INSTANCEOF_RVAL_NOPROTO);
 	DUK_WO_NORETURN(return 0;);
 #endif
 }
 
 #if defined(DUK_USE_SYMBOL_BUILTIN)
 DUK_INTERNAL duk_bool_t duk_js_instanceof_ordinary(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
@@ -82539,17 +83852,15 @@
 	 */
 	duk_push_tval(thr, tv_x);
 	duk_push_tval(thr, tv_y);
 	duk_require_type_mask(thr, -1, DUK_TYPE_MASK_OBJECT | DUK_TYPE_MASK_LIGHTFUNC | DUK_TYPE_MASK_BUFFER);
 
 	(void) duk_to_property_key_hstring(thr, -2);
 
-	retval = duk_hobject_hasprop(thr,
-	                             DUK_GET_TVAL_NEGIDX(thr, -1),
-	                             DUK_GET_TVAL_NEGIDX(thr, -2));
+	retval = duk_hobject_hasprop(thr, DUK_GET_TVAL_NEGIDX(thr, -1), DUK_GET_TVAL_NEGIDX(thr, -2));
 
 	duk_pop_2_unsafe(thr);
 	return retval;
 }
 
 /*
  *  typeof
@@ -82701,15 +84012,15 @@
 				}
 				DUK_ASSERT(res == 0x19999999UL);
 				if (dig >= 6U) {
 					goto parse_fail;
 				}
 				res = 0xfffffffaUL + dig;
 				DUK_ASSERT(res >= 0xfffffffaUL);
-				DUK_ASSERT_DISABLE(res <= 0xffffffffUL);  /* range */
+				DUK_ASSERT_DISABLE(res <= 0xffffffffUL); /* range */
 			} else {
 				res = res * 10U + dig;
 				if (DUK_UNLIKELY(res == 0)) {
 					/* If 'res' is 0, previous 'res' must
 					 * have been 0 and we scanned in a zero.
 					 * This is only allowed if blen == 1,
 					 * i.e. the exact string '0'.
@@ -82726,15 +84037,15 @@
 			 */
 			goto parse_fail;
 		}
 	} while (--blen > 0);
 
 	return res;
 
- parse_fail:
+parse_fail:
 	return DUK_HSTRING_NO_ARRAY_INDEX;
 }
 
 #if !defined(DUK_USE_HSTRING_ARRIDX)
 /* Get array index for a string which is known to be an array index.  This helper
  * is needed when duk_hstring doesn't concretely store the array index, but strings
  * are flagged as array indices at intern time.
@@ -82764,15 +84075,15 @@
 DUK_INTERNAL duk_uarridx_t duk_js_to_arrayindex_hstring_fast(duk_hstring *h) {
 	DUK_ASSERT(h != NULL);
 	if (!DUK_HSTRING_HAS_ARRIDX(h)) {
 		return DUK_HSTRING_NO_ARRAY_INDEX;
 	}
 	return duk_js_to_arrayindex_hstring_fast_known(h);
 }
-#endif  /* DUK_USE_HSTRING_ARRIDX */
+#endif /* DUK_USE_HSTRING_ARRIDX */
 #line 1 "duk_js_var.c"
 /*
  *  Identifier access and function closure handling.
  *
  *  Provides the primitives for slow path identifier accesses: GETVAR,
  *  PUTVAR, DELVAR, etc.  The fast path, direct register accesses, should
  *  be used for most identifier accesses.  Consequently, these slow path
@@ -82806,18 +84117,18 @@
 
 /*
  *  Local result type for duk__get_identifier_reference() lookup.
  */
 
 typedef struct {
 	duk_hobject *env;
-	duk_hobject *holder;      /* for object-bound identifiers */
-	duk_tval *value;          /* for register-bound and declarative env identifiers */
-	duk_uint_t attrs;         /* property attributes for identifier (relevant if value != NULL) */
-	duk_bool_t has_this;      /* for object-bound identifiers: provide 'this' binding */
+	duk_hobject *holder; /* for object-bound identifiers */
+	duk_tval *value; /* for register-bound and declarative env identifiers */
+	duk_uint_t attrs; /* property attributes for identifier (relevant if value != NULL) */
+	duk_bool_t has_this; /* for object-bound identifiers: provide 'this' binding */
 } duk__id_lookup_result;
 
 /*
  *  Create a new function object based on a "template function" which contains
  *  compiled bytecode, constants, etc, but lacks a lexical environment.
  *
  *  ECMAScript requires that each created closure is a separate object, with
@@ -82913,15 +84224,15 @@
 
 	DUK_STATS_INC(thr->heap, stats_envrec_pushclosure);
 
 	fun_clos = duk_push_hcompfunc(thr);
 	DUK_ASSERT(fun_clos != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) fun_clos) == thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE]);
 
-	duk_push_hobject(thr, &fun_temp->obj);  /* -> [ ... closure template ] */
+	duk_push_hobject(thr, &fun_temp->obj); /* -> [ ... closure template ] */
 
 	DUK_ASSERT(DUK_HOBJECT_IS_COMPFUNC((duk_hobject *) fun_clos));
 	DUK_ASSERT(DUK_HCOMPFUNC_GET_DATA(thr->heap, fun_clos) == NULL);
 	DUK_ASSERT(DUK_HCOMPFUNC_GET_FUNCS(thr->heap, fun_clos) == NULL);
 	DUK_ASSERT(DUK_HCOMPFUNC_GET_BYTECODE(thr->heap, fun_clos) == NULL);
 
 	DUK_HCOMPFUNC_SET_DATA(thr->heap, fun_clos, DUK_HCOMPFUNC_GET_DATA(thr->heap, fun_temp));
@@ -83021,54 +84332,53 @@
 			if (outer_lex_env) {
 				proto = outer_lex_env;
 			} else {
 				proto = thr->builtins[DUK_BIDX_GLOBAL_ENV];
 			}
 
 			/* -> [ ... closure template env ] */
-			new_env = duk_hdecenv_alloc(thr,
-			                            DUK_HOBJECT_FLAG_EXTENSIBLE |
-			                            DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
+			new_env =
+			    duk_hdecenv_alloc(thr,
+			                      DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
 			DUK_ASSERT(new_env != NULL);
 			duk_push_hobject(thr, (duk_hobject *) new_env);
 
 			DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) new_env) == NULL);
 			DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) new_env, proto);
 			DUK_HOBJECT_INCREF_ALLOWNULL(thr, proto);
 
-			DUK_ASSERT(new_env->thread == NULL);  /* Closed. */
+			DUK_ASSERT(new_env->thread == NULL); /* Closed. */
 			DUK_ASSERT(new_env->varmap == NULL);
 
 			/* It's important that duk_xdef_prop() is a 'raw define' so that any
 			 * properties in an ancestor are never an issue (they should never be
 			 * e.g. non-writable, but just in case).
 			 *
 			 * Because template objects are not visible to user code, the case
 			 * where .name is missing shouldn't happen in practice.  It it does,
 			 * the name 'undefined' gets bound and maps to the closure (which is
 			 * a bit odd, but safe).
 			 */
 			(void) duk_get_prop_stridx_short(thr, -2, DUK_STRIDX_NAME);
 			/* -> [ ... closure template env funcname ] */
-			duk_dup_m4(thr);                                           /* -> [ ... closure template env funcname closure ] */
-			duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_NONE);           /* -> [ ... closure template env ] */
+			duk_dup_m4(thr); /* -> [ ... closure template env funcname closure ] */
+			duk_xdef_prop(thr, -3, DUK_PROPDESC_FLAGS_NONE); /* -> [ ... closure template env ] */
 			/* env[funcname] = closure */
 
 			/* [ ... closure template env ] */
 
 			DUK_HCOMPFUNC_SET_LEXENV(thr->heap, fun_clos, (duk_hobject *) new_env);
 			DUK_HCOMPFUNC_SET_VARENV(thr->heap, fun_clos, (duk_hobject *) new_env);
 			DUK_HOBJECT_INCREF(thr, (duk_hobject *) new_env);
 			DUK_HOBJECT_INCREF(thr, (duk_hobject *) new_env);
 			duk_pop_unsafe(thr);
 
 			/* [ ... closure template ] */
-		}
-		else
-#endif  /* DUK_USE_FUNC_NAME_PROPERTY */
+		} else
+#endif /* DUK_USE_FUNC_NAME_PROPERTY */
 		{
 			/*
 			 *  Other cases (function declaration, anonymous function expression,
 			 *  strict direct eval code).  The "outer" environment will be whatever
 			 *  the caller gave us.
 			 */
 
@@ -83088,15 +84398,15 @@
 		 *  function.
 		 */
 
 		DUK_ASSERT(!DUK_HOBJECT_HAS_NAMEBINDING(&fun_temp->obj));
 
 		DUK_HCOMPFUNC_SET_LEXENV(thr->heap, fun_clos, outer_lex_env);
 		DUK_HCOMPFUNC_SET_VARENV(thr->heap, fun_clos, outer_var_env);
-		DUK_HOBJECT_INCREF(thr, outer_lex_env);  /* NULLs not allowed; asserted on entry */
+		DUK_HOBJECT_INCREF(thr, outer_lex_env); /* NULLs not allowed; asserted on entry */
 		DUK_HOBJECT_INCREF(thr, outer_var_env);
 	}
 	DUK_DDD(DUK_DDDPRINT("closure varenv -> %!ipO, lexenv -> %!ipO",
 	                     (duk_heaphdr *) fun_clos->var_env,
 	                     (duk_heaphdr *) fun_clos->lex_env));
 
 	/* Call handling assumes this for all callable closures. */
@@ -83147,15 +84457,15 @@
 		len_value = (duk_uint_t) formals->length;
 		DUK_DD(DUK_DDPRINT("closure length from _Formals -> %ld", (long) len_value));
 	} else {
 		len_value = fun_temp->nargs;
 		DUK_DD(DUK_DDPRINT("closure length defaulted from nargs -> %ld", (long) len_value));
 	}
 
-	duk_push_uint(thr, len_value);  /* [ ... closure template len_value ] */
+	duk_push_uint(thr, len_value); /* [ ... closure template len_value ] */
 	duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_LENGTH, DUK_PROPDESC_FLAGS_C);
 
 	/*
 	 *  "prototype" is, by default, a fresh object with the "constructor"
 	 *  property.
 	 *
 	 *  Note that this creates a circular reference for every function
@@ -83167,19 +84477,22 @@
 	 *  prototype is unnecessary.  Perhaps it could be created on-demand
 	 *  when it is first accessed?
 	 */
 
 	/* [ ... closure template ] */
 
 	if (add_auto_proto) {
-		duk_push_object(thr);  /* -> [ ... closure template newobj ] */
-		duk_dup_m3(thr);       /* -> [ ... closure template newobj closure ] */
-		duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_CONSTRUCTOR, DUK_PROPDESC_FLAGS_WC);  /* -> [ ... closure template newobj ] */
-		duk_compact(thr, -1);  /* compact the prototype */
-		duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_PROTOTYPE, DUK_PROPDESC_FLAGS_W);     /* -> [ ... closure template ] */
+		duk_push_object(thr); /* -> [ ... closure template newobj ] */
+		duk_dup_m3(thr); /* -> [ ... closure template newobj closure ] */
+		duk_xdef_prop_stridx_short(thr,
+		                           -2,
+		                           DUK_STRIDX_CONSTRUCTOR,
+		                           DUK_PROPDESC_FLAGS_WC); /* -> [ ... closure template newobj ] */
+		duk_compact(thr, -1); /* compact the prototype */
+		duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_PROTOTYPE, DUK_PROPDESC_FLAGS_W); /* -> [ ... closure template ] */
 	}
 
 	/*
 	 *  "arguments" and "caller" must be mapped to throwers for strict
 	 *  mode and bound functions (E5 Section 15.3.5).
 	 *
 	 *  XXX: This is expensive to have for every strict function instance.
@@ -83212,15 +84525,15 @@
 	/* XXX: Look for own property only; doesn't matter much because
 	 * templates are bare objects.
 	 */
 	if (duk_get_prop_stridx_short(thr, -1, DUK_STRIDX_NAME)) {
 		/* [ ... closure template name ] */
 		DUK_ASSERT(duk_is_string(thr, -1));
 		DUK_DD(DUK_DDPRINT("setting function instance name to %!T", duk_get_tval(thr, -1)));
-		duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_C);  /* -> [ ... closure template ] */
+		duk_xdef_prop_stridx_short(thr, -3, DUK_STRIDX_NAME, DUK_PROPDESC_FLAGS_C); /* -> [ ... closure template ] */
 	} else {
 		/* Anonymous functions don't have a .name in ES2015, so don't set
 		 * it on the instance either.  The instance will then inherit
 		 * it from Function.prototype.name.
 		 */
 		DUK_DD(DUK_DDPRINT("not setting function instance .name"));
 		duk_pop_unsafe(thr);
@@ -83244,18 +84557,16 @@
 
 	DUK_ASSERT(DUK_HOBJECT_GET_CLASS_NUMBER(&fun_clos->obj) == DUK_HOBJECT_CLASS_FUNCTION);
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, &fun_clos->obj) == thr->builtins[DUK_BIDX_FUNCTION_PROTOTYPE]);
 	DUK_ASSERT(DUK_HOBJECT_HAS_EXTENSIBLE(&fun_clos->obj));
 	DUK_ASSERT(duk_has_prop_stridx(thr, -2, DUK_STRIDX_LENGTH) != 0);
 	DUK_ASSERT(add_auto_proto == 0 || duk_has_prop_stridx(thr, -2, DUK_STRIDX_PROTOTYPE) != 0);
 	/* May be missing .name */
-	DUK_ASSERT(!DUK_HOBJECT_HAS_STRICT(&fun_clos->obj) ||
-	           duk_has_prop_stridx(thr, -2, DUK_STRIDX_CALLER) != 0);
-	DUK_ASSERT(!DUK_HOBJECT_HAS_STRICT(&fun_clos->obj) ||
-	           duk_has_prop_stridx(thr, -2, DUK_STRIDX_LC_ARGUMENTS) != 0);
+	DUK_ASSERT(!DUK_HOBJECT_HAS_STRICT(&fun_clos->obj) || duk_has_prop_stridx(thr, -2, DUK_STRIDX_CALLER) != 0);
+	DUK_ASSERT(!DUK_HOBJECT_HAS_STRICT(&fun_clos->obj) || duk_has_prop_stridx(thr, -2, DUK_STRIDX_LC_ARGUMENTS) != 0);
 
 	/*
 	 *  Finish
 	 */
 
 	/* [ ... closure template ] */
 
@@ -83278,16 +84589,16 @@
 DUK_LOCAL void duk__preallocate_env_entries(duk_hthread *thr, duk_hobject *varmap, duk_hobject *env) {
 	duk_uint_fast32_t i;
 
 	for (i = 0; i < (duk_uint_fast32_t) DUK_HOBJECT_GET_ENEXT(varmap); i++) {
 		duk_hstring *key;
 
 		key = DUK_HOBJECT_E_GET_KEY(thr->heap, varmap, i);
-		DUK_ASSERT(key != NULL);   /* assume keys are compact in _Varmap */
-		DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, varmap, i));  /* assume plain values */
+		DUK_ASSERT(key != NULL); /* assume keys are compact in _Varmap */
+		DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, varmap, i)); /* assume plain values */
 
 		/* Predefine as 'undefined' to reserve a property slot.
 		 * This makes the unwind process (where register values
 		 * are copied to the env object) safe against throwing.
 		 *
 		 * XXX: This could be made much faster by creating the
 		 * property table directly.
@@ -83296,17 +84607,15 @@
 		DUK_DDD(DUK_DDDPRINT("preallocate env entry for key %!O", key));
 		duk_hobject_define_property_internal(thr, env, key, DUK_PROPDESC_FLAGS_WE);
 	}
 }
 
 /* shared helper */
 DUK_INTERNAL
-duk_hobject *duk_create_activation_environment_record(duk_hthread *thr,
-                                                      duk_hobject *func,
-                                                      duk_size_t bottom_byteoff) {
+duk_hobject *duk_create_activation_environment_record(duk_hthread *thr, duk_hobject *func, duk_size_t bottom_byteoff) {
 	duk_hdecenv *env;
 	duk_hobject *parent;
 	duk_hcompfunc *f;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(func != NULL);
 
@@ -83314,23 +84623,21 @@
 
 	f = (duk_hcompfunc *) func;
 	parent = DUK_HCOMPFUNC_GET_LEXENV(thr->heap, f);
 	if (!parent) {
 		parent = thr->builtins[DUK_BIDX_GLOBAL_ENV];
 	}
 
-	env = duk_hdecenv_alloc(thr,
-	                        DUK_HOBJECT_FLAG_EXTENSIBLE |
-	                        DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
+	env = duk_hdecenv_alloc(thr, DUK_HOBJECT_FLAG_EXTENSIBLE | DUK_HOBJECT_CLASS_AS_FLAGS(DUK_HOBJECT_CLASS_DECENV));
 	DUK_ASSERT(env != NULL);
 	duk_push_hobject(thr, (duk_hobject *) env);
 
 	DUK_ASSERT(DUK_HOBJECT_GET_PROTOTYPE(thr->heap, (duk_hobject *) env) == NULL);
 	DUK_HOBJECT_SET_PROTOTYPE(thr->heap, (duk_hobject *) env, parent);
-	DUK_HOBJECT_INCREF_ALLOWNULL(thr, parent);  /* parent env is the prototype */
+	DUK_HOBJECT_INCREF_ALLOWNULL(thr, parent); /* parent env is the prototype */
 
 	/* open scope information, for compiled functions only */
 
 	DUK_ASSERT(env->thread == NULL);
 	DUK_ASSERT(env->varmap == NULL);
 	DUK_ASSERT(env->regbase_byteoff == 0);
 	if (DUK_HOBJECT_IS_COMPFUNC(func)) {
@@ -83356,23 +84663,22 @@
 		}
 	}
 
 	return (duk_hobject *) env;
 }
 
 DUK_INTERNAL
-void duk_js_init_activation_environment_records_delayed(duk_hthread *thr,
-                                                        duk_activation *act) {
+void duk_js_init_activation_environment_records_delayed(duk_hthread *thr, duk_activation *act) {
 	duk_hobject *func;
 	duk_hobject *env;
 
 	DUK_ASSERT(thr != NULL);
 	func = DUK_ACT_GET_FUNC(act);
 	DUK_ASSERT(func != NULL);
-	DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func));  /* bound functions are never in act 'func' */
+	DUK_ASSERT(!DUK_HOBJECT_HAS_BOUNDFUNC(func)); /* bound functions are never in act 'func' */
 
 	/*
 	 *  Delayed initialization only occurs for 'NEWENV' functions.
 	 */
 
 	DUK_ASSERT(DUK_HOBJECT_HAS_NEWENV(func));
 	DUK_ASSERT(act->lex_env == NULL);
@@ -83393,15 +84699,15 @@
 			p = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, p);
 		}
 	}
 #endif
 
 	act->lex_env = env;
 	act->var_env = env;
-	DUK_HOBJECT_INCREF(thr, env);  /* XXX: incref by count (here 2 times) */
+	DUK_HOBJECT_INCREF(thr, env); /* XXX: incref by count (here 2 times) */
 	DUK_HOBJECT_INCREF(thr, env);
 
 	duk_pop_unsafe(thr);
 }
 
 /*
  *  Closing environment records.
@@ -83463,44 +84769,47 @@
 	 * Hash part would need special treatment however (maybe copy, and
 	 * then realloc with hash part if large enough).
 	 */
 	for (i = 0; i < (duk_uint_fast32_t) DUK_HOBJECT_GET_ENEXT(varmap); i++) {
 		duk_size_t regbase_byteoff;
 
 		key = DUK_HOBJECT_E_GET_KEY(thr->heap, varmap, i);
-		DUK_ASSERT(key != NULL);   /* assume keys are compact in _Varmap */
-		DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, varmap, i));  /* assume plain values */
+		DUK_ASSERT(key != NULL); /* assume keys are compact in _Varmap */
+		DUK_ASSERT(!DUK_HOBJECT_E_SLOT_IS_ACCESSOR(thr->heap, varmap, i)); /* assume plain values */
 
 		tv = DUK_HOBJECT_E_GET_VALUE_TVAL_PTR(thr->heap, varmap, i);
 		DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
-		DUK_ASSERT(DUK_TVAL_GET_NUMBER(tv) <= (duk_double_t) DUK_UINT32_MAX);  /* limits */
+		DUK_ASSERT(DUK_TVAL_GET_NUMBER(tv) <= (duk_double_t) DUK_UINT32_MAX); /* limits */
 #if defined(DUK_USE_FASTINT)
 		DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv));
 		regnum = (duk_uint_t) DUK_TVAL_GET_FASTINT_U32(tv);
 #else
 		regnum = (duk_uint_t) DUK_TVAL_GET_NUMBER(tv);
 #endif
 
 		regbase_byteoff = ((duk_hdecenv *) env)->regbase_byteoff;
-		DUK_ASSERT((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum >= (duk_uint8_t *) thr->valstack);
-		DUK_ASSERT((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum < (duk_uint8_t *) thr->valstack_top);
+		DUK_ASSERT((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum >=
+		           (duk_uint8_t *) thr->valstack);
+		DUK_ASSERT((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum <
+		           (duk_uint8_t *) thr->valstack_top);
 
 		/* Write register value into env as named properties.
 		 * If property already exists, overwrites silently.
 		 * Property is writable, but not deletable (not configurable
 		 * in terms of property attributes).
 		 *
 		 * This property write must not throw because we're unwinding
 		 * and unwind code is not allowed to throw at present.  The
 		 * call itself has no such guarantees, but we've preallocated
 		 * entries for each property when the env was created, so no
 		 * out-of-memory error should be possible.  If this guarantee
 		 * is not provided, problems like GH-476 may happen.
 		 */
-		duk_push_tval(thr, (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum));
+		duk_push_tval(thr,
+		              (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum));
 		DUK_DDD(DUK_DDDPRINT("closing identifier %!O -> reg %ld, value %!T",
 		                     (duk_heaphdr *) key,
 		                     (long) regnum,
 		                     (duk_tval *) duk_get_tval(thr, -1)));
 		duk_hobject_define_property_internal(thr, env, key, DUK_PROPDESC_FLAGS_WE);
 	}
 
@@ -83534,18 +84843,15 @@
  *
  *  The 'out' structure values are only valid if the function returns
  *  success (non-zero).
  */
 
 /* lookup name from an open declarative record's registers */
 DUK_LOCAL
-duk_bool_t duk__getid_open_decl_env_regs(duk_hthread *thr,
-                                         duk_hstring *name,
-                                         duk_hdecenv *env,
-                                         duk__id_lookup_result *out) {
+duk_bool_t duk__getid_open_decl_env_regs(duk_hthread *thr, duk_hstring *name, duk_hdecenv *env, duk__id_lookup_result *out) {
 	duk_tval *tv;
 	duk_size_t reg_rel;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(name != NULL);
 	DUK_ASSERT(env != NULL);
 	DUK_ASSERT(out != NULL);
@@ -83561,40 +84867,37 @@
 
 	tv = duk_hobject_find_entry_tval_ptr(thr->heap, env->varmap, name);
 	if (DUK_UNLIKELY(tv == NULL)) {
 		return 0;
 	}
 
 	DUK_ASSERT(DUK_TVAL_IS_NUMBER(tv));
-	DUK_ASSERT(DUK_TVAL_GET_NUMBER(tv) <= (duk_double_t) DUK_UINT32_MAX);  /* limits */
+	DUK_ASSERT(DUK_TVAL_GET_NUMBER(tv) <= (duk_double_t) DUK_UINT32_MAX); /* limits */
 #if defined(DUK_USE_FASTINT)
 	DUK_ASSERT(DUK_TVAL_IS_FASTINT(tv));
 	reg_rel = (duk_size_t) DUK_TVAL_GET_FASTINT_U32(tv);
 #else
 	reg_rel = (duk_size_t) DUK_TVAL_GET_NUMBER(tv);
 #endif
-	DUK_ASSERT_DISABLE(reg_rel >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(reg_rel >= 0); /* unsigned */
 
 	tv = (duk_tval *) (void *) ((duk_uint8_t *) env->thread->valstack + env->regbase_byteoff + sizeof(duk_tval) * reg_rel);
-	DUK_ASSERT(tv >= env->thread->valstack && tv < env->thread->valstack_end);  /* XXX: more accurate? */
+	DUK_ASSERT(tv >= env->thread->valstack && tv < env->thread->valstack_end); /* XXX: more accurate? */
 
 	out->value = tv;
-	out->attrs = DUK_PROPDESC_FLAGS_W;  /* registers are mutable, non-deletable */
+	out->attrs = DUK_PROPDESC_FLAGS_W; /* registers are mutable, non-deletable */
 	out->env = (duk_hobject *) env;
 	out->holder = NULL;
 	out->has_this = 0;
 	return 1;
 }
 
 /* lookup name from current activation record's functions' registers */
 DUK_LOCAL
-duk_bool_t duk__getid_activation_regs(duk_hthread *thr,
-                                      duk_hstring *name,
-                                      duk_activation *act,
-                                      duk__id_lookup_result *out) {
+duk_bool_t duk__getid_activation_regs(duk_hthread *thr, duk_hstring *name, duk_activation *act, duk__id_lookup_result *out) {
 	duk_tval *tv;
 	duk_hobject *func;
 	duk_hobject *varmap;
 	duk_size_t reg_rel;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(name != NULL);
@@ -83624,15 +84927,15 @@
 	DUK_ASSERT_DISABLE(reg_rel >= 0);
 	DUK_ASSERT(reg_rel < ((duk_hcompfunc *) func)->nregs);
 
 	tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 	tv += reg_rel;
 
 	out->value = tv;
-	out->attrs = DUK_PROPDESC_FLAGS_W;  /* registers are mutable, non-deletable */
+	out->attrs = DUK_PROPDESC_FLAGS_W; /* registers are mutable, non-deletable */
 	out->env = NULL;
 	out->holder = NULL;
 	out->has_this = 0;
 	return 1;
 }
 
 DUK_LOCAL
@@ -83680,17 +84983,20 @@
 		 *  Try registers
 		 */
 
 		if (duk__getid_activation_regs(thr, name, act, out)) {
 			DUK_DDD(DUK_DDDPRINT("duk__get_identifier_reference successful: "
 			                     "name=%!O -> value=%!T, attrs=%ld, has_this=%ld, env=%!O, holder=%!O "
 			                     "(found from register bindings when env=NULL)",
-			                     (duk_heaphdr *) name, (duk_tval *) out->value,
-			                     (long) out->attrs, (long) out->has_this,
-			                     (duk_heaphdr *) out->env, (duk_heaphdr *) out->holder));
+			                     (duk_heaphdr *) name,
+			                     (duk_tval *) out->value,
+			                     (long) out->attrs,
+			                     (long) out->has_this,
+			                     (duk_heaphdr *) out->env,
+			                     (duk_heaphdr *) out->holder));
 			return 1;
 		}
 
 		DUK_DDD(DUK_DDDPRINT("not found in current activation regs"));
 
 		/*
 		 *  Not found in registers, proceed to the parent record.
@@ -83719,16 +85025,15 @@
 		f = (duk_hcompfunc *) func;
 
 		env = DUK_HCOMPFUNC_GET_LEXENV(thr->heap, f);
 		if (!env) {
 			env = thr->builtins[DUK_BIDX_GLOBAL_ENV];
 		}
 
-		DUK_DDD(DUK_DDDPRINT("continue lookup from env: %!iO",
-		                     (duk_heaphdr *) env));
+		DUK_DDD(DUK_DDDPRINT("continue lookup from env: %!iO", (duk_heaphdr *) env));
 	}
 
 	/*
 	 *  Prototype walking starting from 'env'.
 	 *
 	 *  ('act' is not needed anywhere here.)
 	 */
@@ -83763,34 +85068,40 @@
 			 */
 
 			DUK_HDECENV_ASSERT_VALID((duk_hdecenv *) env);
 			if (duk__getid_open_decl_env_regs(thr, name, (duk_hdecenv *) env, out)) {
 				DUK_DDD(DUK_DDDPRINT("duk__get_identifier_reference successful: "
 				                     "name=%!O -> value=%!T, attrs=%ld, has_this=%ld, env=%!O, holder=%!O "
 				                     "(declarative environment record, scope open, found in regs)",
-				                     (duk_heaphdr *) name, (duk_tval *) out->value,
-				                     (long) out->attrs, (long) out->has_this,
-				                     (duk_heaphdr *) out->env, (duk_heaphdr *) out->holder));
+				                     (duk_heaphdr *) name,
+				                     (duk_tval *) out->value,
+				                     (long) out->attrs,
+				                     (long) out->has_this,
+				                     (duk_heaphdr *) out->env,
+				                     (duk_heaphdr *) out->holder));
 				return 1;
 			}
 
 			tv = duk_hobject_find_entry_tval_ptr_and_attrs(thr->heap, env, name, &attrs);
 			if (tv) {
 				out->value = tv;
 				out->attrs = attrs;
 				out->env = env;
 				out->holder = env;
 				out->has_this = 0;
 
 				DUK_DDD(DUK_DDDPRINT("duk__get_identifier_reference successful: "
 				                     "name=%!O -> value=%!T, attrs=%ld, has_this=%ld, env=%!O, holder=%!O "
 				                     "(declarative environment record, found in properties)",
-				                     (duk_heaphdr *) name, (duk_tval *) out->value,
-				                     (long) out->attrs, (long) out->has_this,
-				                     (duk_heaphdr *) out->env, (duk_heaphdr *) out->holder));
+				                     (duk_heaphdr *) name,
+				                     (duk_tval *) out->value,
+				                     (long) out->attrs,
+				                     (long) out->has_this,
+				                     (duk_heaphdr *) out->env,
+				                     (duk_heaphdr *) out->holder));
 				return 1;
 			}
 		} else {
 			/*
 			 *  Object environment record.
 			 *
 			 *  Binding (target) object is an external, uncontrolled object.
@@ -83827,59 +85138,62 @@
 
 				DUK_ASSERT(name != NULL);
 				DUK_TVAL_SET_STRING(&tv_name, name);
 				DUK_TVAL_SET_OBJECT(&tv_target_tmp, target);
 
 				found = duk_hobject_hasprop(thr, &tv_target_tmp, &tv_name);
 			} else
-#endif  /* DUK_USE_ES6_PROXY */
+#endif /* DUK_USE_ES6_PROXY */
 			{
 				/* XXX: duk_hobject_hasprop() would be correct for
 				 * non-Proxy objects too, but it is about ~20-25%
 				 * slower at present so separate code paths for
 				 * Proxy and non-Proxy now.
 				 */
 				found = duk_hobject_hasprop_raw(thr, target, name);
 			}
 
 			if (found) {
-				out->value = NULL;  /* can't get value, may be accessor */
-				out->attrs = 0;     /* irrelevant when out->value == NULL */
+				out->value = NULL; /* can't get value, may be accessor */
+				out->attrs = 0; /* irrelevant when out->value == NULL */
 				out->env = env;
 				out->holder = target;
 				out->has_this = ((duk_hobjenv *) env)->has_this;
 
 				DUK_DDD(DUK_DDDPRINT("duk__get_identifier_reference successful: "
 				                     "name=%!O -> value=%!T, attrs=%ld, has_this=%ld, env=%!O, holder=%!O "
 				                     "(object environment record)",
-				                     (duk_heaphdr *) name, (duk_tval *) out->value,
-				                     (long) out->attrs, (long) out->has_this,
-				                     (duk_heaphdr *) out->env, (duk_heaphdr *) out->holder));
+				                     (duk_heaphdr *) name,
+				                     (duk_tval *) out->value,
+				                     (long) out->attrs,
+				                     (long) out->has_this,
+				                     (duk_heaphdr *) out->env,
+				                     (duk_heaphdr *) out->holder));
 				return 1;
 			}
 		}
 
 		if (!parents) {
 			DUK_DDD(DUK_DDDPRINT("duk__get_identifier_reference failed, no parent traversal "
 			                     "(not found from first traversed env)"));
 			goto fail_not_found;
 		}
 
-                if (DUK_UNLIKELY(sanity-- == 0)) {
-                        DUK_ERROR_RANGE(thr, DUK_STR_PROTOTYPE_CHAIN_LIMIT);
+		if (DUK_UNLIKELY(sanity-- == 0)) {
+			DUK_ERROR_RANGE(thr, DUK_STR_PROTOTYPE_CHAIN_LIMIT);
 			DUK_WO_NORETURN(return 0;);
-                }
+		}
 		env = DUK_HOBJECT_GET_PROTOTYPE(thr->heap, env);
 	}
 
 	/*
 	 *  Not found (even in global object)
 	 */
 
- fail_not_found:
+fail_not_found:
 	return 0;
 }
 
 /*
  *  HASVAR: check identifier binding from a given environment record
  *  without traversing its parents.
  *
@@ -83890,15 +85204,15 @@
  *    10.2.1.1.1 HasBinding(N)
  *    10.2.1.2.1 HasBinding(N)
  *
  *  Note: strictness has no bearing on this check.  Hence we don't take
  *  a 'strict' parameter.
  */
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL
 duk_bool_t duk_js_hasvar_envrec(duk_hthread *thr,
                                 duk_hobject *env,
                                 duk_hstring *name) {
 	duk__id_lookup_result ref;
 	duk_bool_t parents;
 
@@ -83946,90 +85260,84 @@
  *
  *  The 'throw' flag is needed for implementing 'typeof' for an unreferenced
  *  identifier.  An unreference identifier in other contexts generates a
  *  ReferenceError.
  */
 
 DUK_LOCAL
-duk_bool_t duk__getvar_helper(duk_hthread *thr,
-                              duk_hobject *env,
-                              duk_activation *act,
-                              duk_hstring *name,
-                              duk_bool_t throw_flag) {
+duk_bool_t duk__getvar_helper(duk_hthread *thr, duk_hobject *env, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag) {
 	duk__id_lookup_result ref;
 	duk_tval tv_tmp_obj;
 	duk_tval tv_tmp_key;
 	duk_bool_t parents;
 
 	DUK_DDD(DUK_DDDPRINT("getvar: thr=%p, env=%p, act=%p, name=%!O "
 	                     "(env -> %!dO)",
-	                     (void *) thr, (void *) env, (void *) act,
-	                     (duk_heaphdr *) name, (duk_heaphdr *) env));
+	                     (void *) thr,
+	                     (void *) env,
+	                     (void *) act,
+	                     (duk_heaphdr *) name,
+	                     (duk_heaphdr *) env));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(name != NULL);
 	/* env and act may be NULL */
 
 	DUK_STATS_INC(thr->heap, stats_getvar_all);
 
-        DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(env);
-        DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(name);
+	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(env);
+	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(name);
 
-	parents = 1;     /* follow parent chain */
+	parents = 1; /* follow parent chain */
 	if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
 		if (ref.value) {
 			duk_push_tval(thr, ref.value);
 			duk_push_undefined(thr);
 		} else {
 			DUK_ASSERT(ref.holder != NULL);
 
 			/* ref.holder is safe across the getprop call (even
 			 * with side effects) because 'env' is reachable and
 			 * ref.holder is a direct heap pointer.
 			 */
 
 			DUK_TVAL_SET_OBJECT(&tv_tmp_obj, ref.holder);
 			DUK_TVAL_SET_STRING(&tv_tmp_key, name);
-			(void) duk_hobject_getprop(thr, &tv_tmp_obj, &tv_tmp_key);  /* [value] */
+			(void) duk_hobject_getprop(thr, &tv_tmp_obj, &tv_tmp_key); /* [value] */
 
 			if (ref.has_this) {
 				duk_push_hobject(thr, ref.holder);
 			} else {
 				duk_push_undefined(thr);
 			}
 
 			/* [value this] */
 		}
 
 		return 1;
 	} else {
 		if (throw_flag) {
-			DUK_ERROR_FMT1(thr, DUK_ERR_REFERENCE_ERROR,
+			DUK_ERROR_FMT1(thr,
+			               DUK_ERR_REFERENCE_ERROR,
 			               "identifier '%s' undefined",
 			               (const char *) DUK_HSTRING_GET_DATA(name));
 			DUK_WO_NORETURN(return 0;);
 		}
 
 		return 0;
 	}
 }
 
 DUK_INTERNAL
-duk_bool_t duk_js_getvar_envrec(duk_hthread *thr,
-                                duk_hobject *env,
-                                duk_hstring *name,
-                                duk_bool_t throw_flag) {
+duk_bool_t duk_js_getvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_bool_t throw_flag) {
 	return duk__getvar_helper(thr, env, NULL, name, throw_flag);
 }
 
 DUK_INTERNAL
-duk_bool_t duk_js_getvar_activation(duk_hthread *thr,
-                                    duk_activation *act,
-                                    duk_hstring *name,
-                                    duk_bool_t throw_flag) {
+duk_bool_t duk_js_getvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag) {
 	DUK_ASSERT(act != NULL);
 	return duk__getvar_helper(thr, act->lex_env, act, name, throw_flag);
 }
 
 /*
  *  PUTVAR
  *
@@ -84058,62 +85366,65 @@
 	duk_tval tv_tmp_key;
 	duk_bool_t parents;
 
 	DUK_STATS_INC(thr->heap, stats_putvar_all);
 
 	DUK_DDD(DUK_DDDPRINT("putvar: thr=%p, env=%p, act=%p, name=%!O, val=%p, strict=%ld "
 	                     "(env -> %!dO, val -> %!T)",
-	                     (void *) thr, (void *) env, (void *) act,
-	                     (duk_heaphdr *) name, (void *) val, (long) strict,
-	                     (duk_heaphdr *) env, (duk_tval *) val));
+	                     (void *) thr,
+	                     (void *) env,
+	                     (void *) act,
+	                     (duk_heaphdr *) name,
+	                     (void *) val,
+	                     (long) strict,
+	                     (duk_heaphdr *) env,
+	                     (duk_tval *) val));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(name != NULL);
 	DUK_ASSERT(val != NULL);
 	/* env and act may be NULL */
 
 	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(env);
 	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(name);
 	DUK_ASSERT_REFCOUNT_NONZERO_TVAL(val);
 
-	DUK_TVAL_SET_TVAL(&tv_tmp_val, val);  /* Stabilize. */
+	DUK_TVAL_SET_TVAL(&tv_tmp_val, val); /* Stabilize. */
 	val = NULL;
 
 	/*
 	 *  In strict mode E5 protects 'eval' and 'arguments' from being
 	 *  assigned to (or even declared anywhere).  Attempt to do so
 	 *  should result in a compile time SyntaxError.  See the internal
 	 *  design documentation for details.
 	 *
 	 *  Thus, we should never come here, run-time, for strict code,
 	 *  and name 'eval' or 'arguments'.
 	 */
 
-	DUK_ASSERT(!strict ||
-	           (name != DUK_HTHREAD_STRING_EVAL(thr) &&
-	            name != DUK_HTHREAD_STRING_LC_ARGUMENTS(thr)));
+	DUK_ASSERT(!strict || (name != DUK_HTHREAD_STRING_EVAL(thr) && name != DUK_HTHREAD_STRING_LC_ARGUMENTS(thr)));
 
 	/*
 	 *  Lookup variable and update in-place if found.
 	 */
 
-	parents = 1;     /* follow parent chain */
+	parents = 1; /* follow parent chain */
 
 	if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
 		if (ref.value && (ref.attrs & DUK_PROPDESC_FLAG_WRITABLE)) {
 			/* Update duk_tval in-place if pointer provided and the
 			 * property is writable.  If the property is not writable
 			 * (immutable binding), use duk_hobject_putprop() which
 			 * will respect mutability.
 			 */
 			duk_tval *tv_val;
 
 			tv_val = ref.value;
 			DUK_ASSERT(tv_val != NULL);
-			DUK_TVAL_SET_TVAL_UPDREF(thr, tv_val, &tv_tmp_val);  /* side effects */
+			DUK_TVAL_SET_TVAL_UPDREF(thr, tv_val, &tv_tmp_val); /* side effects */
 
 			/* ref.value invalidated here */
 		} else {
 			DUK_ASSERT(ref.holder != NULL);
 
 			DUK_TVAL_SET_OBJECT(&tv_tmp_obj, ref.holder);
 			DUK_TVAL_SET_STRING(&tv_tmp_key, name);
@@ -84128,46 +85439,39 @@
 	/*
 	 *  Not found: write to global object (non-strict) or ReferenceError
 	 *  (strict); see E5 Section 8.7.2, step 3.
 	 */
 
 	if (strict) {
 		DUK_DDD(DUK_DDDPRINT("identifier binding not found, strict => reference error"));
-		DUK_ERROR_FMT1(thr, DUK_ERR_REFERENCE_ERROR,
+		DUK_ERROR_FMT1(thr,
+		               DUK_ERR_REFERENCE_ERROR,
 		               "identifier '%s' undefined",
 		               (const char *) DUK_HSTRING_GET_DATA(name));
 		DUK_WO_NORETURN(return;);
 	}
 
 	DUK_DDD(DUK_DDDPRINT("identifier binding not found, not strict => set to global"));
 
 	DUK_TVAL_SET_OBJECT(&tv_tmp_obj, thr->builtins[DUK_BIDX_GLOBAL]);
 	DUK_TVAL_SET_STRING(&tv_tmp_key, name);
-	(void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, &tv_tmp_val, 0);  /* 0 = no throw */
+	(void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, &tv_tmp_val, 0); /* 0 = no throw */
 
 	/* NB: 'val' may be invalidated here because put_value may realloc valstack,
 	 * caller beware.
 	 */
 }
 
 DUK_INTERNAL
-void duk_js_putvar_envrec(duk_hthread *thr,
-                          duk_hobject *env,
-                          duk_hstring *name,
-                          duk_tval *val,
-                          duk_bool_t strict) {
+void duk_js_putvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_tval *val, duk_bool_t strict) {
 	duk__putvar_helper(thr, env, NULL, name, val, strict);
 }
 
 DUK_INTERNAL
-void duk_js_putvar_activation(duk_hthread *thr,
-                              duk_activation *act,
-                              duk_hstring *name,
-                              duk_tval *val,
-                              duk_bool_t strict) {
+void duk_js_putvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_bool_t strict) {
 	DUK_ASSERT(act != NULL);
 	duk__putvar_helper(thr, act->lex_env, act, name, val, strict);
 }
 
 /*
  *  DELVAR
  *
@@ -84184,33 +85488,33 @@
  *  For strict mode code, the 'delete' operator should fail with a compile
  *  time SyntaxError if applied to identifiers.  Hence, no strict mode
  *  run-time deletion of identifiers should ever happen.  This function
  *  should never be called from strict mode code!
  */
 
 DUK_LOCAL
-duk_bool_t duk__delvar_helper(duk_hthread *thr,
-                              duk_hobject *env,
-                              duk_activation *act,
-                              duk_hstring *name) {
+duk_bool_t duk__delvar_helper(duk_hthread *thr, duk_hobject *env, duk_activation *act, duk_hstring *name) {
 	duk__id_lookup_result ref;
 	duk_bool_t parents;
 
 	DUK_DDD(DUK_DDDPRINT("delvar: thr=%p, env=%p, act=%p, name=%!O "
 	                     "(env -> %!dO)",
-	                     (void *) thr, (void *) env, (void *) act,
-	                     (duk_heaphdr *) name, (duk_heaphdr *) env));
+	                     (void *) thr,
+	                     (void *) env,
+	                     (void *) act,
+	                     (duk_heaphdr *) name,
+	                     (duk_heaphdr *) env));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(name != NULL);
 	/* env and act may be NULL */
 
-        DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(name);
+	DUK_ASSERT_REFCOUNT_NONZERO_HEAPHDR(name);
 
-	parents = 1;     /* follow parent chain */
+	parents = 1; /* follow parent chain */
 
 	if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
 		if (ref.value && !(ref.attrs & DUK_PROPDESC_FLAG_CONFIGURABLE)) {
 			/* Identifier found in registers (always non-deletable)
 			 * or declarative environment record and non-configurable.
 			 */
 			return 0;
@@ -84230,27 +85534,25 @@
 
 	DUK_DDD(DUK_DDDPRINT("identifier to be deleted not found: name=%!O "
 	                     "(treated as silent success)",
 	                     (duk_heaphdr *) name));
 	return 1;
 }
 
-#if 0  /*unused*/
+#if 0 /*unused*/
 DUK_INTERNAL
 duk_bool_t duk_js_delvar_envrec(duk_hthread *thr,
                                 duk_hobject *env,
                                 duk_hstring *name) {
 	return duk__delvar_helper(thr, env, NULL, name);
 }
 #endif
 
 DUK_INTERNAL
-duk_bool_t duk_js_delvar_activation(duk_hthread *thr,
-                                    duk_activation *act,
-                                    duk_hstring *name) {
+duk_bool_t duk_js_delvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name) {
 	DUK_ASSERT(act != NULL);
 	return duk__delvar_helper(thr, act->lex_env, act, name);
 }
 
 /*
  *  DECLVAR
  *
@@ -84311,17 +85613,21 @@
 	duk_hobject *holder;
 	duk_bool_t parents;
 	duk__id_lookup_result ref;
 	duk_tval *tv;
 
 	DUK_DDD(DUK_DDDPRINT("declvar: thr=%p, env=%p, name=%!O, val=%!T, prop_flags=0x%08lx, is_func_decl=%ld "
 	                     "(env -> %!iO)",
-	                     (void *) thr, (void *) env, (duk_heaphdr *) name,
-	                     (duk_tval *) val, (unsigned long) prop_flags,
-	                     (unsigned int) is_func_decl, (duk_heaphdr *) env));
+	                     (void *) thr,
+	                     (void *) env,
+	                     (duk_heaphdr *) name,
+	                     (duk_tval *) val,
+	                     (unsigned long) prop_flags,
+	                     (unsigned int) is_func_decl,
+	                     (duk_heaphdr *) env));
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(env != NULL);
 	DUK_ASSERT(name != NULL);
 	DUK_ASSERT(val != NULL);
 
 	/* Note: in strict mode the compiler should reject explicit
@@ -84340,30 +85646,30 @@
 	 *
 	 *  We need to check whether the binding exists in the environment
 	 *  without walking its parents.  However, we still need to check
 	 *  register-bound identifiers and the prototype chain of an object
 	 *  environment target object.
 	 */
 
-	parents = 0;  /* just check 'env' */
+	parents = 0; /* just check 'env' */
 	if (duk__get_identifier_reference(thr, env, name, NULL, parents, &ref)) {
 		duk_int_t e_idx;
 		duk_int_t h_idx;
 		duk_small_uint_t flags;
 
 		/*
 		 *  Variable already declared, ignore re-declaration.
 		 *  The only exception is the updated behavior of E5.1 for
 		 *  global function declarations, E5.1 Section 10.5, step 5.e.
 		 *  This behavior does not apply to global variable declarations.
 		 */
 
 		if (!(is_func_decl && env == thr->builtins[DUK_BIDX_GLOBAL_ENV])) {
 			DUK_DDD(DUK_DDDPRINT("re-declare a binding, ignoring"));
-			return 1;  /* 1 -> needs a PUTVAR */
+			return 1; /* 1 -> needs a PUTVAR */
 		}
 
 		/*
 		 *  Special behavior in E5.1.
 		 *
 		 *  Note that even though parents == 0, the conflicting property
 		 *  may be an inherited property (currently our global object's
@@ -84385,15 +85691,15 @@
 		DUK_ASSERT(ref.holder != NULL);
 		holder = ref.holder;
 
 		/* holder will be set to the target object, not the actual object
 		 * where the property was found (see duk__get_identifier_reference()).
 		 */
 		DUK_ASSERT(DUK_HOBJECT_GET_CLASS_NUMBER(holder) == DUK_HOBJECT_CLASS_GLOBAL);
-		DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARRAY(holder));  /* global object doesn't have array part */
+		DUK_ASSERT(!DUK_HOBJECT_HAS_EXOTIC_ARRAY(holder)); /* global object doesn't have array part */
 
 		/* XXX: use a helper for prototype traversal; no loop check here */
 		/* must be found: was found earlier, and cannot be inherited */
 		for (;;) {
 			DUK_ASSERT(holder != NULL);
 			if (duk_hobject_find_entry(thr->heap, holder, name, &e_idx, &h_idx)) {
 				DUK_ASSERT(e_idx >= 0);
@@ -84418,16 +85724,15 @@
 		flags = DUK_HOBJECT_E_GET_FLAGS(thr->heap, holder, e_idx);
 		if (!(flags & DUK_PROPDESC_FLAG_CONFIGURABLE)) {
 			if (flags & DUK_PROPDESC_FLAG_ACCESSOR) {
 				DUK_DDD(DUK_DDDPRINT("existing property is a non-configurable "
 				                     "accessor -> reject"));
 				goto fail_existing_attributes;
 			}
-			if (!((flags & DUK_PROPDESC_FLAG_WRITABLE) &&
-			      (flags & DUK_PROPDESC_FLAG_ENUMERABLE))) {
+			if (!((flags & DUK_PROPDESC_FLAG_WRITABLE) && (flags & DUK_PROPDESC_FLAG_ENUMERABLE))) {
 				DUK_DDD(DUK_DDDPRINT("existing property is a non-configurable "
 				                     "plain property which is not writable and "
 				                     "enumerable -> reject"));
 				goto fail_existing_attributes;
 			}
 
 			DUK_DDD(DUK_DDDPRINT("existing property is not configurable but "
@@ -84514,21 +85819,21 @@
 	if (!DUK_HOBJECT_HAS_EXTENSIBLE(holder)) {
 		goto fail_not_extensible;
 	}
 
 	duk_push_hobject(thr, holder);
 	duk_push_hstring(thr, name);
 	duk_push_tval(thr, val);
-	duk_xdef_prop(thr, -3, prop_flags);  /* [holder name val] -> [holder] */
+	duk_xdef_prop(thr, -3, prop_flags); /* [holder name val] -> [holder] */
 	duk_pop_unsafe(thr);
 
 	return 0;
 
- fail_existing_attributes:
- fail_not_extensible:
+fail_existing_attributes:
+fail_not_extensible:
 	DUK_ERROR_TYPE(thr, "declaration failed");
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_INTERNAL
 duk_bool_t duk_js_declvar_activation(duk_hthread *thr,
                                      duk_activation *act,
@@ -84642,42 +85947,42 @@
 
 /* #include duk_internal.h -> already included */
 
 /*
  *  Various defines and file specific helper macros
  */
 
-#define DUK__MAX_RE_DECESC_DIGITS     9
-#define DUK__MAX_RE_QUANT_DIGITS      9   /* Does not allow e.g. 2**31-1, but one more would allow overflows of u32. */
+#define DUK__MAX_RE_DECESC_DIGITS 9
+#define DUK__MAX_RE_QUANT_DIGITS  9 /* Does not allow e.g. 2**31-1, but one more would allow overflows of u32. */
 
 /* whether to use macros or helper function depends on call count */
-#define DUK__ISDIGIT(x)          ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_9)
-#define DUK__ISHEXDIGIT(x)       duk__is_hex_digit((x))
-#define DUK__ISOCTDIGIT(x)       ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_7)
-#define DUK__ISDIGIT03(x)        ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_3)
-#define DUK__ISDIGIT47(x)        ((x) >= DUK_ASC_4 && (x) <= DUK_ASC_7)
+#define DUK__ISDIGIT(x)    ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_9)
+#define DUK__ISHEXDIGIT(x) duk__is_hex_digit((x))
+#define DUK__ISOCTDIGIT(x) ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_7)
+#define DUK__ISDIGIT03(x)  ((x) >= DUK_ASC_0 && (x) <= DUK_ASC_3)
+#define DUK__ISDIGIT47(x)  ((x) >= DUK_ASC_4 && (x) <= DUK_ASC_7)
 
 /* lexer character window helpers */
-#define DUK__LOOKUP(lex_ctx,idx)            ((lex_ctx)->window[(idx)].codepoint)
-#define DUK__ADVANCECHARS(lex_ctx,count)    duk__advance_chars((lex_ctx), (count))
-#define DUK__ADVANCEBYTES(lex_ctx,count)    duk__advance_bytes((lex_ctx), (count))
+#define DUK__LOOKUP(lex_ctx, idx)           ((lex_ctx)->window[(idx)].codepoint)
+#define DUK__ADVANCECHARS(lex_ctx, count)   duk__advance_chars((lex_ctx), (count))
+#define DUK__ADVANCEBYTES(lex_ctx, count)   duk__advance_bytes((lex_ctx), (count))
 #define DUK__INITBUFFER(lex_ctx)            duk__initbuffer((lex_ctx))
-#define DUK__APPENDBUFFER(lex_ctx,x)        duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x))
-#define DUK__APPENDBUFFER_ASCII(lex_ctx,x)  duk__appendbuffer_ascii((lex_ctx), (duk_codepoint_t) (x))
+#define DUK__APPENDBUFFER(lex_ctx, x)       duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x))
+#define DUK__APPENDBUFFER_ASCII(lex_ctx, x) duk__appendbuffer_ascii((lex_ctx), (duk_codepoint_t) (x))
 
 /* lookup shorthands (note: assume context variable is named 'lex_ctx') */
-#define DUK__L0()  DUK__LOOKUP(lex_ctx, 0)
-#define DUK__L1()  DUK__LOOKUP(lex_ctx, 1)
-#define DUK__L2()  DUK__LOOKUP(lex_ctx, 2)
-#define DUK__L3()  DUK__LOOKUP(lex_ctx, 3)
-#define DUK__L4()  DUK__LOOKUP(lex_ctx, 4)
-#define DUK__L5()  DUK__LOOKUP(lex_ctx, 5)
+#define DUK__L0() DUK__LOOKUP(lex_ctx, 0)
+#define DUK__L1() DUK__LOOKUP(lex_ctx, 1)
+#define DUK__L2() DUK__LOOKUP(lex_ctx, 2)
+#define DUK__L3() DUK__LOOKUP(lex_ctx, 3)
+#define DUK__L4() DUK__LOOKUP(lex_ctx, 4)
+#define DUK__L5() DUK__LOOKUP(lex_ctx, 5)
 
 /* packed advance/token number macro used by multiple functions */
-#define DUK__ADVTOK(advbytes,tok)  ((((advbytes) * sizeof(duk_lexer_codepoint)) << 8) + (tok))
+#define DUK__ADVTOK(advbytes, tok) ((((advbytes) * sizeof(duk_lexer_codepoint)) << 8) + (tok))
 
 /*
  *  Advance lookup window by N characters, filling in new characters as
  *  necessary.  After returning caller is guaranteed a character window of
  *  at least DUK_LEXER_WINDOW_SIZE characters.
  *
  *  The main function duk__advance_bytes() is called at least once per every
@@ -84779,18 +86084,17 @@
 		}
 
 		x = (duk_ucodepoint_t) (*p++);
 
 		/* Fast path. */
 
 		if (DUK_LIKELY(x < 0x80UL)) {
-			DUK_ASSERT(x != 0x2028UL && x != 0x2029UL);  /* not LS/PS */
+			DUK_ASSERT(x != 0x2028UL && x != 0x2029UL); /* not LS/PS */
 			if (DUK_UNLIKELY(x <= 0x000dUL)) {
-				if ((x == 0x000aUL) ||
-				    ((x == 0x000dUL) && (p >= p_end || *p != 0x000aUL))) {
+				if ((x == 0x000aUL) || ((x == 0x000dUL) && (p >= p_end || *p != 0x000aUL))) {
 					/* lookup for 0x000a above assumes shortest encoding now */
 
 					/* E5 Section 7.3, treat the following as newlines:
 					 *   LF
 					 *   CR [not followed by LF]
 					 *   LS
 					 *   PS
@@ -84873,56 +86177,55 @@
 		cp->codepoint = (duk_codepoint_t) x;
 	}
 
 	lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 	lex_ctx->input_line = input_line;
 	return;
 
- error_clipped:   /* clipped codepoint */
- error_encoding:  /* invalid codepoint encoding or codepoint */
+error_clipped: /* clipped codepoint */
+error_encoding: /* invalid codepoint encoding or codepoint */
 	lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 	lex_ctx->input_line = input_line;
 
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_SOURCE_DECODE_FAILED);
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_LOCAL void duk__advance_bytes(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_bytes) {
 	duk_small_uint_t used_bytes, avail_bytes;
 
-	DUK_ASSERT_DISABLE(count_bytes >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(count_bytes >= 0); /* unsigned */
 	DUK_ASSERT(count_bytes <= (duk_small_uint_t) (DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint)));
 	DUK_ASSERT(lex_ctx->window >= lex_ctx->buffer);
 	DUK_ASSERT(lex_ctx->window < lex_ctx->buffer + DUK_LEXER_BUFFER_SIZE);
-	DUK_ASSERT((duk_uint8_t *) lex_ctx->window + count_bytes <= (duk_uint8_t *) lex_ctx->buffer + DUK_LEXER_BUFFER_SIZE * sizeof(duk_lexer_codepoint));
+	DUK_ASSERT((duk_uint8_t *) lex_ctx->window + count_bytes <=
+	           (duk_uint8_t *) lex_ctx->buffer + DUK_LEXER_BUFFER_SIZE * sizeof(duk_lexer_codepoint));
 
 	/* Zero 'count' is also allowed to make call sites easier.
 	 * Arithmetic in bytes generates better code in GCC.
 	 */
 
-	lex_ctx->window = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->window + count_bytes);  /* avoid multiply */
+	lex_ctx->window = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->window + count_bytes); /* avoid multiply */
 	used_bytes = (duk_small_uint_t) ((duk_uint8_t *) lex_ctx->window - (duk_uint8_t *) lex_ctx->buffer);
 	avail_bytes = DUK_LEXER_BUFFER_SIZE * sizeof(duk_lexer_codepoint) - used_bytes;
 	if (avail_bytes < (duk_small_uint_t) (DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint))) {
 		/* Not enough data to provide a full window, so "scroll" window to
 		 * start of buffer and fill up the rest.
 		 */
-		duk_memmove((void *) lex_ctx->buffer,
-		            (const void *) lex_ctx->window,
-		            (size_t) avail_bytes);
+		duk_memmove((void *) lex_ctx->buffer, (const void *) lex_ctx->window, (size_t) avail_bytes);
 		lex_ctx->window = lex_ctx->buffer;
 		duk__fill_lexer_buffer(lex_ctx, avail_bytes);
 	}
 }
 
 DUK_LOCAL void duk__init_lexer_window(duk_lexer_ctx *lex_ctx) {
 	lex_ctx->window = lex_ctx->buffer;
 	duk__fill_lexer_buffer(lex_ctx, 0);
 }
-#else  /* DUK_USE_LEXER_SLIDING_WINDOW */
+#else /* DUK_USE_LEXER_SLIDING_WINDOW */
 DUK_LOCAL duk_codepoint_t duk__read_char(duk_lexer_ctx *lex_ctx) {
 	duk_ucodepoint_t x;
 	duk_small_uint_t len;
 	duk_small_uint_t i;
 	const duk_uint8_t *p;
 #if defined(DUK_USE_STRICT_UTF8_SOURCE)
 	duk_ucodepoint_t mincp;
@@ -84944,19 +86247,18 @@
 
 	if (DUK_LIKELY(x < 0x80UL)) {
 		/* 0xxx xxxx -> fast path */
 
 		/* input offset tracking */
 		lex_ctx->input_offset++;
 
-		DUK_ASSERT(x != 0x2028UL && x != 0x2029UL);  /* not LS/PS */
+		DUK_ASSERT(x != 0x2028UL && x != 0x2029UL); /* not LS/PS */
 		if (DUK_UNLIKELY(x <= 0x000dUL)) {
-			if ((x == 0x000aUL) ||
-			    ((x == 0x000dUL) && (lex_ctx->input_offset >= lex_ctx->input_length ||
-			                         lex_ctx->input[lex_ctx->input_offset] != 0x000aUL))) {
+			if ((x == 0x000aUL) || ((x == 0x000dUL) && (lex_ctx->input_offset >= lex_ctx->input_length ||
+			                                            lex_ctx->input[lex_ctx->input_offset] != 0x000aUL))) {
 				/* lookup for 0x000a above assumes shortest encoding now */
 
 				/* E5 Section 7.3, treat the following as newlines:
 				 *   LF
 				 *   CR [not followed by LF]
 				 *   LS
 				 *   PS
@@ -85037,48 +86339,46 @@
 	DUK_ASSERT(x != 0x000aUL && x != 0x000dUL);
 	if ((x == 0x2028UL) || (x == 0x2029UL)) {
 		lex_ctx->input_line++;
 	}
 
 	return (duk_codepoint_t) x;
 
- error_clipped:   /* clipped codepoint */
- error_encoding:  /* invalid codepoint encoding or codepoint */
+error_clipped: /* clipped codepoint */
+error_encoding: /* invalid codepoint encoding or codepoint */
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_SOURCE_DECODE_FAILED);
 	DUK_WO_NORETURN(return 0;);
 }
 
 DUK_LOCAL void duk__advance_bytes(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_bytes) {
 	duk_small_uint_t keep_bytes;
 	duk_lexer_codepoint *cp, *cp_end;
 
-	DUK_ASSERT_DISABLE(count_bytes >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(count_bytes >= 0); /* unsigned */
 	DUK_ASSERT(count_bytes <= (duk_small_uint_t) (DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint)));
 
 	/* Zero 'count' is also allowed to make call sites easier. */
 
 	keep_bytes = DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint) - count_bytes;
-	duk_memmove((void *) lex_ctx->window,
-	            (const void *) ((duk_uint8_t *) lex_ctx->window + count_bytes),
-	            (size_t) keep_bytes);
+	duk_memmove((void *) lex_ctx->window, (const void *) ((duk_uint8_t *) lex_ctx->window + count_bytes), (size_t) keep_bytes);
 
 	cp = (duk_lexer_codepoint *) ((duk_uint8_t *) lex_ctx->window + keep_bytes);
 	cp_end = lex_ctx->window + DUK_LEXER_WINDOW_SIZE;
 	for (; cp != cp_end; cp++) {
 		cp->offset = lex_ctx->input_offset;
 		cp->line = lex_ctx->input_line;
 		cp->codepoint = duk__read_char(lex_ctx);
 	}
 }
 
 DUK_LOCAL void duk__init_lexer_window(duk_lexer_ctx *lex_ctx) {
 	/* Call with count == DUK_LEXER_WINDOW_SIZE to fill buffer initially. */
-	duk__advance_bytes(lex_ctx, DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint));  /* fill window */
+	duk__advance_bytes(lex_ctx, DUK_LEXER_WINDOW_SIZE * sizeof(duk_lexer_codepoint)); /* fill window */
 }
-#endif  /* DUK_USE_LEXER_SLIDING_WINDOW */
+#endif /* DUK_USE_LEXER_SLIDING_WINDOW */
 
 DUK_LOCAL void duk__advance_chars(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_chars) {
 	duk__advance_bytes(lex_ctx, count_chars * sizeof(duk_lexer_codepoint));
 }
 
 /*
  *  (Re)initialize the temporary byte buffer.  May be called extra times
@@ -85163,15 +86463,15 @@
 
 DUK_INTERNAL void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
 	pt->offset = lex_ctx->window[0].offset;
 	pt->line = lex_ctx->window[0].line;
 }
 
 DUK_INTERNAL void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
-	DUK_ASSERT_DISABLE(pt->offset >= 0);  /* unsigned */
+	DUK_ASSERT_DISABLE(pt->offset >= 0); /* unsigned */
 	DUK_ASSERT(pt->line >= 1);
 	lex_ctx->input_offset = pt->offset;
 	lex_ctx->input_line = pt->line;
 	duk__init_lexer_window(lex_ctx);
 }
 
 /*
@@ -85197,16 +86497,15 @@
 
 /* Just a wrapper for call sites where 'x' is known to be valid so
  * we assert for it before decoding.
  */
 DUK_LOCAL duk_codepoint_t duk__hexval(duk_codepoint_t x) {
 	duk_codepoint_t ret;
 
-	DUK_ASSERT((x >= DUK_ASC_0 && x <= DUK_ASC_9) ||
-	           (x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_F) ||
+	DUK_ASSERT((x >= DUK_ASC_0 && x <= DUK_ASC_9) || (x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_F) ||
 	           (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_F));
 	ret = duk__hexval_validate(x);
 	DUK_ASSERT(ret >= 0 && ret <= 15);
 	return ret;
 }
 
 /* having this as a separate function provided a size benefit */
@@ -85217,20 +86516,20 @@
 	return 0;
 }
 
 /* Parse a Unicode escape of the form \xHH, \uHHHH, or \u{H+}.  Shared by
  * source and RegExp parsing.
  */
 DUK_LOCAL duk_codepoint_t duk__lexer_parse_escape(duk_lexer_ctx *lex_ctx, duk_bool_t allow_es6) {
-	duk_small_int_t digits;  /* Initial value 2 or 4 for fixed length escapes, 0 for ES2015 \u{H+}. */
+	duk_small_int_t digits; /* Initial value 2 or 4 for fixed length escapes, 0 for ES2015 \u{H+}. */
 	duk_codepoint_t escval;
 	duk_codepoint_t x;
 	duk_small_uint_t adv;
 
-	DUK_ASSERT(DUK__L0() == DUK_ASC_BACKSLASH);  /* caller responsibilities */
+	DUK_ASSERT(DUK__L0() == DUK_ASC_BACKSLASH); /* caller responsibilities */
 	DUK_ASSERT(DUK__L1() == DUK_ASC_LC_X || DUK__L1() == DUK_ASC_LC_U);
 	DUK_UNREF(allow_es6);
 
 	adv = 2;
 	digits = 2;
 	if (DUK__L1() == DUK_ASC_LC_U) {
 		digits = 4;
@@ -85296,34 +86595,36 @@
 					goto fail_escape;
 				}
 				DUK_ASSERT(escval >= 0 && escval <= 0x10ffffL);
 				break;
 			} else {
 				goto fail_escape;
 			}
-			digits = -1;  /* Indicate we have at least one digit. */
-#else  /* DUK_USE_ES6_UNICODE_ESCAPE */
-			DUK_ASSERT(0);  /* Never happens if \u{H+} support disabled. */
-#endif  /* DUK_USE_ES6_UNICODE_ESCAPE */
+			digits = -1; /* Indicate we have at least one digit. */
+#else /* DUK_USE_ES6_UNICODE_ESCAPE */
+			DUK_ASSERT(0); /* Never happens if \u{H+} support disabled. */
+#endif /* DUK_USE_ES6_UNICODE_ESCAPE */
 		}
 	}
 
 	return escval;
 
- fail_escape:
+fail_escape:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_ESCAPE);
 	DUK_WO_NORETURN(return 0;);
 }
 
 /* Parse legacy octal escape of the form \N{1,3}, e.g. \0, \5, \0377.  Maximum
  * allowed value is \0377 (U+00FF), longest match is used.  Used for both string
  * RegExp octal escape parsing.  Window[0] must be the slash '\' and the first
  * digit must already be validated to be in [0-9] by the caller.
  */
-DUK_LOCAL duk_codepoint_t duk__lexer_parse_legacy_octal(duk_lexer_ctx *lex_ctx, duk_small_uint_t *out_adv, duk_bool_t reject_annex_b) {
+DUK_LOCAL duk_codepoint_t duk__lexer_parse_legacy_octal(duk_lexer_ctx *lex_ctx,
+                                                        duk_small_uint_t *out_adv,
+                                                        duk_bool_t reject_annex_b) {
 	duk_codepoint_t cp;
 	duk_small_uint_t lookup_idx;
 	duk_small_uint_t adv;
 	duk_codepoint_t tmp;
 
 	DUK_ASSERT(out_adv != NULL);
 	DUK_ASSERT(DUK__LOOKUP(lex_ctx, 0) == DUK_ASC_BACKSLASH);
@@ -85350,15 +86651,15 @@
 	DUK_DDD(DUK_DDDPRINT("final lookup_idx=%ld, cp=%ld", (long) lookup_idx, (long) cp));
 
 	adv = lookup_idx;
 	if (lookup_idx == 1) {
 		DUK_DDD(DUK_DDDPRINT("\\8 or \\9 -> treat as literal, accept in strict mode too"));
 		DUK_ASSERT(tmp == DUK_ASC_8 || tmp == DUK_ASC_9);
 		cp = tmp;
-		adv++;  /* correction to above, eat offending character */
+		adv++; /* correction to above, eat offending character */
 	} else if (lookup_idx == 2 && cp == 0) {
 		/* Note: 'foo\0bar' is OK in strict mode, but 'foo\00bar' is not.
 		 * It won't be interpreted as 'foo\u{0}0bar' but as a SyntaxError.
 		 */
 		DUK_DDD(DUK_DDDPRINT("\\0 -> accept in strict mode too"));
 	} else {
 		/* This clause also handles non-shortest zero, e.g. \00. */
@@ -85374,37 +86675,40 @@
 	*out_adv = adv;
 
 	DUK_ASSERT((cp >= 0 && cp <= 0xff) || (cp == -1 && reject_annex_b));
 	return cp;
 }
 
 /* XXX: move strict mode to lex_ctx? */
-DUK_LOCAL void duk__lexer_parse_string_literal(duk_lexer_ctx *lex_ctx, duk_token *out_token, duk_small_int_t quote, duk_bool_t strict_mode) {
+DUK_LOCAL void duk__lexer_parse_string_literal(duk_lexer_ctx *lex_ctx,
+                                               duk_token *out_token,
+                                               duk_small_int_t quote,
+                                               duk_bool_t strict_mode) {
 	duk_small_uint_t adv;
 
-	for (adv = 1 /* initial quote */ ;;) {
+	for (adv = 1 /* initial quote */;;) {
 		duk_codepoint_t x;
 
-		DUK__ADVANCECHARS(lex_ctx, adv);  /* eat opening quote on first loop */
+		DUK__ADVANCECHARS(lex_ctx, adv); /* eat opening quote on first loop */
 		x = DUK__L0();
 
 		adv = 1;
 		if (x == quote) {
-			DUK__ADVANCECHARS(lex_ctx, 1);  /* eat closing quote */
+			DUK__ADVANCECHARS(lex_ctx, 1); /* eat closing quote */
 			break;
 		} else if (x == '\\') {
 			/* DUK__L0        -> '\' char
 			 * DUK__L1 ... DUK__L5 -> more lookup
 			 */
 			duk_small_int_t emitcp = -1;
 
 			x = DUK__L1();
 
 			/* How much to advance before next loop. */
-			adv = 2;  /* note: long live range */
+			adv = 2; /* note: long live range */
 
 			switch (x) {
 			case '\'':
 				emitcp = 0x0027;
 				break;
 			case '"':
 				emitcp = 0x0022;
@@ -85439,15 +86743,15 @@
 				break;
 			}
 			default: {
 				if (duk_unicode_is_line_terminator(x)) {
 					/* line continuation */
 					if (x == 0x000d && DUK__L2() == 0x000a) {
 						/* CR LF again a special case */
-						adv = 3;  /* line terminator, CR, LF */
+						adv = 3; /* line terminator, CR, LF */
 					}
 				} else if (DUK__ISDIGIT(x)) {
 					/*
 					 *  Octal escape or zero escape:
 					 *    \0                                     (lookahead not OctalDigit)
 					 *    \1 ... \7                              (lookahead not OctalDigit)
 					 *    \ZeroToThree OctalDigit                (lookahead not OctalDigit)
@@ -85468,16 +86772,16 @@
 					}
 				} else if (x < 0) {
 					goto fail_unterminated;
 				} else {
 					/* escaped NonEscapeCharacter */
 					DUK__APPENDBUFFER(lex_ctx, x);
 				}
-			}  /* end default clause */
-			}  /* end switch */
+			} /* end default clause */
+			} /* end switch */
 
 			/* Shared handling for single codepoint escapes. */
 			if (emitcp >= 0) {
 				DUK__APPENDBUFFER(lex_ctx, emitcp);
 			}
 
 			/* Track number of escapes; count not really needed but directive
@@ -85502,19 +86806,19 @@
 			 */
 			DUK__APPENDBUFFER(lex_ctx, x);
 		}
 	} /* string parse loop */
 
 	return;
 
- fail_escape:
+fail_escape:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_ESCAPE);
 	DUK_WO_NORETURN(return;);
 
- fail_unterminated:
+fail_unterminated:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_UNTERMINATED_STRING);
 	DUK_WO_NORETURN(return;);
 }
 
 /* Skip to end-of-line (or end-of-file), used for single line comments. */
 DUK_LOCAL void duk__lexer_skip_to_endofline(duk_lexer_ctx *lex_ctx) {
 	for (;;) {
@@ -85593,27 +86897,27 @@
  */
 
 DUK_INTERNAL
 void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx,
                                       duk_token *out_token,
                                       duk_bool_t strict_mode,
                                       duk_bool_t regexp_mode) {
-	duk_codepoint_t x;           /* temporary, must be signed and 32-bit to hold Unicode code points */
+	duk_codepoint_t x; /* temporary, must be signed and 32-bit to hold Unicode code points */
 	duk_small_uint_t advtok = 0; /* (advance << 8) + token_type, updated at function end,
 	                              * init is unnecessary but suppresses "may be used uninitialized" warnings.
 	                              */
-	duk_bool_t got_lineterm = 0;  /* got lineterm preceding non-whitespace, non-lineterm token */
+	duk_bool_t got_lineterm = 0; /* got lineterm preceding non-whitespace, non-lineterm token */
 
 	if (++lex_ctx->token_count >= lex_ctx->token_limit) {
 		goto fail_token_limit;
 	}
 
 	out_token->t = DUK_TOK_EOF;
-	out_token->t_nores = DUK_TOK_INVALID;  /* marker: copy t if not changed */
-#if 0  /* not necessary to init, disabled for faster parsing */
+	out_token->t_nores = DUK_TOK_INVALID; /* marker: copy t if not changed */
+#if 0 /* not necessary to init, disabled for faster parsing */
 	out_token->num = DUK_DOUBLE_NAN;
 	out_token->str1 = NULL;
 	out_token->str2 = NULL;
 #endif
 	out_token->num_escapes = 0;
 	/* out_token->lineterm set by caller */
 
@@ -85645,52 +86949,51 @@
 	 *    EOF
 	 *
 	 *  The order does not matter as long as the longest match is
 	 *  always correctly identified.  There are order dependencies
 	 *  in the clauses, so it's not trivial to convert to a switch.
 	 */
 
- restart_lineupdate:
+restart_lineupdate:
 	out_token->start_line = lex_ctx->window[0].line;
 
- restart:
+restart:
 	out_token->start_offset = lex_ctx->window[0].offset;
 
 	x = DUK__L0();
 
 	switch (x) {
 	case DUK_ASC_SPACE:
-	case DUK_ASC_HT:  /* fast paths for space and tab */
+	case DUK_ASC_HT: /* fast paths for space and tab */
 		DUK__ADVANCECHARS(lex_ctx, 1);
 		goto restart;
-	case DUK_ASC_LF:  /* LF line terminator; CR LF and Unicode lineterms are handled in slow path */
+	case DUK_ASC_LF: /* LF line terminator; CR LF and Unicode lineterms are handled in slow path */
 		DUK__ADVANCECHARS(lex_ctx, 1);
 		got_lineterm = 1;
 		goto restart_lineupdate;
 #if defined(DUK_USE_SHEBANG_COMMENTS)
-	case DUK_ASC_HASH:  /* '#' */
-		if (DUK__L1() == DUK_ASC_EXCLAMATION && lex_ctx->window[0].offset == 0 &&
-		    (lex_ctx->flags & DUK_COMPILE_SHEBANG)) {
+	case DUK_ASC_HASH: /* '#' */
+		if (DUK__L1() == DUK_ASC_EXCLAMATION && lex_ctx->window[0].offset == 0 && (lex_ctx->flags & DUK_COMPILE_SHEBANG)) {
 			/* "Shebang" comment ('#! ...') on first line. */
 			/* DUK__ADVANCECHARS(lex_ctx, 2) would be correct here, but not necessary */
 			duk__lexer_skip_to_endofline(lex_ctx);
-			goto restart;  /* line terminator will be handled on next round */
+			goto restart; /* line terminator will be handled on next round */
 		}
 		goto fail_token;
-#endif  /* DUK_USE_SHEBANG_COMMENTS */
-	case DUK_ASC_SLASH:  /* '/' */
+#endif /* DUK_USE_SHEBANG_COMMENTS */
+	case DUK_ASC_SLASH: /* '/' */
 		if (DUK__L1() == DUK_ASC_SLASH) {
 			/*
 			 *  E5 Section 7.4, allow SourceCharacter (which is any 16-bit
 			 *  code point).
 			 */
 
 			/* DUK__ADVANCECHARS(lex_ctx, 2) would be correct here, but not necessary */
 			duk__lexer_skip_to_endofline(lex_ctx);
-			goto restart;  /* line terminator will be handled on next round */
+			goto restart; /* line terminator will be handled on next round */
 		} else if (DUK__L1() == DUK_ASC_STAR) {
 			/*
 			 *  E5 Section 7.4.  If the multi-line comment contains a newline,
 			 *  it is treated like a single line terminator for automatic
 			 *  semicolon insertion.
 			 */
 
@@ -85766,27 +87069,27 @@
 			 *
 			 *      The latter is not normative and a typo.
 			 *
 			 */
 
 			/* first, parse regexp body roughly */
 
-			duk_small_int_t state = 0;  /* 0=base, 1=esc, 2=class, 3=class+esc */
+			duk_small_int_t state = 0; /* 0=base, 1=esc, 2=class, 3=class+esc */
 
 			DUK__INITBUFFER(lex_ctx);
 			for (;;) {
-				DUK__ADVANCECHARS(lex_ctx, 1);  /* skip opening slash on first loop */
+				DUK__ADVANCECHARS(lex_ctx, 1); /* skip opening slash on first loop */
 				x = DUK__L0();
 				if (x < 0 || duk_unicode_is_line_terminator(x)) {
 					goto fail_unterm_regexp;
 				}
-				x = DUK__L0();  /* re-read to avoid spill / fetch */
+				x = DUK__L0(); /* re-read to avoid spill / fetch */
 				if (state == 0) {
 					if (x == DUK_ASC_SLASH) {
-						DUK__ADVANCECHARS(lex_ctx, 1);  /* eat closing slash */
+						DUK__ADVANCECHARS(lex_ctx, 1); /* eat closing slash */
 						break;
 					} else if (x == DUK_ASC_BACKSLASH) {
 						state = 1;
 					} else if (x == DUK_ASC_LBRACKET) {
 						state = 2;
 					}
 				} else if (state == 1) {
@@ -85808,137 +87111,136 @@
 
 			DUK__INITBUFFER(lex_ctx);
 			for (;;) {
 				x = DUK__L0();
 				if (!duk_unicode_is_identifier_part(x)) {
 					break;
 				}
-				x = DUK__L0();  /* re-read to avoid spill / fetch */
+				x = DUK__L0(); /* re-read to avoid spill / fetch */
 				DUK__APPENDBUFFER(lex_ctx, x);
 				DUK__ADVANCECHARS(lex_ctx, 1);
 			}
 			out_token->str2 = duk__internbuffer(lex_ctx, lex_ctx->slot2_idx);
 
-			DUK__INITBUFFER(lex_ctx);  /* free some memory */
+			DUK__INITBUFFER(lex_ctx); /* free some memory */
 
 			/* validation of the regexp is caller's responsibility */
 
 			advtok = DUK__ADVTOK(0, DUK_TOK_REGEXP);
-#else  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
 			goto fail_regexp_support;
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			/* "/=" and not in regexp mode */
 			advtok = DUK__ADVTOK(2, DUK_TOK_DIV_EQ);
 		} else {
 			/* "/" and not in regexp mode */
 			advtok = DUK__ADVTOK(1, DUK_TOK_DIV);
 		}
 		break;
-	case DUK_ASC_LCURLY:  /* '{' */
+	case DUK_ASC_LCURLY: /* '{' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_LCURLY);
 		break;
-	case DUK_ASC_RCURLY:  /* '}' */
+	case DUK_ASC_RCURLY: /* '}' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_RCURLY);
 		break;
-	case DUK_ASC_LPAREN:  /* '(' */
+	case DUK_ASC_LPAREN: /* '(' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_LPAREN);
 		break;
-	case DUK_ASC_RPAREN:  /* ')' */
+	case DUK_ASC_RPAREN: /* ')' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_RPAREN);
 		break;
-	case DUK_ASC_LBRACKET:  /* '[' */
+	case DUK_ASC_LBRACKET: /* '[' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_LBRACKET);
 		break;
-	case DUK_ASC_RBRACKET:  /* ']' */
+	case DUK_ASC_RBRACKET: /* ']' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_RBRACKET);
 		break;
-	case DUK_ASC_PERIOD:  /* '.' */
+	case DUK_ASC_PERIOD: /* '.' */
 		if (DUK__ISDIGIT(DUK__L1())) {
 			/* Period followed by a digit can only start DecimalLiteral
 			 * (handled in slow path).  We could jump straight into the
 			 * DecimalLiteral handling but should avoid goto to inside
 			 * a block.
 			 */
 			goto slow_path;
 		}
 		advtok = DUK__ADVTOK(1, DUK_TOK_PERIOD);
 		break;
-	case DUK_ASC_SEMICOLON:  /* ';' */
+	case DUK_ASC_SEMICOLON: /* ';' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_SEMICOLON);
 		break;
-	case DUK_ASC_COMMA:  /* ',' */
+	case DUK_ASC_COMMA: /* ',' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_COMMA);
 		break;
-	case DUK_ASC_LANGLE:  /* '<' */
+	case DUK_ASC_LANGLE: /* '<' */
 #if defined(DUK_USE_HTML_COMMENTS)
 		if (DUK__L1() == DUK_ASC_EXCLAMATION && DUK__L2() == DUK_ASC_MINUS && DUK__L3() == DUK_ASC_MINUS) {
 			/*
 			 *  ES2015: B.1.3, handle "<!--" SingleLineHTMLOpenComment
 			 */
 
 			/* DUK__ADVANCECHARS(lex_ctx, 4) would be correct here, but not necessary */
 			duk__lexer_skip_to_endofline(lex_ctx);
-			goto restart;  /* line terminator will be handled on next round */
-		}
-		else
-#endif  /* DUK_USE_HTML_COMMENTS */
-		if (DUK__L1() == DUK_ASC_LANGLE && DUK__L2() == DUK_ASC_EQUALS) {
+			goto restart; /* line terminator will be handled on next round */
+		} else
+#endif /* DUK_USE_HTML_COMMENTS */
+		    if (DUK__L1() == DUK_ASC_LANGLE && DUK__L2() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_ALSHIFT_EQ);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_LE);
 		} else if (DUK__L1() == DUK_ASC_LANGLE) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_ALSHIFT);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_LT);
 		}
 		break;
-	case DUK_ASC_RANGLE:  /* '>' */
+	case DUK_ASC_RANGLE: /* '>' */
 		if (DUK__L1() == DUK_ASC_RANGLE && DUK__L2() == DUK_ASC_RANGLE && DUK__L3() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(4, DUK_TOK_RSHIFT_EQ);
 		} else if (DUK__L1() == DUK_ASC_RANGLE && DUK__L2() == DUK_ASC_RANGLE) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_RSHIFT);
 		} else if (DUK__L1() == DUK_ASC_RANGLE && DUK__L2() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_ARSHIFT_EQ);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_GE);
 		} else if (DUK__L1() == DUK_ASC_RANGLE) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_ARSHIFT);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_GT);
 		}
 		break;
-	case DUK_ASC_EQUALS:  /* '=' */
+	case DUK_ASC_EQUALS: /* '=' */
 		if (DUK__L1() == DUK_ASC_EQUALS && DUK__L2() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_SEQ);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_EQUALSIGN);
 		}
 		break;
-	case DUK_ASC_EXCLAMATION:  /* '!' */
+	case DUK_ASC_EXCLAMATION: /* '!' */
 		if (DUK__L1() == DUK_ASC_EQUALS && DUK__L2() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_SNEQ);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_NEQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_LNOT);
 		}
 		break;
-	case DUK_ASC_PLUS:  /* '+' */
+	case DUK_ASC_PLUS: /* '+' */
 		if (DUK__L1() == DUK_ASC_PLUS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_INCREMENT);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_ADD_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_ADD);
 		}
 		break;
-	case DUK_ASC_MINUS:  /* '-' */
+	case DUK_ASC_MINUS: /* '-' */
 #if defined(DUK_USE_HTML_COMMENTS)
 		if (got_lineterm && DUK__L1() == DUK_ASC_MINUS && DUK__L2() == DUK_ASC_RANGLE) {
 			/*
 			 *  ES2015: B.1.3, handle "-->" SingleLineHTMLCloseComment
 			 *  Only allowed:
 			 *  - on new line
 			 *  - preceded only by whitespace
@@ -85947,99 +87249,99 @@
 			 * Since whitespace generates no tokens, and multiline comments
 			 * are treated as a line ending, consulting `got_lineterm` is
 			 * sufficient to test for these three options.
 			 */
 
 			/* DUK__ADVANCECHARS(lex_ctx, 3) would be correct here, but not necessary */
 			duk__lexer_skip_to_endofline(lex_ctx);
-			goto restart;  /* line terminator will be handled on next round */
+			goto restart; /* line terminator will be handled on next round */
 		} else
-#endif  /* DUK_USE_HTML_COMMENTS */
-		if (DUK__L1() == DUK_ASC_MINUS) {
+#endif /* DUK_USE_HTML_COMMENTS */
+		    if (DUK__L1() == DUK_ASC_MINUS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_DECREMENT);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_SUB_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_SUB);
 		}
 		break;
-	case DUK_ASC_STAR:  /* '*' */
+	case DUK_ASC_STAR: /* '*' */
 #if defined(DUK_USE_ES7_EXP_OPERATOR)
 		if (DUK__L1() == DUK_ASC_STAR && DUK__L2() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(3, DUK_TOK_EXP_EQ);
 		} else if (DUK__L1() == DUK_ASC_STAR) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_EXP);
 		} else
 #endif
-		if (DUK__L1() == DUK_ASC_EQUALS) {
+		    if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_MUL_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_MUL);
 		}
 		break;
-	case DUK_ASC_PERCENT:  /* '%' */
+	case DUK_ASC_PERCENT: /* '%' */
 		if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_MOD_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_MOD);
 		}
 		break;
-	case DUK_ASC_AMP:  /* '&' */
+	case DUK_ASC_AMP: /* '&' */
 		if (DUK__L1() == DUK_ASC_AMP) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_LAND);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_BAND_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_BAND);
 		}
 		break;
-	case DUK_ASC_PIPE:  /* '|' */
+	case DUK_ASC_PIPE: /* '|' */
 		if (DUK__L1() == DUK_ASC_PIPE) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_LOR);
 		} else if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_BOR_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_BOR);
 		}
 		break;
-	case DUK_ASC_CARET:  /* '^' */
+	case DUK_ASC_CARET: /* '^' */
 		if (DUK__L1() == DUK_ASC_EQUALS) {
 			advtok = DUK__ADVTOK(2, DUK_TOK_BXOR_EQ);
 		} else {
 			advtok = DUK__ADVTOK(1, DUK_TOK_BXOR);
 		}
 		break;
-	case DUK_ASC_TILDE:  /* '~' */
+	case DUK_ASC_TILDE: /* '~' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_BNOT);
 		break;
-	case DUK_ASC_QUESTION:  /* '?' */
+	case DUK_ASC_QUESTION: /* '?' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_QUESTION);
 		break;
-	case DUK_ASC_COLON:  /* ':' */
+	case DUK_ASC_COLON: /* ':' */
 		advtok = DUK__ADVTOK(1, DUK_TOK_COLON);
 		break;
-	case DUK_ASC_DOUBLEQUOTE:    /* '"' */
-	case DUK_ASC_SINGLEQUOTE: {  /* '\'' */
+	case DUK_ASC_DOUBLEQUOTE: /* '"' */
+	case DUK_ASC_SINGLEQUOTE: { /* '\'' */
 		DUK__INITBUFFER(lex_ctx);
 		duk__lexer_parse_string_literal(lex_ctx, out_token, x /*quote*/, strict_mode);
 		duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
 		out_token->str1 = duk_known_hstring(lex_ctx->thr, lex_ctx->slot1_idx);
 
-		DUK__INITBUFFER(lex_ctx);  /* free some memory */
+		DUK__INITBUFFER(lex_ctx); /* free some memory */
 
 		advtok = DUK__ADVTOK(0, DUK_TOK_STRING);
 		break;
 	}
 	default:
 		goto slow_path;
-	}  /* switch */
+	} /* switch */
 
 	goto skip_slow_path;
 
- slow_path:
+slow_path:
 	if (duk_unicode_is_line_terminator(x)) {
 		if (x == 0x000d && DUK__L1() == 0x000a) {
 			/*
 			 *  E5 Section 7.3: CR LF is detected as a single line terminator for
 			 *  line numbers.  Here we also detect it as a single line terminator
 			 *  token.
 			 */
@@ -86122,15 +87424,15 @@
 			first = 0;
 		}
 
 		out_token->str1 = duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
 		str = out_token->str1;
 		out_token->t_nores = DUK_TOK_IDENTIFIER;
 
-		DUK__INITBUFFER(lex_ctx);  /* free some memory */
+		DUK__INITBUFFER(lex_ctx); /* free some memory */
 
 		/*
 		 *  Interned identifier is compared against reserved words, which are
 		 *  currently interned into the heap context.  See genbuiltins.py.
 		 *
 		 *  Note that an escape in the identifier disables recognition of
 		 *  keywords; e.g. "\u0069f = 1;" is a valid statement (assigns to
@@ -86149,15 +87451,15 @@
 		 */
 
 		i_end = (strict_mode ? DUK_STRIDX_END_RESERVED : DUK_STRIDX_START_STRICT_RESERVED);
 
 		advtok = DUK__ADVTOK(0, DUK_TOK_IDENTIFIER);
 		if (out_token->num_escapes == 0) {
 			for (i = DUK_STRIDX_START_RESERVED; i < i_end; i++) {
-				DUK_ASSERT_DISABLE(i >= 0);  /* unsigned */
+				DUK_ASSERT_DISABLE(i >= 0); /* unsigned */
 				DUK_ASSERT(i < DUK_HEAP_NUM_STRINGS);
 				if (DUK_HTHREAD_GET_STRING(lex_ctx->thr, i) == str) {
 					advtok = DUK__ADVTOK(0, DUK_STRIDX_TO_TOK(i));
 					break;
 				}
 			}
 		}
@@ -86184,31 +87486,31 @@
 		 * followed by a digit), this could maybe be simplified, if we bail
 		 * out early from a leading zero (and if there are no periods etc).
 		 * Maybe too complex.
 		 */
 
 		duk_double_t val;
 		duk_bool_t legacy_oct = 0;
-		duk_small_int_t state;  /* 0=before period/exp,
-		                         * 1=after period, before exp
-		                         * 2=after exp, allow '+' or '-'
-		                         * 3=after exp and exp sign
-		                         */
+		duk_small_int_t state; /* 0=before period/exp,
+		                        * 1=after period, before exp
+		                        * 2=after exp, allow '+' or '-'
+		                        * 3=after exp and exp sign
+		                        */
 		duk_small_uint_t s2n_flags;
 		duk_codepoint_t y, z;
 		duk_small_int_t s2n_radix = 10;
 		duk_small_uint_t pre_adv = 0;
 
 		DUK__INITBUFFER(lex_ctx);
 		y = DUK__L1();
 
 		if (x == DUK_ASC_0) {
 			z = DUK_LOWERCASE_CHAR_ASCII(y);
 
-			pre_adv = 2;  /* default for 0xNNN, 0oNNN, 0bNNN. */
+			pre_adv = 2; /* default for 0xNNN, 0oNNN, 0bNNN. */
 			if (z == DUK_ASC_LC_X) {
 				s2n_radix = 16;
 			} else if (z == DUK_ASC_LC_O) {
 				s2n_radix = 8;
 			} else if (z == DUK_ASC_LC_B) {
 				s2n_radix = 2;
 			} else {
@@ -86223,29 +87525,29 @@
 						/* Legacy OctalIntegerLiteral or octal-lookalice
 						 * decimal.  Deciding between the two happens below
 						 * in digit scanning.
 						 */
 						DUK__APPENDBUFFER(lex_ctx, x);
 						pre_adv = 1;
 						legacy_oct = 1;
-						s2n_radix = 8;  /* tentative unless conflicting digits found */
+						s2n_radix = 8; /* tentative unless conflicting digits found */
 					}
 				}
 			}
 		}
 
 		DUK__ADVANCECHARS(lex_ctx, pre_adv);
 
 		/* XXX: we could parse integers here directly, and fall back
 		 * to numconv only when encountering a fractional expression
 		 * or when an octal literal turned out to be decimal (0778 etc).
 		 */
 		state = 0;
 		for (;;) {
-			x = DUK__L0();  /* re-lookup curr char on first round */
+			x = DUK__L0(); /* re-lookup curr char on first round */
 			if (DUK__ISDIGIT(x)) {
 				/* Note: intentionally allow leading zeroes here, as the
 				 * actual parser will check for them.
 				 */
 				if (state == 0 && legacy_oct && (x == DUK_ASC_8 || x == DUK_ASC_9)) {
 					/* Started out as an octal-lookalike
 					 * but interpreted as decimal, e.g.
@@ -86290,30 +87592,27 @@
 		/* XXX: better coercion */
 		(void) duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
 
 		if (s2n_radix != 10) {
 			/* For bases other than 10, integer only. */
 			s2n_flags = DUK_S2N_FLAG_ALLOW_LEADING_ZERO;
 		} else {
-			s2n_flags = DUK_S2N_FLAG_ALLOW_EXP |
-			            DUK_S2N_FLAG_ALLOW_FRAC |
-			            DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
-			            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC |
-			            DUK_S2N_FLAG_ALLOW_LEADING_ZERO;
+			s2n_flags = DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_FRAC | DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
+			            DUK_S2N_FLAG_ALLOW_EMPTY_FRAC | DUK_S2N_FLAG_ALLOW_LEADING_ZERO;
 		}
 
 		duk_dup(lex_ctx->thr, lex_ctx->slot1_idx);
 		duk_numconv_parse(lex_ctx->thr, s2n_radix, s2n_flags);
 		val = duk_to_number_m1(lex_ctx->thr);
 		if (DUK_ISNAN(val)) {
 			goto fail_number_literal;
 		}
-		duk_replace(lex_ctx->thr, lex_ctx->slot1_idx);  /* could also just pop? */
+		duk_replace(lex_ctx->thr, lex_ctx->slot1_idx); /* could also just pop? */
 
-		DUK__INITBUFFER(lex_ctx);  /* free some memory */
+		DUK__INITBUFFER(lex_ctx); /* free some memory */
 
 		/* Section 7.8.3 (note): NumericLiteral must be followed by something other than
 		 * IdentifierStart or DecimalDigit.
 		 */
 
 		if (DUK__ISDIGIT(DUK__L0()) || duk_unicode_is_identifier_start(DUK__L0())) {
 			goto fail_number_literal;
@@ -86325,15 +87624,15 @@
 		DUK__ADVANCECHARS(lex_ctx, 1);
 		goto restart;
 	} else if (x < 0) {
 		advtok = DUK__ADVTOK(0, DUK_TOK_EOF);
 	} else {
 		goto fail_token;
 	}
- skip_slow_path:
+skip_slow_path:
 
 	/*
 	 *  Shared exit path
 	 */
 
 	DUK__ADVANCEBYTES(lex_ctx, advtok >> 8);
 	out_token->t = advtok & 0xff;
@@ -86350,40 +87649,40 @@
 		out_token->allow_auto_semi = 1;
 	} else {
 		out_token->allow_auto_semi = 0;
 	}
 
 	return;
 
- fail_token_limit:
+fail_token_limit:
 	DUK_ERROR_RANGE(lex_ctx->thr, DUK_STR_TOKEN_LIMIT);
 	DUK_WO_NORETURN(return;);
 
- fail_token:
+fail_token:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_TOKEN);
 	DUK_WO_NORETURN(return;);
 
- fail_number_literal:
+fail_number_literal:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_NUMBER_LITERAL);
 	DUK_WO_NORETURN(return;);
 
- fail_escape:
+fail_escape:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_ESCAPE);
 	DUK_WO_NORETURN(return;);
 
- fail_unterm_regexp:
+fail_unterm_regexp:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_UNTERMINATED_REGEXP);
 	DUK_WO_NORETURN(return;);
 
- fail_unterm_comment:
+fail_unterm_comment:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_UNTERMINATED_COMMENT);
 	DUK_WO_NORETURN(return;);
 
 #if !defined(DUK_USE_REGEXP_SUPPORT)
- fail_regexp_support:
+fail_regexp_support:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_REGEXP_SUPPORT_DISABLED);
 	DUK_WO_NORETURN(return;);
 #endif
 }
 
 #if defined(DUK_USE_REGEXP_SUPPORT)
 
@@ -86393,15 +87692,15 @@
  *
  *  0xffffffffU is used as a marker for "infinity" in quantifiers.  Further,
  *  DUK__MAX_RE_QUANT_DIGITS limits the maximum number of digits that
  *  will be accepted for a quantifier.
  */
 
 DUK_INTERNAL void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token) {
-	duk_small_uint_t advtok = 0;  /* init is unnecessary but suppresses "may be used uninitialized" warnings */
+	duk_small_uint_t advtok = 0; /* init is unnecessary but suppresses "may be used uninitialized" warnings */
 	duk_codepoint_t x, y;
 
 	if (++lex_ctx->token_count >= lex_ctx->token_limit) {
 		goto fail_token_limit;
 	}
 
 	duk_memzero(out_token, sizeof(*out_token));
@@ -86471,15 +87770,15 @@
 
 #if defined(DUK_USE_ES6_REGEXP_SYNTAX)
 		/* Store lexer position, restoring if quantifier is invalid. */
 		DUK_LEXER_GETPOINT(lex_ctx, &lex_pt);
 #endif
 
 		for (;;) {
-			DUK__ADVANCECHARS(lex_ctx, 1);  /* eat '{' on entry */
+			DUK__ADVANCECHARS(lex_ctx, 1); /* eat '{' on entry */
 			x = DUK__L0();
 			if (DUK__ISDIGIT(x)) {
 				digits++;
 				val1 = val1 * 10 + (duk_uint32_t) duk__hexval(x);
 			} else if (x == DUK_ASC_COMMA) {
 				if (digits > DUK__MAX_RE_QUANT_DIGITS) {
 					goto invalid_quantifier;
@@ -86495,15 +87794,15 @@
 					out_token->qmin = val1;
 					out_token->qmax = DUK_RE_QUANTIFIER_INFINITE;
 					DUK__ADVANCECHARS(lex_ctx, 2);
 					break;
 				}
 				val2 = val1;
 				val1 = 0;
-				digits = 0;  /* not strictly necessary because of lookahead '}' above */
+				digits = 0; /* not strictly necessary because of lookahead '}' above */
 			} else if (x == DUK_ASC_RCURLY) {
 				if (digits > DUK__MAX_RE_QUANT_DIGITS) {
 					goto invalid_quantifier;
 				}
 				if (digits == 0) {
 					goto invalid_quantifier;
 				}
@@ -86526,15 +87825,15 @@
 			out_token->greedy = 0;
 			DUK__ADVANCECHARS(lex_ctx, 1);
 		} else {
 			out_token->greedy = 1;
 		}
 		advtok = DUK__ADVTOK(0, DUK_RETOK_QUANTIFIER);
 		break;
- invalid_quantifier:
+	invalid_quantifier:
 #if defined(DUK_USE_ES6_REGEXP_SYNTAX)
 		/* Failed to match the quantifier, restore lexer and parse
 		 * opening brace as a literal.
 		 */
 		DUK_LEXER_SETPOINT(lex_ctx, &lex_pt);
 		advtok = DUK__ADVTOK(1, DUK_RETOK_ATOM_CHAR);
 		out_token->num = DUK_ASC_LCURLY;
@@ -86552,15 +87851,15 @@
 		 * to be used as identity escapes.  Unfortunately this includes '$', which
 		 * cannot be escaped as '\$'; it needs to be escaped e.g. as '\u0024'.
 		 * Many other implementations (including V8 and Rhino, for instance) do
 		 * accept '\$' as a valid identity escape, which is quite pragmatic, and
 		 * ES2015 Annex B relaxes the rules to allow these (and other) real world forms.
 		 */
 
-		advtok = DUK__ADVTOK(2, DUK_RETOK_ATOM_CHAR);  /* default: char escape (two chars) */
+		advtok = DUK__ADVTOK(2, DUK_RETOK_ATOM_CHAR); /* default: char escape (two chars) */
 		if (y == DUK_ASC_LC_B) {
 			advtok = DUK__ADVTOK(2, DUK_RETOK_ASSERT_WORD_BOUNDARY);
 		} else if (y == DUK_ASC_UC_B) {
 			advtok = DUK__ADVTOK(2, DUK_RETOK_ASSERT_NOT_WORD_BOUNDARY);
 		} else if (y == DUK_ASC_LC_F) {
 			out_token->num = 0x000c;
 		} else if (y == DUK_ASC_LC_N) {
@@ -86569,16 +87868,15 @@
 			out_token->num = 0x0009;
 		} else if (y == DUK_ASC_LC_R) {
 			out_token->num = 0x000d;
 		} else if (y == DUK_ASC_LC_V) {
 			out_token->num = 0x000b;
 		} else if (y == DUK_ASC_LC_C) {
 			x = DUK__L2();
-			if ((x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_Z) ||
-			    (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_Z)) {
+			if ((x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_Z) || (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_Z)) {
 				out_token->num = (duk_uint32_t) (x % 32);
 				advtok = DUK__ADVTOK(3, DUK_RETOK_ATOM_CHAR);
 			} else {
 				goto fail_escape;
 			}
 		} else if (y == DUK_ASC_LC_X || y == DUK_ASC_LC_U) {
 			/* The token value is the Unicode codepoint without
@@ -86608,19 +87906,19 @@
 				}
 				out_token->num = 0x0000;
 				advtok = DUK__ADVTOK(2, DUK_RETOK_ATOM_CHAR);
 			} else {
 				/* XXX: shared parsing? */
 				duk_uint32_t val = 0;
 				duk_small_int_t i;
-				for (i = 0; ; i++) {
+				for (i = 0;; i++) {
 					if (i >= DUK__MAX_RE_DECESC_DIGITS) {
 						goto fail_escape;
 					}
-					DUK__ADVANCECHARS(lex_ctx, 1);  /* eat backslash on entry */
+					DUK__ADVANCECHARS(lex_ctx, 1); /* eat backslash on entry */
 					x = DUK__L0();
 					if (!DUK__ISDIGIT(x)) {
 						break;
 					}
 					val = val * 10 + (duk_uint32_t) duk__hexval(x);
 				}
 				/* DUK__L0() cannot be a digit, because the loop doesn't terminate if it is */
@@ -86632,25 +87930,23 @@
 			/* For ES2015 Annex B, accept any source character as identity
 			 * escape except 'c' which is used for control characters.
 			 * http://www.ecma-international.org/ecma-262/6.0/#sec-regular-expressions-patterns
 			 * Careful not to match end-of-buffer (<0) here.
 			 * This is not yet full ES2015 Annex B because cases above
 			 * (like hex escape) won't backtrack.
 			 */
-			DUK_ASSERT(y != DUK_ASC_LC_C);  /* covered above */
-#else  /* DUK_USE_ES6_REGEXP_SYNTAX */
-		} else if ((y >= 0 && !duk_unicode_is_identifier_part(y)) ||
-		           y == DUK_UNICODE_CP_ZWNJ ||
-		           y == DUK_UNICODE_CP_ZWJ) {
+			DUK_ASSERT(y != DUK_ASC_LC_C); /* covered above */
+#else /* DUK_USE_ES6_REGEXP_SYNTAX */
+		} else if ((y >= 0 && !duk_unicode_is_identifier_part(y)) || y == DUK_UNICODE_CP_ZWNJ || y == DUK_UNICODE_CP_ZWJ) {
 			/* For ES5.1 identity escapes are not allowed for identifier
 			 * parts.  This conflicts with a lot of real world code as this
 			 * doesn't e.g. allow escaping a dollar sign as /\$/, see
 			 * test-regexp-identity-escape-dollar.js.
 			 */
-#endif  /* DUK_USE_ES6_REGEXP_SYNTAX */
+#endif /* DUK_USE_ES6_REGEXP_SYNTAX */
 			out_token->num = (duk_uint32_t) y;
 		} else {
 			goto fail_escape;
 		}
 		break;
 	}
 	case DUK_ASC_LPAREN: {
@@ -86723,32 +88019,32 @@
 	 *  Shared exit path
 	 */
 
 	DUK__ADVANCEBYTES(lex_ctx, advtok >> 8);
 	out_token->t = advtok & 0xff;
 	return;
 
- fail_token_limit:
+fail_token_limit:
 	DUK_ERROR_RANGE(lex_ctx->thr, DUK_STR_TOKEN_LIMIT);
 	DUK_WO_NORETURN(return;);
 
- fail_escape:
+fail_escape:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_REGEXP_ESCAPE);
 	DUK_WO_NORETURN(return;);
 
- fail_group:
+fail_group:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_REGEXP_GROUP);
 	DUK_WO_NORETURN(return;);
 
 #if !defined(DUK_USE_ES6_REGEXP_SYNTAX)
- fail_invalid_char:
+fail_invalid_char:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_REGEXP_CHARACTER);
 	DUK_WO_NORETURN(return;);
 
- fail_quantifier:
+fail_quantifier:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_QUANTIFIER);
 	DUK_WO_NORETURN(return;);
 #endif
 }
 
 /*
  *  Special parser for character classes; calls callback for every
@@ -86799,24 +88095,24 @@
 
 	for (;;) {
 		DUK__ADVANCECHARS(lex_ctx, adv);
 		adv = 1;
 
 		x = DUK__L0();
 
-		ch = -1;  /* not strictly necessary, but avoids "uninitialized variable" warnings */
+		ch = -1; /* not strictly necessary, but avoids "uninitialized variable" warnings */
 		DUK_UNREF(ch);
 
 		if (x < 0) {
 			goto fail_unterm_charclass;
 		} else if (x == DUK_ASC_RBRACKET) {
 			if (start >= 0) {
 				gen_range(userdata, start, start, 0);
 			}
-			DUK__ADVANCECHARS(lex_ctx, 1);  /* eat ']' before finishing */
+			DUK__ADVANCECHARS(lex_ctx, 1); /* eat ']' before finishing */
 			break;
 		} else if (x == DUK_ASC_MINUS) {
 			if (start >= 0 && !dash && DUK__L1() != DUK_ASC_RBRACKET) {
 				/* '-' as a range indicator */
 				dash = 1;
 				continue;
 			} else {
@@ -86853,16 +88149,15 @@
 			} else if (x == DUK_ASC_LC_R) {
 				ch = 0x000d;
 			} else if (x == DUK_ASC_LC_V) {
 				ch = 0x000b;
 			} else if (x == DUK_ASC_LC_C) {
 				x = DUK__L2();
 				adv = 3;
-				if ((x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_Z) ||
-				    (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_Z)) {
+				if ((x >= DUK_ASC_LC_A && x <= DUK_ASC_LC_Z) || (x >= DUK_ASC_UC_A && x <= DUK_ASC_UC_Z)) {
 					ch = (x % 32);
 				} else {
 					goto fail_escape;
 				}
 			} else if (x == DUK_ASC_LC_X || x == DUK_ASC_LC_U) {
 				/* The \u{H+} form is only allowed in Unicode mode which
 				 * we don't support yet.
@@ -86918,38 +88213,38 @@
 				 * ES2015 Annex B also allows (maximal match) legacy
 				 * octal escapes up to \377 and \8 and \9 are
 				 * accepted as literal '8' and '9', also in strict mode.
 				 */
 
 #if defined(DUK_USE_ES6_REGEXP_SYNTAX)
 				ch = duk__lexer_parse_legacy_octal(lex_ctx, &adv, 0 /*reject_annex_b*/);
-				DUK_ASSERT(ch >= 0);  /* no rejections */
+				DUK_ASSERT(ch >= 0); /* no rejections */
 #else
 				if (x == DUK_ASC_0 && !DUK__ISDIGIT(DUK__L2())) {
 					ch = 0x0000;
 				} else {
 					goto fail_escape;
 				}
 #endif
 #if defined(DUK_USE_ES6_REGEXP_SYNTAX)
 			} else if (x >= 0) {
 				/* IdentityEscape: ES2015 Annex B allows almost all
 				 * source characters here.  Match anything except
 				 * EOF here.
 				 */
 				ch = x;
-#else  /* DUK_USE_ES6_REGEXP_SYNTAX */
+#else /* DUK_USE_ES6_REGEXP_SYNTAX */
 			} else if (!duk_unicode_is_identifier_part(x)) {
 				/* IdentityEscape: ES5.1 doesn't allow identity escape
 				 * for identifier part characters, which conflicts with
 				 * some real world code.  For example, it doesn't allow
 				 * /[\$]/ which is awkward.
 				 */
 				ch = x;
-#endif  /* DUK_USE_ES6_REGEXP_SYNTAX */
+#endif /* DUK_USE_ES6_REGEXP_SYNTAX */
 			} else {
 				goto fail_escape;
 			}
 		} else {
 			/* character represents itself */
 			ch = x;
 		}
@@ -86989,28 +88284,28 @@
 				start = ch;
 			}
 		}
 	}
 
 	return;
 
- fail_escape:
+fail_escape:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_REGEXP_ESCAPE);
 	DUK_WO_NORETURN(return;);
 
- fail_range:
+fail_range:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_INVALID_RANGE);
 	DUK_WO_NORETURN(return;);
 
- fail_unterm_charclass:
+fail_unterm_charclass:
 	DUK_ERROR_SYNTAX(lex_ctx->thr, DUK_STR_UNTERMINATED_CHARCLASS);
 	DUK_WO_NORETURN(return;);
 }
 
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__ADVANCEBYTES
 #undef DUK__ADVANCECHARS
 #undef DUK__ADVTOK
 #undef DUK__APPENDBUFFER
 #undef DUK__APPENDBUFFER_ASCII
@@ -87040,18 +88335,18 @@
  *  fixed maximum size and does not require dynamic allocations.
  *
  *  See: doc/number-conversion.rst.
  */
 
 /* #include duk_internal.h -> already included */
 
-#define DUK__IEEE_DOUBLE_EXP_BIAS  1023
-#define DUK__IEEE_DOUBLE_EXP_MIN   (-1022)   /* biased exp == 0 -> denormal, exp -1022 */
+#define DUK__IEEE_DOUBLE_EXP_BIAS 1023
+#define DUK__IEEE_DOUBLE_EXP_MIN  (-1022) /* biased exp == 0 -> denormal, exp -1022 */
 
-#define DUK__DIGITCHAR(x)  duk_lc_digits[(x)]
+#define DUK__DIGITCHAR(x) duk_lc_digits[(x)]
 
 /*
  *  Tables generated with util/gennumdigits.py.
  *
  *  duk__str2num_digits_for_radix indicates, for each radix, how many input
  *  digits should be considered significant for string-to-number conversion.
  *  The input is also padded to this many digits to give the Dragon4
@@ -87061,35 +88356,31 @@
  *  minimum/maximum exponent values (for a Dragon4 integer mantissa)
  *  below and above which the number is guaranteed to underflow to zero
  *  or overflow to Infinity.  This allows parsing to keep bigint values
  *  bounded.
  */
 
 DUK_LOCAL const duk_uint8_t duk__str2num_digits_for_radix[] = {
-	69, 44, 35, 30, 27, 25, 23, 22, 20, 20,    /* 2 to 11 */
-	20, 19, 19, 18, 18, 17, 17, 17, 16, 16,    /* 12 to 21 */
-	16, 16, 16, 15, 15, 15, 15, 15, 15, 14,    /* 22 to 31 */
-	14, 14, 14, 14, 14                         /* 31 to 36 */
+	69, 44, 35, 30, 27, 25, 23, 22, 20, 20, /* 2 to 11 */
+	20, 19, 19, 18, 18, 17, 17, 17, 16, 16, /* 12 to 21 */
+	16, 16, 16, 15, 15, 15, 15, 15, 15, 14, /* 22 to 31 */
+	14, 14, 14, 14, 14 /* 31 to 36 */
 };
 
 typedef struct {
 	duk_int16_t upper;
 	duk_int16_t lower;
 } duk__exp_limits;
 
 DUK_LOCAL const duk__exp_limits duk__str2num_exp_limits[] = {
-	{ 957, -1147 }, { 605, -725 },  { 479, -575 },  { 414, -496 },
-	{ 372, -446 },  { 342, -411 },  { 321, -384 },  { 304, -364 },
-	{ 291, -346 },  { 279, -334 },  { 268, -323 },  { 260, -312 },
-	{ 252, -304 },  { 247, -296 },  { 240, -289 },  { 236, -283 },
-	{ 231, -278 },  { 227, -273 },  { 223, -267 },  { 220, -263 },
-	{ 216, -260 },  { 213, -256 },  { 210, -253 },  { 208, -249 },
-	{ 205, -246 },  { 203, -244 },  { 201, -241 },  { 198, -239 },
-	{ 196, -237 },  { 195, -234 },  { 193, -232 },  { 191, -230 },
-	{ 190, -228 },  { 188, -226 },  { 187, -225 },
+	{ 957, -1147 }, { 605, -725 }, { 479, -575 }, { 414, -496 }, { 372, -446 }, { 342, -411 }, { 321, -384 },
+	{ 304, -364 },  { 291, -346 }, { 279, -334 }, { 268, -323 }, { 260, -312 }, { 252, -304 }, { 247, -296 },
+	{ 240, -289 },  { 236, -283 }, { 231, -278 }, { 227, -273 }, { 223, -267 }, { 220, -263 }, { 216, -260 },
+	{ 213, -256 },  { 210, -253 }, { 208, -249 }, { 205, -246 }, { 203, -244 }, { 201, -241 }, { 198, -239 },
+	{ 196, -237 },  { 195, -234 }, { 193, -232 }, { 191, -230 }, { 190, -228 }, { 188, -226 }, { 187, -225 },
 };
 
 /*
  *  Limited functionality bigint implementation.
  *
  *  Restricted to non-negative numbers with less than 32 * DUK__BI_MAX_PARTS bits,
  *  with the caller responsible for ensuring this is never exceeded.  No memory
@@ -87099,26 +88390,26 @@
  *  Argument order is "assignment order", i.e. target first, then arguments:
  *  x <- y * z  -->  duk__bi_mul(x, y, z);
  */
 
 /* This upper value has been experimentally determined; debug build will check
  * bigint size with assertions.
  */
-#define DUK__BI_MAX_PARTS  37  /* 37x32 = 1184 bits */
+#define DUK__BI_MAX_PARTS 37 /* 37x32 = 1184 bits */
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
-#define DUK__BI_PRINT(name,x)  duk__bi_print((name),(x))
+#define DUK__BI_PRINT(name, x) duk__bi_print((name), (x))
 #else
-#define DUK__BI_PRINT(name,x)
+#define DUK__BI_PRINT(name, x)
 #endif
 
 /* Current size is about 152 bytes. */
 typedef struct {
 	duk_small_int_t n;
-	duk_uint32_t v[DUK__BI_MAX_PARTS];  /* low to high */
+	duk_uint32_t v[DUK__BI_MAX_PARTS]; /* low to high */
 } duk__bigint;
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
 DUK_LOCAL void duk__bi_print(const char *name, duk__bigint *x) {
 	/* Overestimate required size; debug code so not critical to be tight. */
 	char buf[DUK__BI_MAX_PARTS * 9 + 64];
 	char *p = buf;
@@ -87135,17 +88426,16 @@
 
 	DUK_DDD(DUK_DDDPRINT("%s: %s", (const char *) name, (const char *) buf));
 }
 #endif
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_LOCAL duk_small_int_t duk__bi_is_valid(duk__bigint *x) {
-	return (duk_small_int_t)
-	       ( ((x->n >= 0) && (x->n <= DUK__BI_MAX_PARTS)) /* is valid size */ &&
-	         ((x->n == 0) || (x->v[x->n - 1] != 0)) /* is normalized */ );
+	return (duk_small_int_t) (((x->n >= 0) && (x->n <= DUK__BI_MAX_PARTS)) /* is valid size */ &&
+	                          ((x->n == 0) || (x->v[x->n - 1] != 0)) /* is normalized */);
 }
 #endif
 
 DUK_LOCAL void duk__bi_normalize(duk__bigint *x) {
 	duk_small_int_t i;
 
 	for (i = x->n - 1; i >= 0; i--) {
@@ -87208,37 +88498,40 @@
 		if (tx < ty) {
 			goto ret_lt;
 		}
 	}
 
 	return 0;
 
- ret_gt:
+ret_gt:
 	return 1;
 
- ret_lt:
+ret_lt:
 	return -1;
 }
 
 /* x <- y + z */
 #if defined(DUK_USE_64BIT_OPS)
 DUK_LOCAL void duk__bi_add(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 	duk_uint64_t tmp;
 	duk_small_int_t i, ny, nz;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 	DUK_ASSERT(duk__bi_is_valid(z));
 
 	if (z->n > y->n) {
 		duk__bigint *t;
-		t = y; y = z; z = t;
+		t = y;
+		y = z;
+		z = t;
 	}
 	DUK_ASSERT(y->n >= z->n);
 
-	ny = y->n; nz = z->n;
+	ny = y->n;
+	nz = z->n;
 	tmp = 0U;
 	for (i = 0; i < ny; i++) {
 		DUK_ASSERT(i < DUK__BI_MAX_PARTS);
 		tmp += y->v[i];
 		if (i < nz) {
 			tmp += z->v[i];
 		}
@@ -87251,29 +88544,32 @@
 	}
 	x->n = i;
 	DUK_ASSERT(x->n <= DUK__BI_MAX_PARTS);
 
 	/* no need to normalize */
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
-#else  /* DUK_USE_64BIT_OPS */
+#else /* DUK_USE_64BIT_OPS */
 DUK_LOCAL void duk__bi_add(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 	duk_uint32_t carry, tmp1, tmp2;
 	duk_small_int_t i, ny, nz;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 	DUK_ASSERT(duk__bi_is_valid(z));
 
 	if (z->n > y->n) {
 		duk__bigint *t;
-		t = y; y = z; z = t;
+		t = y;
+		y = z;
+		z = t;
 	}
 	DUK_ASSERT(y->n >= z->n);
 
-	ny = y->n; nz = z->n;
+	ny = y->n;
+	nz = z->n;
 	carry = 0U;
 	for (i = 0; i < ny; i++) {
 		/* Carry is detected based on wrapping which relies on exact 32-bit
 		 * types.
 		 */
 		DUK_ASSERT(i < DUK__BI_MAX_PARTS);
 		tmp1 = y->v[i];
@@ -87302,30 +88598,30 @@
 	}
 	x->n = i;
 	DUK_ASSERT(x->n <= DUK__BI_MAX_PARTS);
 
 	/* no need to normalize */
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
-#endif  /* DUK_USE_64BIT_OPS */
+#endif /* DUK_USE_64BIT_OPS */
 
 /* x <- y + z */
 DUK_LOCAL void duk__bi_add_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 	duk__bigint tmp;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 
 	/* XXX: this could be optimized; there is only one call site now though */
 	duk__bi_set_small(&tmp, z);
 	duk__bi_add(x, y, &tmp);
 
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 /* x <- x + y, use t as temp */
 DUK_LOCAL void duk__bi_add_copy(duk__bigint *x, duk__bigint *y, duk__bigint *t) {
 	duk__bi_add(t, x, y);
 	duk__bi_copy(x, t);
 }
 #endif
 
@@ -87337,44 +88633,46 @@
 	duk_int64_t tmp;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 	DUK_ASSERT(duk__bi_is_valid(z));
 	DUK_ASSERT(duk__bi_compare(y, z) >= 0);
 	DUK_ASSERT(y->n >= z->n);
 
-	ny = y->n; nz = z->n;
+	ny = y->n;
+	nz = z->n;
 	tmp = 0;
 	for (i = 0; i < ny; i++) {
 		ty = y->v[i];
 		if (i < nz) {
 			tz = z->v[i];
 		} else {
 			tz = 0;
 		}
 		tmp = (duk_int64_t) ty - (duk_int64_t) tz + tmp;
 		x->v[i] = (duk_uint32_t) ((duk_uint64_t) tmp & 0xffffffffUL);
-		tmp = tmp >> 32;  /* 0 or -1 */
+		tmp = tmp >> 32; /* 0 or -1 */
 	}
 	DUK_ASSERT(tmp == 0);
 
 	x->n = i;
-	duk__bi_normalize(x);  /* need to normalize, may even cancel to 0 */
+	duk__bi_normalize(x); /* need to normalize, may even cancel to 0 */
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
 #else
 DUK_LOCAL void duk__bi_sub(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 	duk_small_int_t i, ny, nz;
 	duk_uint32_t tmp1, tmp2, borrow;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 	DUK_ASSERT(duk__bi_is_valid(z));
 	DUK_ASSERT(duk__bi_compare(y, z) >= 0);
 	DUK_ASSERT(y->n >= z->n);
 
-	ny = y->n; nz = z->n;
+	ny = y->n;
+	nz = z->n;
 	borrow = 0U;
 	for (i = 0; i < ny; i++) {
 		/* Borrow is detected based on wrapping which relies on exact 32-bit
 		 * types.
 		 */
 		tmp1 = y->v[i];
 		tmp2 = tmp1;
@@ -87394,20 +88692,20 @@
 		}
 
 		x->v[i] = tmp2;
 	}
 	DUK_ASSERT(borrow == 0U);
 
 	x->n = i;
-	duk__bi_normalize(x);  /* need to normalize, may even cancel to 0 */
+	duk__bi_normalize(x); /* need to normalize, may even cancel to 0 */
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
 #endif
 
-#if 0  /* unused */
+#if 0 /* unused */
 /* x <- y - z */
 DUK_LOCAL void duk__bi_sub_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 	duk__bigint tmp;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 
 	/* XXX: this could be optimized */
@@ -87427,15 +88725,15 @@
 /* x <- y * z */
 DUK_LOCAL void duk__bi_mul(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 	duk_small_int_t i, j, nx, nz;
 
 	DUK_ASSERT(duk__bi_is_valid(y));
 	DUK_ASSERT(duk__bi_is_valid(z));
 
-	nx = y->n + z->n;  /* max possible */
+	nx = y->n + z->n; /* max possible */
 	DUK_ASSERT(nx <= DUK__BI_MAX_PARTS);
 
 	if (nx == 0) {
 		/* Both inputs are zero; cases where only one is zero can go
 		 * through main algorithm.
 		 */
 		x->n = 0;
@@ -87446,23 +88744,23 @@
 	x->n = nx;
 
 	nz = z->n;
 	for (i = 0; i < y->n; i++) {
 #if defined(DUK_USE_64BIT_OPS)
 		duk_uint64_t tmp = 0U;
 		for (j = 0; j < nz; j++) {
-			tmp += (duk_uint64_t) y->v[i] * (duk_uint64_t) z->v[j] + x->v[i+j];
-			x->v[i+j] = (duk_uint32_t) (tmp & 0xffffffffUL);
+			tmp += (duk_uint64_t) y->v[i] * (duk_uint64_t) z->v[j] + x->v[i + j];
+			x->v[i + j] = (duk_uint32_t) (tmp & 0xffffffffUL);
 			tmp = tmp >> 32;
 		}
 		if (tmp > 0) {
 			DUK_ASSERT(i + j < nx);
 			DUK_ASSERT(i + j < DUK__BI_MAX_PARTS);
-			DUK_ASSERT(x->v[i+j] == 0U);
-			x->v[i+j] = (duk_uint32_t) tmp;
+			DUK_ASSERT(x->v[i + j] == 0U);
+			x->v[i + j] = (duk_uint32_t) tmp;
 		}
 #else
 		/*
 		 *  Multiply + add + carry for 32-bit components using only 16x16->32
 		 *  multiplies and carry detection based on unsigned overflow.
 		 *
 		 *    1st mult, 32-bit: (A*2^16 + B)
@@ -87474,68 +88772,82 @@
 		 *    = AC*2^32 + AD*2^16 + BC*2^16 + BD + E + F
 		 *    = AC*2^32 + (AD + BC)*2^16 + (BD + E + F)
 		 *    = AC*2^32 + AD*2^16 + BC*2^16 + (BD + E + F)
 		 */
 		duk_uint32_t a, b, c, d, e, f;
 		duk_uint32_t r, s, t;
 
-		a = y->v[i]; b = a & 0xffffUL; a = a >> 16;
+		a = y->v[i];
+		b = a & 0xffffUL;
+		a = a >> 16;
 
 		f = 0;
 		for (j = 0; j < nz; j++) {
-			c = z->v[j]; d = c & 0xffffUL; c = c >> 16;
-			e = x->v[i+j];
+			c = z->v[j];
+			d = c & 0xffffUL;
+			c = c >> 16;
+			e = x->v[i + j];
 
 			/* build result as: (r << 32) + s: start with (BD + E + F) */
 			r = 0;
 			s = b * d;
 
 			/* add E */
 			t = s + e;
-			if (t < s) { r++; }  /* carry */
+			if (t < s) {
+				r++;
+			} /* carry */
 			s = t;
 
 			/* add F */
 			t = s + f;
-			if (t < s) { r++; }  /* carry */
+			if (t < s) {
+				r++;
+			} /* carry */
 			s = t;
 
 			/* add BC*2^16 */
 			t = b * c;
 			r += (t >> 16);
 			t = s + ((t & 0xffffUL) << 16);
-			if (t < s) { r++; }  /* carry */
+			if (t < s) {
+				r++;
+			} /* carry */
 			s = t;
 
 			/* add AD*2^16 */
 			t = a * d;
 			r += (t >> 16);
 			t = s + ((t & 0xffffUL) << 16);
-			if (t < s) { r++; }  /* carry */
+			if (t < s) {
+				r++;
+			} /* carry */
 			s = t;
 
 			/* add AC*2^32 */
 			t = a * c;
 			r += t;
 
 			DUK_DDD(DUK_DDDPRINT("ab=%08lx cd=%08lx ef=%08lx -> rs=%08lx %08lx",
-			                     (unsigned long) y->v[i], (unsigned long) z->v[j],
-			                     (unsigned long) x->v[i+j], (unsigned long) r,
+			                     (unsigned long) y->v[i],
+			                     (unsigned long) z->v[j],
+			                     (unsigned long) x->v[i + j],
+			                     (unsigned long) r,
 			                     (unsigned long) s));
 
-			x->v[i+j] = s;
+			x->v[i + j] = s;
 			f = r;
 		}
 		if (f > 0U) {
 			DUK_ASSERT(i + j < nx);
 			DUK_ASSERT(i + j < DUK__BI_MAX_PARTS);
-			DUK_ASSERT(x->v[i+j] == 0U);
-			x->v[i+j] = (duk_uint32_t) f;
+			DUK_ASSERT(x->v[i + j] == 0U);
+			x->v[i + j] = (duk_uint32_t) f;
 		}
-#endif  /* DUK_USE_64BIT_OPS */
+#endif /* DUK_USE_64BIT_OPS */
 	}
 
 	duk__bi_normalize(x);
 	DUK_ASSERT(duk__bi_is_valid(x));
 }
 
 /* x <- y * z */
@@ -87566,27 +88878,26 @@
 DUK_LOCAL int duk__bi_is_even(duk__bigint *x) {
 	DUK_ASSERT(duk__bi_is_valid(x));
 	return (x->n == 0) || ((x->v[0] & 0x01) == 0);
 }
 
 DUK_LOCAL int duk__bi_is_zero(duk__bigint *x) {
 	DUK_ASSERT(duk__bi_is_valid(x));
-	return (x->n == 0);  /* this is the case for normalized numbers */
+	return (x->n == 0); /* this is the case for normalized numbers */
 }
 
 /* Bigint is 2^52.  Used to detect normalized IEEE double mantissa values
  * which are at the lowest edge (next floating point value downwards has
  * a different exponent).  The lowest mantissa has the form:
  *
  *     1000........000    (52 zeroes; only "hidden bit" is set)
  */
 DUK_LOCAL duk_small_int_t duk__bi_is_2to52(duk__bigint *x) {
 	DUK_ASSERT(duk__bi_is_valid(x));
-	return (duk_small_int_t)
-	        (x->n == 2) && (x->v[0] == 0U) && (x->v[1] == (1U << (52-32)));
+	return (duk_small_int_t) (x->n == 2) && (x->v[0] == 0U) && (x->v[1] == (1U << (52 - 32)));
 }
 
 /* x <- (1<<y) */
 DUK_LOCAL void duk__bi_twoexp(duk__bigint *x, duk_small_int_t y) {
 	duk_small_int_t n, r;
 
 	n = (y / 32) + 1;
@@ -87597,15 +88908,15 @@
 	x->v[n - 1] = (((duk_uint32_t) 1) << r);
 }
 
 /* x <- b^y; use t1 and t2 as temps */
 DUK_LOCAL void duk__bi_exp_small(duk__bigint *x, duk_small_int_t b, duk_small_int_t y, duk__bigint *t1, duk__bigint *t2) {
 	/* Fast path the binary case */
 
-	DUK_ASSERT(x != t1 && x != t2 && t1 != t2);  /* distinct bignums, easy mistake to make */
+	DUK_ASSERT(x != t1 && x != t2 && t1 != t2); /* distinct bignums, easy mistake to make */
 	DUK_ASSERT(b >= 0);
 	DUK_ASSERT(y >= 0);
 
 	if (b == 2) {
 		duk__bi_twoexp(x, y);
 		return;
 	}
@@ -87652,56 +88963,57 @@
  *  The same algorithm is used for number parsing (with b=10 and B=2)
  *  by generating one extra digit and doing rounding manually.
  *
  *  See doc/number-conversion.rst for limitations.
  */
 
 /* Maximum number of digits generated. */
-#define DUK__MAX_OUTPUT_DIGITS          1040  /* (Number.MAX_VALUE).toString(2).length == 1024, + slack */
+#define DUK__MAX_OUTPUT_DIGITS 1040 /* (Number.MAX_VALUE).toString(2).length == 1024, + slack */
 
 /* Maximum number of characters in formatted value. */
-#define DUK__MAX_FORMATTED_LENGTH       1040  /* (-Number.MAX_VALUE).toString(2).length == 1025, + slack */
+#define DUK__MAX_FORMATTED_LENGTH 1040 /* (-Number.MAX_VALUE).toString(2).length == 1025, + slack */
 
 /* Number and (minimum) size of bigints in the nc_ctx structure. */
-#define DUK__NUMCONV_CTX_NUM_BIGINTS    7
-#define DUK__NUMCONV_CTX_BIGINTS_SIZE   (sizeof(duk__bigint) * DUK__NUMCONV_CTX_NUM_BIGINTS)
+#define DUK__NUMCONV_CTX_NUM_BIGINTS  7
+#define DUK__NUMCONV_CTX_BIGINTS_SIZE (sizeof(duk__bigint) * DUK__NUMCONV_CTX_NUM_BIGINTS)
 
 typedef struct {
 	/* Currently about 7*152 = 1064 bytes.  The space for these
 	 * duk__bigints is used also as a temporary buffer for generating
 	 * the final string.  This is a bit awkard; a union would be
 	 * more correct.
 	 */
 	duk__bigint f, r, s, mp, mm, t1, t2;
 
-	duk_small_int_t is_s2n;        /* if 1, doing a string-to-number; else doing a number-to-string */
-	duk_small_int_t is_fixed;      /* if 1, doing a fixed format output (not free format) */
-	duk_small_int_t req_digits;    /* requested number of output digits; 0 = free-format */
-	duk_small_int_t abs_pos;       /* digit position is absolute, not relative */
-	duk_small_int_t e;             /* exponent for 'f' */
-	duk_small_int_t b;             /* input radix */
-	duk_small_int_t B;             /* output radix */
-	duk_small_int_t k;             /* see algorithm */
-	duk_small_int_t low_ok;        /* see algorithm */
-	duk_small_int_t high_ok;       /* see algorithm */
-	duk_small_int_t unequal_gaps;  /* m+ != m- (very rarely) */
+	duk_small_int_t is_s2n; /* if 1, doing a string-to-number; else doing a number-to-string */
+	duk_small_int_t is_fixed; /* if 1, doing a fixed format output (not free format) */
+	duk_small_int_t req_digits; /* requested number of output digits; 0 = free-format */
+	duk_small_int_t abs_pos; /* digit position is absolute, not relative */
+	duk_small_int_t e; /* exponent for 'f' */
+	duk_small_int_t b; /* input radix */
+	duk_small_int_t B; /* output radix */
+	duk_small_int_t k; /* see algorithm */
+	duk_small_int_t low_ok; /* see algorithm */
+	duk_small_int_t high_ok; /* see algorithm */
+	duk_small_int_t unequal_gaps; /* m+ != m- (very rarely) */
 
 	/* Buffer used for generated digits, values are in the range [0,B-1]. */
 	duk_uint8_t digits[DUK__MAX_OUTPUT_DIGITS];
-	duk_small_int_t count;  /* digit count */
+	duk_small_int_t count; /* digit count */
 } duk__numconv_stringify_ctx;
 
 /* Note: computes with 'idx' in assertions, so caller beware.
  * 'idx' is preincremented, i.e. '1' on first call, because it
  * is more convenient for the caller.
  */
-#define DUK__DRAGON4_OUTPUT_PREINC(nc_ctx,preinc_idx,x)  do { \
-		DUK_ASSERT((preinc_idx) - 1 >= 0); \
-		DUK_ASSERT((preinc_idx) - 1 < DUK__MAX_OUTPUT_DIGITS); \
-		((nc_ctx)->digits[(preinc_idx) - 1]) = (duk_uint8_t) (x); \
+#define DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, preinc_idx, x) \
+	do { \
+		DUK_ASSERT((preinc_idx) -1 >= 0); \
+		DUK_ASSERT((preinc_idx) -1 < DUK__MAX_OUTPUT_DIGITS); \
+		((nc_ctx)->digits[(preinc_idx) -1]) = (duk_uint8_t) (x); \
 	} while (0)
 
 DUK_LOCAL duk_size_t duk__dragon4_format_uint32(duk_uint8_t *buf, duk_uint32_t x, duk_small_int_t radix) {
 	duk_uint8_t *p;
 	duk_size_t len;
 	duk_small_int_t dig;
 	duk_uint32_t t;
@@ -87792,19 +89104,19 @@
 			 * high_ok <- round
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("non-negative exponent (not smallest exponent); "
 			                     "lowest mantissa value for this exponent -> "
 			                     "unequal gaps"));
 
-			duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);  /* mm <- b^e */
-			duk__bi_mul_small(&nc_ctx->mp, &nc_ctx->mm, (duk_uint32_t) nc_ctx->b);           /* mp <- b^(e+1) */
+			duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2); /* mm <- b^e */
+			duk__bi_mul_small(&nc_ctx->mp, &nc_ctx->mm, (duk_uint32_t) nc_ctx->b); /* mp <- b^(e+1) */
 			duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
-			duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);              /* r <- (2 * f) * b^(e+1) */
-			duk__bi_set_small(&nc_ctx->s, (duk_uint32_t) (nc_ctx->b * 2));  /* s <- 2 * b */
+			duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp); /* r <- (2 * f) * b^(e+1) */
+			duk__bi_set_small(&nc_ctx->s, (duk_uint32_t) (nc_ctx->b * 2)); /* s <- 2 * b */
 			nc_ctx->unequal_gaps = 1;
 		} else {
 			/* (>= e 0) AND (not (= f (expt b (- p 1))))
 			 *
 			 * be <- (expt b e) == b^e
 			 * r <- (* f be 2) == 2 * f * b^e    [if b==2 -> f * b^(e+1)]
 			 * s <- 2
@@ -87816,19 +89128,19 @@
 			 * high_ok <- round
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("non-negative exponent (not smallest exponent); "
 			                     "not lowest mantissa for this exponent -> "
 			                     "equal gaps"));
 
-			duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);  /* mm <- b^e */
-			duk__bi_copy(&nc_ctx->mp, &nc_ctx->mm);                /* mp <- b^e */
+			duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2); /* mm <- b^e */
+			duk__bi_copy(&nc_ctx->mp, &nc_ctx->mm); /* mp <- b^e */
 			duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
-			duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);     /* r <- (2 * f) * b^e */
-			duk__bi_set_small(&nc_ctx->s, 2);                      /* s <- 2 */
+			duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp); /* r <- (2 * f) * b^e */
+			duk__bi_set_small(&nc_ctx->s, 2); /* s <- 2 */
 		}
 	} else {
 		/* When doing string-to-number, lowest_mantissa is always 0 so
 		 * the exponent check, while incorrect, won't matter.
 		 */
 		if (nc_ctx->e > DUK__IEEE_DOUBLE_EXP_MIN /*not minimum exponent*/ &&
 		    lowest_mantissa /* lowest mantissa for this exponent*/) {
@@ -87842,17 +89154,21 @@
 			 * high_ok <- round
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("negative exponent; not minimum exponent and "
 			                     "lowest mantissa for this exponent -> "
 			                     "unequal gaps"));
 
-			duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, (duk_uint32_t) (nc_ctx->b * 2));  /* r <- (2 * b) * f */
-			duk__bi_exp_small(&nc_ctx->t1, nc_ctx->b, 1 - nc_ctx->e, &nc_ctx->s, &nc_ctx->t2);  /* NB: use 's' as temp on purpose */
-			duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);             /* s <- b^(1-e) * 2 */
+			duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, (duk_uint32_t) (nc_ctx->b * 2)); /* r <- (2 * b) * f */
+			duk__bi_exp_small(&nc_ctx->t1,
+			                  nc_ctx->b,
+			                  1 - nc_ctx->e,
+			                  &nc_ctx->s,
+			                  &nc_ctx->t2); /* NB: use 's' as temp on purpose */
+			duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2); /* s <- b^(1-e) * 2 */
 			duk__bi_set_small(&nc_ctx->mp, 2);
 			duk__bi_set_small(&nc_ctx->mm, 1);
 			nc_ctx->unequal_gaps = 1;
 		} else {
 			/* r <- (* f 2)
 			 * s <- (* (expt b (- e)) 2) == b^(-e) * 2    [if b==2 -> b^(1-e)]
 			 * m+ <- 1
@@ -87863,17 +89179,21 @@
 			 * high_ok <- round
 			 */
 
 			DUK_DDD(DUK_DDDPRINT("negative exponent; minimum exponent or not "
 			                     "lowest mantissa for this exponent -> "
 			                     "equal gaps"));
 
-			duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, 2);            /* r <- 2 * f */
-			duk__bi_exp_small(&nc_ctx->t1, nc_ctx->b, -nc_ctx->e, &nc_ctx->s, &nc_ctx->t2);  /* NB: use 's' as temp on purpose */
-			duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);           /* s <- b^(-e) * 2 */
+			duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, 2); /* r <- 2 * f */
+			duk__bi_exp_small(&nc_ctx->t1,
+			                  nc_ctx->b,
+			                  -nc_ctx->e,
+			                  &nc_ctx->s,
+			                  &nc_ctx->t2); /* NB: use 's' as temp on purpose */
+			duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2); /* s <- b^(-e) * 2 */
 			duk__bi_set_small(&nc_ctx->mp, 1);
 			duk__bi_set_small(&nc_ctx->mm, 1);
 		}
 	}
 }
 
 DUK_LOCAL void duk__dragon4_scale(duk__numconv_stringify_ctx *nc_ctx) {
@@ -87897,29 +89217,29 @@
 	/* XXX: this algorithm could be optimized quite a lot by using e.g.
 	 * a logarithm based estimator for 'k' and performing B^n multiplication
 	 * using a lookup table or using some bit-representation based exp
 	 * algorithm.  Currently we just loop, with significant performance
 	 * impact for very large and very small numbers.
 	 */
 
-	DUK_DDD(DUK_DDDPRINT("scale: B=%ld, low_ok=%ld, high_ok=%ld",
-	                     (long) nc_ctx->B, (long) nc_ctx->low_ok, (long) nc_ctx->high_ok));
+	DUK_DDD(
+	    DUK_DDDPRINT("scale: B=%ld, low_ok=%ld, high_ok=%ld", (long) nc_ctx->B, (long) nc_ctx->low_ok, (long) nc_ctx->high_ok));
 	DUK__BI_PRINT("r(init)", &nc_ctx->r);
 	DUK__BI_PRINT("s(init)", &nc_ctx->s);
 	DUK__BI_PRINT("mp(init)", &nc_ctx->mp);
 	DUK__BI_PRINT("mm(init)", &nc_ctx->mm);
 
 	for (;;) {
 		DUK_DDD(DUK_DDDPRINT("scale loop (inc k), k=%ld", (long) k));
 		DUK__BI_PRINT("r", &nc_ctx->r);
 		DUK__BI_PRINT("s", &nc_ctx->s);
 		DUK__BI_PRINT("m+", &nc_ctx->mp);
 		DUK__BI_PRINT("m-", &nc_ctx->mm);
 
-		duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);  /* t1 = (+ r m+) */
+		duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp); /* t1 = (+ r m+) */
 		if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1)) {
 			DUK_DDD(DUK_DDDPRINT("k is too low"));
 			/* r <- r
 			 * s <- (* s B)
 			 * m+ <- m+
 			 * m- <- m-
 			 * k <- (+ k 1)
@@ -87940,16 +89260,16 @@
 	for (;;) {
 		DUK_DDD(DUK_DDDPRINT("scale loop (dec k), k=%ld", (long) k));
 		DUK__BI_PRINT("r", &nc_ctx->r);
 		DUK__BI_PRINT("s", &nc_ctx->s);
 		DUK__BI_PRINT("m+", &nc_ctx->mp);
 		DUK__BI_PRINT("m-", &nc_ctx->mm);
 
-		duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);  /* t1 = (+ r m+) */
-		duk__bi_mul_small(&nc_ctx->t2, &nc_ctx->t1, (duk_uint32_t) nc_ctx->B);   /* t2 = (* (+ r m+) B) */
+		duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp); /* t1 = (+ r m+) */
+		duk__bi_mul_small(&nc_ctx->t2, &nc_ctx->t1, (duk_uint32_t) nc_ctx->B); /* t2 = (* (+ r m+) B) */
 		if (duk__bi_compare(&nc_ctx->t2, &nc_ctx->s) <= (nc_ctx->high_ok ? -1 : 0)) {
 			DUK_DDD(DUK_DDDPRINT("k is too high"));
 			/* r <- (* r B)
 			 * s <- s
 			 * m+ <- (* m+ B)
 			 * m- <- (* m- B)
 			 * k <- (- k 1)
@@ -87962,33 +89282,33 @@
 			}
 			k--;
 		} else {
 			break;
 		}
 	}
 
- skip_dec_k:
+skip_dec_k:
 
 	if (!nc_ctx->unequal_gaps) {
 		DUK_DDD(DUK_DDDPRINT("equal gaps, copy m- from m+"));
-		duk__bi_copy(&nc_ctx->mm, &nc_ctx->mp);  /* mm <- mp */
+		duk__bi_copy(&nc_ctx->mm, &nc_ctx->mp); /* mm <- mp */
 	}
 	nc_ctx->k = k;
 
 	DUK_DDD(DUK_DDDPRINT("final k: %ld", (long) k));
 	DUK__BI_PRINT("r(final)", &nc_ctx->r);
 	DUK__BI_PRINT("s(final)", &nc_ctx->s);
 	DUK__BI_PRINT("mp(final)", &nc_ctx->mp);
 	DUK__BI_PRINT("mm(final)", &nc_ctx->mm);
 }
 
 DUK_LOCAL void duk__dragon4_generate(duk__numconv_stringify_ctx *nc_ctx) {
-	duk_small_int_t tc1, tc2;    /* terminating conditions */
-	duk_small_int_t d;           /* current digit */
-	duk_small_int_t count = 0;   /* digit count */
+	duk_small_int_t tc1, tc2; /* terminating conditions */
+	duk_small_int_t d; /* current digit */
+	duk_small_int_t count = 0; /* digit count */
 
 	/*
 	 *  Digit generation loop.
 	 *
 	 *  Different termination conditions:
 	 *
 	 *    1. Free format output.  Terminate when shortest accurate
@@ -88002,33 +89322,36 @@
 	 *       position (e.g. 10 digits after decimal point).  Note
 	 *       that we always generate at least one digit, even if
 	 *       the digit is below the cut-off point already.
 	 */
 
 	for (;;) {
 		DUK_DDD(DUK_DDDPRINT("generate loop, count=%ld, k=%ld, B=%ld, low_ok=%ld, high_ok=%ld",
-		                     (long) count, (long) nc_ctx->k, (long) nc_ctx->B,
-		                     (long) nc_ctx->low_ok, (long) nc_ctx->high_ok));
+		                     (long) count,
+		                     (long) nc_ctx->k,
+		                     (long) nc_ctx->B,
+		                     (long) nc_ctx->low_ok,
+		                     (long) nc_ctx->high_ok));
 		DUK__BI_PRINT("r", &nc_ctx->r);
 		DUK__BI_PRINT("s", &nc_ctx->s);
 		DUK__BI_PRINT("m+", &nc_ctx->mp);
 		DUK__BI_PRINT("m-", &nc_ctx->mm);
 
 		/* (quotient-remainder (* r B) s) using a dummy subtraction loop */
-		duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, (duk_uint32_t) nc_ctx->B);       /* t1 <- (* r B) */
+		duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, (duk_uint32_t) nc_ctx->B); /* t1 <- (* r B) */
 		d = 0;
 		for (;;) {
 			if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {
 				break;
 			}
-			duk__bi_sub_copy(&nc_ctx->t1, &nc_ctx->s, &nc_ctx->t2);  /* t1 <- t1 - s */
+			duk__bi_sub_copy(&nc_ctx->t1, &nc_ctx->s, &nc_ctx->t2); /* t1 <- t1 - s */
 			d++;
 		}
-		duk__bi_copy(&nc_ctx->r, &nc_ctx->t1);  /* r <- (remainder (* r B) s) */
-		                                        /* d <- (quotient (* r B) s)   (in range 0...B-1) */
+		duk__bi_copy(&nc_ctx->r, &nc_ctx->t1); /* r <- (remainder (* r B) s) */
+		/* d <- (quotient (* r B) s)   (in range 0...B-1) */
 		DUK_DDD(DUK_DDDPRINT("-> d(quot)=%ld", (long) d));
 		DUK__BI_PRINT("r(rem)", &nc_ctx->r);
 
 		duk__bi_mul_small_copy(&nc_ctx->mp, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2); /* m+ <- (* m+ B) */
 		duk__bi_mul_small_copy(&nc_ctx->mm, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2); /* m- <- (* m- B) */
 		DUK__BI_PRINT("mp(upd)", &nc_ctx->mp);
 		DUK__BI_PRINT("mm(upd)", &nc_ctx->mm);
@@ -88039,15 +89362,15 @@
 		 * extra digits and use rounding (with carry) to finish the output.
 		 */
 
 		if (nc_ctx->is_fixed == 0) {
 			/* free-form */
 			tc1 = (duk__bi_compare(&nc_ctx->r, &nc_ctx->mm) <= (nc_ctx->low_ok ? 0 : -1));
 
-			duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);  /* t1 <- (+ r m+) */
+			duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp); /* t1 <- (+ r m+) */
 			tc2 = (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1));
 
 			DUK_DDD(DUK_DDDPRINT("tc1=%ld, tc2=%ld", (long) tc1, (long) tc2));
 		} else {
 			/* fixed-format */
 			tc1 = 0;
 			tc2 = 0;
@@ -88058,42 +89381,43 @@
 		 */
 		count++;
 
 		if (tc1) {
 			if (tc2) {
 				/* tc1 = true, tc2 = true */
 				duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, 2);
-				if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {  /* (< (* r 2) s) */
+				if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) { /* (< (* r 2) s) */
 					DUK_DDD(DUK_DDDPRINT("tc1=true, tc2=true, 2r > s: output d --> %ld (k=%ld)",
-					                     (long) d, (long) nc_ctx->k));
+					                     (long) d,
+					                     (long) nc_ctx->k));
 					DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, count, d);
 				} else {
 					DUK_DDD(DUK_DDDPRINT("tc1=true, tc2=true, 2r <= s: output d+1 --> %ld (k=%ld)",
-					                     (long) (d + 1), (long) nc_ctx->k));
+					                     (long) (d + 1),
+					                     (long) nc_ctx->k));
 					DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, count, d + 1);
 				}
 				break;
 			} else {
 				/* tc1 = true, tc2 = false */
-				DUK_DDD(DUK_DDDPRINT("tc1=true, tc2=false: output d --> %ld (k=%ld)",
-				                     (long) d, (long) nc_ctx->k));
+				DUK_DDD(DUK_DDDPRINT("tc1=true, tc2=false: output d --> %ld (k=%ld)", (long) d, (long) nc_ctx->k));
 				DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, count, d);
 				break;
 			}
 		} else {
 			if (tc2) {
 				/* tc1 = false, tc2 = true */
 				DUK_DDD(DUK_DDDPRINT("tc1=false, tc2=true: output d+1 --> %ld (k=%ld)",
-				                     (long) (d + 1), (long) nc_ctx->k));
+				                     (long) (d + 1),
+				                     (long) nc_ctx->k));
 				DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, count, d + 1);
 				break;
 			} else {
 				/* tc1 = false, tc2 = false */
-				DUK_DDD(DUK_DDDPRINT("tc1=false, tc2=false: output d --> %ld (k=%ld)",
-				                     (long) d, (long) nc_ctx->k));
+				DUK_DDD(DUK_DDDPRINT("tc1=false, tc2=false: output d --> %ld (k=%ld)", (long) d, (long) nc_ctx->k));
 				DUK__DRAGON4_OUTPUT_PREINC(nc_ctx, count, d);
 
 				/* r <- r    (updated above: r <- (remainder (* r B) s)
 				 * s <- s
 				 * m+ <- m+  (updated above: m+ <- (* m+ B)
 				 * m- <- m-  (updated above: m- <- (* m- B)
 				 * B, low_ok, high_ok are fixed
@@ -88102,31 +89426,36 @@
 				/* fall through and continue for-loop */
 			}
 		}
 
 		/* fixed-format termination conditions */
 		if (nc_ctx->is_fixed) {
 			if (nc_ctx->abs_pos) {
-				int pos = nc_ctx->k - count + 1;  /* count is already incremented, take into account */
+				int pos = nc_ctx->k - count + 1; /* count is already incremented, take into account */
 				DUK_DDD(DUK_DDDPRINT("fixed format, absolute: abs pos=%ld, k=%ld, count=%ld, req=%ld",
-				                     (long) pos, (long) nc_ctx->k, (long) count, (long) nc_ctx->req_digits));
+				                     (long) pos,
+				                     (long) nc_ctx->k,
+				                     (long) count,
+				                     (long) nc_ctx->req_digits));
 				if (pos <= nc_ctx->req_digits) {
 					DUK_DDD(DUK_DDDPRINT("digit position reached req_digits, end generate loop"));
 					break;
 				}
 			} else {
 				DUK_DDD(DUK_DDDPRINT("fixed format, relative: k=%ld, count=%ld, req=%ld",
-				                     (long) nc_ctx->k, (long) count, (long) nc_ctx->req_digits));
+				                     (long) nc_ctx->k,
+				                     (long) count,
+				                     (long) nc_ctx->req_digits));
 				if (count >= nc_ctx->req_digits) {
 					DUK_DDD(DUK_DDDPRINT("digit count reached req_digits, end generate loop"));
 					break;
 				}
 			}
 		}
-	}  /* for */
+	} /* for */
 
 	nc_ctx->count = count;
 
 	DUK_DDD(DUK_DDDPRINT("generate finished"));
 
 #if defined(DUK_USE_DEBUG_LEVEL) && (DUK_USE_DEBUG_LEVEL >= 2)
 	{
@@ -88137,16 +89466,15 @@
 			t = nc_ctx->digits[i];
 			if (t < 0 || t > 36) {
 				buf[i] = (duk_uint8_t) '?';
 			} else {
 				buf[i] = (duk_uint8_t) DUK__DIGITCHAR(t);
 			}
 		}
-		DUK_DDD(DUK_DDDPRINT("-> generated digits; k=%ld, digits='%s'",
-		                     (long) nc_ctx->k, (const char *) buf));
+		DUK_DDD(DUK_DDDPRINT("-> generated digits; k=%ld, digits='%s'", (long) nc_ctx->k, (const char *) buf));
 	}
 #endif
 }
 
 /* Round up digits to a given position.  If position is out-of-bounds,
  * does nothing.  If carry propagates over the first digit, a '1' is
  * prepended to digits and 'k' will be updated.  Return value indicates
@@ -88167,19 +89495,19 @@
 	 *  digit to its left is the final digit of the rounded value.  If round_idx
 	 *  is zero, rounding will be performed; the result will either be an empty
 	 *  rounded value or if carry happens a '1' digit is generated.
 	 */
 
 	if (round_idx >= nc_ctx->count) {
 		DUK_DDD(DUK_DDDPRINT("round_idx out of bounds (%ld >= %ld (count)) -> no rounding",
-		                     (long) round_idx, (long) nc_ctx->count));
+		                     (long) round_idx,
+		                     (long) nc_ctx->count));
 		return 0;
 	} else if (round_idx < 0) {
-		DUK_DDD(DUK_DDDPRINT("round_idx out of bounds (%ld < 0) -> no rounding",
-		                     (long) round_idx));
+		DUK_DDD(DUK_DDDPRINT("round_idx out of bounds (%ld < 0) -> no rounding", (long) round_idx));
 		return 0;
 	}
 
 	/*
 	 *  Round-up limit.
 	 *
 	 *  For even values, divides evenly, e.g. 10 -> roundup_limit=5.
@@ -88196,23 +89524,26 @@
 		for (;;) {
 			*p = 0;
 			if (p == &nc_ctx->digits[0]) {
 				DUK_DDD(DUK_DDDPRINT("carry propagated to first digit -> special case handling"));
 				duk_memmove((void *) (&nc_ctx->digits[1]),
 				            (const void *) (&nc_ctx->digits[0]),
 				            (size_t) (sizeof(char) * (size_t) nc_ctx->count));
-				nc_ctx->digits[0] = 1;  /* don't increase 'count' */
-				nc_ctx->k++;  /* position of highest digit changed */
-				nc_ctx->count++;  /* number of digits changed */
+				nc_ctx->digits[0] = 1; /* don't increase 'count' */
+				nc_ctx->k++; /* position of highest digit changed */
+				nc_ctx->count++; /* number of digits changed */
 				ret = 1;
 				break;
 			}
 
 			DUK_DDD(DUK_DDDPRINT("fixed-format rounding carry: B=%ld, roundup_limit=%ld, p=%p, digits=%p",
-			                     (long) nc_ctx->B, (long) roundup_limit, (void *) p, (void *) nc_ctx->digits));
+			                     (long) nc_ctx->B,
+			                     (long) roundup_limit,
+			                     (void *) p,
+			                     (void *) nc_ctx->digits));
 			p--;
 			t = *p;
 			DUK_DDD(DUK_DDDPRINT("digit before carry: %ld", (long) t));
 			if (++t < nc_ctx->B) {
 				DUK_DDD(DUK_DDDPRINT("rounding carry terminated"));
 				*p = (duk_uint8_t) t;
 				break;
@@ -88221,15 +89552,15 @@
 			DUK_DDD(DUK_DDDPRINT("wraps, carry to next digit"));
 		}
 	}
 
 	return ret;
 }
 
-#define DUK__NO_EXP  (65536)  /* arbitrary marker, outside valid exp range */
+#define DUK__NO_EXP (65536) /* arbitrary marker, outside valid exp range */
 
 DUK_LOCAL void duk__dragon4_convert_and_push(duk__numconv_stringify_ctx *nc_ctx,
                                              duk_hthread *thr,
                                              duk_small_int_t radix,
                                              duk_small_int_t digits,
                                              duk_small_uint_t flags,
                                              duk_small_int_t neg) {
@@ -88264,34 +89595,33 @@
 	 *  allocating even more stack.
 	 */
 
 	DUK_ASSERT(DUK__NUMCONV_CTX_BIGINTS_SIZE >= DUK__MAX_FORMATTED_LENGTH);
 	DUK_ASSERT(nc_ctx->count >= 1);
 
 	k = nc_ctx->k;
-	buf = (duk_uint8_t *) &nc_ctx->f;  /* XXX: union would be more correct */
+	buf = (duk_uint8_t *) &nc_ctx->f; /* XXX: union would be more correct */
 	q = buf;
 
 	/* Exponent handling: if exponent format is used, record exponent value and
 	 * fake k such that one leading digit is generated (e.g. digits=123 -> "1.23").
 	 *
 	 * toFixed() prevents exponent use; otherwise apply a set of criteria to
 	 * match the other API calls (toString(), toPrecision, etc).
 	 */
 
 	expt = DUK__NO_EXP;
 	if (!nc_ctx->abs_pos /* toFixed() */) {
-		if ((flags & DUK_N2S_FLAG_FORCE_EXP) ||             /* exponential notation forced */
-		    ((flags & DUK_N2S_FLAG_NO_ZERO_PAD) &&          /* fixed precision and zero padding would be required */
-	             (k - digits >= 1)) ||                          /* (e.g. k=3, digits=2 -> "12X") */
-		    ((k > 21 || k <= -6) && (radix == 10))) {       /* toString() conditions */
-			DUK_DDD(DUK_DDDPRINT("use exponential notation: k=%ld -> expt=%ld",
-			                     (long) k, (long) (k - 1)));
-			expt = k - 1;  /* e.g. 12.3 -> digits="123" k=2 -> 1.23e1 */
-			k = 1;  /* generate mantissa with a single leading whole number digit */
+		if ((flags & DUK_N2S_FLAG_FORCE_EXP) || /* exponential notation forced */
+		    ((flags & DUK_N2S_FLAG_NO_ZERO_PAD) && /* fixed precision and zero padding would be required */
+		     (k - digits >= 1)) || /* (e.g. k=3, digits=2 -> "12X") */
+		    ((k > 21 || k <= -6) && (radix == 10))) { /* toString() conditions */
+			DUK_DDD(DUK_DDDPRINT("use exponential notation: k=%ld -> expt=%ld", (long) k, (long) (k - 1)));
+			expt = k - 1; /* e.g. 12.3 -> digits="123" k=2 -> 1.23e1 */
+			k = 1; /* generate mantissa with a single leading whole number digit */
 		}
 	}
 
 	if (neg) {
 		*q++ = '-';
 	}
 
@@ -88309,21 +89639,26 @@
 	}
 	if (pos_end > 0) {
 		pos_end = 0;
 	}
 
 	DUK_DDD(DUK_DDDPRINT("expt=%ld, k=%ld, count=%ld, pos=%ld, pos_end=%ld, is_fixed=%ld, "
 	                     "digits=%ld, abs_pos=%ld",
-	                     (long) expt, (long) k, (long) nc_ctx->count, (long) pos, (long) pos_end,
-	                     (long) nc_ctx->is_fixed, (long) digits, (long) nc_ctx->abs_pos));
+	                     (long) expt,
+	                     (long) k,
+	                     (long) nc_ctx->count,
+	                     (long) pos,
+	                     (long) pos_end,
+	                     (long) nc_ctx->is_fixed,
+	                     (long) digits,
+	                     (long) nc_ctx->abs_pos));
 
 	/* Digit generation */
 	while (pos > pos_end) {
-		DUK_DDD(DUK_DDDPRINT("digit generation: pos=%ld, pos_end=%ld",
-		                     (long) pos, (long) pos_end));
+		DUK_DDD(DUK_DDDPRINT("digit generation: pos=%ld, pos_end=%ld", (long) pos, (long) pos_end));
 		if (pos == 0) {
 			*q++ = (duk_uint8_t) '.';
 		}
 		if (pos > k) {
 			*q++ = (duk_uint8_t) '0';
 		} else if (pos <= k - nc_ctx->count) {
 			*q++ = (duk_uint8_t) '0';
@@ -88408,15 +89743,15 @@
 		/* denormal */
 		expt = DUK__IEEE_DOUBLE_EXP_MIN - 52;
 		duk__bi_normalize(&nc_ctx->f);
 	} else {
 		/* normal: implicit leading 1-bit */
 		nc_ctx->f.v[1] |= 0x00100000UL;
 		expt = expt - DUK__IEEE_DOUBLE_EXP_BIAS - 52;
-		DUK_ASSERT(duk__bi_is_valid(&nc_ctx->f));  /* true, because v[1] has at least one bit set */
+		DUK_ASSERT(duk__bi_is_valid(&nc_ctx->f)); /* true, because v[1] has at least one bit set */
 	}
 
 	DUK_ASSERT(duk__bi_is_valid(&nc_ctx->f));
 
 	nc_ctx->e = expt;
 }
 
@@ -88431,15 +89766,15 @@
 	duk_uint32_t t, v;
 
 	DUK_ASSERT(nc_ctx->count == 53 + 1);
 
 	/* Sometimes this assert is not true right now; it will be true after
 	 * rounding.  See: test-bug-numconv-mantissa-assert.js.
 	 */
-	DUK_ASSERT_DISABLE(nc_ctx->digits[0] == 1);  /* zero handled by caller */
+	DUK_ASSERT_DISABLE(nc_ctx->digits[0] == 1); /* zero handled by caller */
 
 	/* Should not be required because the code below always sets both high
 	 * and low parts, but at least gcc-4.4.5 fails to deduce this correctly
 	 * (perhaps because the low part is set (seemingly) conditionally in a
 	 * loop), so this is here to avoid the bogus warning.
 	 */
 	duk_memzero((void *) &u, sizeof(u));
@@ -88476,39 +89811,38 @@
 	 *  exponent.  For instance, k==0 indicates that the leading '1'
 	 *  digit is at the first binary fraction position (0.1xxx...);
 	 *  the corresponding IEEE exponent would be -1.
 	 */
 
 	skip_round = 0;
 
- recheck_exp:
+recheck_exp:
 
-	expt = nc_ctx->k - 1;   /* IEEE exp without bias */
+	expt = nc_ctx->k - 1; /* IEEE exp without bias */
 	if (expt > 1023) {
 		/* Infinity */
-		bitstart = -255;  /* needed for inf: causes mantissa to become zero,
-		                   * and rounding to be skipped.
-		                   */
+		bitstart = -255; /* needed for inf: causes mantissa to become zero,
+		                  * and rounding to be skipped.
+		                  */
 		expt = 2047;
 	} else if (expt >= -1022) {
 		/* normal */
-		bitstart = 1;  /* skip leading digit */
+		bitstart = 1; /* skip leading digit */
 		expt += DUK__IEEE_DOUBLE_EXP_BIAS;
 		DUK_ASSERT(expt >= 1 && expt <= 2046);
 	} else {
 		/* denormal or zero */
-		bitstart = 1023 + expt;  /* expt==-1023 -> bitstart=0 (leading 1);
-		                          * expt==-1024 -> bitstart=-1 (one left of leading 1), etc
-		                          */
+		bitstart = 1023 + expt; /* expt==-1023 -> bitstart=0 (leading 1);
+		                         * expt==-1024 -> bitstart=-1 (one left of leading 1), etc
+		                         */
 		expt = 0;
 	}
 	bitround = bitstart + 52;
 
-	DUK_DDD(DUK_DDDPRINT("ieee expt=%ld, bitstart=%ld, bitround=%ld",
-	                     (long) expt, (long) bitstart, (long) bitround));
+	DUK_DDD(DUK_DDDPRINT("ieee expt=%ld, bitstart=%ld, bitround=%ld", (long) expt, (long) bitstart, (long) bitround));
 
 	if (!skip_round) {
 		if (duk__dragon4_fixed_format_round(nc_ctx, bitround)) {
 			/* Corner case: see test-numconv-parse-mant-carry.js.  We could
 			 * just bump the exponent and update bitstart, but it's more robust
 			 * to recompute (but avoid rounding twice).
 			 */
@@ -88538,21 +89872,19 @@
 			/* low 32 bits is complete */
 			DUK_DBLUNION_SET_LOW32(&u, t);
 			t = 0;
 		}
 	}
 	/* t has high mantissa */
 
-	DUK_DDD(DUK_DDDPRINT("mantissa is complete: %08lx %08lx",
-	                     (unsigned long) t,
-	                     (unsigned long) DUK_DBLUNION_GET_LOW32(&u)));
+	DUK_DDD(DUK_DDDPRINT("mantissa is complete: %08lx %08lx", (unsigned long) t, (unsigned long) DUK_DBLUNION_GET_LOW32(&u)));
 
 	DUK_ASSERT(expt >= 0 && expt <= 0x7ffL);
 	t += ((duk_uint32_t) expt) << 20;
-#if 0  /* caller handles sign change */
+#if 0 /* caller handles sign change */
 	if (negative) {
 		t |= 0x80000000U;
 	}
 #endif
 	DUK_DBLUNION_SET_HIGH32(&u, t);
 
 	DUK_DDD(DUK_DDDPRINT("number is complete: %08lx %08lx",
@@ -88565,20 +89897,23 @@
 /*
  *  Exposed number-to-string API
  *
  *  Input: [ number ]
  *  Output: [ string ]
  */
 
-DUK_LOCAL DUK_NOINLINE void duk__numconv_stringify_raw(duk_hthread *thr, duk_small_int_t radix, duk_small_int_t digits, duk_small_uint_t flags) {
+DUK_LOCAL DUK_NOINLINE void duk__numconv_stringify_raw(duk_hthread *thr,
+                                                       duk_small_int_t radix,
+                                                       duk_small_int_t digits,
+                                                       duk_small_uint_t flags) {
 	duk_double_t x;
 	duk_small_int_t c;
 	duk_small_int_t neg;
 	duk_uint32_t uval;
-	duk__numconv_stringify_ctx nc_ctx_alloc;  /* large context; around 2kB now */
+	duk__numconv_stringify_ctx nc_ctx_alloc; /* large context; around 2kB now */
 	duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;
 
 	x = (duk_double_t) duk_require_number(thr, -1);
 	duk_pop(thr);
 
 	/*
 	 *  Handle special cases (NaN, infinity, zero).
@@ -88622,21 +89957,21 @@
 	 *  is in force.
 	 *
 	 *  XXX: could save space by supporting radix 10 only and using
 	 *  sprintf "%lu" for the fast path and for exponent formatting.
 	 */
 
 	uval = duk_double_to_uint32_t(x);
-	if (duk_double_equals((double) uval, x) &&  /* integer number in range */
-	    flags == 0) {                           /* no special formatting */
+	if (duk_double_equals((double) uval, x) && /* integer number in range */
+	    flags == 0) { /* no special formatting */
 		/* use bigint area as a temp */
 		duk_uint8_t *buf = (duk_uint8_t *) (&nc_ctx->f);
 		duk_uint8_t *p = buf;
 
-		DUK_ASSERT(DUK__NUMCONV_CTX_BIGINTS_SIZE >= 32 + 1);  /* max size: radix=2 + sign */
+		DUK_ASSERT(DUK__NUMCONV_CTX_BIGINTS_SIZE >= 32 + 1); /* max size: radix=2 + sign */
 		if (neg && uval != 0) {
 			/* no negative sign for zero */
 			*p++ = (duk_uint8_t) '-';
 		}
 		p += duk__dragon4_format_uint32(p, uval, radix);
 		duk_push_lstring(thr, (const char *) buf, (duk_size_t) (p - buf));
 		return;
@@ -88684,39 +90019,39 @@
 		/* Zero special case: fake requested number of zero digits; ensure
 		 * no sign bit is printed.  Relative and absolute fixed format
 		 * require separate handling.
 		 */
 		duk_small_int_t count;
 		if (nc_ctx->is_fixed) {
 			if (nc_ctx->abs_pos) {
-				count = digits + 2;  /* lead zero + 'digits' fractions + 1 for rounding */
+				count = digits + 2; /* lead zero + 'digits' fractions + 1 for rounding */
 			} else {
-				count = digits + 1;  /* + 1 for rounding */
+				count = digits + 1; /* + 1 for rounding */
 			}
 		} else {
 			count = 1;
 		}
 		DUK_DDD(DUK_DDDPRINT("count=%ld", (long) count));
 		DUK_ASSERT(count >= 1);
 		duk_memzero((void *) nc_ctx->digits, (size_t) count);
 		nc_ctx->count = count;
-		nc_ctx->k = 1;  /* 0.000... */
+		nc_ctx->k = 1; /* 0.000... */
 		neg = 0;
 		goto zero_skip;
 	}
 
-	duk__dragon4_double_to_ctx(nc_ctx, x);   /* -> sets 'f' and 'e' */
+	duk__dragon4_double_to_ctx(nc_ctx, x); /* -> sets 'f' and 'e' */
 	DUK__BI_PRINT("f", &nc_ctx->f);
 	DUK_DDD(DUK_DDDPRINT("e=%ld", (long) nc_ctx->e));
 
 	/*
 	 *  Dragon4 slow path digit generation.
 	 */
 
-	duk__dragon4_prepare(nc_ctx);  /* setup many variables in nc_ctx */
+	duk__dragon4_prepare(nc_ctx); /* setup many variables in nc_ctx */
 
 	DUK_DDD(DUK_DDDPRINT("after prepare:"));
 	DUK__BI_PRINT("r", &nc_ctx->r);
 	DUK__BI_PRINT("s", &nc_ctx->s);
 	DUK__BI_PRINT("mp", &nc_ctx->mp);
 	DUK__BI_PRINT("mm", &nc_ctx->mm);
 
@@ -88730,30 +90065,33 @@
 
 	duk__dragon4_generate(nc_ctx);
 
 	/*
 	 *  Convert and push final string.
 	 */
 
- zero_skip:
+zero_skip:
 
 	if (flags & DUK_N2S_FLAG_FIXED_FORMAT) {
 		/* Perform fixed-format rounding. */
 		duk_small_int_t roundpos;
 		if (flags & DUK_N2S_FLAG_FRACTION_DIGITS) {
 			/* 'roundpos' is relative to nc_ctx->k and increases to the right
 			 * (opposite of how 'k' changes).
 			 */
-			roundpos = -digits;  /* absolute position for digit considered for rounding */
+			roundpos = -digits; /* absolute position for digit considered for rounding */
 			roundpos = nc_ctx->k - roundpos;
 		} else {
 			roundpos = digits;
 		}
 		DUK_DDD(DUK_DDDPRINT("rounding: k=%ld, count=%ld, digits=%ld, roundpos=%ld",
-		                     (long) nc_ctx->k, (long) nc_ctx->count, (long) digits, (long) roundpos));
+		                     (long) nc_ctx->k,
+		                     (long) nc_ctx->count,
+		                     (long) digits,
+		                     (long) roundpos));
 		(void) duk__dragon4_fixed_format_round(nc_ctx, roundpos);
 
 		/* Note: 'count' is currently not adjusted by rounding (i.e. the
 		 * digits are not "chopped off".  That shouldn't matter because
 		 * the digit position (absolute or relative) is passed on to the
 		 * convert-and-push function.
 		 */
@@ -88774,15 +90112,15 @@
  *  Output: [ number ]
  *
  *  If number parsing fails, a NaN is pushed as the result.  If number parsing
  *  fails due to an internal error, an InternalError is thrown.
  */
 
 DUK_LOCAL DUK_NOINLINE void duk__numconv_parse_raw(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags) {
-	duk__numconv_stringify_ctx nc_ctx_alloc;  /* large context; around 2kB now */
+	duk__numconv_stringify_ctx nc_ctx_alloc; /* large context; around 2kB now */
 	duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;
 	duk_double_t res;
 	duk_hstring *h_str;
 	duk_int_t expt;
 	duk_bool_t expt_neg;
 	duk_small_int_t expt_adj;
 	duk_small_int_t neg;
@@ -88794,15 +90132,16 @@
 	duk_small_int_t dig_prec;
 	const duk__exp_limits *explim;
 	const duk_uint8_t *p;
 	duk_small_int_t ch;
 
 	DUK_DDD(DUK_DDDPRINT("parse number: %!T, radix=%ld, flags=0x%08lx",
 	                     (duk_tval *) duk_get_tval(thr, -1),
-	                     (long) radix, (unsigned long) flags));
+	                     (long) radix,
+	                     (unsigned long) flags));
 
 	DUK_ASSERT(radix >= 2 && radix <= 36);
 	DUK_ASSERT(radix - 2 < (duk_small_int_t) sizeof(duk__str2num_digits_for_radix));
 
 	/*
 	 *  Preliminaries: trim, sign, Infinity check
 	 *
@@ -88867,15 +90206,15 @@
 			res = DUK_DOUBLE_INFINITY;
 			goto negcheck_and_ret;
 		}
 	}
 	ch = *p;
 	if (ch == (duk_small_int_t) '0') {
 		duk_small_int_t detect_radix = 0;
-		ch = DUK_LOWERCASE_CHAR_ASCII(p[1]);  /* 'x' or 'X' -> 'x' */
+		ch = DUK_LOWERCASE_CHAR_ASCII(p[1]); /* 'x' or 'X' -> 'x' */
 		if ((flags & DUK_S2N_FLAG_ALLOW_AUTO_HEX_INT) && ch == DUK_ASC_LC_X) {
 			DUK_DDD(DUK_DDDPRINT("detected 0x/0X hex prefix, changing radix and preventing fractions and exponent"));
 			detect_radix = 16;
 #if 0
 		} else if ((flags & DUK_S2N_FLAG_ALLOW_AUTO_LEGACY_OCT_INT) &&
 		           (ch >= (duk_small_int_t) '0' && ch <= (duk_small_int_t) '9')) {
 			DUK_DDD(DUK_DDDPRINT("detected 0n oct prefix, changing radix and preventing fractions and exponent"));
@@ -88894,18 +90233,17 @@
 		} else if ((flags & DUK_S2N_FLAG_ALLOW_AUTO_BIN_INT) && ch == DUK_ASC_LC_B) {
 			DUK_DDD(DUK_DDDPRINT("detected 0b bin prefix, changing radix and preventing fractions and exponent"));
 			detect_radix = 2;
 		}
 		if (detect_radix > 0) {
 			radix = detect_radix;
 			/* Clear empty as zero flag: interpret e.g. '0x' and '0xg' as a NaN (= parse error) */
-			flags &= ~(DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_EMPTY_FRAC |
-			           DUK_S2N_FLAG_ALLOW_FRAC | DUK_S2N_FLAG_ALLOW_NAKED_FRAC |
-			           DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO);
-			flags |= DUK_S2N_FLAG_ALLOW_LEADING_ZERO;  /* allow e.g. '0x0009' and '0b00010001' */
+			flags &= ~(DUK_S2N_FLAG_ALLOW_EXP | DUK_S2N_FLAG_ALLOW_EMPTY_FRAC | DUK_S2N_FLAG_ALLOW_FRAC |
+			           DUK_S2N_FLAG_ALLOW_NAKED_FRAC | DUK_S2N_FLAG_ALLOW_EMPTY_AS_ZERO);
+			flags |= DUK_S2N_FLAG_ALLOW_LEADING_ZERO; /* allow e.g. '0x0009' and '0b00010001' */
 			p += 2;
 		}
 	}
 
 	/*
 	 *  Scan number and setup for Dragon4.
 	 *
@@ -88955,24 +90293,31 @@
 	duk__bi_set_small(&nc_ctx->f, 0);
 	dig_prec = 0;
 	dig_lzero = 0;
 	dig_whole = 0;
 	dig_frac = -1;
 	dig_expt = -1;
 	expt = 0;
-	expt_adj = 0;  /* essentially tracks digit position of lowest 'f' digit */
+	expt_adj = 0; /* essentially tracks digit position of lowest 'f' digit */
 	expt_neg = 0;
 	for (;;) {
 		ch = *p++;
 
 		DUK_DDD(DUK_DDDPRINT("parse digits: p=%p, ch='%c' (%ld), expt=%ld, expt_adj=%ld, "
 		                     "dig_whole=%ld, dig_frac=%ld, dig_expt=%ld, dig_lzero=%ld, dig_prec=%ld",
-		                     (const void *) p, (int) ((ch >= 0x20 && ch <= 0x7e) ? ch : '?'), (long) ch,
-		                     (long) expt, (long) expt_adj, (long) dig_whole, (long) dig_frac,
-		                     (long) dig_expt, (long) dig_lzero, (long) dig_prec));
+		                     (const void *) p,
+		                     (int) ((ch >= 0x20 && ch <= 0x7e) ? ch : '?'),
+		                     (long) ch,
+		                     (long) expt,
+		                     (long) expt_adj,
+		                     (long) dig_whole,
+		                     (long) dig_frac,
+		                     (long) dig_expt,
+		                     (long) dig_lzero,
+		                     (long) dig_prec));
 		DUK__BI_PRINT("f", &nc_ctx->f);
 
 		/* Most common cases first. */
 		if (ch >= (duk_small_int_t) '0' && ch <= (duk_small_int_t) '9') {
 			dig = (duk_small_int_t) ch - '0' + 0;
 		} else if (ch == (duk_small_int_t) '.') {
 			/* A leading digit is not required in some cases, e.g. accept ".123".
@@ -89003,16 +90348,16 @@
 
 			DUK_DDD(DUK_DDDPRINT("start fraction part"));
 			dig_frac = 0;
 			continue;
 		} else if (ch == (duk_small_int_t) 0) {
 			DUK_DDD(DUK_DDDPRINT("NUL termination"));
 			break;
-		} else if ((flags & DUK_S2N_FLAG_ALLOW_EXP) &&
-		           dig_expt < 0 && (ch == (duk_small_int_t) 'e' || ch == (duk_small_int_t) 'E')) {
+		} else if ((flags & DUK_S2N_FLAG_ALLOW_EXP) && dig_expt < 0 &&
+		           (ch == (duk_small_int_t) 'e' || ch == (duk_small_int_t) 'E')) {
 			/* Note: we don't parse back exponent notation for anything else
 			 * than radix 10, so this is not an ambiguous check (e.g. hex
 			 * exponent values may have 'e' either as a significand digit
 			 * or as an exponent separator).
 			 *
 			 * If the exponent separator occurs twice, 'e' will be interpreted
 			 * as a digit (= 14) and will be rejected as an invalid decimal
@@ -89034,15 +90379,15 @@
 			dig_expt = 0;
 			continue;
 		} else if (ch >= (duk_small_int_t) 'a' && ch <= (duk_small_int_t) 'z') {
 			dig = (duk_small_int_t) (ch - (duk_small_int_t) 'a' + 0x0a);
 		} else if (ch >= (duk_small_int_t) 'A' && ch <= (duk_small_int_t) 'Z') {
 			dig = (duk_small_int_t) (ch - (duk_small_int_t) 'A' + 0x0a);
 		} else {
-			dig = 255;  /* triggers garbage digit check below */
+			dig = 255; /* triggers garbage digit check below */
 		}
 		DUK_ASSERT((dig >= 0 && dig <= 35) || dig == 255);
 
 		if (dig >= radix) {
 			if (flags & DUK_S2N_FLAG_ALLOW_GARBAGE) {
 				DUK_DDD(DUK_DDDPRINT("garbage termination"));
 				break;
@@ -89167,22 +90512,22 @@
 		}
 		DUK_ASSERT(expt == 0);
 	}
 
 	if (expt_neg) {
 		expt = -expt;
 	}
-	DUK_DDD(DUK_DDDPRINT("expt=%ld, expt_adj=%ld, net exponent -> %ld",
-	                     (long) expt, (long) expt_adj, (long) (expt + expt_adj)));
+	DUK_DDD(
+	    DUK_DDDPRINT("expt=%ld, expt_adj=%ld, net exponent -> %ld", (long) expt, (long) expt_adj, (long) (expt + expt_adj)));
 	expt += expt_adj;
 
 	/* Fast path check. */
 
-	if (nc_ctx->f.n <= 1 &&   /* 32-bit value */
-	    expt == 0    /* no net exponent */) {
+	if (nc_ctx->f.n <= 1 && /* 32-bit value */
+	    expt == 0 /* no net exponent */) {
 		/* Fast path is triggered for no exponent and also for balanced exponent
 		 * and fraction parts, e.g. for "1.23e2" == "123".  Remember to respect
 		 * zero sign.
 		 */
 
 		/* XXX: could accept numbers larger than 32 bits, e.g. up to 53 bits? */
 		DUK_DDD(DUK_DDDPRINT("fast path number parse"));
@@ -89216,15 +90561,14 @@
 		 * not balanced (e.g. "0e1").  Remember to respect zero sign.
 		 */
 		DUK_DDD(DUK_DDDPRINT("significand is zero"));
 		res = 0.0;
 		goto negcheck_and_ret;
 	}
 
-
 	/* Quick reject of too large or too small exponents.  This check
 	 * would be incorrect for zero (e.g. "0e1000" is zero, not Infinity)
 	 * so zero check must be above.
 	 */
 
 	explim = &duk__str2num_exp_limits[radix - 2];
 	if (expt > explim->upper) {
@@ -89249,15 +90593,15 @@
 	DUK_DDD(DUK_DDDPRINT("e=%ld", (long) nc_ctx->e));
 
 	/*
 	 *  Dragon4 slow path (binary) digit generation.
 	 *  An extra digit is generated for rounding.
 	 */
 
-	duk__dragon4_prepare(nc_ctx);  /* setup many variables in nc_ctx */
+	duk__dragon4_prepare(nc_ctx); /* setup many variables in nc_ctx */
 
 	DUK_DDD(DUK_DDDPRINT("after prepare:"));
 	DUK__BI_PRINT("r", &nc_ctx->r);
 	DUK__BI_PRINT("s", &nc_ctx->s);
 	DUK__BI_PRINT("mp", &nc_ctx->mp);
 	DUK__BI_PRINT("mm", &nc_ctx->mm);
 
@@ -89281,30 +90625,30 @@
 	 *  non-fastint double.  If this is changed, check all call
 	 *  sites.
 	 */
 
 	duk__dragon4_ctx_to_double(nc_ctx, &res);
 	goto negcheck_and_ret;
 
- negcheck_and_ret:
+negcheck_and_ret:
 	if (neg) {
 		res = -res;
 	}
 	duk_pop(thr);
 	duk_push_number(thr, (double) res);
 	DUK_DDD(DUK_DDDPRINT("result: %!T", (duk_tval *) duk_get_tval(thr, -1)));
 	return;
 
- parse_fail:
+parse_fail:
 	DUK_DDD(DUK_DDDPRINT("parse failed"));
 	duk_pop(thr);
 	duk_push_nan(thr);
 	return;
 
- parse_explimit_error:
+parse_explimit_error:
 	DUK_DDD(DUK_DDDPRINT("parse failed, internal error, can't return a value"));
 	DUK_ERROR_RANGE(thr, "exponent too large");
 	DUK_WO_NORETURN(return;);
 }
 
 DUK_INTERNAL void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags) {
 	duk_native_stack_check(thr);
@@ -89350,16 +90694,15 @@
 
 /*
  *  Helper macros
  */
 
 #define DUK__RE_INITIAL_BUFSIZE 64
 
-#define DUK__RE_BUFLEN(re_ctx) \
-	DUK_BW_GET_SIZE(re_ctx->thr, &re_ctx->bw)
+#define DUK__RE_BUFLEN(re_ctx) DUK_BW_GET_SIZE(re_ctx->thr, &re_ctx->bw)
 
 /*
  *  Disjunction struct: result of parsing a disjunction
  */
 
 typedef struct {
 	/* Number of characters that the atom matches (e.g. 3 for 'abc'),
@@ -89441,29 +90784,32 @@
 }
 
 DUK_LOCAL void duk__append_reop(duk_re_compiler_ctx *re_ctx, duk_uint32_t reop) {
 	DUK_ASSERT(reop <= 0x7fU);
 	(void) duk__append_7bit(re_ctx, reop);
 }
 
-#if 0  /* unused */
+#if 0 /* unused */
 DUK_LOCAL void duk__append_i32(duk_re_compiler_ctx *re_ctx, duk_int32_t x) {
 	duk__append_u32(re_ctx, duk__encode_i32(x));
 }
 #endif
 
 /* special helper for emitting u16 lists (used for character ranges for built-in char classes) */
 DUK_LOCAL void duk__append_u16_list(duk_re_compiler_ctx *re_ctx, const duk_uint16_t *values, duk_uint32_t count) {
 	/* Call sites don't need the result length so it's not accumulated. */
 	while (count-- > 0) {
 		duk__append_u32(re_ctx, (duk_uint32_t) (*values++));
 	}
 }
 
-DUK_LOCAL void duk__insert_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_uint32_t data_offset, duk_uint32_t data_length) {
+DUK_LOCAL void duk__insert_slice(duk_re_compiler_ctx *re_ctx,
+                                 duk_uint32_t offset,
+                                 duk_uint32_t data_offset,
+                                 duk_uint32_t data_length) {
 	DUK_BW_INSERT_ENSURE_SLICE(re_ctx->thr, &re_ctx->bw, offset, data_offset, data_length);
 }
 
 DUK_LOCAL void duk__append_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t data_offset, duk_uint32_t data_length) {
 	DUK_BW_WRITE_ENSURE_SLICE(re_ctx->thr, &re_ctx->bw, data_offset, data_length);
 }
 
@@ -89518,15 +90864,15 @@
 		if (skip < -0x1ffffffL) {
 			skip--;
 		}
 		if (skip < -0x3fffffffL) {
 			skip--;
 		}
 	}
-#else  /* DUK_USE_PREFER_SIZE */
+#else /* DUK_USE_PREFER_SIZE */
 	/* Closed form solution, this produces fastest code.
 	 * See re_neg_jump_offset (closed1).
 	 */
 	if (skip < 0) {
 		if (skip >= -0x3eL) {
 			skip -= 1;
 		} else if (skip >= -0x3fdL) {
@@ -89539,15 +90885,15 @@
 			skip -= 5;
 		} else if (skip >= -0x3ffffff9L) {
 			skip -= 6;
 		} else {
 			skip -= 7;
 		}
 	}
-#endif  /* DUK_USE_PREFER_SIZE */
+#endif /* DUK_USE_PREFER_SIZE */
 
 	return duk__insert_i32(re_ctx, offset, skip);
 }
 
 DUK_LOCAL duk_uint32_t duk__append_jump_offset(duk_re_compiler_ctx *re_ctx, duk_int32_t skip) {
 	return (duk_uint32_t) duk__insert_jump_offset(re_ctx, (duk_uint32_t) DUK__RE_BUFLEN(re_ctx), skip);
 }
@@ -89672,42 +91018,45 @@
 			if (blk > start_blk) {
 				return (duk_codepoint_t) (blk << DUK_CANON_BITMAP_BLKSHIFT);
 			} else {
 				return start;
 			}
 		}
 	}
-	DUK_ASSERT(blk == end_blk + 1);  /* Reached end block which is continuous. */
+	DUK_ASSERT(blk == end_blk + 1); /* Reached end block which is continuous. */
 	return end;
 }
-#else  /* DUK_USE_REGEXP_CANON_BITMAP */
+#else /* DUK_USE_REGEXP_CANON_BITMAP */
 DUK_LOCAL duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
 	DUK_ASSERT(start >= 0);
 	DUK_ASSERT(end >= 0);
 	DUK_ASSERT(end >= start);
 	if (start >= 0x10000) {
 		/* Even without the bitmap, treat non-BMP as continuous. */
 		return end;
 	}
 	return start;
 }
-#endif  /* DUK_USE_REGEXP_CANON_BITMAP */
+#endif /* DUK_USE_REGEXP_CANON_BITMAP */
 
 DUK_LOCAL void duk__regexp_generate_ranges(void *userdata, duk_codepoint_t r1, duk_codepoint_t r2, duk_bool_t direct) {
 	duk_re_compiler_ctx *re_ctx = (duk_re_compiler_ctx *) userdata;
 	duk_codepoint_t r_start;
 	duk_codepoint_t r_end;
 	duk_codepoint_t i;
 	duk_codepoint_t t;
 	duk_codepoint_t r_disc;
 
 	DUK_DD(DUK_DDPRINT("duk__regexp_generate_ranges(): re_ctx=%p, range=[%ld,%ld] direct=%ld",
-	                   (void *) re_ctx, (long) r1, (long) r2, (long) direct));
+	                   (void *) re_ctx,
+	                   (long) r1,
+	                   (long) r2,
+	                   (long) direct));
 
-	DUK_ASSERT(r2 >= r1);  /* SyntaxError for out of order range. */
+	DUK_ASSERT(r2 >= r1); /* SyntaxError for out of order range. */
 
 	if (direct || (re_ctx->re_flags & DUK_RE_FLAG_IGNORE_CASE) == 0) {
 		DUK_DD(DUK_DDPRINT("direct or not case sensitive, emit range: [%ld,%ld]", (long) r1, (long) r2));
 		duk__regexp_emit_range(re_ctx, r1, r2);
 		return;
 	}
 
@@ -89721,31 +91070,31 @@
 		 * current range in r_{start,end} is up-to-date
 		 * (inclusive) and may either break or continue.
 		 */
 		r_disc = duk__re_canon_next_discontinuity(i, r2);
 		DUK_ASSERT(r_disc >= i);
 		DUK_ASSERT(r_disc <= r2);
 
-		r_end += r_disc - i;  /* May be zero. */
+		r_end += r_disc - i; /* May be zero. */
 		t = duk_unicode_re_canonicalize_char(re_ctx->thr, r_disc);
 		if (t == r_end + 1) {
 			/* Not actually a discontinuity, continue range
 			 * to r_disc and recheck.
 			 */
 			r_end = t;
 		} else {
 			duk__regexp_emit_range(re_ctx, r_start, r_end);
 			r_start = t;
 			r_end = t;
 		}
-		i = r_disc + 1;  /* Guarantees progress. */
+		i = r_disc + 1; /* Guarantees progress. */
 	}
 	duk__regexp_emit_range(re_ctx, r_start, r_end);
 
-#if 0  /* Exhaustive search, very slow. */
+#if 0 /* Exhaustive search, very slow. */
 	r_start = duk_unicode_re_canonicalize_char(re_ctx->thr, r1);
 	r_end = r_start;
 	for (i = r1 + 1; i <= r2; i++) {
 		t = duk_unicode_re_canonicalize_char(re_ctx->thr, i);
 		if (t == r_end + 1) {
 			r_end = t;
 		} else {
@@ -89810,44 +91159,43 @@
  *      main for loop collectively for atoms.  Assertions, quantifiers,
  *      and '|' tokens need to taint the result manually if necessary.
  *      Assertions cannot add to result char length, only atoms (and
  *      quantifiers) can; currently quantifiers will taint the result
  *      as complex though.
  */
 
-DUK_LOCAL const duk_uint16_t * const duk__re_range_lookup1[3] = {
-	duk_unicode_re_ranges_digit,
-	duk_unicode_re_ranges_white,
-	duk_unicode_re_ranges_wordchar
-};
-DUK_LOCAL const duk_uint8_t duk__re_range_lookup2[3] = {
-	sizeof(duk_unicode_re_ranges_digit) / (2 * sizeof(duk_uint16_t)),
-	sizeof(duk_unicode_re_ranges_white) / (2 * sizeof(duk_uint16_t)),
-	sizeof(duk_unicode_re_ranges_wordchar) / (2 * sizeof(duk_uint16_t))
-};
-
-DUK_LOCAL void duk__append_range_atom_matcher(duk_re_compiler_ctx *re_ctx, duk_small_uint_t re_op, const duk_uint16_t *ranges, duk_small_uint_t count) {
+DUK_LOCAL const duk_uint16_t * const duk__re_range_lookup1[3] = { duk_unicode_re_ranges_digit,
+	                                                          duk_unicode_re_ranges_white,
+	                                                          duk_unicode_re_ranges_wordchar };
+DUK_LOCAL const duk_uint8_t duk__re_range_lookup2[3] = { sizeof(duk_unicode_re_ranges_digit) / (2 * sizeof(duk_uint16_t)),
+	                                                 sizeof(duk_unicode_re_ranges_white) / (2 * sizeof(duk_uint16_t)),
+	                                                 sizeof(duk_unicode_re_ranges_wordchar) / (2 * sizeof(duk_uint16_t)) };
+
+DUK_LOCAL void duk__append_range_atom_matcher(duk_re_compiler_ctx *re_ctx,
+                                              duk_small_uint_t re_op,
+                                              const duk_uint16_t *ranges,
+                                              duk_small_uint_t count) {
 #if 0
 	DUK_ASSERT(re_op <= 0x7fUL);
 	DUK_ASSERT(count <= 0x7fUL);
 	duk__append_2bytes(re_ctx, (duk_uint8_t) re_op, (duk_uint8_t) count);
 #endif
 	duk__append_reop(re_ctx, re_op);
 	duk__append_7bit(re_ctx, count);
 	duk__append_u16_list(re_ctx, ranges, count * 2);
 }
 
 DUK_LOCAL void duk__parse_disjunction(duk_re_compiler_ctx *re_ctx, duk_bool_t expect_eof, duk__re_disjunction_info *out_atom_info) {
-	duk_int32_t atom_start_offset = -1;                   /* negative -> no atom matched on previous round */
-	duk_int32_t atom_char_length = 0;                     /* negative -> complex atom */
-	duk_uint32_t atom_start_captures = re_ctx->captures;  /* value of re_ctx->captures at start of atom */
+	duk_int32_t atom_start_offset = -1; /* negative -> no atom matched on previous round */
+	duk_int32_t atom_char_length = 0; /* negative -> complex atom */
+	duk_uint32_t atom_start_captures = re_ctx->captures; /* value of re_ctx->captures at start of atom */
 	duk_int32_t unpatched_disjunction_split = -1;
 	duk_int32_t unpatched_disjunction_jump = -1;
 	duk_uint32_t entry_offset = (duk_uint32_t) DUK__RE_BUFLEN(re_ctx);
-	duk_int32_t res_charlen = 0;  /* -1 if disjunction is complex, char length if simple */
+	duk_int32_t res_charlen = 0; /* -1 if disjunction is complex, char length if simple */
 	duk__re_disjunction_info tmp_disj;
 
 	DUK_ASSERT(out_atom_info != NULL);
 
 	duk_native_stack_check(re_ctx->thr);
 	if (re_ctx->recursion_depth >= re_ctx->recursion_limit) {
 		DUK_ERROR_RANGE(re_ctx->thr, DUK_STR_REGEXP_COMPILER_RECURSION_LIMIT);
@@ -89862,27 +91210,27 @@
 	for (;;) {
 		/* atom_char_length, atom_start_offset, atom_start_offset reflect the
 		 * atom matched on the previous loop.  If a quantifier is encountered
 		 * on this loop, these are needed to handle the quantifier correctly.
 		 * new_atom_char_length etc are for the atom parsed on this round;
 		 * they're written to atom_char_length etc at the end of the round.
 		 */
-		duk_int32_t new_atom_char_length;   /* char length of the atom parsed in this loop */
-		duk_int32_t new_atom_start_offset;  /* bytecode start offset of the atom parsed in this loop
-		                                     * (allows quantifiers to copy the atom bytecode)
-		                                     */
-		duk_uint32_t new_atom_start_captures;  /* re_ctx->captures at the start of the atom parsed in this loop */
+		duk_int32_t new_atom_char_length; /* char length of the atom parsed in this loop */
+		duk_int32_t new_atom_start_offset; /* bytecode start offset of the atom parsed in this loop
+		                                    * (allows quantifiers to copy the atom bytecode)
+		                                    */
+		duk_uint32_t new_atom_start_captures; /* re_ctx->captures at the start of the atom parsed in this loop */
 
 		duk_lexer_parse_re_token(&re_ctx->lex, &re_ctx->curr_token);
 
-		DUK_DD(DUK_DDPRINT("re token: %ld (num=%ld, char=%c)",
-		                   (long) re_ctx->curr_token.t,
-		                   (long) re_ctx->curr_token.num,
-		                   (re_ctx->curr_token.num >= 0x20 && re_ctx->curr_token.num <= 0x7e) ?
-		                   (int) re_ctx->curr_token.num : (int) '?'));
+		DUK_DD(DUK_DDPRINT(
+		    "re token: %ld (num=%ld, char=%c)",
+		    (long) re_ctx->curr_token.t,
+		    (long) re_ctx->curr_token.num,
+		    (re_ctx->curr_token.num >= 0x20 && re_ctx->curr_token.num <= 0x7e) ? (int) re_ctx->curr_token.num : (int) '?'));
 
 		/* set by atom case clauses */
 		new_atom_start_offset = -1;
 		new_atom_char_length = -1;
 		new_atom_start_captures = re_ctx->captures;
 
 		switch (re_ctx->curr_token.t) {
@@ -89895,28 +91243,24 @@
 
 			/* patch pending jump and split */
 			if (unpatched_disjunction_jump >= 0) {
 				duk_uint32_t offset;
 
 				DUK_ASSERT(unpatched_disjunction_split >= 0);
 				offset = (duk_uint32_t) unpatched_disjunction_jump;
-				offset += duk__insert_jump_offset(re_ctx,
-				                                  offset,
-				                                  (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - offset));
+				offset += duk__insert_jump_offset(re_ctx, offset, (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - offset));
 				/* offset is now target of the pending split (right after jump) */
 				duk__insert_jump_offset(re_ctx,
 				                        (duk_uint32_t) unpatched_disjunction_split,
 				                        (duk_int32_t) offset - unpatched_disjunction_split);
 			}
 
 			/* add a new pending split to the beginning of the entire disjunction */
-			(void) duk__insert_u32(re_ctx,
-			                       entry_offset,
-			                       DUK_REOP_SPLIT1);   /* prefer direct execution */
-			unpatched_disjunction_split = (duk_int32_t) (entry_offset + 1);   /* +1 for opcode */
+			(void) duk__insert_u32(re_ctx, entry_offset, DUK_REOP_SPLIT1); /* prefer direct execution */
+			unpatched_disjunction_split = (duk_int32_t) (entry_offset + 1); /* +1 for opcode */
 
 			/* add a new pending match jump for latest finished alternative */
 			duk__append_reop(re_ctx, DUK_REOP_JUMP);
 			unpatched_disjunction_jump = (duk_int32_t) DUK__RE_BUFLEN(re_ctx);
 
 			/* 'taint' result as complex */
 			res_charlen = -1;
@@ -89956,15 +91300,15 @@
 						qmin = 1;
 					}
 					if (qmax > 1) {
 						qmax = 1;
 					}
 				}
 
-				duk__append_reop(re_ctx, DUK_REOP_MATCH);   /* complete 'sub atom' */
+				duk__append_reop(re_ctx, DUK_REOP_MATCH); /* complete 'sub atom' */
 				atom_code_length = (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - (duk_size_t) atom_start_offset);
 
 				offset = (duk_uint32_t) atom_start_offset;
 				if (re_ctx->curr_token.greedy) {
 					offset += duk__insert_u32(re_ctx, offset, DUK_REOP_SQGREEDY);
 					offset += duk__insert_u32(re_ctx, offset, qmin);
 					offset += duk__insert_u32(re_ctx, offset, qmax);
@@ -89972,15 +91316,15 @@
 					offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
 				} else {
 					offset += duk__insert_u32(re_ctx, offset, DUK_REOP_SQMINIMAL);
 					offset += duk__insert_u32(re_ctx, offset, qmin);
 					offset += duk__insert_u32(re_ctx, offset, qmax);
 					offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
 				}
-				DUK_UNREF(offset);  /* silence scan-build warning */
+				DUK_UNREF(offset); /* silence scan-build warning */
 			} else {
 				/*
 				 *  Complex atom
 				 *
 				 *  The original code is used as a template, and removed at the end
 				 *  (this differs from the handling of simple quantifiers).
 				 *
@@ -89990,44 +91334,50 @@
 				 *  XXX: impose limit on maximum result size, i.e. atom_code_len * atom_copies?
 				 */
 				duk_int32_t atom_code_length;
 				duk_uint32_t atom_copies;
 				duk_uint32_t tmp_qmin, tmp_qmax;
 
 				/* pre-check how many atom copies we're willing to make (atom_copies not needed below) */
-				atom_copies = (re_ctx->curr_token.qmax == DUK_RE_QUANTIFIER_INFINITE) ?
-				              re_ctx->curr_token.qmin : re_ctx->curr_token.qmax;
+				atom_copies = (re_ctx->curr_token.qmax == DUK_RE_QUANTIFIER_INFINITE) ? re_ctx->curr_token.qmin :
+                                                                                                        re_ctx->curr_token.qmax;
 				if (atom_copies > DUK_RE_MAX_ATOM_COPIES) {
 					DUK_ERROR_RANGE(re_ctx->thr, DUK_STR_QUANTIFIER_TOO_MANY_COPIES);
 					DUK_WO_NORETURN(return;);
 				}
 
 				/* wipe the capture range made by the atom (if any) */
 				DUK_ASSERT(atom_start_captures <= re_ctx->captures);
 				if (atom_start_captures != re_ctx->captures) {
 					DUK_ASSERT(atom_start_captures < re_ctx->captures);
 					DUK_DDD(DUK_DDDPRINT("must wipe ]atom_start_captures,re_ctx->captures]: ]%ld,%ld]",
-					                     (long) atom_start_captures, (long) re_ctx->captures));
+					                     (long) atom_start_captures,
+					                     (long) re_ctx->captures));
 
 					/* insert (DUK_REOP_WIPERANGE, start, count) in reverse order so the order ends up right */
-					duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, (re_ctx->captures - atom_start_captures) * 2U);
+					duk__insert_u32(re_ctx,
+					                (duk_uint32_t) atom_start_offset,
+					                (re_ctx->captures - atom_start_captures) * 2U);
 					duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, (atom_start_captures + 1) * 2);
 					duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, DUK_REOP_WIPERANGE);
 				} else {
-					DUK_DDD(DUK_DDDPRINT("no need to wipe captures: atom_start_captures == re_ctx->captures == %ld",
-					                     (long) atom_start_captures));
+					DUK_DDD(
+					    DUK_DDDPRINT("no need to wipe captures: atom_start_captures == re_ctx->captures == %ld",
+					                 (long) atom_start_captures));
 				}
 
 				atom_code_length = (duk_int32_t) DUK__RE_BUFLEN(re_ctx) - atom_start_offset;
 
 				/* insert the required matches (qmin) by copying the atom */
 				tmp_qmin = re_ctx->curr_token.qmin;
 				tmp_qmax = re_ctx->curr_token.qmax;
 				while (tmp_qmin > 0) {
-					duk__append_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
+					duk__append_slice(re_ctx,
+					                  (duk_uint32_t) atom_start_offset,
+					                  (duk_uint32_t) atom_code_length);
 					tmp_qmin--;
 					if (tmp_qmax != DUK_RE_QUANTIFIER_INFINITE) {
 						tmp_qmax--;
 					}
 				}
 				DUK_ASSERT(tmp_qmin == 0);
 
@@ -90037,22 +91387,24 @@
 
 					if (re_ctx->curr_token.qmin == 0) {
 						/* Special case: original qmin was zero so there is nothing
 						 * to repeat.  Emit an atom copy but jump over it here.
 						 */
 						duk__append_reop(re_ctx, DUK_REOP_JUMP);
 						duk__append_jump_offset(re_ctx, atom_code_length);
-						duk__append_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
+						duk__append_slice(re_ctx,
+						                  (duk_uint32_t) atom_start_offset,
+						                  (duk_uint32_t) atom_code_length);
 					}
 					if (re_ctx->curr_token.greedy) {
-						duk__append_reop(re_ctx, DUK_REOP_SPLIT2);   /* prefer jump */
+						duk__append_reop(re_ctx, DUK_REOP_SPLIT2); /* prefer jump */
 					} else {
-						duk__append_reop(re_ctx, DUK_REOP_SPLIT1);   /* prefer direct */
+						duk__append_reop(re_ctx, DUK_REOP_SPLIT1); /* prefer direct */
 					}
-					duk__append_jump_offset(re_ctx, -atom_code_length - 1);  /* -1 for opcode */
+					duk__append_jump_offset(re_ctx, -atom_code_length - 1); /* -1 for opcode */
 				} else {
 					/*
 					 *  The remaining matches are emitted as sequence of SPLITs and atom
 					 *  copies; the SPLITs skip the remaining copies and match the sequel.
 					 *  This sequence needs to be emitted starting from the last copy
 					 *  because the SPLITs are variable length due to the variable length
 					 *  skip offset.  This causes a lot of memory copying now.
@@ -90064,22 +91416,25 @@
 					 *      SPLIT1 LSEQ    ; <- the byte length of this instruction is needed
 					 *      (atom)         ; to encode the above SPLIT1 correctly
 					 *      ...
 					 *   LSEQ:
 					 */
 					duk_uint32_t offset = (duk_uint32_t) DUK__RE_BUFLEN(re_ctx);
 					while (tmp_qmax > 0) {
-						duk__insert_slice(re_ctx, offset, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
+						duk__insert_slice(re_ctx,
+						                  offset,
+						                  (duk_uint32_t) atom_start_offset,
+						                  (duk_uint32_t) atom_code_length);
 						if (re_ctx->curr_token.greedy) {
-							duk__insert_u32(re_ctx, offset, DUK_REOP_SPLIT1);   /* prefer direct */
+							duk__insert_u32(re_ctx, offset, DUK_REOP_SPLIT1); /* prefer direct */
 						} else {
-							duk__insert_u32(re_ctx, offset, DUK_REOP_SPLIT2);   /* prefer jump */
+							duk__insert_u32(re_ctx, offset, DUK_REOP_SPLIT2); /* prefer jump */
 						}
 						duk__insert_jump_offset(re_ctx,
-						                        offset + 1,   /* +1 for opcode */
+						                        offset + 1, /* +1 for opcode */
 						                        (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - (offset + 1)));
 						tmp_qmax--;
 					}
 				}
 
 				/* remove the original 'template' atom */
 				duk__remove_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
@@ -90104,24 +91459,24 @@
 		case DUK_RETOK_ASSERT_NOT_WORD_BOUNDARY: {
 			duk__append_reop(re_ctx, DUK_REOP_ASSERT_NOT_WORD_BOUNDARY);
 			break;
 		}
 		case DUK_RETOK_ASSERT_START_POS_LOOKAHEAD:
 		case DUK_RETOK_ASSERT_START_NEG_LOOKAHEAD: {
 			duk_uint32_t offset;
-			duk_uint32_t opcode = (re_ctx->curr_token.t == DUK_RETOK_ASSERT_START_POS_LOOKAHEAD) ?
-			                      DUK_REOP_LOOKPOS : DUK_REOP_LOOKNEG;
+			duk_uint32_t opcode =
+			    (re_ctx->curr_token.t == DUK_RETOK_ASSERT_START_POS_LOOKAHEAD) ? DUK_REOP_LOOKPOS : DUK_REOP_LOOKNEG;
 
 			offset = (duk_uint32_t) DUK__RE_BUFLEN(re_ctx);
 			duk__parse_disjunction(re_ctx, 0, &tmp_disj);
 			duk__append_reop(re_ctx, DUK_REOP_MATCH);
 
 			(void) duk__insert_u32(re_ctx, offset, opcode);
 			(void) duk__insert_jump_offset(re_ctx,
-			                               offset + 1,   /* +1 for opcode */
+			                               offset + 1, /* +1 for opcode */
 			                               (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - (offset + 1)));
 
 			/* 'taint' result as complex -- this is conservative,
 			 * as lookaheads do not backtrack.
 			 */
 			res_charlen = -1;
 			break;
@@ -90174,39 +91529,41 @@
 			DUK_ASSERT((DUK_RETOK_ATOM_NOT_WHITE & 0x01) == 0);
 			DUK_ASSERT((DUK_RETOK_ATOM_NOT_WORD_CHAR & 0x01) == 0);
 			re_op = (re_ctx->curr_token.t & 0x01) ? DUK_REOP_RANGES : DUK_REOP_INVRANGES;
 
 			DUK_ASSERT(DUK_RETOK_ATOM_WHITE == DUK_RETOK_ATOM_DIGIT + 2);
 			DUK_ASSERT(DUK_RETOK_ATOM_WORD_CHAR == DUK_RETOK_ATOM_DIGIT + 4);
 			idx = (duk_small_uint_t) ((re_ctx->curr_token.t - DUK_RETOK_ATOM_DIGIT) >> 1U);
-			DUK_ASSERT(idx <= 2U);  /* Assume continuous token numbers; also checks negative underflow. */
+			DUK_ASSERT(idx <= 2U); /* Assume continuous token numbers; also checks negative underflow. */
 
 			duk__append_range_atom_matcher(re_ctx, re_op, duk__re_range_lookup1[idx], duk__re_range_lookup2[idx]);
 			break;
 		}
 		case DUK_RETOK_ATOM_BACKREFERENCE: {
 			duk_uint32_t backref = (duk_uint32_t) re_ctx->curr_token.num;
 			if (backref > re_ctx->highest_backref) {
 				re_ctx->highest_backref = backref;
 			}
-			new_atom_char_length = -1;   /* mark as complex */
+			new_atom_char_length = -1; /* mark as complex */
 			new_atom_start_offset = (duk_int32_t) DUK__RE_BUFLEN(re_ctx);
 			duk__append_reop(re_ctx, DUK_REOP_BACKREFERENCE);
 			duk__append_u32(re_ctx, backref);
 			break;
 		}
 		case DUK_RETOK_ATOM_START_CAPTURE_GROUP: {
 			duk_uint32_t cap;
 
-			new_atom_char_length = -1;   /* mark as complex (capture handling) */
+			new_atom_char_length = -1; /* mark as complex (capture handling) */
 			new_atom_start_offset = (duk_int32_t) DUK__RE_BUFLEN(re_ctx);
 			cap = ++re_ctx->captures;
 			duk__append_reop(re_ctx, DUK_REOP_SAVE);
 			duk__append_u32(re_ctx, cap * 2);
-			duk__parse_disjunction(re_ctx, 0, &tmp_disj);  /* retval (sub-atom char length) unused, tainted as complex above */
+			duk__parse_disjunction(re_ctx,
+			                       0,
+			                       &tmp_disj); /* retval (sub-atom char length) unused, tainted as complex above */
 			duk__append_reop(re_ctx, DUK_REOP_SAVE);
 			duk__append_u32(re_ctx, cap * 2 + 1);
 			break;
 		}
 		case DUK_RETOK_ATOM_START_NONCAPTURE_GROUP: {
 			new_atom_start_offset = (duk_int32_t) DUK__RE_BUFLEN(re_ctx);
 			duk__parse_disjunction(re_ctx, 0, &tmp_disj);
@@ -90243,20 +91600,20 @@
 
 			DUK_DD(DUK_DDPRINT("character class"));
 
 			/* insert ranges instruction, range count patched in later */
 			new_atom_char_length = 1;
 			new_atom_start_offset = (duk_int32_t) DUK__RE_BUFLEN(re_ctx);
 			duk__append_reop(re_ctx,
-			                 (re_ctx->curr_token.t == DUK_RETOK_ATOM_START_CHARCLASS) ?
-			                 DUK_REOP_RANGES : DUK_REOP_INVRANGES);
-			offset = (duk_uint32_t) DUK__RE_BUFLEN(re_ctx);    /* patch in range count later */
+			                 (re_ctx->curr_token.t == DUK_RETOK_ATOM_START_CHARCLASS) ? DUK_REOP_RANGES :
+                                                                                                    DUK_REOP_INVRANGES);
+			offset = (duk_uint32_t) DUK__RE_BUFLEN(re_ctx); /* patch in range count later */
 
 			/* parse ranges until character class ends */
-			re_ctx->nranges = 0;    /* note: ctx-wide temporary */
+			re_ctx->nranges = 0; /* note: ctx-wide temporary */
 			duk_lexer_parse_re_ranges(&re_ctx->lex, duk__regexp_generate_ranges, (void *) re_ctx);
 
 			/* insert range count */
 			duk__insert_u32(re_ctx, offset, re_ctx->nranges);
 			break;
 		}
 		case DUK_RETOK_ATOM_END_GROUP: {
@@ -90291,37 +91648,34 @@
 
 		/* record previous atom info in case next token is a quantifier */
 		atom_start_offset = new_atom_start_offset;
 		atom_char_length = new_atom_char_length;
 		atom_start_captures = new_atom_start_captures;
 	}
 
- done:
+done:
 
 	/* finish up pending jump and split for last alternative */
 	if (unpatched_disjunction_jump >= 0) {
 		duk_uint32_t offset;
 
 		DUK_ASSERT(unpatched_disjunction_split >= 0);
 		offset = (duk_uint32_t) unpatched_disjunction_jump;
-		offset += duk__insert_jump_offset(re_ctx,
-		                                  offset,
-		                                  (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - offset));
+		offset += duk__insert_jump_offset(re_ctx, offset, (duk_int32_t) (DUK__RE_BUFLEN(re_ctx) - offset));
 		/* offset is now target of the pending split (right after jump) */
 		duk__insert_jump_offset(re_ctx,
 		                        (duk_uint32_t) unpatched_disjunction_split,
 		                        (duk_int32_t) offset - unpatched_disjunction_split);
 	}
 
 #if 0
 	out_atom_info->end_captures = re_ctx->captures;
 #endif
 	out_atom_info->charlen = res_charlen;
-	DUK_DDD(DUK_DDDPRINT("parse disjunction finished: charlen=%ld",
-	                     (long) out_atom_info->charlen));
+	DUK_DDD(DUK_DDDPRINT("parse disjunction finished: charlen=%ld", (long) out_atom_info->charlen));
 
 	re_ctx->recursion_depth--;
 }
 
 /*
  *  Flags parsing (see E5 Section 15.10.4.1).
  */
@@ -90364,15 +91718,15 @@
 			goto flags_error;
 		}
 		}
 	}
 
 	return flags;
 
- flags_error:
+flags_error:
 	DUK_ERROR_SYNTAX(thr, DUK_STR_INVALID_REGEXP_FLAGS);
 	DUK_WO_NORETURN(return 0U;);
 }
 
 /*
  *  Create escaped RegExp source (E5 Section 15.10.3).
  *
@@ -90430,15 +91784,15 @@
 		}
 		*q++ = (duk_uint8_t) c;
 
 		c_prev = c;
 	}
 
 	DUK_BW_SETPTR_AND_COMPACT(thr, bw, q);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe if input is safe. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe if input is safe. */
 
 	/* [ ... escaped_source ] */
 }
 
 /*
  *  Exposed regexp compilation primitive.
  *
@@ -90484,33 +91838,34 @@
 	/*
 	 *  Init compilation context
 	 */
 
 	/* [ ... pattern flags escaped_source buffer ] */
 
 	duk_memzero(&re_ctx, sizeof(re_ctx));
-	DUK_LEXER_INITCTX(&re_ctx.lex);  /* duplicate zeroing, expect for (possible) NULL inits */
+	DUK_LEXER_INITCTX(&re_ctx.lex); /* duplicate zeroing, expect for (possible) NULL inits */
 	re_ctx.thr = thr;
 	re_ctx.lex.thr = thr;
 	re_ctx.lex.input = DUK_HSTRING_GET_DATA(h_pattern);
 	re_ctx.lex.input_length = DUK_HSTRING_GET_BYTELEN(h_pattern);
 	re_ctx.lex.token_limit = DUK_RE_COMPILE_TOKEN_LIMIT;
 	re_ctx.recursion_limit = DUK_USE_REGEXP_COMPILER_RECLIMIT;
 	re_ctx.re_flags = duk__parse_regexp_flags(thr, h_flags);
 
 	DUK_BW_INIT_PUSHBUF(thr, &re_ctx.bw, DUK__RE_INITIAL_BUFSIZE);
 
 	DUK_DD(DUK_DDPRINT("regexp compiler ctx initialized, flags=0x%08lx, recursion_limit=%ld",
-	                   (unsigned long) re_ctx.re_flags, (long) re_ctx.recursion_limit));
+	                   (unsigned long) re_ctx.re_flags,
+	                   (long) re_ctx.recursion_limit));
 
 	/*
 	 *  Init lexer
 	 */
 
-	lex_point.offset = 0;  /* expensive init, just want to fill window */
+	lex_point.offset = 0; /* expensive init, just want to fill window */
 	lex_point.line = 1;
 	DUK_LEXER_SETPOINT(&re_ctx.lex, &lex_point);
 
 	/*
 	 *  Compilation
 	 */
 
@@ -90544,27 +91899,28 @@
 
 	duk__insert_u32(&re_ctx, 0, (re_ctx.captures + 1) * 2);
 	duk__insert_u32(&re_ctx, 0, re_ctx.re_flags);
 
 	/* [ ... pattern flags escaped_source buffer ] */
 
 	DUK_BW_COMPACT(thr, &re_ctx.bw);
-	(void) duk_buffer_to_string(thr, -1);  /* Safe because flags is at most 7 bit. */
+	(void) duk_buffer_to_string(thr, -1); /* Safe because flags is at most 7 bit. */
 
 	/* [ ... pattern flags escaped_source bytecode ] */
 
 	/*
 	 *  Finalize stack
 	 */
 
-	duk_remove(thr, -4);     /* -> [ ... flags escaped_source bytecode ] */
-	duk_remove(thr, -3);     /* -> [ ... escaped_source bytecode ] */
+	duk_remove(thr, -4); /* -> [ ... flags escaped_source bytecode ] */
+	duk_remove(thr, -3); /* -> [ ... escaped_source bytecode ] */
 
 	DUK_DD(DUK_DDPRINT("regexp compilation successful, bytecode: %!T, escaped source: %!T",
-	                   (duk_tval *) duk_get_tval(thr, -1), (duk_tval *) duk_get_tval(thr, -2)));
+	                   (duk_tval *) duk_get_tval(thr, -1),
+	                   (duk_tval *) duk_get_tval(thr, -2)));
 }
 
 /*
  *  Create a RegExp instance (E5 Section 15.10.7).
  *
  *  Note: the output stack left by duk_regexp_compile() is directly compatible
  *  with the input here.
@@ -90602,19 +91958,19 @@
 
 	duk_push_int(thr, 0);
 	duk_xdef_prop_stridx_short(thr, -2, DUK_STRIDX_LAST_INDEX, DUK_PROPDESC_FLAGS_W);
 
 	/* [ ... regexp_object ] */
 }
 
-#else  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
 
 /* regexp support disabled */
 
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 
 /* automatic undefs */
 #undef DUK__RE_BUFLEN
 #undef DUK__RE_INITIAL_BUFSIZE
 #line 1 "duk_regexp_executor.c"
 /*
  *  Regexp executor.
@@ -90655,15 +92011,19 @@
 	if (t & 1) {
 		return -((duk_int32_t) (t >> 1));
 	} else {
 		return (duk_int32_t) (t >> 1);
 	}
 }
 
-DUK_LOCAL const duk_uint8_t *duk__utf8_backtrack(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_uint_fast32_t count) {
+DUK_LOCAL const duk_uint8_t *duk__utf8_backtrack(duk_hthread *thr,
+                                                 const duk_uint8_t **ptr,
+                                                 const duk_uint8_t *ptr_start,
+                                                 const duk_uint8_t *ptr_end,
+                                                 duk_uint_fast32_t count) {
 	const duk_uint8_t *p;
 
 	/* Note: allow backtracking from p == ptr_end */
 	p = *ptr;
 	if (p < ptr_start || p > ptr_end) {
 		goto fail;
 	}
@@ -90680,20 +92040,24 @@
 			}
 		}
 		count--;
 	}
 	*ptr = p;
 	return p;
 
- fail:
+fail:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 
-DUK_LOCAL const duk_uint8_t *duk__utf8_advance(duk_hthread *thr, const duk_uint8_t **ptr, const duk_uint8_t *ptr_start, const duk_uint8_t *ptr_end, duk_uint_fast32_t count) {
+DUK_LOCAL const duk_uint8_t *duk__utf8_advance(duk_hthread *thr,
+                                               const duk_uint8_t **ptr,
+                                               const duk_uint8_t *ptr_start,
+                                               const duk_uint8_t *ptr_end,
+                                               duk_uint_fast32_t count) {
 	const duk_uint8_t *p;
 
 	p = *ptr;
 	if (p < ptr_start || p >= ptr_end) {
 		goto fail;
 	}
 
@@ -90711,15 +92075,15 @@
 		}
 		count--;
 	}
 
 	*ptr = p;
 	return p;
 
- fail:
+fail:
 	DUK_ERROR_INTERNAL(thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 /*
  *  Helpers for dealing with the input string
  */
@@ -90815,15 +92179,15 @@
 			 *  regexp compiler has trouble joining strings efficiently
 			 *  during compilation.  See doc/regexp.rst for more discussion.
 			 */
 			duk_codepoint_t c1, c2;
 
 			c1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
 			DUK_ASSERT(!(re_ctx->re_flags & DUK_RE_FLAG_IGNORE_CASE) ||
-			           c1 == duk_unicode_re_canonicalize_char(re_ctx->thr, c1));  /* canonicalized by compiler */
+			           c1 == duk_unicode_re_canonicalize_char(re_ctx->thr, c1)); /* canonicalized by compiler */
 			c2 = duk__inp_get_cp(re_ctx, &sp);
 			/* No need to check for c2 < 0 (end of input): because c1 >= 0, it
 			 * will fail the match below automatically and cause goto fail.
 			 */
 #if 0
 			if (c2 < 0) {
 				goto fail;
@@ -90861,15 +92225,18 @@
 
 			match = 0;
 			while (n) {
 				duk_codepoint_t r1, r2;
 				r1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
 				r2 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
 				DUK_DDD(DUK_DDDPRINT("matching ranges/invranges, n=%ld, r1=%ld, r2=%ld, c=%ld",
-				                     (long) n, (long) r1, (long) r2, (long) c));
+				                     (long) n,
+				                     (long) r1,
+				                     (long) r2,
+				                     (long) c));
 				if (c >= r1 && c <= r2) {
 					/* Note: don't bail out early, we must read all the ranges from
 					 * bytecode.  Another option is to skip them efficiently after
 					 * breaking out of here.  Prefer smallest code.
 					 */
 					match = 1;
 				}
@@ -90930,24 +92297,24 @@
 			 *  canonicalization does not affect the result of IsWordChar()
 			 *  (which depends on Unicode characters never canonicalizing
 			 *  into ASCII characters) so this does not matter.
 			 */
 			duk_small_int_t w1, w2;
 
 			if (sp <= re_ctx->input) {
-				w1 = 0;  /* not a wordchar */
+				w1 = 0; /* not a wordchar */
 			} else {
 				duk_codepoint_t c;
 				c = duk__inp_get_prev_cp(re_ctx, sp);
 				w1 = duk_unicode_re_is_wordchar(c);
 			}
 			if (sp >= re_ctx->input_end) {
-				w2 = 0;  /* not a wordchar */
+				w2 = 0; /* not a wordchar */
 			} else {
-				const duk_uint8_t *tmp_sp = sp;  /* dummy so sp won't get updated */
+				const duk_uint8_t *tmp_sp = sp; /* dummy so sp won't get updated */
 				duk_codepoint_t c;
 				c = duk__inp_get_cp(re_ctx, &tmp_sp);
 				w2 = duk_unicode_re_is_wordchar(c);
 			}
 
 			if (op == DUK_REOP_ASSERT_WORD_BOUNDARY) {
 				if (w1 == w2) {
@@ -91000,15 +92367,17 @@
 			duk_int32_t skip;
 			const duk_uint8_t *sub_sp;
 
 			qmin = duk__bc_get_u32(re_ctx, &pc);
 			qmax = duk__bc_get_u32(re_ctx, &pc);
 			skip = duk__bc_get_i32(re_ctx, &pc);
 			DUK_DDD(DUK_DDDPRINT("minimal quantifier, qmin=%lu, qmax=%lu, skip=%ld",
-			                     (unsigned long) qmin, (unsigned long) qmax, (long) skip));
+			                     (unsigned long) qmin,
+			                     (unsigned long) qmax,
+			                     (long) skip));
 
 			q = 0;
 			while (q <= qmax) {
 				if (q >= qmin) {
 					sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
 					if (sub_sp) {
 						sp = sub_sp;
@@ -91030,15 +92399,18 @@
 			const duk_uint8_t *sub_sp;
 
 			qmin = duk__bc_get_u32(re_ctx, &pc);
 			qmax = duk__bc_get_u32(re_ctx, &pc);
 			atomlen = duk__bc_get_u32(re_ctx, &pc);
 			skip = duk__bc_get_i32(re_ctx, &pc);
 			DUK_DDD(DUK_DDDPRINT("greedy quantifier, qmin=%lu, qmax=%lu, atomlen=%lu, skip=%ld",
-			                     (unsigned long) qmin, (unsigned long) qmax, (unsigned long) atomlen, (long) skip));
+			                     (unsigned long) qmin,
+			                     (unsigned long) qmax,
+			                     (unsigned long) atomlen,
+			                     (long) skip));
 
 			q = 0;
 			while (q < qmax) {
 				sub_sp = duk__match_regexp(re_ctx, pc, sp);
 				if (!sub_sp) {
 					break;
 				}
@@ -91056,16 +92428,15 @@
 				}
 
 				/* Note: if atom were to contain e.g. captures, we would need to
 				 * re-match the atom to get correct captures.  Simply quantifiers
 				 * do not allow captures in their atom now, so this is not an issue.
 				 */
 
-				DUK_DDD(DUK_DDDPRINT("greedy quantifier, backtrack %ld characters (atomlen)",
-				                     (long) atomlen));
+				DUK_DDD(DUK_DDDPRINT("greedy quantifier, backtrack %ld characters (atomlen)", (long) atomlen));
 				sp = duk__inp_backtrack(re_ctx, &sp, (duk_uint_fast32_t) atomlen);
 				q--;
 			}
 			goto fail;
 		}
 		case DUK_REOP_SAVE: {
 			duk_uint32_t idx;
@@ -91103,28 +92474,31 @@
 #endif
 			duk_uint8_t **range_save;
 			const duk_uint8_t *sub_sp;
 
 			idx_start = duk__bc_get_u32(re_ctx, &pc);
 			idx_count = duk__bc_get_u32(re_ctx, &pc);
 			DUK_DDD(DUK_DDDPRINT("wipe saved range: start=%ld, count=%ld -> [%ld,%ld] (captures [%ld,%ld])",
-			                     (long) idx_start, (long) idx_count,
-			                     (long) idx_start, (long) (idx_start + idx_count - 1),
-			                     (long) (idx_start / 2), (long) ((idx_start + idx_count - 1) / 2)));
+			                     (long) idx_start,
+			                     (long) idx_count,
+			                     (long) idx_start,
+			                     (long) (idx_start + idx_count - 1),
+			                     (long) (idx_start / 2),
+			                     (long) ((idx_start + idx_count - 1) / 2)));
 			if (idx_start + idx_count > re_ctx->nsaved || idx_count == 0) {
 				/* idx is unsigned, < 0 check is not necessary */
 				DUK_D(DUK_DPRINT("internal error, regexp wipe indices insane: idx_start=%ld, idx_count=%ld",
-				                 (long) idx_start, (long) idx_count));
+				                 (long) idx_start,
+				                 (long) idx_count));
 				goto internal_error;
 			}
 			DUK_ASSERT(idx_count > 0);
 
 			duk_require_stack(re_ctx->thr, 1);
-			range_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr,
-			                                                           sizeof(duk_uint8_t *) * idx_count);
+			range_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr, sizeof(duk_uint8_t *) * idx_count);
 			DUK_ASSERT(range_save != NULL);
 			duk_memcpy(range_save, re_ctx->saved + idx_start, sizeof(duk_uint8_t *) * idx_count);
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
 			idx_end = idx_start + idx_count;
 			for (idx = idx_start; idx < idx_end; idx++) {
 				re_ctx->saved[idx] = NULL;
 			}
@@ -91132,25 +92506,29 @@
 			duk_memzero((void *) (re_ctx->saved + idx_start), sizeof(duk_uint8_t *) * idx_count);
 #endif
 
 			sub_sp = duk__match_regexp(re_ctx, pc, sp);
 			if (sub_sp) {
 				/* match: keep wiped/resaved values */
 				DUK_DDD(DUK_DDDPRINT("match: keep wiped/resaved values [%ld,%ld] (captures [%ld,%ld])",
-				                     (long) idx_start, (long) (idx_start + idx_count - 1),
-			                             (long) (idx_start / 2), (long) ((idx_start + idx_count - 1) / 2)));
+				                     (long) idx_start,
+				                     (long) (idx_start + idx_count - 1),
+				                     (long) (idx_start / 2),
+				                     (long) ((idx_start + idx_count - 1) / 2)));
 				duk_pop_unsafe(re_ctx->thr);
 				sp = sub_sp;
 				goto match;
 			}
 
 			/* fail: restore saves */
 			DUK_DDD(DUK_DDDPRINT("fail: restore wiped/resaved values [%ld,%ld] (captures [%ld,%ld])",
-			                     (long) idx_start, (long) (idx_start + idx_count - 1),
-			                     (long) (idx_start / 2), (long) ((idx_start + idx_count - 1) / 2)));
+			                     (long) idx_start,
+			                     (long) (idx_start + idx_count - 1),
+			                     (long) (idx_start / 2),
+			                     (long) ((idx_start + idx_count - 1) / 2)));
 			duk_memcpy((void *) (re_ctx->saved + idx_start),
 			           (const void *) range_save,
 			           sizeof(duk_uint8_t *) * idx_count);
 			duk_pop_unsafe(re_ctx->thr);
 			goto fail;
 		}
 		case DUK_REOP_LOOKPOS:
@@ -91172,16 +92550,16 @@
 			duk_int32_t skip;
 			duk_uint8_t **full_save;
 			const duk_uint8_t *sub_sp;
 
 			DUK_ASSERT(re_ctx->nsaved > 0);
 
 			duk_require_stack(re_ctx->thr, 1);
-			full_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr,
-			                                                          sizeof(duk_uint8_t *) * re_ctx->nsaved);
+			full_save =
+			    (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr, sizeof(duk_uint8_t *) * re_ctx->nsaved);
 			DUK_ASSERT(full_save != NULL);
 			duk_memcpy(full_save, re_ctx->saved, sizeof(duk_uint8_t *) * re_ctx->nsaved);
 
 			skip = duk__bc_get_i32(re_ctx, &pc);
 			sub_sp = duk__match_regexp(re_ctx, pc, sp);
 			if (op == DUK_REOP_LOOKPOS) {
 				if (!sub_sp) {
@@ -91198,19 +92576,17 @@
 				duk_pop_unsafe(re_ctx->thr);
 				sp = sub_sp;
 				goto match;
 			}
 
 			/* fall through */
 
-		 lookahead_fail:
+		lookahead_fail:
 			/* fail: restore saves */
-			duk_memcpy((void *) re_ctx->saved,
-			           (const void *) full_save,
-			           sizeof(duk_uint8_t *) * re_ctx->nsaved);
+			duk_memcpy((void *) re_ctx->saved, (const void *) full_save, sizeof(duk_uint8_t *) * re_ctx->nsaved);
 			duk_pop_unsafe(re_ctx->thr);
 			goto fail;
 		}
 		case DUK_REOP_BACKREFERENCE: {
 			/*
 			 *  Byte matching for back-references would be OK in case-
 			 *  sensitive matching.  In case-insensitive matching we need
@@ -91225,30 +92601,31 @@
 			 *  not matched anything always succeeds!  See E5 Section
 			 *  15.10.2.9, step 5, sub-step 3.
 			 */
 			duk_uint32_t idx;
 			const duk_uint8_t *p;
 
 			idx = duk__bc_get_u32(re_ctx, &pc);
-			idx = idx << 1;  /* backref n -> saved indices [n*2, n*2+1] */
+			idx = idx << 1; /* backref n -> saved indices [n*2, n*2+1] */
 			if (idx < 2 || idx + 1 >= re_ctx->nsaved) {
 				/* regexp compiler should catch these */
 				DUK_D(DUK_DPRINT("internal error, backreference index insane"));
 				goto internal_error;
 			}
-			if (!re_ctx->saved[idx] || !re_ctx->saved[idx+1]) {
+			if (!re_ctx->saved[idx] || !re_ctx->saved[idx + 1]) {
 				/* capture is 'undefined', always matches! */
 				DUK_DDD(DUK_DDDPRINT("backreference: saved[%ld,%ld] not complete, always match",
-				                     (long) idx, (long) (idx + 1)));
+				                     (long) idx,
+				                     (long) (idx + 1)));
 				break;
 			}
 			DUK_DDD(DUK_DDDPRINT("backreference: match saved[%ld,%ld]", (long) idx, (long) (idx + 1)));
 
 			p = re_ctx->saved[idx];
-			while (p < re_ctx->saved[idx+1]) {
+			while (p < re_ctx->saved[idx + 1]) {
 				duk_codepoint_t c1, c2;
 
 				/* Note: not necessary to check p against re_ctx->input_end:
 				 * the memory access is checked by duk__inp_get_cp(), while
 				 * valid compiled regexps cannot write a saved[] entry
 				 * which points to outside the string.
 				 */
@@ -91272,23 +92649,23 @@
 		default: {
 			DUK_D(DUK_DPRINT("internal error, regexp opcode error: %ld", (long) op));
 			goto internal_error;
 		}
 		}
 	}
 
- match:
+match:
 	re_ctx->recursion_depth--;
 	return sp;
 
- fail:
+fail:
 	re_ctx->recursion_depth--;
 	return NULL;
 
- internal_error:
+internal_error:
 	DUK_ERROR_INTERNAL(re_ctx->thr);
 	DUK_WO_NORETURN(return NULL;);
 }
 
 /*
  *  Exposed matcher function which provides the semantics of RegExp.prototype.exec().
  *
@@ -91332,16 +92709,17 @@
 	DUK_ASSERT(h_regexp != NULL);
 	DUK_ASSERT(DUK_HOBJECT_GET_CLASS_NUMBER(h_regexp) == DUK_HOBJECT_CLASS_REGEXP);
 	DUK_UNREF(h_regexp);
 
 	h_input = duk_to_hstring(thr, -1);
 	DUK_ASSERT(h_input != NULL);
 
-	duk_xget_owndataprop_stridx_short(thr, -2, DUK_STRIDX_INT_BYTECODE);  /* [ ... re_obj input ] -> [ ... re_obj input bc ] */
-	h_bytecode = duk_require_hstring(thr, -1);  /* no regexp instance should exist without a non-configurable bytecode property */
+	duk_xget_owndataprop_stridx_short(thr, -2, DUK_STRIDX_INT_BYTECODE); /* [ ... re_obj input ] -> [ ... re_obj input bc ] */
+	h_bytecode =
+	    duk_require_hstring(thr, -1); /* no regexp instance should exist without a non-configurable bytecode property */
 	DUK_ASSERT(h_bytecode != NULL);
 
 	/*
 	 *  Basic context initialization.
 	 *
 	 *  Some init values are read from the bytecode header
 	 *  whose format is (UTF-8 codepoints):
@@ -91365,21 +92743,21 @@
 
 	/* read header */
 	pc = re_ctx.bytecode;
 	re_ctx.re_flags = duk__bc_get_u32(&re_ctx, &pc);
 	re_ctx.nsaved = duk__bc_get_u32(&re_ctx, &pc);
 	re_ctx.bytecode = pc;
 
-	DUK_ASSERT(DUK_RE_FLAG_GLOBAL < 0x10000UL);  /* must fit into duk_small_int_t */
+	DUK_ASSERT(DUK_RE_FLAG_GLOBAL < 0x10000UL); /* must fit into duk_small_int_t */
 	global = (duk_small_int_t) (force_global | (duk_small_int_t) (re_ctx.re_flags & DUK_RE_FLAG_GLOBAL));
 
 	DUK_ASSERT(re_ctx.nsaved >= 2);
 	DUK_ASSERT((re_ctx.nsaved % 2) == 0);
 
-	p_buf = (duk_uint8_t *) duk_push_fixed_buffer(thr, sizeof(duk_uint8_t *) * re_ctx.nsaved);  /* rely on zeroing */
+	p_buf = (duk_uint8_t *) duk_push_fixed_buffer(thr, sizeof(duk_uint8_t *) * re_ctx.nsaved); /* rely on zeroing */
 	DUK_UNREF(p_buf);
 	re_ctx.saved = (const duk_uint8_t **) duk_get_buffer(thr, -1, NULL);
 	DUK_ASSERT(re_ctx.saved != NULL);
 
 	/* [ ... re_obj input bc saved_buf ] */
 
 #if defined(DUK_USE_EXPLICIT_NULL_INIT)
@@ -91389,15 +92767,17 @@
 #elif defined(DUK_USE_ZERO_BUFFER_DATA)
 	/* buffer is automatically zeroed */
 #else
 	duk_memzero((void *) p_buf, sizeof(duk_uint8_t *) * re_ctx.nsaved);
 #endif
 
 	DUK_DDD(DUK_DDDPRINT("regexp ctx initialized, flags=0x%08lx, nsaved=%ld, recursion_limit=%ld, steps_limit=%ld",
-	                     (unsigned long) re_ctx.re_flags, (long) re_ctx.nsaved, (long) re_ctx.recursion_limit,
+	                     (unsigned long) re_ctx.re_flags,
+	                     (long) re_ctx.nsaved,
+	                     (long) re_ctx.recursion_limit,
 	                     (long) re_ctx.steps_limit));
 
 	/*
 	 *  Get starting character offset for match, and initialize 'sp' based on it.
 	 *
 	 *  Note: lastIndex is non-configurable so it must be present (we check the
 	 *  internal class of the object above, so we know it is).  User code can set
@@ -91411,23 +92791,23 @@
 	 *  If not, the check in E5 Section 15.10.6.2, step 9.a applies.
 	 */
 
 	/* XXX: lastIndex handling produces a lot of asm */
 
 	/* [ ... re_obj input bc saved_buf ] */
 
-	duk_get_prop_stridx_short(thr, -4, DUK_STRIDX_LAST_INDEX);  /* -> [ ... re_obj input bc saved_buf lastIndex ] */
-	(void) duk_to_int(thr, -1);  /* ToInteger(lastIndex) */
-	d = duk_get_number(thr, -1);  /* integer, but may be +/- Infinite, +/- zero (not NaN, though) */
+	duk_get_prop_stridx_short(thr, -4, DUK_STRIDX_LAST_INDEX); /* -> [ ... re_obj input bc saved_buf lastIndex ] */
+	(void) duk_to_int(thr, -1); /* ToInteger(lastIndex) */
+	d = duk_get_number(thr, -1); /* integer, but may be +/- Infinite, +/- zero (not NaN, though) */
 	duk_pop_nodecref_unsafe(thr);
 
 	if (global) {
 		if (d < 0.0 || d > (double) DUK_HSTRING_GET_CHARLEN(h_input)) {
 			/* match fail */
-			char_offset = 0;   /* not really necessary */
+			char_offset = 0; /* not really necessary */
 			DUK_ASSERT(match == 0);
 			goto match_over;
 		}
 		char_offset = (duk_uint32_t) d;
 	} else {
 		/* lastIndex must be ignored for non-global regexps, but get the
 		 * value for (theoretical) side effects.  No side effects can
@@ -91455,16 +92835,18 @@
 		DUK_ASSERT_DISABLE(char_offset >= 0);
 		DUK_ASSERT(char_offset <= DUK_HSTRING_GET_CHARLEN(h_input));
 
 		/* Note: re_ctx.steps is intentionally not reset, it applies to the entire unanchored match */
 		DUK_ASSERT(re_ctx.recursion_depth == 0);
 
 		DUK_DDD(DUK_DDDPRINT("attempt match at char offset %ld; %p [%p,%p]",
-		                     (long) char_offset, (const void *) sp,
-		                     (const void *) re_ctx.input, (const void *) re_ctx.input_end));
+		                     (long) char_offset,
+		                     (const void *) sp,
+		                     (const void *) re_ctx.input,
+		                     (const void *) re_ctx.input_end));
 
 		/*
 		 *  Note:
 		 *
 		 *    - duk__match_regexp() is required not to longjmp() in ordinary "non-match"
 		 *      conditions; a longjmp() will terminate the entire matching process.
 		 *
@@ -91503,15 +92885,15 @@
 			break;
 		}
 
 		/* avoid calling at end of input, will DUK_ERROR (above check suffices to avoid this) */
 		(void) duk__utf8_advance(thr, &sp, re_ctx.input, re_ctx.input_end, (duk_uint_fast32_t) 1);
 	}
 
- match_over:
+match_over:
 
 	/*
 	 *  Matching complete, create result array or return a 'null'.  Update lastIndex
 	 *  if necessary.  See E5 Section 15.10.6.2.
 	 *
 	 *  Because lastIndex is a character (not byte) offset, we need the character
 	 *  length of the match which we conveniently get as a side effect of interning
@@ -91529,16 +92911,16 @@
 #if defined(DUK_USE_ASSERTIONS)
 		duk_hobject *h_res;
 #endif
 		duk_uint32_t char_end_offset = 0;
 
 		DUK_DDD(DUK_DDDPRINT("regexp matches at char_offset %ld", (long) char_offset));
 
-		DUK_ASSERT(re_ctx.nsaved >= 2);        /* must have start and end */
-		DUK_ASSERT((re_ctx.nsaved % 2) == 0);  /* and even number */
+		DUK_ASSERT(re_ctx.nsaved >= 2); /* must have start and end */
+		DUK_ASSERT((re_ctx.nsaved % 2) == 0); /* and even number */
 
 		/* XXX: Array size is known before and (2 * re_ctx.nsaved) but not taken
 		 * advantage of now.  The array is not compacted either, as regexp match
 		 * objects are usually short lived.
 		 */
 
 		duk_push_array(thr);
@@ -91571,15 +92953,15 @@
 				                 (duk_size_t) (re_ctx.saved[i + 1] - re_ctx.saved[i]));
 				if (i == 0) {
 					/* Assumes that saved[0] and saved[1] are always
 					 * set by regexp bytecode (if not, char_end_offset
 					 * will be zero).  Also assumes clen reflects the
 					 * correct char length.
 					 */
-					char_end_offset = char_offset + (duk_uint32_t) duk_get_length(thr, -1);  /* add charlen */
+					char_end_offset = char_offset + (duk_uint32_t) duk_get_length(thr, -1); /* add charlen */
 				}
 			} else {
 				duk_push_undefined(thr);
 			}
 
 			/* [ ... re_obj input bc saved_buf res_obj idx val ] */
 			duk_def_prop(thr, -3, DUK_DEFPROP_HAVE_VALUE | DUK_DEFPROP_SET_WEC);
@@ -91636,19 +93018,19 @@
 /* This variant is needed by String.prototype.split(); it needs to perform
  * global-style matching on a cloned RegExp which is potentially non-global.
  */
 DUK_INTERNAL void duk_regexp_match_force_global(duk_hthread *thr) {
 	duk__regexp_match_helper(thr, 1 /*force_global*/);
 }
 
-#else  /* DUK_USE_REGEXP_SUPPORT */
+#else /* DUK_USE_REGEXP_SUPPORT */
 
 /* regexp support disabled */
 
-#endif  /* DUK_USE_REGEXP_SUPPORT */
+#endif /* DUK_USE_REGEXP_SUPPORT */
 #line 1 "duk_selftest.c"
 /*
  *  Self tests to ensure execution environment is sane.  Intended to catch
  *  compiler/platform problems which cannot be detected at compile time.
  */
 
 /* #include duk_internal.h -> already included */
@@ -91661,96 +93043,123 @@
 
 typedef union {
 	double d;
 	duk_uint8_t x[8];
 } duk__test_double_union;
 
 /* Self test failed.  Expects a local variable 'error_count' to exist. */
-#define DUK__FAILED(msg)  do { \
+#define DUK__FAILED(msg) \
+	do { \
 		DUK_D(DUK_DPRINT("self test failed: " #msg " at " DUK_FILE_MACRO ":" DUK_MACRO_STRINGIFY(DUK_LINE_MACRO))); \
 		error_count++; \
 	} while (0)
 
-#define DUK__DBLUNION_CMP_TRUE(a,b)  do { \
+#define DUK__DBLUNION_CMP_TRUE(a, b) \
+	do { \
 		if (duk_memcmp((const void *) (a), (const void *) (b), sizeof(duk__test_double_union)) != 0) { \
 			DUK__FAILED("double union compares false (expected true)"); \
 		} \
 	} while (0)
 
-#define DUK__DBLUNION_CMP_FALSE(a,b)  do { \
+#define DUK__DBLUNION_CMP_FALSE(a, b) \
+	do { \
 		if (duk_memcmp((const void *) (a), (const void *) (b), sizeof(duk__test_double_union)) == 0) { \
 			DUK__FAILED("double union compares true (expected false)"); \
 		} \
 	} while (0)
 
 typedef union {
 	duk_uint32_t i;
 	duk_uint8_t x[8];
 } duk__test_u32_union;
 
 #if defined(DUK_USE_INTEGER_LE)
-#define DUK__U32_INIT(u, a, b, c, d) do { \
-		(u)->x[0] = (d); (u)->x[1] = (c); (u)->x[2] = (b); (u)->x[3] = (a); \
+#define DUK__U32_INIT(u, a, b, c, d) \
+	do { \
+		(u)->x[0] = (d); \
+		(u)->x[1] = (c); \
+		(u)->x[2] = (b); \
+		(u)->x[3] = (a); \
 	} while (0)
 #elif defined(DUK_USE_INTEGER_ME)
 #error integer mixed endian not supported now
 #elif defined(DUK_USE_INTEGER_BE)
-#define DUK__U32_INIT(u, a, b, c, d) do { \
-		(u)->x[0] = (a); (u)->x[1] = (b); (u)->x[2] = (c); (u)->x[3] = (d); \
+#define DUK__U32_INIT(u, a, b, c, d) \
+	do { \
+		(u)->x[0] = (a); \
+		(u)->x[1] = (b); \
+		(u)->x[2] = (c); \
+		(u)->x[3] = (d); \
 	} while (0)
 #else
 #error unknown integer endianness
 #endif
 
 #if defined(DUK_USE_DOUBLE_LE)
-#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) do { \
-		(u)->x[0] = (h); (u)->x[1] = (g); (u)->x[2] = (f); (u)->x[3] = (e); \
-		(u)->x[4] = (d); (u)->x[5] = (c); (u)->x[6] = (b); (u)->x[7] = (a); \
+#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) \
+	do { \
+		(u)->x[0] = (h); \
+		(u)->x[1] = (g); \
+		(u)->x[2] = (f); \
+		(u)->x[3] = (e); \
+		(u)->x[4] = (d); \
+		(u)->x[5] = (c); \
+		(u)->x[6] = (b); \
+		(u)->x[7] = (a); \
 	} while (0)
 #define DUK__DOUBLE_COMPARE(u, a, b, c, d, e, f, g, h) \
-	((u)->x[0] == (h) && (u)->x[1] == (g) && (u)->x[2] == (f) && (u)->x[3] == (e) && \
-	 (u)->x[4] == (d) && (u)->x[5] == (c) && (u)->x[6] == (b) && (u)->x[7] == (a))
+	((u)->x[0] == (h) && (u)->x[1] == (g) && (u)->x[2] == (f) && (u)->x[3] == (e) && (u)->x[4] == (d) && (u)->x[5] == (c) && \
+	 (u)->x[6] == (b) && (u)->x[7] == (a))
 #elif defined(DUK_USE_DOUBLE_ME)
-#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) do { \
-		(u)->x[0] = (d); (u)->x[1] = (c); (u)->x[2] = (b); (u)->x[3] = (a); \
-		(u)->x[4] = (h); (u)->x[5] = (g); (u)->x[6] = (f); (u)->x[7] = (e); \
+#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) \
+	do { \
+		(u)->x[0] = (d); \
+		(u)->x[1] = (c); \
+		(u)->x[2] = (b); \
+		(u)->x[3] = (a); \
+		(u)->x[4] = (h); \
+		(u)->x[5] = (g); \
+		(u)->x[6] = (f); \
+		(u)->x[7] = (e); \
 	} while (0)
 #define DUK__DOUBLE_COMPARE(u, a, b, c, d, e, f, g, h) \
-	((u)->x[0] == (d) && (u)->x[1] == (c) && (u)->x[2] == (b) && (u)->x[3] == (a) && \
-	 (u)->x[4] == (h) && (u)->x[5] == (g) && (u)->x[6] == (f) && (u)->x[7] == (e))
+	((u)->x[0] == (d) && (u)->x[1] == (c) && (u)->x[2] == (b) && (u)->x[3] == (a) && (u)->x[4] == (h) && (u)->x[5] == (g) && \
+	 (u)->x[6] == (f) && (u)->x[7] == (e))
 #elif defined(DUK_USE_DOUBLE_BE)
-#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) do { \
-		(u)->x[0] = (a); (u)->x[1] = (b); (u)->x[2] = (c); (u)->x[3] = (d); \
-		(u)->x[4] = (e); (u)->x[5] = (f); (u)->x[6] = (g); (u)->x[7] = (h); \
+#define DUK__DOUBLE_INIT(u, a, b, c, d, e, f, g, h) \
+	do { \
+		(u)->x[0] = (a); \
+		(u)->x[1] = (b); \
+		(u)->x[2] = (c); \
+		(u)->x[3] = (d); \
+		(u)->x[4] = (e); \
+		(u)->x[5] = (f); \
+		(u)->x[6] = (g); \
+		(u)->x[7] = (h); \
 	} while (0)
 #define DUK__DOUBLE_COMPARE(u, a, b, c, d, e, f, g, h) \
-	((u)->x[0] == (a) && (u)->x[1] == (b) && (u)->x[2] == (c) && (u)->x[3] == (d) && \
-	 (u)->x[4] == (e) && (u)->x[5] == (f) && (u)->x[6] == (g) && (u)->x[7] == (h))
+	((u)->x[0] == (a) && (u)->x[1] == (b) && (u)->x[2] == (c) && (u)->x[3] == (d) && (u)->x[4] == (e) && (u)->x[5] == (f) && \
+	 (u)->x[6] == (g) && (u)->x[7] == (h))
 #else
 #error unknown double endianness
 #endif
 
 /*
  *  Various sanity checks for typing
  */
 
 DUK_LOCAL duk_uint_t duk__selftest_types(void) {
 	duk_uint_t error_count = 0;
 
-	if (!(sizeof(duk_int8_t) == 1 &&
-	      sizeof(duk_uint8_t) == 1 &&
-	      sizeof(duk_int16_t) == 2 &&
-	      sizeof(duk_uint16_t) == 2 &&
-	      sizeof(duk_int32_t) == 4 &&
-	      sizeof(duk_uint32_t) == 4)) {
+	if (!(sizeof(duk_int8_t) == 1 && sizeof(duk_uint8_t) == 1 && sizeof(duk_int16_t) == 2 && sizeof(duk_uint16_t) == 2 &&
+	      sizeof(duk_int32_t) == 4 && sizeof(duk_uint32_t) == 4)) {
 		DUK__FAILED("duk_(u)int{8,16,32}_t size");
 	}
 #if defined(DUK_USE_64BIT_OPS)
-	if (!(sizeof(duk_int64_t) == 8 &&
-	      sizeof(duk_uint64_t) == 8)) {
+	if (!(sizeof(duk_int64_t) == 8 && sizeof(duk_uint64_t) == 8)) {
 		DUK__FAILED("duk_(u)int64_t size");
 	}
 #endif
 
 	if (!(sizeof(duk_size_t) >= sizeof(duk_uint_t))) {
 		/* Some internal code now assumes that all duk_uint_t values
 		 * can be expressed with a duk_size_t.
@@ -91894,16 +93303,22 @@
 	}
 #endif
 
 	/* >>> struct.unpack('>d', '4000112233445566'.decode('hex'))
 	 * (2.008366013071895,)
 	 */
 
-	du.uc[0] = 0x40; du.uc[1] = 0x00; du.uc[2] = 0x11; du.uc[3] = 0x22;
-	du.uc[4] = 0x33; du.uc[5] = 0x44; du.uc[6] = 0x55; du.uc[7] = 0x66;
+	du.uc[0] = 0x40;
+	du.uc[1] = 0x00;
+	du.uc[2] = 0x11;
+	du.uc[3] = 0x22;
+	du.uc[4] = 0x33;
+	du.uc[5] = 0x44;
+	du.uc[6] = 0x55;
+	du.uc[7] = 0x66;
 	DUK_DBLUNION_DOUBLE_NTOH(&du);
 	du_diff = du.d - 2.008366013071895;
 #if 0
 	DUK_D(DUK_DPRINT("du_diff: %lg\n", (double) du_diff));
 #endif
 	if (du_diff > 1e-15) {
 		/* Allow very small lenience because some compilers won't parse
@@ -91950,28 +93365,46 @@
 	duk_uint_t error_count = 0;
 	duk__test_double_union a, b;
 
 	/* Test signaling NaN and alias assignment in all endianness combinations.
 	 */
 
 	/* little endian */
-	a.x[0] = 0x11; a.x[1] = 0x22; a.x[2] = 0x33; a.x[3] = 0x44;
-	a.x[4] = 0x00; a.x[5] = 0x00; a.x[6] = 0xf1; a.x[7] = 0xff;
+	a.x[0] = 0x11;
+	a.x[1] = 0x22;
+	a.x[2] = 0x33;
+	a.x[3] = 0x44;
+	a.x[4] = 0x00;
+	a.x[5] = 0x00;
+	a.x[6] = 0xf1;
+	a.x[7] = 0xff;
 	b = a;
 	DUK__DBLUNION_CMP_TRUE(&a, &b);
 
 	/* big endian */
-	a.x[0] = 0xff; a.x[1] = 0xf1; a.x[2] = 0x00; a.x[3] = 0x00;
-	a.x[4] = 0x44; a.x[5] = 0x33; a.x[6] = 0x22; a.x[7] = 0x11;
+	a.x[0] = 0xff;
+	a.x[1] = 0xf1;
+	a.x[2] = 0x00;
+	a.x[3] = 0x00;
+	a.x[4] = 0x44;
+	a.x[5] = 0x33;
+	a.x[6] = 0x22;
+	a.x[7] = 0x11;
 	b = a;
 	DUK__DBLUNION_CMP_TRUE(&a, &b);
 
 	/* mixed endian */
-	a.x[0] = 0x00; a.x[1] = 0x00; a.x[2] = 0xf1; a.x[3] = 0xff;
-	a.x[4] = 0x11; a.x[5] = 0x22; a.x[6] = 0x33; a.x[7] = 0x44;
+	a.x[0] = 0x00;
+	a.x[1] = 0x00;
+	a.x[2] = 0xf1;
+	a.x[3] = 0xff;
+	a.x[4] = 0x11;
+	a.x[5] = 0x22;
+	a.x[6] = 0x33;
+	a.x[7] = 0x44;
 	b = a;
 	DUK__DBLUNION_CMP_TRUE(&a, &b);
 
 	return error_count;
 #else
 	DUK_D(DUK_DPRINT("skip double aliasing self test when duk_tval is not packed"));
 	return 0;
@@ -92028,18 +93461,22 @@
 	 */
 	DUK__DOUBLE_INIT(&a, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 	DUK__DOUBLE_INIT(&b, 0x3c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 	duk_memset((void *) &c, 0, sizeof(c));
 	c.d = a.d + b.d;
 	if (!DUK__DOUBLE_COMPARE(&c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)) {
 		DUK_D(DUK_DPRINT("broken result (native endiannesss): %02x %02x %02x %02x %02x %02x %02x %02x",
-		                 (unsigned int) c.x[0], (unsigned int) c.x[1],
-		                 (unsigned int) c.x[2], (unsigned int) c.x[3],
-		                 (unsigned int) c.x[4], (unsigned int) c.x[5],
-		                 (unsigned int) c.x[6], (unsigned int) c.x[7]));
+		                 (unsigned int) c.x[0],
+		                 (unsigned int) c.x[1],
+		                 (unsigned int) c.x[2],
+		                 (unsigned int) c.x[3],
+		                 (unsigned int) c.x[4],
+		                 (unsigned int) c.x[5],
+		                 (unsigned int) c.x[6],
+		                 (unsigned int) c.x[7]));
 		DUK__FAILED("invalid result from 1.0 + 0.5ulp");
 	}
 
 	/* (1.0 + ulp) + 2^(-53): result is midway between 1.0 + ulp and 1.0 + 2*ulp.
 	 * Round to nearest: 1.0 + 2*ulp (round to even mantissa)
 	 * Round to +Inf:    1.0 + 2*ulp
 	 * Round to -Inf:    1.0 + ulp
@@ -92048,18 +93485,22 @@
 	 */
 	DUK__DOUBLE_INIT(&a, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01);
 	DUK__DOUBLE_INIT(&b, 0x3c, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
 	duk_memset((void *) &c, 0, sizeof(c));
 	c.d = a.d + b.d;
 	if (!DUK__DOUBLE_COMPARE(&c, 0x3f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02)) {
 		DUK_D(DUK_DPRINT("broken result (native endiannesss): %02x %02x %02x %02x %02x %02x %02x %02x",
-		                 (unsigned int) c.x[0], (unsigned int) c.x[1],
-		                 (unsigned int) c.x[2], (unsigned int) c.x[3],
-		                 (unsigned int) c.x[4], (unsigned int) c.x[5],
-		                 (unsigned int) c.x[6], (unsigned int) c.x[7]));
+		                 (unsigned int) c.x[0],
+		                 (unsigned int) c.x[1],
+		                 (unsigned int) c.x[2],
+		                 (unsigned int) c.x[3],
+		                 (unsigned int) c.x[4],
+		                 (unsigned int) c.x[5],
+		                 (unsigned int) c.x[6],
+		                 (unsigned int) c.x[7]));
 		DUK__FAILED("invalid result from (1.0 + ulp) + 0.5ulp");
 	}
 
 	/* Could do negative number testing too, but the tests above should
 	 * differentiate between IEEE 754 rounding modes.
 	 */
 	return error_count;
@@ -92222,15 +93663,15 @@
 	 *  https://github.com/svaarala/duktape/issues/336
 	 */
 
 	duk_uint_t error_count = 0;
 	duk_double_t dv;
 	duk_uint32_t uv;
 
-	dv = 3735928559.0;  /* 0xdeadbeef in decimal */
+	dv = 3735928559.0; /* 0xdeadbeef in decimal */
 	uv = (duk_uint32_t) dv;
 
 	if (uv != 0xdeadbeefUL) {
 		DUK__FAILED("double to duk_uint32_t cast failed");
 	}
 
 	return error_count;
@@ -92259,31 +93700,32 @@
 		return 0;
 	}
 
 	for (i = 1; i <= 256; i++) {
 		ptr = alloc_func(udata, (duk_size_t) i);
 		if (ptr == NULL) {
 			DUK_D(DUK_DPRINT("alloc failed, ignore"));
-			continue;  /* alloc failed, ignore */
+			continue; /* alloc failed, ignore */
 		}
 		for (j = 0; j < i; j++) {
 			((unsigned char *) ptr)[j] = (unsigned char) (0x80 + j);
 		}
 		new_ptr = realloc_func(udata, ptr, 1024);
 		if (new_ptr == NULL) {
 			DUK_D(DUK_DPRINT("realloc failed, ignore"));
 			free_func(udata, ptr);
-			continue;  /* realloc failed, ignore */
+			continue; /* realloc failed, ignore */
 		}
 		ptr = new_ptr;
 		for (j = 0; j < i; j++) {
 			x = ((unsigned char *) ptr)[j];
 			if (x != (unsigned char) (0x80 + j)) {
 				DUK_D(DUK_DPRINT("byte at index %ld doesn't match after realloc: %02lx",
-				                 (long) j, (unsigned long) x));
+				                 (long) j,
+				                 (unsigned long) x));
 				DUK__FAILED("byte compare after realloc");
 				break;
 			}
 		}
 		free_func(udata, ptr);
 	}
 
@@ -92319,15 +93761,15 @@
 	error_count += duk__selftest_alloc_funcs(alloc_func, realloc_func, free_func, udata);
 
 	DUK_D(DUK_DPRINT("self test complete, total error count: %ld", (long) error_count));
 
 	return error_count;
 }
 
-#endif  /* DUK_USE_SELF_TESTS */
+#endif /* DUK_USE_SELF_TESTS */
 
 /* automatic undefs */
 #undef DUK__DBLUNION_CMP_FALSE
 #undef DUK__DBLUNION_CMP_TRUE
 #undef DUK__DOUBLE_COMPARE
 #undef DUK__DOUBLE_INIT
 #undef DUK__FAILED
@@ -92363,34 +93805,34 @@
 	/* XXX: optimize for packed duk_tval directly? */
 
 	du.d = x;
 	i = (duk_int64_t) DUK_DBLUNION_GET_INT64(&du);
 	expt = (duk_small_int_t) ((i >> 52) & 0x07ff);
 	shift = expt - 1023;
 
-	if (shift >= 0 && shift <= 46) {  /* exponents 1023 to 1069 */
+	if (shift >= 0 && shift <= 46) { /* exponents 1023 to 1069 */
 		duk_int64_t t;
 
 		if (((DUK_I64_CONSTANT(0x000fffffffffffff) >> shift) & i) == 0) {
-			t = i | DUK_I64_CONSTANT(0x0010000000000000);  /* implicit leading one */
+			t = i | DUK_I64_CONSTANT(0x0010000000000000); /* implicit leading one */
 			t = t & DUK_I64_CONSTANT(0x001fffffffffffff);
 			t = t >> (52 - shift);
 			if (i < 0) {
 				t = -t;
 			}
 			DUK_TVAL_SET_FASTINT(tv, t);
 			return;
 		}
-	} else if (shift == -1023) {  /* exponent 0 */
+	} else if (shift == -1023) { /* exponent 0 */
 		if (i >= 0 && (i & DUK_I64_CONSTANT(0x000fffffffffffff)) == 0) {
 			/* Note: reject negative zero. */
 			DUK_TVAL_SET_FASTINT(tv, (duk_int64_t) 0);
 			return;
 		}
-	} else if (shift == 47) {  /* exponent 1070 */
+	} else if (shift == 47) { /* exponent 1070 */
 		if (i < 0 && (i & DUK_I64_CONSTANT(0x000fffffffffffff)) == 0) {
 			DUK_TVAL_SET_FASTINT(tv, (duk_int64_t) DUK_FASTINT_MIN);
 			return;
 		}
 	}
 
 	DUK_TVAL_SET_DOUBLE(tv, x);
@@ -92410,31 +93852,31 @@
 	duk_double_union du;
 	duk_uint64_t t;
 
 	t = (duk_uint64_t) DUK_DBLUNION_GET_UINT64(tv);
 	if ((t >> 48) != DUK_TAG_FASTINT) {
 		return tv->d;
 	} else if (t & DUK_U64_CONSTANT(0x0000800000000000)) {
-		t = (duk_uint64_t) (-((duk_int64_t) t));  /* avoid unary minus on unsigned */
-		t = t & DUK_U64_CONSTANT(0x0000ffffffffffff);  /* negative */
+		t = (duk_uint64_t) (-((duk_int64_t) t)); /* avoid unary minus on unsigned */
+		t = t & DUK_U64_CONSTANT(0x0000ffffffffffff); /* negative */
 		t |= DUK_U64_CONSTANT(0xc330000000000000);
 		DUK_DBLUNION_SET_UINT64(&du, t);
-		return du.d + 4503599627370496.0;  /* 1 << 52 */
+		return du.d + 4503599627370496.0; /* 1 << 52 */
 	} else if (t != 0) {
-		t &= DUK_U64_CONSTANT(0x0000ffffffffffff);  /* positive */
+		t &= DUK_U64_CONSTANT(0x0000ffffffffffff); /* positive */
 		t |= DUK_U64_CONSTANT(0x4330000000000000);
 		DUK_DBLUNION_SET_UINT64(&du, t);
-		return du.d - 4503599627370496.0;  /* 1 << 52 */
+		return du.d - 4503599627370496.0; /* 1 << 52 */
 	} else {
-		return 0.0;  /* zero */
+		return 0.0; /* zero */
 	}
 }
-#endif  /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
 
-#if 0  /* unused */
+#if 0 /* unused */
 #if defined(DUK_USE_FASTINT) && !defined(DUK_USE_PACKED_TVAL)
 DUK_INTERNAL DUK_ALWAYS_INLINE duk_double_t duk_tval_get_number_unpacked(duk_tval *tv) {
 	duk_double_union du;
 	duk_uint64_t t;
 
 	DUK_ASSERT(tv->t == DUK_TAG_NUMBER || tv->t == DUK_TAG_FASTINT);
 
@@ -92448,37 +93890,37 @@
 			DUK_DBLUNION_SET_UINT64(&du, t);
 			return du.d + 4503599627370496.0;  /* 1 << 52 */
 		}
 	} else {
 		return tv->v.d;
 	}
 }
-#endif  /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
-#endif  /* 0 */
+#endif /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
+#endif /* 0 */
 
 #if defined(DUK_USE_FASTINT) && !defined(DUK_USE_PACKED_TVAL)
 DUK_INTERNAL DUK_ALWAYS_INLINE duk_double_t duk_tval_get_number_unpacked_fastint(duk_tval *tv) {
 	duk_double_union du;
 	duk_uint64_t t;
 
 	DUK_ASSERT(tv->t == DUK_TAG_FASTINT);
 
 	if (tv->v.fi >= 0) {
 		t = DUK_U64_CONSTANT(0x4330000000000000) | (duk_uint64_t) tv->v.fi;
 		DUK_DBLUNION_SET_UINT64(&du, t);
-		return du.d - 4503599627370496.0;  /* 1 << 52 */
+		return du.d - 4503599627370496.0; /* 1 << 52 */
 	} else {
 		t = DUK_U64_CONSTANT(0xc330000000000000) | (duk_uint64_t) (-tv->v.fi);
 		DUK_DBLUNION_SET_UINT64(&du, t);
-		return du.d + 4503599627370496.0;  /* 1 << 52 */
+		return du.d + 4503599627370496.0; /* 1 << 52 */
 	}
 }
-#endif  /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
+#endif /* DUK_USE_FASTINT && DUK_USE_PACKED_TVAL */
 
-#endif  /* DUK_USE_FASTINT */
+#endif /* DUK_USE_FASTINT */
 
 /*
  *  Assertion helpers.
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL void duk_tval_assert_valid(duk_tval *tv) {
@@ -98703,15 +100145,15 @@
 
 	/* Extract 'top' bits of currval; note that the extracted bits do not need
 	 * to be cleared, we just ignore them on next round.
 	 */
 	shift = ctx->currbits - bits;
 	mask = (((duk_uint32_t) 1U) << bits) - 1U;
 	tmp = (ctx->currval >> shift) & mask;
-	ctx->currbits = shift;  /* remaining */
+	ctx->currbits = shift; /* remaining */
 
 #if 0
 	DUK_DDD(DUK_DDDPRINT("decode_bits: %ld bits -> 0x%08lx (%ld), currbits=%ld, currval=0x%08lx",
 	                     (long) bits, (unsigned long) tmp, (long) tmp, (long) ctx->currbits, (unsigned long) ctx->currval));
 #endif
 
 	return tmp;
@@ -98742,71 +100184,69 @@
 	duk_small_uint_t t;
 
 	/* The bit encoding choices here are based on manual testing against
 	 * the actual varuints generated by genbuiltins.py.
 	 */
 	switch (duk_bd_decode(ctx, 2)) {
 	case 0:
-		return 0;  /* [0,0] */
+		return 0; /* [0,0] */
 	case 1:
-		return duk_bd_decode(ctx, 2) + 1;  /* [1,4] */
+		return duk_bd_decode(ctx, 2) + 1; /* [1,4] */
 	case 2:
-		return duk_bd_decode(ctx, 5) + 5;  /* [5,36] */
+		return duk_bd_decode(ctx, 5) + 5; /* [5,36] */
 	default:
 		t = duk_bd_decode(ctx, 7);
 		if (t == 0) {
 			return duk_bd_decode(ctx, 20);
 		}
-		return (t - 1) + 37;  /* [37,163] */
+		return (t - 1) + 37; /* [37,163] */
 	}
 }
 
 /* Decode a bit packed string from a custom format used by genbuiltins.py.
  * This function is here because it's used for both heap and thread inits.
  * Caller must supply the output buffer whose size is NOT checked!
  */
 
-#define DUK__BITPACK_LETTER_LIMIT  26
-#define DUK__BITPACK_LOOKUP1       26
-#define DUK__BITPACK_LOOKUP2       27
-#define DUK__BITPACK_SWITCH1       28
-#define DUK__BITPACK_SWITCH        29
-#define DUK__BITPACK_UNUSED1       30
-#define DUK__BITPACK_EIGHTBIT      31
-
-DUK_LOCAL const duk_uint8_t duk__bitpacked_lookup[16] = {
-	DUK_ASC_0, DUK_ASC_1, DUK_ASC_2, DUK_ASC_3,
-	DUK_ASC_4, DUK_ASC_5, DUK_ASC_6, DUK_ASC_7,
-	DUK_ASC_8, DUK_ASC_9, DUK_ASC_UNDERSCORE, DUK_ASC_SPACE,
-	0x82, 0x80, DUK_ASC_DOUBLEQUOTE, DUK_ASC_LCURLY
-};
+#define DUK__BITPACK_LETTER_LIMIT 26
+#define DUK__BITPACK_LOOKUP1      26
+#define DUK__BITPACK_LOOKUP2      27
+#define DUK__BITPACK_SWITCH1      28
+#define DUK__BITPACK_SWITCH       29
+#define DUK__BITPACK_UNUSED1      30
+#define DUK__BITPACK_EIGHTBIT     31
+
+DUK_LOCAL const duk_uint8_t duk__bitpacked_lookup[16] = { DUK_ASC_0, DUK_ASC_1, DUK_ASC_2,           DUK_ASC_3,
+	                                                  DUK_ASC_4, DUK_ASC_5, DUK_ASC_6,           DUK_ASC_7,
+	                                                  DUK_ASC_8, DUK_ASC_9, DUK_ASC_UNDERSCORE,  DUK_ASC_SPACE,
+	                                                  0x82,      0x80,      DUK_ASC_DOUBLEQUOTE, DUK_ASC_LCURLY };
 
 DUK_INTERNAL duk_small_uint_t duk_bd_decode_bitpacked_string(duk_bitdecoder_ctx *bd, duk_uint8_t *out) {
 	duk_small_uint_t len;
 	duk_small_uint_t mode;
 	duk_small_uint_t t;
 	duk_small_uint_t i;
 
 	len = duk_bd_decode(bd, 5);
 	if (len == 31) {
-		len = duk_bd_decode(bd, 8);  /* Support up to 256 bytes; rare. */
+		len = duk_bd_decode(bd, 8); /* Support up to 256 bytes; rare. */
 	}
 
-	mode = 32;  /* 0 = uppercase, 32 = lowercase (= 'a' - 'A') */
+	mode = 32; /* 0 = uppercase, 32 = lowercase (= 'a' - 'A') */
 	for (i = 0; i < len; i++) {
 		t = duk_bd_decode(bd, 5);
 		if (t < DUK__BITPACK_LETTER_LIMIT) {
 			t = t + DUK_ASC_UC_A + mode;
 		} else if (t == DUK__BITPACK_LOOKUP1) {
 			t = duk__bitpacked_lookup[duk_bd_decode(bd, 3)];
 		} else if (t == DUK__BITPACK_LOOKUP2) {
 			t = duk__bitpacked_lookup[8 + duk_bd_decode(bd, 3)];
 		} else if (t == DUK__BITPACK_SWITCH1) {
 			t = duk_bd_decode(bd, 5);
-			DUK_ASSERT_DISABLE(t >= 0);  /* unsigned */
+			DUK_ASSERT_DISABLE(t >= 0); /* unsigned */
 			DUK_ASSERT(t <= 25);
 			t = t + DUK_ASC_UC_A + (mode ^ 32);
 		} else if (t == DUK__BITPACK_SWITCH) {
 			mode = mode ^ 32;
 			t = duk_bd_decode(bd, 5);
 			DUK_ASSERT_DISABLE(t >= 0);
 			DUK_ASSERT(t <= 25);
@@ -98942,15 +100382,15 @@
 	add_sz = (curr_off >> DUK_BW_SLACK_SHIFT) + DUK_BW_SLACK_ADD;
 	new_sz = curr_off + sz + add_sz;
 	if (DUK_UNLIKELY(new_sz < curr_off)) {
 		/* overflow */
 		DUK_ERROR_RANGE(thr, DUK_STR_BUFFER_TOO_LONG);
 		DUK_WO_NORETURN(return NULL;);
 	}
-#if 0  /* for manual torture testing: tight allocation, useful with valgrind */
+#if 0 /* for manual torture testing: tight allocation, useful with valgrind */
 	new_sz = curr_off + sz;
 #endif
 
 	/* This is important to ensure dynamic buffer data pointer is not
 	 * NULL (which is possible if buffer size is zero), which in turn
 	 * causes portability issues with e.g. memmove() and memcpy().
 	 */
@@ -98983,66 +100423,72 @@
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(src_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(len <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(src_off + len <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_UNREF(thr);
 
 	p_base = bw->p_base;
-	duk_memcpy_unsafe((void *) bw->p,
-	                  (const void *) (p_base + src_off),
-	                  (size_t) len);
+	duk_memcpy_unsafe((void *) bw->p, (const void *) (p_base + src_off), (size_t) len);
 	bw->p += len;
 }
 
 DUK_INTERNAL void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(src_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(len <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(src_off + len <= DUK_BW_GET_SIZE(thr, bw));
 
 	DUK_BW_ENSURE(thr, bw, len);
 	duk_bw_write_raw_slice(thr, bw, src_off, len);
 }
 
-DUK_INTERNAL void duk_bw_insert_raw_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len) {
+DUK_INTERNAL void duk_bw_insert_raw_bytes(duk_hthread *thr,
+                                          duk_bufwriter_ctx *bw,
+                                          duk_size_t dst_off,
+                                          const duk_uint8_t *buf,
+                                          duk_size_t len) {
 	duk_uint8_t *p_base;
 	duk_size_t buf_sz, move_sz;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(dst_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(buf != NULL);
 	DUK_UNREF(thr);
 
 	p_base = bw->p_base;
-	buf_sz = (duk_size_t) (bw->p - p_base);  /* constrained by maximum buffer size */
+	buf_sz = (duk_size_t) (bw->p - p_base); /* constrained by maximum buffer size */
 	move_sz = buf_sz - dst_off;
 
-	DUK_ASSERT(p_base != NULL);  /* buffer size is >= 1 */
-	duk_memmove_unsafe((void *) (p_base + dst_off + len),
-	                   (const void *) (p_base + dst_off),
-	                   (size_t) move_sz);
-	duk_memcpy_unsafe((void *) (p_base + dst_off),
-	                  (const void *) buf,
-	                  (size_t) len);
+	DUK_ASSERT(p_base != NULL); /* buffer size is >= 1 */
+	duk_memmove_unsafe((void *) (p_base + dst_off + len), (const void *) (p_base + dst_off), (size_t) move_sz);
+	duk_memcpy_unsafe((void *) (p_base + dst_off), (const void *) buf, (size_t) len);
 	bw->p += len;
 }
 
-DUK_INTERNAL void duk_bw_insert_ensure_bytes(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, const duk_uint8_t *buf, duk_size_t len) {
+DUK_INTERNAL void duk_bw_insert_ensure_bytes(duk_hthread *thr,
+                                             duk_bufwriter_ctx *bw,
+                                             duk_size_t dst_off,
+                                             const duk_uint8_t *buf,
+                                             duk_size_t len) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(dst_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(buf != NULL);
 
 	DUK_BW_ENSURE(thr, bw, len);
 	duk_bw_insert_raw_bytes(thr, bw, dst_off, buf, len);
 }
 
-DUK_INTERNAL void duk_bw_insert_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len) {
+DUK_INTERNAL void duk_bw_insert_raw_slice(duk_hthread *thr,
+                                          duk_bufwriter_ctx *bw,
+                                          duk_size_t dst_off,
+                                          duk_size_t src_off,
+                                          duk_size_t len) {
 	duk_uint8_t *p_base;
 	duk_size_t buf_sz, move_sz;
 
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(dst_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(src_off <= DUK_BW_GET_SIZE(thr, bw));
@@ -99061,25 +100507,25 @@
 		 */
 		src_off += len;
 	}
 
 	buf_sz = (duk_size_t) (bw->p - p_base);
 	move_sz = buf_sz - dst_off;
 
-	DUK_ASSERT(p_base != NULL);  /* buffer size is >= 1 */
-	duk_memmove_unsafe((void *) (p_base + dst_off + len),
-	                   (const void *) (p_base + dst_off),
-	                   (size_t) move_sz);
-	duk_memcpy_unsafe((void *) (p_base + dst_off),
-	                  (const void *) (p_base + src_off),
-	                  (size_t) len);
+	DUK_ASSERT(p_base != NULL); /* buffer size is >= 1 */
+	duk_memmove_unsafe((void *) (p_base + dst_off + len), (const void *) (p_base + dst_off), (size_t) move_sz);
+	duk_memcpy_unsafe((void *) (p_base + dst_off), (const void *) (p_base + src_off), (size_t) len);
 	bw->p += len;
 }
 
-DUK_INTERNAL void duk_bw_insert_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t dst_off, duk_size_t src_off, duk_size_t len) {
+DUK_INTERNAL void duk_bw_insert_ensure_slice(duk_hthread *thr,
+                                             duk_bufwriter_ctx *bw,
+                                             duk_size_t dst_off,
+                                             duk_size_t src_off,
+                                             duk_size_t len) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(dst_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(src_off <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(len <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_ASSERT(src_off + len <= DUK_BW_GET_SIZE(thr, bw));
 
@@ -99101,15 +100547,15 @@
 
 	p_base = bw->p_base;
 	buf_sz = (duk_size_t) (bw->p - p_base);
 	move_sz = buf_sz - off;
 	p_dst = p_base + off + len;
 	p_src = p_base + off;
 	duk_memmove_unsafe((void *) p_dst, (const void *) p_src, (size_t) move_sz);
-	return p_src;  /* point to start of 'reserved area' */
+	return p_src; /* point to start of 'reserved area' */
 }
 
 DUK_INTERNAL duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 	DUK_ASSERT(thr != NULL);
 	DUK_ASSERT(bw != NULL);
 	DUK_ASSERT(off <= DUK_BW_GET_SIZE(thr, bw));
 
@@ -99131,36 +100577,30 @@
 	DUK_ASSERT(off + len <= DUK_BW_GET_SIZE(thr, bw));
 	DUK_UNREF(thr);
 
 	p_base = bw->p_base;
 	p_dst = p_base + off;
 	p_src = p_dst + len;
 	move_sz = (duk_size_t) (bw->p - p_src);
-	duk_memmove_unsafe((void *) p_dst,
-	                   (const void *) p_src,
-	                   (size_t) move_sz);
+	duk_memmove_unsafe((void *) p_dst, (const void *) p_src, (size_t) move_sz);
 	bw->p -= len;
 }
 
 /*
  *  Assertion helpers
  */
 
 #if defined(DUK_USE_ASSERTIONS)
 DUK_INTERNAL void duk_bw_assert_valid(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx) {
 	DUK_UNREF(thr);
 	DUK_ASSERT(bw_ctx != NULL);
 	DUK_ASSERT(bw_ctx->buf != NULL);
 	DUK_ASSERT((DUK_HBUFFER_DYNAMIC_GET_SIZE(bw_ctx->buf) == 0) ||
-	           (bw_ctx->p != NULL &&
-	            bw_ctx->p_base != NULL &&
-	            bw_ctx->p_limit != NULL &&
-	            bw_ctx->p_limit >= bw_ctx->p_base &&
-	            bw_ctx->p >= bw_ctx->p_base &&
-	            bw_ctx->p <= bw_ctx->p_limit));
+	           (bw_ctx->p != NULL && bw_ctx->p_base != NULL && bw_ctx->p_limit != NULL && bw_ctx->p_limit >= bw_ctx->p_base &&
+	            bw_ctx->p >= bw_ctx->p_base && bw_ctx->p <= bw_ctx->p_limit));
 }
 #endif
 #line 1 "duk_util_cast.c"
 /*
  *  Cast helpers.
  *
  *  C99+ coercion is challenging portability-wise because out-of-range casts
@@ -99175,15 +100615,16 @@
 
 /* #include duk_internal.h -> already included */
 
 /* Portable double-to-integer cast which avoids undefined behavior and avoids
  * relying on fmin(), fmax(), or other intrinsics.  Out-of-range results are
  * not assumed by caller, but here value is clamped, NaN converts to minval.
  */
-#define DUK__DOUBLE_INT_CAST1(tname,minval,maxval)  do { \
+#define DUK__DOUBLE_INT_CAST1(tname, minval, maxval) \
+	do { \
 		if (DUK_LIKELY(x >= (duk_double_t) (minval))) { \
 			DUK_ASSERT(!DUK_ISNAN(x)); \
 			if (DUK_LIKELY(x <= (duk_double_t) (maxval))) { \
 				return (tname) x; \
 			} else { \
 				return (tname) (maxval); \
 			} \
@@ -99196,36 +100637,40 @@
 		} \
 	} while (0)
 
 /* Rely on specific NaN behavior for duk_double_{fmin,fmax}(): if either
  * argument is a NaN, return the second argument.  This avoids a
  * NaN-to-integer cast which is undefined behavior.
  */
-#define DUK__DOUBLE_INT_CAST2(tname,minval,maxval)  do { \
+#define DUK__DOUBLE_INT_CAST2(tname, minval, maxval) \
+	do { \
 		return (tname) duk_double_fmin(duk_double_fmax(x, (duk_double_t) (minval)), (duk_double_t) (maxval)); \
 	} while (0)
 
 /* Another solution which doesn't need C99+ behavior for fmin() and fmax(). */
-#define DUK__DOUBLE_INT_CAST3(tname,minval,maxval)  do { \
+#define DUK__DOUBLE_INT_CAST3(tname, minval, maxval) \
+	do { \
 		if (DUK_ISNAN(x)) { \
 			/* 0 or any other value is fine. */ \
 			return (tname) 0; \
 		} else \
 			return (tname) DUK_FMIN(DUK_FMAX(x, (duk_double_t) (minval)), (duk_double_t) (maxval)); \
-		} \
-	} while (0)
+	} \
+	} \
+	while (0)
 
 /* C99+ solution: relies on specific fmin() and fmax() behavior in C99: if
  * one argument is NaN but the other isn't, the non-NaN argument is returned.
  * Because the limits are non-NaN values, explicit NaN check is not needed.
  * This may not work on all legacy platforms, and also doesn't seem to inline
  * the fmin() and fmax() calls (unless one uses -ffast-math which we don't
  * support).
  */
-#define DUK__DOUBLE_INT_CAST4(tname,minval,maxval)  do { \
+#define DUK__DOUBLE_INT_CAST4(tname, minval, maxval) \
+	do { \
 		return (tname) DUK_FMIN(DUK_FMAX(x, (duk_double_t) (minval)), (duk_double_t) (maxval)); \
 	} while (0)
 
 DUK_INTERNAL duk_int_t duk_double_to_int_t(duk_double_t x) {
 #if defined(DUK_USE_ALLOW_UNDEFINED_BEHAVIOR)
 	/* Real world solution: almost any practical platform will provide
 	 * an integer value without any guarantees what it is (which is fine).
@@ -99261,20 +100706,20 @@
 }
 
 /* Largest IEEE double that doesn't round to infinity in the default rounding
  * mode.  The exact midpoint between (1 - 2^(-24)) * 2^128 and 2^128 rounds to
  * infinity, at least on x64.  This number is one double unit below that
  * midpoint.  See misc/float_cast.c.
  */
-#define DUK__FLOAT_ROUND_LIMIT      340282356779733623858607532500980858880.0
+#define DUK__FLOAT_ROUND_LIMIT 340282356779733623858607532500980858880.0
 
 /* Maximum IEEE float.  Double-to-float conversion above this would be out of
  * range and thus technically undefined behavior.
  */
-#define DUK__FLOAT_MAX              340282346638528859811704183484516925440.0
+#define DUK__FLOAT_MAX 340282346638528859811704183484516925440.0
 
 DUK_INTERNAL duk_float_t duk_double_to_float_t(duk_double_t x) {
 	/* Even a double-to-float cast is technically undefined behavior if
 	 * the double is out-of-range.  C99 Section 6.3.1.5:
 	 *
 	 *   If the value being converted is in the range of values that can
 	 *   be represented but cannot be represented exactly, the result is
@@ -99285,16 +100730,15 @@
 	 */
 #if defined(DUK_USE_ALLOW_UNDEFINED_BEHAVIOR)
 	return (duk_float_t) x;
 #else
 	duk_double_t t;
 
 	t = DUK_FABS(x);
-	DUK_ASSERT((DUK_ISNAN(x) && DUK_ISNAN(t)) ||
-	           (!DUK_ISNAN(x) && !DUK_ISNAN(t)));
+	DUK_ASSERT((DUK_ISNAN(x) && DUK_ISNAN(t)) || (!DUK_ISNAN(x) && !DUK_ISNAN(t)));
 
 	if (DUK_LIKELY(t <= DUK__FLOAT_MAX)) {
 		/* Standard in-range case, try to get here with a minimum
 		 * number of checks and branches.
 		 */
 		DUK_ASSERT(!DUK_ISNAN(x));
 		return (duk_float_t) x;
@@ -99435,15 +100879,15 @@
 	du.d = x;
 	return (duk_small_uint_t) DUK_DBLUNION_GET_SIGNBIT(&du);
 }
 
 DUK_INTERNAL duk_double_t duk_double_trunc_towards_zero(duk_double_t x) {
 	/* XXX: optimize */
 	duk_small_uint_t s = duk_double_signbit(x);
-	x = DUK_FLOOR(DUK_FABS(x));  /* truncate towards zero */
+	x = DUK_FLOOR(DUK_FABS(x)); /* truncate towards zero */
 	if (s) {
 		x = -x;
 	}
 	return x;
 }
 
 DUK_INTERNAL duk_bool_t duk_double_same_sign(duk_double_t x, duk_double_t y) {
@@ -99682,58 +101126,59 @@
  *  dependent, for instance.
  */
 
 /* #include duk_internal.h -> already included */
 
 #if defined(DUK_USE_STRHASH_DENSE)
 /* 'magic' constants for Murmurhash2 */
-#define DUK__MAGIC_M  ((duk_uint32_t) 0x5bd1e995UL)
-#define DUK__MAGIC_R  24
+#define DUK__MAGIC_M ((duk_uint32_t) 0x5bd1e995UL)
+#define DUK__MAGIC_R 24
 
 DUK_INTERNAL duk_uint32_t duk_util_hashbytes(const duk_uint8_t *data, duk_size_t len, duk_uint32_t seed) {
 	duk_uint32_t h = seed ^ ((duk_uint32_t) len);
 
 	while (len >= 4) {
 		/* Portability workaround is required for platforms without
 		 * unaligned access.  The replacement code emulates little
 		 * endian access even on big endian architectures, which is
 		 * OK as long as it is consistent for a build.
 		 */
 #if defined(DUK_USE_HASHBYTES_UNALIGNED_U32_ACCESS)
 		duk_uint32_t k = *((const duk_uint32_t *) (const void *) data);
 #else
-		duk_uint32_t k = ((duk_uint32_t) data[0]) |
-		                 (((duk_uint32_t) data[1]) << 8) |
-		                 (((duk_uint32_t) data[2]) << 16) |
+		duk_uint32_t k = ((duk_uint32_t) data[0]) | (((duk_uint32_t) data[1]) << 8) | (((duk_uint32_t) data[2]) << 16) |
 		                 (((duk_uint32_t) data[3]) << 24);
 #endif
 
 		k *= DUK__MAGIC_M;
 		k ^= k >> DUK__MAGIC_R;
 		k *= DUK__MAGIC_M;
 		h *= DUK__MAGIC_M;
 		h ^= k;
 		data += 4;
 		len -= 4;
 	}
 
 	switch (len) {
-	case 3: h ^= data[2] << 16;
-	case 2: h ^= data[1] << 8;
-	case 1: h ^= data[0];
-	        h *= DUK__MAGIC_M;
-        }
+	case 3:
+		h ^= data[2] << 16;
+	case 2:
+		h ^= data[1] << 8;
+	case 1:
+		h ^= data[0];
+		h *= DUK__MAGIC_M;
+	}
 
 	h ^= h >> 13;
 	h *= DUK__MAGIC_M;
 	h ^= h >> 15;
 
 	return h;
 }
-#endif  /* DUK_USE_STRHASH_DENSE */
+#endif /* DUK_USE_STRHASH_DENSE */
 
 /* automatic undefs */
 #undef DUK__MAGIC_M
 #undef DUK__MAGIC_R
 #line 1 "duk_util_memory.c"
 /*
  *  Memory utils.
@@ -99749,15 +101194,15 @@
 }
 
 DUK_INTERNAL DUK_INLINE duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len) {
 	DUK_ASSERT(s1 != NULL);
 	DUK_ASSERT(s2 != NULL);
 	return DUK_MEMCMP(s1, s2, (size_t) len);
 }
-#else  /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
+#else /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
 DUK_INTERNAL DUK_INLINE duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len) {
 	DUK_ASSERT(s1 != NULL || len == 0U);
 	DUK_ASSERT(s2 != NULL || len == 0U);
 	if (DUK_UNLIKELY(len == 0U)) {
 		return 0;
 	}
 	DUK_ASSERT(s1 != NULL);
@@ -99766,15 +101211,15 @@
 }
 
 DUK_INTERNAL DUK_INLINE duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len) {
 	DUK_ASSERT(s1 != NULL);
 	DUK_ASSERT(s2 != NULL);
 	return DUK_MEMCMP(s1, s2, (size_t) len);
 }
-#endif  /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
+#endif /* DUK_USE_ALLOW_UNDEFINED_BEHAVIOR */
 #line 1 "duk_util_tinyrandom.c"
 /*
  *  A tiny random number generator used for Math.random() and other internals.
  *
  *  Default algorithm is xoroshiro128+: http://xoroshiro.di.unimi.it/xoroshiro128plus.c
  *  with SplitMix64 seed preparation: http://xorshift.di.unimi.it/splitmix64.c.
  *
@@ -99791,33 +101236,34 @@
 #if defined(DUK_USE_PREFER_SIZE) || !defined(DUK_USE_64BIT_OPS)
 #define DUK__RANDOM_SHAMIR3OP
 #else
 #define DUK__RANDOM_XOROSHIRO128PLUS
 #endif
 
 #if defined(DUK__RANDOM_SHAMIR3OP)
-#define DUK__UPDATE_RND(rnd) do { \
+#define DUK__UPDATE_RND(rnd) \
+	do { \
 		(rnd) += ((rnd) * (rnd)) | 0x05UL; \
-		(rnd) = ((rnd) & 0xffffffffUL);       /* if duk_uint32_t is exactly 32 bits, this is a NOP */ \
+		(rnd) = ((rnd) &0xffffffffUL); /* if duk_uint32_t is exactly 32 bits, this is a NOP */ \
 	} while (0)
 
-#define DUK__RND_BIT(rnd)  ((rnd) >> 31)  /* only use the highest bit */
+#define DUK__RND_BIT(rnd) ((rnd) >> 31) /* only use the highest bit */
 
 DUK_INTERNAL void duk_util_tinyrandom_prepare_seed(duk_hthread *thr) {
-	DUK_UNREF(thr);  /* Nothing now. */
+	DUK_UNREF(thr); /* Nothing now. */
 }
 
 DUK_INTERNAL duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr) {
 	duk_double_t t;
 	duk_small_int_t n;
 	duk_uint32_t rnd;
 
 	rnd = thr->heap->rnd_state;
 
-	n = 53;  /* enough to cover the whole mantissa */
+	n = 53; /* enough to cover the whole mantissa */
 	t = 0.0;
 
 	do {
 		DUK__UPDATE_RND(rnd);
 		t += DUK__RND_BIT(rnd);
 		t /= 2.0;
 	} while (--n);
@@ -99825,15 +101271,15 @@
 	thr->heap->rnd_state = rnd;
 
 	DUK_ASSERT(t >= (duk_double_t) 0.0);
 	DUK_ASSERT(t < (duk_double_t) 1.0);
 
 	return t;
 }
-#endif  /* DUK__RANDOM_SHAMIR3OP */
+#endif /* DUK__RANDOM_SHAMIR3OP */
 
 #if defined(DUK__RANDOM_XOROSHIRO128PLUS)
 DUK_LOCAL DUK_ALWAYS_INLINE duk_uint64_t duk__rnd_splitmix64(duk_uint64_t *x) {
 	duk_uint64_t z;
 	z = (*x += DUK_U64_CONSTANT(0x9E3779B97F4A7C15));
 	z = (z ^ (z >> 30U)) * DUK_U64_CONSTANT(0xBF58476D1CE4E5B9);
 	z = (z ^ (z >> 27U)) * DUK_U64_CONSTANT(0x94D049BB133111EB);
@@ -99864,17 +101310,17 @@
 	duk_uint64_t x;
 
 	/* Mix both halves of the initial seed with SplitMix64.  The intent
 	 * is to ensure that very similar raw seeds (which is usually the case
 	 * because current seed is Date.now()) result in different xoroshiro128+
 	 * seeds.
 	 */
-	x = thr->heap->rnd_state[0];  /* Only [0] is used as input here. */
+	x = thr->heap->rnd_state[0]; /* Only [0] is used as input here. */
 	for (i = 0; i < 64; i++) {
-		thr->heap->rnd_state[i & 0x01] = duk__rnd_splitmix64(&x);  /* Keep last 2 values. */
+		thr->heap->rnd_state[i & 0x01] = duk__rnd_splitmix64(&x); /* Keep last 2 values. */
 	}
 }
 
 DUK_INTERNAL duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr) {
 	duk_uint64_t v;
 	duk_double_union du;
 
@@ -99890,16 +101336,16 @@
 		tmp = du.ui[0];
 		du.ui[0] = du.ui[1];
 		du.ui[1] = tmp;
 	} while (0);
 #endif
 	return du.d - 1.0;
 }
-#endif  /* DUK__RANDOM_XOROSHIRO128PLUS */
+#endif /* DUK__RANDOM_XOROSHIRO128PLUS */
 
-#endif  /* !DUK_USE_GET_RANDOM_DOUBLE */
+#endif /* !DUK_USE_GET_RANDOM_DOUBLE */
 
 /* automatic undefs */
 #undef DUK__RANDOM_SHAMIR3OP
 #undef DUK__RANDOM_XOROSHIRO128PLUS
 #undef DUK__RND_BIT
 #undef DUK__UPDATE_RND
```

### Comparing `pyduktape2-0.4.2/vendor/duktape.h` & `pyduktape2-0.4.3/vendor/duktape.h`

 * *Files 0% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 /*
- *  Duktape public API for Duktape 2.6.0.
+ *  Duktape public API for Duktape 2.7.0.
  *
  *  See the API reference for documentation on call semantics.  The exposed,
  *  supported API is between the "BEGIN PUBLIC API" and "END PUBLIC API"
  *  comments.  Other parts of the header are Duktape internal and related to
  *  e.g. platform/compiler/feature detection.
  *
- *  Git commit fffa346eff06a8764b02c31d4336f63a773a95c3 (v2.6.0).
- *  Git branch v2-maintenance.
+ *  Git commit 03d4d728f8365021de6955c649e6dcd05dcca99f (03d4d72-dirty).
+ *  Git branch HEAD.
  *
  *  See Duktape AUTHORS.rst and LICENSE.txt for copyright and
  *  licensing information.
  */
 
 /* LICENSE.txt */
 /*
  *  ===============
  *  Duktape license
  *  ===============
  *  
  *  (http://opensource.org/licenses/MIT)
  *  
- *  Copyright (c) 2013-2019 by Duktape authors (see AUTHORS.rst)
+ *  Copyright (c) 2013-present by Duktape authors (see AUTHORS.rst)
  *  
  *  Permission is hereby granted, free of charge, to any person obtaining a copy
  *  of this software and associated documentation files (the "Software"), to deal
  *  in the Software without restriction, including without limitation the rights
  *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  *  copies of the Software, and to permit persons to whom the Software is
  *  furnished to do so, subject to the following conditions:
@@ -106,14 +106,20 @@
  *  * TheBrokenRail (https://github.com/TheBrokenRail)
  *  * Jesse Doyle (https://github.com/jessedoyle)
  *  * Gero Kuehn (https://github.com/dc6jgk)
  *  * James Swift (https://github.com/phraemer)
  *  * Luis de Bethencourt (https://github.com/luisbg)
  *  * Ian Whyman (https://github.com/v00d00)
  *  * Rick Sayre (https://github.com/whorfin)
+ *  * Craig Leres (https://github.com/leres)
+ *  * Maurici Abad (https://github.com/mauriciabad)
+ *  * Nancy Li (https://github.com/NancyLi1013)
+ *  * William Parks (https://github.com/WilliamParks)
+ *  * Sam Hellawell (https://github.com/samhellawell)
+ *  * Vladislavs Sokurenko (https://github.com/sokurenko)
  *  
  *  Other contributions
  *  ===================
  *  
  *  The following people have contributed something other than code (e.g. reported
  *  bugs, provided ideas, etc; roughly in order of appearance):
  *  
@@ -172,24 +178,24 @@
 
 /* Duktape version, (major * 10000) + (minor * 100) + patch.  Allows C code
  * to #if (DUK_VERSION >= NNN) against Duktape API version.  The same value
  * is also available to ECMAScript code in Duktape.version.  Unofficial
  * development snapshots have 99 for patch level (e.g. 0.10.99 would be a
  * development version after 0.10.0 but before the next official release).
  */
-#define DUK_VERSION                       20600L
+#define DUK_VERSION                       20700L
 
 /* Git commit, describe, and branch for Duktape build.  Useful for
  * non-official snapshot builds so that application code can easily log
  * which Duktape snapshot was used.  Not available in the ECMAScript
  * environment.
  */
-#define DUK_GIT_COMMIT                    "fffa346eff06a8764b02c31d4336f63a773a95c3"
-#define DUK_GIT_DESCRIBE                  "v2.6.0"
-#define DUK_GIT_BRANCH                    "v2-maintenance"
+#define DUK_GIT_COMMIT                    "03d4d728f8365021de6955c649e6dcd05dcca99f"
+#define DUK_GIT_DESCRIBE                  "03d4d72-dirty"
+#define DUK_GIT_BRANCH                    "HEAD"
 
 /* External duk_config.h provides platform/compiler/OS dependent
  * typedefs and macros, and DUK_USE_xxx config options so that
  * the rest of Duktape doesn't need to do any feature detection.
  * DUK_VERSION is defined before including so that configuration
  * snippets can react to it.
  */
```

