# Comparing `tmp/proxsuite-0.3.6-0-pp39-pypy39_pp73-manylinux_2_17_x86_64.whl.zip` & `tmp/proxsuite-0.3.7-0-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,116 +1,117 @@
-Zip file size: 2046046 bytes, number of entries: 114
--rw-r--r--  2.0 unx     3067 b- defN 23-Mar-14 12:30 cmeel.prefix/include/proxsuite/config.hpp
--rw-r--r--  2.0 unx     2158 b- defN 23-Mar-14 12:30 cmeel.prefix/include/proxsuite/deprecated.hpp
--rw-r--r--  2.0 unx     1404 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/fwd.hpp
--rw-r--r--  2.0 unx     1108 b- defN 23-Mar-14 12:30 cmeel.prefix/include/proxsuite/warning.hpp
--rw-r--r--  2.0 unx     2292 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/helpers/common.hpp
--rw-r--r--  2.0 unx     8714 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/helpers/instruction-set.hpp
--rw-r--r--  2.0 unx     1156 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/helpers/optional.hpp
--rw-r--r--  2.0 unx    73389 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/helpers/tl-optional.hpp
--rw-r--r--  2.0 unx      811 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/helpers/version.hpp
--rw-r--r--  2.0 unx    26100 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/core.hpp
--rw-r--r--  2.0 unx     9696 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/factorize.hpp
--rw-r--r--  2.0 unx    23225 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/ldlt.hpp
--rw-r--r--  2.0 unx     8795 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/modify.hpp
--rw-r--r--  2.0 unx      915 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/solve.hpp
--rw-r--r--  2.0 unx     7791 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/dense/update.hpp
--rw-r--r--  2.0 unx    12865 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/sparse/core.hpp
--rw-r--r--  2.0 unx    36154 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/sparse/factorize.hpp
--rw-r--r--  2.0 unx    15390 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/sparse/rowmod.hpp
--rw-r--r--  2.0 unx    10394 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/sparse/update.hpp
--rw-r--r--  2.0 unx     3032 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/ref.hpp
--rw-r--r--  2.0 unx     5354 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/slice.hpp
--rw-r--r--  2.0 unx    27087 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/tuple.hpp
--rw-r--r--  2.0 unx    29817 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/vec.hpp
--rw-r--r--  2.0 unx      788 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/assert_impl.hpp
--rw-r--r--  2.0 unx     2444 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/collection_algo.hpp
--rw-r--r--  2.0 unx      539 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/dbg.hpp
--rw-r--r--  2.0 unx     2164 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/delete_special_members.hpp
--rw-r--r--  2.0 unx     8861 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/dyn_index.hpp
--rw-r--r--  2.0 unx      710 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/epilogue.hpp
--rw-r--r--  2.0 unx    10323 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/fix_index.hpp
--rw-r--r--  2.0 unx      377 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/has_asan.hpp
--rw-r--r--  2.0 unx     6749 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/integer_seq.hpp
--rw-r--r--  2.0 unx    54801 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/macros.hpp
--rw-r--r--  2.0 unx     1251 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/narrow.hpp
--rw-r--r--  2.0 unx    26076 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/preprocessor.hpp
--rw-r--r--  2.0 unx     5933 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/prologue.hpp
--rw-r--r--  2.0 unx      323 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/std.hpp
--rw-r--r--  2.0 unx      502 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/terminate.hpp
--rw-r--r--  2.0 unx     1120 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/typedefs.hpp
--rw-r--r--  2.0 unx    91845 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/external/hedley.ext.hpp
--rw-r--r--  2.0 unx     4401 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/internal/external/unhedley.ext.hpp
--rw-r--r--  2.0 unx     2184 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/memory/address.hpp
--rw-r--r--  2.0 unx    10111 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/memory/alloc.hpp
--rw-r--r--  2.0 unx    13133 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/memory/dynamic_stack.hpp
--rw-r--r--  2.0 unx     5854 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/memory/placement.hpp
--rw-r--r--  2.0 unx     6799 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/memory/stack_alloc.hpp
--rw-r--r--  2.0 unx     4920 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/alloc.hpp
--rw-r--r--  2.0 unx     1984 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/assignable.hpp
--rw-r--r--  2.0 unx     6798 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/constructible.hpp
--rw-r--r--  2.0 unx     7909 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/core.hpp
--rw-r--r--  2.0 unx     1606 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/invocable.hpp
--rw-r--r--  2.0 unx     1627 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/primitives.hpp
--rw-r--r--  2.0 unx     1088 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/tags.hpp
--rw-r--r--  2.0 unx     1666 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/assert.hpp
--rw-r--r--  2.0 unx      167 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/dbg.hpp
--rw-r--r--  2.0 unx     1436 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/defer.hpp
--rw-r--r--  2.0 unx      985 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/dynstack_alloc.hpp
--rw-r--r--  2.0 unx     4151 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/get.hpp
--rw-r--r--  2.0 unx      179 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/index.hpp
--rw-r--r--  2.0 unx      946 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/linalg/veg/util/unreachable.hpp
--rw-r--r--  2.0 unx     5233 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/results.hpp
--rw-r--r--  2.0 unx    11192 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/settings.hpp
--rw-r--r--  2.0 unx     1247 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/status.hpp
--rw-r--r--  2.0 unx     1892 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/timings.hpp
--rw-r--r--  2.0 unx      267 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/dense.hpp
--rw-r--r--  2.0 unx     1365 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/fwd.hpp
--rw-r--r--  2.0 unx    16045 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/helpers.hpp
--rw-r--r--  2.0 unx    17874 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/linesearch.hpp
--rw-r--r--  2.0 unx     4072 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/model.hpp
--rw-r--r--  2.0 unx    46602 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/solver.hpp
--rw-r--r--  2.0 unx    15150 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/utils.hpp
--rw-r--r--  2.0 unx    37758 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/views.hpp
--rw-r--r--  2.0 unx     6553 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/workspace.hpp
--rw-r--r--  2.0 unx    17306 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/wrapper.hpp
--rw-r--r--  2.0 unx     2515 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/identity.hpp
--rw-r--r--  2.0 unx    17026 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/ruiz.hpp
--rw-r--r--  2.0 unx     1507 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/fwd.hpp
--rw-r--r--  2.0 unx     8974 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/helpers.hpp
--rw-r--r--  2.0 unx     5900 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/model.hpp
--rw-r--r--  2.0 unx    53641 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/solver.hpp
--rw-r--r--  2.0 unx      274 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/sparse.hpp
--rw-r--r--  2.0 unx    25494 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/utils.hpp
--rw-r--r--  2.0 unx     1802 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/views.hpp
--rw-r--r--  2.0 unx    26363 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/workspace.hpp
--rw-r--r--  2.0 unx    28790 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/wrapper.hpp
--rw-r--r--  2.0 unx     2051 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/identity.hpp
--rw-r--r--  2.0 unx    15487 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/ruiz.hpp
--rw-r--r--  2.0 unx     1073 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/utils/prints.hpp
--rw-r--r--  2.0 unx    17647 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/proxqp/utils/random_qp_problems.hpp
--rw-r--r--  2.0 unx     6014 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/archive.hpp
--rw-r--r--  2.0 unx     2627 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/eigen.hpp
--rw-r--r--  2.0 unx      804 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/model.hpp
--rw-r--r--  2.0 unx     1901 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/results.hpp
--rw-r--r--  2.0 unx     2233 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/settings.hpp
--rw-r--r--  2.0 unx      538 b- defN 23-Mar-14 12:29 cmeel.prefix/include/proxsuite/serialization/wrapper.hpp
--rw-r--r--  2.0 unx     6307 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake
--rw-r--r--  2.0 unx     2878 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake
--rw-r--r--  2.0 unx     1018 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-release.cmake
--rw-r--r--  2.0 unx     4567 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake
--rw-r--r--  2.0 unx     1035 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake
--rw-r--r--  2.0 unx      541 b- defN 23-Mar-14 12:30 cmeel.prefix/lib/pkgconfig/proxsuite.pc
--rw-r--r--  2.0 unx     1109 b- defN 23-Mar-14 12:29 cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py
--rwxr-xr-x  2.0 unx   259392 b- defN 23-Mar-14 12:30 cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.so
--rwxr-xr-x  2.0 unx  1411400 b- defN 23-Mar-14 12:31 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.so
--rwxr-xr-x  2.0 unx  1532128 b- defN 23-Mar-14 12:31 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.so
--rwxr-xr-x  2.0 unx  1598968 b- defN 23-Mar-14 12:32 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.so
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-14 12:30 cmeel.prefix/share/ament_index/resource_index/packages/proxsuite
--rw-r--r--  2.0 unx     1774 b- defN 23-Mar-14 12:29 cmeel.prefix/share/proxsuite/package.xml
--rw-r--r--  2.0 unx       40 b- defN 23-Mar-14 12:30 cmeel.prefix/share/proxsuite/hook/ament_prefix_path.dsv
--rw-r--r--  2.0 unx       60 b- defN 23-Mar-14 12:30 cmeel.prefix/share/proxsuite/hook/python_path.dsv
--rw-r--r--  2.0 unx     9886 b- defN 23-Mar-14 12:32 proxsuite-0.3.6.dist-info/METADATA
--rw-r--r--  2.0 unx      120 b- defN 23-Mar-14 12:32 proxsuite-0.3.6.dist-info/WHEEL
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-14 12:32 proxsuite-0.3.6.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx    12979 b- defN 23-Mar-14 12:32 proxsuite-0.3.6.dist-info/RECORD
-114 files, 5852883 bytes uncompressed, 2024314 bytes compressed:  65.4%
+Zip file size: 3430733 bytes, number of entries: 115
+-rw-rw-rw-  2.0 fat     3135 b- defN 23-May-05 10:44 cmeel.prefix/include/proxsuite/config.hpp
+-rw-rw-rw-  2.0 fat     2214 b- defN 23-May-05 10:44 cmeel.prefix/include/proxsuite/deprecated.hpp
+-rw-rw-rw-  2.0 fat     1456 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/fwd.hpp
+-rw-rw-rw-  2.0 fat     1143 b- defN 23-May-05 10:44 cmeel.prefix/include/proxsuite/warning.hpp
+-rw-rw-rw-  2.0 fat     2362 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/helpers/common.hpp
+-rw-rw-rw-  2.0 fat     8989 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/helpers/instruction-set.hpp
+-rw-rw-rw-  2.0 fat     1202 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/helpers/optional.hpp
+-rw-rw-rw-  2.0 fat    75861 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/helpers/tl-optional.hpp
+-rw-rw-rw-  2.0 fat      850 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/helpers/version.hpp
+-rw-rw-rw-  2.0 fat    26959 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/core.hpp
+-rw-rw-rw-  2.0 fat    10071 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/factorize.hpp
+-rw-rw-rw-  2.0 fat    24042 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/ldlt.hpp
+-rw-rw-rw-  2.0 fat     9128 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/modify.hpp
+-rw-rw-rw-  2.0 fat      953 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/solve.hpp
+-rw-rw-rw-  2.0 fat     8121 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/dense/update.hpp
+-rw-rw-rw-  2.0 fat    13396 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/sparse/core.hpp
+-rw-rw-rw-  2.0 fat    37457 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/sparse/factorize.hpp
+-rw-rw-rw-  2.0 fat    15833 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/sparse/rowmod.hpp
+-rw-rw-rw-  2.0 fat    10742 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/sparse/update.hpp
+-rw-rw-rw-  2.0 fat     3180 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/ref.hpp
+-rw-rw-rw-  2.0 fat     5594 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/slice.hpp
+-rw-rw-rw-  2.0 fat    27963 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/tuple.hpp
+-rw-rw-rw-  2.0 fat    30851 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/vec.hpp
+-rw-rw-rw-  2.0 fat      808 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/assert_impl.hpp
+-rw-rw-rw-  2.0 fat     2537 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/collection_algo.hpp
+-rw-rw-rw-  2.0 fat      554 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/dbg.hpp
+-rw-rw-rw-  2.0 fat     2241 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/delete_special_members.hpp
+-rw-rw-rw-  2.0 fat     9153 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/dyn_index.hpp
+-rw-rw-rw-  2.0 fat      741 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/epilogue.hpp
+-rw-rw-rw-  2.0 fat    10663 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/fix_index.hpp
+-rw-rw-rw-  2.0 fat      394 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/has_asan.hpp
+-rw-rw-rw-  2.0 fat     6997 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/integer_seq.hpp
+-rw-rw-rw-  2.0 fat    56354 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/macros.hpp
+-rw-rw-rw-  2.0 fat     1297 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/narrow.hpp
+-rw-rw-rw-  2.0 fat    26510 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/preprocessor.hpp
+-rw-rw-rw-  2.0 fat     6090 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/prologue.hpp
+-rw-rw-rw-  2.0 fat      336 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/std.hpp
+-rw-rw-rw-  2.0 fat      524 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/terminate.hpp
+-rw-rw-rw-  2.0 fat     1178 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/typedefs.hpp
+-rw-rw-rw-  2.0 fat    93934 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/external/hedley.ext.hpp
+-rw-rw-rw-  2.0 fat     4549 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/internal/external/unhedley.ext.hpp
+-rw-rw-rw-  2.0 fat     2281 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/memory/address.hpp
+-rw-rw-rw-  2.0 fat    10463 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/memory/alloc.hpp
+-rw-rw-rw-  2.0 fat    13637 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/memory/dynamic_stack.hpp
+-rw-rw-rw-  2.0 fat     6056 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/memory/placement.hpp
+-rw-rw-rw-  2.0 fat     7038 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/memory/stack_alloc.hpp
+-rw-rw-rw-  2.0 fat     5089 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/alloc.hpp
+-rw-rw-rw-  2.0 fat     2037 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/assignable.hpp
+-rw-rw-rw-  2.0 fat     7015 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/constructible.hpp
+-rw-rw-rw-  2.0 fat     8207 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/core.hpp
+-rw-rw-rw-  2.0 fat     1651 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/invocable.hpp
+-rw-rw-rw-  2.0 fat     1670 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/primitives.hpp
+-rw-rw-rw-  2.0 fat     1135 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/type_traits/tags.hpp
+-rw-rw-rw-  2.0 fat     1714 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/assert.hpp
+-rw-rw-rw-  2.0 fat      173 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/dbg.hpp
+-rw-rw-rw-  2.0 fat     1493 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/defer.hpp
+-rw-rw-rw-  2.0 fat     1004 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/dynstack_alloc.hpp
+-rw-rw-rw-  2.0 fat     4299 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/get.hpp
+-rw-rw-rw-  2.0 fat      185 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/index.hpp
+-rw-rw-rw-  2.0 fat      987 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/linalg/veg/util/unreachable.hpp
+-rw-rw-rw-  2.0 fat     5445 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/results.hpp
+-rw-rw-rw-  2.0 fat    11494 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/settings.hpp
+-rw-rw-rw-  2.0 fat     1293 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/status.hpp
+-rw-rw-rw-  2.0 fat     1993 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/timings.hpp
+-rw-rw-rw-  2.0 fat      277 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/dense.hpp
+-rw-rw-rw-  2.0 fat     1420 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/fwd.hpp
+-rw-rw-rw-  2.0 fat    16565 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/helpers.hpp
+-rw-rw-rw-  2.0 fat    18391 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/linesearch.hpp
+-rw-rw-rw-  2.0 fat     4219 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/model.hpp
+-rw-rw-rw-  2.0 fat    47932 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/solver.hpp
+-rw-rw-rw-  2.0 fat    15565 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/utils.hpp
+-rw-rw-rw-  2.0 fat    39206 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/views.hpp
+-rw-rw-rw-  2.0 fat     6817 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/workspace.hpp
+-rw-rw-rw-  2.0 fat    17797 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/wrapper.hpp
+-rw-rw-rw-  2.0 fat     2628 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/identity.hpp
+-rw-rw-rw-  2.0 fat    17597 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/ruiz.hpp
+-rw-rw-rw-  2.0 fat     1565 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/fwd.hpp
+-rw-rw-rw-  2.0 fat     9283 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/helpers.hpp
+-rw-rw-rw-  2.0 fat     6128 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/model.hpp
+-rw-rw-rw-  2.0 fat    55082 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/solver.hpp
+-rw-rw-rw-  2.0 fat      284 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/sparse.hpp
+-rw-rw-rw-  2.0 fat    26309 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/utils.hpp
+-rw-rw-rw-  2.0 fat     1865 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/views.hpp
+-rw-rw-rw-  2.0 fat    27153 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/workspace.hpp
+-rw-rw-rw-  2.0 fat    29562 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/wrapper.hpp
+-rw-rw-rw-  2.0 fat     2115 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/identity.hpp
+-rw-rw-rw-  2.0 fat    16056 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/ruiz.hpp
+-rw-rw-rw-  2.0 fat     1120 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/utils/prints.hpp
+-rw-rw-rw-  2.0 fat    18316 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/proxqp/utils/random_qp_problems.hpp
+-rw-rw-rw-  2.0 fat     6245 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/archive.hpp
+-rw-rw-rw-  2.0 fat     2734 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/eigen.hpp
+-rw-rw-rw-  2.0 fat      838 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/model.hpp
+-rw-rw-rw-  2.0 fat     1975 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/results.hpp
+-rw-rw-rw-  2.0 fat     2293 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/settings.hpp
+-rw-rw-rw-  2.0 fat      562 b- defN 23-May-05 10:35 cmeel.prefix/include/proxsuite/serialization/wrapper.hpp
+-rw-rw-rw-  2.0 fat     6484 b- defN 23-May-05 10:46 cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake
+-rw-rw-rw-  2.0 fat     2827 b- defN 23-May-05 10:46 cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake
+-rw-rw-rw-  2.0 fat     1093 b- defN 23-May-05 10:46 cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-debug.cmake
+-rw-rw-rw-  2.0 fat     4766 b- defN 23-May-05 10:46 cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake
+-rw-rw-rw-  2.0 fat     1074 b- defN 23-May-05 10:46 cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake
+-rw-rw-rw-  2.0 fat      563 b- defN 23-May-05 10:44 cmeel.prefix/lib/pkgconfig/proxsuite.pc
+-rw-rw-rw-  2.0 fat     1149 b- defN 23-May-05 10:35 cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py
+-rw-rw-rw-  2.0 fat   616448 b- defN 23-May-05 10:44 cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.pyd
+-rw-rw-rw-  2.0 fat  5119488 b- defN 23-May-05 10:45 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.pyd
+-rw-rw-rw-  2.0 fat  5143040 b- defN 23-May-05 10:45 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.pyd
+-rw-rw-rw-  2.0 fat  5157888 b- defN 23-May-05 10:46 cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.pyd
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-05 10:44 cmeel.prefix/share/ament_index/resource_index/packages/proxsuite
+-rw-rw-rw-  2.0 fat     1840 b- defN 23-May-05 10:35 cmeel.prefix/share/proxsuite/package.xml
+-rw-rw-rw-  2.0 fat       40 b- defN 23-May-05 10:44 cmeel.prefix/share/proxsuite/hook/ament_prefix_path.dsv
+-rw-rw-rw-  2.0 fat       60 b- defN 23-May-05 10:44 cmeel.prefix/share/proxsuite/hook/python_path.dsv
+-rw-rw-rw-  2.0 fat     1345 b- defN 23-May-05 10:46 proxsuite-0.3.7.dist-info/license/LICENSE
+-rw-rw-rw-  2.0 fat    10186 b- defN 23-May-05 10:46 proxsuite-0.3.7.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      105 b- defN 23-May-05 10:46 proxsuite-0.3.7.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        0 b- defN 23-May-05 10:46 proxsuite-0.3.7.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat    13082 b- defN 23-May-05 10:46 proxsuite-0.3.7.dist-info/RECORD
+115 files, 17122098 bytes uncompressed, 3408839 bytes compressed:  80.1%
```

## zipnote {}

```diff
@@ -285,59 +285,62 @@
 
 Filename: cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake
 Comment: 
 
 Filename: cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake
 Comment: 
 
-Filename: cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-release.cmake
+Filename: cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-debug.cmake
 Comment: 
 
 Filename: cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake
 Comment: 
 
 Filename: cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake
 Comment: 
 
 Filename: cmeel.prefix/lib/pkgconfig/proxsuite.pc
 Comment: 
 
 Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py
 Comment: 
 
-Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.so
+Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.pyd
 Comment: 
 
-Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.so
+Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.pyd
 Comment: 
 
-Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.so
+Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.pyd
 Comment: 
 
-Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.so
+Filename: cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.pyd
 Comment: 
 
 Filename: cmeel.prefix/share/ament_index/resource_index/packages/proxsuite
 Comment: 
 
 Filename: cmeel.prefix/share/proxsuite/package.xml
 Comment: 
 
 Filename: cmeel.prefix/share/proxsuite/hook/ament_prefix_path.dsv
 Comment: 
 
 Filename: cmeel.prefix/share/proxsuite/hook/python_path.dsv
 Comment: 
 
-Filename: proxsuite-0.3.6.dist-info/METADATA
+Filename: proxsuite-0.3.7.dist-info/license/LICENSE
 Comment: 
 
-Filename: proxsuite-0.3.6.dist-info/WHEEL
+Filename: proxsuite-0.3.7.dist-info/METADATA
 Comment: 
 
-Filename: proxsuite-0.3.6.dist-info/top_level.txt
+Filename: proxsuite-0.3.7.dist-info/WHEEL
 Comment: 
 
-Filename: proxsuite-0.3.6.dist-info/RECORD
+Filename: proxsuite-0.3.7.dist-info/top_level.txt
+Comment: 
+
+Filename: proxsuite-0.3.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cmeel.prefix/include/proxsuite/config.hpp

```diff
@@ -1,68 +1,68 @@
-/*
- * This file has been automatically generated by the jrl-cmakemodules.
- * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/config.hh.cmake for details.
-*/
-
-#ifndef PROXSUITE_CONFIG_HH
-# define PROXSUITE_CONFIG_HH
-
-// Package version (header).
-# define PROXSUITE_VERSION_UNKNOWN_TAG 0 // Used to mention that the current version is unknown.
-# define PROXSUITE_VERSION "0.3.6"
-# define PROXSUITE_MAJOR_VERSION 0
-# define PROXSUITE_MINOR_VERSION 3
-# define PROXSUITE_PATCH_VERSION 6
-
-#define PROXSUITE_VERSION_AT_LEAST(major, minor, patch) (PROXSUITE_MAJOR_VERSION>major || (PROXSUITE_MAJOR_VERSION>=major && \
-                                                             (PROXSUITE_MINOR_VERSION>minor || (PROXSUITE_MINOR_VERSION>=minor && \
-                                                                                                     PROXSUITE_PATCH_VERSION>=patch))))
-
-#define PROXSUITE_VERSION_AT_MOST(major, minor, patch) (PROXSUITE_MAJOR_VERSION<major || (PROXSUITE_MAJOR_VERSION<=major && \
-                                                            (PROXSUITE_MINOR_VERSION<minor || (PROXSUITE_MINOR_VERSION<=minor && \
-                                                                                                     PROXSUITE_PATCH_VERSION<=patch))))
-
-// Handle portable symbol export.
-// Defining manually which symbol should be exported is required
-// under Windows whether MinGW or MSVC is used.
-//
-// The headers then have to be able to work in two different modes:
-// - dllexport when one is building the library,
-// - dllimport for clients using the library.
-//
-// On Linux, set the visibility accordingly. If C++ symbol visibility
-// is handled by the compiler, see: http://gcc.gnu.org/wiki/Visibility
-# if defined _WIN32 || defined __CYGWIN__
-// On Microsoft Windows, use dllimport and dllexport to tag symbols.
-#  define PROXSUITE_DLLIMPORT __declspec(dllimport)
-#  define PROXSUITE_DLLEXPORT __declspec(dllexport)
-#  define PROXSUITE_DLLLOCAL
-# else
-// On Linux, for GCC >= 4, tag symbols using GCC extension.
-#  if __GNUC__ >= 4
-#   define PROXSUITE_DLLIMPORT __attribute__ ((visibility("default")))
-#   define PROXSUITE_DLLEXPORT __attribute__ ((visibility("default")))
-#   define PROXSUITE_DLLLOCAL  __attribute__ ((visibility("hidden")))
-#  else
-// Otherwise (GCC < 4 or another compiler is used), export everything.
-#   define PROXSUITE_DLLIMPORT
-#   define PROXSUITE_DLLEXPORT
-#   define PROXSUITE_DLLLOCAL
-#  endif // __GNUC__ >= 4
-# endif // defined _WIN32 || defined __CYGWIN__
-
-# ifdef PROXSUITE_STATIC
-// If one is using the library statically, get rid of
-// extra information.
-#  define PROXSUITE_DLLAPI
-#  define PROXSUITE_LOCAL
-# else
-// Depending on whether one is building or using the
-// library define DLLAPI to import or export.
-#  ifdef proxsuite_EXPORTS
-#   define PROXSUITE_DLLAPI PROXSUITE_DLLEXPORT
-#  else
-#   define PROXSUITE_DLLAPI PROXSUITE_DLLIMPORT
-#  endif // PROXSUITE_EXPORTS
-#  define PROXSUITE_LOCAL PROXSUITE_DLLLOCAL
-# endif // PROXSUITE_STATIC
-#endif //! PROXSUITE_CONFIG_HH
+/*
+ * This file has been automatically generated by the jrl-cmakemodules.
+ * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/config.hh.cmake for details.
+*/
+
+#ifndef PROXSUITE_CONFIG_HH
+# define PROXSUITE_CONFIG_HH
+
+// Package version (header).
+# define PROXSUITE_VERSION_UNKNOWN_TAG 0 // Used to mention that the current version is unknown.
+# define PROXSUITE_VERSION "0.3.7"
+# define PROXSUITE_MAJOR_VERSION 0
+# define PROXSUITE_MINOR_VERSION 3
+# define PROXSUITE_PATCH_VERSION 7
+
+#define PROXSUITE_VERSION_AT_LEAST(major, minor, patch) (PROXSUITE_MAJOR_VERSION>major || (PROXSUITE_MAJOR_VERSION>=major && \
+                                                             (PROXSUITE_MINOR_VERSION>minor || (PROXSUITE_MINOR_VERSION>=minor && \
+                                                                                                     PROXSUITE_PATCH_VERSION>=patch))))
+
+#define PROXSUITE_VERSION_AT_MOST(major, minor, patch) (PROXSUITE_MAJOR_VERSION<major || (PROXSUITE_MAJOR_VERSION<=major && \
+                                                            (PROXSUITE_MINOR_VERSION<minor || (PROXSUITE_MINOR_VERSION<=minor && \
+                                                                                                     PROXSUITE_PATCH_VERSION<=patch))))
+
+// Handle portable symbol export.
+// Defining manually which symbol should be exported is required
+// under Windows whether MinGW or MSVC is used.
+//
+// The headers then have to be able to work in two different modes:
+// - dllexport when one is building the library,
+// - dllimport for clients using the library.
+//
+// On Linux, set the visibility accordingly. If C++ symbol visibility
+// is handled by the compiler, see: http://gcc.gnu.org/wiki/Visibility
+# if defined _WIN32 || defined __CYGWIN__
+// On Microsoft Windows, use dllimport and dllexport to tag symbols.
+#  define PROXSUITE_DLLIMPORT __declspec(dllimport)
+#  define PROXSUITE_DLLEXPORT __declspec(dllexport)
+#  define PROXSUITE_DLLLOCAL
+# else
+// On Linux, for GCC >= 4, tag symbols using GCC extension.
+#  if __GNUC__ >= 4
+#   define PROXSUITE_DLLIMPORT __attribute__ ((visibility("default")))
+#   define PROXSUITE_DLLEXPORT __attribute__ ((visibility("default")))
+#   define PROXSUITE_DLLLOCAL  __attribute__ ((visibility("hidden")))
+#  else
+// Otherwise (GCC < 4 or another compiler is used), export everything.
+#   define PROXSUITE_DLLIMPORT
+#   define PROXSUITE_DLLEXPORT
+#   define PROXSUITE_DLLLOCAL
+#  endif // __GNUC__ >= 4
+# endif // defined _WIN32 || defined __CYGWIN__
+
+# ifdef PROXSUITE_STATIC
+// If one is using the library statically, get rid of
+// extra information.
+#  define PROXSUITE_DLLAPI
+#  define PROXSUITE_LOCAL
+# else
+// Depending on whether one is building or using the
+// library define DLLAPI to import or export.
+#  ifdef proxsuite_EXPORTS
+#   define PROXSUITE_DLLAPI PROXSUITE_DLLEXPORT
+#  else
+#   define PROXSUITE_DLLAPI PROXSUITE_DLLIMPORT
+#  endif // PROXSUITE_EXPORTS
+#  define PROXSUITE_LOCAL PROXSUITE_DLLLOCAL
+# endif // PROXSUITE_STATIC
+#endif //! PROXSUITE_CONFIG_HH
```

## cmeel.prefix/include/proxsuite/deprecated.hpp

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-/*
- * This file has been automatically generated by the jrl-cmakemodules.
- * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/deprecated.hh.cmake for details.
-*/
-
-#ifndef PROXSUITE_DEPRECATED_HH
-# define PROXSUITE_DEPRECATED_HH
-
-// Define a suffix which can be used to tag a type, a function or a a
-// variable as deprecated (i.e. it will emit a warning when using it).
-//
-// Tagging a function as deprecated:
-//  void foo () PROXSUITE_DEPRECATED;
-//
-// Tagging a type as deprecated:
-//  class Foo {};
-//  typedef Foo Bar PROXSUITE_DEPRECATED;
-//
-// Tagging a variable as deprecated:
-//  int a PROXSUITE_DEPRECATED = 0;
-//
-// The use of a macro is required as this is /not/ a standardized
-// feature of C++ language or preprocessor, even if most of the
-// compilers support it.
-# if defined(__cplusplus) && (__cplusplus >= 201402L)
-#  define PROXSUITE_DEPRECATED [[deprecated]]
-#  define PROXSUITE_DEPRECATED_MESSAGE(message) [[deprecated(#message)]]
-# elif defined(__GNUC__) || defined(__clang__)
-#  define PROXSUITE_DEPRECATED __attribute__ ((deprecated))
-#  define PROXSUITE_DEPRECATED_MESSAGE(message) __attribute__ (( deprecated(#message) ))
-# else
-#  if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#   define PROXSUITE_DEPRECATED __declspec (deprecated)
-#   define PROXSUITE_DEPRECATED_MESSAGE(message) __declspec ( deprecated(#message) )
-#  else
-// If the compiler is not recognized, drop the feature.
-#   define PROXSUITE_DEPRECATED /* nothing */
-#   define PROXSUITE_DEPRECATED_MESSAGE(message)
-#  endif // __MSVC__
-# endif // __cplusplus
-
-# if defined(__GNUC__) || defined(__clang__)
-#  ifndef PROXSUITE_PRAGMA
-#   define PROXSUITE_PRAGMA(X) _Pragma(#X)
-#  endif
-#  define PROXSUITE_DEPRECATED_HEADER(MSG) PROXSUITE_PRAGMA(GCC warning MSG)
-# elif defined(_MSC_VER) && !defined(__INTEL_COMPILER)
-#  define PROXSUITE_STRINGIZE_(MSG) #MSG
-#  define PROXSUITE_STRINGIZE(MSG) PROXSUITE_STRINGIZE_(MSG)
-#  define PROXSUITE_DEPRECATED_HEADER(MSG) \
-    __pragma(message(__FILE__ "(" PROXSUITE_STRINGIZE(__LINE__) ") : Warning: " MSG))
-# else
-#  define PROXSUITE_DEPRECATED_HEADER(MSG)
-# endif
-
-#endif //! PROXSUITE_DEPRECATED_HH
+/*
+ * This file has been automatically generated by the jrl-cmakemodules.
+ * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/deprecated.hh.cmake for details.
+*/
+
+#ifndef PROXSUITE_DEPRECATED_HH
+# define PROXSUITE_DEPRECATED_HH
+
+// Define a suffix which can be used to tag a type, a function or a a
+// variable as deprecated (i.e. it will emit a warning when using it).
+//
+// Tagging a function as deprecated:
+//  void foo () PROXSUITE_DEPRECATED;
+//
+// Tagging a type as deprecated:
+//  class Foo {};
+//  typedef Foo Bar PROXSUITE_DEPRECATED;
+//
+// Tagging a variable as deprecated:
+//  int a PROXSUITE_DEPRECATED = 0;
+//
+// The use of a macro is required as this is /not/ a standardized
+// feature of C++ language or preprocessor, even if most of the
+// compilers support it.
+# if defined(__cplusplus) && (__cplusplus >= 201402L)
+#  define PROXSUITE_DEPRECATED [[deprecated]]
+#  define PROXSUITE_DEPRECATED_MESSAGE(message) [[deprecated(#message)]]
+# elif defined(__GNUC__) || defined(__clang__)
+#  define PROXSUITE_DEPRECATED __attribute__ ((deprecated))
+#  define PROXSUITE_DEPRECATED_MESSAGE(message) __attribute__ (( deprecated(#message) ))
+# else
+#  if defined(_MSC_VER) && !defined(__INTEL_COMPILER)
+#   define PROXSUITE_DEPRECATED __declspec (deprecated)
+#   define PROXSUITE_DEPRECATED_MESSAGE(message) __declspec ( deprecated(#message) )
+#  else
+// If the compiler is not recognized, drop the feature.
+#   define PROXSUITE_DEPRECATED /* nothing */
+#   define PROXSUITE_DEPRECATED_MESSAGE(message)
+#  endif // __MSVC__
+# endif // __cplusplus
+
+# if defined(__GNUC__) || defined(__clang__)
+#  ifndef PROXSUITE_PRAGMA
+#   define PROXSUITE_PRAGMA(X) _Pragma(#X)
+#  endif
+#  define PROXSUITE_DEPRECATED_HEADER(MSG) PROXSUITE_PRAGMA(GCC warning MSG)
+# elif defined(_MSC_VER) && !defined(__INTEL_COMPILER)
+#  define PROXSUITE_STRINGIZE_(MSG) #MSG
+#  define PROXSUITE_STRINGIZE(MSG) PROXSUITE_STRINGIZE_(MSG)
+#  define PROXSUITE_DEPRECATED_HEADER(MSG) \
+    __pragma(message(__FILE__ "(" PROXSUITE_STRINGIZE(__LINE__) ") : Warning: " MSG))
+# else
+#  define PROXSUITE_DEPRECATED_HEADER(MSG)
+# endif
+
+#endif //! PROXSUITE_DEPRECATED_HH
```

## cmeel.prefix/include/proxsuite/fwd.hpp

 * *Ordering differences only*

```diff
@@ -1,52 +1,52 @@
-//
-// Copyright (c) 2022 INRIA
-//
-
-#ifndef __proxsuite_fwd_hpp__
-#define __proxsuite_fwd_hpp__
-
-#if __cplusplus >= 201703L
-#define PROXSUITE_WITH_CPP_17
-#endif
-#if __cplusplus >= 201402L
-#define PROXSUITE_WITH_CPP_14
-#endif
-
-#if defined(PROXSUITE_WITH_CPP_17)
-#define PROXSUITE_MAYBE_UNUSED [[maybe_unused]]
-#elif defined(_MSC_VER) && !defined(__clang__)
-#define PROXSUITE_MAYBE_UNUSED
-#else
-#define PROXSUITE_MAYBE_UNUSED __attribute__((__unused__))
-#endif
-
-// Same logic as in Pinocchio to check eigen malloc
-#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
-#ifndef EIGEN_RUNTIME_NO_MALLOC
-#define EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
-#define EIGEN_RUNTIME_NO_MALLOC
-#endif
-#endif
-
-#include <Eigen/Core>
-
-#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
-#ifdef EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
-#undef EIGEN_RUNTIME_NO_MALLOC
-#undef EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
-#endif
-#endif
-
-// Check memory allocation for Eigen
-#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
-#define PROXSUITE_EIGEN_MALLOC(allowed)                                        \
-  ::Eigen::internal::set_is_malloc_allowed(allowed)
-#define PROXSUITE_EIGEN_MALLOC_ALLOWED() PROXSUITE_EIGEN_MALLOC(true)
-#define PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED() PROXSUITE_EIGEN_MALLOC(false)
-#else
-#define PROXSUITE_EIGEN_MALLOC(allowed)
-#define PROXSUITE_EIGEN_MALLOC_ALLOWED()
-#define PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED()
-#endif
-
-#endif // #ifndef __proxsuite_fwd_hpp__
+//
+// Copyright (c) 2022 INRIA
+//
+
+#ifndef __proxsuite_fwd_hpp__
+#define __proxsuite_fwd_hpp__
+
+#if __cplusplus >= 201703L
+#define PROXSUITE_WITH_CPP_17
+#endif
+#if __cplusplus >= 201402L
+#define PROXSUITE_WITH_CPP_14
+#endif
+
+#if defined(PROXSUITE_WITH_CPP_17)
+#define PROXSUITE_MAYBE_UNUSED [[maybe_unused]]
+#elif defined(_MSC_VER) && !defined(__clang__)
+#define PROXSUITE_MAYBE_UNUSED
+#else
+#define PROXSUITE_MAYBE_UNUSED __attribute__((__unused__))
+#endif
+
+// Same logic as in Pinocchio to check eigen malloc
+#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
+#ifndef EIGEN_RUNTIME_NO_MALLOC
+#define EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
+#define EIGEN_RUNTIME_NO_MALLOC
+#endif
+#endif
+
+#include <Eigen/Core>
+
+#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
+#ifdef EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
+#undef EIGEN_RUNTIME_NO_MALLOC
+#undef EIGEN_RUNTIME_NO_MALLOC_WAS_NOT_DEFINED
+#endif
+#endif
+
+// Check memory allocation for Eigen
+#ifdef PROXSUITE_EIGEN_CHECK_MALLOC
+#define PROXSUITE_EIGEN_MALLOC(allowed)                                        \
+  ::Eigen::internal::set_is_malloc_allowed(allowed)
+#define PROXSUITE_EIGEN_MALLOC_ALLOWED() PROXSUITE_EIGEN_MALLOC(true)
+#define PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED() PROXSUITE_EIGEN_MALLOC(false)
+#else
+#define PROXSUITE_EIGEN_MALLOC(allowed)
+#define PROXSUITE_EIGEN_MALLOC_ALLOWED()
+#define PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED()
+#endif
+
+#endif // #ifndef __proxsuite_fwd_hpp__
```

## cmeel.prefix/include/proxsuite/warning.hpp

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-/*
- * This file has been automatically generated by the jrl-cmakemodules.
- * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/warning.hh.cmake for details.
-*/
-
-#ifndef PROXSUITE_WARNING_HH
-# define PROXSUITE_WARNING_HH
-
-// Emits a warning in a portable way.
-//
-// To emit a warning, one can insert:
-//
-// #pragma message PROXSUITE_WARN("your warning message here")
-//
-// The use of this syntax is required as this is /not/ a standardized
-// feature of C++ language or preprocessor, even if most of the
-// compilers support it.
-
-# define PROXSUITE_WARN_STRINGISE_IMPL(x) #x
-# define PROXSUITE_WARN_STRINGISE(x) \
-         PROXSUITE_WARN_STRINGISE_IMPL(x)
-# ifdef __GNUC__
-#   define PROXSUITE_WARN(exp) ("WARNING: " exp)
-# else
-#  ifdef _MSC_VER
-#   define FILE_LINE_LINK __FILE__ "(" \
-           PROXSUITE_WARN_STRINGISE(__LINE__) ") : "
-#   define PROXSUITE_WARN(exp) (FILE_LINE_LINK "WARNING: " exp)
-#  else
-// If the compiler is not recognized, drop the feature.
-#   define PROXSUITE_WARN(MSG) /* nothing */
-#  endif // __MSVC__
-# endif // __GNUC__
-
-#endif //! PROXSUITE_WARNING_HH
+/*
+ * This file has been automatically generated by the jrl-cmakemodules.
+ * Please see https://github.com/jrl-umi3218/jrl-cmakemodules/blob/master/warning.hh.cmake for details.
+*/
+
+#ifndef PROXSUITE_WARNING_HH
+# define PROXSUITE_WARNING_HH
+
+// Emits a warning in a portable way.
+//
+// To emit a warning, one can insert:
+//
+// #pragma message PROXSUITE_WARN("your warning message here")
+//
+// The use of this syntax is required as this is /not/ a standardized
+// feature of C++ language or preprocessor, even if most of the
+// compilers support it.
+
+# define PROXSUITE_WARN_STRINGISE_IMPL(x) #x
+# define PROXSUITE_WARN_STRINGISE(x) \
+         PROXSUITE_WARN_STRINGISE_IMPL(x)
+# ifdef __GNUC__
+#   define PROXSUITE_WARN(exp) ("WARNING: " exp)
+# else
+#  ifdef _MSC_VER
+#   define FILE_LINE_LINK __FILE__ "(" \
+           PROXSUITE_WARN_STRINGISE(__LINE__) ") : "
+#   define PROXSUITE_WARN(exp) (FILE_LINE_LINK "WARNING: " exp)
+#  else
+// If the compiler is not recognized, drop the feature.
+#   define PROXSUITE_WARN(MSG) /* nothing */
+#  endif // __MSVC__
+# endif // __GNUC__
+
+#endif //! PROXSUITE_WARNING_HH
```

## cmeel.prefix/include/proxsuite/helpers/common.hpp

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file common.hpp
- */
-
-#ifndef PROXSUITE_HELPERS_COMMON_HPP
-#define PROXSUITE_HELPERS_COMMON_HPP
-
-#include "proxsuite/config.hpp"
-#include <limits>
-
-namespace proxsuite {
-namespace helpers {
-
-template<typename Scalar>
-struct infinite_bound
-{
-  static Scalar value()
-  {
-    using namespace std;
-    return sqrt(std::numeric_limits<Scalar>::max());
-  }
-};
-
-#define PROXSUITE_DEDUCE_RET(...)                                              \
-  noexcept(noexcept(__VA_ARGS__))                                              \
-    ->typename std::remove_const<decltype(__VA_ARGS__)>::type                  \
-  {                                                                            \
-    return __VA_ARGS__;                                                        \
-  }                                                                            \
-  static_assert(true, ".")
-
-/// @brief \brief Returns the part of the expression which is lower than value
-template<typename T, typename Scalar>
-auto
-at_most(T const& expr, const Scalar value) PROXSUITE_DEDUCE_RET(
-  (expr.array() < value).select(expr, T::Constant(expr.rows(), value)));
-
-/// @brief \brief Returns the part of the expression which is greater than value
-template<typename T, typename Scalar>
-auto
-at_least(T const& expr, const Scalar value) PROXSUITE_DEDUCE_RET(
-  (expr.array() > value).select(expr, T::Constant(expr.rows(), value)));
-
-/// @brief \brief Returns the positive part of an expression
-template<typename T>
-auto
-positive_part(T const& expr)
-  PROXSUITE_DEDUCE_RET((expr.array() > 0).select(expr, T::Zero(expr.rows())));
-
-/// @brief \brief Returns the negative part of an expression
-template<typename T>
-auto
-negative_part(T const& expr)
-  PROXSUITE_DEDUCE_RET((expr.array() < 0).select(expr, T::Zero(expr.rows())));
-
-/// @brief \brief Select the components of the expression if the condition is
-/// fullfiled. Otherwise, set the component to value
-template<typename Condition, typename T, typename Scalar>
-auto
-select(Condition const& condition, T const& expr, const Scalar value)
-  PROXSUITE_DEDUCE_RET((condition).select(expr,
-                                          T::Constant(expr.rows(), value)));
-
-} // helpers
-} // proxsuite
-
-#endif // ifndef PROXSUITE_HELPERS_COMMON_HPP
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file common.hpp
+ */
+
+#ifndef PROXSUITE_HELPERS_COMMON_HPP
+#define PROXSUITE_HELPERS_COMMON_HPP
+
+#include "proxsuite/config.hpp"
+#include <limits>
+
+namespace proxsuite {
+namespace helpers {
+
+template<typename Scalar>
+struct infinite_bound
+{
+  static Scalar value()
+  {
+    using namespace std;
+    return sqrt(std::numeric_limits<Scalar>::max());
+  }
+};
+
+#define PROXSUITE_DEDUCE_RET(...)                                              \
+  noexcept(noexcept(__VA_ARGS__))                                              \
+    ->typename std::remove_const<decltype(__VA_ARGS__)>::type                  \
+  {                                                                            \
+    return __VA_ARGS__;                                                        \
+  }                                                                            \
+  static_assert(true, ".")
+
+/// @brief \brief Returns the part of the expression which is lower than value
+template<typename T, typename Scalar>
+auto
+at_most(T const& expr, const Scalar value) PROXSUITE_DEDUCE_RET(
+  (expr.array() < value).select(expr, T::Constant(expr.rows(), value)));
+
+/// @brief \brief Returns the part of the expression which is greater than value
+template<typename T, typename Scalar>
+auto
+at_least(T const& expr, const Scalar value) PROXSUITE_DEDUCE_RET(
+  (expr.array() > value).select(expr, T::Constant(expr.rows(), value)));
+
+/// @brief \brief Returns the positive part of an expression
+template<typename T>
+auto
+positive_part(T const& expr)
+  PROXSUITE_DEDUCE_RET((expr.array() > 0).select(expr, T::Zero(expr.rows())));
+
+/// @brief \brief Returns the negative part of an expression
+template<typename T>
+auto
+negative_part(T const& expr)
+  PROXSUITE_DEDUCE_RET((expr.array() < 0).select(expr, T::Zero(expr.rows())));
+
+/// @brief \brief Select the components of the expression if the condition is
+/// fullfiled. Otherwise, set the component to value
+template<typename Condition, typename T, typename Scalar>
+auto
+select(Condition const& condition, T const& expr, const Scalar value)
+  PROXSUITE_DEDUCE_RET((condition).select(expr,
+                                          T::Constant(expr.rows(), value)));
+
+} // helpers
+} // proxsuite
+
+#endif // ifndef PROXSUITE_HELPERS_COMMON_HPP
```

## cmeel.prefix/include/proxsuite/helpers/instruction-set.hpp

 * *Ordering differences only*

```diff
@@ -1,275 +1,275 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file instruction-set.hpp
- */
-
-#ifndef PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
-#define PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
-
-#include <vector>
-#include <bitset>
-#include <array>
-
-#ifndef _WIN32
-#include <cpuid.h>
-#else
-#include <intrin.h>
-#endif
-
-namespace proxsuite {
-namespace helpers {
-
-namespace internal {
-inline void
-cpuid(std::array<int, 4>& cpui, int level)
-{
-#ifndef _WIN32
-  __cpuid(level, cpui[0], cpui[1], cpui[2], cpui[3]);
-#else
-  __cpuid(cpui.data(), level);
-#endif
-}
-
-inline void
-cpuidex(std::array<int, 4>& cpui, int level, int count)
-{
-#ifndef _WIN32
-  __cpuid_count(level, count, cpui[0], cpui[1], cpui[2], cpui[3]);
-#else
-  __cpuidex(cpui.data(), level, count);
-#endif
-}
-
-template<typename T = void>
-struct InstructionSetBase
-{
-protected:
-  struct Data
-  {
-    Data()
-      : nIds_{ 0 }
-      , nExIds_{ 0 }
-      , isIntel_{ false }
-      , isAMD_{ false }
-      , f_1_ECX_{ 0 }
-      , f_1_EDX_{ 0 }
-      , f_7_EBX_{ 0 }
-      , f_7_ECX_{ 0 }
-      , f_81_ECX_{ 0 }
-      , f_81_EDX_{ 0 }
-      , data_{}
-      , extdata_{}
-    {
-      std::array<int, 4> cpui;
-      typedef unsigned long long bistset_equivalent_type;
-
-      // Calling __cpuid with 0x0 as the function_id argument
-      // gets the number of the highest valid function ID.
-      internal::cpuid(cpui, 0);
-      nIds_ = cpui[0];
-
-      for (int i = 0; i <= nIds_; ++i) {
-        internal::cpuidex(cpui, i, 0);
-        data_.push_back(cpui);
-      }
-
-      // Capture vendor string
-      char vendor[0x20];
-      memset(vendor, 0, sizeof(vendor));
-      *reinterpret_cast<int*>(vendor) = data_[0][1];
-      *reinterpret_cast<int*>(vendor + 4) = data_[0][3];
-      *reinterpret_cast<int*>(vendor + 8) = data_[0][2];
-      vendor_ = vendor;
-      if (vendor_ == "GenuineIntel") {
-        isIntel_ = true;
-      } else if (vendor_ == "AuthenticAMD") {
-        isAMD_ = true;
-      }
-
-      // load bitset with flags for function 0x00000001
-      if (nIds_ >= 1) {
-        f_1_ECX_ = static_cast<bistset_equivalent_type>(data_[1][2]);
-        f_1_EDX_ = static_cast<bistset_equivalent_type>(data_[1][3]);
-      }
-
-      // load bitset with flags for function 0x00000007
-      if (nIds_ >= 7) {
-        f_7_EBX_ = static_cast<bistset_equivalent_type>(data_[7][1]);
-        f_7_ECX_ = static_cast<bistset_equivalent_type>(data_[7][2]);
-      }
-
-      // Calling __cpuid with 0x80000000 as the function_id argument
-      // gets the number of the highest valid extended ID.
-      internal::cpuid(cpui, static_cast<int>(0x80000000));
-      nExIds_ = cpui[0];
-
-      char brand[0x40];
-      memset(brand, 0, sizeof(brand));
-
-      for (int i = static_cast<int>(0x80000000); i <= nExIds_; ++i) {
-        internal::cpuidex(cpui, i, 0);
-        extdata_.push_back(cpui);
-      }
-
-      // load bitset with flags for function 0x80000001
-      if (nExIds_ >= static_cast<int>(0x80000001)) {
-        f_81_ECX_ = static_cast<bistset_equivalent_type>(extdata_[1][2]);
-        f_81_EDX_ = static_cast<bistset_equivalent_type>(extdata_[1][3]);
-      }
-
-      // Interpret CPU brand string if reported
-      if (nExIds_ >= static_cast<int>(0x80000004)) {
-        memcpy(brand, extdata_[2].data(), sizeof(cpui));
-        memcpy(brand + 16, extdata_[3].data(), sizeof(cpui));
-        memcpy(brand + 32, extdata_[4].data(), sizeof(cpui));
-        brand_ = brand;
-      }
-    };
-
-    int nIds_;
-    int nExIds_;
-    std::string vendor_;
-    std::string brand_;
-    bool isIntel_;
-    bool isAMD_;
-    std::bitset<32> f_1_ECX_;
-    std::bitset<32> f_1_EDX_;
-    std::bitset<32> f_7_EBX_;
-    std::bitset<32> f_7_ECX_;
-    std::bitset<32> f_81_ECX_;
-    std::bitset<32> f_81_EDX_;
-    std::vector<std::array<int, 4>> data_;
-    std::vector<std::array<int, 4>> extdata_;
-  };
-
-  static const Data data;
-};
-
-template<>
-const typename InstructionSetBase<>::Data InstructionSetBase<>::data =
-  typename InstructionSetBase<>::Data();
-} // namespace internal
-
-// Adapted from
-// https://docs.microsoft.com/fr-fr/cpp/intrinsics/cpuid-cpuidex?view=msvc-170
-struct InstructionSet : public internal::InstructionSetBase<>
-{
-  typedef internal::InstructionSetBase<> Base;
-
-  static std::string vendor(void) { return Base::data.vendor_; }
-  static std::string brand(void) { return Base::data.brand_; }
-
-  static bool has_SSE3(void) { return Base::data.f_1_ECX_[0]; }
-  static bool has_PCLMULQDQ(void) { return Base::data.f_1_ECX_[1]; }
-  static bool has_MONITOR(void) { return Base::data.f_1_ECX_[3]; }
-  static bool has_SSSE3(void) { return Base::data.f_1_ECX_[9]; }
-  static bool has_FMA(void) { return Base::data.f_1_ECX_[12]; }
-  static bool has_CMPXCHG16B(void) { return Base::data.f_1_ECX_[13]; }
-  static bool has_SSE41(void) { return Base::data.f_1_ECX_[19]; }
-  static bool has_SSE42(void) { return Base::data.f_1_ECX_[20]; }
-  static bool has_MOVBE(void) { return Base::data.f_1_ECX_[22]; }
-  static bool has_POPCNT(void) { return Base::data.f_1_ECX_[23]; }
-  static bool has_AES(void) { return Base::data.f_1_ECX_[25]; }
-  static bool has_XSAVE(void) { return Base::data.f_1_ECX_[26]; }
-  static bool has_OSXSAVE(void) { return Base::data.f_1_ECX_[27]; }
-  static bool has_AVX(void) { return Base::data.f_1_ECX_[28]; }
-  static bool has_F16C(void) { return Base::data.f_1_ECX_[29]; }
-  static bool has_RDRAND(void) { return Base::data.f_1_ECX_[30]; }
-
-  static bool has_MSR(void) { return Base::data.f_1_EDX_[5]; }
-  static bool has_CX8(void) { return Base::data.f_1_EDX_[8]; }
-  static bool has_SEP(void) { return Base::data.f_1_EDX_[11]; }
-  static bool has_CMOV(void) { return Base::data.f_1_EDX_[15]; }
-  static bool has_CLFSH(void) { return Base::data.f_1_EDX_[19]; }
-  static bool has_MMX(void) { return Base::data.f_1_EDX_[23]; }
-  static bool has_FXSR(void) { return Base::data.f_1_EDX_[24]; }
-  static bool has_SSE(void) { return Base::data.f_1_EDX_[25]; }
-  static bool has_SSE2(void) { return Base::data.f_1_EDX_[26]; }
-
-  static bool has_FSGSBASE(void) { return Base::data.f_7_EBX_[0]; }
-  static bool has_AVX512VBMI(void) { return Base::data.f_7_EBX_[1]; }
-  static bool has_BMI1(void) { return Base::data.f_7_EBX_[3]; }
-  static bool has_HLE(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_7_EBX_[4];
-  }
-  static bool has_AVX2(void) { return Base::data.f_7_EBX_[5]; }
-  static bool has_BMI2(void) { return Base::data.f_7_EBX_[8]; }
-  static bool has_ERMS(void) { return Base::data.f_7_EBX_[9]; }
-  static bool has_INVPCID(void) { return Base::data.f_7_EBX_[10]; }
-  static bool has_RTM(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_7_EBX_[11];
-  }
-  static bool has_AVX512F(void) { return Base::data.f_7_EBX_[16]; }
-  static bool has_AVX512DQ(void) { return Base::data.f_7_EBX_[17]; }
-  static bool has_RDSEED(void) { return Base::data.f_7_EBX_[18]; }
-  static bool has_ADX(void) { return Base::data.f_7_EBX_[19]; }
-  static bool has_AVX512IFMA(void) { return Base::data.f_7_EBX_[21]; }
-  static bool has_AVX512PF(void) { return Base::data.f_7_EBX_[26]; }
-  static bool has_AVX512ER(void) { return Base::data.f_7_EBX_[27]; }
-  static bool has_AVX512CD(void) { return Base::data.f_7_EBX_[28]; }
-  static bool has_SHA(void) { return Base::data.f_7_EBX_[29]; }
-  static bool has_AVX512BW(void) { return Base::data.f_7_EBX_[30]; }
-  static bool has_AVX512VL(void) { return Base::data.f_7_EBX_[31]; }
-
-  static bool has_PREFETCHWT1(void) { return Base::data.f_7_ECX_[0]; }
-
-  static bool has_LAHF(void) { return Base::data.f_81_ECX_[0]; }
-  static bool has_LZCNT(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_81_ECX_[5];
-  }
-  static bool has_ABM(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_ECX_[5];
-  }
-  static bool has_SSE4a(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_ECX_[6];
-  }
-  static bool has_XOP(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_ECX_[11];
-  }
-  static bool has_FMA4(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_ECX_[16];
-  }
-  static bool has_TBM(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_ECX_[21];
-  }
-
-  static bool has_SYSCALL(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_81_EDX_[11];
-  }
-  static bool has_MMXEXT(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_EDX_[22];
-  }
-  static bool has_RDTSCP(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_81_EDX_[27];
-  }
-  static bool has_x64(void)
-  {
-    return Base::data.isIntel_ && Base::data.f_81_EDX_[29];
-  }
-  static bool has_3DNOWEXT(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_EDX_[30];
-  }
-  static bool has_3DNOW(void)
-  {
-    return Base::data.isAMD_ && Base::data.f_81_EDX_[31];
-  }
-};
-
-} // helpers
-} // proxsuite
-
-#endif // ifndef PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file instruction-set.hpp
+ */
+
+#ifndef PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
+#define PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
+
+#include <vector>
+#include <bitset>
+#include <array>
+
+#ifndef _WIN32
+#include <cpuid.h>
+#else
+#include <intrin.h>
+#endif
+
+namespace proxsuite {
+namespace helpers {
+
+namespace internal {
+inline void
+cpuid(std::array<int, 4>& cpui, int level)
+{
+#ifndef _WIN32
+  __cpuid(level, cpui[0], cpui[1], cpui[2], cpui[3]);
+#else
+  __cpuid(cpui.data(), level);
+#endif
+}
+
+inline void
+cpuidex(std::array<int, 4>& cpui, int level, int count)
+{
+#ifndef _WIN32
+  __cpuid_count(level, count, cpui[0], cpui[1], cpui[2], cpui[3]);
+#else
+  __cpuidex(cpui.data(), level, count);
+#endif
+}
+
+template<typename T = void>
+struct InstructionSetBase
+{
+protected:
+  struct Data
+  {
+    Data()
+      : nIds_{ 0 }
+      , nExIds_{ 0 }
+      , isIntel_{ false }
+      , isAMD_{ false }
+      , f_1_ECX_{ 0 }
+      , f_1_EDX_{ 0 }
+      , f_7_EBX_{ 0 }
+      , f_7_ECX_{ 0 }
+      , f_81_ECX_{ 0 }
+      , f_81_EDX_{ 0 }
+      , data_{}
+      , extdata_{}
+    {
+      std::array<int, 4> cpui;
+      typedef unsigned long long bistset_equivalent_type;
+
+      // Calling __cpuid with 0x0 as the function_id argument
+      // gets the number of the highest valid function ID.
+      internal::cpuid(cpui, 0);
+      nIds_ = cpui[0];
+
+      for (int i = 0; i <= nIds_; ++i) {
+        internal::cpuidex(cpui, i, 0);
+        data_.push_back(cpui);
+      }
+
+      // Capture vendor string
+      char vendor[0x20];
+      memset(vendor, 0, sizeof(vendor));
+      *reinterpret_cast<int*>(vendor) = data_[0][1];
+      *reinterpret_cast<int*>(vendor + 4) = data_[0][3];
+      *reinterpret_cast<int*>(vendor + 8) = data_[0][2];
+      vendor_ = vendor;
+      if (vendor_ == "GenuineIntel") {
+        isIntel_ = true;
+      } else if (vendor_ == "AuthenticAMD") {
+        isAMD_ = true;
+      }
+
+      // load bitset with flags for function 0x00000001
+      if (nIds_ >= 1) {
+        f_1_ECX_ = static_cast<bistset_equivalent_type>(data_[1][2]);
+        f_1_EDX_ = static_cast<bistset_equivalent_type>(data_[1][3]);
+      }
+
+      // load bitset with flags for function 0x00000007
+      if (nIds_ >= 7) {
+        f_7_EBX_ = static_cast<bistset_equivalent_type>(data_[7][1]);
+        f_7_ECX_ = static_cast<bistset_equivalent_type>(data_[7][2]);
+      }
+
+      // Calling __cpuid with 0x80000000 as the function_id argument
+      // gets the number of the highest valid extended ID.
+      internal::cpuid(cpui, static_cast<int>(0x80000000));
+      nExIds_ = cpui[0];
+
+      char brand[0x40];
+      memset(brand, 0, sizeof(brand));
+
+      for (int i = static_cast<int>(0x80000000); i <= nExIds_; ++i) {
+        internal::cpuidex(cpui, i, 0);
+        extdata_.push_back(cpui);
+      }
+
+      // load bitset with flags for function 0x80000001
+      if (nExIds_ >= static_cast<int>(0x80000001)) {
+        f_81_ECX_ = static_cast<bistset_equivalent_type>(extdata_[1][2]);
+        f_81_EDX_ = static_cast<bistset_equivalent_type>(extdata_[1][3]);
+      }
+
+      // Interpret CPU brand string if reported
+      if (nExIds_ >= static_cast<int>(0x80000004)) {
+        memcpy(brand, extdata_[2].data(), sizeof(cpui));
+        memcpy(brand + 16, extdata_[3].data(), sizeof(cpui));
+        memcpy(brand + 32, extdata_[4].data(), sizeof(cpui));
+        brand_ = brand;
+      }
+    };
+
+    int nIds_;
+    int nExIds_;
+    std::string vendor_;
+    std::string brand_;
+    bool isIntel_;
+    bool isAMD_;
+    std::bitset<32> f_1_ECX_;
+    std::bitset<32> f_1_EDX_;
+    std::bitset<32> f_7_EBX_;
+    std::bitset<32> f_7_ECX_;
+    std::bitset<32> f_81_ECX_;
+    std::bitset<32> f_81_EDX_;
+    std::vector<std::array<int, 4>> data_;
+    std::vector<std::array<int, 4>> extdata_;
+  };
+
+  static const Data data;
+};
+
+template<>
+const typename InstructionSetBase<>::Data InstructionSetBase<>::data =
+  typename InstructionSetBase<>::Data();
+} // namespace internal
+
+// Adapted from
+// https://docs.microsoft.com/fr-fr/cpp/intrinsics/cpuid-cpuidex?view=msvc-170
+struct InstructionSet : public internal::InstructionSetBase<>
+{
+  typedef internal::InstructionSetBase<> Base;
+
+  static std::string vendor(void) { return Base::data.vendor_; }
+  static std::string brand(void) { return Base::data.brand_; }
+
+  static bool has_SSE3(void) { return Base::data.f_1_ECX_[0]; }
+  static bool has_PCLMULQDQ(void) { return Base::data.f_1_ECX_[1]; }
+  static bool has_MONITOR(void) { return Base::data.f_1_ECX_[3]; }
+  static bool has_SSSE3(void) { return Base::data.f_1_ECX_[9]; }
+  static bool has_FMA(void) { return Base::data.f_1_ECX_[12]; }
+  static bool has_CMPXCHG16B(void) { return Base::data.f_1_ECX_[13]; }
+  static bool has_SSE41(void) { return Base::data.f_1_ECX_[19]; }
+  static bool has_SSE42(void) { return Base::data.f_1_ECX_[20]; }
+  static bool has_MOVBE(void) { return Base::data.f_1_ECX_[22]; }
+  static bool has_POPCNT(void) { return Base::data.f_1_ECX_[23]; }
+  static bool has_AES(void) { return Base::data.f_1_ECX_[25]; }
+  static bool has_XSAVE(void) { return Base::data.f_1_ECX_[26]; }
+  static bool has_OSXSAVE(void) { return Base::data.f_1_ECX_[27]; }
+  static bool has_AVX(void) { return Base::data.f_1_ECX_[28]; }
+  static bool has_F16C(void) { return Base::data.f_1_ECX_[29]; }
+  static bool has_RDRAND(void) { return Base::data.f_1_ECX_[30]; }
+
+  static bool has_MSR(void) { return Base::data.f_1_EDX_[5]; }
+  static bool has_CX8(void) { return Base::data.f_1_EDX_[8]; }
+  static bool has_SEP(void) { return Base::data.f_1_EDX_[11]; }
+  static bool has_CMOV(void) { return Base::data.f_1_EDX_[15]; }
+  static bool has_CLFSH(void) { return Base::data.f_1_EDX_[19]; }
+  static bool has_MMX(void) { return Base::data.f_1_EDX_[23]; }
+  static bool has_FXSR(void) { return Base::data.f_1_EDX_[24]; }
+  static bool has_SSE(void) { return Base::data.f_1_EDX_[25]; }
+  static bool has_SSE2(void) { return Base::data.f_1_EDX_[26]; }
+
+  static bool has_FSGSBASE(void) { return Base::data.f_7_EBX_[0]; }
+  static bool has_AVX512VBMI(void) { return Base::data.f_7_EBX_[1]; }
+  static bool has_BMI1(void) { return Base::data.f_7_EBX_[3]; }
+  static bool has_HLE(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_7_EBX_[4];
+  }
+  static bool has_AVX2(void) { return Base::data.f_7_EBX_[5]; }
+  static bool has_BMI2(void) { return Base::data.f_7_EBX_[8]; }
+  static bool has_ERMS(void) { return Base::data.f_7_EBX_[9]; }
+  static bool has_INVPCID(void) { return Base::data.f_7_EBX_[10]; }
+  static bool has_RTM(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_7_EBX_[11];
+  }
+  static bool has_AVX512F(void) { return Base::data.f_7_EBX_[16]; }
+  static bool has_AVX512DQ(void) { return Base::data.f_7_EBX_[17]; }
+  static bool has_RDSEED(void) { return Base::data.f_7_EBX_[18]; }
+  static bool has_ADX(void) { return Base::data.f_7_EBX_[19]; }
+  static bool has_AVX512IFMA(void) { return Base::data.f_7_EBX_[21]; }
+  static bool has_AVX512PF(void) { return Base::data.f_7_EBX_[26]; }
+  static bool has_AVX512ER(void) { return Base::data.f_7_EBX_[27]; }
+  static bool has_AVX512CD(void) { return Base::data.f_7_EBX_[28]; }
+  static bool has_SHA(void) { return Base::data.f_7_EBX_[29]; }
+  static bool has_AVX512BW(void) { return Base::data.f_7_EBX_[30]; }
+  static bool has_AVX512VL(void) { return Base::data.f_7_EBX_[31]; }
+
+  static bool has_PREFETCHWT1(void) { return Base::data.f_7_ECX_[0]; }
+
+  static bool has_LAHF(void) { return Base::data.f_81_ECX_[0]; }
+  static bool has_LZCNT(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_81_ECX_[5];
+  }
+  static bool has_ABM(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_ECX_[5];
+  }
+  static bool has_SSE4a(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_ECX_[6];
+  }
+  static bool has_XOP(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_ECX_[11];
+  }
+  static bool has_FMA4(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_ECX_[16];
+  }
+  static bool has_TBM(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_ECX_[21];
+  }
+
+  static bool has_SYSCALL(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_81_EDX_[11];
+  }
+  static bool has_MMXEXT(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_EDX_[22];
+  }
+  static bool has_RDTSCP(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_81_EDX_[27];
+  }
+  static bool has_x64(void)
+  {
+    return Base::data.isIntel_ && Base::data.f_81_EDX_[29];
+  }
+  static bool has_3DNOWEXT(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_EDX_[30];
+  }
+  static bool has_3DNOW(void)
+  {
+    return Base::data.isAMD_ && Base::data.f_81_EDX_[31];
+  }
+};
+
+} // helpers
+} // proxsuite
+
+#endif // ifndef PROXSUITE_HELPERS_INSTRUCTION_SET_HPP
```

## cmeel.prefix/include/proxsuite/helpers/optional.hpp

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file optional.hpp
- */
-
-#ifndef PROXSUITE_HELPERS_OPTIONAL_HPP
-#define PROXSUITE_HELPERS_OPTIONAL_HPP
-
-#include <proxsuite/fwd.hpp>
-
-#ifdef PROXSUITE_WITH_CPP_17
-#include <optional>
-#else
-#include <proxsuite/helpers/tl-optional.hpp>
-#endif
-
-namespace proxsuite {
-#ifdef PROXSUITE_WITH_CPP_17
-template<class T>
-using optional = std::optional<T>;
-using nullopt_t = std::nullopt_t;
-inline constexpr nullopt_t nullopt = std::nullopt;
-#else
-namespace detail {
-// Source boost: https://www.boost.org/doc/libs/1_74_0/boost/none.hpp
-// the trick here is to make instance defined once as a global but in a header
-// file
-template<typename T>
-struct nullopt_instance
-{
-  static const T instance;
-};
-template<typename T>
-const T nullopt_instance<T>::instance =
-  T(tl::nullopt); // global, but because 'tis a template, no cpp file required
-} // namespace detail
-template<class T>
-using optional = tl::optional<T>;
-using nullopt_t = tl::nullopt_t;
-constexpr nullopt_t nullopt = detail::nullopt_instance<tl::nullopt_t>::instance;
-#endif
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_HELPERS_OPTIONAL_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file optional.hpp
+ */
+
+#ifndef PROXSUITE_HELPERS_OPTIONAL_HPP
+#define PROXSUITE_HELPERS_OPTIONAL_HPP
+
+#include <proxsuite/fwd.hpp>
+
+#ifdef PROXSUITE_WITH_CPP_17
+#include <optional>
+#else
+#include <proxsuite/helpers/tl-optional.hpp>
+#endif
+
+namespace proxsuite {
+#ifdef PROXSUITE_WITH_CPP_17
+template<class T>
+using optional = std::optional<T>;
+using nullopt_t = std::nullopt_t;
+inline constexpr nullopt_t nullopt = std::nullopt;
+#else
+namespace detail {
+// Source boost: https://www.boost.org/doc/libs/1_74_0/boost/none.hpp
+// the trick here is to make instance defined once as a global but in a header
+// file
+template<typename T>
+struct nullopt_instance
+{
+  static const T instance;
+};
+template<typename T>
+const T nullopt_instance<T>::instance =
+  T(tl::nullopt); // global, but because 'tis a template, no cpp file required
+} // namespace detail
+template<class T>
+using optional = tl::optional<T>;
+using nullopt_t = tl::nullopt_t;
+constexpr nullopt_t nullopt = detail::nullopt_instance<tl::nullopt_t>::instance;
+#endif
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_HELPERS_OPTIONAL_HPP */
```

## cmeel.prefix/include/proxsuite/helpers/tl-optional.hpp

 * *Ordering differences only*

```diff
@@ -1,2472 +1,2472 @@
-
-///
-// optional - An implementation of std::optional with extensions
-// Written in 2017 by Sy Brand (tartanllama@gmail.com, @TartanLlama)
-//
-// Documentation available at https://tl.tartanllama.xyz/
-//
-// To the extent possible under law, the author(s) have dedicated all
-// copyright and related and neighboring rights to this software to the
-// public domain worldwide. This software is distributed without any warranty.
-//
-// You should have received a copy of the CC0 Public Domain Dedication
-// along with this software. If not, see
-// <http://creativecommons.org/publicdomain/zero/1.0/>.
-///
-
-#ifndef TL_OPTIONAL_HPP
-#define TL_OPTIONAL_HPP
-
-#define TL_OPTIONAL_VERSION_MAJOR 1
-#define TL_OPTIONAL_VERSION_MINOR 0
-#define TL_OPTIONAL_VERSION_PATCH 0
-
-#include <exception>
-#include <functional>
-#include <new>
-#include <type_traits>
-#include <utility>
-
-#if (defined(_MSC_VER) && _MSC_VER == 1900)
-#define TL_OPTIONAL_MSVC2015
-#endif
-
-#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
-     !defined(__clang__))
-#define TL_OPTIONAL_GCC49
-#endif
-
-#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \
-     !defined(__clang__))
-#define TL_OPTIONAL_GCC54
-#endif
-
-#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \
-     !defined(__clang__))
-#define TL_OPTIONAL_GCC55
-#endif
-
-#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
-     !defined(__clang__))
-// GCC < 5 doesn't support overloading on const&& for member functions
-#define TL_OPTIONAL_NO_CONSTRR
-
-// GCC < 5 doesn't support some standard C++11 type traits
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
-  std::has_trivial_copy_constructor<T>::value
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
-  std::has_trivial_copy_assign<T>::value
-
-// This one will be different for GCC 5.7 if it's ever supported
-#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
-  std::is_trivially_destructible<T>::value
-
-// GCC 5 < v < 8 has a bug in is_trivially_copy_constructible which breaks
-// std::vector for non-copyable types
-#elif (defined(__GNUC__) && __GNUC__ < 8 && !defined(__clang__))
-#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
-#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
-namespace tl {
-namespace detail {
-template<class T>
-struct is_trivially_copy_constructible : std::is_trivially_copy_constructible<T>
-{};
-#ifdef _GLIBCXX_VECTOR
-template<class T, class A>
-struct is_trivially_copy_constructible<std::vector<T, A>>
-  : std::is_trivially_copy_constructible<T>
-{};
-#endif
-}
-}
-#endif
-
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
-  tl::detail::is_trivially_copy_constructible<T>::value
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
-  std::is_trivially_copy_assignable<T>::value
-#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
-  std::is_trivially_destructible<T>::value
-#else
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
-  std::is_trivially_copy_constructible<T>::value
-#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
-  std::is_trivially_copy_assignable<T>::value
-#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
-  std::is_trivially_destructible<T>::value
-#endif
-
-#if __cplusplus > 201103L
-#define TL_OPTIONAL_CXX14
-#endif
-
-// constexpr implies const in C++11, not C++14
-#if (__cplusplus == 201103L || defined(TL_OPTIONAL_MSVC2015) ||                \
-     defined(TL_OPTIONAL_GCC49))
-#define TL_OPTIONAL_11_CONSTEXPR
-#else
-#define TL_OPTIONAL_11_CONSTEXPR constexpr
-#endif
-
-namespace tl {
-#ifndef TL_MONOSTATE_INPLACE_MUTEX
-#define TL_MONOSTATE_INPLACE_MUTEX
-/// Used to represent an optional with no data; essentially a bool
-class monostate
-{};
-
-///  A tag type to tell optional to construct its value in-place
-struct in_place_t
-{
-  explicit in_place_t() = default;
-};
-/// A tag to tell optional to construct its value in-place
-static constexpr in_place_t in_place{};
-#endif
-
-template<class T>
-class optional;
-
-namespace detail {
-#ifndef TL_TRAITS_MUTEX
-#define TL_TRAITS_MUTEX
-// C++14-style aliases for brevity
-template<class T>
-using remove_const_t = typename std::remove_const<T>::type;
-template<class T>
-using remove_reference_t = typename std::remove_reference<T>::type;
-template<class T>
-using decay_t = typename std::decay<T>::type;
-template<bool E, class T = void>
-using enable_if_t = typename std::enable_if<E, T>::type;
-template<bool B, class T, class F>
-using conditional_t = typename std::conditional<B, T, F>::type;
-
-// std::conjunction from C++17
-template<class...>
-struct conjunction : std::true_type
-{};
-template<class B>
-struct conjunction<B> : B
-{};
-template<class B, class... Bs>
-struct conjunction<B, Bs...>
-  : std::conditional<bool(B::value), conjunction<Bs...>, B>::type
-{};
-
-#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
-#define TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
-#endif
-
-// In C++11 mode, there's an issue in libc++'s std::mem_fn
-// which results in a hard-error when using it in a noexcept expression
-// in some cases. This is a check to workaround the common failing case.
-#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
-template<class T>
-struct is_pointer_to_non_const_member_func : std::false_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)> : std::true_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)&>
-  : std::true_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &&>
-  : std::true_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile>
-  : std::true_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile&>
-  : std::true_type
-{};
-template<class T, class Ret, class... Args>
-struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile&&>
-  : std::true_type
-{};
-
-template<class T>
-struct is_const_or_const_ref : std::false_type
-{};
-template<class T>
-struct is_const_or_const_ref<T const&> : std::true_type
-{};
-template<class T>
-struct is_const_or_const_ref<T const> : std::true_type
-{};
-#endif
-
-// std::invoke from C++17
-// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
-template<
-  typename Fn,
-  typename... Args,
-#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
-  typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value &&
-                           is_const_or_const_ref<Args...>::value)>,
-#endif
-  typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>,
-  int = 0>
-constexpr auto
-invoke(Fn&& f, Args&&... args) noexcept(
-  noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
-  -> decltype(std::mem_fn(f)(std::forward<Args>(args)...))
-{
-  return std::mem_fn(f)(std::forward<Args>(args)...);
-}
-
-template<typename Fn,
-         typename... Args,
-         typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
-constexpr auto
-invoke(Fn&& f, Args&&... args) noexcept(
-  noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
-  -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...))
-{
-  return std::forward<Fn>(f)(std::forward<Args>(args)...);
-}
-
-// std::invoke_result from C++17
-template<class F, class, class... Us>
-struct invoke_result_impl;
-
-template<class F, class... Us>
-struct invoke_result_impl<
-  F,
-  decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
-  Us...>
-{
-  using type =
-    decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
-};
-
-template<class F, class... Us>
-using invoke_result = invoke_result_impl<F, void, Us...>;
-
-template<class F, class... Us>
-using invoke_result_t = typename invoke_result<F, Us...>::type;
-
-#if defined(_MSC_VER) && _MSC_VER <= 1900
-// TODO make a version which works with MSVC 2015
-template<class T, class U = T>
-struct is_swappable : std::true_type
-{};
-
-template<class T, class U = T>
-struct is_nothrow_swappable : std::true_type
-{};
-#else
-// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
-namespace swap_adl_tests {
-// if swap ADL finds this then it would call std::swap otherwise (same
-// signature)
-struct tag
-{};
-
-template<class T>
-tag
-swap(T&, T&);
-template<class T, std::size_t N>
-tag swap(T (&a)[N], T (&b)[N]);
-
-// helper functions to test if an unqualified swap is possible, and if it
-// becomes std::swap
-template<class, class>
-std::false_type
-can_swap(...) noexcept(false);
-template<class T,
-         class U,
-         class = decltype(swap(std::declval<T&>(), std::declval<U&>()))>
-std::true_type
-can_swap(int) noexcept(noexcept(swap(std::declval<T&>(), std::declval<U&>())));
-
-template<class, class>
-std::false_type
-uses_std(...);
-template<class T, class U>
-std::is_same<decltype(swap(std::declval<T&>(), std::declval<U&>())), tag>
-uses_std(int);
-
-template<class T>
-struct is_std_swap_noexcept
-  : std::integral_constant<bool,
-                           std::is_nothrow_move_constructible<T>::value &&
-                             std::is_nothrow_move_assignable<T>::value>
-{};
-
-template<class T, std::size_t N>
-struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T>
-{};
-
-template<class T, class U>
-struct is_adl_swap_noexcept
-  : std::integral_constant<bool, noexcept(can_swap<T, U>(0))>
-{};
-} // namespace swap_adl_tests
-
-template<class T, class U = T>
-struct is_swappable
-  : std::integral_constant<
-      bool,
-      decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
-        (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
-         (std::is_move_assignable<T>::value &&
-          std::is_move_constructible<T>::value))>
-{};
-
-template<class T, std::size_t N>
-struct is_swappable<T[N], T[N]>
-  : std::integral_constant<
-      bool,
-      decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
-        (!decltype(detail::swap_adl_tests::uses_std<T[N], T[N]>(0))::value ||
-         is_swappable<T, T>::value)>
-{};
-
-template<class T, class U = T>
-struct is_nothrow_swappable
-  : std::integral_constant<
-      bool,
-      is_swappable<T, U>::value &&
-        ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
-          detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
-         (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
-          detail::swap_adl_tests::is_adl_swap_noexcept<T, U>::value))>
-{};
-#endif
-#endif
-
-// std::void_t from C++17
-template<class...>
-struct voider
-{
-  using type = void;
-};
-template<class... Ts>
-using void_t = typename voider<Ts...>::type;
-
-// Trait for checking if a type is a tl::optional
-template<class T>
-struct is_optional_impl : std::false_type
-{};
-template<class T>
-struct is_optional_impl<optional<T>> : std::true_type
-{};
-template<class T>
-using is_optional = is_optional_impl<decay_t<T>>;
-
-// Change void to tl::monostate
-template<class U>
-using fixup_void = conditional_t<std::is_void<U>::value, monostate, U>;
-
-template<class F, class U, class = invoke_result_t<F, U>>
-using get_map_return = optional<fixup_void<invoke_result_t<F, U>>>;
-
-// Check if invoking F for some Us returns void
-template<class F, class = void, class... U>
-struct returns_void_impl;
-template<class F, class... U>
-struct returns_void_impl<F, void_t<invoke_result_t<F, U...>>, U...>
-  : std::is_void<invoke_result_t<F, U...>>
-{};
-template<class F, class... U>
-using returns_void = returns_void_impl<F, void, U...>;
-
-template<class T, class... U>
-using enable_if_ret_void = enable_if_t<returns_void<T&&, U...>::value>;
-
-template<class T, class... U>
-using disable_if_ret_void = enable_if_t<!returns_void<T&&, U...>::value>;
-
-template<class T, class U>
-using enable_forward_value =
-  detail::enable_if_t<std::is_constructible<T, U&&>::value &&
-                      !std::is_same<detail::decay_t<U>, in_place_t>::value &&
-                      !std::is_same<optional<T>, detail::decay_t<U>>::value>;
-
-template<class T, class U, class Other>
-using enable_from_other =
-  detail::enable_if_t<std::is_constructible<T, Other>::value &&
-                      !std::is_constructible<T, optional<U>&>::value &&
-                      !std::is_constructible<T, optional<U>&&>::value &&
-                      !std::is_constructible<T, const optional<U>&>::value &&
-                      !std::is_constructible<T, const optional<U>&&>::value &&
-                      !std::is_convertible<optional<U>&, T>::value &&
-                      !std::is_convertible<optional<U>&&, T>::value &&
-                      !std::is_convertible<const optional<U>&, T>::value &&
-                      !std::is_convertible<const optional<U>&&, T>::value>;
-
-template<class T, class U>
-using enable_assign_forward = detail::enable_if_t<
-  !std::is_same<optional<T>, detail::decay_t<U>>::value &&
-  !detail::conjunction<std::is_scalar<T>,
-                       std::is_same<T, detail::decay_t<U>>>::value &&
-  std::is_constructible<T, U>::value && std::is_assignable<T&, U>::value>;
-
-template<class T, class U, class Other>
-using enable_assign_from_other =
-  detail::enable_if_t<std::is_constructible<T, Other>::value &&
-                      std::is_assignable<T&, Other>::value &&
-                      !std::is_constructible<T, optional<U>&>::value &&
-                      !std::is_constructible<T, optional<U>&&>::value &&
-                      !std::is_constructible<T, const optional<U>&>::value &&
-                      !std::is_constructible<T, const optional<U>&&>::value &&
-                      !std::is_convertible<optional<U>&, T>::value &&
-                      !std::is_convertible<optional<U>&&, T>::value &&
-                      !std::is_convertible<const optional<U>&, T>::value &&
-                      !std::is_convertible<const optional<U>&&, T>::value &&
-                      !std::is_assignable<T&, optional<U>&>::value &&
-                      !std::is_assignable<T&, optional<U>&&>::value &&
-                      !std::is_assignable<T&, const optional<U>&>::value &&
-                      !std::is_assignable<T&, const optional<U>&&>::value>;
-
-// The storage base manages the actual storage, and correctly propagates
-// trivial destruction from T. This case is for when T is not trivially
-// destructible.
-template<class T, bool = ::std::is_trivially_destructible<T>::value>
-struct optional_storage_base
-{
-  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
-    : m_dummy()
-    , m_has_value(false)
-  {
-  }
-
-  template<class... U>
-  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U&&... u)
-    : m_value(std::forward<U>(u)...)
-    , m_has_value(true)
-  {
-  }
-
-  ~optional_storage_base()
-  {
-    if (m_has_value) {
-      m_value.~T();
-      m_has_value = false;
-    }
-  }
-
-  struct dummy
-  {};
-  union
-  {
-    dummy m_dummy;
-    T m_value;
-  };
-
-  bool m_has_value;
-};
-
-// This case is for when T is trivially destructible.
-template<class T>
-struct optional_storage_base<T, true>
-{
-  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
-    : m_dummy()
-    , m_has_value(false)
-  {
-  }
-
-  template<class... U>
-  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U&&... u)
-    : m_value(std::forward<U>(u)...)
-    , m_has_value(true)
-  {
-  }
-
-  // No destructor, so this class is trivially destructible
-
-  struct dummy
-  {};
-  union
-  {
-    dummy m_dummy;
-    T m_value;
-  };
-
-  bool m_has_value = false;
-};
-
-// This base class provides some handy member functions which can be used in
-// further derived classes
-template<class T>
-struct optional_operations_base : optional_storage_base<T>
-{
-  using optional_storage_base<T>::optional_storage_base;
-
-  void hard_reset() noexcept
-  {
-    get().~T();
-    this->m_has_value = false;
-  }
-
-  template<class... Args>
-  void construct(Args&&... args) noexcept
-  {
-    new (std::addressof(this->m_value)) T(std::forward<Args>(args)...);
-    this->m_has_value = true;
-  }
-
-  template<class Opt>
-  void assign(Opt&& rhs)
-  {
-    if (this->has_value()) {
-      if (rhs.has_value()) {
-        this->m_value = std::forward<Opt>(rhs).get();
-      } else {
-        this->m_value.~T();
-        this->m_has_value = false;
-      }
-    }
-
-    else if (rhs.has_value()) {
-      construct(std::forward<Opt>(rhs).get());
-    }
-  }
-
-  bool has_value() const { return this->m_has_value; }
-
-  TL_OPTIONAL_11_CONSTEXPR T& get() & { return this->m_value; }
-  TL_OPTIONAL_11_CONSTEXPR const T& get() const& { return this->m_value; }
-  TL_OPTIONAL_11_CONSTEXPR T&& get() && { return std::move(this->m_value); }
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr const T&& get() const&& { return std::move(this->m_value); }
-#endif
-};
-
-// This class manages conditionally having a trivial copy constructor
-// This specialization is for when T is trivially copy constructible
-template<class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>
-struct optional_copy_base : optional_operations_base<T>
-{
-  using optional_operations_base<T>::optional_operations_base;
-};
-
-// This specialization is for when T is not trivially copy constructible
-template<class T>
-struct optional_copy_base<T, false> : optional_operations_base<T>
-{
-  using optional_operations_base<T>::optional_operations_base;
-
-  optional_copy_base() = default;
-  optional_copy_base(const optional_copy_base& rhs)
-    : optional_operations_base<T>()
-  {
-    if (rhs.has_value()) {
-      this->construct(rhs.get());
-    } else {
-      this->m_has_value = false;
-    }
-  }
-
-  optional_copy_base(optional_copy_base&& rhs) = default;
-  optional_copy_base& operator=(const optional_copy_base& rhs) = default;
-  optional_copy_base& operator=(optional_copy_base&& rhs) = default;
-};
-
-// This class manages conditionally having a trivial move constructor
-// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
-// doesn't implement an analogue to std::is_trivially_move_constructible. We
-// have to make do with a non-trivial move constructor even if T is trivially
-// move constructible
-#ifndef TL_OPTIONAL_GCC49
-template<class T, bool = std::is_trivially_move_constructible<T>::value>
-struct optional_move_base : optional_copy_base<T>
-{
-  using optional_copy_base<T>::optional_copy_base;
-};
-#else
-template<class T, bool = false>
-struct optional_move_base;
-#endif
-template<class T>
-struct optional_move_base<T, false> : optional_copy_base<T>
-{
-  using optional_copy_base<T>::optional_copy_base;
-
-  optional_move_base() = default;
-  optional_move_base(const optional_move_base& rhs) = default;
-
-  optional_move_base(optional_move_base&& rhs) noexcept(
-    std::is_nothrow_move_constructible<T>::value)
-  {
-    if (rhs.has_value()) {
-      this->construct(std::move(rhs.get()));
-    } else {
-      this->m_has_value = false;
-    }
-  }
-  optional_move_base& operator=(const optional_move_base& rhs) = default;
-  optional_move_base& operator=(optional_move_base&& rhs) = default;
-};
-
-// This class manages conditionally having a trivial copy assignment operator
-template<class T,
-         bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) &&
-                TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) &&
-                TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)>
-struct optional_copy_assign_base : optional_move_base<T>
-{
-  using optional_move_base<T>::optional_move_base;
-};
-
-template<class T>
-struct optional_copy_assign_base<T, false> : optional_move_base<T>
-{
-  using optional_move_base<T>::optional_move_base;
-
-  optional_copy_assign_base() = default;
-  optional_copy_assign_base(const optional_copy_assign_base& rhs) = default;
-
-  optional_copy_assign_base(optional_copy_assign_base&& rhs) = default;
-  optional_copy_assign_base& operator=(const optional_copy_assign_base& rhs)
-  {
-    this->assign(rhs);
-    return *this;
-  }
-  optional_copy_assign_base& operator=(optional_copy_assign_base&& rhs) =
-    default;
-};
-
-// This class manages conditionally having a trivial move assignment operator
-// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
-// doesn't implement an analogue to std::is_trivially_move_assignable. We have
-// to make do with a non-trivial move assignment operator even if T is trivially
-// move assignable
-#ifndef TL_OPTIONAL_GCC49
-template<class T,
-         bool = std::is_trivially_destructible<T>::value&&
-           std::is_trivially_move_constructible<T>::value&&
-             std::is_trivially_move_assignable<T>::value>
-struct optional_move_assign_base : optional_copy_assign_base<T>
-{
-  using optional_copy_assign_base<T>::optional_copy_assign_base;
-};
-#else
-template<class T, bool = false>
-struct optional_move_assign_base;
-#endif
-
-template<class T>
-struct optional_move_assign_base<T, false> : optional_copy_assign_base<T>
-{
-  using optional_copy_assign_base<T>::optional_copy_assign_base;
-
-  optional_move_assign_base() = default;
-  optional_move_assign_base(const optional_move_assign_base& rhs) = default;
-
-  optional_move_assign_base(optional_move_assign_base&& rhs) = default;
-
-  optional_move_assign_base& operator=(const optional_move_assign_base& rhs) =
-    default;
-
-  optional_move_assign_base&
-  operator=(optional_move_assign_base&& rhs) noexcept(
-    std::is_nothrow_move_constructible<T>::value&&
-      std::is_nothrow_move_assignable<T>::value)
-  {
-    this->assign(std::move(rhs));
-    return *this;
-  }
-};
-
-// optional_delete_ctor_base will conditionally delete copy and move
-// constructors depending on whether T is copy/move constructible
-template<class T,
-         bool EnableCopy = std::is_copy_constructible<T>::value,
-         bool EnableMove = std::is_move_constructible<T>::value>
-struct optional_delete_ctor_base
-{
-  optional_delete_ctor_base() = default;
-  optional_delete_ctor_base(const optional_delete_ctor_base&) = default;
-  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = default;
-  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
-    default;
-  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
-    default;
-};
-
-template<class T>
-struct optional_delete_ctor_base<T, true, false>
-{
-  optional_delete_ctor_base() = default;
-  optional_delete_ctor_base(const optional_delete_ctor_base&) = default;
-  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = delete;
-  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
-    default;
-  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
-    default;
-};
-
-template<class T>
-struct optional_delete_ctor_base<T, false, true>
-{
-  optional_delete_ctor_base() = default;
-  optional_delete_ctor_base(const optional_delete_ctor_base&) = delete;
-  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = default;
-  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
-    default;
-  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
-    default;
-};
-
-template<class T>
-struct optional_delete_ctor_base<T, false, false>
-{
-  optional_delete_ctor_base() = default;
-  optional_delete_ctor_base(const optional_delete_ctor_base&) = delete;
-  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = delete;
-  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
-    default;
-  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
-    default;
-};
-
-// optional_delete_assign_base will conditionally delete copy and move
-// constructors depending on whether T is copy/move constructible + assignable
-template<class T,
-         bool EnableCopy = (std::is_copy_constructible<T>::value &&
-                            std::is_copy_assignable<T>::value),
-         bool EnableMove = (std::is_move_constructible<T>::value &&
-                            std::is_move_assignable<T>::value)>
-struct optional_delete_assign_base
-{
-  optional_delete_assign_base() = default;
-  optional_delete_assign_base(const optional_delete_assign_base&) = default;
-  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
-  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
-    default;
-  optional_delete_assign_base& operator=(
-    optional_delete_assign_base&&) noexcept = default;
-};
-
-template<class T>
-struct optional_delete_assign_base<T, true, false>
-{
-  optional_delete_assign_base() = default;
-  optional_delete_assign_base(const optional_delete_assign_base&) = default;
-  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
-  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
-    default;
-  optional_delete_assign_base& operator=(
-    optional_delete_assign_base&&) noexcept = delete;
-};
-
-template<class T>
-struct optional_delete_assign_base<T, false, true>
-{
-  optional_delete_assign_base() = default;
-  optional_delete_assign_base(const optional_delete_assign_base&) = default;
-  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
-  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
-    delete;
-  optional_delete_assign_base& operator=(
-    optional_delete_assign_base&&) noexcept = default;
-};
-
-template<class T>
-struct optional_delete_assign_base<T, false, false>
-{
-  optional_delete_assign_base() = default;
-  optional_delete_assign_base(const optional_delete_assign_base&) = default;
-  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
-  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
-    delete;
-  optional_delete_assign_base& operator=(
-    optional_delete_assign_base&&) noexcept = delete;
-};
-
-} // namespace detail
-
-/// A tag type to represent an empty optional
-struct nullopt_t
-{
-  struct do_not_use
-  {};
-  constexpr explicit nullopt_t(do_not_use, do_not_use) noexcept {}
-};
-/// Represents an empty optional
-static constexpr nullopt_t nullopt{ nullopt_t::do_not_use{},
-                                    nullopt_t::do_not_use{} };
-
-class bad_optional_access : public std::exception
-{
-public:
-  bad_optional_access() = default;
-  const char* what() const noexcept { return "Optional has no value"; }
-};
-
-/// An optional object is an object that contains the storage for another
-/// object and manages the lifetime of this contained object, if any. The
-/// contained object may be initialized after the optional object has been
-/// initialized, and may be destroyed before the optional object has been
-/// destroyed. The initialization state of the contained object is tracked by
-/// the optional object.
-template<class T>
-class optional
-  : private detail::optional_move_assign_base<T>
-  , private detail::optional_delete_ctor_base<T>
-  , private detail::optional_delete_assign_base<T>
-{
-  using base = detail::optional_move_assign_base<T>;
-
-  static_assert(!std::is_same<T, in_place_t>::value,
-                "instantiation of optional with in_place_t is ill-formed");
-  static_assert(!std::is_same<detail::decay_t<T>, nullopt_t>::value,
-                "instantiation of optional with nullopt_t is ill-formed");
-
-public:
-// The different versions for C++14 and 11 are needed because deduced return
-// types are not SFINAE-safe. This provides better support for things like
-// generic lambdas. C.f.
-// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-  /// Carries out some operation which returns an optional on the stored
-  /// object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &&
-  {
-    using result = detail::invoke_result_t<F, T&&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : result(nullopt);
-  }
-
-  template<class F>
-  constexpr auto and_then(F&& f) const&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr auto and_then(F&& f) const&&
-  {
-    using result = detail::invoke_result_t<F, const T&&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : result(nullopt);
-  }
-#endif
-#else
-  /// Carries out some operation which returns an optional on the stored
-  /// object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&&> and_then(F&& f) &&
-  {
-    using result = detail::invoke_result_t<F, T&&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : result(nullopt);
-  }
-
-  template<class F>
-  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr detail::invoke_result_t<F, const T&&> and_then(F&& f) const&&
-  {
-    using result = detail::invoke_result_t<F, const T&&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : result(nullopt);
-  }
-#endif
-#endif
-
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto map(F&& f) const&
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto map(F&& f) const&&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#else
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional&>(),
-                                                      std::declval<F&&>()))
-  map(F&& f) &
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(
-    std::declval<optional&&>(),
-    std::declval<F&&>()))
-  map(F&& f) &&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr decltype(optional_map_impl(std::declval<const optional&>(),
-                                       std::declval<F&&>()))
-  map(F&& f) const&
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr decltype(optional_map_impl(std::declval<const optional&&>(),
-                                       std::declval<F&&>()))
-  map(F&& f) const&&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#endif
-#endif
-
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto transform(F&& f) const&
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto transform(F&& f) const&&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#else
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional&>(),
-                                                      std::declval<F&&>()))
-  transform(F&& f) &
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(
-    std::declval<optional&&>(),
-    std::declval<F&&>()))
-  transform(F&& f) &&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr decltype(optional_map_impl(std::declval<const optional&>(),
-                                       std::declval<F&&>()))
-  transform(F&& f) const&
-  {
-    return optional_map_impl(*this, std::forward<F>(f));
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr decltype(optional_map_impl(std::declval<const optional&&>(),
-                                       std::declval<F&&>()))
-  transform(F&& f) const&&
-  {
-    return optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#endif
-#endif
-
-  /// Calls `f` if the optional is empty
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
-  {
-    if (has_value())
-      return *this;
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
-  {
-    return has_value() ? *this : std::forward<F>(f)();
-  }
-
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) &&
-  {
-    if (has_value())
-      return std::move(*this);
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &&
-  {
-    return has_value() ? std::move(*this) : std::forward<F>(f)();
-  }
-
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&
-  {
-    if (has_value())
-      return *this;
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) const&
-  {
-    return has_value() ? *this : std::forward<F>(f)();
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&&
-  {
-    if (has_value())
-      return std::move(*this);
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&&
-  {
-    return has_value() ? std::move(*this) : std::forward<F>(f)();
-  }
-#endif
-
-  /// Maps the stored value with `f` if there is one, otherwise returns `u`.
-  template<class F, class U>
-  U map_or(F&& f, U&& u) &
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u);
-  }
-
-  template<class F, class U>
-  U map_or(F&& f, U&& u) &&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u);
-  }
-
-  template<class F, class U>
-  U map_or(F&& f, U&& u) const&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, class U>
-  U map_or(F&& f, U&& u) const&&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u);
-  }
-#endif
-
-  /// Maps the stored value with `f` if there is one, otherwise calls
-  /// `u` and returns the result.
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u)();
-  }
-
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u)();
-  }
-
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u)();
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u)();
-  }
-#endif
-
-  /// Returns `u` if `*this` has a value, otherwise an empty optional.
-  template<class U>
-  constexpr optional<typename std::decay<U>::type> conjunction(U&& u) const
-  {
-    using result = optional<detail::decay_t<U>>;
-    return has_value() ? result{ u } : result{ nullopt };
-  }
-
-  /// Returns `rhs` if `*this` is empty, otherwise the current value.
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &
-  {
-    return has_value() ? *this : rhs;
-  }
-
-  constexpr optional disjunction(const optional& rhs) const&
-  {
-    return has_value() ? *this : rhs;
-  }
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &&
-  {
-    return has_value() ? std::move(*this) : rhs;
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr optional disjunction(const optional& rhs) const&&
-  {
-    return has_value() ? std::move(*this) : rhs;
-  }
-#endif
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &
-  {
-    return has_value() ? *this : std::move(rhs);
-  }
-
-  constexpr optional disjunction(optional&& rhs) const&
-  {
-    return has_value() ? *this : std::move(rhs);
-  }
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &&
-  {
-    return has_value() ? std::move(*this) : std::move(rhs);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr optional disjunction(optional&& rhs) const&&
-  {
-    return has_value() ? std::move(*this) : std::move(rhs);
-  }
-#endif
-
-  /// Takes the value out of the optional, leaving it empty
-  optional take()
-  {
-    optional ret = std::move(*this);
-    reset();
-    return ret;
-  }
-
-  using value_type = T;
-
-  /// Constructs an optional that does not contain a value.
-  constexpr optional() noexcept = default;
-
-  constexpr optional(nullopt_t) noexcept {}
-
-  /// Copy constructor
-  ///
-  /// If `rhs` contains a value, the stored value is direct-initialized with
-  /// it. Otherwise, the constructed optional is empty.
-  TL_OPTIONAL_11_CONSTEXPR optional(const optional& rhs) = default;
-
-  /// Move constructor
-  ///
-  /// If `rhs` contains a value, the stored value is direct-initialized with
-  /// it. Otherwise, the constructed optional is empty.
-  TL_OPTIONAL_11_CONSTEXPR optional(optional&& rhs) = default;
-
-  /// Constructs the stored value in-place using the given arguments.
-  template<class... Args>
-  constexpr explicit optional(
-    detail::enable_if_t<std::is_constructible<T, Args...>::value, in_place_t>,
-    Args&&... args)
-    : base(in_place, std::forward<Args>(args)...)
-  {
-  }
-
-  template<class U, class... Args>
-  TL_OPTIONAL_11_CONSTEXPR explicit optional(
-    detail::enable_if_t<
-      std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
-      in_place_t>,
-    std::initializer_list<U> il,
-    Args&&... args)
-  {
-    this->construct(il, std::forward<Args>(args)...);
-  }
-
-  /// Constructs the stored value with `u`.
-  template<class U = T,
-           detail::enable_if_t<std::is_convertible<U&&, T>::value>* = nullptr,
-           detail::enable_forward_value<T, U>* = nullptr>
-  constexpr optional(U&& u)
-    : base(in_place, std::forward<U>(u))
-  {
-  }
-
-  template<class U = T,
-           detail::enable_if_t<!std::is_convertible<U&&, T>::value>* = nullptr,
-           detail::enable_forward_value<T, U>* = nullptr>
-  constexpr explicit optional(U&& u)
-    : base(in_place, std::forward<U>(u))
-  {
-  }
-
-  /// Converting copy constructor.
-  template<
-    class U,
-    detail::enable_from_other<T, U, const U&>* = nullptr,
-    detail::enable_if_t<std::is_convertible<const U&, T>::value>* = nullptr>
-  optional(const optional<U>& rhs)
-  {
-    if (rhs.has_value()) {
-      this->construct(*rhs);
-    }
-  }
-
-  template<
-    class U,
-    detail::enable_from_other<T, U, const U&>* = nullptr,
-    detail::enable_if_t<!std::is_convertible<const U&, T>::value>* = nullptr>
-  explicit optional(const optional<U>& rhs)
-  {
-    if (rhs.has_value()) {
-      this->construct(*rhs);
-    }
-  }
-
-  /// Converting move constructor.
-  template<class U,
-           detail::enable_from_other<T, U, U&&>* = nullptr,
-           detail::enable_if_t<std::is_convertible<U&&, T>::value>* = nullptr>
-  optional(optional<U>&& rhs)
-  {
-    if (rhs.has_value()) {
-      this->construct(std::move(*rhs));
-    }
-  }
-
-  template<class U,
-           detail::enable_from_other<T, U, U&&>* = nullptr,
-           detail::enable_if_t<!std::is_convertible<U&&, T>::value>* = nullptr>
-  explicit optional(optional<U>&& rhs)
-  {
-    if (rhs.has_value()) {
-      this->construct(std::move(*rhs));
-    }
-  }
-
-  /// Destroys the stored value if there is one.
-  ~optional() = default;
-
-  /// Assignment to empty.
-  ///
-  /// Destroys the current value if there is one.
-  optional& operator=(nullopt_t) noexcept
-  {
-    if (has_value()) {
-      this->m_value.~T();
-      this->m_has_value = false;
-    }
-
-    return *this;
-  }
-
-  /// Copy assignment.
-  ///
-  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
-  /// value in `*this`.
-  optional& operator=(const optional& rhs) = default;
-
-  /// Move assignment.
-  ///
-  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
-  /// value in `*this`.
-  optional& operator=(optional&& rhs) = default;
-
-  /// Assigns the stored value from `u`, destroying the old value if there was
-  /// one.
-  template<class U = T, detail::enable_assign_forward<T, U>* = nullptr>
-  optional& operator=(U&& u)
-  {
-    if (has_value()) {
-      this->m_value = std::forward<U>(u);
-    } else {
-      this->construct(std::forward<U>(u));
-    }
-
-    return *this;
-  }
-
-  /// Converting copy assignment operator.
-  ///
-  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
-  /// value in `*this`.
-  template<class U, detail::enable_assign_from_other<T, U, const U&>* = nullptr>
-  optional& operator=(const optional<U>& rhs)
-  {
-    if (has_value()) {
-      if (rhs.has_value()) {
-        this->m_value = *rhs;
-      } else {
-        this->hard_reset();
-      }
-    }
-
-    if (rhs.has_value()) {
-      this->construct(*rhs);
-    }
-
-    return *this;
-  }
-
-  // TODO check exception guarantee
-  /// Converting move assignment operator.
-  ///
-  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
-  /// value in `*this`.
-  template<class U, detail::enable_assign_from_other<T, U, U>* = nullptr>
-  optional& operator=(optional<U>&& rhs)
-  {
-    if (has_value()) {
-      if (rhs.has_value()) {
-        this->m_value = std::move(*rhs);
-      } else {
-        this->hard_reset();
-      }
-    }
-
-    if (rhs.has_value()) {
-      this->construct(std::move(*rhs));
-    }
-
-    return *this;
-  }
-
-  /// Constructs the value in-place, destroying the current one if there is
-  /// one.
-  template<class... Args>
-  T& emplace(Args&&... args)
-  {
-    static_assert(std::is_constructible<T, Args&&...>::value,
-                  "T must be constructible with Args");
-
-    *this = nullopt;
-    this->construct(std::forward<Args>(args)...);
-    return value();
-  }
-
-  template<class U, class... Args>
-  detail::enable_if_t<
-    std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
-    T&>
-  emplace(std::initializer_list<U> il, Args&&... args)
-  {
-    *this = nullopt;
-    this->construct(il, std::forward<Args>(args)...);
-    return value();
-  }
-
-  /// Swaps this optional with the other.
-  ///
-  /// If neither optionals have a value, nothing happens.
-  /// If both have a value, the values are swapped.
-  /// If one has a value, it is moved to the other and the movee is left
-  /// valueless.
-  void swap(optional& rhs) noexcept(
-    std::is_nothrow_move_constructible<T>::value&&
-      detail::is_nothrow_swappable<T>::value)
-  {
-    using std::swap;
-    if (has_value()) {
-      if (rhs.has_value()) {
-        swap(**this, *rhs);
-      } else {
-        new (std::addressof(rhs.m_value)) T(std::move(this->m_value));
-        this->m_value.T::~T();
-      }
-    } else if (rhs.has_value()) {
-      new (std::addressof(this->m_value)) T(std::move(rhs.m_value));
-      rhs.m_value.T::~T();
-    }
-    swap(this->m_has_value, rhs.m_has_value);
-  }
-
-  /// Returns a pointer to the stored value
-  constexpr const T* operator->() const
-  {
-    return std::addressof(this->m_value);
-  }
-
-  TL_OPTIONAL_11_CONSTEXPR T* operator->()
-  {
-    return std::addressof(this->m_value);
-  }
-
-  /// Returns the stored value
-  TL_OPTIONAL_11_CONSTEXPR T& operator*() & { return this->m_value; }
-
-  constexpr const T& operator*() const& { return this->m_value; }
-
-  TL_OPTIONAL_11_CONSTEXPR T&& operator*() &&
-  {
-    return std::move(this->m_value);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr const T&& operator*() const&& { return std::move(this->m_value); }
-#endif
-
-  /// Returns whether or not the optional has a value
-  constexpr bool has_value() const noexcept { return this->m_has_value; }
-
-  constexpr explicit operator bool() const noexcept
-  {
-    return this->m_has_value;
-  }
-
-  /// Returns the contained value if there is one, otherwise throws
-  /// bad_optional_access
-  TL_OPTIONAL_11_CONSTEXPR T& value() &
-  {
-    if (has_value())
-      return this->m_value;
-    throw bad_optional_access();
-  }
-  TL_OPTIONAL_11_CONSTEXPR const T& value() const&
-  {
-    if (has_value())
-      return this->m_value;
-    throw bad_optional_access();
-  }
-  TL_OPTIONAL_11_CONSTEXPR T&& value() &&
-  {
-    if (has_value())
-      return std::move(this->m_value);
-    throw bad_optional_access();
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  TL_OPTIONAL_11_CONSTEXPR const T&& value() const&&
-  {
-    if (has_value())
-      return std::move(this->m_value);
-    throw bad_optional_access();
-  }
-#endif
-
-  /// Returns the stored value if there is one, otherwise returns `u`
-  template<class U>
-  constexpr T value_or(U&& u) const&
-  {
-    static_assert(std::is_copy_constructible<T>::value &&
-                    std::is_convertible<U&&, T>::value,
-                  "T must be copy constructible and convertible from U");
-    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
-  }
-
-  template<class U>
-  TL_OPTIONAL_11_CONSTEXPR T value_or(U&& u) &&
-  {
-    static_assert(std::is_move_constructible<T>::value &&
-                    std::is_convertible<U&&, T>::value,
-                  "T must be move constructible and convertible from U");
-    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
-  }
-
-  /// Destroys the stored value if one exists, making the optional empty
-  void reset() noexcept
-  {
-    if (has_value()) {
-      this->m_value.~T();
-      this->m_has_value = false;
-    }
-  }
-}; // namespace tl
-
-/// Compares two optional objects
-template<class T, class U>
-inline constexpr bool
-operator==(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return lhs.has_value() == rhs.has_value() &&
-         (!lhs.has_value() || *lhs == *rhs);
-}
-template<class T, class U>
-inline constexpr bool
-operator!=(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return lhs.has_value() != rhs.has_value() ||
-         (lhs.has_value() && *lhs != *rhs);
-}
-template<class T, class U>
-inline constexpr bool
-operator<(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return rhs.has_value() && (!lhs.has_value() || *lhs < *rhs);
-}
-template<class T, class U>
-inline constexpr bool
-operator>(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return lhs.has_value() && (!rhs.has_value() || *lhs > *rhs);
-}
-template<class T, class U>
-inline constexpr bool
-operator<=(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return !lhs.has_value() || (rhs.has_value() && *lhs <= *rhs);
-}
-template<class T, class U>
-inline constexpr bool
-operator>=(const optional<T>& lhs, const optional<U>& rhs)
-{
-  return !rhs.has_value() || (lhs.has_value() && *lhs >= *rhs);
-}
-
-/// Compares an optional to a `nullopt`
-template<class T>
-inline constexpr bool
-operator==(const optional<T>& lhs, nullopt_t) noexcept
-{
-  return !lhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator==(nullopt_t, const optional<T>& rhs) noexcept
-{
-  return !rhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator!=(const optional<T>& lhs, nullopt_t) noexcept
-{
-  return lhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator!=(nullopt_t, const optional<T>& rhs) noexcept
-{
-  return rhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator<(const optional<T>&, nullopt_t) noexcept
-{
-  return false;
-}
-template<class T>
-inline constexpr bool
-operator<(nullopt_t, const optional<T>& rhs) noexcept
-{
-  return rhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator<=(const optional<T>& lhs, nullopt_t) noexcept
-{
-  return !lhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator<=(nullopt_t, const optional<T>&) noexcept
-{
-  return true;
-}
-template<class T>
-inline constexpr bool
-operator>(const optional<T>& lhs, nullopt_t) noexcept
-{
-  return lhs.has_value();
-}
-template<class T>
-inline constexpr bool
-operator>(nullopt_t, const optional<T>&) noexcept
-{
-  return false;
-}
-template<class T>
-inline constexpr bool
-operator>=(const optional<T>&, nullopt_t) noexcept
-{
-  return true;
-}
-template<class T>
-inline constexpr bool
-operator>=(nullopt_t, const optional<T>& rhs) noexcept
-{
-  return !rhs.has_value();
-}
-
-/// Compares the optional with a value.
-template<class T, class U>
-inline constexpr bool
-operator==(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs == rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator==(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs == *rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator!=(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs != rhs : true;
-}
-template<class T, class U>
-inline constexpr bool
-operator!=(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs != *rhs : true;
-}
-template<class T, class U>
-inline constexpr bool
-operator<(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs < rhs : true;
-}
-template<class T, class U>
-inline constexpr bool
-operator<(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs < *rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator<=(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs <= rhs : true;
-}
-template<class T, class U>
-inline constexpr bool
-operator<=(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs <= *rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator>(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs > rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator>(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs > *rhs : true;
-}
-template<class T, class U>
-inline constexpr bool
-operator>=(const optional<T>& lhs, const U& rhs)
-{
-  return lhs.has_value() ? *lhs >= rhs : false;
-}
-template<class T, class U>
-inline constexpr bool
-operator>=(const U& lhs, const optional<T>& rhs)
-{
-  return rhs.has_value() ? lhs >= *rhs : true;
-}
-
-template<class T,
-         detail::enable_if_t<std::is_move_constructible<T>::value>* = nullptr,
-         detail::enable_if_t<detail::is_swappable<T>::value>* = nullptr>
-void
-swap(optional<T>& lhs, optional<T>& rhs) noexcept(noexcept(lhs.swap(rhs)))
-{
-  return lhs.swap(rhs);
-}
-
-namespace detail {
-struct i_am_secret
-{};
-} // namespace detail
-
-template<
-  class T = detail::i_am_secret,
-  class U,
-  class Ret = detail::conditional_t<std::is_same<T, detail::i_am_secret>::value,
-                                    detail::decay_t<U>,
-                                    T>>
-inline constexpr optional<Ret>
-make_optional(U&& v)
-{
-  return optional<Ret>(std::forward<U>(v));
-}
-
-template<class T, class... Args>
-inline constexpr optional<T>
-make_optional(Args&&... args)
-{
-  return optional<T>(in_place, std::forward<Args>(args)...);
-}
-template<class T, class U, class... Args>
-inline constexpr optional<T>
-make_optional(std::initializer_list<U> il, Args&&... args)
-{
-  return optional<T>(in_place, il, std::forward<Args>(args)...);
-}
-
-#if __cplusplus >= 201703L
-template<class T>
-optional(T) -> optional<T>;
-#endif
-
-/// \exclude
-namespace detail {
-#ifdef TL_OPTIONAL_CXX14
-template<class Opt,
-         class F,
-         class Ret = decltype(detail::invoke(std::declval<F>(),
-                                             *std::declval<Opt>())),
-         detail::enable_if_t<!std::is_void<Ret>::value>* = nullptr>
-constexpr auto
-optional_map_impl(Opt&& opt, F&& f)
-{
-  return opt.has_value()
-           ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
-           : optional<Ret>(nullopt);
-}
-
-template<class Opt,
-         class F,
-         class Ret = decltype(detail::invoke(std::declval<F>(),
-                                             *std::declval<Opt>())),
-         detail::enable_if_t<std::is_void<Ret>::value>* = nullptr>
-auto
-optional_map_impl(Opt&& opt, F&& f)
-{
-  if (opt.has_value()) {
-    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
-    return make_optional(monostate{});
-  }
-
-  return optional<monostate>(nullopt);
-}
-#else
-template<class Opt,
-         class F,
-         class Ret = decltype(detail::invoke(std::declval<F>(),
-                                             *std::declval<Opt>())),
-         detail::enable_if_t<!std::is_void<Ret>::value>* = nullptr>
-
-constexpr auto
-optional_map_impl(Opt&& opt, F&& f) -> optional<Ret>
-{
-  return opt.has_value()
-           ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
-           : optional<Ret>(nullopt);
-}
-
-template<class Opt,
-         class F,
-         class Ret = decltype(detail::invoke(std::declval<F>(),
-                                             *std::declval<Opt>())),
-         detail::enable_if_t<std::is_void<Ret>::value>* = nullptr>
-
-auto
-optional_map_impl(Opt&& opt, F&& f) -> optional<monostate>
-{
-  if (opt.has_value()) {
-    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
-    return monostate{};
-  }
-
-  return nullopt;
-}
-#endif
-} // namespace detail
-
-/// Specialization for when `T` is a reference. `optional<T&>` acts similarly
-/// to a `T*`, but provides more operations and shows intent more clearly.
-template<class T>
-class optional<T&>
-{
-public:
-// The different versions for C++14 and 11 are needed because deduced return
-// types are not SFINAE-safe. This provides better support for things like
-// generic lambdas. C.f.
-// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-
-  /// Carries out some operation which returns an optional on the stored
-  /// object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &&
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  constexpr auto and_then(F&& f) const&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr auto and_then(F&& f) const&&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-#endif
-#else
-  /// Carries out some operation which returns an optional on the stored
-  /// object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &&
-  {
-    using result = detail::invoke_result_t<F, T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-  template<class F>
-  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&&
-  {
-    using result = detail::invoke_result_t<F, const T&>;
-    static_assert(detail::is_optional<result>::value,
-                  "F must return an optional");
-
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : result(nullopt);
-  }
-#endif
-#endif
-
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto map(F&& f) const&
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto map(F&& f) const&&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#else
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
-    std::declval<optional&>(),
-    std::declval<F&&>()))
-  map(F&& f) &
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
-    std::declval<optional&&>(),
-    std::declval<F&&>()))
-  map(F&& f) &&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr decltype(detail::optional_map_impl(std::declval<const optional&>(),
-                                               std::declval<F&&>()))
-  map(F&& f) const&
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr decltype(detail::optional_map_impl(std::declval<const optional&&>(),
-                                               std::declval<F&&>()))
-  map(F&& f) const&&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#endif
-#endif
-
-#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
-  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto transform(F&& f) const&
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr auto transform(F&& f) const&&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#else
-  /// Carries out some operation on the stored object if there is one.
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
-    std::declval<optional&>(),
-    std::declval<F&&>()))
-  transform(F&& f) &
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-  /// \group map
-  /// \synopsis template <class F> auto transform(F &&f) &&;
-  template<class F>
-  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
-    std::declval<optional&&>(),
-    std::declval<F&&>()))
-  transform(F&& f) &&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-
-  template<class F>
-  constexpr decltype(detail::optional_map_impl(std::declval<const optional&>(),
-                                               std::declval<F&&>()))
-  transform(F&& f) const&
-  {
-    return detail::optional_map_impl(*this, std::forward<F>(f));
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F>
-  constexpr decltype(detail::optional_map_impl(std::declval<const optional&&>(),
-                                               std::declval<F&&>()))
-  transform(F&& f) const&&
-  {
-    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
-  }
-#endif
-#endif
-
-  /// Calls `f` if the optional is empty
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
-  {
-    if (has_value())
-      return *this;
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
-  {
-    return has_value() ? *this : std::forward<F>(f)();
-  }
-
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) &&
-  {
-    if (has_value())
-      return std::move(*this);
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &&
-  {
-    return has_value() ? std::move(*this) : std::forward<F>(f)();
-  }
-
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&
-  {
-    if (has_value())
-      return *this;
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) const&
-  {
-    return has_value() ? *this : std::forward<F>(f)();
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, detail::enable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&&
-  {
-    if (has_value())
-      return std::move(*this);
-
-    std::forward<F>(f)();
-    return nullopt;
-  }
-
-  template<class F, detail::disable_if_ret_void<F>* = nullptr>
-  optional<T> or_else(F&& f) const&&
-  {
-    return has_value() ? std::move(*this) : std::forward<F>(f)();
-  }
-#endif
-
-  /// Maps the stored value with `f` if there is one, otherwise returns `u`
-  template<class F, class U>
-  U map_or(F&& f, U&& u) &
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u);
-  }
-
-  template<class F, class U>
-  U map_or(F&& f, U&& u) &&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u);
-  }
-
-  template<class F, class U>
-  U map_or(F&& f, U&& u) const&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, class U>
-  U map_or(F&& f, U&& u) const&&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u);
-  }
-#endif
-
-  /// Maps the stored value with `f` if there is one, otherwise calls
-  /// `u` and returns the result.
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u)();
-  }
-
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u)();
-  }
-
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), **this)
-                       : std::forward<U>(u)();
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  template<class F, class U>
-  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&&
-  {
-    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
-                       : std::forward<U>(u)();
-  }
-#endif
-
-  /// Returns `u` if `*this` has a value, otherwise an empty optional.
-  template<class U>
-  constexpr optional<typename std::decay<U>::type> conjunction(U&& u) const
-  {
-    using result = optional<detail::decay_t<U>>;
-    return has_value() ? result{ u } : result{ nullopt };
-  }
-
-  /// Returns `rhs` if `*this` is empty, otherwise the current value.
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &
-  {
-    return has_value() ? *this : rhs;
-  }
-
-  constexpr optional disjunction(const optional& rhs) const&
-  {
-    return has_value() ? *this : rhs;
-  }
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &&
-  {
-    return has_value() ? std::move(*this) : rhs;
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr optional disjunction(const optional& rhs) const&&
-  {
-    return has_value() ? std::move(*this) : rhs;
-  }
-#endif
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &
-  {
-    return has_value() ? *this : std::move(rhs);
-  }
-
-  constexpr optional disjunction(optional&& rhs) const&
-  {
-    return has_value() ? *this : std::move(rhs);
-  }
-
-  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &&
-  {
-    return has_value() ? std::move(*this) : std::move(rhs);
-  }
-
-#ifndef TL_OPTIONAL_NO_CONSTRR
-  constexpr optional disjunction(optional&& rhs) const&&
-  {
-    return has_value() ? std::move(*this) : std::move(rhs);
-  }
-#endif
-
-  /// Takes the value out of the optional, leaving it empty
-  optional take()
-  {
-    optional ret = std::move(*this);
-    reset();
-    return ret;
-  }
-
-  using value_type = T&;
-
-  /// Constructs an optional that does not contain a value.
-  constexpr optional() noexcept
-    : m_value(nullptr)
-  {
-  }
-
-  constexpr optional(nullopt_t) noexcept
-    : m_value(nullptr)
-  {
-  }
-
-  /// Copy constructor
-  ///
-  /// If `rhs` contains a value, the stored value is direct-initialized with
-  /// it. Otherwise, the constructed optional is empty.
-  TL_OPTIONAL_11_CONSTEXPR optional(const optional& rhs) noexcept = default;
-
-  /// Move constructor
-  ///
-  /// If `rhs` contains a value, the stored value is direct-initialized with
-  /// it. Otherwise, the constructed optional is empty.
-  TL_OPTIONAL_11_CONSTEXPR optional(optional&& rhs) = default;
-
-  /// Constructs the stored value with `u`.
-  template<class U = T,
-           detail::enable_if_t<
-             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
-  constexpr optional(U&& u) noexcept
-    : m_value(std::addressof(u))
-  {
-    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
-  }
-
-  template<class U>
-  constexpr explicit optional(const optional<U>& rhs) noexcept
-    : optional(*rhs)
-  {
-  }
-
-  /// No-op
-  ~optional() = default;
-
-  /// Assignment to empty.
-  ///
-  /// Destroys the current value if there is one.
-  optional& operator=(nullopt_t) noexcept
-  {
-    m_value = nullptr;
-    return *this;
-  }
-
-  /// Copy assignment.
-  ///
-  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
-  /// resets the stored value in `*this`.
-  optional& operator=(const optional& rhs) = default;
-
-  /// Rebinds this optional to `u`.
-  template<class U = T,
-           detail::enable_if_t<
-             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
-  optional& operator=(U&& u)
-  {
-    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
-    m_value = std::addressof(u);
-    return *this;
-  }
-
-  /// Converting copy assignment operator.
-  ///
-  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
-  /// resets the stored value in `*this`.
-  template<class U>
-  optional& operator=(const optional<U>& rhs) noexcept
-  {
-    m_value = std::addressof(rhs.value());
-    return *this;
-  }
-
-  /// Rebinds this optional to `u`.
-  template<class U = T,
-           detail::enable_if_t<
-             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
-  optional& emplace(U&& u) noexcept
-  {
-    return *this = std::forward<U>(u);
-  }
-
-  void swap(optional& rhs) noexcept { std::swap(m_value, rhs.m_value); }
-
-  /// Returns a pointer to the stored value
-  constexpr const T* operator->() const noexcept { return m_value; }
-
-  TL_OPTIONAL_11_CONSTEXPR T* operator->() noexcept { return m_value; }
-
-  /// Returns the stored value
-  TL_OPTIONAL_11_CONSTEXPR T& operator*() noexcept { return *m_value; }
-
-  constexpr const T& operator*() const noexcept { return *m_value; }
-
-  constexpr bool has_value() const noexcept { return m_value != nullptr; }
-
-  constexpr explicit operator bool() const noexcept
-  {
-    return m_value != nullptr;
-  }
-
-  /// Returns the contained value if there is one, otherwise throws
-  /// bad_optional_access
-  TL_OPTIONAL_11_CONSTEXPR T& value()
-  {
-    if (has_value())
-      return *m_value;
-    throw bad_optional_access();
-  }
-  TL_OPTIONAL_11_CONSTEXPR const T& value() const
-  {
-    if (has_value())
-      return *m_value;
-    throw bad_optional_access();
-  }
-
-  /// Returns the stored value if there is one, otherwise returns `u`
-  template<class U>
-  constexpr T value_or(U&& u) const& noexcept
-  {
-    static_assert(std::is_copy_constructible<T>::value &&
-                    std::is_convertible<U&&, T>::value,
-                  "T must be copy constructible and convertible from U");
-    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
-  }
-
-  /// \group value_or
-  template<class U>
-  TL_OPTIONAL_11_CONSTEXPR T value_or(U&& u) && noexcept
-  {
-    static_assert(std::is_move_constructible<T>::value &&
-                    std::is_convertible<U&&, T>::value,
-                  "T must be move constructible and convertible from U");
-    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
-  }
-
-  /// Destroys the stored value if one exists, making the optional empty
-  void reset() noexcept { m_value = nullptr; }
-
-private:
-  T* m_value;
-}; // namespace tl
-
-} // namespace tl
-
-namespace std {
-// TODO SFINAE
-template<class T>
-struct hash<tl::optional<T>>
-{
-  ::std::size_t operator()(const tl::optional<T>& o) const
-  {
-    if (!o.has_value())
-      return 0;
-
-    return std::hash<tl::detail::remove_const_t<T>>()(*o);
-  }
-};
-} // namespace std
-
-#endif
+
+///
+// optional - An implementation of std::optional with extensions
+// Written in 2017 by Sy Brand (tartanllama@gmail.com, @TartanLlama)
+//
+// Documentation available at https://tl.tartanllama.xyz/
+//
+// To the extent possible under law, the author(s) have dedicated all
+// copyright and related and neighboring rights to this software to the
+// public domain worldwide. This software is distributed without any warranty.
+//
+// You should have received a copy of the CC0 Public Domain Dedication
+// along with this software. If not, see
+// <http://creativecommons.org/publicdomain/zero/1.0/>.
+///
+
+#ifndef TL_OPTIONAL_HPP
+#define TL_OPTIONAL_HPP
+
+#define TL_OPTIONAL_VERSION_MAJOR 1
+#define TL_OPTIONAL_VERSION_MINOR 0
+#define TL_OPTIONAL_VERSION_PATCH 0
+
+#include <exception>
+#include <functional>
+#include <new>
+#include <type_traits>
+#include <utility>
+
+#if (defined(_MSC_VER) && _MSC_VER == 1900)
+#define TL_OPTIONAL_MSVC2015
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
+     !defined(__clang__))
+#define TL_OPTIONAL_GCC49
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \
+     !defined(__clang__))
+#define TL_OPTIONAL_GCC54
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \
+     !defined(__clang__))
+#define TL_OPTIONAL_GCC55
+#endif
+
+#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \
+     !defined(__clang__))
+// GCC < 5 doesn't support overloading on const&& for member functions
+#define TL_OPTIONAL_NO_CONSTRR
+
+// GCC < 5 doesn't support some standard C++11 type traits
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
+  std::has_trivial_copy_constructor<T>::value
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
+  std::has_trivial_copy_assign<T>::value
+
+// This one will be different for GCC 5.7 if it's ever supported
+#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
+  std::is_trivially_destructible<T>::value
+
+// GCC 5 < v < 8 has a bug in is_trivially_copy_constructible which breaks
+// std::vector for non-copyable types
+#elif (defined(__GNUC__) && __GNUC__ < 8 && !defined(__clang__))
+#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
+#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX
+namespace tl {
+namespace detail {
+template<class T>
+struct is_trivially_copy_constructible : std::is_trivially_copy_constructible<T>
+{};
+#ifdef _GLIBCXX_VECTOR
+template<class T, class A>
+struct is_trivially_copy_constructible<std::vector<T, A>>
+  : std::is_trivially_copy_constructible<T>
+{};
+#endif
+}
+}
+#endif
+
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
+  tl::detail::is_trivially_copy_constructible<T>::value
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
+  std::is_trivially_copy_assignable<T>::value
+#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
+  std::is_trivially_destructible<T>::value
+#else
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                         \
+  std::is_trivially_copy_constructible<T>::value
+#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                            \
+  std::is_trivially_copy_assignable<T>::value
+#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)                               \
+  std::is_trivially_destructible<T>::value
+#endif
+
+#if __cplusplus > 201103L
+#define TL_OPTIONAL_CXX14
+#endif
+
+// constexpr implies const in C++11, not C++14
+#if (__cplusplus == 201103L || defined(TL_OPTIONAL_MSVC2015) ||                \
+     defined(TL_OPTIONAL_GCC49))
+#define TL_OPTIONAL_11_CONSTEXPR
+#else
+#define TL_OPTIONAL_11_CONSTEXPR constexpr
+#endif
+
+namespace tl {
+#ifndef TL_MONOSTATE_INPLACE_MUTEX
+#define TL_MONOSTATE_INPLACE_MUTEX
+/// Used to represent an optional with no data; essentially a bool
+class monostate
+{};
+
+///  A tag type to tell optional to construct its value in-place
+struct in_place_t
+{
+  explicit in_place_t() = default;
+};
+/// A tag to tell optional to construct its value in-place
+static constexpr in_place_t in_place{};
+#endif
+
+template<class T>
+class optional;
+
+namespace detail {
+#ifndef TL_TRAITS_MUTEX
+#define TL_TRAITS_MUTEX
+// C++14-style aliases for brevity
+template<class T>
+using remove_const_t = typename std::remove_const<T>::type;
+template<class T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+template<class T>
+using decay_t = typename std::decay<T>::type;
+template<bool E, class T = void>
+using enable_if_t = typename std::enable_if<E, T>::type;
+template<bool B, class T, class F>
+using conditional_t = typename std::conditional<B, T, F>::type;
+
+// std::conjunction from C++17
+template<class...>
+struct conjunction : std::true_type
+{};
+template<class B>
+struct conjunction<B> : B
+{};
+template<class B, class... Bs>
+struct conjunction<B, Bs...>
+  : std::conditional<bool(B::value), conjunction<Bs...>, B>::type
+{};
+
+#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L
+#define TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+#endif
+
+// In C++11 mode, there's an issue in libc++'s std::mem_fn
+// which results in a hard-error when using it in a noexcept expression
+// in some cases. This is a check to workaround the common failing case.
+#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+template<class T>
+struct is_pointer_to_non_const_member_func : std::false_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)> : std::true_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...)&>
+  : std::true_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) &&>
+  : std::true_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile>
+  : std::true_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile&>
+  : std::true_type
+{};
+template<class T, class Ret, class... Args>
+struct is_pointer_to_non_const_member_func<Ret (T::*)(Args...) volatile&&>
+  : std::true_type
+{};
+
+template<class T>
+struct is_const_or_const_ref : std::false_type
+{};
+template<class T>
+struct is_const_or_const_ref<T const&> : std::true_type
+{};
+template<class T>
+struct is_const_or_const_ref<T const> : std::true_type
+{};
+#endif
+
+// std::invoke from C++17
+// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround
+template<
+  typename Fn,
+  typename... Args,
+#ifdef TL_TRAITS_LIBCXX_MEM_FN_WORKAROUND
+  typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value &&
+                           is_const_or_const_ref<Args...>::value)>,
+#endif
+  typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>,
+  int = 0>
+constexpr auto
+invoke(Fn&& f, Args&&... args) noexcept(
+  noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))
+  -> decltype(std::mem_fn(f)(std::forward<Args>(args)...))
+{
+  return std::mem_fn(f)(std::forward<Args>(args)...);
+}
+
+template<typename Fn,
+         typename... Args,
+         typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>
+constexpr auto
+invoke(Fn&& f, Args&&... args) noexcept(
+  noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))
+  -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...))
+{
+  return std::forward<Fn>(f)(std::forward<Args>(args)...);
+}
+
+// std::invoke_result from C++17
+template<class F, class, class... Us>
+struct invoke_result_impl;
+
+template<class F, class... Us>
+struct invoke_result_impl<
+  F,
+  decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),
+  Us...>
+{
+  using type =
+    decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));
+};
+
+template<class F, class... Us>
+using invoke_result = invoke_result_impl<F, void, Us...>;
+
+template<class F, class... Us>
+using invoke_result_t = typename invoke_result<F, Us...>::type;
+
+#if defined(_MSC_VER) && _MSC_VER <= 1900
+// TODO make a version which works with MSVC 2015
+template<class T, class U = T>
+struct is_swappable : std::true_type
+{};
+
+template<class T, class U = T>
+struct is_nothrow_swappable : std::true_type
+{};
+#else
+// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept
+namespace swap_adl_tests {
+// if swap ADL finds this then it would call std::swap otherwise (same
+// signature)
+struct tag
+{};
+
+template<class T>
+tag
+swap(T&, T&);
+template<class T, std::size_t N>
+tag swap(T (&a)[N], T (&b)[N]);
+
+// helper functions to test if an unqualified swap is possible, and if it
+// becomes std::swap
+template<class, class>
+std::false_type
+can_swap(...) noexcept(false);
+template<class T,
+         class U,
+         class = decltype(swap(std::declval<T&>(), std::declval<U&>()))>
+std::true_type
+can_swap(int) noexcept(noexcept(swap(std::declval<T&>(), std::declval<U&>())));
+
+template<class, class>
+std::false_type
+uses_std(...);
+template<class T, class U>
+std::is_same<decltype(swap(std::declval<T&>(), std::declval<U&>())), tag>
+uses_std(int);
+
+template<class T>
+struct is_std_swap_noexcept
+  : std::integral_constant<bool,
+                           std::is_nothrow_move_constructible<T>::value &&
+                             std::is_nothrow_move_assignable<T>::value>
+{};
+
+template<class T, std::size_t N>
+struct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T>
+{};
+
+template<class T, class U>
+struct is_adl_swap_noexcept
+  : std::integral_constant<bool, noexcept(can_swap<T, U>(0))>
+{};
+} // namespace swap_adl_tests
+
+template<class T, class U = T>
+struct is_swappable
+  : std::integral_constant<
+      bool,
+      decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&
+        (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||
+         (std::is_move_assignable<T>::value &&
+          std::is_move_constructible<T>::value))>
+{};
+
+template<class T, std::size_t N>
+struct is_swappable<T[N], T[N]>
+  : std::integral_constant<
+      bool,
+      decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&
+        (!decltype(detail::swap_adl_tests::uses_std<T[N], T[N]>(0))::value ||
+         is_swappable<T, T>::value)>
+{};
+
+template<class T, class U = T>
+struct is_nothrow_swappable
+  : std::integral_constant<
+      bool,
+      is_swappable<T, U>::value &&
+        ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
+          detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||
+         (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&
+          detail::swap_adl_tests::is_adl_swap_noexcept<T, U>::value))>
+{};
+#endif
+#endif
+
+// std::void_t from C++17
+template<class...>
+struct voider
+{
+  using type = void;
+};
+template<class... Ts>
+using void_t = typename voider<Ts...>::type;
+
+// Trait for checking if a type is a tl::optional
+template<class T>
+struct is_optional_impl : std::false_type
+{};
+template<class T>
+struct is_optional_impl<optional<T>> : std::true_type
+{};
+template<class T>
+using is_optional = is_optional_impl<decay_t<T>>;
+
+// Change void to tl::monostate
+template<class U>
+using fixup_void = conditional_t<std::is_void<U>::value, monostate, U>;
+
+template<class F, class U, class = invoke_result_t<F, U>>
+using get_map_return = optional<fixup_void<invoke_result_t<F, U>>>;
+
+// Check if invoking F for some Us returns void
+template<class F, class = void, class... U>
+struct returns_void_impl;
+template<class F, class... U>
+struct returns_void_impl<F, void_t<invoke_result_t<F, U...>>, U...>
+  : std::is_void<invoke_result_t<F, U...>>
+{};
+template<class F, class... U>
+using returns_void = returns_void_impl<F, void, U...>;
+
+template<class T, class... U>
+using enable_if_ret_void = enable_if_t<returns_void<T&&, U...>::value>;
+
+template<class T, class... U>
+using disable_if_ret_void = enable_if_t<!returns_void<T&&, U...>::value>;
+
+template<class T, class U>
+using enable_forward_value =
+  detail::enable_if_t<std::is_constructible<T, U&&>::value &&
+                      !std::is_same<detail::decay_t<U>, in_place_t>::value &&
+                      !std::is_same<optional<T>, detail::decay_t<U>>::value>;
+
+template<class T, class U, class Other>
+using enable_from_other =
+  detail::enable_if_t<std::is_constructible<T, Other>::value &&
+                      !std::is_constructible<T, optional<U>&>::value &&
+                      !std::is_constructible<T, optional<U>&&>::value &&
+                      !std::is_constructible<T, const optional<U>&>::value &&
+                      !std::is_constructible<T, const optional<U>&&>::value &&
+                      !std::is_convertible<optional<U>&, T>::value &&
+                      !std::is_convertible<optional<U>&&, T>::value &&
+                      !std::is_convertible<const optional<U>&, T>::value &&
+                      !std::is_convertible<const optional<U>&&, T>::value>;
+
+template<class T, class U>
+using enable_assign_forward = detail::enable_if_t<
+  !std::is_same<optional<T>, detail::decay_t<U>>::value &&
+  !detail::conjunction<std::is_scalar<T>,
+                       std::is_same<T, detail::decay_t<U>>>::value &&
+  std::is_constructible<T, U>::value && std::is_assignable<T&, U>::value>;
+
+template<class T, class U, class Other>
+using enable_assign_from_other =
+  detail::enable_if_t<std::is_constructible<T, Other>::value &&
+                      std::is_assignable<T&, Other>::value &&
+                      !std::is_constructible<T, optional<U>&>::value &&
+                      !std::is_constructible<T, optional<U>&&>::value &&
+                      !std::is_constructible<T, const optional<U>&>::value &&
+                      !std::is_constructible<T, const optional<U>&&>::value &&
+                      !std::is_convertible<optional<U>&, T>::value &&
+                      !std::is_convertible<optional<U>&&, T>::value &&
+                      !std::is_convertible<const optional<U>&, T>::value &&
+                      !std::is_convertible<const optional<U>&&, T>::value &&
+                      !std::is_assignable<T&, optional<U>&>::value &&
+                      !std::is_assignable<T&, optional<U>&&>::value &&
+                      !std::is_assignable<T&, const optional<U>&>::value &&
+                      !std::is_assignable<T&, const optional<U>&&>::value>;
+
+// The storage base manages the actual storage, and correctly propagates
+// trivial destruction from T. This case is for when T is not trivially
+// destructible.
+template<class T, bool = ::std::is_trivially_destructible<T>::value>
+struct optional_storage_base
+{
+  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
+    : m_dummy()
+    , m_has_value(false)
+  {
+  }
+
+  template<class... U>
+  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U&&... u)
+    : m_value(std::forward<U>(u)...)
+    , m_has_value(true)
+  {
+  }
+
+  ~optional_storage_base()
+  {
+    if (m_has_value) {
+      m_value.~T();
+      m_has_value = false;
+    }
+  }
+
+  struct dummy
+  {};
+  union
+  {
+    dummy m_dummy;
+    T m_value;
+  };
+
+  bool m_has_value;
+};
+
+// This case is for when T is trivially destructible.
+template<class T>
+struct optional_storage_base<T, true>
+{
+  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept
+    : m_dummy()
+    , m_has_value(false)
+  {
+  }
+
+  template<class... U>
+  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U&&... u)
+    : m_value(std::forward<U>(u)...)
+    , m_has_value(true)
+  {
+  }
+
+  // No destructor, so this class is trivially destructible
+
+  struct dummy
+  {};
+  union
+  {
+    dummy m_dummy;
+    T m_value;
+  };
+
+  bool m_has_value = false;
+};
+
+// This base class provides some handy member functions which can be used in
+// further derived classes
+template<class T>
+struct optional_operations_base : optional_storage_base<T>
+{
+  using optional_storage_base<T>::optional_storage_base;
+
+  void hard_reset() noexcept
+  {
+    get().~T();
+    this->m_has_value = false;
+  }
+
+  template<class... Args>
+  void construct(Args&&... args) noexcept
+  {
+    new (std::addressof(this->m_value)) T(std::forward<Args>(args)...);
+    this->m_has_value = true;
+  }
+
+  template<class Opt>
+  void assign(Opt&& rhs)
+  {
+    if (this->has_value()) {
+      if (rhs.has_value()) {
+        this->m_value = std::forward<Opt>(rhs).get();
+      } else {
+        this->m_value.~T();
+        this->m_has_value = false;
+      }
+    }
+
+    else if (rhs.has_value()) {
+      construct(std::forward<Opt>(rhs).get());
+    }
+  }
+
+  bool has_value() const { return this->m_has_value; }
+
+  TL_OPTIONAL_11_CONSTEXPR T& get() & { return this->m_value; }
+  TL_OPTIONAL_11_CONSTEXPR const T& get() const& { return this->m_value; }
+  TL_OPTIONAL_11_CONSTEXPR T&& get() && { return std::move(this->m_value); }
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr const T&& get() const&& { return std::move(this->m_value); }
+#endif
+};
+
+// This class manages conditionally having a trivial copy constructor
+// This specialization is for when T is trivially copy constructible
+template<class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>
+struct optional_copy_base : optional_operations_base<T>
+{
+  using optional_operations_base<T>::optional_operations_base;
+};
+
+// This specialization is for when T is not trivially copy constructible
+template<class T>
+struct optional_copy_base<T, false> : optional_operations_base<T>
+{
+  using optional_operations_base<T>::optional_operations_base;
+
+  optional_copy_base() = default;
+  optional_copy_base(const optional_copy_base& rhs)
+    : optional_operations_base<T>()
+  {
+    if (rhs.has_value()) {
+      this->construct(rhs.get());
+    } else {
+      this->m_has_value = false;
+    }
+  }
+
+  optional_copy_base(optional_copy_base&& rhs) = default;
+  optional_copy_base& operator=(const optional_copy_base& rhs) = default;
+  optional_copy_base& operator=(optional_copy_base&& rhs) = default;
+};
+
+// This class manages conditionally having a trivial move constructor
+// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
+// doesn't implement an analogue to std::is_trivially_move_constructible. We
+// have to make do with a non-trivial move constructor even if T is trivially
+// move constructible
+#ifndef TL_OPTIONAL_GCC49
+template<class T, bool = std::is_trivially_move_constructible<T>::value>
+struct optional_move_base : optional_copy_base<T>
+{
+  using optional_copy_base<T>::optional_copy_base;
+};
+#else
+template<class T, bool = false>
+struct optional_move_base;
+#endif
+template<class T>
+struct optional_move_base<T, false> : optional_copy_base<T>
+{
+  using optional_copy_base<T>::optional_copy_base;
+
+  optional_move_base() = default;
+  optional_move_base(const optional_move_base& rhs) = default;
+
+  optional_move_base(optional_move_base&& rhs) noexcept(
+    std::is_nothrow_move_constructible<T>::value)
+  {
+    if (rhs.has_value()) {
+      this->construct(std::move(rhs.get()));
+    } else {
+      this->m_has_value = false;
+    }
+  }
+  optional_move_base& operator=(const optional_move_base& rhs) = default;
+  optional_move_base& operator=(optional_move_base&& rhs) = default;
+};
+
+// This class manages conditionally having a trivial copy assignment operator
+template<class T,
+         bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) &&
+                TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) &&
+                TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)>
+struct optional_copy_assign_base : optional_move_base<T>
+{
+  using optional_move_base<T>::optional_move_base;
+};
+
+template<class T>
+struct optional_copy_assign_base<T, false> : optional_move_base<T>
+{
+  using optional_move_base<T>::optional_move_base;
+
+  optional_copy_assign_base() = default;
+  optional_copy_assign_base(const optional_copy_assign_base& rhs) = default;
+
+  optional_copy_assign_base(optional_copy_assign_base&& rhs) = default;
+  optional_copy_assign_base& operator=(const optional_copy_assign_base& rhs)
+  {
+    this->assign(rhs);
+    return *this;
+  }
+  optional_copy_assign_base& operator=(optional_copy_assign_base&& rhs) =
+    default;
+};
+
+// This class manages conditionally having a trivial move assignment operator
+// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
+// doesn't implement an analogue to std::is_trivially_move_assignable. We have
+// to make do with a non-trivial move assignment operator even if T is trivially
+// move assignable
+#ifndef TL_OPTIONAL_GCC49
+template<class T,
+         bool = std::is_trivially_destructible<T>::value&&
+           std::is_trivially_move_constructible<T>::value&&
+             std::is_trivially_move_assignable<T>::value>
+struct optional_move_assign_base : optional_copy_assign_base<T>
+{
+  using optional_copy_assign_base<T>::optional_copy_assign_base;
+};
+#else
+template<class T, bool = false>
+struct optional_move_assign_base;
+#endif
+
+template<class T>
+struct optional_move_assign_base<T, false> : optional_copy_assign_base<T>
+{
+  using optional_copy_assign_base<T>::optional_copy_assign_base;
+
+  optional_move_assign_base() = default;
+  optional_move_assign_base(const optional_move_assign_base& rhs) = default;
+
+  optional_move_assign_base(optional_move_assign_base&& rhs) = default;
+
+  optional_move_assign_base& operator=(const optional_move_assign_base& rhs) =
+    default;
+
+  optional_move_assign_base&
+  operator=(optional_move_assign_base&& rhs) noexcept(
+    std::is_nothrow_move_constructible<T>::value&&
+      std::is_nothrow_move_assignable<T>::value)
+  {
+    this->assign(std::move(rhs));
+    return *this;
+  }
+};
+
+// optional_delete_ctor_base will conditionally delete copy and move
+// constructors depending on whether T is copy/move constructible
+template<class T,
+         bool EnableCopy = std::is_copy_constructible<T>::value,
+         bool EnableMove = std::is_move_constructible<T>::value>
+struct optional_delete_ctor_base
+{
+  optional_delete_ctor_base() = default;
+  optional_delete_ctor_base(const optional_delete_ctor_base&) = default;
+  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = default;
+  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
+    default;
+  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
+    default;
+};
+
+template<class T>
+struct optional_delete_ctor_base<T, true, false>
+{
+  optional_delete_ctor_base() = default;
+  optional_delete_ctor_base(const optional_delete_ctor_base&) = default;
+  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = delete;
+  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
+    default;
+  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
+    default;
+};
+
+template<class T>
+struct optional_delete_ctor_base<T, false, true>
+{
+  optional_delete_ctor_base() = default;
+  optional_delete_ctor_base(const optional_delete_ctor_base&) = delete;
+  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = default;
+  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
+    default;
+  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
+    default;
+};
+
+template<class T>
+struct optional_delete_ctor_base<T, false, false>
+{
+  optional_delete_ctor_base() = default;
+  optional_delete_ctor_base(const optional_delete_ctor_base&) = delete;
+  optional_delete_ctor_base(optional_delete_ctor_base&&) noexcept = delete;
+  optional_delete_ctor_base& operator=(const optional_delete_ctor_base&) =
+    default;
+  optional_delete_ctor_base& operator=(optional_delete_ctor_base&&) noexcept =
+    default;
+};
+
+// optional_delete_assign_base will conditionally delete copy and move
+// constructors depending on whether T is copy/move constructible + assignable
+template<class T,
+         bool EnableCopy = (std::is_copy_constructible<T>::value &&
+                            std::is_copy_assignable<T>::value),
+         bool EnableMove = (std::is_move_constructible<T>::value &&
+                            std::is_move_assignable<T>::value)>
+struct optional_delete_assign_base
+{
+  optional_delete_assign_base() = default;
+  optional_delete_assign_base(const optional_delete_assign_base&) = default;
+  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
+  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
+    default;
+  optional_delete_assign_base& operator=(
+    optional_delete_assign_base&&) noexcept = default;
+};
+
+template<class T>
+struct optional_delete_assign_base<T, true, false>
+{
+  optional_delete_assign_base() = default;
+  optional_delete_assign_base(const optional_delete_assign_base&) = default;
+  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
+  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
+    default;
+  optional_delete_assign_base& operator=(
+    optional_delete_assign_base&&) noexcept = delete;
+};
+
+template<class T>
+struct optional_delete_assign_base<T, false, true>
+{
+  optional_delete_assign_base() = default;
+  optional_delete_assign_base(const optional_delete_assign_base&) = default;
+  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
+  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
+    delete;
+  optional_delete_assign_base& operator=(
+    optional_delete_assign_base&&) noexcept = default;
+};
+
+template<class T>
+struct optional_delete_assign_base<T, false, false>
+{
+  optional_delete_assign_base() = default;
+  optional_delete_assign_base(const optional_delete_assign_base&) = default;
+  optional_delete_assign_base(optional_delete_assign_base&&) noexcept = default;
+  optional_delete_assign_base& operator=(const optional_delete_assign_base&) =
+    delete;
+  optional_delete_assign_base& operator=(
+    optional_delete_assign_base&&) noexcept = delete;
+};
+
+} // namespace detail
+
+/// A tag type to represent an empty optional
+struct nullopt_t
+{
+  struct do_not_use
+  {};
+  constexpr explicit nullopt_t(do_not_use, do_not_use) noexcept {}
+};
+/// Represents an empty optional
+static constexpr nullopt_t nullopt{ nullopt_t::do_not_use{},
+                                    nullopt_t::do_not_use{} };
+
+class bad_optional_access : public std::exception
+{
+public:
+  bad_optional_access() = default;
+  const char* what() const noexcept { return "Optional has no value"; }
+};
+
+/// An optional object is an object that contains the storage for another
+/// object and manages the lifetime of this contained object, if any. The
+/// contained object may be initialized after the optional object has been
+/// initialized, and may be destroyed before the optional object has been
+/// destroyed. The initialization state of the contained object is tracked by
+/// the optional object.
+template<class T>
+class optional
+  : private detail::optional_move_assign_base<T>
+  , private detail::optional_delete_ctor_base<T>
+  , private detail::optional_delete_assign_base<T>
+{
+  using base = detail::optional_move_assign_base<T>;
+
+  static_assert(!std::is_same<T, in_place_t>::value,
+                "instantiation of optional with in_place_t is ill-formed");
+  static_assert(!std::is_same<detail::decay_t<T>, nullopt_t>::value,
+                "instantiation of optional with nullopt_t is ill-formed");
+
+public:
+// The different versions for C++14 and 11 are needed because deduced return
+// types are not SFINAE-safe. This provides better support for things like
+// generic lambdas. C.f.
+// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+  /// Carries out some operation which returns an optional on the stored
+  /// object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &&
+  {
+    using result = detail::invoke_result_t<F, T&&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : result(nullopt);
+  }
+
+  template<class F>
+  constexpr auto and_then(F&& f) const&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr auto and_then(F&& f) const&&
+  {
+    using result = detail::invoke_result_t<F, const T&&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : result(nullopt);
+  }
+#endif
+#else
+  /// Carries out some operation which returns an optional on the stored
+  /// object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&&> and_then(F&& f) &&
+  {
+    using result = detail::invoke_result_t<F, T&&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : result(nullopt);
+  }
+
+  template<class F>
+  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr detail::invoke_result_t<F, const T&&> and_then(F&& f) const&&
+  {
+    using result = detail::invoke_result_t<F, const T&&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : result(nullopt);
+  }
+#endif
+#endif
+
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto map(F&& f) const&
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto map(F&& f) const&&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional&>(),
+                                                      std::declval<F&&>()))
+  map(F&& f) &
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(
+    std::declval<optional&&>(),
+    std::declval<F&&>()))
+  map(F&& f) &&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr decltype(optional_map_impl(std::declval<const optional&>(),
+                                       std::declval<F&&>()))
+  map(F&& f) const&
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr decltype(optional_map_impl(std::declval<const optional&&>(),
+                                       std::declval<F&&>()))
+  map(F&& f) const&&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto transform(F&& f) const&
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto transform(F&& f) const&&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional&>(),
+                                                      std::declval<F&&>()))
+  transform(F&& f) &
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(
+    std::declval<optional&&>(),
+    std::declval<F&&>()))
+  transform(F&& f) &&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr decltype(optional_map_impl(std::declval<const optional&>(),
+                                       std::declval<F&&>()))
+  transform(F&& f) const&
+  {
+    return optional_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr decltype(optional_map_impl(std::declval<const optional&&>(),
+                                       std::declval<F&&>()))
+  transform(F&& f) const&&
+  {
+    return optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+  /// Calls `f` if the optional is empty
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
+  {
+    if (has_value())
+      return *this;
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
+  {
+    return has_value() ? *this : std::forward<F>(f)();
+  }
+
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) &&
+  {
+    if (has_value())
+      return std::move(*this);
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &&
+  {
+    return has_value() ? std::move(*this) : std::forward<F>(f)();
+  }
+
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&
+  {
+    if (has_value())
+      return *this;
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) const&
+  {
+    return has_value() ? *this : std::forward<F>(f)();
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&&
+  {
+    if (has_value())
+      return std::move(*this);
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&&
+  {
+    return has_value() ? std::move(*this) : std::forward<F>(f)();
+  }
+#endif
+
+  /// Maps the stored value with `f` if there is one, otherwise returns `u`.
+  template<class F, class U>
+  U map_or(F&& f, U&& u) &
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u);
+  }
+
+  template<class F, class U>
+  U map_or(F&& f, U&& u) &&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u);
+  }
+
+  template<class F, class U>
+  U map_or(F&& f, U&& u) const&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, class U>
+  U map_or(F&& f, U&& u) const&&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u);
+  }
+#endif
+
+  /// Maps the stored value with `f` if there is one, otherwise calls
+  /// `u` and returns the result.
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u)();
+  }
+
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u)();
+  }
+
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u)();
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u)();
+  }
+#endif
+
+  /// Returns `u` if `*this` has a value, otherwise an empty optional.
+  template<class U>
+  constexpr optional<typename std::decay<U>::type> conjunction(U&& u) const
+  {
+    using result = optional<detail::decay_t<U>>;
+    return has_value() ? result{ u } : result{ nullopt };
+  }
+
+  /// Returns `rhs` if `*this` is empty, otherwise the current value.
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &
+  {
+    return has_value() ? *this : rhs;
+  }
+
+  constexpr optional disjunction(const optional& rhs) const&
+  {
+    return has_value() ? *this : rhs;
+  }
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &&
+  {
+    return has_value() ? std::move(*this) : rhs;
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr optional disjunction(const optional& rhs) const&&
+  {
+    return has_value() ? std::move(*this) : rhs;
+  }
+#endif
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &
+  {
+    return has_value() ? *this : std::move(rhs);
+  }
+
+  constexpr optional disjunction(optional&& rhs) const&
+  {
+    return has_value() ? *this : std::move(rhs);
+  }
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &&
+  {
+    return has_value() ? std::move(*this) : std::move(rhs);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr optional disjunction(optional&& rhs) const&&
+  {
+    return has_value() ? std::move(*this) : std::move(rhs);
+  }
+#endif
+
+  /// Takes the value out of the optional, leaving it empty
+  optional take()
+  {
+    optional ret = std::move(*this);
+    reset();
+    return ret;
+  }
+
+  using value_type = T;
+
+  /// Constructs an optional that does not contain a value.
+  constexpr optional() noexcept = default;
+
+  constexpr optional(nullopt_t) noexcept {}
+
+  /// Copy constructor
+  ///
+  /// If `rhs` contains a value, the stored value is direct-initialized with
+  /// it. Otherwise, the constructed optional is empty.
+  TL_OPTIONAL_11_CONSTEXPR optional(const optional& rhs) = default;
+
+  /// Move constructor
+  ///
+  /// If `rhs` contains a value, the stored value is direct-initialized with
+  /// it. Otherwise, the constructed optional is empty.
+  TL_OPTIONAL_11_CONSTEXPR optional(optional&& rhs) = default;
+
+  /// Constructs the stored value in-place using the given arguments.
+  template<class... Args>
+  constexpr explicit optional(
+    detail::enable_if_t<std::is_constructible<T, Args...>::value, in_place_t>,
+    Args&&... args)
+    : base(in_place, std::forward<Args>(args)...)
+  {
+  }
+
+  template<class U, class... Args>
+  TL_OPTIONAL_11_CONSTEXPR explicit optional(
+    detail::enable_if_t<
+      std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
+      in_place_t>,
+    std::initializer_list<U> il,
+    Args&&... args)
+  {
+    this->construct(il, std::forward<Args>(args)...);
+  }
+
+  /// Constructs the stored value with `u`.
+  template<class U = T,
+           detail::enable_if_t<std::is_convertible<U&&, T>::value>* = nullptr,
+           detail::enable_forward_value<T, U>* = nullptr>
+  constexpr optional(U&& u)
+    : base(in_place, std::forward<U>(u))
+  {
+  }
+
+  template<class U = T,
+           detail::enable_if_t<!std::is_convertible<U&&, T>::value>* = nullptr,
+           detail::enable_forward_value<T, U>* = nullptr>
+  constexpr explicit optional(U&& u)
+    : base(in_place, std::forward<U>(u))
+  {
+  }
+
+  /// Converting copy constructor.
+  template<
+    class U,
+    detail::enable_from_other<T, U, const U&>* = nullptr,
+    detail::enable_if_t<std::is_convertible<const U&, T>::value>* = nullptr>
+  optional(const optional<U>& rhs)
+  {
+    if (rhs.has_value()) {
+      this->construct(*rhs);
+    }
+  }
+
+  template<
+    class U,
+    detail::enable_from_other<T, U, const U&>* = nullptr,
+    detail::enable_if_t<!std::is_convertible<const U&, T>::value>* = nullptr>
+  explicit optional(const optional<U>& rhs)
+  {
+    if (rhs.has_value()) {
+      this->construct(*rhs);
+    }
+  }
+
+  /// Converting move constructor.
+  template<class U,
+           detail::enable_from_other<T, U, U&&>* = nullptr,
+           detail::enable_if_t<std::is_convertible<U&&, T>::value>* = nullptr>
+  optional(optional<U>&& rhs)
+  {
+    if (rhs.has_value()) {
+      this->construct(std::move(*rhs));
+    }
+  }
+
+  template<class U,
+           detail::enable_from_other<T, U, U&&>* = nullptr,
+           detail::enable_if_t<!std::is_convertible<U&&, T>::value>* = nullptr>
+  explicit optional(optional<U>&& rhs)
+  {
+    if (rhs.has_value()) {
+      this->construct(std::move(*rhs));
+    }
+  }
+
+  /// Destroys the stored value if there is one.
+  ~optional() = default;
+
+  /// Assignment to empty.
+  ///
+  /// Destroys the current value if there is one.
+  optional& operator=(nullopt_t) noexcept
+  {
+    if (has_value()) {
+      this->m_value.~T();
+      this->m_has_value = false;
+    }
+
+    return *this;
+  }
+
+  /// Copy assignment.
+  ///
+  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
+  /// value in `*this`.
+  optional& operator=(const optional& rhs) = default;
+
+  /// Move assignment.
+  ///
+  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
+  /// value in `*this`.
+  optional& operator=(optional&& rhs) = default;
+
+  /// Assigns the stored value from `u`, destroying the old value if there was
+  /// one.
+  template<class U = T, detail::enable_assign_forward<T, U>* = nullptr>
+  optional& operator=(U&& u)
+  {
+    if (has_value()) {
+      this->m_value = std::forward<U>(u);
+    } else {
+      this->construct(std::forward<U>(u));
+    }
+
+    return *this;
+  }
+
+  /// Converting copy assignment operator.
+  ///
+  /// Copies the value from `rhs` if there is one. Otherwise resets the stored
+  /// value in `*this`.
+  template<class U, detail::enable_assign_from_other<T, U, const U&>* = nullptr>
+  optional& operator=(const optional<U>& rhs)
+  {
+    if (has_value()) {
+      if (rhs.has_value()) {
+        this->m_value = *rhs;
+      } else {
+        this->hard_reset();
+      }
+    }
+
+    if (rhs.has_value()) {
+      this->construct(*rhs);
+    }
+
+    return *this;
+  }
+
+  // TODO check exception guarantee
+  /// Converting move assignment operator.
+  ///
+  /// Moves the value from `rhs` if there is one. Otherwise resets the stored
+  /// value in `*this`.
+  template<class U, detail::enable_assign_from_other<T, U, U>* = nullptr>
+  optional& operator=(optional<U>&& rhs)
+  {
+    if (has_value()) {
+      if (rhs.has_value()) {
+        this->m_value = std::move(*rhs);
+      } else {
+        this->hard_reset();
+      }
+    }
+
+    if (rhs.has_value()) {
+      this->construct(std::move(*rhs));
+    }
+
+    return *this;
+  }
+
+  /// Constructs the value in-place, destroying the current one if there is
+  /// one.
+  template<class... Args>
+  T& emplace(Args&&... args)
+  {
+    static_assert(std::is_constructible<T, Args&&...>::value,
+                  "T must be constructible with Args");
+
+    *this = nullopt;
+    this->construct(std::forward<Args>(args)...);
+    return value();
+  }
+
+  template<class U, class... Args>
+  detail::enable_if_t<
+    std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
+    T&>
+  emplace(std::initializer_list<U> il, Args&&... args)
+  {
+    *this = nullopt;
+    this->construct(il, std::forward<Args>(args)...);
+    return value();
+  }
+
+  /// Swaps this optional with the other.
+  ///
+  /// If neither optionals have a value, nothing happens.
+  /// If both have a value, the values are swapped.
+  /// If one has a value, it is moved to the other and the movee is left
+  /// valueless.
+  void swap(optional& rhs) noexcept(
+    std::is_nothrow_move_constructible<T>::value&&
+      detail::is_nothrow_swappable<T>::value)
+  {
+    using std::swap;
+    if (has_value()) {
+      if (rhs.has_value()) {
+        swap(**this, *rhs);
+      } else {
+        new (std::addressof(rhs.m_value)) T(std::move(this->m_value));
+        this->m_value.T::~T();
+      }
+    } else if (rhs.has_value()) {
+      new (std::addressof(this->m_value)) T(std::move(rhs.m_value));
+      rhs.m_value.T::~T();
+    }
+    swap(this->m_has_value, rhs.m_has_value);
+  }
+
+  /// Returns a pointer to the stored value
+  constexpr const T* operator->() const
+  {
+    return std::addressof(this->m_value);
+  }
+
+  TL_OPTIONAL_11_CONSTEXPR T* operator->()
+  {
+    return std::addressof(this->m_value);
+  }
+
+  /// Returns the stored value
+  TL_OPTIONAL_11_CONSTEXPR T& operator*() & { return this->m_value; }
+
+  constexpr const T& operator*() const& { return this->m_value; }
+
+  TL_OPTIONAL_11_CONSTEXPR T&& operator*() &&
+  {
+    return std::move(this->m_value);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr const T&& operator*() const&& { return std::move(this->m_value); }
+#endif
+
+  /// Returns whether or not the optional has a value
+  constexpr bool has_value() const noexcept { return this->m_has_value; }
+
+  constexpr explicit operator bool() const noexcept
+  {
+    return this->m_has_value;
+  }
+
+  /// Returns the contained value if there is one, otherwise throws
+  /// bad_optional_access
+  TL_OPTIONAL_11_CONSTEXPR T& value() &
+  {
+    if (has_value())
+      return this->m_value;
+    throw bad_optional_access();
+  }
+  TL_OPTIONAL_11_CONSTEXPR const T& value() const&
+  {
+    if (has_value())
+      return this->m_value;
+    throw bad_optional_access();
+  }
+  TL_OPTIONAL_11_CONSTEXPR T&& value() &&
+  {
+    if (has_value())
+      return std::move(this->m_value);
+    throw bad_optional_access();
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  TL_OPTIONAL_11_CONSTEXPR const T&& value() const&&
+  {
+    if (has_value())
+      return std::move(this->m_value);
+    throw bad_optional_access();
+  }
+#endif
+
+  /// Returns the stored value if there is one, otherwise returns `u`
+  template<class U>
+  constexpr T value_or(U&& u) const&
+  {
+    static_assert(std::is_copy_constructible<T>::value &&
+                    std::is_convertible<U&&, T>::value,
+                  "T must be copy constructible and convertible from U");
+    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
+  }
+
+  template<class U>
+  TL_OPTIONAL_11_CONSTEXPR T value_or(U&& u) &&
+  {
+    static_assert(std::is_move_constructible<T>::value &&
+                    std::is_convertible<U&&, T>::value,
+                  "T must be move constructible and convertible from U");
+    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
+  }
+
+  /// Destroys the stored value if one exists, making the optional empty
+  void reset() noexcept
+  {
+    if (has_value()) {
+      this->m_value.~T();
+      this->m_has_value = false;
+    }
+  }
+}; // namespace tl
+
+/// Compares two optional objects
+template<class T, class U>
+inline constexpr bool
+operator==(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return lhs.has_value() == rhs.has_value() &&
+         (!lhs.has_value() || *lhs == *rhs);
+}
+template<class T, class U>
+inline constexpr bool
+operator!=(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return lhs.has_value() != rhs.has_value() ||
+         (lhs.has_value() && *lhs != *rhs);
+}
+template<class T, class U>
+inline constexpr bool
+operator<(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return rhs.has_value() && (!lhs.has_value() || *lhs < *rhs);
+}
+template<class T, class U>
+inline constexpr bool
+operator>(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return lhs.has_value() && (!rhs.has_value() || *lhs > *rhs);
+}
+template<class T, class U>
+inline constexpr bool
+operator<=(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return !lhs.has_value() || (rhs.has_value() && *lhs <= *rhs);
+}
+template<class T, class U>
+inline constexpr bool
+operator>=(const optional<T>& lhs, const optional<U>& rhs)
+{
+  return !rhs.has_value() || (lhs.has_value() && *lhs >= *rhs);
+}
+
+/// Compares an optional to a `nullopt`
+template<class T>
+inline constexpr bool
+operator==(const optional<T>& lhs, nullopt_t) noexcept
+{
+  return !lhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator==(nullopt_t, const optional<T>& rhs) noexcept
+{
+  return !rhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator!=(const optional<T>& lhs, nullopt_t) noexcept
+{
+  return lhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator!=(nullopt_t, const optional<T>& rhs) noexcept
+{
+  return rhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator<(const optional<T>&, nullopt_t) noexcept
+{
+  return false;
+}
+template<class T>
+inline constexpr bool
+operator<(nullopt_t, const optional<T>& rhs) noexcept
+{
+  return rhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator<=(const optional<T>& lhs, nullopt_t) noexcept
+{
+  return !lhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator<=(nullopt_t, const optional<T>&) noexcept
+{
+  return true;
+}
+template<class T>
+inline constexpr bool
+operator>(const optional<T>& lhs, nullopt_t) noexcept
+{
+  return lhs.has_value();
+}
+template<class T>
+inline constexpr bool
+operator>(nullopt_t, const optional<T>&) noexcept
+{
+  return false;
+}
+template<class T>
+inline constexpr bool
+operator>=(const optional<T>&, nullopt_t) noexcept
+{
+  return true;
+}
+template<class T>
+inline constexpr bool
+operator>=(nullopt_t, const optional<T>& rhs) noexcept
+{
+  return !rhs.has_value();
+}
+
+/// Compares the optional with a value.
+template<class T, class U>
+inline constexpr bool
+operator==(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs == rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator==(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs == *rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator!=(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs != rhs : true;
+}
+template<class T, class U>
+inline constexpr bool
+operator!=(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs != *rhs : true;
+}
+template<class T, class U>
+inline constexpr bool
+operator<(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs < rhs : true;
+}
+template<class T, class U>
+inline constexpr bool
+operator<(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs < *rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator<=(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs <= rhs : true;
+}
+template<class T, class U>
+inline constexpr bool
+operator<=(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs <= *rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator>(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs > rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator>(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs > *rhs : true;
+}
+template<class T, class U>
+inline constexpr bool
+operator>=(const optional<T>& lhs, const U& rhs)
+{
+  return lhs.has_value() ? *lhs >= rhs : false;
+}
+template<class T, class U>
+inline constexpr bool
+operator>=(const U& lhs, const optional<T>& rhs)
+{
+  return rhs.has_value() ? lhs >= *rhs : true;
+}
+
+template<class T,
+         detail::enable_if_t<std::is_move_constructible<T>::value>* = nullptr,
+         detail::enable_if_t<detail::is_swappable<T>::value>* = nullptr>
+void
+swap(optional<T>& lhs, optional<T>& rhs) noexcept(noexcept(lhs.swap(rhs)))
+{
+  return lhs.swap(rhs);
+}
+
+namespace detail {
+struct i_am_secret
+{};
+} // namespace detail
+
+template<
+  class T = detail::i_am_secret,
+  class U,
+  class Ret = detail::conditional_t<std::is_same<T, detail::i_am_secret>::value,
+                                    detail::decay_t<U>,
+                                    T>>
+inline constexpr optional<Ret>
+make_optional(U&& v)
+{
+  return optional<Ret>(std::forward<U>(v));
+}
+
+template<class T, class... Args>
+inline constexpr optional<T>
+make_optional(Args&&... args)
+{
+  return optional<T>(in_place, std::forward<Args>(args)...);
+}
+template<class T, class U, class... Args>
+inline constexpr optional<T>
+make_optional(std::initializer_list<U> il, Args&&... args)
+{
+  return optional<T>(in_place, il, std::forward<Args>(args)...);
+}
+
+#if __cplusplus >= 201703L
+template<class T>
+optional(T) -> optional<T>;
+#endif
+
+/// \exclude
+namespace detail {
+#ifdef TL_OPTIONAL_CXX14
+template<class Opt,
+         class F,
+         class Ret = decltype(detail::invoke(std::declval<F>(),
+                                             *std::declval<Opt>())),
+         detail::enable_if_t<!std::is_void<Ret>::value>* = nullptr>
+constexpr auto
+optional_map_impl(Opt&& opt, F&& f)
+{
+  return opt.has_value()
+           ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
+           : optional<Ret>(nullopt);
+}
+
+template<class Opt,
+         class F,
+         class Ret = decltype(detail::invoke(std::declval<F>(),
+                                             *std::declval<Opt>())),
+         detail::enable_if_t<std::is_void<Ret>::value>* = nullptr>
+auto
+optional_map_impl(Opt&& opt, F&& f)
+{
+  if (opt.has_value()) {
+    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
+    return make_optional(monostate{});
+  }
+
+  return optional<monostate>(nullopt);
+}
+#else
+template<class Opt,
+         class F,
+         class Ret = decltype(detail::invoke(std::declval<F>(),
+                                             *std::declval<Opt>())),
+         detail::enable_if_t<!std::is_void<Ret>::value>* = nullptr>
+
+constexpr auto
+optional_map_impl(Opt&& opt, F&& f) -> optional<Ret>
+{
+  return opt.has_value()
+           ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))
+           : optional<Ret>(nullopt);
+}
+
+template<class Opt,
+         class F,
+         class Ret = decltype(detail::invoke(std::declval<F>(),
+                                             *std::declval<Opt>())),
+         detail::enable_if_t<std::is_void<Ret>::value>* = nullptr>
+
+auto
+optional_map_impl(Opt&& opt, F&& f) -> optional<monostate>
+{
+  if (opt.has_value()) {
+    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));
+    return monostate{};
+  }
+
+  return nullopt;
+}
+#endif
+} // namespace detail
+
+/// Specialization for when `T` is a reference. `optional<T&>` acts similarly
+/// to a `T*`, but provides more operations and shows intent more clearly.
+template<class T>
+class optional<T&>
+{
+public:
+// The different versions for C++14 and 11 are needed because deduced return
+// types are not SFINAE-safe. This provides better support for things like
+// generic lambdas. C.f.
+// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+
+  /// Carries out some operation which returns an optional on the stored
+  /// object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto and_then(F&& f) &&
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  constexpr auto and_then(F&& f) const&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr auto and_then(F&& f) const&&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+#endif
+#else
+  /// Carries out some operation which returns an optional on the stored
+  /// object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T&> and_then(F&& f) &&
+  {
+    using result = detail::invoke_result_t<F, T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+  template<class F>
+  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr detail::invoke_result_t<F, const T&> and_then(F&& f) const&&
+  {
+    using result = detail::invoke_result_t<F, const T&>;
+    static_assert(detail::is_optional<result>::value,
+                  "F must return an optional");
+
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : result(nullopt);
+  }
+#endif
+#endif
+
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto map(F&& f) &&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto map(F&& f) const&
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto map(F&& f) const&&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
+    std::declval<optional&>(),
+    std::declval<F&&>()))
+  map(F&& f) &
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
+    std::declval<optional&&>(),
+    std::declval<F&&>()))
+  map(F&& f) &&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr decltype(detail::optional_map_impl(std::declval<const optional&>(),
+                                               std::declval<F&&>()))
+  map(F&& f) const&
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr decltype(detail::optional_map_impl(std::declval<const optional&&>(),
+                                               std::declval<F&&>()))
+  map(F&& f) const&&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \
+  !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR auto transform(F&& f) &&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto transform(F&& f) const&
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr auto transform(F&& f) const&&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#else
+  /// Carries out some operation on the stored object if there is one.
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
+    std::declval<optional&>(),
+    std::declval<F&&>()))
+  transform(F&& f) &
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+  /// \group map
+  /// \synopsis template <class F> auto transform(F &&f) &&;
+  template<class F>
+  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(
+    std::declval<optional&&>(),
+    std::declval<F&&>()))
+  transform(F&& f) &&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+
+  template<class F>
+  constexpr decltype(detail::optional_map_impl(std::declval<const optional&>(),
+                                               std::declval<F&&>()))
+  transform(F&& f) const&
+  {
+    return detail::optional_map_impl(*this, std::forward<F>(f));
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F>
+  constexpr decltype(detail::optional_map_impl(std::declval<const optional&&>(),
+                                               std::declval<F&&>()))
+  transform(F&& f) const&&
+  {
+    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));
+  }
+#endif
+#endif
+
+  /// Calls `f` if the optional is empty
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
+  {
+    if (has_value())
+      return *this;
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &
+  {
+    return has_value() ? *this : std::forward<F>(f)();
+  }
+
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) &&
+  {
+    if (has_value())
+      return std::move(*this);
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) &&
+  {
+    return has_value() ? std::move(*this) : std::forward<F>(f)();
+  }
+
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&
+  {
+    if (has_value())
+      return *this;
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F&& f) const&
+  {
+    return has_value() ? *this : std::forward<F>(f)();
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, detail::enable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&&
+  {
+    if (has_value())
+      return std::move(*this);
+
+    std::forward<F>(f)();
+    return nullopt;
+  }
+
+  template<class F, detail::disable_if_ret_void<F>* = nullptr>
+  optional<T> or_else(F&& f) const&&
+  {
+    return has_value() ? std::move(*this) : std::forward<F>(f)();
+  }
+#endif
+
+  /// Maps the stored value with `f` if there is one, otherwise returns `u`
+  template<class F, class U>
+  U map_or(F&& f, U&& u) &
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u);
+  }
+
+  template<class F, class U>
+  U map_or(F&& f, U&& u) &&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u);
+  }
+
+  template<class F, class U>
+  U map_or(F&& f, U&& u) const&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, class U>
+  U map_or(F&& f, U&& u) const&&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u);
+  }
+#endif
+
+  /// Maps the stored value with `f` if there is one, otherwise calls
+  /// `u` and returns the result.
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u)();
+  }
+
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) &&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u)();
+  }
+
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), **this)
+                       : std::forward<U>(u)();
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  template<class F, class U>
+  detail::invoke_result_t<U> map_or_else(F&& f, U&& u) const&&
+  {
+    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))
+                       : std::forward<U>(u)();
+  }
+#endif
+
+  /// Returns `u` if `*this` has a value, otherwise an empty optional.
+  template<class U>
+  constexpr optional<typename std::decay<U>::type> conjunction(U&& u) const
+  {
+    using result = optional<detail::decay_t<U>>;
+    return has_value() ? result{ u } : result{ nullopt };
+  }
+
+  /// Returns `rhs` if `*this` is empty, otherwise the current value.
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &
+  {
+    return has_value() ? *this : rhs;
+  }
+
+  constexpr optional disjunction(const optional& rhs) const&
+  {
+    return has_value() ? *this : rhs;
+  }
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional& rhs) &&
+  {
+    return has_value() ? std::move(*this) : rhs;
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr optional disjunction(const optional& rhs) const&&
+  {
+    return has_value() ? std::move(*this) : rhs;
+  }
+#endif
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &
+  {
+    return has_value() ? *this : std::move(rhs);
+  }
+
+  constexpr optional disjunction(optional&& rhs) const&
+  {
+    return has_value() ? *this : std::move(rhs);
+  }
+
+  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional&& rhs) &&
+  {
+    return has_value() ? std::move(*this) : std::move(rhs);
+  }
+
+#ifndef TL_OPTIONAL_NO_CONSTRR
+  constexpr optional disjunction(optional&& rhs) const&&
+  {
+    return has_value() ? std::move(*this) : std::move(rhs);
+  }
+#endif
+
+  /// Takes the value out of the optional, leaving it empty
+  optional take()
+  {
+    optional ret = std::move(*this);
+    reset();
+    return ret;
+  }
+
+  using value_type = T&;
+
+  /// Constructs an optional that does not contain a value.
+  constexpr optional() noexcept
+    : m_value(nullptr)
+  {
+  }
+
+  constexpr optional(nullopt_t) noexcept
+    : m_value(nullptr)
+  {
+  }
+
+  /// Copy constructor
+  ///
+  /// If `rhs` contains a value, the stored value is direct-initialized with
+  /// it. Otherwise, the constructed optional is empty.
+  TL_OPTIONAL_11_CONSTEXPR optional(const optional& rhs) noexcept = default;
+
+  /// Move constructor
+  ///
+  /// If `rhs` contains a value, the stored value is direct-initialized with
+  /// it. Otherwise, the constructed optional is empty.
+  TL_OPTIONAL_11_CONSTEXPR optional(optional&& rhs) = default;
+
+  /// Constructs the stored value with `u`.
+  template<class U = T,
+           detail::enable_if_t<
+             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
+  constexpr optional(U&& u) noexcept
+    : m_value(std::addressof(u))
+  {
+    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
+  }
+
+  template<class U>
+  constexpr explicit optional(const optional<U>& rhs) noexcept
+    : optional(*rhs)
+  {
+  }
+
+  /// No-op
+  ~optional() = default;
+
+  /// Assignment to empty.
+  ///
+  /// Destroys the current value if there is one.
+  optional& operator=(nullopt_t) noexcept
+  {
+    m_value = nullptr;
+    return *this;
+  }
+
+  /// Copy assignment.
+  ///
+  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
+  /// resets the stored value in `*this`.
+  optional& operator=(const optional& rhs) = default;
+
+  /// Rebinds this optional to `u`.
+  template<class U = T,
+           detail::enable_if_t<
+             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
+  optional& operator=(U&& u)
+  {
+    static_assert(std::is_lvalue_reference<U>::value, "U must be an lvalue");
+    m_value = std::addressof(u);
+    return *this;
+  }
+
+  /// Converting copy assignment operator.
+  ///
+  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise
+  /// resets the stored value in `*this`.
+  template<class U>
+  optional& operator=(const optional<U>& rhs) noexcept
+  {
+    m_value = std::addressof(rhs.value());
+    return *this;
+  }
+
+  /// Rebinds this optional to `u`.
+  template<class U = T,
+           detail::enable_if_t<
+             !detail::is_optional<detail::decay_t<U>>::value>* = nullptr>
+  optional& emplace(U&& u) noexcept
+  {
+    return *this = std::forward<U>(u);
+  }
+
+  void swap(optional& rhs) noexcept { std::swap(m_value, rhs.m_value); }
+
+  /// Returns a pointer to the stored value
+  constexpr const T* operator->() const noexcept { return m_value; }
+
+  TL_OPTIONAL_11_CONSTEXPR T* operator->() noexcept { return m_value; }
+
+  /// Returns the stored value
+  TL_OPTIONAL_11_CONSTEXPR T& operator*() noexcept { return *m_value; }
+
+  constexpr const T& operator*() const noexcept { return *m_value; }
+
+  constexpr bool has_value() const noexcept { return m_value != nullptr; }
+
+  constexpr explicit operator bool() const noexcept
+  {
+    return m_value != nullptr;
+  }
+
+  /// Returns the contained value if there is one, otherwise throws
+  /// bad_optional_access
+  TL_OPTIONAL_11_CONSTEXPR T& value()
+  {
+    if (has_value())
+      return *m_value;
+    throw bad_optional_access();
+  }
+  TL_OPTIONAL_11_CONSTEXPR const T& value() const
+  {
+    if (has_value())
+      return *m_value;
+    throw bad_optional_access();
+  }
+
+  /// Returns the stored value if there is one, otherwise returns `u`
+  template<class U>
+  constexpr T value_or(U&& u) const& noexcept
+  {
+    static_assert(std::is_copy_constructible<T>::value &&
+                    std::is_convertible<U&&, T>::value,
+                  "T must be copy constructible and convertible from U");
+    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
+  }
+
+  /// \group value_or
+  template<class U>
+  TL_OPTIONAL_11_CONSTEXPR T value_or(U&& u) && noexcept
+  {
+    static_assert(std::is_move_constructible<T>::value &&
+                    std::is_convertible<U&&, T>::value,
+                  "T must be move constructible and convertible from U");
+    return has_value() ? **this : static_cast<T>(std::forward<U>(u));
+  }
+
+  /// Destroys the stored value if one exists, making the optional empty
+  void reset() noexcept { m_value = nullptr; }
+
+private:
+  T* m_value;
+}; // namespace tl
+
+} // namespace tl
+
+namespace std {
+// TODO SFINAE
+template<class T>
+struct hash<tl::optional<T>>
+{
+  ::std::size_t operator()(const tl::optional<T>& o) const
+  {
+    if (!o.has_value())
+      return 0;
+
+    return std::hash<tl::detail::remove_const_t<T>>()(*o);
+  }
+};
+} // namespace std
+
+#endif
```

## cmeel.prefix/include/proxsuite/helpers/version.hpp

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file version.hpp
- */
-
-#ifndef PROXSUITE_HELPERS_VERSION_HPP
-#define PROXSUITE_HELPERS_VERSION_HPP
-
-#include "proxsuite/config.hpp"
-#include <string>
-#include <sstream>
-
-namespace proxsuite {
-namespace helpers {
-
-inline std::string
-printVersion(const std::string& delimiter = ".")
-{
-  std::ostringstream oss;
-  oss << PROXSUITE_MAJOR_VERSION << delimiter << PROXSUITE_MINOR_VERSION
-      << delimiter << PROXSUITE_PATCH_VERSION;
-  return oss.str();
-}
-
-inline bool
-checkVersionAtLeast(signed int major_version,
-                    signed int minor_version,
-                    signed int patch_version)
-{
-  return PROXSUITE_VERSION_AT_LEAST(
-    major_version, minor_version, patch_version);
-}
-
-} // helpers
-} // proxsuite
-
-#endif // ifndef PROXSUITE_HELPERS_VERSION_HPP
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file version.hpp
+ */
+
+#ifndef PROXSUITE_HELPERS_VERSION_HPP
+#define PROXSUITE_HELPERS_VERSION_HPP
+
+#include "proxsuite/config.hpp"
+#include <string>
+#include <sstream>
+
+namespace proxsuite {
+namespace helpers {
+
+inline std::string
+printVersion(const std::string& delimiter = ".")
+{
+  std::ostringstream oss;
+  oss << PROXSUITE_MAJOR_VERSION << delimiter << PROXSUITE_MINOR_VERSION
+      << delimiter << PROXSUITE_PATCH_VERSION;
+  return oss.str();
+}
+
+inline bool
+checkVersionAtLeast(signed int major_version,
+                    signed int minor_version,
+                    signed int patch_version)
+{
+  return PROXSUITE_VERSION_AT_LEAST(
+    major_version, minor_version, patch_version);
+}
+
+} // helpers
+} // proxsuite
+
+#endif // ifndef PROXSUITE_HELPERS_VERSION_HPP
```

## cmeel.prefix/include/proxsuite/linalg/dense/core.hpp

```diff
@@ -1,863 +1,863 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP
-
-#include <proxsuite/linalg/veg/util/dbg.hpp>
-#include <proxsuite/linalg/veg/util/assert.hpp>
-#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
-
-#if !(defined(__aarch64__) || defined(__PPC64__) || defined(__ppc64__) ||      \
-      defined(_ARCH_PPC64))
-#include <immintrin.h>
-#endif
-
-#ifdef PROXSUITE_VECTORIZE
-#include <cmath> // to avoid error of the type no member named 'isnan' in namespace 'std';
-#include <simde/x86/avx2.h>
-#include <simde/x86/fma.h>
-#endif
-
-#include <Eigen/Core>
-
-#define LDLT_ID(id) __VEG_PP_CAT(id, __LINE__)
-
-#define __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, Make)                    \
-  auto LDLT_ID(vec_storage) = (Stack).Make(                                    \
-    ::proxsuite::linalg::veg::Tag<__VEG_PP_REMOVE_PAREN(Type)>{},              \
-    (Rows),                                                                    \
-    ::proxsuite::linalg::dense::_detail::align<__VEG_PP_REMOVE_PAREN(          \
-      Type)>());                                                               \
-  auto Name /* NOLINT */ = ::Eigen::Map<                                       \
-    ::Eigen::Matrix<__VEG_PP_REMOVE_PAREN(Type), ::Eigen::Dynamic, 1>,         \
-    ::Eigen::Unaligned,                                                        \
-    ::Eigen::Stride<::Eigen::Dynamic, 1>>{                                     \
-    LDLT_ID(vec_storage).ptr_mut(),                                            \
-    LDLT_ID(vec_storage).len(),                                                \
-    ::Eigen::Stride<::Eigen::Dynamic, 1>{                                      \
-      LDLT_ID(vec_storage).len(),                                              \
-      1,                                                                       \
-    },                                                                         \
-  };                                                                           \
-  static_assert(true, ".")
-
-#define __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, Make)              \
-  ::proxsuite::linalg::veg::isize LDLT_ID(rows) = (Rows);                      \
-  ::proxsuite::linalg::veg::isize LDLT_ID(cols) = (Cols);                      \
-  ::proxsuite::linalg::veg::isize LDLT_ID(stride) =                            \
-    ::proxsuite::linalg::dense::_detail::adjusted_stride<                      \
-      __VEG_PP_REMOVE_PAREN(Type)>(LDLT_ID(rows));                             \
-  auto LDLT_ID(vec_storage) = (Stack).Make(                                    \
-    ::proxsuite::linalg::veg::Tag<__VEG_PP_REMOVE_PAREN(Type)>{},              \
-    LDLT_ID(stride) * LDLT_ID(cols),                                           \
-    ::proxsuite::linalg::dense::_detail::align<__VEG_PP_REMOVE_PAREN(          \
-      Type)>());                                                               \
-  auto Name /* NOLINT */ =                                                     \
-    ::Eigen::Map<::Eigen::Matrix<__VEG_PP_REMOVE_PAREN(Type),                  \
-                                 ::Eigen::Dynamic,                             \
-                                 ::Eigen::Dynamic,                             \
-                                 ::Eigen::ColMajor>,                           \
-                 ::Eigen::Unaligned,                                           \
-                 ::Eigen::Stride<::Eigen::Dynamic, 1>>{                        \
-      LDLT_ID(vec_storage).ptr_mut(),                                          \
-      LDLT_ID(rows),                                                           \
-      LDLT_ID(cols),                                                           \
-      ::Eigen::Stride<::Eigen::Dynamic, 1>{                                    \
-        LDLT_ID(stride),                                                       \
-        1,                                                                     \
-      },                                                                       \
-    };                                                                         \
-  static_assert(true, ".")
-
-#define LDLT_TEMP_VEC(Type, Name, Rows, Stack)                                 \
-  __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, make_new)
-#define LDLT_TEMP_VEC_UNINIT(Type, Name, Rows, Stack)                          \
-  __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, make_new_for_overwrite)
-
-#define LDLT_TEMP_MAT(Type, Name, Rows, Cols, Stack)                           \
-  __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, make_new)
-#define LDLT_TEMP_MAT_UNINIT(Type, Name, Rows, Cols, Stack)                    \
-  __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, make_new_for_overwrite)
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-using proxsuite::linalg::veg::i32;
-using proxsuite::linalg::veg::isize;
-using proxsuite::linalg::veg::u32;
-using proxsuite::linalg::veg::usize;
-using f32 = float;
-using f64 = double;
-
-namespace _detail {
-namespace _simd {
-
-#ifdef __clang__
-#define DENSE_LDLT_FP_PRAGMA _Pragma("STDC FP_CONTRACT ON")
-#else
-#define DENSE_LDLT_FP_PRAGMA
-#endif
-
-static_assert(static_cast<unsigned char>(-1) == 255, "char should have 8 bits");
-static_assert(sizeof(f32) == 4, "f32 should be 32 bits");
-static_assert(sizeof(f64) == 8, "f64 should be 64 bits");
-
-#define LDLT_FN_IMPL3(Fn, Prefix, Suffix)                                      \
-  VEG_INLINE static auto Fn(Pack a, Pack b, Pack c) noexcept -> Pack           \
-  {                                                                            \
-    return Pack{ simde_mm##Prefix##_##Fn##_##Suffix(                           \
-      a.inner, b.inner, c.inner) };                                            \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-#define LDLT_ARITHMETIC_IMPL(Prefix, Suffix)                                   \
-  LDLT_FN_IMPL3(fmadd, Prefix, Suffix);  /* (a * b + c) */                     \
-  LDLT_FN_IMPL3(fnmadd, Prefix, Suffix); /* (-a * b + c) */
-
-#define LDLT_LOAD_STORE(Prefix, Suffix)                                        \
-  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept        \
-    -> Pack                                                                    \
-  {                                                                            \
-    return Pack{ simde_mm##Prefix##_loadu_##Suffix(ptr) };                     \
-  }                                                                            \
-  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack          \
-  {                                                                            \
-    return Pack{ simde_mm##Prefix##_set1_##Suffix(value) };                    \
-  }                                                                            \
-  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept              \
-  {                                                                            \
-    simde_mm##Prefix##_storeu_##Suffix(ptr, inner);                            \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-template<typename T, usize N>
-struct Pack;
-
-template<typename T>
-struct Pack<T, 1>
-{
-  using ScalarType = T;
-
-  T inner;
-
-  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    DENSE_LDLT_FP_PRAGMA
-    return { a.inner * b.inner + c.inner };
-  }
-  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    return fmadd({ -a.inner }, b, c);
-  }
-  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
-  {
-    return { *ptr };
-  }
-  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
-  {
-    return { value };
-  }
-  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
-  {
-    *ptr = inner;
-  }
-};
-
-#ifdef PROXSUITE_VECTORIZE
-template<>
-struct Pack<f32, 4>
-{
-  using ScalarType = f32;
-
-  simde__m128 inner;
-  LDLT_ARITHMETIC_IMPL(, ps)
-  LDLT_LOAD_STORE(, ps);
-};
-
-template<>
-struct Pack<f32, 8>
-{
-  using ScalarType = f32;
-
-  simde__m256 inner;
-  LDLT_ARITHMETIC_IMPL(256, ps)
-  LDLT_LOAD_STORE(256, ps);
-};
-
-#ifdef __AVX512F__
-template<>
-struct Pack<f32, 16>
-{
-  using ScalarType = f32;
-
-  __m512 inner;
-  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    DENSE_LDLT_FP_PRAGMA
-    return { _mm512_fmadd_ps(a.inner, b.inner, c.inner) };
-  }
-  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    return { _mm512_fnmadd_ps(a.inner, b.inner, c.inner) };
-  }
-  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
-  {
-    return { _mm512_loadu_ps(ptr) };
-  }
-  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
-  {
-    return { _mm512_set1_ps(value) };
-  }
-  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
-  {
-    _mm512_storeu_ps(ptr, inner);
-  }
-};
-#endif
-
-template<>
-struct Pack<f64, 2>
-{
-  using ScalarType = f64;
-
-  simde__m128d inner;
-  LDLT_ARITHMETIC_IMPL(, pd)
-  LDLT_LOAD_STORE(, pd);
-};
-template<>
-struct Pack<f64, 4>
-{
-  using ScalarType = f64;
-
-  simde__m256d inner;
-  LDLT_ARITHMETIC_IMPL(256, pd)
-  LDLT_LOAD_STORE(256, pd);
-};
-
-#ifdef __AVX512F__
-template<>
-struct Pack<f64, 8>
-{
-  using ScalarType = f64;
-
-  __m512d inner;
-  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    DENSE_LDLT_FP_PRAGMA
-    return { _mm512_fmadd_pd(a.inner, b.inner, c.inner) };
-  }
-  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
-  {
-    return { _mm512_fnmadd_pd(a.inner, b.inner, c.inner) };
-  }
-  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
-  {
-    return { _mm512_loadu_pd(ptr) };
-  }
-  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
-  {
-    return { _mm512_set1_pd(value) };
-  }
-  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
-  {
-    _mm512_storeu_pd(ptr, inner);
-  }
-};
-#endif
-
-#endif
-
-template<typename T>
-struct NativePackInfo
-{
-  static constexpr usize N = 1;
-  using Type = Pack<f32, N>;
-};
-
-#ifdef PROXSUITE_VECTORIZE
-template<>
-struct NativePackInfo<f32>
-{
-  static constexpr usize N = SIMDE_NATURAL_VECTOR_SIZE / 32;
-  using Type = Pack<f32, N>;
-};
-template<>
-struct NativePackInfo<f64>
-{
-  static constexpr usize N = SIMDE_NATURAL_VECTOR_SIZE / 64;
-  using Type = Pack<f64, N>;
-};
-#endif
-
-template<typename T>
-using NativePack = typename NativePackInfo<T>::Type;
-} // namespace _simd
-} // namespace _detail
-
-namespace _detail {
-using proxsuite::linalg::veg::uncvref_t;
-template<bool COND, typename T>
-using const_if = proxsuite::linalg::veg::meta::if_t<COND, T const, T>;
-
-template<typename T>
-using ptr_is_const = proxsuite::linalg::veg::meta::bool_constant<VEG_CONCEPT(
-  const_type<proxsuite::linalg::veg::meta::unptr_t<T>>)>;
-
-template<typename T>
-constexpr auto
-round_up(T a, T b) noexcept -> T
-{
-  return a + (b - 1) / b * b;
-}
-
-#ifdef PROXSUITE_VECTORIZE
-template<typename T>
-using should_vectorize =
-  proxsuite::linalg::veg::meta::bool_constant<VEG_CONCEPT(same<T, f32>) ||
-                                              VEG_CONCEPT(same<T, f64>)>;
-#else
-template<typename T>
-using should_vectorize = proxsuite::linalg::veg::meta::bool_constant<false>;
-#endif
-
-template<typename T>
-auto
-adjusted_stride(isize n) noexcept -> isize
-{
-#ifndef SIMDE_NATURAL_FLOAT_VECTOR_SIZE
-  isize simd_stride = 1;
-#else
-  isize simd_stride =
-    (SIMDE_NATURAL_VECTOR_SIZE / CHAR_BIT) / isize{ sizeof(T) };
-#endif
-  return _detail::should_vectorize<T>::value ? _detail::round_up(n, simd_stride)
-                                             : n;
-}
-template<typename T>
-auto
-align() noexcept -> isize
-{
-  return isize{ alignof(T) } * _detail::adjusted_stride<T>(1);
-}
-
-struct NoCopy
-{
-  NoCopy() = default;
-  ~NoCopy() = default;
-
-  NoCopy(NoCopy const&) = delete;
-  NoCopy(NoCopy&&) = delete;
-  auto operator=(NoCopy const&) -> NoCopy& = delete;
-  auto operator=(NoCopy&&) -> NoCopy& = delete;
-};
-
-namespace nb {
-struct max2
-{
-  template<typename T>
-  VEG_INLINE constexpr auto operator()(T const& a, T const& b) const -> T const&
-  {
-    return a > b ? a : b;
-  }
-};
-struct min2
-{
-  template<typename T>
-  VEG_INLINE constexpr auto operator()(T a, T b) const -> T
-  {
-    return (a < b) ? a : b;
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(min2);
-VEG_NIEBLOID(max2);
-
-template<typename T>
-void
-set_zero(T* dest, usize n)
-{
-  for (usize i = 0; i < n; ++i) {
-    *dest = 0;
-  }
-}
-
-template<typename T>
-using OwnedMatrix =
-  Eigen::Matrix<typename T::Scalar,
-                Eigen::Dynamic,
-                Eigen::Dynamic,
-                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
-
-template<typename T>
-using OwnedAll =
-  Eigen::Matrix<typename T::Scalar,
-                T::RowsAtCompileTime,
-                T::ColsAtCompileTime,
-                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
-
-template<typename T>
-using OwnedRows =
-  Eigen::Matrix<typename T::Scalar,
-                Eigen::Dynamic,
-                T::ColsAtCompileTime,
-                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
-
-template<typename T>
-using OwnedCols =
-  Eigen::Matrix<typename T::Scalar,
-                T::RowsAtCompileTime,
-                Eigen::Dynamic,
-                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
-
-template<typename T>
-using OwnedColVector = Eigen::Matrix< //
-  typename T::Scalar,
-  Eigen::Dynamic,
-  1,
-  Eigen::ColMajor>;
-template<typename T>
-using OwnedRowVector = Eigen::Matrix< //
-  typename T::Scalar,
-  1,
-  Eigen::Dynamic,
-  Eigen::RowMajor>;
-
-template<bool ROWMAJOR>
-struct ElemAddrImpl;
-
-template<>
-struct ElemAddrImpl<false>
-{
-  template<typename T>
-  static auto fn(T* ptr,
-                 isize row,
-                 isize col,
-                 isize outer_stride,
-                 isize inner_stride) noexcept -> T*
-  {
-    return ptr + (inner_stride * row + outer_stride * col);
-  }
-};
-template<>
-struct ElemAddrImpl<true>
-{
-  template<typename T>
-  static auto fn(T* ptr,
-                 isize row,
-                 isize col,
-                 isize outer_stride,
-                 isize inner_stride) noexcept -> T*
-  {
-    return ptr + (outer_stride * row + inner_stride * col);
-  }
-};
-
-template<bool COLMAJOR>
-struct RowColAccessImpl;
-
-template<>
-struct RowColAccessImpl<true>
-{
-  template<typename T>
-  using Col =
-    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T &&).data())>::value,
-                        OwnedColVector<uncvref_t<T>>>,
-               Eigen::Unaligned,
-               Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>>;
-  template<typename T>
-  using Row =
-    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T &&).data())>::value,
-                        OwnedRowVector<uncvref_t<T>>>,
-               Eigen::Unaligned,
-               Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>>;
-
-  template<typename T>
-  static auto col(T&& mat, isize col_idx) noexcept -> Col<T>
-  {
-    return {
-      mat.data() + col_idx * mat.outerStride(),
-      mat.rows(),
-      1,
-      Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>{
-        mat.innerStride(),
-      },
-    };
-  }
-  template<typename T>
-  static auto row(T&& mat, isize row_idx) noexcept -> Row<T>
-  {
-    return {
-      mat.data() + row_idx * mat.innerStride(),
-      1,
-      mat.cols(),
-      Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>{
-        mat.outerStride(),
-      },
-    };
-  }
-};
-template<>
-struct RowColAccessImpl<false>
-{
-  template<typename T>
-  using Col =
-    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T &&).data())>::value,
-                        OwnedColVector<uncvref_t<T>>>,
-               Eigen::Unaligned,
-               Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>>;
-  template<typename T>
-  using Row =
-    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T &&).data())>::value,
-                        OwnedRowVector<uncvref_t<T>>>,
-               Eigen::Unaligned,
-               Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>>;
-
-  template<typename T>
-  static auto col(T&& mat, isize col_idx) noexcept -> Col<T>
-  {
-    return {
-      mat.data() + col_idx * mat.innerStride(),
-      mat.rows(),
-      1,
-      Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>{
-        mat.outerStride(),
-      },
-    };
-  }
-  template<typename T>
-  static auto row(T&& mat, isize row_idx) noexcept -> Row<T>
-  {
-    return {
-      mat.data() + row_idx * mat.outerStride(),
-      1,
-      mat.cols(),
-      Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>{
-        mat.innerStride(),
-      },
-    };
-  }
-};
-template<typename T>
-using StrideOf = Eigen::Stride< //
-  T::OuterStrideAtCompileTime,
-  T::InnerStrideAtCompileTime>;
-} // namespace _detail
-
-namespace util {
-template<bool COLMAJOR, typename T>
-auto
-elem_addr(T* ptr,
-          isize row,
-          isize col,
-          isize outer_stride,
-          isize inner_stride) noexcept -> T*
-{
-  return _detail::ElemAddrImpl<!COLMAJOR>::fn(
-    ptr, row, col, outer_stride, inner_stride);
-}
-
-template<typename Mat>
-auto
-matrix_elem_addr(Mat&& mat, isize row, isize col) noexcept
-  -> decltype(mat.data())
-{
-  return util::elem_addr<!bool(
-    proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>( //
-    mat.data(),
-    row,
-    col,
-    mat.outerStride(),
-    mat.innerStride());
-}
-
-template<typename T>
-auto
-col(T&& mat, isize col_idx) noexcept -> typename _detail::RowColAccessImpl<
-  !bool(proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::template Col<T>
-{
-  return _detail::RowColAccessImpl<!bool(
-    proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::col(mat, col_idx);
-}
-template<typename T>
-auto
-row(T&& mat, isize row_idx) noexcept -> typename _detail::RowColAccessImpl<
-  !bool(proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::template Row<T>
-{
-  return _detail::RowColAccessImpl<!bool(
-    proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::row(mat, row_idx);
-}
-
-template<typename Mat>
-auto
-trans(Mat&& mat) noexcept -> Eigen::Map< //
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    Eigen::Matrix< //
-                      typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar,
-                      proxsuite::linalg::veg::uncvref_t<Mat>::ColsAtCompileTime,
-                      proxsuite::linalg::veg::uncvref_t<Mat>::RowsAtCompileTime,
-                      bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)
-                        ? Eigen::ColMajor
-                        : Eigen::RowMajor>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    mat.data(),
-    mat.cols(),
-    mat.rows(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-diagonal(Mat&& mat) noexcept -> Eigen::Map< //
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    Eigen::Matrix< //
-                      typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar,
-                      Eigen::Dynamic,
-                      1,
-                      Eigen::ColMajor>>,
-  Eigen::Unaligned,
-  Eigen::InnerStride<Eigen::Dynamic>>
-{
-  VEG_DEBUG_ASSERT( //
-    mat.rows() == mat.cols());
-  return { mat.data(),
-           mat.rows(),
-           1,
-           Eigen::InnerStride<Eigen::Dynamic>{ mat.outerStride() + 1 } };
-}
-
-template<typename Mat>
-auto
-submatrix(Mat&& mat,
-          isize row_start,
-          isize col_start,
-          isize nrows,
-          isize ncols) noexcept
-  -> Eigen::Map<_detail::const_if<
-                  _detail::ptr_is_const<decltype(mat.data())>::value,
-                  _detail::OwnedMatrix<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-                Eigen::Unaligned,
-                _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
-      mat.data(), row_start, col_start, mat.outerStride(), mat.innerStride()),
-    nrows,
-    ncols,
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-to_view(Mat&& mat) noexcept -> Eigen::Map<
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    _detail::OwnedAll<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    mat.data(),
-    mat.rows(),
-    mat.cols(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-to_view_dyn_rows(Mat&& mat) noexcept -> Eigen::Map<
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    _detail::OwnedRows<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    mat.data(),
-    mat.rows(),
-    mat.cols(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-to_view_dyn_cols(Mat&& mat) noexcept -> Eigen::Map<
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    _detail::OwnedCols<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    mat.data(),
-    mat.rows(),
-    mat.cols(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-to_view_dyn(Mat&& mat) noexcept
-  -> Eigen::Map<_detail::const_if<
-                  _detail::ptr_is_const<decltype(mat.data())>::value,
-                  _detail::OwnedMatrix<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-                Eigen::Unaligned,
-                _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    mat.data(),
-    mat.rows(),
-    mat.cols(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-subrows(Mat&& mat, isize row_start, isize nrows) noexcept -> Eigen::Map<
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    _detail::OwnedRows<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
-      mat.data(), row_start, 0, mat.outerStride(), mat.innerStride()),
-    nrows,
-    mat.cols(),
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-template<typename Mat>
-auto
-subcols(Mat&& mat, isize col_start, isize ncols) noexcept -> Eigen::Map<
-  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
-                    _detail::OwnedCols<proxsuite::linalg::veg::uncvref_t<Mat>>>,
-  Eigen::Unaligned,
-  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
-{
-  return {
-    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
-      mat.data(), 0, col_start, mat.outerStride(), mat.innerStride()),
-    mat.rows(),
-    ncols,
-    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
-      mat.outerStride(),
-      mat.innerStride(),
-    },
-  };
-}
-
-} // namespace util
-namespace _detail {
-template<typename Dst, typename Lhs, typename Rhs, typename T>
-void
-noalias_mul_add_impl(Dst dst, Lhs lhs, Rhs rhs, T factor)
-{
-  VEG_ASSERT_ALL_OF(dst.rows() == lhs.rows(),
-                    dst.cols() == rhs.cols(),
-                    lhs.cols() == rhs.rows());
-
-  isize nrows = dst.rows();
-  isize ncols = dst.cols();
-  isize depth = lhs.cols();
-
-  if (nrows == 0 || ncols == 0 || depth == 0) {
-    return;
-  }
-
-#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
-#define LAZY_PRODUCT(a, b) a.lazyProduct(b)
-#else
-#define LAZY_PRODUCT(a, b) a.operator*(b)
-#endif
-
-#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
-  if ((dst.rows() < 20) && (dst.cols() < 20) && (rhs.rows() < 20)) {
-    // gemm
-    // workaround for eigen 3.3.7 bug:
-    // https://gitlab.com/libeigen/eigen/-/issues/1562
-    using Mat =
-      Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor, 20, 20>;
-    using MapMut =
-      Eigen::Map<Mat, Eigen::Unaligned, Eigen::OuterStride<Eigen::Dynamic>>;
-
-    auto dst_ =
-      MapMut(dst.data(), dst.rows(), dst.cols(), { dst.outerStride() });
-    dst_.noalias().operator+=(factor * LAZY_PRODUCT(lhs, rhs));
-  } else
-#endif
-  {
-    dst.noalias().operator+=(factor * LAZY_PRODUCT(lhs, rhs));
-  }
-
-#undef LAZY_PRODUCT
-}
-} // namespace _detail
-namespace util {
-template<typename Dst, typename Lhs, typename Rhs, typename T>
-void
-noalias_mul_add(Dst&& dst, Lhs const& lhs, Rhs const& rhs, T factor)
-{
-  _detail::noalias_mul_add_impl(
-    util::submatrix(dst, 0, 0, dst.rows(), dst.cols()),
-    util::submatrix(lhs, 0, 0, lhs.rows(), lhs.cols()),
-    util::submatrix(rhs, 0, 0, rhs.rows(), rhs.cols()),
-    factor);
-}
-} // namespace util
-template<typename T>
-auto
-temp_mat_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
-             isize rows,
-             isize cols) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return {
-    _detail::adjusted_stride<T>(rows) * cols * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-}
-
-template<typename T>
-auto
-temp_vec_req(proxsuite::linalg::veg::Tag<T> /*tag*/, isize rows) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return {
-    rows * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-}
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP
+
+#include <proxsuite/linalg/veg/util/dbg.hpp>
+#include <proxsuite/linalg/veg/util/assert.hpp>
+#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
+
+#if !(defined(__aarch64__) || defined(__PPC64__) || defined(__ppc64__) ||      \
+      defined(_ARCH_PPC64))
+#include <immintrin.h>
+#endif
+
+#ifdef PROXSUITE_VECTORIZE
+#include <cmath> // to avoid error of the type no member named 'isnan' in namespace 'std';
+#include <simde/x86/avx2.h>
+#include <simde/x86/fma.h>
+#endif
+
+#include <Eigen/Core>
+
+#define LDLT_ID(id) __VEG_PP_CAT(id, __LINE__)
+
+#define __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, Make)                    \
+  auto LDLT_ID(vec_storage) = (Stack).Make(                                    \
+    ::proxsuite::linalg::veg::Tag<__VEG_PP_REMOVE_PAREN(Type)>{},              \
+    (Rows),                                                                    \
+    ::proxsuite::linalg::dense::_detail::align<__VEG_PP_REMOVE_PAREN(          \
+      Type)>());                                                               \
+  auto Name /* NOLINT */ = ::Eigen::Map<                                       \
+    ::Eigen::Matrix<__VEG_PP_REMOVE_PAREN(Type), ::Eigen::Dynamic, 1>,         \
+    ::Eigen::Unaligned,                                                        \
+    ::Eigen::Stride<::Eigen::Dynamic, 1>>{                                     \
+    LDLT_ID(vec_storage).ptr_mut(),                                            \
+    LDLT_ID(vec_storage).len(),                                                \
+    ::Eigen::Stride<::Eigen::Dynamic, 1>{                                      \
+      LDLT_ID(vec_storage).len(),                                              \
+      1,                                                                       \
+    },                                                                         \
+  };                                                                           \
+  static_assert(true, ".")
+
+#define __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, Make)              \
+  ::proxsuite::linalg::veg::isize LDLT_ID(rows) = (Rows);                      \
+  ::proxsuite::linalg::veg::isize LDLT_ID(cols) = (Cols);                      \
+  ::proxsuite::linalg::veg::isize LDLT_ID(stride) =                            \
+    ::proxsuite::linalg::dense::_detail::adjusted_stride<                      \
+      __VEG_PP_REMOVE_PAREN(Type)>(LDLT_ID(rows));                             \
+  auto LDLT_ID(vec_storage) = (Stack).Make(                                    \
+    ::proxsuite::linalg::veg::Tag<__VEG_PP_REMOVE_PAREN(Type)>{},              \
+    LDLT_ID(stride) * LDLT_ID(cols),                                           \
+    ::proxsuite::linalg::dense::_detail::align<__VEG_PP_REMOVE_PAREN(          \
+      Type)>());                                                               \
+  auto Name /* NOLINT */ =                                                     \
+    ::Eigen::Map<::Eigen::Matrix<__VEG_PP_REMOVE_PAREN(Type),                  \
+                                 ::Eigen::Dynamic,                             \
+                                 ::Eigen::Dynamic,                             \
+                                 ::Eigen::ColMajor>,                           \
+                 ::Eigen::Unaligned,                                           \
+                 ::Eigen::Stride<::Eigen::Dynamic, 1>>{                        \
+      LDLT_ID(vec_storage).ptr_mut(),                                          \
+      LDLT_ID(rows),                                                           \
+      LDLT_ID(cols),                                                           \
+      ::Eigen::Stride<::Eigen::Dynamic, 1>{                                    \
+        LDLT_ID(stride),                                                       \
+        1,                                                                     \
+      },                                                                       \
+    };                                                                         \
+  static_assert(true, ".")
+
+#define LDLT_TEMP_VEC(Type, Name, Rows, Stack)                                 \
+  __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, make_new)
+#define LDLT_TEMP_VEC_UNINIT(Type, Name, Rows, Stack)                          \
+  __LDLT_TEMP_VEC_IMPL(Type, Name, Rows, Stack, make_new_for_overwrite)
+
+#define LDLT_TEMP_MAT(Type, Name, Rows, Cols, Stack)                           \
+  __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, make_new)
+#define LDLT_TEMP_MAT_UNINIT(Type, Name, Rows, Cols, Stack)                    \
+  __LDLT_TEMP_MAT_IMPL(Type, Name, Rows, Cols, Stack, make_new_for_overwrite)
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+using proxsuite::linalg::veg::i32;
+using proxsuite::linalg::veg::isize;
+using proxsuite::linalg::veg::u32;
+using proxsuite::linalg::veg::usize;
+using f32 = float;
+using f64 = double;
+
+namespace _detail {
+namespace _simd {
+
+#ifdef __clang__
+#define DENSE_LDLT_FP_PRAGMA _Pragma("STDC FP_CONTRACT ON")
+#else
+#define DENSE_LDLT_FP_PRAGMA
+#endif
+
+static_assert(static_cast<unsigned char>(-1) == 255, "char should have 8 bits");
+static_assert(sizeof(f32) == 4, "f32 should be 32 bits");
+static_assert(sizeof(f64) == 8, "f64 should be 64 bits");
+
+#define LDLT_FN_IMPL3(Fn, Prefix, Suffix)                                      \
+  VEG_INLINE static auto Fn(Pack a, Pack b, Pack c) noexcept -> Pack           \
+  {                                                                            \
+    return Pack{ simde_mm##Prefix##_##Fn##_##Suffix(                           \
+      a.inner, b.inner, c.inner) };                                            \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+#define LDLT_ARITHMETIC_IMPL(Prefix, Suffix)                                   \
+  LDLT_FN_IMPL3(fmadd, Prefix, Suffix);  /* (a * b + c) */                     \
+  LDLT_FN_IMPL3(fnmadd, Prefix, Suffix); /* (-a * b + c) */
+
+#define LDLT_LOAD_STORE(Prefix, Suffix)                                        \
+  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept        \
+    -> Pack                                                                    \
+  {                                                                            \
+    return Pack{ simde_mm##Prefix##_loadu_##Suffix(ptr) };                     \
+  }                                                                            \
+  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack          \
+  {                                                                            \
+    return Pack{ simde_mm##Prefix##_set1_##Suffix(value) };                    \
+  }                                                                            \
+  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept              \
+  {                                                                            \
+    simde_mm##Prefix##_storeu_##Suffix(ptr, inner);                            \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+template<typename T, usize N>
+struct Pack;
+
+template<typename T>
+struct Pack<T, 1>
+{
+  using ScalarType = T;
+
+  T inner;
+
+  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    DENSE_LDLT_FP_PRAGMA
+    return { a.inner * b.inner + c.inner };
+  }
+  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    return fmadd({ -a.inner }, b, c);
+  }
+  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
+  {
+    return { *ptr };
+  }
+  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
+  {
+    return { value };
+  }
+  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
+  {
+    *ptr = inner;
+  }
+};
+
+#ifdef PROXSUITE_VECTORIZE
+template<>
+struct Pack<f32, 4>
+{
+  using ScalarType = f32;
+
+  simde__m128 inner;
+  LDLT_ARITHMETIC_IMPL(, ps)
+  LDLT_LOAD_STORE(, ps);
+};
+
+template<>
+struct Pack<f32, 8>
+{
+  using ScalarType = f32;
+
+  simde__m256 inner;
+  LDLT_ARITHMETIC_IMPL(256, ps)
+  LDLT_LOAD_STORE(256, ps);
+};
+
+#ifdef __AVX512F__
+template<>
+struct Pack<f32, 16>
+{
+  using ScalarType = f32;
+
+  __m512 inner;
+  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    DENSE_LDLT_FP_PRAGMA
+    return { _mm512_fmadd_ps(a.inner, b.inner, c.inner) };
+  }
+  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    return { _mm512_fnmadd_ps(a.inner, b.inner, c.inner) };
+  }
+  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
+  {
+    return { _mm512_loadu_ps(ptr) };
+  }
+  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
+  {
+    return { _mm512_set1_ps(value) };
+  }
+  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
+  {
+    _mm512_storeu_ps(ptr, inner);
+  }
+};
+#endif
+
+template<>
+struct Pack<f64, 2>
+{
+  using ScalarType = f64;
+
+  simde__m128d inner;
+  LDLT_ARITHMETIC_IMPL(, pd)
+  LDLT_LOAD_STORE(, pd);
+};
+template<>
+struct Pack<f64, 4>
+{
+  using ScalarType = f64;
+
+  simde__m256d inner;
+  LDLT_ARITHMETIC_IMPL(256, pd)
+  LDLT_LOAD_STORE(256, pd);
+};
+
+#ifdef __AVX512F__
+template<>
+struct Pack<f64, 8>
+{
+  using ScalarType = f64;
+
+  __m512d inner;
+  VEG_INLINE static auto fmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    DENSE_LDLT_FP_PRAGMA
+    return { _mm512_fmadd_pd(a.inner, b.inner, c.inner) };
+  }
+  VEG_INLINE static auto fnmadd(Pack a, Pack b, Pack c) noexcept -> Pack
+  {
+    return { _mm512_fnmadd_pd(a.inner, b.inner, c.inner) };
+  }
+  VEG_INLINE static auto load_unaligned(ScalarType const* ptr) noexcept -> Pack
+  {
+    return { _mm512_loadu_pd(ptr) };
+  }
+  VEG_INLINE static auto broadcast(ScalarType value) noexcept -> Pack
+  {
+    return { _mm512_set1_pd(value) };
+  }
+  VEG_INLINE void store_unaligned(ScalarType* ptr) const noexcept
+  {
+    _mm512_storeu_pd(ptr, inner);
+  }
+};
+#endif
+
+#endif
+
+template<typename T>
+struct NativePackInfo
+{
+  static constexpr usize N = 1;
+  using Type = Pack<f32, N>;
+};
+
+#ifdef PROXSUITE_VECTORIZE
+template<>
+struct NativePackInfo<f32>
+{
+  static constexpr usize N = SIMDE_NATURAL_VECTOR_SIZE / 32;
+  using Type = Pack<f32, N>;
+};
+template<>
+struct NativePackInfo<f64>
+{
+  static constexpr usize N = SIMDE_NATURAL_VECTOR_SIZE / 64;
+  using Type = Pack<f64, N>;
+};
+#endif
+
+template<typename T>
+using NativePack = typename NativePackInfo<T>::Type;
+} // namespace _simd
+} // namespace _detail
+
+namespace _detail {
+using proxsuite::linalg::veg::uncvref_t;
+template<bool COND, typename T>
+using const_if = proxsuite::linalg::veg::meta::if_t<COND, T const, T>;
+
+template<typename T>
+using ptr_is_const = proxsuite::linalg::veg::meta::bool_constant<VEG_CONCEPT(
+  const_type<proxsuite::linalg::veg::meta::unptr_t<T>>)>;
+
+template<typename T>
+constexpr auto
+round_up(T a, T b) noexcept -> T
+{
+  return a + (b - 1) / b * b;
+}
+
+#ifdef PROXSUITE_VECTORIZE
+template<typename T>
+using should_vectorize =
+  proxsuite::linalg::veg::meta::bool_constant<VEG_CONCEPT(same<T, f32>) ||
+                                              VEG_CONCEPT(same<T, f64>)>;
+#else
+template<typename T>
+using should_vectorize = proxsuite::linalg::veg::meta::bool_constant<false>;
+#endif
+
+template<typename T>
+auto
+adjusted_stride(isize n) noexcept -> isize
+{
+#ifndef SIMDE_NATURAL_FLOAT_VECTOR_SIZE
+  isize simd_stride = 1;
+#else
+  isize simd_stride =
+    (SIMDE_NATURAL_VECTOR_SIZE / CHAR_BIT) / isize{ sizeof(T) };
+#endif
+  return _detail::should_vectorize<T>::value ? _detail::round_up(n, simd_stride)
+                                             : n;
+}
+template<typename T>
+auto
+align() noexcept -> isize
+{
+  return isize{ alignof(T) } * _detail::adjusted_stride<T>(1);
+}
+
+struct NoCopy
+{
+  NoCopy() = default;
+  ~NoCopy() = default;
+
+  NoCopy(NoCopy const&) = delete;
+  NoCopy(NoCopy&&) = delete;
+  auto operator=(NoCopy const&) -> NoCopy& = delete;
+  auto operator=(NoCopy&&) -> NoCopy& = delete;
+};
+
+namespace nb {
+struct max2
+{
+  template<typename T>
+  VEG_INLINE constexpr auto operator()(T const& a, T const& b) const -> T const&
+  {
+    return a > b ? a : b;
+  }
+};
+struct min2
+{
+  template<typename T>
+  VEG_INLINE constexpr auto operator()(T a, T b) const -> T
+  {
+    return (a < b) ? a : b;
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(min2);
+VEG_NIEBLOID(max2);
+
+template<typename T>
+void
+set_zero(T* dest, usize n)
+{
+  for (usize i = 0; i < n; ++i) {
+    *dest = 0;
+  }
+}
+
+template<typename T>
+using OwnedMatrix =
+  Eigen::Matrix<typename T::Scalar,
+                Eigen::Dynamic,
+                Eigen::Dynamic,
+                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
+
+template<typename T>
+using OwnedAll =
+  Eigen::Matrix<typename T::Scalar,
+                T::RowsAtCompileTime,
+                T::ColsAtCompileTime,
+                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
+
+template<typename T>
+using OwnedRows =
+  Eigen::Matrix<typename T::Scalar,
+                Eigen::Dynamic,
+                T::ColsAtCompileTime,
+                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
+
+template<typename T>
+using OwnedCols =
+  Eigen::Matrix<typename T::Scalar,
+                T::RowsAtCompileTime,
+                Eigen::Dynamic,
+                bool(T::IsRowMajor) ? Eigen::RowMajor : Eigen::ColMajor>;
+
+template<typename T>
+using OwnedColVector = Eigen::Matrix< //
+  typename T::Scalar,
+  Eigen::Dynamic,
+  1,
+  Eigen::ColMajor>;
+template<typename T>
+using OwnedRowVector = Eigen::Matrix< //
+  typename T::Scalar,
+  1,
+  Eigen::Dynamic,
+  Eigen::RowMajor>;
+
+template<bool ROWMAJOR>
+struct ElemAddrImpl;
+
+template<>
+struct ElemAddrImpl<false>
+{
+  template<typename T>
+  static auto fn(T* ptr,
+                 isize row,
+                 isize col,
+                 isize outer_stride,
+                 isize inner_stride) noexcept -> T*
+  {
+    return ptr + (inner_stride * row + outer_stride * col);
+  }
+};
+template<>
+struct ElemAddrImpl<true>
+{
+  template<typename T>
+  static auto fn(T* ptr,
+                 isize row,
+                 isize col,
+                 isize outer_stride,
+                 isize inner_stride) noexcept -> T*
+  {
+    return ptr + (outer_stride * row + inner_stride * col);
+  }
+};
+
+template<bool COLMAJOR>
+struct RowColAccessImpl;
+
+template<>
+struct RowColAccessImpl<true>
+{
+  template<typename T>
+  using Col =
+    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T&&).data())>::value,
+                        OwnedColVector<uncvref_t<T>>>,
+               Eigen::Unaligned,
+               Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>>;
+  template<typename T>
+  using Row =
+    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T&&).data())>::value,
+                        OwnedRowVector<uncvref_t<T>>>,
+               Eigen::Unaligned,
+               Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>>;
+
+  template<typename T>
+  static auto col(T&& mat, isize col_idx) noexcept -> Col<T>
+  {
+    return {
+      mat.data() + col_idx * mat.outerStride(),
+      mat.rows(),
+      1,
+      Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>{
+        mat.innerStride(),
+      },
+    };
+  }
+  template<typename T>
+  static auto row(T&& mat, isize row_idx) noexcept -> Row<T>
+  {
+    return {
+      mat.data() + row_idx * mat.innerStride(),
+      1,
+      mat.cols(),
+      Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>{
+        mat.outerStride(),
+      },
+    };
+  }
+};
+template<>
+struct RowColAccessImpl<false>
+{
+  template<typename T>
+  using Col =
+    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T&&).data())>::value,
+                        OwnedColVector<uncvref_t<T>>>,
+               Eigen::Unaligned,
+               Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>>;
+  template<typename T>
+  using Row =
+    Eigen::Map<const_if<ptr_is_const<decltype(VEG_DECLVAL(T&&).data())>::value,
+                        OwnedRowVector<uncvref_t<T>>>,
+               Eigen::Unaligned,
+               Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>>;
+
+  template<typename T>
+  static auto col(T&& mat, isize col_idx) noexcept -> Col<T>
+  {
+    return {
+      mat.data() + col_idx * mat.innerStride(),
+      mat.rows(),
+      1,
+      Eigen::InnerStride<uncvref_t<T>::OuterStrideAtCompileTime>{
+        mat.outerStride(),
+      },
+    };
+  }
+  template<typename T>
+  static auto row(T&& mat, isize row_idx) noexcept -> Row<T>
+  {
+    return {
+      mat.data() + row_idx * mat.outerStride(),
+      1,
+      mat.cols(),
+      Eigen::InnerStride<uncvref_t<T>::InnerStrideAtCompileTime>{
+        mat.innerStride(),
+      },
+    };
+  }
+};
+template<typename T>
+using StrideOf = Eigen::Stride< //
+  T::OuterStrideAtCompileTime,
+  T::InnerStrideAtCompileTime>;
+} // namespace _detail
+
+namespace util {
+template<bool COLMAJOR, typename T>
+auto
+elem_addr(T* ptr,
+          isize row,
+          isize col,
+          isize outer_stride,
+          isize inner_stride) noexcept -> T*
+{
+  return _detail::ElemAddrImpl<!COLMAJOR>::fn(
+    ptr, row, col, outer_stride, inner_stride);
+}
+
+template<typename Mat>
+auto
+matrix_elem_addr(Mat&& mat, isize row, isize col) noexcept
+  -> decltype(mat.data())
+{
+  return util::elem_addr<!bool(
+    proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>( //
+    mat.data(),
+    row,
+    col,
+    mat.outerStride(),
+    mat.innerStride());
+}
+
+template<typename T>
+auto
+col(T&& mat, isize col_idx) noexcept -> typename _detail::RowColAccessImpl<
+  !bool(proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::template Col<T>
+{
+  return _detail::RowColAccessImpl<!bool(
+    proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::col(mat, col_idx);
+}
+template<typename T>
+auto
+row(T&& mat, isize row_idx) noexcept -> typename _detail::RowColAccessImpl<
+  !bool(proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::template Row<T>
+{
+  return _detail::RowColAccessImpl<!bool(
+    proxsuite::linalg::veg::uncvref_t<T>::IsRowMajor)>::row(mat, row_idx);
+}
+
+template<typename Mat>
+auto
+trans(Mat&& mat) noexcept -> Eigen::Map< //
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    Eigen::Matrix< //
+                      typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar,
+                      proxsuite::linalg::veg::uncvref_t<Mat>::ColsAtCompileTime,
+                      proxsuite::linalg::veg::uncvref_t<Mat>::RowsAtCompileTime,
+                      bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)
+                        ? Eigen::ColMajor
+                        : Eigen::RowMajor>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    mat.data(),
+    mat.cols(),
+    mat.rows(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+diagonal(Mat&& mat) noexcept -> Eigen::Map< //
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    Eigen::Matrix< //
+                      typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar,
+                      Eigen::Dynamic,
+                      1,
+                      Eigen::ColMajor>>,
+  Eigen::Unaligned,
+  Eigen::InnerStride<Eigen::Dynamic>>
+{
+  VEG_DEBUG_ASSERT( //
+    mat.rows() == mat.cols());
+  return { mat.data(),
+           mat.rows(),
+           1,
+           Eigen::InnerStride<Eigen::Dynamic>{ mat.outerStride() + 1 } };
+}
+
+template<typename Mat>
+auto
+submatrix(Mat&& mat,
+          isize row_start,
+          isize col_start,
+          isize nrows,
+          isize ncols) noexcept
+  -> Eigen::Map<_detail::const_if<
+                  _detail::ptr_is_const<decltype(mat.data())>::value,
+                  _detail::OwnedMatrix<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+                Eigen::Unaligned,
+                _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
+      mat.data(), row_start, col_start, mat.outerStride(), mat.innerStride()),
+    nrows,
+    ncols,
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+to_view(Mat&& mat) noexcept -> Eigen::Map<
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    _detail::OwnedAll<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    mat.data(),
+    mat.rows(),
+    mat.cols(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+to_view_dyn_rows(Mat&& mat) noexcept -> Eigen::Map<
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    _detail::OwnedRows<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    mat.data(),
+    mat.rows(),
+    mat.cols(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+to_view_dyn_cols(Mat&& mat) noexcept -> Eigen::Map<
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    _detail::OwnedCols<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    mat.data(),
+    mat.rows(),
+    mat.cols(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+to_view_dyn(Mat&& mat) noexcept
+  -> Eigen::Map<_detail::const_if<
+                  _detail::ptr_is_const<decltype(mat.data())>::value,
+                  _detail::OwnedMatrix<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+                Eigen::Unaligned,
+                _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    mat.data(),
+    mat.rows(),
+    mat.cols(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+subrows(Mat&& mat, isize row_start, isize nrows) noexcept -> Eigen::Map<
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    _detail::OwnedRows<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
+      mat.data(), row_start, 0, mat.outerStride(), mat.innerStride()),
+    nrows,
+    mat.cols(),
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+template<typename Mat>
+auto
+subcols(Mat&& mat, isize col_start, isize ncols) noexcept -> Eigen::Map<
+  _detail::const_if<_detail::ptr_is_const<decltype(mat.data())>::value,
+                    _detail::OwnedCols<proxsuite::linalg::veg::uncvref_t<Mat>>>,
+  Eigen::Unaligned,
+  _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>>
+{
+  return {
+    util::elem_addr<!bool(proxsuite::linalg::veg::uncvref_t<Mat>::IsRowMajor)>(
+      mat.data(), 0, col_start, mat.outerStride(), mat.innerStride()),
+    mat.rows(),
+    ncols,
+    _detail::StrideOf<proxsuite::linalg::veg::uncvref_t<Mat>>{
+      mat.outerStride(),
+      mat.innerStride(),
+    },
+  };
+}
+
+} // namespace util
+namespace _detail {
+template<typename Dst, typename Lhs, typename Rhs, typename T>
+void
+noalias_mul_add_impl(Dst dst, Lhs lhs, Rhs rhs, T factor)
+{
+  VEG_ASSERT_ALL_OF(dst.rows() == lhs.rows(),
+                    dst.cols() == rhs.cols(),
+                    lhs.cols() == rhs.rows());
+
+  isize nrows = dst.rows();
+  isize ncols = dst.cols();
+  isize depth = lhs.cols();
+
+  if (nrows == 0 || ncols == 0 || depth == 0) {
+    return;
+  }
+
+#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
+#define LAZY_PRODUCT(a, b) a.lazyProduct(b)
+#else
+#define LAZY_PRODUCT(a, b) a.operator*(b)
+#endif
+
+#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
+  if ((dst.rows() < 20) && (dst.cols() < 20) && (rhs.rows() < 20)) {
+    // gemm
+    // workaround for eigen 3.3.7 bug:
+    // https://gitlab.com/libeigen/eigen/-/issues/1562
+    using Mat =
+      Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor, 20, 20>;
+    using MapMut =
+      Eigen::Map<Mat, Eigen::Unaligned, Eigen::OuterStride<Eigen::Dynamic>>;
+
+    auto dst_ =
+      MapMut(dst.data(), dst.rows(), dst.cols(), { dst.outerStride() });
+    dst_.noalias().operator+=(factor * LAZY_PRODUCT(lhs, rhs));
+  } else
+#endif
+  {
+    dst.noalias().operator+=(factor * LAZY_PRODUCT(lhs, rhs));
+  }
+
+#undef LAZY_PRODUCT
+}
+} // namespace _detail
+namespace util {
+template<typename Dst, typename Lhs, typename Rhs, typename T>
+void
+noalias_mul_add(Dst&& dst, Lhs const& lhs, Rhs const& rhs, T factor)
+{
+  _detail::noalias_mul_add_impl(
+    util::submatrix(dst, 0, 0, dst.rows(), dst.cols()),
+    util::submatrix(lhs, 0, 0, lhs.rows(), lhs.cols()),
+    util::submatrix(rhs, 0, 0, rhs.rows(), rhs.cols()),
+    factor);
+}
+} // namespace util
+template<typename T>
+auto
+temp_mat_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
+             isize rows,
+             isize cols) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return {
+    _detail::adjusted_stride<T>(rows) * cols * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+}
+
+template<typename T>
+auto
+temp_vec_req(proxsuite::linalg::veg::Tag<T> /*tag*/, isize rows) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return {
+    rows * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+}
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_CORE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/dense/factorize.hpp

 * *Ordering differences only*

```diff
@@ -1,375 +1,375 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP
-
-#include "proxsuite/linalg/dense/core.hpp"
-#include <algorithm>
-#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-namespace _detail {
-
-template<typename T>
-VEG_NO_INLINE void
-compute_permutation_impl(isize* perm_indices,
-                         isize* perm_inv_indices,
-                         isize n,
-                         T const* diagonal_data,
-                         isize stride)
-{
-  for (isize k = 0; k < n; ++k) {
-    perm_indices[k] = k;
-  }
-
-  {
-    std::sort(perm_indices,
-              perm_indices + n,
-              [diagonal_data, stride](isize i, isize j) noexcept -> bool {
-                using std::fabs;
-                auto lhs = fabs(diagonal_data[stride * i]);
-                auto rhs = fabs(diagonal_data[stride * j]);
-                if (lhs == rhs) {
-                  return i < j;
-                }
-                return lhs > rhs;
-              });
-  }
-
-  for (isize k = 0; k < n; ++k) {
-    perm_inv_indices[perm_indices[k]] = k;
-  }
-}
-
-template<typename Diag>
-VEG_NO_INLINE void
-compute_permutation(isize* perm_indices,
-                    isize* perm_inv_indices,
-                    Diag const& diagonal)
-{
-  _detail::compute_permutation_impl<typename Diag::Scalar>(
-    perm_indices,
-    perm_inv_indices,
-    diagonal.rows(),
-    diagonal.data(),
-    diagonal.innerStride());
-}
-
-template<typename Mat, typename Work>
-void
-apply_permutation_tri_lower(Mat&& mat, Work&& work, isize const* perm_indices)
-{
-  using T = typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar;
-
-  isize n = mat.rows();
-  VEG_ASSERT_ALL_OF( //
-    n == mat.rows(),
-    n == mat.cols(),
-    n == work.rows(),
-    n == work.cols());
-
-  auto mat_coeff = [&](isize i, isize j) noexcept -> T& {
-    return i >= j ? mat(i, j) : mat(j, i);
-  };
-
-  for (isize j = 0; j < n; ++j) {
-    for (isize i = j; i < n; ++i) {
-      work(i, j) = mat_coeff(perm_indices[i], perm_indices[j]);
-    }
-  }
-
-  mat.template triangularView<Eigen::Lower>() =
-    work.template triangularView<Eigen::Lower>();
-}
-
-template<typename Mat>
-void
-factorize_unblocked_impl(Mat mat,
-                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  // left looking cholesky
-  // https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition_2
-
-  using T = typename Mat::Scalar;
-  isize n = mat.rows();
-  if (n == 0) {
-    return;
-  }
-
-  auto _work = stack.make_new_for_overwrite( //
-    proxsuite::linalg::veg::Tag<T>{},
-    n,
-    _detail::align<T>());
-  auto work_storage =
-    Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1>, Eigen::Unaligned>{
-      _work.ptr_mut(),
-      n,
-      1,
-    };
-
-  isize j = 0;
-  while (true) {
-    /*
-     *     L00
-     * l = l10  1
-     *     L20 l21 L22
-     *
-     *     D0
-     * d =    d1
-     *           D2
-     *
-     * compute d1 and l21
-     */
-
-    auto l10 = util::subcols(util::row(mat, j), 0, j);
-    auto d0 = util::subrows(mat.diagonal(), 0, j);
-    auto work = util::subrows(work_storage, 0, j);
-
-    work = util::trans(l10).cwiseProduct(d0);
-    mat(j, j) -= work.dot(l10);
-
-    if (j + 1 == n) {
-      break;
-    }
-
-    isize rem = n - j - 1;
-
-    auto l20 = util::submatrix(mat, j + 1, 0, rem, j);
-    auto l21 = util::subrows(util::col(mat, j), j + 1, rem);
-
-    util::noalias_mul_add(l21, l20, work, T(-1));
-    l21 *= 1 / mat(j, j);
-    ++j;
-  }
-}
-
-template<typename Mat>
-void
-factorize_blocked_impl(Mat mat,
-                       isize block_size,
-                       proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  // right looking blocked cholesky
-
-  using T = typename Mat::Scalar;
-  VEG_ASSERT(mat.rows() == mat.cols());
-
-  isize n = mat.rows();
-
-  if (n == 0) {
-    return;
-  }
-
-  isize j = 0;
-  while (true) {
-    isize bs = min2(n - j, block_size);
-
-    auto ld11 = util::submatrix(mat, j, j, bs, bs);
-    auto d1 = util::diagonal(ld11);
-    _detail::factorize_unblocked_impl(ld11, stack);
-
-    if (j + bs == n) {
-      break;
-    }
-    isize rem = n - j - bs;
-
-    isize work_stride = _detail::adjusted_stride<T>(rem);
-
-    auto _work = stack.make_new_for_overwrite( //
-      proxsuite::linalg::veg::Tag<T>{},
-      bs * work_stride,
-      _detail::align<T>());
-
-    auto work = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>,
-                           Eigen::Unaligned,
-                           Eigen::OuterStride<Eigen::Dynamic>>{
-      _work.ptr_mut(),
-      rem,
-      bs,
-      Eigen::OuterStride<Eigen::Dynamic>{ work_stride },
-    };
-
-    auto l21 = util::submatrix(mat, j + bs, j, rem, bs);
-
-    util::trans(ld11)
-      .template triangularView<Eigen::UnitUpper>()
-      .template solveInPlace<Eigen::OnTheRight>(l21);
-
-    work = l21;
-    l21 = l21 * d1.asDiagonal().inverse();
-
-    auto l22 = util::submatrix(mat, j + bs, j + bs, rem, rem);
-
-    l22.template triangularView<Eigen::Lower>() -= l21 * util::trans(work);
-    j += bs;
-  }
-}
-
-using factorize_recursive_threshold =
-  proxsuite::linalg::veg::meta::constant<isize, 32>;
-
-template<typename Mat>
-void
-factorize_recursive_impl(Mat mat,
-                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  // right looking recursive cholesky
-
-  using T = typename Mat::Scalar;
-  VEG_ASSERT(mat.rows() == mat.cols());
-
-  isize n = mat.rows();
-
-  if (n < factorize_recursive_threshold::value) {
-    _detail::factorize_unblocked_impl(mat, stack);
-  } else {
-    /*
-     *     L00
-     * L = L10 L11
-     *
-     *     D0
-     * D =    D1
-     *
-     * compute L00 and D0 recursively
-     * compute L10 by solving a triangular system
-     * compute L11 recursively
-     */
-    isize bs = (n + 1) / 2;
-    isize rem = n - bs;
-
-    auto l00 = util::submatrix(mat, 0, 0, bs, bs);
-
-    auto l10 = util::submatrix(mat, bs, 0, rem, bs);
-    auto l11 = util::submatrix(mat, bs, bs, rem, rem);
-
-    _detail::factorize_recursive_impl(l00, stack);
-    auto d0 = util::diagonal(l00);
-
-    isize work_stride = _detail::adjusted_stride<T>(rem);
-
-    util::trans(l00)
-      .template triangularView<Eigen::UnitUpper>()
-      .template solveInPlace<Eigen::OnTheRight>(l10);
-
-    {
-      auto _work = stack.make_new_for_overwrite( //
-        proxsuite::linalg::veg::Tag<T>{},
-        bs * work_stride,
-        _detail::align<T>());
-
-      auto work = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>,
-                             Eigen::Unaligned,
-                             Eigen::OuterStride<Eigen::Dynamic>>{
-        _work.ptr_mut(),
-        rem,
-        bs,
-        Eigen::OuterStride<Eigen::Dynamic>{ work_stride },
-      };
-      work = l10;
-      l10 = l10 * d0.asDiagonal().inverse();
-
-      l11.template triangularView<Eigen::Lower>() -= l10 * util::trans(work);
-    }
-
-    _detail::factorize_recursive_impl(l11, stack);
-  }
-}
-} // namespace _detail
-template<typename T>
-auto
-factorize_unblocked_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
-                        isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return {
-    n * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-}
-
-template<typename T>
-auto
-factorize_blocked_req(proxsuite::linalg::veg::Tag<T> tag,
-                      isize n,
-                      isize block_size) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return proxsuite::linalg::dense::factorize_unblocked_req(tag, block_size) |
-         proxsuite::linalg::veg::dynstack::StackReq{
-           _detail::adjusted_stride<T>(
-             _detail::max2(n - block_size, isize(0))) *
-             block_size * isize{ sizeof(T) },
-           _detail::align<T>(),
-         };
-}
-
-template<typename T>
-auto
-factorize_recursive_req(proxsuite::linalg::veg::Tag<T> tag, isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  auto req0 = proxsuite::linalg::dense::factorize_unblocked_req(
-    tag, _detail::min2(n, _detail::factorize_recursive_threshold::value));
-  if (n < _detail::factorize_recursive_threshold::value) {
-    return req0;
-  }
-  isize bs = (n + 1) / 2;
-  isize rem = n - bs;
-  return req0 | proxsuite::linalg::veg::dynstack::StackReq{
-    bs * _detail::adjusted_stride<T>(rem) * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-}
-
-template<typename Mat>
-void
-factorize_unblocked(Mat&& mat,
-                    proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  _detail::factorize_unblocked_impl(util::to_view_dyn(mat), stack);
-}
-template<typename Mat>
-void
-factorize_blocked(Mat&& mat,
-                  isize block_size,
-                  proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  _detail::factorize_blocked_impl(util::to_view_dyn(mat), block_size, stack);
-}
-template<typename Mat>
-void
-factorize_recursive(Mat&& mat,
-                    proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  _detail::factorize_recursive_impl(util::to_view_dyn(mat), stack);
-}
-
-template<typename T>
-auto
-factorize_req(proxsuite::linalg::veg::Tag<T> tag, isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return proxsuite::linalg::dense::factorize_blocked_req(tag, n, 128) |
-         proxsuite::linalg::dense::factorize_recursive_req(tag, n);
-}
-
-template<typename Mat>
-void
-factorize(Mat&& mat, proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  isize n = mat.rows();
-  if (n > 2048) {
-    proxsuite::linalg::dense::factorize_blocked(mat, 128, stack);
-  } else {
-    proxsuite::linalg::dense::factorize_recursive(mat, stack);
-  }
-}
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP
+
+#include "proxsuite/linalg/dense/core.hpp"
+#include <algorithm>
+#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+namespace _detail {
+
+template<typename T>
+VEG_NO_INLINE void
+compute_permutation_impl(isize* perm_indices,
+                         isize* perm_inv_indices,
+                         isize n,
+                         T const* diagonal_data,
+                         isize stride)
+{
+  for (isize k = 0; k < n; ++k) {
+    perm_indices[k] = k;
+  }
+
+  {
+    std::sort(perm_indices,
+              perm_indices + n,
+              [diagonal_data, stride](isize i, isize j) noexcept -> bool {
+                using std::fabs;
+                auto lhs = fabs(diagonal_data[stride * i]);
+                auto rhs = fabs(diagonal_data[stride * j]);
+                if (lhs == rhs) {
+                  return i < j;
+                }
+                return lhs > rhs;
+              });
+  }
+
+  for (isize k = 0; k < n; ++k) {
+    perm_inv_indices[perm_indices[k]] = k;
+  }
+}
+
+template<typename Diag>
+VEG_NO_INLINE void
+compute_permutation(isize* perm_indices,
+                    isize* perm_inv_indices,
+                    Diag const& diagonal)
+{
+  _detail::compute_permutation_impl<typename Diag::Scalar>(
+    perm_indices,
+    perm_inv_indices,
+    diagonal.rows(),
+    diagonal.data(),
+    diagonal.innerStride());
+}
+
+template<typename Mat, typename Work>
+void
+apply_permutation_tri_lower(Mat&& mat, Work&& work, isize const* perm_indices)
+{
+  using T = typename proxsuite::linalg::veg::uncvref_t<Mat>::Scalar;
+
+  isize n = mat.rows();
+  VEG_ASSERT_ALL_OF( //
+    n == mat.rows(),
+    n == mat.cols(),
+    n == work.rows(),
+    n == work.cols());
+
+  auto mat_coeff = [&](isize i, isize j) noexcept -> T& {
+    return i >= j ? mat(i, j) : mat(j, i);
+  };
+
+  for (isize j = 0; j < n; ++j) {
+    for (isize i = j; i < n; ++i) {
+      work(i, j) = mat_coeff(perm_indices[i], perm_indices[j]);
+    }
+  }
+
+  mat.template triangularView<Eigen::Lower>() =
+    work.template triangularView<Eigen::Lower>();
+}
+
+template<typename Mat>
+void
+factorize_unblocked_impl(Mat mat,
+                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  // left looking cholesky
+  // https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition_2
+
+  using T = typename Mat::Scalar;
+  isize n = mat.rows();
+  if (n == 0) {
+    return;
+  }
+
+  auto _work = stack.make_new_for_overwrite( //
+    proxsuite::linalg::veg::Tag<T>{},
+    n,
+    _detail::align<T>());
+  auto work_storage =
+    Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1>, Eigen::Unaligned>{
+      _work.ptr_mut(),
+      n,
+      1,
+    };
+
+  isize j = 0;
+  while (true) {
+    /*
+     *     L00
+     * l = l10  1
+     *     L20 l21 L22
+     *
+     *     D0
+     * d =    d1
+     *           D2
+     *
+     * compute d1 and l21
+     */
+
+    auto l10 = util::subcols(util::row(mat, j), 0, j);
+    auto d0 = util::subrows(mat.diagonal(), 0, j);
+    auto work = util::subrows(work_storage, 0, j);
+
+    work = util::trans(l10).cwiseProduct(d0);
+    mat(j, j) -= work.dot(l10);
+
+    if (j + 1 == n) {
+      break;
+    }
+
+    isize rem = n - j - 1;
+
+    auto l20 = util::submatrix(mat, j + 1, 0, rem, j);
+    auto l21 = util::subrows(util::col(mat, j), j + 1, rem);
+
+    util::noalias_mul_add(l21, l20, work, T(-1));
+    l21 *= 1 / mat(j, j);
+    ++j;
+  }
+}
+
+template<typename Mat>
+void
+factorize_blocked_impl(Mat mat,
+                       isize block_size,
+                       proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  // right looking blocked cholesky
+
+  using T = typename Mat::Scalar;
+  VEG_ASSERT(mat.rows() == mat.cols());
+
+  isize n = mat.rows();
+
+  if (n == 0) {
+    return;
+  }
+
+  isize j = 0;
+  while (true) {
+    isize bs = min2(n - j, block_size);
+
+    auto ld11 = util::submatrix(mat, j, j, bs, bs);
+    auto d1 = util::diagonal(ld11);
+    _detail::factorize_unblocked_impl(ld11, stack);
+
+    if (j + bs == n) {
+      break;
+    }
+    isize rem = n - j - bs;
+
+    isize work_stride = _detail::adjusted_stride<T>(rem);
+
+    auto _work = stack.make_new_for_overwrite( //
+      proxsuite::linalg::veg::Tag<T>{},
+      bs * work_stride,
+      _detail::align<T>());
+
+    auto work = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>,
+                           Eigen::Unaligned,
+                           Eigen::OuterStride<Eigen::Dynamic>>{
+      _work.ptr_mut(),
+      rem,
+      bs,
+      Eigen::OuterStride<Eigen::Dynamic>{ work_stride },
+    };
+
+    auto l21 = util::submatrix(mat, j + bs, j, rem, bs);
+
+    util::trans(ld11)
+      .template triangularView<Eigen::UnitUpper>()
+      .template solveInPlace<Eigen::OnTheRight>(l21);
+
+    work = l21;
+    l21 = l21 * d1.asDiagonal().inverse();
+
+    auto l22 = util::submatrix(mat, j + bs, j + bs, rem, rem);
+
+    l22.template triangularView<Eigen::Lower>() -= l21 * util::trans(work);
+    j += bs;
+  }
+}
+
+using factorize_recursive_threshold =
+  proxsuite::linalg::veg::meta::constant<isize, 32>;
+
+template<typename Mat>
+void
+factorize_recursive_impl(Mat mat,
+                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  // right looking recursive cholesky
+
+  using T = typename Mat::Scalar;
+  VEG_ASSERT(mat.rows() == mat.cols());
+
+  isize n = mat.rows();
+
+  if (n < factorize_recursive_threshold::value) {
+    _detail::factorize_unblocked_impl(mat, stack);
+  } else {
+    /*
+     *     L00
+     * L = L10 L11
+     *
+     *     D0
+     * D =    D1
+     *
+     * compute L00 and D0 recursively
+     * compute L10 by solving a triangular system
+     * compute L11 recursively
+     */
+    isize bs = (n + 1) / 2;
+    isize rem = n - bs;
+
+    auto l00 = util::submatrix(mat, 0, 0, bs, bs);
+
+    auto l10 = util::submatrix(mat, bs, 0, rem, bs);
+    auto l11 = util::submatrix(mat, bs, bs, rem, rem);
+
+    _detail::factorize_recursive_impl(l00, stack);
+    auto d0 = util::diagonal(l00);
+
+    isize work_stride = _detail::adjusted_stride<T>(rem);
+
+    util::trans(l00)
+      .template triangularView<Eigen::UnitUpper>()
+      .template solveInPlace<Eigen::OnTheRight>(l10);
+
+    {
+      auto _work = stack.make_new_for_overwrite( //
+        proxsuite::linalg::veg::Tag<T>{},
+        bs * work_stride,
+        _detail::align<T>());
+
+      auto work = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>,
+                             Eigen::Unaligned,
+                             Eigen::OuterStride<Eigen::Dynamic>>{
+        _work.ptr_mut(),
+        rem,
+        bs,
+        Eigen::OuterStride<Eigen::Dynamic>{ work_stride },
+      };
+      work = l10;
+      l10 = l10 * d0.asDiagonal().inverse();
+
+      l11.template triangularView<Eigen::Lower>() -= l10 * util::trans(work);
+    }
+
+    _detail::factorize_recursive_impl(l11, stack);
+  }
+}
+} // namespace _detail
+template<typename T>
+auto
+factorize_unblocked_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
+                        isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return {
+    n * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+}
+
+template<typename T>
+auto
+factorize_blocked_req(proxsuite::linalg::veg::Tag<T> tag,
+                      isize n,
+                      isize block_size) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return proxsuite::linalg::dense::factorize_unblocked_req(tag, block_size) |
+         proxsuite::linalg::veg::dynstack::StackReq{
+           _detail::adjusted_stride<T>(
+             _detail::max2(n - block_size, isize(0))) *
+             block_size * isize{ sizeof(T) },
+           _detail::align<T>(),
+         };
+}
+
+template<typename T>
+auto
+factorize_recursive_req(proxsuite::linalg::veg::Tag<T> tag, isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  auto req0 = proxsuite::linalg::dense::factorize_unblocked_req(
+    tag, _detail::min2(n, _detail::factorize_recursive_threshold::value));
+  if (n < _detail::factorize_recursive_threshold::value) {
+    return req0;
+  }
+  isize bs = (n + 1) / 2;
+  isize rem = n - bs;
+  return req0 | proxsuite::linalg::veg::dynstack::StackReq{
+    bs * _detail::adjusted_stride<T>(rem) * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+}
+
+template<typename Mat>
+void
+factorize_unblocked(Mat&& mat,
+                    proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  _detail::factorize_unblocked_impl(util::to_view_dyn(mat), stack);
+}
+template<typename Mat>
+void
+factorize_blocked(Mat&& mat,
+                  isize block_size,
+                  proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  _detail::factorize_blocked_impl(util::to_view_dyn(mat), block_size, stack);
+}
+template<typename Mat>
+void
+factorize_recursive(Mat&& mat,
+                    proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  _detail::factorize_recursive_impl(util::to_view_dyn(mat), stack);
+}
+
+template<typename T>
+auto
+factorize_req(proxsuite::linalg::veg::Tag<T> tag, isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return proxsuite::linalg::dense::factorize_blocked_req(tag, n, 128) |
+         proxsuite::linalg::dense::factorize_recursive_req(tag, n);
+}
+
+template<typename Mat>
+void
+factorize(Mat&& mat, proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  isize n = mat.rows();
+  if (n > 2048) {
+    proxsuite::linalg::dense::factorize_blocked(mat, 128, stack);
+  } else {
+    proxsuite::linalg::dense::factorize_recursive(mat, stack);
+  }
+}
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_FACTORIZE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/dense/ldlt.hpp

 * *Ordering differences only*

```diff
@@ -1,817 +1,817 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP
-
-#include "proxsuite/linalg/dense/factorize.hpp"
-#include "proxsuite/linalg/dense/update.hpp"
-#include "proxsuite/linalg/dense/modify.hpp"
-#include "proxsuite/linalg/dense/solve.hpp"
-#include <proxsuite/linalg/veg/vec.hpp>
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-namespace _detail {
-struct SimdAlignedSystemAlloc
-{
-  friend auto operator==(SimdAlignedSystemAlloc /*unused*/,
-                         SimdAlignedSystemAlloc /*unused*/) noexcept -> bool
-  {
-    return true;
-  }
-};
-} // namespace _detail
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-template<>
-struct proxsuite::linalg::veg::mem::Alloc<
-  proxsuite::linalg::dense::_detail::SimdAlignedSystemAlloc>
-{
-#ifdef PROXSUITE_VECTORIZE
-  static constexpr usize min_align = alignof(std::max_align_t) >
-                                         SIMDE_NATURAL_VECTOR_SIZE / 8
-                                       ? SIMDE_NATURAL_VECTOR_SIZE / 8
-                                       : alignof(std::max_align_t);
-#else
-  static constexpr usize min_align = 0;
-#endif
-
-  using RefMut = proxsuite::linalg::veg::RefMut<
-    proxsuite::linalg::dense::_detail::SimdAlignedSystemAlloc>;
-
-  VEG_INLINE static auto adjusted_layout(Layout l) noexcept -> Layout
-  {
-    if (l.align < min_align) {
-      l.align = min_align;
-    }
-    return l;
-  }
-
-  VEG_INLINE static void dealloc(RefMut /*alloc*/, void* ptr, Layout l) noexcept
-  {
-    return Alloc<SystemAlloc>::dealloc(
-      mut(SystemAlloc{}), ptr, adjusted_layout(l));
-  }
-
-  VEG_NODISCARD VEG_INLINE static auto alloc(RefMut /*alloc*/,
-                                             Layout l) noexcept
-    -> mem::AllocBlock
-  {
-    return Alloc<SystemAlloc>::alloc(mut(SystemAlloc{}), adjusted_layout(l));
-  }
-
-  VEG_NODISCARD VEG_INLINE static auto grow(RefMut /*alloc*/,
-                                            void* ptr,
-                                            Layout l,
-                                            usize new_size,
-                                            RelocFn reloc) noexcept
-    -> mem::AllocBlock
-  {
-    return Alloc<SystemAlloc>::grow(
-      mut(SystemAlloc{}), ptr, adjusted_layout(l), new_size, reloc);
-  }
-  VEG_NODISCARD VEG_INLINE static auto shrink(RefMut /*alloc*/,
-                                              void* ptr,
-                                              Layout l,
-                                              usize new_size,
-                                              RelocFn reloc) noexcept
-    -> mem::AllocBlock
-  {
-    return Alloc<SystemAlloc>::shrink(
-      mut(SystemAlloc{}), ptr, adjusted_layout(l), new_size, reloc);
-  }
-};
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-/*!
- * Wrapper class that handles an allocated LDLT decomposition,
- * with an applied permutation.
- * When provided with a matrix `A`, this internally stores a lower triangular
- * matrix with unit diagonal `L`, a vector `D`, and a permutation `P` such that
- * `A = P.T L diag(D) L.T P`.
- *
- * Example usage:
- * ```cpp
-#include <proxsuite/linalg/dense/ldlt.hpp>
-#include <proxsuite/linalg/veg/util/dynstack_alloc.hpp>
-
-auto main() -> int {
-        constexpr auto DYN = Eigen::Dynamic;
-        using Matrix = Eigen::Matrix<double, DYN, DYN>;
-        using Vector = Eigen::Matrix<double, DYN, 1>;
-        using Ldlt = proxsuite::linalg::dense::Ldlt<double>;
-        using proxsuite::linalg::veg::dynstack::StackReq;
-
-        // allocate a matrix `a`
-        auto a0 = Matrix{
-                        2,
-                        2,
-        };
-
-        // workspace memory requirements
-        auto req =
-                        Ldlt::factorize_req(2) |          // initial
-factorization of dim 2 Ldlt::insert_block_at_req(2, 1) | // or 1 insertion to
-matrix of dim 2 Ldlt::delete_at_req(3, 2) |       // or 2 deletions from matrix
-of dim 3 Ldlt::solve_in_place_req(1);      // or solve in place with dim 1
-
-        VEG_MAKE_STACK(stack, req);
-
-        Ldlt ldl;
-
-        // fill up the lower triangular part
-        // matrix is
-        // 1.0 2.0
-        // 2.0 3.0
-        a0(0, 0) = 1.0;
-        a0(1, 0) = 2.0;
-        a0(1, 1) = 3.0;
-
-        ldl.factorize(a0, stack);
-
-        // add one column at the index 1
-        // matrix is
-        // 1.0 4.0 2.0
-        // 4.0 5.0 6.0
-        // 2.0 6.0 3.0
-        auto c = Matrix{3, 1};
-        c(0, 0) = 4.0;
-        c(1, 0) = 5.0;
-        c(2, 0) = 6.0;
-        ldl.insert_block_at(1, c, stack);
-
-        // then delete two rows and columns at indices 0 and 2
-        // matrix is
-        // 5.0
-        proxsuite::linalg::veg::isize const indices[] = {0, 2};
-        ldl.delete_at(indices, 2, stack);
-
-        auto rhs = Vector{1};
-        rhs[0] = 5.0;
-
-        ldl.solve_in_place(rhs, stack);
-        VEG_ASSERT(rhs[0] == 1.0);
-}
- * ```
- */
-template<typename T>
-struct Ldlt
-{
-private:
-  static constexpr auto DYN = Eigen::Dynamic;
-  using ColMat = Eigen::Matrix<T, DYN, DYN, Eigen::ColMajor>;
-  using RowMat = Eigen::Matrix<T, DYN, DYN, Eigen::RowMajor>;
-  using Vec = Eigen::Matrix<T, DYN, 1>;
-
-  using LView = Eigen::TriangularView<Eigen::Map< //
-                                        ColMat const,
-                                        Eigen::Unaligned,
-                                        Eigen::OuterStride<DYN>>,
-                                      Eigen::UnitLower>;
-  using LViewMut = Eigen::TriangularView<Eigen::Map< //
-                                           ColMat,
-                                           Eigen::Unaligned,
-                                           Eigen::OuterStride<DYN>>,
-                                         Eigen::UnitLower>;
-
-  using LTView = Eigen::TriangularView<Eigen::Map< //
-                                         RowMat const,
-                                         Eigen::Unaligned,
-                                         Eigen::OuterStride<DYN>>,
-                                       Eigen::UnitUpper>;
-  using LTViewMut = Eigen::TriangularView<Eigen::Map< //
-                                            RowMat,
-                                            Eigen::Unaligned,
-                                            Eigen::OuterStride<DYN>>,
-                                          Eigen::UnitUpper>;
-
-  using DView =
-    Eigen::Map<Vec const, Eigen::Unaligned, Eigen::InnerStride<DYN>>;
-  using DViewMut = Eigen::Map<Vec, Eigen::Unaligned, Eigen::InnerStride<DYN>>;
-
-  using VecMapISize = Eigen::Map<Eigen::Matrix<isize, DYN, 1> const>;
-  using Perm = Eigen::PermutationWrapper<VecMapISize>;
-
-  using StorageSimdVec =
-    proxsuite::linalg::veg::Vec<T,
-                                proxsuite::linalg::veg::meta::if_t<
-                                  _detail::should_vectorize<T>::value,
-                                  _detail::SimdAlignedSystemAlloc,
-                                  proxsuite::linalg::veg::mem::SystemAlloc>>;
-
-  StorageSimdVec ld_storage;
-  isize stride{};
-  proxsuite::linalg::veg::Vec<isize> perm;
-  proxsuite::linalg::veg::Vec<isize> perm_inv;
-
-  // sorted on a best effort basis
-  proxsuite::linalg::veg::Vec<T> maybe_sorted_diag;
-
-  VEG_REFLECT(Ldlt, ld_storage, stride, perm, perm_inv, maybe_sorted_diag);
-
-  static auto adjusted_stride(isize n) noexcept -> isize
-  {
-    return _detail::adjusted_stride<T>(n);
-  }
-
-  // soft invariants:
-  // - perm.len() == perm_inv.len() == dim
-  // - dim < stride
-  // - ld_storage.len() >= dim * stride
-public:
-  /*!
-   * Default constructor, initialized with a `0×0` empty matrix.
-   */
-  Ldlt() = default;
-
-  /*!
-   * Reserves enough internal storage for a matrix `A` of size at least
-   * `cap×cap`.
-   * This operation invalidates the existing decomposition.
-   *
-   * @param cap new capacity
-   */
-  void reserve_uninit(isize cap) noexcept
-  {
-    static_assert(VEG_CONCEPT(nothrow_constructible<T>), ".");
-
-    auto new_stride = adjusted_stride(cap);
-    if (cap <= stride && cap * new_stride <= ld_storage.len()) {
-      return;
-    }
-
-    ld_storage.reserve_exact(cap * new_stride);
-    perm.reserve_exact(cap);
-    perm_inv.reserve_exact(cap);
-    maybe_sorted_diag.reserve_exact(cap);
-
-    ld_storage.resize_for_overwrite(cap * new_stride);
-    stride = new_stride;
-  }
-
-  /*!
-   * Reserves enough internal storage for a matrix `A` of size at least
-   * `cap×cap`.
-   * This operation preserves the existing decomposition.
-   *
-   * @param cap new capacity
-   */
-  void reserve(isize cap) noexcept
-  {
-    auto new_stride = adjusted_stride(cap);
-    if (cap <= stride && cap * new_stride <= ld_storage.len()) {
-      return;
-    }
-    auto n = dim();
-
-    ld_storage.reserve_exact(cap * new_stride);
-    perm.reserve_exact(cap);
-    perm_inv.reserve_exact(cap);
-    maybe_sorted_diag.reserve_exact(cap);
-
-    ld_storage.resize_for_overwrite(cap * new_stride);
-
-    for (isize i = 0; i < n; ++i) {
-      auto col = n - i - 1;
-      T* ptr = ld_col_mut().data();
-      std::move_backward( //
-        ptr + col * stride,
-        ptr + col * stride + n,
-        ptr + col * new_stride + n);
-    }
-    stride = new_stride;
-  }
-
-  /*!
-   * Returns the memory storage requirements for performing a rank `k` update
-   * on a matrix with size at most `n×n`, with `k ≤ r`.
-   *
-   * @param n maximum dimension of the matrix
-   * @param r maximum number of simultaneous rank updates
-   */
-  static auto rank_r_update_req(isize n, isize r) noexcept
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
-      _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
-      _detail::align<T>(),
-    };
-    auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
-      r * isize{ sizeof(T) },
-      alignof(T),
-    };
-    return w_req & alpha_req;
-  }
-
-  /*!
-   * Returns the memory storage requirements for deleting at most `r` rows and
-   * columns from a matrix with size at most `n×n`.
-   *
-   * @param n maximum dimension of the matrix
-   * @param r maximum number of rows to be deleted
-   */
-  static auto delete_at_req(isize n, isize r) noexcept
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return proxsuite::linalg::veg::dynstack::StackReq{
-      r * isize{ sizeof(isize) },
-      alignof(isize),
-    } &
-           proxsuite::linalg::dense::ldlt_delete_rows_and_cols_req(
-             proxsuite::linalg::veg::Tag<T>{}, n, r);
-  }
-
-  /*!
-   * Given an LDLT decomposition for a matrix `A`, this computes the
-   * decomposition for the matrix `A` with `r` columns and rows removed, as
-   * indicated by the indices `indices[0], ..., indices[r-1]`.
-   *
-   * @param indices pointer to the array of indices to be deleted
-   * @param r number of the indices to be deleted
-   * @param stack workspace memory stack
-   */
-  void delete_at(isize const* indices,
-                 isize r,
-                 proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-    if (r == 0) {
-      return;
-    }
-
-    VEG_ASSERT(std::is_sorted(indices, indices + r));
-
-    isize n = dim();
-
-    auto _indices_actual =
-      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
-    auto* indices_actual = _indices_actual.ptr_mut();
-
-    for (isize k = 0; k < r; ++k) {
-      indices_actual[k] = perm_inv[indices[k]];
-    }
-
-    proxsuite::linalg::dense::ldlt_delete_rows_and_cols_sort_indices( //
-      ld_col_mut(),
-      indices_actual,
-      r,
-      stack);
-
-    // PERF: do this in one pass
-    for (isize k = 0; k < r; ++k) {
-      auto i_actual = indices_actual[r - 1 - k];
-      auto i = indices[r - 1 - k];
-
-      perm.pop_mid(i_actual);
-      perm_inv.pop_mid(i);
-      maybe_sorted_diag.pop_mid(i_actual);
-
-      for (isize j = 0; j < n - 1 - k; ++j) {
-        auto& p_j = perm[j];
-        auto& pinv_j = perm_inv[j];
-
-        if (p_j > i) {
-          --p_j;
-        }
-        if (pinv_j > i_actual) {
-          --pinv_j;
-        }
-      }
-    }
-  }
-
-  auto choose_insertion_position(isize i, Eigen::Ref<Vec const> a) -> isize
-  {
-    isize n = dim();
-    auto diag_elem = a[i];
-
-    isize pos = 0;
-    for (; pos < n; ++pos) {
-      if (diag_elem >= maybe_sorted_diag[pos]) {
-        break;
-      }
-    }
-    return pos;
-  }
-
-  /*!
-   * Returns the memory storage requirements for inserting at most `r` rows and
-   * columns from a matrix with size at most `n×n`.
-   *
-   * @param n maximum dimension of the matrix
-   * @param r maximum number of rows to be inserted
-   */
-  static auto insert_block_at_req(isize n, isize r) noexcept
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    using proxsuite::linalg::veg::dynstack::StackReq;
-    return StackReq{
-      isize{ sizeof(T) } * (adjusted_stride(n + r) * r),
-      _detail::align<T>(),
-    } &
-           proxsuite::linalg::dense::ldlt_insert_rows_and_cols_req(
-             proxsuite::linalg::veg::Tag<T>{}, n, r);
-  }
-
-  /*!
-   * Given an LDLT decomposition for a matrix `A`, this computes the
-   * decomposition for the matrix `A` with extra `r` columns and rows from `a`
-   * added at the index `i`.
-   *
-   * @param i index where the block should be inserted
-   * @param a matrix of the new columns that are inserted
-   * @param stack workspace memory stack
-   */
-  void insert_block_at(isize i,
-                       Eigen::Ref<ColMat const> a,
-                       proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-
-    isize n = dim();
-    isize r = a.cols();
-
-    if (r == 0) {
-      return;
-    }
-
-    reserve(n + r);
-
-    isize i_actual = choose_insertion_position(i, a.col(0));
-
-    for (isize j = 0; j < n; ++j) {
-      auto& p_j = perm[j];
-      auto& pinv_j = perm_inv[j];
-
-      if (p_j >= i) {
-        p_j += r;
-      }
-      if (pinv_j >= i_actual) {
-        pinv_j += r;
-      }
-    }
-
-    for (isize k = 0; k < r; ++k) {
-      perm.push_mid(i + k, i_actual + k);
-      perm_inv.push_mid(i_actual + k, i + k);
-      maybe_sorted_diag.push_mid(a(i + k, k), i_actual + k);
-    }
-
-    LDLT_TEMP_MAT_UNINIT(T, permuted_a, n + r, r, stack);
-
-    for (isize k = 0; k < r; ++k) {
-      for (isize j = 0; j < n + r; ++j) {
-        permuted_a(j, k) = a(perm[j], k);
-      }
-    }
-
-    proxsuite::linalg::dense::ldlt_insert_rows_and_cols(
-      ld_col_mut(), i_actual, permuted_a, stack);
-  }
-
-  /*!
-   * Returns the memory storage requirements for a diagonal subsection update
-   * with size at most `r`, in a matrix with size at most `n×n`.
-   *
-   * @param n maximum dimension of the matrix
-   * @param r maximum size of diagonal subsection that gets updated
-   */
-  static auto diagonal_update_req(isize n, isize r) noexcept
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    using proxsuite::linalg::veg::dynstack::StackReq;
-    auto algo_req = StackReq{
-      2 * r * isize{ sizeof(isize) },
-      alignof(isize),
-    };
-    auto w_req = StackReq{
-      _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
-      _detail::align<T>(),
-    };
-    auto alpha_req = StackReq{
-      r * isize{ sizeof(T) },
-      alignof(T),
-    };
-    return algo_req & w_req & alpha_req;
-  }
-
-  /*!
-   * Given an LDLT decomposition for a matrix `A`, this computes the
-   * decomposition for the matrix `A` with the vector `alpha` added to a
-   * diagonal subset, as specified by the provided indices.
-   *
-   * The values pointed at by `indices` are unspecified after a call to this
-   * function.
-   *
-   * @param indices pointer to the array of indices of diagonal elements that
-   * are updated
-   * @param r number of the indices to be updated
-   * @param stack workspace memory stack
-   */
-  void diagonal_update_clobber_indices( //
-    isize* indices,
-    isize r,
-    Eigen::Ref<Vec const> alpha,
-    proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-
-    if (r == 0) {
-      return;
-    }
-
-    auto _positions =
-      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
-    auto _sorted_indices =
-      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
-    auto* positions = _positions.ptr_mut();
-    auto* sorted_indices = _sorted_indices.ptr_mut();
-
-    for (isize k = 0; k < r; ++k) {
-      indices[k] = perm_inv[indices[k]];
-      positions[k] = k;
-    }
-
-    std::sort(
-      positions, positions + r, [indices](isize i, isize j) noexcept -> bool {
-        return indices[i] < indices[j];
-      });
-
-    for (isize k = 0; k < r; ++k) {
-      sorted_indices[k] = indices[positions[k]];
-    }
-
-    auto first = sorted_indices[0];
-    auto n = dim() - first;
-
-    LDLT_TEMP_MAT(T, _w, n, r, stack);
-    LDLT_TEMP_VEC_UNINIT(T, _alpha, r, stack);
-
-    for (isize k = 0; k < r; ++k) {
-      _alpha(k) = alpha(positions[k]);
-      _w(sorted_indices[k] - first, k) = 1;
-    }
-
-    proxsuite::linalg::dense::_detail::rank_r_update_clobber_w_impl(
-      util::submatrix(ld_col_mut(), first, first, n, n),
-      _w.data(),
-      _w.outerStride(),
-      _alpha.data(),
-      _detail::IndicesR{
-        first,
-        0,
-        r,
-        sorted_indices,
-      });
-  }
-
-  /*!
-   * Given an LDLT decomposition for a matrix `A`, this computes the
-   * decomposition for the rank-updated matrix `A + w×diag(alpha)×w.T`
-   *
-   * @param w rank update matrix
-   * @param alpha rank update diagonal vector
-   * @param stack workspace memory stack
-   */
-  void rank_r_update( //
-    Eigen::Ref<ColMat const> w,
-    Eigen::Ref<Vec const> alpha,
-    proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-
-    auto n = dim();
-    auto r = w.cols();
-    if (r == 0) {
-      return;
-    }
-
-    VEG_ASSERT(w.rows() == n);
-
-    LDLT_TEMP_MAT_UNINIT(T, _w, n, r, stack);
-    LDLT_TEMP_VEC_UNINIT(T, _alpha, r, stack);
-
-    for (isize k = 0; k < r; ++k) {
-      auto alpha_tmp = alpha(k);
-      _alpha(k) = alpha_tmp;
-      for (isize i = 0; i < n; ++i) {
-        auto w_tmp = w(perm[i], k);
-        _w(i, k) = w_tmp;
-        maybe_sorted_diag[i] += alpha_tmp * (w_tmp * w_tmp);
-      }
-    }
-
-    proxsuite::linalg::dense::rank_r_update_clobber_inputs(
-      ld_col_mut(), _w, _alpha);
-  }
-
-  /*!
-   * Returns the dimension of the stored decomposition.
-   */
-  auto dim() const noexcept -> isize { return perm.len(); }
-
-  auto ld_col() const noexcept -> Eigen::Map< //
-    ColMat const,
-    Eigen::Unaligned,
-    Eigen::OuterStride<DYN>>
-  {
-    return { ld_storage.ptr(), dim(), dim(), stride };
-  }
-  auto ld_col_mut() noexcept -> Eigen::Map< //
-    ColMat,
-    Eigen::Unaligned,
-    Eigen::OuterStride<DYN>>
-  {
-    return { ld_storage.ptr_mut(), dim(), dim(), stride };
-  }
-  auto ld_row() const noexcept -> Eigen::Map< //
-    RowMat const,
-    Eigen::Unaligned,
-    Eigen::OuterStride<DYN>>
-  {
-    return {
-      ld_storage.ptr(),
-      dim(),
-      dim(),
-      Eigen::OuterStride<DYN>{ stride },
-    };
-  }
-  auto ld_row_mut() noexcept -> Eigen::Map< //
-    RowMat,
-    Eigen::Unaligned,
-    Eigen::OuterStride<DYN>>
-  {
-    return {
-      ld_storage.ptr_mut(),
-      dim(),
-      dim(),
-      Eigen::OuterStride<DYN>{ stride },
-    };
-  }
-
-  auto l() const noexcept -> LView
-  {
-    return ld_col().template triangularView<Eigen::UnitLower>();
-  }
-  auto l_mut() noexcept -> LViewMut
-  {
-    return ld_col_mut().template triangularView<Eigen::UnitLower>();
-  }
-  auto lt() const noexcept -> LTView
-  {
-    return ld_row().template triangularView<Eigen::UnitUpper>();
-  }
-  auto lt_mut() noexcept -> LTViewMut
-  {
-    return ld_row_mut().template triangularView<Eigen::UnitUpper>();
-  }
-
-  auto d() const noexcept -> DView
-  {
-    return {
-      ld_storage.ptr(),
-      dim(),
-      1,
-      Eigen::InnerStride<DYN>{ stride + 1 },
-    };
-  }
-  auto d_mut() noexcept -> DViewMut
-  {
-    return {
-      ld_storage.ptr_mut(),
-      dim(),
-      1,
-      Eigen::InnerStride<DYN>{ stride + 1 },
-    };
-  }
-  auto p() const -> Perm { return { VecMapISize(perm.ptr(), dim()) }; }
-  auto pt() const -> Perm { return { VecMapISize(perm_inv.ptr(), dim()) }; }
-
-  /*!
-   * Returns the memory storage requirements for a factorization of a matrix
-   * of size at most `n×n`
-   *
-   * @param n maximum dimension of the matrix
-   */
-  static auto factorize_req(isize n)
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return proxsuite::linalg::veg::dynstack::StackReq{
-      n * adjusted_stride(n) * isize{ sizeof(T) },
-      _detail::align<T>(),
-    } |
-           proxsuite::linalg::dense::factorize_req(
-             proxsuite::linalg::veg::Tag<T>{}, n);
-  }
-
-  /*!
-   * Computes the decomposition of a given matrix `A`.
-   * The matrix is interpreted as a symmetric matrix and only
-   * the lower triangular part of `A` is accessed.
-   *
-   * @param mat matrix whose decomposition should be computed
-   * @param stack workspace memory stack
-   */
-  void factorize(Eigen::Ref<ColMat const> mat /* NOLINT */,
-                 proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-    VEG_ASSERT(mat.rows() == mat.cols());
-    isize n = mat.rows();
-    reserve_uninit(n);
-
-    perm.resize_for_overwrite(n);
-    perm_inv.resize_for_overwrite(n);
-    maybe_sorted_diag.resize_for_overwrite(n);
-
-    proxsuite::linalg::dense::_detail::compute_permutation( //
-      perm.ptr_mut(),
-      perm_inv.ptr_mut(),
-      util::diagonal(mat));
-
-    {
-      LDLT_TEMP_MAT_UNINIT(T, work, n, n, stack);
-      ld_col_mut() = mat;
-      proxsuite::linalg::dense::_detail::apply_permutation_tri_lower(
-        ld_col_mut(), work, perm.ptr());
-    }
-
-    for (isize i = 0; i < n; ++i) {
-      maybe_sorted_diag[i] = ld_col()(i, i);
-    }
-
-    proxsuite::linalg::dense::factorize(ld_col_mut(), stack);
-  }
-
-  /*!
-   * Returns the memory storage requirements for solving a linear system
-   * with a decomposition of dimension at most `n`
-   *
-   * @param n maximum dimension of the matrix
-   */
-  static auto solve_in_place_req(isize n)
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return {
-      n * isize{ sizeof(T) },
-      _detail::align<T>(),
-    };
-  }
-
-  /*!
-   * Solves the system `A×x = rhs`, and stores the result in `rhs`.
-   *
-   * @param rhs right hand side of the linear system
-   * @param stack workspace memory stack
-   */
-  void solve_in_place(Eigen::Ref<Vec> rhs,
-                      proxsuite::linalg::veg::dynstack::DynStackMut stack) const
-  {
-    isize n = rhs.rows();
-    LDLT_TEMP_VEC_UNINIT(T, work, n, stack);
-
-    for (isize i = 0; i < n; ++i) {
-      work[i] = rhs[perm[i]];
-    }
-
-    proxsuite::linalg::dense::solve(ld_col(), work);
-
-    for (isize i = 0; i < n; ++i) {
-      rhs[i] = work[perm_inv[i]];
-    }
-  }
-
-  auto dbg_reconstructed_matrix_internal() const -> ColMat
-  {
-    isize n = dim();
-    auto tmp = ColMat(n, n);
-    tmp = l();
-    tmp = tmp * d().asDiagonal();
-    auto A = ColMat(tmp * lt());
-    return A;
-  }
-
-  auto dbg_reconstructed_matrix() const -> ColMat
-  {
-    isize n = dim();
-    auto tmp = ColMat(n, n);
-    tmp = l();
-    tmp = tmp * d().asDiagonal();
-    auto A = ColMat(tmp * lt());
-
-    for (isize i = 0; i < n; i++) {
-      tmp.row(i) = A.row(perm_inv[i]);
-    }
-    for (isize i = 0; i < n; i++) {
-      A.col(i) = tmp.col(perm_inv[i]);
-    }
-    return A;
-  }
-};
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP
+
+#include "proxsuite/linalg/dense/factorize.hpp"
+#include "proxsuite/linalg/dense/update.hpp"
+#include "proxsuite/linalg/dense/modify.hpp"
+#include "proxsuite/linalg/dense/solve.hpp"
+#include <proxsuite/linalg/veg/vec.hpp>
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+namespace _detail {
+struct SimdAlignedSystemAlloc
+{
+  friend auto operator==(SimdAlignedSystemAlloc /*unused*/,
+                         SimdAlignedSystemAlloc /*unused*/) noexcept -> bool
+  {
+    return true;
+  }
+};
+} // namespace _detail
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+template<>
+struct proxsuite::linalg::veg::mem::Alloc<
+  proxsuite::linalg::dense::_detail::SimdAlignedSystemAlloc>
+{
+#ifdef PROXSUITE_VECTORIZE
+  static constexpr usize min_align = alignof(std::max_align_t) >
+                                         SIMDE_NATURAL_VECTOR_SIZE / 8
+                                       ? SIMDE_NATURAL_VECTOR_SIZE / 8
+                                       : alignof(std::max_align_t);
+#else
+  static constexpr usize min_align = 0;
+#endif
+
+  using RefMut = proxsuite::linalg::veg::RefMut<
+    proxsuite::linalg::dense::_detail::SimdAlignedSystemAlloc>;
+
+  VEG_INLINE static auto adjusted_layout(Layout l) noexcept -> Layout
+  {
+    if (l.align < min_align) {
+      l.align = min_align;
+    }
+    return l;
+  }
+
+  VEG_INLINE static void dealloc(RefMut /*alloc*/, void* ptr, Layout l) noexcept
+  {
+    return Alloc<SystemAlloc>::dealloc(
+      mut(SystemAlloc{}), ptr, adjusted_layout(l));
+  }
+
+  VEG_NODISCARD VEG_INLINE static auto alloc(RefMut /*alloc*/,
+                                             Layout l) noexcept
+    -> mem::AllocBlock
+  {
+    return Alloc<SystemAlloc>::alloc(mut(SystemAlloc{}), adjusted_layout(l));
+  }
+
+  VEG_NODISCARD VEG_INLINE static auto grow(RefMut /*alloc*/,
+                                            void* ptr,
+                                            Layout l,
+                                            usize new_size,
+                                            RelocFn reloc) noexcept
+    -> mem::AllocBlock
+  {
+    return Alloc<SystemAlloc>::grow(
+      mut(SystemAlloc{}), ptr, adjusted_layout(l), new_size, reloc);
+  }
+  VEG_NODISCARD VEG_INLINE static auto shrink(RefMut /*alloc*/,
+                                              void* ptr,
+                                              Layout l,
+                                              usize new_size,
+                                              RelocFn reloc) noexcept
+    -> mem::AllocBlock
+  {
+    return Alloc<SystemAlloc>::shrink(
+      mut(SystemAlloc{}), ptr, adjusted_layout(l), new_size, reloc);
+  }
+};
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+/*!
+ * Wrapper class that handles an allocated LDLT decomposition,
+ * with an applied permutation.
+ * When provided with a matrix `A`, this internally stores a lower triangular
+ * matrix with unit diagonal `L`, a vector `D`, and a permutation `P` such that
+ * `A = P.T L diag(D) L.T P`.
+ *
+ * Example usage:
+ * ```cpp
+#include <proxsuite/linalg/dense/ldlt.hpp>
+#include <proxsuite/linalg/veg/util/dynstack_alloc.hpp>
+
+auto main() -> int {
+        constexpr auto DYN = Eigen::Dynamic;
+        using Matrix = Eigen::Matrix<double, DYN, DYN>;
+        using Vector = Eigen::Matrix<double, DYN, 1>;
+        using Ldlt = proxsuite::linalg::dense::Ldlt<double>;
+        using proxsuite::linalg::veg::dynstack::StackReq;
+
+        // allocate a matrix `a`
+        auto a0 = Matrix{
+                        2,
+                        2,
+        };
+
+        // workspace memory requirements
+        auto req =
+                        Ldlt::factorize_req(2) |          // initial
+factorization of dim 2 Ldlt::insert_block_at_req(2, 1) | // or 1 insertion to
+matrix of dim 2 Ldlt::delete_at_req(3, 2) |       // or 2 deletions from matrix
+of dim 3 Ldlt::solve_in_place_req(1);      // or solve in place with dim 1
+
+        VEG_MAKE_STACK(stack, req);
+
+        Ldlt ldl;
+
+        // fill up the lower triangular part
+        // matrix is
+        // 1.0 2.0
+        // 2.0 3.0
+        a0(0, 0) = 1.0;
+        a0(1, 0) = 2.0;
+        a0(1, 1) = 3.0;
+
+        ldl.factorize(a0, stack);
+
+        // add one column at the index 1
+        // matrix is
+        // 1.0 4.0 2.0
+        // 4.0 5.0 6.0
+        // 2.0 6.0 3.0
+        auto c = Matrix{3, 1};
+        c(0, 0) = 4.0;
+        c(1, 0) = 5.0;
+        c(2, 0) = 6.0;
+        ldl.insert_block_at(1, c, stack);
+
+        // then delete two rows and columns at indices 0 and 2
+        // matrix is
+        // 5.0
+        proxsuite::linalg::veg::isize const indices[] = {0, 2};
+        ldl.delete_at(indices, 2, stack);
+
+        auto rhs = Vector{1};
+        rhs[0] = 5.0;
+
+        ldl.solve_in_place(rhs, stack);
+        VEG_ASSERT(rhs[0] == 1.0);
+}
+ * ```
+ */
+template<typename T>
+struct Ldlt
+{
+private:
+  static constexpr auto DYN = Eigen::Dynamic;
+  using ColMat = Eigen::Matrix<T, DYN, DYN, Eigen::ColMajor>;
+  using RowMat = Eigen::Matrix<T, DYN, DYN, Eigen::RowMajor>;
+  using Vec = Eigen::Matrix<T, DYN, 1>;
+
+  using LView = Eigen::TriangularView<Eigen::Map< //
+                                        ColMat const,
+                                        Eigen::Unaligned,
+                                        Eigen::OuterStride<DYN>>,
+                                      Eigen::UnitLower>;
+  using LViewMut = Eigen::TriangularView<Eigen::Map< //
+                                           ColMat,
+                                           Eigen::Unaligned,
+                                           Eigen::OuterStride<DYN>>,
+                                         Eigen::UnitLower>;
+
+  using LTView = Eigen::TriangularView<Eigen::Map< //
+                                         RowMat const,
+                                         Eigen::Unaligned,
+                                         Eigen::OuterStride<DYN>>,
+                                       Eigen::UnitUpper>;
+  using LTViewMut = Eigen::TriangularView<Eigen::Map< //
+                                            RowMat,
+                                            Eigen::Unaligned,
+                                            Eigen::OuterStride<DYN>>,
+                                          Eigen::UnitUpper>;
+
+  using DView =
+    Eigen::Map<Vec const, Eigen::Unaligned, Eigen::InnerStride<DYN>>;
+  using DViewMut = Eigen::Map<Vec, Eigen::Unaligned, Eigen::InnerStride<DYN>>;
+
+  using VecMapISize = Eigen::Map<Eigen::Matrix<isize, DYN, 1> const>;
+  using Perm = Eigen::PermutationWrapper<VecMapISize>;
+
+  using StorageSimdVec =
+    proxsuite::linalg::veg::Vec<T,
+                                proxsuite::linalg::veg::meta::if_t<
+                                  _detail::should_vectorize<T>::value,
+                                  _detail::SimdAlignedSystemAlloc,
+                                  proxsuite::linalg::veg::mem::SystemAlloc>>;
+
+  StorageSimdVec ld_storage;
+  isize stride{};
+  proxsuite::linalg::veg::Vec<isize> perm;
+  proxsuite::linalg::veg::Vec<isize> perm_inv;
+
+  // sorted on a best effort basis
+  proxsuite::linalg::veg::Vec<T> maybe_sorted_diag;
+
+  VEG_REFLECT(Ldlt, ld_storage, stride, perm, perm_inv, maybe_sorted_diag);
+
+  static auto adjusted_stride(isize n) noexcept -> isize
+  {
+    return _detail::adjusted_stride<T>(n);
+  }
+
+  // soft invariants:
+  // - perm.len() == perm_inv.len() == dim
+  // - dim < stride
+  // - ld_storage.len() >= dim * stride
+public:
+  /*!
+   * Default constructor, initialized with a `0×0` empty matrix.
+   */
+  Ldlt() = default;
+
+  /*!
+   * Reserves enough internal storage for a matrix `A` of size at least
+   * `cap×cap`.
+   * This operation invalidates the existing decomposition.
+   *
+   * @param cap new capacity
+   */
+  void reserve_uninit(isize cap) noexcept
+  {
+    static_assert(VEG_CONCEPT(nothrow_constructible<T>), ".");
+
+    auto new_stride = adjusted_stride(cap);
+    if (cap <= stride && cap * new_stride <= ld_storage.len()) {
+      return;
+    }
+
+    ld_storage.reserve_exact(cap * new_stride);
+    perm.reserve_exact(cap);
+    perm_inv.reserve_exact(cap);
+    maybe_sorted_diag.reserve_exact(cap);
+
+    ld_storage.resize_for_overwrite(cap * new_stride);
+    stride = new_stride;
+  }
+
+  /*!
+   * Reserves enough internal storage for a matrix `A` of size at least
+   * `cap×cap`.
+   * This operation preserves the existing decomposition.
+   *
+   * @param cap new capacity
+   */
+  void reserve(isize cap) noexcept
+  {
+    auto new_stride = adjusted_stride(cap);
+    if (cap <= stride && cap * new_stride <= ld_storage.len()) {
+      return;
+    }
+    auto n = dim();
+
+    ld_storage.reserve_exact(cap * new_stride);
+    perm.reserve_exact(cap);
+    perm_inv.reserve_exact(cap);
+    maybe_sorted_diag.reserve_exact(cap);
+
+    ld_storage.resize_for_overwrite(cap * new_stride);
+
+    for (isize i = 0; i < n; ++i) {
+      auto col = n - i - 1;
+      T* ptr = ld_col_mut().data();
+      std::move_backward( //
+        ptr + col * stride,
+        ptr + col * stride + n,
+        ptr + col * new_stride + n);
+    }
+    stride = new_stride;
+  }
+
+  /*!
+   * Returns the memory storage requirements for performing a rank `k` update
+   * on a matrix with size at most `n×n`, with `k ≤ r`.
+   *
+   * @param n maximum dimension of the matrix
+   * @param r maximum number of simultaneous rank updates
+   */
+  static auto rank_r_update_req(isize n, isize r) noexcept
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
+      _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
+      _detail::align<T>(),
+    };
+    auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
+      r * isize{ sizeof(T) },
+      alignof(T),
+    };
+    return w_req & alpha_req;
+  }
+
+  /*!
+   * Returns the memory storage requirements for deleting at most `r` rows and
+   * columns from a matrix with size at most `n×n`.
+   *
+   * @param n maximum dimension of the matrix
+   * @param r maximum number of rows to be deleted
+   */
+  static auto delete_at_req(isize n, isize r) noexcept
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return proxsuite::linalg::veg::dynstack::StackReq{
+      r * isize{ sizeof(isize) },
+      alignof(isize),
+    } &
+           proxsuite::linalg::dense::ldlt_delete_rows_and_cols_req(
+             proxsuite::linalg::veg::Tag<T>{}, n, r);
+  }
+
+  /*!
+   * Given an LDLT decomposition for a matrix `A`, this computes the
+   * decomposition for the matrix `A` with `r` columns and rows removed, as
+   * indicated by the indices `indices[0], ..., indices[r-1]`.
+   *
+   * @param indices pointer to the array of indices to be deleted
+   * @param r number of the indices to be deleted
+   * @param stack workspace memory stack
+   */
+  void delete_at(isize const* indices,
+                 isize r,
+                 proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+    if (r == 0) {
+      return;
+    }
+
+    VEG_ASSERT(std::is_sorted(indices, indices + r));
+
+    isize n = dim();
+
+    auto _indices_actual =
+      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
+    auto* indices_actual = _indices_actual.ptr_mut();
+
+    for (isize k = 0; k < r; ++k) {
+      indices_actual[k] = perm_inv[indices[k]];
+    }
+
+    proxsuite::linalg::dense::ldlt_delete_rows_and_cols_sort_indices( //
+      ld_col_mut(),
+      indices_actual,
+      r,
+      stack);
+
+    // PERF: do this in one pass
+    for (isize k = 0; k < r; ++k) {
+      auto i_actual = indices_actual[r - 1 - k];
+      auto i = indices[r - 1 - k];
+
+      perm.pop_mid(i_actual);
+      perm_inv.pop_mid(i);
+      maybe_sorted_diag.pop_mid(i_actual);
+
+      for (isize j = 0; j < n - 1 - k; ++j) {
+        auto& p_j = perm[j];
+        auto& pinv_j = perm_inv[j];
+
+        if (p_j > i) {
+          --p_j;
+        }
+        if (pinv_j > i_actual) {
+          --pinv_j;
+        }
+      }
+    }
+  }
+
+  auto choose_insertion_position(isize i, Eigen::Ref<Vec const> a) -> isize
+  {
+    isize n = dim();
+    auto diag_elem = a[i];
+
+    isize pos = 0;
+    for (; pos < n; ++pos) {
+      if (diag_elem >= maybe_sorted_diag[pos]) {
+        break;
+      }
+    }
+    return pos;
+  }
+
+  /*!
+   * Returns the memory storage requirements for inserting at most `r` rows and
+   * columns from a matrix with size at most `n×n`.
+   *
+   * @param n maximum dimension of the matrix
+   * @param r maximum number of rows to be inserted
+   */
+  static auto insert_block_at_req(isize n, isize r) noexcept
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    using proxsuite::linalg::veg::dynstack::StackReq;
+    return StackReq{
+      isize{ sizeof(T) } * (adjusted_stride(n + r) * r),
+      _detail::align<T>(),
+    } &
+           proxsuite::linalg::dense::ldlt_insert_rows_and_cols_req(
+             proxsuite::linalg::veg::Tag<T>{}, n, r);
+  }
+
+  /*!
+   * Given an LDLT decomposition for a matrix `A`, this computes the
+   * decomposition for the matrix `A` with extra `r` columns and rows from `a`
+   * added at the index `i`.
+   *
+   * @param i index where the block should be inserted
+   * @param a matrix of the new columns that are inserted
+   * @param stack workspace memory stack
+   */
+  void insert_block_at(isize i,
+                       Eigen::Ref<ColMat const> a,
+                       proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+
+    isize n = dim();
+    isize r = a.cols();
+
+    if (r == 0) {
+      return;
+    }
+
+    reserve(n + r);
+
+    isize i_actual = choose_insertion_position(i, a.col(0));
+
+    for (isize j = 0; j < n; ++j) {
+      auto& p_j = perm[j];
+      auto& pinv_j = perm_inv[j];
+
+      if (p_j >= i) {
+        p_j += r;
+      }
+      if (pinv_j >= i_actual) {
+        pinv_j += r;
+      }
+    }
+
+    for (isize k = 0; k < r; ++k) {
+      perm.push_mid(i + k, i_actual + k);
+      perm_inv.push_mid(i_actual + k, i + k);
+      maybe_sorted_diag.push_mid(a(i + k, k), i_actual + k);
+    }
+
+    LDLT_TEMP_MAT_UNINIT(T, permuted_a, n + r, r, stack);
+
+    for (isize k = 0; k < r; ++k) {
+      for (isize j = 0; j < n + r; ++j) {
+        permuted_a(j, k) = a(perm[j], k);
+      }
+    }
+
+    proxsuite::linalg::dense::ldlt_insert_rows_and_cols(
+      ld_col_mut(), i_actual, permuted_a, stack);
+  }
+
+  /*!
+   * Returns the memory storage requirements for a diagonal subsection update
+   * with size at most `r`, in a matrix with size at most `n×n`.
+   *
+   * @param n maximum dimension of the matrix
+   * @param r maximum size of diagonal subsection that gets updated
+   */
+  static auto diagonal_update_req(isize n, isize r) noexcept
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    using proxsuite::linalg::veg::dynstack::StackReq;
+    auto algo_req = StackReq{
+      2 * r * isize{ sizeof(isize) },
+      alignof(isize),
+    };
+    auto w_req = StackReq{
+      _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
+      _detail::align<T>(),
+    };
+    auto alpha_req = StackReq{
+      r * isize{ sizeof(T) },
+      alignof(T),
+    };
+    return algo_req & w_req & alpha_req;
+  }
+
+  /*!
+   * Given an LDLT decomposition for a matrix `A`, this computes the
+   * decomposition for the matrix `A` with the vector `alpha` added to a
+   * diagonal subset, as specified by the provided indices.
+   *
+   * The values pointed at by `indices` are unspecified after a call to this
+   * function.
+   *
+   * @param indices pointer to the array of indices of diagonal elements that
+   * are updated
+   * @param r number of the indices to be updated
+   * @param stack workspace memory stack
+   */
+  void diagonal_update_clobber_indices( //
+    isize* indices,
+    isize r,
+    Eigen::Ref<Vec const> alpha,
+    proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+
+    if (r == 0) {
+      return;
+    }
+
+    auto _positions =
+      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
+    auto _sorted_indices =
+      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<isize>{}, r);
+    auto* positions = _positions.ptr_mut();
+    auto* sorted_indices = _sorted_indices.ptr_mut();
+
+    for (isize k = 0; k < r; ++k) {
+      indices[k] = perm_inv[indices[k]];
+      positions[k] = k;
+    }
+
+    std::sort(
+      positions, positions + r, [indices](isize i, isize j) noexcept -> bool {
+        return indices[i] < indices[j];
+      });
+
+    for (isize k = 0; k < r; ++k) {
+      sorted_indices[k] = indices[positions[k]];
+    }
+
+    auto first = sorted_indices[0];
+    auto n = dim() - first;
+
+    LDLT_TEMP_MAT(T, _w, n, r, stack);
+    LDLT_TEMP_VEC_UNINIT(T, _alpha, r, stack);
+
+    for (isize k = 0; k < r; ++k) {
+      _alpha(k) = alpha(positions[k]);
+      _w(sorted_indices[k] - first, k) = 1;
+    }
+
+    proxsuite::linalg::dense::_detail::rank_r_update_clobber_w_impl(
+      util::submatrix(ld_col_mut(), first, first, n, n),
+      _w.data(),
+      _w.outerStride(),
+      _alpha.data(),
+      _detail::IndicesR{
+        first,
+        0,
+        r,
+        sorted_indices,
+      });
+  }
+
+  /*!
+   * Given an LDLT decomposition for a matrix `A`, this computes the
+   * decomposition for the rank-updated matrix `A + w×diag(alpha)×w.T`
+   *
+   * @param w rank update matrix
+   * @param alpha rank update diagonal vector
+   * @param stack workspace memory stack
+   */
+  void rank_r_update( //
+    Eigen::Ref<ColMat const> w,
+    Eigen::Ref<Vec const> alpha,
+    proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+
+    auto n = dim();
+    auto r = w.cols();
+    if (r == 0) {
+      return;
+    }
+
+    VEG_ASSERT(w.rows() == n);
+
+    LDLT_TEMP_MAT_UNINIT(T, _w, n, r, stack);
+    LDLT_TEMP_VEC_UNINIT(T, _alpha, r, stack);
+
+    for (isize k = 0; k < r; ++k) {
+      auto alpha_tmp = alpha(k);
+      _alpha(k) = alpha_tmp;
+      for (isize i = 0; i < n; ++i) {
+        auto w_tmp = w(perm[i], k);
+        _w(i, k) = w_tmp;
+        maybe_sorted_diag[i] += alpha_tmp * (w_tmp * w_tmp);
+      }
+    }
+
+    proxsuite::linalg::dense::rank_r_update_clobber_inputs(
+      ld_col_mut(), _w, _alpha);
+  }
+
+  /*!
+   * Returns the dimension of the stored decomposition.
+   */
+  auto dim() const noexcept -> isize { return perm.len(); }
+
+  auto ld_col() const noexcept -> Eigen::Map< //
+    ColMat const,
+    Eigen::Unaligned,
+    Eigen::OuterStride<DYN>>
+  {
+    return { ld_storage.ptr(), dim(), dim(), stride };
+  }
+  auto ld_col_mut() noexcept -> Eigen::Map< //
+    ColMat,
+    Eigen::Unaligned,
+    Eigen::OuterStride<DYN>>
+  {
+    return { ld_storage.ptr_mut(), dim(), dim(), stride };
+  }
+  auto ld_row() const noexcept -> Eigen::Map< //
+    RowMat const,
+    Eigen::Unaligned,
+    Eigen::OuterStride<DYN>>
+  {
+    return {
+      ld_storage.ptr(),
+      dim(),
+      dim(),
+      Eigen::OuterStride<DYN>{ stride },
+    };
+  }
+  auto ld_row_mut() noexcept -> Eigen::Map< //
+    RowMat,
+    Eigen::Unaligned,
+    Eigen::OuterStride<DYN>>
+  {
+    return {
+      ld_storage.ptr_mut(),
+      dim(),
+      dim(),
+      Eigen::OuterStride<DYN>{ stride },
+    };
+  }
+
+  auto l() const noexcept -> LView
+  {
+    return ld_col().template triangularView<Eigen::UnitLower>();
+  }
+  auto l_mut() noexcept -> LViewMut
+  {
+    return ld_col_mut().template triangularView<Eigen::UnitLower>();
+  }
+  auto lt() const noexcept -> LTView
+  {
+    return ld_row().template triangularView<Eigen::UnitUpper>();
+  }
+  auto lt_mut() noexcept -> LTViewMut
+  {
+    return ld_row_mut().template triangularView<Eigen::UnitUpper>();
+  }
+
+  auto d() const noexcept -> DView
+  {
+    return {
+      ld_storage.ptr(),
+      dim(),
+      1,
+      Eigen::InnerStride<DYN>{ stride + 1 },
+    };
+  }
+  auto d_mut() noexcept -> DViewMut
+  {
+    return {
+      ld_storage.ptr_mut(),
+      dim(),
+      1,
+      Eigen::InnerStride<DYN>{ stride + 1 },
+    };
+  }
+  auto p() const -> Perm { return { VecMapISize(perm.ptr(), dim()) }; }
+  auto pt() const -> Perm { return { VecMapISize(perm_inv.ptr(), dim()) }; }
+
+  /*!
+   * Returns the memory storage requirements for a factorization of a matrix
+   * of size at most `n×n`
+   *
+   * @param n maximum dimension of the matrix
+   */
+  static auto factorize_req(isize n)
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return proxsuite::linalg::veg::dynstack::StackReq{
+      n * adjusted_stride(n) * isize{ sizeof(T) },
+      _detail::align<T>(),
+    } |
+           proxsuite::linalg::dense::factorize_req(
+             proxsuite::linalg::veg::Tag<T>{}, n);
+  }
+
+  /*!
+   * Computes the decomposition of a given matrix `A`.
+   * The matrix is interpreted as a symmetric matrix and only
+   * the lower triangular part of `A` is accessed.
+   *
+   * @param mat matrix whose decomposition should be computed
+   * @param stack workspace memory stack
+   */
+  void factorize(Eigen::Ref<ColMat const> mat /* NOLINT */,
+                 proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+    VEG_ASSERT(mat.rows() == mat.cols());
+    isize n = mat.rows();
+    reserve_uninit(n);
+
+    perm.resize_for_overwrite(n);
+    perm_inv.resize_for_overwrite(n);
+    maybe_sorted_diag.resize_for_overwrite(n);
+
+    proxsuite::linalg::dense::_detail::compute_permutation( //
+      perm.ptr_mut(),
+      perm_inv.ptr_mut(),
+      util::diagonal(mat));
+
+    {
+      LDLT_TEMP_MAT_UNINIT(T, work, n, n, stack);
+      ld_col_mut() = mat;
+      proxsuite::linalg::dense::_detail::apply_permutation_tri_lower(
+        ld_col_mut(), work, perm.ptr());
+    }
+
+    for (isize i = 0; i < n; ++i) {
+      maybe_sorted_diag[i] = ld_col()(i, i);
+    }
+
+    proxsuite::linalg::dense::factorize(ld_col_mut(), stack);
+  }
+
+  /*!
+   * Returns the memory storage requirements for solving a linear system
+   * with a decomposition of dimension at most `n`
+   *
+   * @param n maximum dimension of the matrix
+   */
+  static auto solve_in_place_req(isize n)
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return {
+      n * isize{ sizeof(T) },
+      _detail::align<T>(),
+    };
+  }
+
+  /*!
+   * Solves the system `A×x = rhs`, and stores the result in `rhs`.
+   *
+   * @param rhs right hand side of the linear system
+   * @param stack workspace memory stack
+   */
+  void solve_in_place(Eigen::Ref<Vec> rhs,
+                      proxsuite::linalg::veg::dynstack::DynStackMut stack) const
+  {
+    isize n = rhs.rows();
+    LDLT_TEMP_VEC_UNINIT(T, work, n, stack);
+
+    for (isize i = 0; i < n; ++i) {
+      work[i] = rhs[perm[i]];
+    }
+
+    proxsuite::linalg::dense::solve(ld_col(), work);
+
+    for (isize i = 0; i < n; ++i) {
+      rhs[i] = work[perm_inv[i]];
+    }
+  }
+
+  auto dbg_reconstructed_matrix_internal() const -> ColMat
+  {
+    isize n = dim();
+    auto tmp = ColMat(n, n);
+    tmp = l();
+    tmp = tmp * d().asDiagonal();
+    auto A = ColMat(tmp * lt());
+    return A;
+  }
+
+  auto dbg_reconstructed_matrix() const -> ColMat
+  {
+    isize n = dim();
+    auto tmp = ColMat(n, n);
+    tmp = l();
+    tmp = tmp * d().asDiagonal();
+    auto A = ColMat(tmp * lt());
+
+    for (isize i = 0; i < n; i++) {
+      tmp.row(i) = A.row(perm_inv[i]);
+    }
+    for (isize i = 0; i < n; i++) {
+      A.col(i) = tmp.col(perm_inv[i]);
+    }
+    return A;
+  }
+};
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_LDLT_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/dense/modify.hpp

 * *Ordering differences only*

```diff
@@ -1,333 +1,333 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP
-
-#include "proxsuite/linalg/dense/core.hpp"
-#include "proxsuite/linalg/dense/update.hpp"
-#include "proxsuite/linalg/dense/factorize.hpp"
-#include <algorithm>
-#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-namespace _detail {
-
-template<typename Mat>
-void
-delete_rows_and_cols_triangular_impl(Mat mat, isize const* indices, isize r)
-{
-  isize n = mat.rows();
-
-  for (isize chunk_j = 0; chunk_j < r + 1; ++chunk_j) {
-    isize j_start = chunk_j == 0 ? 0 : indices[chunk_j - 1] + 1;
-    isize j_finish = chunk_j == r ? n : indices[chunk_j];
-
-    for (isize j = j_start; j < j_finish; ++j) {
-      for (isize chunk_i = chunk_j; chunk_i < r + 1; ++chunk_i) {
-        isize i_start = chunk_i == chunk_j ? j : indices[chunk_i - 1] + 1;
-        isize i_finish = chunk_i == r ? n : indices[chunk_i];
-
-        if (chunk_i != 0 || chunk_j != 0) {
-          std::move( //
-            util::matrix_elem_addr(mat, i_start, j),
-            util::matrix_elem_addr(mat, i_finish, j),
-            util::matrix_elem_addr( //
-              mat,
-              (i_start - chunk_i),
-              (j - chunk_j)));
-        }
-      }
-    }
-  }
-}
-// indices: rows and columns to delete, in strictly increasing order
-//          must have at least one element (excluding the end)
-// r: count of rows to delete
-template<typename Mat>
-void
-delete_rows_and_cols_triangular(Mat&& mat, isize const* indices, isize r)
-{
-  _detail::delete_rows_and_cols_triangular_impl(
-    util::to_view_dyn(mat), indices, r);
-}
-
-struct IndicesR
-{
-  isize current_col;
-  isize current_r;
-  isize r;
-  isize const* indices;
-  VEG_INLINE auto operator()() noexcept -> isize
-  {
-    if (current_r == r) {
-      return current_r;
-    }
-
-    while (current_col == indices[current_r] - current_r) {
-      ++current_r;
-      if (current_r == r) {
-        return current_r;
-      }
-    }
-    ++current_col;
-    return current_r;
-  }
-};
-template<typename Mat>
-void
-ldlt_delete_rows_and_cols_impl( //
-  Mat ld,
-  isize* indices,
-  isize r,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  std::sort(indices, indices + r);
-
-  using T = typename Mat::Scalar;
-
-  isize n = ld.rows();
-  isize first = indices[0];
-
-  auto w_stride = _detail::adjusted_stride<T>(n - first - r);
-
-  proxsuite::linalg::veg::Tag<T> tag;
-
-  auto _w = stack.make_new(tag, r * w_stride, _detail::align<T>());
-  auto _alpha = stack.make_new_for_overwrite(tag, r);
-
-  auto pw = _w.ptr_mut();
-  auto palpha = _alpha.ptr_mut();
-
-  for (isize k = 0; k < r; ++k) {
-    isize j = indices[k];
-    palpha[k] = ld(j, j);
-    auto pwk = pw + k * w_stride;
-
-    for (isize chunk_i = k + 1; chunk_i < r + 1; ++chunk_i) {
-      isize i_start = indices[chunk_i - 1] + 1;
-      isize i_finish = chunk_i == r ? n : indices[chunk_i];
-
-      std::move(util::matrix_elem_addr(ld, i_start, j),
-                util::matrix_elem_addr(ld, i_finish, j),
-                pwk + i_start - chunk_i - first);
-    }
-  }
-  _detail::delete_rows_and_cols_triangular(ld, indices, r);
-
-  _detail::rank_r_update_clobber_w_impl(
-    util::submatrix(ld, first, first, n - first - r, n - first - r),
-    pw,
-    w_stride,
-    palpha,
-    IndicesR{ first, 0, r, indices });
-}
-
-template<typename Mat, typename A_1>
-void
-ldlt_insert_rows_and_cols_impl(
-  Mat ld,
-  isize pos,
-  A_1 a_1,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  using T = typename Mat::Scalar;
-
-  proxsuite::linalg::veg::Tag<T> tag;
-
-  isize const new_n = ld.rows();
-  isize const r = a_1.cols();
-  isize const old_n = new_n - r;
-
-  isize current_col = old_n;
-  while (true) {
-    if (current_col == pos) {
-      break;
-    }
-    --current_col;
-
-    T* src_col_ptr = util::matrix_elem_addr(ld, 0, current_col);
-    T* dest_col_ptr = util::matrix_elem_addr(ld, 0, current_col + r);
-
-    std::move_backward( //
-      src_col_ptr + pos,
-      src_col_ptr + old_n,
-      dest_col_ptr + new_n);
-
-    std::move_backward( //
-      src_col_ptr,
-      src_col_ptr + pos,
-      dest_col_ptr + pos);
-  }
-
-  while (true) {
-    if (current_col == 0) {
-      break;
-    }
-    --current_col;
-
-    T* src_col_ptr = util::matrix_elem_addr(ld, 0, current_col);
-    T* dest_col_ptr = src_col_ptr;
-
-    std::move_backward( //
-      src_col_ptr + pos,
-      src_col_ptr + old_n,
-      dest_col_ptr + new_n);
-  }
-
-  auto rem = new_n - pos - r;
-
-  auto ld00 = util::submatrix(ld, 0, 0, pos, pos);
-  auto l10 = util::submatrix(ld, pos, 0, r, pos);
-  auto l20 = util::submatrix(ld, pos + r, 0, rem, pos);
-
-  auto ld11 = util::submatrix(ld, pos, pos, r, r);
-  auto l21 = util::submatrix(ld, pos + r, pos, rem, r);
-
-  auto ld22 = util::submatrix(ld, pos + r, pos + r, rem, rem);
-
-  auto d0 = util::diagonal(ld00).asDiagonal();
-
-  auto a01 = util::subrows(a_1, 0, pos);
-  auto a11 = util::subrows(a_1, pos, r);
-  auto a21 = util::subrows(a_1, pos + r, rem);
-
-  if (l10.cols() > 0) {
-    l10 = util::trans(a01);
-    util::trans(ld00) //
-      .template triangularView<Eigen::UnitUpper>()
-      .template solveInPlace<Eigen::OnTheRight>(l10);
-
-    l10 = l10 * d0.inverse();
-  }
-
-  {
-    isize tmp_stride = _detail::adjusted_stride<T>(pos);
-    auto _tmp = stack.make_new_for_overwrite( //
-      tag,
-      tmp_stride,
-      _detail::align<T>());
-    auto d0xl10T = Eigen::Map<Eigen::Matrix< //
-                                T,
-                                Eigen::Dynamic,
-                                A_1::ColsAtCompileTime>,
-                              Eigen::Unaligned,
-                              Eigen::OuterStride<Eigen::Dynamic>>{
-      _tmp.ptr_mut(),
-      pos,
-      r,
-      tmp_stride,
-    };
-
-    ld11.template triangularView<Eigen::Lower>() =
-      a11.template triangularView<Eigen::Lower>();
-
-    if (l10.cols() > 0) {
-      d0xl10T = d0 * util::trans(l10);
-      ld11.template triangularView<Eigen::Lower>() -= l10 * d0xl10T;
-    }
-
-    l21 = a21;
-    util::noalias_mul_add(l21, l20, d0xl10T, T(-1));
-  }
-
-  proxsuite::linalg::dense::factorize(ld11, stack);
-  util::trans(ld11) //
-    .template triangularView<Eigen::UnitUpper>()
-    .template solveInPlace<Eigen::OnTheRight>(l21);
-
-  auto d1 = util::diagonal(ld11).asDiagonal();
-  l21 = l21 * d1.inverse();
-
-  auto w_stride = _detail::adjusted_stride<T>(rem);
-  auto _w = stack.make_new(tag, r * w_stride, _detail::align<T>());
-  auto _alpha = stack.make_new_for_overwrite(tag, r);
-
-  auto pw = _w.ptr_mut();
-  auto palpha = _alpha.ptr_mut();
-
-  for (isize k = 0; k < r; ++k) {
-    palpha[k] = -ld11(k, k);
-    T const* src_ptr = util::matrix_elem_addr(l21, 0, k);
-    std::copy(src_ptr, src_ptr + rem, pw + k * w_stride);
-  }
-
-  _detail::rank_r_update_clobber_w_impl( //
-    ld22,
-    pw,
-    w_stride,
-    palpha,
-    _detail::ConstantR{ r });
-}
-} // namespace _detail
-
-template<typename T>
-auto
-ldlt_delete_rows_and_cols_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
-                              isize n,
-                              isize r) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-
-  auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
-    _detail::adjusted_stride<T>(n - r) * r * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-  auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
-    r * isize{ sizeof(T) },
-    alignof(T),
-  };
-  return w_req & alpha_req;
-}
-
-template<typename Mat>
-void
-ldlt_delete_rows_and_cols_sort_indices( //
-  Mat&& ld,
-  isize* indices,
-  isize r,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  _detail::ldlt_delete_rows_and_cols_impl(
-    util::to_view_dyn(ld), indices, r, stack);
-}
-
-template<typename T>
-auto
-ldlt_insert_rows_and_cols_req(proxsuite::linalg::veg::Tag<T> tag,
-                              isize n,
-                              isize r) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  auto factorize_req = proxsuite::linalg::dense::factorize_req(tag, r);
-
-  auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
-    _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
-    _detail::align<T>(),
-  };
-  auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
-    r * isize{ sizeof(T) },
-    alignof(T),
-  };
-
-  return (w_req & alpha_req) | factorize_req;
-}
-
-template<typename Mat, typename A_1>
-void
-ldlt_insert_rows_and_cols(Mat&& ld,
-                          isize pos,
-                          A_1 const& a_1,
-                          proxsuite::linalg::veg::dynstack::DynStackMut stack)
-{
-  _detail::ldlt_insert_rows_and_cols_impl(
-    util::to_view_dyn(ld), pos, util::to_view_dyn_rows(a_1), stack);
-}
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP
+
+#include "proxsuite/linalg/dense/core.hpp"
+#include "proxsuite/linalg/dense/update.hpp"
+#include "proxsuite/linalg/dense/factorize.hpp"
+#include <algorithm>
+#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+namespace _detail {
+
+template<typename Mat>
+void
+delete_rows_and_cols_triangular_impl(Mat mat, isize const* indices, isize r)
+{
+  isize n = mat.rows();
+
+  for (isize chunk_j = 0; chunk_j < r + 1; ++chunk_j) {
+    isize j_start = chunk_j == 0 ? 0 : indices[chunk_j - 1] + 1;
+    isize j_finish = chunk_j == r ? n : indices[chunk_j];
+
+    for (isize j = j_start; j < j_finish; ++j) {
+      for (isize chunk_i = chunk_j; chunk_i < r + 1; ++chunk_i) {
+        isize i_start = chunk_i == chunk_j ? j : indices[chunk_i - 1] + 1;
+        isize i_finish = chunk_i == r ? n : indices[chunk_i];
+
+        if (chunk_i != 0 || chunk_j != 0) {
+          std::move( //
+            util::matrix_elem_addr(mat, i_start, j),
+            util::matrix_elem_addr(mat, i_finish, j),
+            util::matrix_elem_addr( //
+              mat,
+              (i_start - chunk_i),
+              (j - chunk_j)));
+        }
+      }
+    }
+  }
+}
+// indices: rows and columns to delete, in strictly increasing order
+//          must have at least one element (excluding the end)
+// r: count of rows to delete
+template<typename Mat>
+void
+delete_rows_and_cols_triangular(Mat&& mat, isize const* indices, isize r)
+{
+  _detail::delete_rows_and_cols_triangular_impl(
+    util::to_view_dyn(mat), indices, r);
+}
+
+struct IndicesR
+{
+  isize current_col;
+  isize current_r;
+  isize r;
+  isize const* indices;
+  VEG_INLINE auto operator()() noexcept -> isize
+  {
+    if (current_r == r) {
+      return current_r;
+    }
+
+    while (current_col == indices[current_r] - current_r) {
+      ++current_r;
+      if (current_r == r) {
+        return current_r;
+      }
+    }
+    ++current_col;
+    return current_r;
+  }
+};
+template<typename Mat>
+void
+ldlt_delete_rows_and_cols_impl( //
+  Mat ld,
+  isize* indices,
+  isize r,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  std::sort(indices, indices + r);
+
+  using T = typename Mat::Scalar;
+
+  isize n = ld.rows();
+  isize first = indices[0];
+
+  auto w_stride = _detail::adjusted_stride<T>(n - first - r);
+
+  proxsuite::linalg::veg::Tag<T> tag;
+
+  auto _w = stack.make_new(tag, r * w_stride, _detail::align<T>());
+  auto _alpha = stack.make_new_for_overwrite(tag, r);
+
+  auto pw = _w.ptr_mut();
+  auto palpha = _alpha.ptr_mut();
+
+  for (isize k = 0; k < r; ++k) {
+    isize j = indices[k];
+    palpha[k] = ld(j, j);
+    auto pwk = pw + k * w_stride;
+
+    for (isize chunk_i = k + 1; chunk_i < r + 1; ++chunk_i) {
+      isize i_start = indices[chunk_i - 1] + 1;
+      isize i_finish = chunk_i == r ? n : indices[chunk_i];
+
+      std::move(util::matrix_elem_addr(ld, i_start, j),
+                util::matrix_elem_addr(ld, i_finish, j),
+                pwk + i_start - chunk_i - first);
+    }
+  }
+  _detail::delete_rows_and_cols_triangular(ld, indices, r);
+
+  _detail::rank_r_update_clobber_w_impl(
+    util::submatrix(ld, first, first, n - first - r, n - first - r),
+    pw,
+    w_stride,
+    palpha,
+    IndicesR{ first, 0, r, indices });
+}
+
+template<typename Mat, typename A_1>
+void
+ldlt_insert_rows_and_cols_impl(
+  Mat ld,
+  isize pos,
+  A_1 a_1,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  using T = typename Mat::Scalar;
+
+  proxsuite::linalg::veg::Tag<T> tag;
+
+  isize const new_n = ld.rows();
+  isize const r = a_1.cols();
+  isize const old_n = new_n - r;
+
+  isize current_col = old_n;
+  while (true) {
+    if (current_col == pos) {
+      break;
+    }
+    --current_col;
+
+    T* src_col_ptr = util::matrix_elem_addr(ld, 0, current_col);
+    T* dest_col_ptr = util::matrix_elem_addr(ld, 0, current_col + r);
+
+    std::move_backward( //
+      src_col_ptr + pos,
+      src_col_ptr + old_n,
+      dest_col_ptr + new_n);
+
+    std::move_backward( //
+      src_col_ptr,
+      src_col_ptr + pos,
+      dest_col_ptr + pos);
+  }
+
+  while (true) {
+    if (current_col == 0) {
+      break;
+    }
+    --current_col;
+
+    T* src_col_ptr = util::matrix_elem_addr(ld, 0, current_col);
+    T* dest_col_ptr = src_col_ptr;
+
+    std::move_backward( //
+      src_col_ptr + pos,
+      src_col_ptr + old_n,
+      dest_col_ptr + new_n);
+  }
+
+  auto rem = new_n - pos - r;
+
+  auto ld00 = util::submatrix(ld, 0, 0, pos, pos);
+  auto l10 = util::submatrix(ld, pos, 0, r, pos);
+  auto l20 = util::submatrix(ld, pos + r, 0, rem, pos);
+
+  auto ld11 = util::submatrix(ld, pos, pos, r, r);
+  auto l21 = util::submatrix(ld, pos + r, pos, rem, r);
+
+  auto ld22 = util::submatrix(ld, pos + r, pos + r, rem, rem);
+
+  auto d0 = util::diagonal(ld00).asDiagonal();
+
+  auto a01 = util::subrows(a_1, 0, pos);
+  auto a11 = util::subrows(a_1, pos, r);
+  auto a21 = util::subrows(a_1, pos + r, rem);
+
+  if (l10.cols() > 0) {
+    l10 = util::trans(a01);
+    util::trans(ld00) //
+      .template triangularView<Eigen::UnitUpper>()
+      .template solveInPlace<Eigen::OnTheRight>(l10);
+
+    l10 = l10 * d0.inverse();
+  }
+
+  {
+    isize tmp_stride = _detail::adjusted_stride<T>(pos);
+    auto _tmp = stack.make_new_for_overwrite( //
+      tag,
+      tmp_stride,
+      _detail::align<T>());
+    auto d0xl10T = Eigen::Map<Eigen::Matrix< //
+                                T,
+                                Eigen::Dynamic,
+                                A_1::ColsAtCompileTime>,
+                              Eigen::Unaligned,
+                              Eigen::OuterStride<Eigen::Dynamic>>{
+      _tmp.ptr_mut(),
+      pos,
+      r,
+      tmp_stride,
+    };
+
+    ld11.template triangularView<Eigen::Lower>() =
+      a11.template triangularView<Eigen::Lower>();
+
+    if (l10.cols() > 0) {
+      d0xl10T = d0 * util::trans(l10);
+      ld11.template triangularView<Eigen::Lower>() -= l10 * d0xl10T;
+    }
+
+    l21 = a21;
+    util::noalias_mul_add(l21, l20, d0xl10T, T(-1));
+  }
+
+  proxsuite::linalg::dense::factorize(ld11, stack);
+  util::trans(ld11) //
+    .template triangularView<Eigen::UnitUpper>()
+    .template solveInPlace<Eigen::OnTheRight>(l21);
+
+  auto d1 = util::diagonal(ld11).asDiagonal();
+  l21 = l21 * d1.inverse();
+
+  auto w_stride = _detail::adjusted_stride<T>(rem);
+  auto _w = stack.make_new(tag, r * w_stride, _detail::align<T>());
+  auto _alpha = stack.make_new_for_overwrite(tag, r);
+
+  auto pw = _w.ptr_mut();
+  auto palpha = _alpha.ptr_mut();
+
+  for (isize k = 0; k < r; ++k) {
+    palpha[k] = -ld11(k, k);
+    T const* src_ptr = util::matrix_elem_addr(l21, 0, k);
+    std::copy(src_ptr, src_ptr + rem, pw + k * w_stride);
+  }
+
+  _detail::rank_r_update_clobber_w_impl( //
+    ld22,
+    pw,
+    w_stride,
+    palpha,
+    _detail::ConstantR{ r });
+}
+} // namespace _detail
+
+template<typename T>
+auto
+ldlt_delete_rows_and_cols_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
+                              isize n,
+                              isize r) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+
+  auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
+    _detail::adjusted_stride<T>(n - r) * r * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+  auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
+    r * isize{ sizeof(T) },
+    alignof(T),
+  };
+  return w_req & alpha_req;
+}
+
+template<typename Mat>
+void
+ldlt_delete_rows_and_cols_sort_indices( //
+  Mat&& ld,
+  isize* indices,
+  isize r,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  _detail::ldlt_delete_rows_and_cols_impl(
+    util::to_view_dyn(ld), indices, r, stack);
+}
+
+template<typename T>
+auto
+ldlt_insert_rows_and_cols_req(proxsuite::linalg::veg::Tag<T> tag,
+                              isize n,
+                              isize r) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  auto factorize_req = proxsuite::linalg::dense::factorize_req(tag, r);
+
+  auto w_req = proxsuite::linalg::veg::dynstack::StackReq{
+    _detail::adjusted_stride<T>(n) * r * isize{ sizeof(T) },
+    _detail::align<T>(),
+  };
+  auto alpha_req = proxsuite::linalg::veg::dynstack::StackReq{
+    r * isize{ sizeof(T) },
+    alignof(T),
+  };
+
+  return (w_req & alpha_req) | factorize_req;
+}
+
+template<typename Mat, typename A_1>
+void
+ldlt_insert_rows_and_cols(Mat&& ld,
+                          isize pos,
+                          A_1 const& a_1,
+                          proxsuite::linalg::veg::dynstack::DynStackMut stack)
+{
+  _detail::ldlt_insert_rows_and_cols_impl(
+    util::to_view_dyn(ld), pos, util::to_view_dyn_rows(a_1), stack);
+}
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_MODIFY_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/dense/solve.hpp

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP
-
-#include "proxsuite/linalg/dense/core.hpp"
-#include <Eigen/Core>
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-namespace _detail {
-template<typename Mat, typename Rhs>
-void
-solve_impl(Mat ld, Rhs rhs)
-{
-  auto l = ld.template triangularView<Eigen::UnitLower>();
-  auto lt = util::trans(ld).template triangularView<Eigen::UnitUpper>();
-  auto d = util::diagonal(ld);
-
-  l.solveInPlace(rhs);
-  rhs = rhs.cwiseQuotient(d);
-  lt.solveInPlace(rhs);
-}
-} // namespace _detail
-template<typename Mat, typename Rhs>
-void
-solve(Mat const& mat, Rhs&& rhs)
-{
-  _detail::solve_impl(util::to_view(mat), util::to_view_dyn_rows(rhs));
-}
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP
+
+#include "proxsuite/linalg/dense/core.hpp"
+#include <Eigen/Core>
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+namespace _detail {
+template<typename Mat, typename Rhs>
+void
+solve_impl(Mat ld, Rhs rhs)
+{
+  auto l = ld.template triangularView<Eigen::UnitLower>();
+  auto lt = util::trans(ld).template triangularView<Eigen::UnitUpper>();
+  auto d = util::diagonal(ld);
+
+  l.solveInPlace(rhs);
+  rhs = rhs.cwiseQuotient(d);
+  lt.solveInPlace(rhs);
+}
+} // namespace _detail
+template<typename Mat, typename Rhs>
+void
+solve(Mat const& mat, Rhs&& rhs)
+{
+  _detail::solve_impl(util::to_view(mat), util::to_view_dyn_rows(rhs));
+}
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_SOLVE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/dense/update.hpp

 * *Ordering differences only*

```diff
@@ -1,330 +1,330 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP
-#define PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP
-
-#include "proxsuite/linalg/dense/core.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace dense {
-namespace _detail {
-inline auto
-bytes_to_prev_aligned(void* ptr, usize align) noexcept -> isize
-{
-  using UPtr = std::uintptr_t;
-
-  UPtr mask = align - 1;
-  UPtr iptr = UPtr(ptr);
-  UPtr aligned_ptr = iptr & ~mask;
-  return isize(aligned_ptr - iptr);
-}
-inline auto
-bytes_to_next_aligned(void* ptr, usize align) noexcept -> isize
-{
-  using UPtr = std::uintptr_t;
-
-  UPtr mask = align - 1;
-  UPtr iptr = UPtr(ptr);
-  UPtr aligned_ptr = (iptr + mask) & ~mask;
-  return isize(aligned_ptr - iptr);
-}
-
-template<usize... Is, typename Fn>
-VEG_INLINE void
-unroll_impl(proxsuite::linalg::veg::meta::index_sequence<Is...> /*unused*/,
-            Fn fn)
-{
-  VEG_EVAL_ALL(fn(Is));
-}
-
-template<usize N, typename Fn>
-VEG_INLINE void
-unroll(Fn fn)
-{
-  _detail::unroll_impl(proxsuite::linalg::veg::meta::make_index_sequence<N>{},
-                       VEG_FWD(fn));
-}
-
-template<typename T, usize N>
-struct RankUpdateLoadW
-{
-  _simd::Pack<T, N>* p_wr;
-  T const* pw;
-  isize w_stride;
-
-  VEG_INLINE void operator()(usize i) const
-  {
-    p_wr[i] = _simd::Pack<T, N>::load_unaligned(pw + w_stride * isize(i));
-  }
-};
-
-template<typename T, usize N>
-struct RankUpdateUpdateWAndL
-{
-  _simd::Pack<T, N>* p_wr;
-  _simd::Pack<T, N>& p_in_l;
-  _simd::Pack<T, N> const* p_p;
-  _simd::Pack<T, N> const* p_mu;
-
-  VEG_INLINE void operator()(usize i) const
-  {
-    p_wr[i] = _simd::Pack<T, N>::fnmadd(p_p[i], p_in_l, p_wr[i]);
-    p_in_l = _simd::Pack<T, N>::fmadd(p_mu[i], p_wr[i], p_in_l);
-  }
-};
-
-template<typename T, usize N>
-struct RankUpdateStoreW
-{
-  _simd::Pack<T, N> const* p_wr;
-  T* pw;
-  isize w_stride;
-
-  VEG_INLINE void operator()(usize i) const
-  {
-    p_wr[i].store_unaligned(pw + w_stride * isize(i));
-  }
-};
-
-template<usize R, typename T, usize N>
-VEG_INLINE void
-rank_r_update_inner_loop_iter( //
-  _simd::Pack<T, N> const* p_p,
-  _simd::Pack<T, N> const* p_mu,
-  T* inout_l,
-  T* pw,
-  isize w_stride)
-{
-
-  _simd::Pack<T, N> p_wr[R];
-  _detail::unroll<R>(RankUpdateLoadW<T, N>{ p_wr, pw, w_stride });
-  _simd::Pack<T, N> p_in_l = _simd::Pack<T, N>::load_unaligned(inout_l);
-  _detail::unroll<R>(RankUpdateUpdateWAndL<T, N>{ p_wr, p_in_l, p_p, p_mu });
-  _detail::unroll<R>(RankUpdateStoreW<T, N>{ p_wr, pw, w_stride });
-
-  p_in_l.store_unaligned(inout_l);
-}
-
-template<bool VECTORIZABLE>
-struct RankRUpdateLoopImpl;
-
-template<typename T, usize N>
-struct RankUpdateLoadPMu
-{
-  _simd::Pack<T, N>* p_p;
-  _simd::Pack<T, N>* p_mu;
-  T const* p;
-  T const* mu;
-  VEG_INLINE void operator()(usize i) const
-  {
-    p_p[i] = _simd::Pack<T, N>::broadcast(p[i]);
-    p_mu[i] = _simd::Pack<T, N>::broadcast(mu[i]);
-  }
-};
-
-template<>
-struct RankRUpdateLoopImpl<false>
-{
-  template<usize R, typename T>
-  VEG_INLINE static void fn(isize n,
-                            T* inout_l,
-                            T* pw,
-                            isize w_stride,
-                            T const* p,
-                            T const* mu) noexcept
-  {
-    using Pack_ = _simd::Pack<T, 1>;
-    Pack_ p_p[R];
-    Pack_ p_mu[R];
-
-    _detail::unroll<R>(RankUpdateLoadPMu<T, 1>{ p_p, p_mu, p, mu });
-
-    auto inout_l_finish = inout_l + n;
-    while (inout_l < inout_l_finish) {
-      _detail::rank_r_update_inner_loop_iter<R>(
-        p_p, p_mu, inout_l, pw, w_stride);
-      ++inout_l;
-      ++pw;
-    }
-  }
-};
-
-template<>
-struct RankRUpdateLoopImpl<true>
-{
-  template<usize R, typename T>
-  VEG_INLINE static void fn(isize n,
-                            T* inout_l,
-                            T* pw,
-                            isize w_stride,
-                            T const* p,
-                            T const* mu) noexcept
-  {
-
-    // best perf if beginning of each pw is aligned
-    // should be enforced by the Ldlt class
-
-    using Info = _simd::NativePackInfo<T>;
-    constexpr usize N = Info::N;
-    auto inout_l_vectorized_end = inout_l + usize(n) / N * N;
-    auto inout_l_end = inout_l + usize(n);
-
-    {
-      using Pack = _simd::NativePack<T>;
-      Pack p_p[R];
-      Pack p_mu[R];
-
-      _detail::unroll<R>(RankUpdateLoadPMu<T, N>{ p_p, p_mu, p, mu });
-
-      while (inout_l < inout_l_vectorized_end) {
-        _detail::rank_r_update_inner_loop_iter<R>(
-          p_p, p_mu, inout_l, pw, w_stride);
-        inout_l += N;
-        pw += N;
-      }
-    }
-    {
-      using Pack_ = _simd::Pack<T, 1>;
-      Pack_ p_p[R];
-      Pack_ p_mu[R];
-
-      _detail::unroll<R>(RankUpdateLoadPMu<T, 1>{ p_p, p_mu, p, mu });
-
-      while (inout_l < inout_l_end) {
-        _detail::rank_r_update_inner_loop_iter<R>(
-          p_p, p_mu, inout_l, pw, w_stride);
-        ++inout_l;
-        ++pw;
-      }
-    }
-  }
-};
-
-template<usize R, typename T>
-VEG_INLINE void
-rank_r_update_inner_loop(isize n,
-                         T* inout_l,
-                         T* pw,
-                         isize w_stride,
-                         T const* p,
-                         T const* mu)
-{
-  RankRUpdateLoopImpl<should_vectorize<T>::value>::template fn<R>(
-    n, inout_l, pw, w_stride, p, mu);
-}
-
-template<typename LD, typename T, typename Fn>
-void
-rank_r_update_clobber_w_impl( //
-  LD ld,
-  T* pw,
-  isize w_stride,
-  T* palpha,
-  Fn r_fn)
-{
-  static_assert(LD::InnerStrideAtCompileTime == 1, ".");
-  static_assert(!bool(LD::IsRowMajor), ".");
-
-  isize n = ld.rows();
-
-  for (isize j = 0; j < n; ++j) {
-    isize r = r_fn();
-
-    isize r_done = 0;
-    if (!(r_done < r)) {
-      continue;
-    }
-
-    while (true) {
-      isize r_chunk = min2(isize(4), r - r_done);
-
-      T p_array[4];
-      T mu_array[4];
-
-      T dj = ld(j, j);
-      for (isize k = 0; k < r_chunk; ++k) {
-        auto& p = (+p_array)[k];
-        auto& mu = (+mu_array)[k];
-        auto& alpha = palpha[r_done + k];
-
-        p = pw[(r_done + k) * w_stride];
-        T new_dj = dj + (alpha * p) * p;
-        mu = (alpha * p) / new_dj;
-        alpha -= new_dj * (mu * mu);
-
-        dj = new_dj;
-      }
-      ld(j, j) = dj;
-
-      isize rem = n - j - 1;
-
-      using FnType = void (*)(isize, T*, T*, isize, T const*, T const*);
-      FnType fn_table[] = {
-        rank_r_update_inner_loop<1, T>,
-        rank_r_update_inner_loop<2, T>,
-        rank_r_update_inner_loop<3, T>,
-        rank_r_update_inner_loop<4, T>,
-      };
-
-      (*fn_table[r_chunk - 1])( //
-        rem,
-        util::matrix_elem_addr(ld, j + 1, j),
-        pw + 1 + r_done * w_stride,
-        w_stride,
-        p_array,
-        mu_array);
-
-      r_done += r_chunk;
-      if (!(r_done < r)) {
-        break;
-      }
-    }
-    ++pw;
-  }
-}
-struct ConstantR
-{
-  isize r;
-  VEG_INLINE auto operator()() const noexcept -> isize { return r; }
-};
-} // namespace _detail
-
-template<typename LD,
-         typename W,
-         typename T = typename proxsuite::linalg::veg::uncvref_t<LD>::Scalar>
-void
-rank_1_update_clobber_w(LD&& ld,
-                        W&& w,
-                        proxsuite::linalg::veg::DoNotDeduce<T> alpha)
-{
-  _detail::rank_r_update_clobber_w_impl( //
-    util::to_view_dyn(ld),
-    w.data(),
-    0,
-    proxsuite::linalg::veg::mem::addressof(alpha),
-    _detail::ConstantR{ 1 });
-}
-
-template<typename LD,
-         typename W,
-         typename A,
-         typename T = typename proxsuite::linalg::veg::uncvref_t<LD>::Scalar>
-void
-rank_r_update_clobber_inputs(LD&& ld, W&& w, A&& alpha)
-{
-  isize r = w.cols();
-  _detail::rank_r_update_clobber_w_impl( //
-    util::to_view_dyn(ld),
-    w.data(),
-    w.outerStride(),
-    alpha.data(),
-    _detail::ConstantR{ r });
-}
-} // namespace dense
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP
+#define PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP
+
+#include "proxsuite/linalg/dense/core.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace dense {
+namespace _detail {
+inline auto
+bytes_to_prev_aligned(void* ptr, usize align) noexcept -> isize
+{
+  using UPtr = std::uintptr_t;
+
+  UPtr mask = align - 1;
+  UPtr iptr = UPtr(ptr);
+  UPtr aligned_ptr = iptr & ~mask;
+  return isize(aligned_ptr - iptr);
+}
+inline auto
+bytes_to_next_aligned(void* ptr, usize align) noexcept -> isize
+{
+  using UPtr = std::uintptr_t;
+
+  UPtr mask = align - 1;
+  UPtr iptr = UPtr(ptr);
+  UPtr aligned_ptr = (iptr + mask) & ~mask;
+  return isize(aligned_ptr - iptr);
+}
+
+template<usize... Is, typename Fn>
+VEG_INLINE void
+unroll_impl(proxsuite::linalg::veg::meta::index_sequence<Is...> /*unused*/,
+            Fn fn)
+{
+  VEG_EVAL_ALL(fn(Is));
+}
+
+template<usize N, typename Fn>
+VEG_INLINE void
+unroll(Fn fn)
+{
+  _detail::unroll_impl(proxsuite::linalg::veg::meta::make_index_sequence<N>{},
+                       VEG_FWD(fn));
+}
+
+template<typename T, usize N>
+struct RankUpdateLoadW
+{
+  _simd::Pack<T, N>* p_wr;
+  T const* pw;
+  isize w_stride;
+
+  VEG_INLINE void operator()(usize i) const
+  {
+    p_wr[i] = _simd::Pack<T, N>::load_unaligned(pw + w_stride * isize(i));
+  }
+};
+
+template<typename T, usize N>
+struct RankUpdateUpdateWAndL
+{
+  _simd::Pack<T, N>* p_wr;
+  _simd::Pack<T, N>& p_in_l;
+  _simd::Pack<T, N> const* p_p;
+  _simd::Pack<T, N> const* p_mu;
+
+  VEG_INLINE void operator()(usize i) const
+  {
+    p_wr[i] = _simd::Pack<T, N>::fnmadd(p_p[i], p_in_l, p_wr[i]);
+    p_in_l = _simd::Pack<T, N>::fmadd(p_mu[i], p_wr[i], p_in_l);
+  }
+};
+
+template<typename T, usize N>
+struct RankUpdateStoreW
+{
+  _simd::Pack<T, N> const* p_wr;
+  T* pw;
+  isize w_stride;
+
+  VEG_INLINE void operator()(usize i) const
+  {
+    p_wr[i].store_unaligned(pw + w_stride * isize(i));
+  }
+};
+
+template<usize R, typename T, usize N>
+VEG_INLINE void
+rank_r_update_inner_loop_iter( //
+  _simd::Pack<T, N> const* p_p,
+  _simd::Pack<T, N> const* p_mu,
+  T* inout_l,
+  T* pw,
+  isize w_stride)
+{
+
+  _simd::Pack<T, N> p_wr[R];
+  _detail::unroll<R>(RankUpdateLoadW<T, N>{ p_wr, pw, w_stride });
+  _simd::Pack<T, N> p_in_l = _simd::Pack<T, N>::load_unaligned(inout_l);
+  _detail::unroll<R>(RankUpdateUpdateWAndL<T, N>{ p_wr, p_in_l, p_p, p_mu });
+  _detail::unroll<R>(RankUpdateStoreW<T, N>{ p_wr, pw, w_stride });
+
+  p_in_l.store_unaligned(inout_l);
+}
+
+template<bool VECTORIZABLE>
+struct RankRUpdateLoopImpl;
+
+template<typename T, usize N>
+struct RankUpdateLoadPMu
+{
+  _simd::Pack<T, N>* p_p;
+  _simd::Pack<T, N>* p_mu;
+  T const* p;
+  T const* mu;
+  VEG_INLINE void operator()(usize i) const
+  {
+    p_p[i] = _simd::Pack<T, N>::broadcast(p[i]);
+    p_mu[i] = _simd::Pack<T, N>::broadcast(mu[i]);
+  }
+};
+
+template<>
+struct RankRUpdateLoopImpl<false>
+{
+  template<usize R, typename T>
+  VEG_INLINE static void fn(isize n,
+                            T* inout_l,
+                            T* pw,
+                            isize w_stride,
+                            T const* p,
+                            T const* mu) noexcept
+  {
+    using Pack_ = _simd::Pack<T, 1>;
+    Pack_ p_p[R];
+    Pack_ p_mu[R];
+
+    _detail::unroll<R>(RankUpdateLoadPMu<T, 1>{ p_p, p_mu, p, mu });
+
+    auto inout_l_finish = inout_l + n;
+    while (inout_l < inout_l_finish) {
+      _detail::rank_r_update_inner_loop_iter<R>(
+        p_p, p_mu, inout_l, pw, w_stride);
+      ++inout_l;
+      ++pw;
+    }
+  }
+};
+
+template<>
+struct RankRUpdateLoopImpl<true>
+{
+  template<usize R, typename T>
+  VEG_INLINE static void fn(isize n,
+                            T* inout_l,
+                            T* pw,
+                            isize w_stride,
+                            T const* p,
+                            T const* mu) noexcept
+  {
+
+    // best perf if beginning of each pw is aligned
+    // should be enforced by the Ldlt class
+
+    using Info = _simd::NativePackInfo<T>;
+    constexpr usize N = Info::N;
+    auto inout_l_vectorized_end = inout_l + usize(n) / N * N;
+    auto inout_l_end = inout_l + usize(n);
+
+    {
+      using Pack = _simd::NativePack<T>;
+      Pack p_p[R];
+      Pack p_mu[R];
+
+      _detail::unroll<R>(RankUpdateLoadPMu<T, N>{ p_p, p_mu, p, mu });
+
+      while (inout_l < inout_l_vectorized_end) {
+        _detail::rank_r_update_inner_loop_iter<R>(
+          p_p, p_mu, inout_l, pw, w_stride);
+        inout_l += N;
+        pw += N;
+      }
+    }
+    {
+      using Pack_ = _simd::Pack<T, 1>;
+      Pack_ p_p[R];
+      Pack_ p_mu[R];
+
+      _detail::unroll<R>(RankUpdateLoadPMu<T, 1>{ p_p, p_mu, p, mu });
+
+      while (inout_l < inout_l_end) {
+        _detail::rank_r_update_inner_loop_iter<R>(
+          p_p, p_mu, inout_l, pw, w_stride);
+        ++inout_l;
+        ++pw;
+      }
+    }
+  }
+};
+
+template<usize R, typename T>
+VEG_INLINE void
+rank_r_update_inner_loop(isize n,
+                         T* inout_l,
+                         T* pw,
+                         isize w_stride,
+                         T const* p,
+                         T const* mu)
+{
+  RankRUpdateLoopImpl<should_vectorize<T>::value>::template fn<R>(
+    n, inout_l, pw, w_stride, p, mu);
+}
+
+template<typename LD, typename T, typename Fn>
+void
+rank_r_update_clobber_w_impl( //
+  LD ld,
+  T* pw,
+  isize w_stride,
+  T* palpha,
+  Fn r_fn)
+{
+  static_assert(LD::InnerStrideAtCompileTime == 1, ".");
+  static_assert(!bool(LD::IsRowMajor), ".");
+
+  isize n = ld.rows();
+
+  for (isize j = 0; j < n; ++j) {
+    isize r = r_fn();
+
+    isize r_done = 0;
+    if (!(r_done < r)) {
+      continue;
+    }
+
+    while (true) {
+      isize r_chunk = min2(isize(4), r - r_done);
+
+      T p_array[4];
+      T mu_array[4];
+
+      T dj = ld(j, j);
+      for (isize k = 0; k < r_chunk; ++k) {
+        auto& p = (+p_array)[k];
+        auto& mu = (+mu_array)[k];
+        auto& alpha = palpha[r_done + k];
+
+        p = pw[(r_done + k) * w_stride];
+        T new_dj = dj + (alpha * p) * p;
+        mu = (alpha * p) / new_dj;
+        alpha -= new_dj * (mu * mu);
+
+        dj = new_dj;
+      }
+      ld(j, j) = dj;
+
+      isize rem = n - j - 1;
+
+      using FnType = void (*)(isize, T*, T*, isize, T const*, T const*);
+      FnType fn_table[] = {
+        rank_r_update_inner_loop<1, T>,
+        rank_r_update_inner_loop<2, T>,
+        rank_r_update_inner_loop<3, T>,
+        rank_r_update_inner_loop<4, T>,
+      };
+
+      (*fn_table[r_chunk - 1])( //
+        rem,
+        util::matrix_elem_addr(ld, j + 1, j),
+        pw + 1 + r_done * w_stride,
+        w_stride,
+        p_array,
+        mu_array);
+
+      r_done += r_chunk;
+      if (!(r_done < r)) {
+        break;
+      }
+    }
+    ++pw;
+  }
+}
+struct ConstantR
+{
+  isize r;
+  VEG_INLINE auto operator()() const noexcept -> isize { return r; }
+};
+} // namespace _detail
+
+template<typename LD,
+         typename W,
+         typename T = typename proxsuite::linalg::veg::uncvref_t<LD>::Scalar>
+void
+rank_1_update_clobber_w(LD&& ld,
+                        W&& w,
+                        proxsuite::linalg::veg::DoNotDeduce<T> alpha)
+{
+  _detail::rank_r_update_clobber_w_impl( //
+    util::to_view_dyn(ld),
+    w.data(),
+    0,
+    proxsuite::linalg::veg::mem::addressof(alpha),
+    _detail::ConstantR{ 1 });
+}
+
+template<typename LD,
+         typename W,
+         typename A,
+         typename T = typename proxsuite::linalg::veg::uncvref_t<LD>::Scalar>
+void
+rank_r_update_clobber_inputs(LD&& ld, W&& w, A&& alpha)
+{
+  isize r = w.cols();
+  _detail::rank_r_update_clobber_w_impl( //
+    util::to_view_dyn(ld),
+    w.data(),
+    w.outerStride(),
+    alpha.data(),
+    _detail::ConstantR{ r });
+}
+} // namespace dense
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_DENSE_LDLT_UPDATE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/sparse/core.hpp

 * *Ordering differences only*

```diff
@@ -1,531 +1,531 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP
-#define PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP
-
-#include <proxsuite/linalg/veg/slice.hpp>
-#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
-#include <type_traits>
-#include <Eigen/SparseCore>
-
-#define SPARSE_LDLT_CONCEPT(...)                                               \
-  VEG_CONCEPT_MACRO(::proxsuite::linalg::sparse::concepts, __VA_ARGS__)
-#define SPARSE_LDLT_CHECK_CONCEPT(...)                                         \
-  VEG_CONCEPT_MACRO(::proxsuite::linalg::sparse::concepts, __VA_ARGS__)
-
-namespace proxsuite {
-namespace linalg {
-namespace sparse {
-using proxsuite::linalg::veg::dynstack::DynStackMut;
-using namespace proxsuite::linalg::veg::literals;
-
-using proxsuite::linalg::veg::isize;
-using proxsuite::linalg::veg::usize;
-
-using proxsuite::linalg::veg::Slice;
-using proxsuite::linalg::veg::SliceMut;
-
-using proxsuite::linalg::veg::mut;
-using proxsuite::linalg::veg::Ref;
-using proxsuite::linalg::veg::ref;
-using proxsuite::linalg::veg::RefMut;
-
-inline namespace tags {
-using proxsuite::linalg::veg::Unsafe;
-using proxsuite::linalg::veg::unsafe;
-
-using proxsuite::linalg::veg::from_raw_parts;
-using proxsuite::linalg::veg::FromRawParts;
-VEG_TAG(from_eigen, FromEigen);
-} // namespace tags
-
-namespace concepts {
-} // namespace concepts
-
-namespace _detail {
-template<typename I, bool = sizeof(I) < sizeof(int)>
-struct WrappingPlusType;
-
-template<typename I>
-struct WrappingPlusType<I, true>
-{
-  using Promoted = unsigned;
-};
-template<typename I>
-struct WrappingPlusType<I, false>
-{
-  using Promoted = typename std::make_unsigned<I>::type;
-};
-} // namespace _detail
-namespace util {
-namespace nb {
-struct wrapping_plus
-{
-  template<typename I>
-  auto operator()(I a, I b) const noexcept -> I
-  {
-    using U = typename _detail::WrappingPlusType<I>::Promoted;
-    return I(U(a) + U(b));
-  }
-};
-struct checked_non_negative_plus
-{
-  template<typename I>
-  auto operator()(I a, I b) const noexcept -> I
-  {
-    return (VEG_ASSERT(wrapping_plus{}(a, b) >= a), //
-            wrapping_plus{}(a, b));
-  }
-};
-
-struct wrapping_inc
-{
-  template<typename I>
-  auto operator()(RefMut<I> a) const noexcept -> I
-  {
-    return a.get() = wrapping_plus{}(a.get(), I(1));
-  }
-};
-struct wrapping_dec
-{
-  template<typename I>
-  auto operator()(RefMut<I> a) const noexcept -> I
-  {
-    return a.get() = wrapping_plus{}(a.get(), I(-1));
-  }
-};
-struct sign_extend
-{
-  template<typename I>
-  auto operator()(I a) const noexcept -> usize
-  {
-    return usize(isize(typename std::make_signed<I>::type(a)));
-  }
-};
-struct zero_extend
-{
-  template<typename I>
-  auto operator()(I a) const noexcept -> usize
-  {
-    return usize(typename std::make_unsigned<I>::type(a));
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(wrapping_plus);
-VEG_NIEBLOID(checked_non_negative_plus);
-VEG_NIEBLOID(wrapping_inc);
-VEG_NIEBLOID(wrapping_dec);
-VEG_NIEBLOID(sign_extend);
-VEG_NIEBLOID(zero_extend);
-} // namespace util
-
-template<typename T>
-struct DenseVecRef
-{
-  DenseVecRef() = default;
-  DenseVecRef(FromRawParts /*from_raw_parts*/,
-              T const* data,
-              isize len) noexcept
-    : _{ data, len }
-  {
-  }
-  template<typename V>
-  DenseVecRef(FromEigen /*from_eigen*/, V const& v) noexcept
-    : _{ v.data(), v.rows() }
-  {
-    static_assert(V::InnerStrideAtCompileTime == 1, ".");
-    static_assert(V::ColsAtCompileTime == 1, ".");
-  }
-
-  auto as_slice() const noexcept -> Slice<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      _.ptr,
-      _.size,
-    };
-  }
-  auto nrows() const noexcept -> isize { return _.size; }
-  auto ncols() const noexcept -> isize { return 1; }
-
-  auto to_eigen() const noexcept -> Eigen::Map<Eigen::Matrix<T, -1, 1> const>
-  {
-    return { _.ptr, _.size };
-  }
-
-private:
-  struct
-  {
-    T const* ptr;
-    isize size;
-  } _ = {};
-};
-
-template<typename T>
-struct DenseVecMut
-{
-  DenseVecMut() = default;
-  DenseVecMut(FromRawParts /*from_raw_parts*/, T* data, isize len) noexcept
-    : _{ data, len }
-  {
-  }
-  template<typename V>
-  DenseVecMut(FromEigen /*from_eigen*/, V&& v) noexcept
-    : _{ v.data(), v.rows() }
-  {
-    static_assert(
-      proxsuite::linalg::veg::uncvref_t<V>::InnerStrideAtCompileTime == 1, ".");
-    static_assert(proxsuite::linalg::veg::uncvref_t<V>::ColsAtCompileTime == 1,
-                  ".");
-  }
-
-  auto as_slice() const noexcept -> Slice<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      _.ptr,
-      _.size,
-    };
-  }
-  auto as_slice_mut() noexcept -> SliceMut<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      _.ptr,
-      _.size,
-    };
-  }
-
-  auto as_const() const noexcept -> DenseVecRef<T>
-  {
-    return { from_raw_parts, _.ptr, _.size };
-  }
-  auto nrows() const noexcept -> isize { return _.size; }
-  auto ncols() const noexcept -> isize { return 1; }
-
-  auto to_eigen() const noexcept -> Eigen::Map<Eigen::Matrix<T, -1, 1>>
-  {
-    return { _.ptr, _.size };
-  }
-
-private:
-  struct
-  {
-    T* ptr;
-    isize size;
-  } _ = {};
-};
-
-template<typename T, typename I = isize>
-struct VecRef
-{
-  VecRef( //
-    FromRawParts /*from_raw_parts*/,
-    isize nrows,
-    isize nnz,
-    I const* row_indices,
-    T const* values)
-    : _{ nrows, nnz, row_indices, values }
-  {
-  }
-
-  auto nrows() const noexcept -> isize { return _.nrows; }
-  auto ncols() const noexcept -> isize { return 1; }
-  auto nnz() const noexcept -> isize { return _.nnz; }
-
-  auto row_indices() const noexcept -> I const* { return _.row; }
-  auto values() const noexcept -> T const* { return _.val; }
-
-private:
-  struct
-  {
-    isize nrows;
-    isize nnz;
-    I const* row;
-    T const* val;
-  } _;
-};
-
-namespace _detail {
-template<typename D, typename I>
-struct SymbolicMatRefInterface
-{
-private:
-  template<typename U = D>
-  auto _() const noexcept -> decltype((VEG_DECLVAL(U const&)._))
-  {
-    return static_cast<D const*>(this)->_;
-  }
-
-public:
-  auto nrows() const noexcept -> isize { return _().nrows; }
-  auto ncols() const noexcept -> isize { return _().ncols; }
-  auto nnz() const noexcept -> isize { return _().nnz; }
-
-  auto col_ptrs() const noexcept -> I const* { return _().col; }
-  auto nnz_per_col() const noexcept -> I const* { return _().nnz_per_col; }
-  auto is_compressed() const noexcept -> bool
-  {
-    return nnz_per_col() == nullptr;
-  }
-
-  auto row_indices() const noexcept -> I const* { return _().row; }
-
-  auto col_start(usize j) const noexcept -> usize
-  {
-    return VEG_ASSERT(j < usize(ncols())), util::zero_extend(_().col[j]);
-  }
-  auto col_start_unchecked(Unsafe /*unsafe*/, usize j) const noexcept -> usize
-  {
-    return VEG_DEBUG_ASSERT(j < usize(ncols())), util::zero_extend(_().col[j]);
-  }
-  auto col_end(usize j) const noexcept -> usize
-  {
-    return VEG_ASSERT(j < usize(ncols())), col_end_unchecked(unsafe, j);
-  }
-  auto col_end_unchecked(Unsafe /*unsafe*/, usize j) const noexcept -> usize
-  {
-    return VEG_DEBUG_ASSERT(j < usize(ncols())),
-           util::zero_extend(is_compressed()
-                               ? _().col[j + 1]
-                               : I(_().col[j] + _().nnz_per_col[j]));
-  }
-};
-template<typename D, typename I>
-struct SymbolicMatMutInterface : SymbolicMatRefInterface<D, I>
-{
-private:
-  template<typename U = D>
-  auto _() noexcept -> decltype((VEG_DECLVAL(U&)._))
-  {
-    return static_cast<D*>(this)->_;
-  }
-
-public:
-  auto col_ptrs_mut() noexcept -> I* { return _().col; }
-  auto nnz_per_col_mut() noexcept -> I* { return _().nnz_per_col; }
-  auto row_indices_mut() noexcept -> I* { return _().row; }
-};
-} // namespace _detail
-
-template<typename I = isize>
-struct SymbolicMatRef : _detail::SymbolicMatRefInterface<SymbolicMatRef<I>, I>
-{
-  friend struct _detail::SymbolicMatRefInterface<SymbolicMatRef, I>;
-  SymbolicMatRef(FromRawParts /*from_raw_parts*/,
-                 isize nrows,
-                 isize ncols,
-                 isize nnz,
-                 I const* col_ptrs,
-                 I const* nnz_per_col,
-                 I const* row_indices)
-    : _{
-      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices,
-    }
-  {
-  }
-
-private:
-  struct
-  {
-    isize nrows;
-    isize ncols;
-    isize nnz;
-    I const* col;
-    I const* nnz_per_col;
-    I const* row;
-  } _;
-};
-template<typename I = isize>
-struct SymbolicMatMut : _detail::SymbolicMatMutInterface<SymbolicMatMut<I>, I>
-{
-  friend struct _detail::SymbolicMatRefInterface<SymbolicMatMut, I>;
-  friend struct _detail::SymbolicMatMutInterface<SymbolicMatMut, I>;
-  SymbolicMatMut(FromRawParts /*from_raw_parts*/,
-                 isize nrows,
-                 isize ncols,
-                 isize nnz,
-                 I* col_ptrs,
-                 I* nnz_per_col,
-                 I* row_indices)
-    : _{
-      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices,
-    }
-  {
-  }
-
-  auto as_const() const noexcept -> SymbolicMatRef<I>
-  {
-    return {
-      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
-      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
-    };
-  }
-
-private:
-  struct
-  {
-    isize nrows;
-    isize ncols;
-    isize nnz;
-    I* col;
-    I* nnz_per_col;
-    I* row;
-  } _;
-};
-
-template<typename T, typename I = isize>
-struct MatRef : _detail::SymbolicMatRefInterface<MatRef<T, I>, I>
-{
-  friend struct _detail::SymbolicMatRefInterface<MatRef, I>;
-  MatRef(FromRawParts /*from_raw_parts*/,
-         isize nrows,
-         isize ncols,
-         isize nnz,
-         I const* col_ptrs,
-         I const* nnz_per_col,
-         I const* row_indices,
-         T const* values)
-    : _{
-      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices, values,
-    }
-  {
-  }
-
-  template<typename M>
-  MatRef(FromEigen /*from_eigen*/, M const& m)
-    : _{
-      m.rows(),
-      m.cols(),
-      m.nonZeros(),
-      m.outerIndexPtr(),
-      m.innerNonZeroPtr(),
-      m.innerIndexPtr(),
-      m.valuePtr(),
-    }
-  {
-    static_assert(!bool(M::IsRowMajor), ".");
-  }
-
-  auto values() const noexcept -> T const* { return _.val; }
-  auto symbolic() const noexcept -> SymbolicMatRef<I>
-  {
-    return {
-      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
-      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
-    };
-  }
-
-  auto to_eigen() const noexcept
-    -> Eigen::Map<Eigen::SparseMatrix<T, Eigen::ColMajor, I> const>
-  {
-    return { _.nrows, _.ncols, _.nnz, _.col, _.row, _.val, _.nnz_per_col };
-  }
-
-private:
-  struct
-  {
-    isize nrows;
-    isize ncols;
-    isize nnz;
-    I const* col;
-    I const* nnz_per_col;
-    I const* row;
-    T const* val;
-  } _;
-};
-
-template<typename T, typename I = isize>
-struct MatMut : _detail::SymbolicMatMutInterface<MatMut<T, I>, I>
-{
-  friend struct _detail::SymbolicMatRefInterface<MatMut, I>;
-  friend struct _detail::SymbolicMatMutInterface<MatMut, I>;
-  MatMut(FromRawParts /*from_raw_parts*/,
-         isize nrows,
-         isize ncols,
-         isize nnz,
-         I* col_ptrs,
-         I* nnz_per_col,
-         I* row_indices,
-         T* values)
-    : _{
-      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices, values,
-    }
-  {
-  }
-
-  template<typename M>
-  MatMut(FromEigen /*from_eigen*/, M&& m)
-    : _{
-      m.rows(),
-      m.cols(),
-      m.nonZeros(),
-      m.outerIndexPtr(),
-      m.innerNonZeroPtr(),
-      m.innerIndexPtr(),
-      m.valuePtr(),
-    }
-  {
-    static_assert(!bool(proxsuite::linalg::veg::uncvref_t<M>::IsRowMajor), ".");
-  }
-
-  auto values() const noexcept -> T const* { return _.val; }
-  auto values_mut() const noexcept -> T* { return _.val; }
-  auto is_compressed() const noexcept -> bool
-  {
-    return _.nnz_per_col == nullptr;
-  }
-
-  auto as_const() const noexcept -> MatRef<T, I>
-  {
-    return {
-      from_raw_parts,      this->nrows(),    this->ncols(),
-      this->nnz(),         this->col_ptrs(), this->nnz_per_col(),
-      this->row_indices(), this->values(),
-    };
-  }
-  auto symbolic() const noexcept -> SymbolicMatRef<I>
-  {
-    return {
-      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
-      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
-    };
-  }
-  auto symbolic_mut() const noexcept -> SymbolicMatRef<I>
-  {
-    return {
-      from_raw_parts,          this->nrows(),
-      this->ncols(),           this->nnz(),
-      this->col_ptrs_mut(),    this->nnz_per_col_mut(),
-      this->row_indices_mut(),
-    };
-  }
-  auto to_eigen() const noexcept
-    -> Eigen::Map<Eigen::SparseMatrix<T, Eigen::ColMajor, I>>
-  {
-    return { _.nrows, _.ncols, _.nnz, _.col, _.row, _.val, _.nnz_per_col };
-  }
-  void _set_nnz(isize new_nnz) noexcept { _.nnz = new_nnz; }
-
-private:
-  struct
-  {
-    isize nrows;
-    isize ncols;
-    isize nnz;
-    I* col;
-    I* nnz_per_col;
-    I* row;
-    T* val;
-  } _;
-};
-} // namespace sparse
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP
+#define PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP
+
+#include <proxsuite/linalg/veg/slice.hpp>
+#include <proxsuite/linalg/veg/memory/dynamic_stack.hpp>
+#include <type_traits>
+#include <Eigen/SparseCore>
+
+#define SPARSE_LDLT_CONCEPT(...)                                               \
+  VEG_CONCEPT_MACRO(::proxsuite::linalg::sparse::concepts, __VA_ARGS__)
+#define SPARSE_LDLT_CHECK_CONCEPT(...)                                         \
+  VEG_CONCEPT_MACRO(::proxsuite::linalg::sparse::concepts, __VA_ARGS__)
+
+namespace proxsuite {
+namespace linalg {
+namespace sparse {
+using proxsuite::linalg::veg::dynstack::DynStackMut;
+using namespace proxsuite::linalg::veg::literals;
+
+using proxsuite::linalg::veg::isize;
+using proxsuite::linalg::veg::usize;
+
+using proxsuite::linalg::veg::Slice;
+using proxsuite::linalg::veg::SliceMut;
+
+using proxsuite::linalg::veg::mut;
+using proxsuite::linalg::veg::Ref;
+using proxsuite::linalg::veg::ref;
+using proxsuite::linalg::veg::RefMut;
+
+inline namespace tags {
+using proxsuite::linalg::veg::Unsafe;
+using proxsuite::linalg::veg::unsafe;
+
+using proxsuite::linalg::veg::from_raw_parts;
+using proxsuite::linalg::veg::FromRawParts;
+VEG_TAG(from_eigen, FromEigen);
+} // namespace tags
+
+namespace concepts {
+} // namespace concepts
+
+namespace _detail {
+template<typename I, bool = sizeof(I) < sizeof(int)>
+struct WrappingPlusType;
+
+template<typename I>
+struct WrappingPlusType<I, true>
+{
+  using Promoted = unsigned;
+};
+template<typename I>
+struct WrappingPlusType<I, false>
+{
+  using Promoted = typename std::make_unsigned<I>::type;
+};
+} // namespace _detail
+namespace util {
+namespace nb {
+struct wrapping_plus
+{
+  template<typename I>
+  auto operator()(I a, I b) const noexcept -> I
+  {
+    using U = typename _detail::WrappingPlusType<I>::Promoted;
+    return I(U(a) + U(b));
+  }
+};
+struct checked_non_negative_plus
+{
+  template<typename I>
+  auto operator()(I a, I b) const noexcept -> I
+  {
+    return (VEG_ASSERT(wrapping_plus{}(a, b) >= a), //
+            wrapping_plus{}(a, b));
+  }
+};
+
+struct wrapping_inc
+{
+  template<typename I>
+  auto operator()(RefMut<I> a) const noexcept -> I
+  {
+    return a.get() = wrapping_plus{}(a.get(), I(1));
+  }
+};
+struct wrapping_dec
+{
+  template<typename I>
+  auto operator()(RefMut<I> a) const noexcept -> I
+  {
+    return a.get() = wrapping_plus{}(a.get(), I(-1));
+  }
+};
+struct sign_extend
+{
+  template<typename I>
+  auto operator()(I a) const noexcept -> usize
+  {
+    return usize(isize(typename std::make_signed<I>::type(a)));
+  }
+};
+struct zero_extend
+{
+  template<typename I>
+  auto operator()(I a) const noexcept -> usize
+  {
+    return usize(typename std::make_unsigned<I>::type(a));
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(wrapping_plus);
+VEG_NIEBLOID(checked_non_negative_plus);
+VEG_NIEBLOID(wrapping_inc);
+VEG_NIEBLOID(wrapping_dec);
+VEG_NIEBLOID(sign_extend);
+VEG_NIEBLOID(zero_extend);
+} // namespace util
+
+template<typename T>
+struct DenseVecRef
+{
+  DenseVecRef() = default;
+  DenseVecRef(FromRawParts /*from_raw_parts*/,
+              T const* data,
+              isize len) noexcept
+    : _{ data, len }
+  {
+  }
+  template<typename V>
+  DenseVecRef(FromEigen /*from_eigen*/, V const& v) noexcept
+    : _{ v.data(), v.rows() }
+  {
+    static_assert(V::InnerStrideAtCompileTime == 1, ".");
+    static_assert(V::ColsAtCompileTime == 1, ".");
+  }
+
+  auto as_slice() const noexcept -> Slice<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      _.ptr,
+      _.size,
+    };
+  }
+  auto nrows() const noexcept -> isize { return _.size; }
+  auto ncols() const noexcept -> isize { return 1; }
+
+  auto to_eigen() const noexcept -> Eigen::Map<Eigen::Matrix<T, -1, 1> const>
+  {
+    return { _.ptr, _.size };
+  }
+
+private:
+  struct
+  {
+    T const* ptr;
+    isize size;
+  } _ = {};
+};
+
+template<typename T>
+struct DenseVecMut
+{
+  DenseVecMut() = default;
+  DenseVecMut(FromRawParts /*from_raw_parts*/, T* data, isize len) noexcept
+    : _{ data, len }
+  {
+  }
+  template<typename V>
+  DenseVecMut(FromEigen /*from_eigen*/, V&& v) noexcept
+    : _{ v.data(), v.rows() }
+  {
+    static_assert(
+      proxsuite::linalg::veg::uncvref_t<V>::InnerStrideAtCompileTime == 1, ".");
+    static_assert(proxsuite::linalg::veg::uncvref_t<V>::ColsAtCompileTime == 1,
+                  ".");
+  }
+
+  auto as_slice() const noexcept -> Slice<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      _.ptr,
+      _.size,
+    };
+  }
+  auto as_slice_mut() noexcept -> SliceMut<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      _.ptr,
+      _.size,
+    };
+  }
+
+  auto as_const() const noexcept -> DenseVecRef<T>
+  {
+    return { from_raw_parts, _.ptr, _.size };
+  }
+  auto nrows() const noexcept -> isize { return _.size; }
+  auto ncols() const noexcept -> isize { return 1; }
+
+  auto to_eigen() const noexcept -> Eigen::Map<Eigen::Matrix<T, -1, 1>>
+  {
+    return { _.ptr, _.size };
+  }
+
+private:
+  struct
+  {
+    T* ptr;
+    isize size;
+  } _ = {};
+};
+
+template<typename T, typename I = isize>
+struct VecRef
+{
+  VecRef( //
+    FromRawParts /*from_raw_parts*/,
+    isize nrows,
+    isize nnz,
+    I const* row_indices,
+    T const* values)
+    : _{ nrows, nnz, row_indices, values }
+  {
+  }
+
+  auto nrows() const noexcept -> isize { return _.nrows; }
+  auto ncols() const noexcept -> isize { return 1; }
+  auto nnz() const noexcept -> isize { return _.nnz; }
+
+  auto row_indices() const noexcept -> I const* { return _.row; }
+  auto values() const noexcept -> T const* { return _.val; }
+
+private:
+  struct
+  {
+    isize nrows;
+    isize nnz;
+    I const* row;
+    T const* val;
+  } _;
+};
+
+namespace _detail {
+template<typename D, typename I>
+struct SymbolicMatRefInterface
+{
+private:
+  template<typename U = D>
+  auto _() const noexcept -> decltype((VEG_DECLVAL(U const&)._))
+  {
+    return static_cast<D const*>(this)->_;
+  }
+
+public:
+  auto nrows() const noexcept -> isize { return _().nrows; }
+  auto ncols() const noexcept -> isize { return _().ncols; }
+  auto nnz() const noexcept -> isize { return _().nnz; }
+
+  auto col_ptrs() const noexcept -> I const* { return _().col; }
+  auto nnz_per_col() const noexcept -> I const* { return _().nnz_per_col; }
+  auto is_compressed() const noexcept -> bool
+  {
+    return nnz_per_col() == nullptr;
+  }
+
+  auto row_indices() const noexcept -> I const* { return _().row; }
+
+  auto col_start(usize j) const noexcept -> usize
+  {
+    return VEG_ASSERT(j < usize(ncols())), util::zero_extend(_().col[j]);
+  }
+  auto col_start_unchecked(Unsafe /*unsafe*/, usize j) const noexcept -> usize
+  {
+    return VEG_DEBUG_ASSERT(j < usize(ncols())), util::zero_extend(_().col[j]);
+  }
+  auto col_end(usize j) const noexcept -> usize
+  {
+    return VEG_ASSERT(j < usize(ncols())), col_end_unchecked(unsafe, j);
+  }
+  auto col_end_unchecked(Unsafe /*unsafe*/, usize j) const noexcept -> usize
+  {
+    return VEG_DEBUG_ASSERT(j < usize(ncols())),
+           util::zero_extend(is_compressed()
+                               ? _().col[j + 1]
+                               : I(_().col[j] + _().nnz_per_col[j]));
+  }
+};
+template<typename D, typename I>
+struct SymbolicMatMutInterface : SymbolicMatRefInterface<D, I>
+{
+private:
+  template<typename U = D>
+  auto _() noexcept -> decltype((VEG_DECLVAL(U&)._))
+  {
+    return static_cast<D*>(this)->_;
+  }
+
+public:
+  auto col_ptrs_mut() noexcept -> I* { return _().col; }
+  auto nnz_per_col_mut() noexcept -> I* { return _().nnz_per_col; }
+  auto row_indices_mut() noexcept -> I* { return _().row; }
+};
+} // namespace _detail
+
+template<typename I = isize>
+struct SymbolicMatRef : _detail::SymbolicMatRefInterface<SymbolicMatRef<I>, I>
+{
+  friend struct _detail::SymbolicMatRefInterface<SymbolicMatRef, I>;
+  SymbolicMatRef(FromRawParts /*from_raw_parts*/,
+                 isize nrows,
+                 isize ncols,
+                 isize nnz,
+                 I const* col_ptrs,
+                 I const* nnz_per_col,
+                 I const* row_indices)
+    : _{
+      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices,
+    }
+  {
+  }
+
+private:
+  struct
+  {
+    isize nrows;
+    isize ncols;
+    isize nnz;
+    I const* col;
+    I const* nnz_per_col;
+    I const* row;
+  } _;
+};
+template<typename I = isize>
+struct SymbolicMatMut : _detail::SymbolicMatMutInterface<SymbolicMatMut<I>, I>
+{
+  friend struct _detail::SymbolicMatRefInterface<SymbolicMatMut, I>;
+  friend struct _detail::SymbolicMatMutInterface<SymbolicMatMut, I>;
+  SymbolicMatMut(FromRawParts /*from_raw_parts*/,
+                 isize nrows,
+                 isize ncols,
+                 isize nnz,
+                 I* col_ptrs,
+                 I* nnz_per_col,
+                 I* row_indices)
+    : _{
+      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices,
+    }
+  {
+  }
+
+  auto as_const() const noexcept -> SymbolicMatRef<I>
+  {
+    return {
+      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
+      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
+    };
+  }
+
+private:
+  struct
+  {
+    isize nrows;
+    isize ncols;
+    isize nnz;
+    I* col;
+    I* nnz_per_col;
+    I* row;
+  } _;
+};
+
+template<typename T, typename I = isize>
+struct MatRef : _detail::SymbolicMatRefInterface<MatRef<T, I>, I>
+{
+  friend struct _detail::SymbolicMatRefInterface<MatRef, I>;
+  MatRef(FromRawParts /*from_raw_parts*/,
+         isize nrows,
+         isize ncols,
+         isize nnz,
+         I const* col_ptrs,
+         I const* nnz_per_col,
+         I const* row_indices,
+         T const* values)
+    : _{
+      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices, values,
+    }
+  {
+  }
+
+  template<typename M>
+  MatRef(FromEigen /*from_eigen*/, M const& m)
+    : _{
+      m.rows(),
+      m.cols(),
+      m.nonZeros(),
+      m.outerIndexPtr(),
+      m.innerNonZeroPtr(),
+      m.innerIndexPtr(),
+      m.valuePtr(),
+    }
+  {
+    static_assert(!bool(M::IsRowMajor), ".");
+  }
+
+  auto values() const noexcept -> T const* { return _.val; }
+  auto symbolic() const noexcept -> SymbolicMatRef<I>
+  {
+    return {
+      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
+      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
+    };
+  }
+
+  auto to_eigen() const noexcept
+    -> Eigen::Map<Eigen::SparseMatrix<T, Eigen::ColMajor, I> const>
+  {
+    return { _.nrows, _.ncols, _.nnz, _.col, _.row, _.val, _.nnz_per_col };
+  }
+
+private:
+  struct
+  {
+    isize nrows;
+    isize ncols;
+    isize nnz;
+    I const* col;
+    I const* nnz_per_col;
+    I const* row;
+    T const* val;
+  } _;
+};
+
+template<typename T, typename I = isize>
+struct MatMut : _detail::SymbolicMatMutInterface<MatMut<T, I>, I>
+{
+  friend struct _detail::SymbolicMatRefInterface<MatMut, I>;
+  friend struct _detail::SymbolicMatMutInterface<MatMut, I>;
+  MatMut(FromRawParts /*from_raw_parts*/,
+         isize nrows,
+         isize ncols,
+         isize nnz,
+         I* col_ptrs,
+         I* nnz_per_col,
+         I* row_indices,
+         T* values)
+    : _{
+      nrows, ncols, nnz, col_ptrs, nnz_per_col, row_indices, values,
+    }
+  {
+  }
+
+  template<typename M>
+  MatMut(FromEigen /*from_eigen*/, M&& m)
+    : _{
+      m.rows(),
+      m.cols(),
+      m.nonZeros(),
+      m.outerIndexPtr(),
+      m.innerNonZeroPtr(),
+      m.innerIndexPtr(),
+      m.valuePtr(),
+    }
+  {
+    static_assert(!bool(proxsuite::linalg::veg::uncvref_t<M>::IsRowMajor), ".");
+  }
+
+  auto values() const noexcept -> T const* { return _.val; }
+  auto values_mut() const noexcept -> T* { return _.val; }
+  auto is_compressed() const noexcept -> bool
+  {
+    return _.nnz_per_col == nullptr;
+  }
+
+  auto as_const() const noexcept -> MatRef<T, I>
+  {
+    return {
+      from_raw_parts,      this->nrows(),    this->ncols(),
+      this->nnz(),         this->col_ptrs(), this->nnz_per_col(),
+      this->row_indices(), this->values(),
+    };
+  }
+  auto symbolic() const noexcept -> SymbolicMatRef<I>
+  {
+    return {
+      from_raw_parts,   this->nrows(),       this->ncols(),       this->nnz(),
+      this->col_ptrs(), this->nnz_per_col(), this->row_indices(),
+    };
+  }
+  auto symbolic_mut() const noexcept -> SymbolicMatRef<I>
+  {
+    return {
+      from_raw_parts,          this->nrows(),
+      this->ncols(),           this->nnz(),
+      this->col_ptrs_mut(),    this->nnz_per_col_mut(),
+      this->row_indices_mut(),
+    };
+  }
+  auto to_eigen() const noexcept
+    -> Eigen::Map<Eigen::SparseMatrix<T, Eigen::ColMajor, I>>
+  {
+    return { _.nrows, _.ncols, _.nnz, _.col, _.row, _.val, _.nnz_per_col };
+  }
+  void _set_nnz(isize new_nnz) noexcept { _.nnz = new_nnz; }
+
+private:
+  struct
+  {
+    isize nrows;
+    isize ncols;
+    isize nnz;
+    I* col;
+    I* nnz_per_col;
+    I* row;
+    T* val;
+  } _;
+};
+} // namespace sparse
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_CORE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/sparse/factorize.hpp

 * *Ordering differences only*

```diff
@@ -1,1303 +1,1303 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP
-#define PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP
-
-#include "proxsuite/linalg/sparse/core.hpp"
-#include <Eigen/OrderingMethods>
-
-namespace proxsuite {
-namespace linalg {
-namespace sparse {
-
-template<typename I>
-auto
-transpose_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize nrows) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { nrows * isize(sizeof(I)), isize(alignof(I)) };
-}
-
-// at = a.T
-template<typename T, typename I>
-void
-transpose( //
-  MatMut<T, I> at,
-  MatRef<T, I> a,
-  DynStackMut stack) noexcept(VEG_CONCEPT(nothrow_copyable<T>))
-{
-  using namespace _detail;
-
-  VEG_ASSERT_ALL_OF( //
-    at.is_compressed(),
-    at.nrows() == a.ncols(),
-    at.ncols() == a.nrows(),
-    at.nnz() == a.nnz());
-
-  auto pai = a.row_indices();
-  auto pax = a.values();
-
-  auto patp = at.col_ptrs_mut();
-  auto pati = at.row_indices_mut();
-  auto patx = at.values_mut();
-
-  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, at.ncols());
-  auto work = _work.ptr_mut();
-
-  // work[i] = num zeros in ith row of A
-  if (a.is_compressed()) {
-    for (usize p = 0; p < usize(a.nnz()); ++p) {
-      util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
-    }
-  } else {
-    for (usize j = 0; j < a.ncols(); ++j) {
-      isize col_start = a.col_start(j);
-      isize col_end = a.col_end(j);
-      for (isize p = col_start; p < col_end; ++p) {
-        util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
-      }
-    }
-  }
-
-  // compute the cumulative sum
-  for (usize j = 0; j < usize(at.ncols()); ++j) {
-    patp[j + 1] = util::checked_non_negative_plus(patp[j], work[j]);
-    work[j] = patp[j];
-  }
-
-  for (usize j = 0; j < usize(a.ncols()); ++j) {
-    auto col_start = a.col_start(j);
-    auto col_end = a.col_end(j);
-    for (usize p = col_start; p < col_end; ++p) {
-      auto i = util::zero_extend(pai[p]);
-      auto q = util::zero_extend(work[i]);
-
-      pati[q] = j;
-      patx[q] = pax[p];
-      util::wrapping_inc(mut(work[i]));
-    }
-  }
-}
-
-template<typename I>
-auto
-transpose_symbolic_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
-                       isize nrows) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { nrows * isize(sizeof(I)), isize(alignof(I)) };
-}
-
-template<typename I>
-void
-transpose_symbolic( //
-  SymbolicMatMut<I> at,
-  SymbolicMatRef<I> a,
-  DynStackMut stack) noexcept
-{
-  using namespace _detail;
-
-  VEG_ASSERT_ALL_OF( //
-    at.is_compressed(),
-    at.nrows() == a.ncols(),
-    at.ncols() == a.nrows(),
-    at.nnz() == a.nnz());
-
-  auto pai = a.row_indices();
-
-  auto patp = at.col_ptrs_mut();
-  auto pati = at.row_indices_mut();
-
-  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, at.ncols());
-  auto work = _work.ptr_mut();
-
-  // work[i] = num zeros in ith row of A
-  for (usize p = 0; p < usize(a.nnz()); ++p) {
-    util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
-  }
-
-  // compute the cumulative sum
-  for (usize j = 0; j < usize(at.ncols()); ++j) {
-    patp[j + 1] = util::checked_non_negative_plus(patp[j], work[j]);
-    work[j] = patp[j];
-  }
-
-  for (usize j = 0; j < usize(a.ncols()); ++j) {
-    auto col_start = a.col_start(j);
-    auto col_end = a.col_end(j);
-    for (usize p = col_start; p < col_end; ++p) {
-      auto i = util::zero_extend(pai[p]);
-      auto q = util::zero_extend(work[i]);
-
-      pati[q] = I(j);
-      util::wrapping_inc(mut(work[i]));
-    }
-  }
-}
-
-/*!
- * `l` is unit lower triangular whose diagonal elements are ignored.
- * Solves `l×y = x` and store the solution in `x`.
- *
- * @param x RHS of the system, solution storage.
- * @param l matrix to be inverted.
- */
-template<typename T, typename I>
-void
-dense_lsolve(DenseVecMut<T> x, MatRef<T, I> l) noexcept(false)
-{
-  using namespace _detail;
-
-  VEG_ASSERT_ALL_OF( //
-    l.nrows() == l.ncols(),
-    x.nrows() == l.nrows()
-    /* l is unit lower triangular */
-  );
-
-  usize n = usize(l.nrows());
-
-  auto pli = l.row_indices();
-  auto plx = l.values();
-
-  auto px = x.as_slice_mut().ptr_mut();
-
-  for (usize j = 0; j < n; ++j) {
-    auto const xj = px[j];
-    auto col_start = l.col_start(j);
-    auto col_end = l.col_end(j);
-
-    // skip the diagonal entry
-    for (usize p = col_start + 1; p < col_end; ++p) {
-      auto i = util::zero_extend(pli[p]);
-      px[i] -= plx[p] * xj;
-    }
-  }
-}
-
-/*!
- * `l` is unit lower triangular whose diagonal elements are ignored.
- * Solves `l.T×y = x` and store the solution in `x`.
- *
- * @param x RHS of the system, solution storage.
- * @param l matrix to be inverted.
- */
-template<typename T, typename I>
-void
-dense_ltsolve(DenseVecMut<T> x, MatRef<T, I> l) noexcept(false)
-{
-  using namespace _detail;
-
-  VEG_ASSERT_ALL_OF( //
-    l.nrows() == l.ncols(),
-    x.nrows() == l.nrows()
-    /* l is unit lower triangular */
-  );
-
-  usize n = usize(l.nrows());
-
-  auto pli = l.row_indices();
-  auto plx = l.values();
-
-  auto px = x.as_slice_mut().ptr_mut();
-
-  usize j = n;
-  while (true) {
-    if (j == 0) {
-      break;
-    }
-    --j;
-
-    auto col_start = l.col_start(j);
-    auto col_end = l.col_end(j);
-    T acc0 = 0;
-    T acc1 = 0;
-    T acc2 = 0;
-    T acc3 = 0;
-
-    // skip the diagonal entry
-    usize pstart = col_start + 1;
-    usize pcount = col_end - pstart;
-
-    usize p = pstart;
-    for (; p < pstart + pcount / 4 * 4; p += 4) {
-      auto i0 = util::zero_extend(pli[p + 0]);
-      auto i1 = util::zero_extend(pli[p + 1]);
-      auto i2 = util::zero_extend(pli[p + 2]);
-      auto i3 = util::zero_extend(pli[p + 3]);
-      acc0 += plx[p + 0] * px[i0];
-      acc1 += plx[p + 1] * px[i1];
-      acc2 += plx[p + 2] * px[i2];
-      acc3 += plx[p + 3] * px[i3];
-    }
-    for (; p < pstart + pcount; ++p) {
-      auto i0 = util::zero_extend(pli[p + 0]);
-      acc0 += plx[p + 0] * px[i0];
-    }
-
-    acc0 = (acc0 + acc1) + (acc2 + acc3);
-
-    px[j] -= acc0;
-  }
-}
-
-/*!
- * Computes the stack memory requirements of etree computation.
- *
- * @param n dimension of the matrix.
- */
-template<typename I>
-auto
-etree_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { n * isize{ sizeof(I) }, alignof(I) };
-}
-
-/*!
- * Computes the elimination tree of the cholesky factor  of `a` of size `n`.
- * `a` is considered symmetric but should only contain terms from the upper
- * triangular part.
- *
- * @param parent pointer to the elimination tree storage, of size `n`.
- * @param a symbolic structure of the matrix to be factorized.
- * @param stack temporary allocation stack
- */
-template<typename I>
-VEG_INLINE void
-etree( //
-  I* parent,
-  SymbolicMatRef<I> a,
-  DynStackMut stack) noexcept
-{
-  using namespace _detail;
-
-  usize n = usize(a.ncols());
-  auto pai = a.row_indices();
-
-  auto _work =
-    stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{}, isize(n));
-  auto pancestors = _work.ptr_mut();
-
-  // for each column of a
-  for (usize k = 0; k < n; ++k) {
-    parent[k] = I(-1);
-    pancestors[k] = I(-1);
-    // assuming elimination subtree T_{k-1} is known, compute T_k
-
-    auto col_start = a.col_start(k);
-    auto col_end = a.col_end(k);
-
-    // for each non zero element of a
-    for (usize p = col_start; p < col_end; ++p) {
-      // get the row
-      auto i = util::zero_extend(pai[p]);
-      // skip if looking at lower triangular half
-      if (i >= k) {
-        continue;
-      }
-
-      // go up towards the root of the tree
-      usize node = i;
-      auto next = usize(-1);
-      while (true) {
-        if (node == usize(-1) || node >= k) {
-          break;
-        }
-
-        // use the highest known ancestor instead of the parent
-        next = util::sign_extend(pancestors[node]);
-
-        // set the highest known ancestor to k, since we know we're going
-        // to find it eventually
-        pancestors[node] = I(k);
-
-        // if there is no highest known ancestor, we must have hit the root of
-        // the tree
-        // set the parent to k
-        if (next == usize(-1)) {
-          parent[node] = I(k);
-          break;
-        }
-        // go to the highest ancestor
-        node = next;
-      }
-    }
-  }
-}
-
-namespace _detail {
-inline auto
-ereach_req(isize k) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { (k + 1) * isize{ sizeof(bool) }, alignof(bool) };
-}
-
-// compute the set of reachable nodes from the non zero pattern of a_{.,k}
-// not including the node k itself
-template<typename I>
-VEG_NODISCARD VEG_INLINE auto
-ereach(usize& count,
-       I* s,
-       SymbolicMatRef<I> a,
-       I const* parent,
-       isize k,
-       bool* pmarked) noexcept -> I*
-{
-
-  usize n = usize(a.ncols());
-  auto k_ = usize(k);
-
-  auto pai = a.row_indices();
-  auto pparent = parent;
-
-  auto col_start = a.col_start(k_);
-  auto col_end = a.col_end(k_);
-
-  pmarked[k_] = true;
-
-  usize top = n;
-
-  // for each non zero element of a_{.,k}
-  for (usize p = col_start; p < col_end; ++p) {
-    auto i = util::zero_extend(pai[p]);
-
-    // only triu part of a
-    if (i > k_) {
-      continue;
-    }
-
-    usize len = 0;
-    while (true) {
-      // if we reach a marked node
-      if (pmarked[i]) {
-        break;
-      }
-
-      // can't overwrite top of the stack since elements of s are unique
-      // and s is large enough to hold all the nodes
-      s[isize(len)] = I(i);
-      util::wrapping_inc(mut(len));
-
-      // mark node i as reached
-      pmarked[i] = true;
-      i = util::sign_extend(pparent[i]);
-    }
-
-    // make sure that we can memmove
-    std::memmove( //
-      s + (top - len),
-      s,
-      usize(len) * sizeof(I));
-
-    // move down the top of the stack
-    top = util::wrapping_plus(top, -len);
-  }
-
-  for (usize q = top; q < n; ++q) {
-    pmarked[s[q]] = false;
-  }
-  pmarked[k_] = false;
-
-  // [top, end[
-  count = n - top;
-  return s + top;
-}
-} // namespace _detail
-
-namespace _detail {
-// return the next start_index
-template<typename I>
-VEG_INLINE auto
-postorder_depth_first_search( //
-  I* post,
-  usize root,
-  usize start_index,
-  I* pstack,
-  I* pfirst_child,
-  I* pnext_child) noexcept -> usize
-{
-  using namespace _detail;
-
-  usize top = 0;
-  pstack[0] = I(root);
-
-  // stack is non empty
-  while (top != usize(-1)) {
-    auto current_node = util::zero_extend(pstack[top]);
-    auto current_child = util::sign_extend(pfirst_child[current_node]);
-
-    // no more children
-    if (current_child == usize(-1)) {
-      post[start_index] = I(current_node);
-      ++start_index;
-
-      // pop node from the stack
-      util::wrapping_dec(mut(top));
-    } else {
-      // add current child to the stack
-      util::wrapping_inc(mut(top));
-      pstack[top] = I(current_child);
-
-      // next child is now the first child
-      pfirst_child[current_node] = pnext_child[current_child];
-    }
-  }
-  return start_index;
-}
-} // namespace _detail
-
-/*!
- * Computes the memory requirements of the postordering of the cholesky
- * factorization.
- *
- * @param n dimension of the matrix to be factorized.
- */
-template<typename I>
-auto
-postorder_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { (3 * n) * isize(sizeof(I)), alignof(I) };
-}
-
-/*!
- * Computes the postordering of the cholesky factorization of dimension `n`.
- *
- * @param post storage for the postordering, of size `n`
- * @param parent pointer to the elimination tree
- * @param n dimension of the matrix to be factorized
- * @param stack temporary allocation stack
- */
-template<typename I>
-void
-postorder(I* post, I const* parent, isize n, DynStackMut stack) noexcept
-{
-  using namespace _detail;
-
-  auto _work = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{},
-                                            3 * isize(n));
-  I* pwork = _work.ptr_mut();
-
-  I* pstack = pwork;
-  I* pfirst_child = pstack + n;
-  I* pnext_child = pfirst_child + n;
-
-  // no children are found yet
-  for (usize j = 0; j < usize(n); ++j) {
-    pfirst_child[j] = I(-1);
-  }
-
-  for (usize _j = 0; _j < usize(n); ++_j) {
-    // traverse in reverse order, since the children appear in reverse order
-    // of insertion in the linked list
-    usize j = usize(n) - 1 - _j;
-
-    // if not a root node
-    if (parent[isize(j)] != I(-1)) {
-      // next child of this node is the previous first child
-      pnext_child[j] = pfirst_child[util::zero_extend(parent[isize(j)])];
-      // set this node to be the new first child
-      pfirst_child[util::zero_extend(parent[isize(j)])] = I(j);
-    }
-  }
-
-  usize start_index = 0;
-  for (usize root = 0; root < usize(n); ++root) {
-    if (parent[isize(root)] == I(-1)) {
-      start_index = _detail::postorder_depth_first_search(
-        post, root, start_index, pstack, pfirst_child, pnext_child);
-    }
-  }
-}
-
-namespace _detail {
-// returns -2 if j is not a leaf
-// returns -1 if j is a first leaf
-// returns the least common ancestor of j and the previous j otherwise
-template<typename I>
-VEG_INLINE auto
-least_common_ancestor(usize i,
-                      usize j,
-                      I const* pfirst,
-                      I* pmax_first,
-                      I* pprev_leaf,
-                      I* pancestor) noexcept -> I
-{
-  using namespace _detail;
-
-  // if upper triangular part, or not a leaf
-  // leaves always have a new larger value of pfirst
-  // add 1 to get the correct result when comparing with -1
-  if (i <= j || util::wrapping_plus(pfirst[j], I(1)) <=
-                  util::wrapping_plus(pmax_first[i], I(1))) {
-    return I(-2);
-  }
-
-  // update the largest max_first
-  // no need to compare because the value of j increases
-  // inbetween successive calls, and so does first_j
-  pmax_first[i] = pfirst[j];
-
-  // get the previous j
-  usize j_prev = util::sign_extend(pprev_leaf[i]);
-
-  // set the previous j to the current j
-  pprev_leaf[i] = I(j);
-
-  // if first leaf
-  if (j_prev == usize(-1)) {
-    return I(-1);
-  }
-
-  // else, subsequent leaf
-  // get the least common ancestor of j and j_prev
-  usize lca = j_prev;
-  while (true) {
-    if (lca == util::zero_extend(pancestor[lca])) {
-      break;
-    }
-    lca = util::zero_extend(pancestor[lca]);
-  }
-
-  // compress the path to speed up the subsequent calls
-  // to this function
-  usize node = j_prev;
-  while (true) {
-    if (node == lca) {
-      break;
-    }
-    usize next = util::zero_extend(pancestor[node]);
-    pancestor[node] = I(lca);
-    node = next;
-  }
-
-  return I(lca);
-}
-} // namespace _detail
-
-template<typename I>
-auto
-column_counts_req(proxsuite::linalg::veg::Tag<I> tag,
-                  isize n,
-                  isize nnz) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  using proxsuite::linalg::veg::dynstack::StackReq;
-  return StackReq{
-    isize{ sizeof(I) } * (1 + 5 * n + nnz),
-    alignof(I),
-  } & sparse::transpose_symbolic_req(tag, n);
-}
-
-template<typename I>
-void
-column_counts(I* counts,
-              SymbolicMatRef<I> a,
-              I const* parent,
-              I const* post,
-              DynStackMut stack) noexcept
-{
-  // https://youtu.be/uZKJPTo4dZs
-  using namespace _detail;
-  usize n = usize(a.nrows());
-  auto _at_work = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{},
-                                               1 + 5 * isize(n) + a.nnz());
-  auto pat_work = _at_work.ptr_mut();
-  pat_work[0] = 0;
-  pat_work[n] = I(a.nnz());
-
-  SymbolicMatMut<I> at{
-    from_raw_parts, isize(n), isize(n),         a.nnz(),
-    pat_work,       nullptr,  pat_work + n + 1,
-  };
-  sparse::transpose_symbolic(at, a, stack);
-
-  auto patp = at.col_ptrs();
-  auto pati = at.row_indices();
-
-  auto pwork = pat_work + n + 1 + a.nnz();
-
-  auto pdelta = counts;
-
-  auto pfirst = pwork;
-  auto pmax_first = pwork + n;
-  auto pprev_leaf = pwork + 2 * n;
-  auto pancestor = pwork + 3 * n;
-
-  auto pcounts = counts;
-  auto ppost = post;
-  auto pparent = parent;
-
-  for (usize i = 0; i < 3 * n; ++i) {
-    pwork[i] = I(-1);
-  }
-  for (usize i = 0; i < n; ++i) {
-    pancestor[i] = I(i);
-  }
-
-  // for each column in a
-  for (usize k = 0; k < n; ++k) {
-    // in postordered fashion
-    auto j = util::zero_extend(ppost[k]);
-
-    // if first_j isn't computed, j must be a leaf
-    // because if it's not a leaf then first_j will be initialized from
-    // the init loop of its first descendant
-    //
-    // in which case initialize delta_j to 1
-    pdelta[j] = (pfirst[j] == I(-1)) ? I(1) : I(0);
-
-    // init loop
-    while (true) {
-      // while j is not a root, and the first descendant of j isn't computed
-      // set the first descendant of j to k, as well as all of its ancestors
-      // that don't yet have a first descendant
-      if (j == usize(-1) || pfirst[j] != I(-1)) {
-        break;
-      }
-      pfirst[j] = I(k);
-      j = util::sign_extend(pparent[j]);
-    }
-  }
-
-  // for each node
-  for (usize k = 0; k < n; ++k) {
-    // in postordered fashion
-    auto j = util::zero_extend(ppost[k]);
-
-    // if this node is the child of some other node
-    if (pparent[j] != I(-1)) {
-      // decrement the delta of that node
-      // corresponding to the correction term e_j
-      util::wrapping_dec(mut(pdelta[util::zero_extend(pparent[j])]));
-    }
-
-    auto col_start = util::zero_extend(patp[j]);
-    auto col_end = util::zero_extend(patp[j + 1]);
-
-    // iterate over lower triangular half of a
-    for (usize p = col_start; p < col_end; ++p) {
-      auto i = util::zero_extend(pati[p]);
-      I lca = _detail::least_common_ancestor( //
-        i,
-        j,
-        pfirst,
-        pmax_first,
-        pprev_leaf,
-        pancestor);
-
-      // if j is a leaf of T^i
-      if (lca != I(-2)) {
-        util::wrapping_inc(mut(pdelta[j]));
-
-        // if j is a subsequent leaf
-        if (lca != I(-1)) {
-          util::wrapping_dec(mut(pdelta[util::zero_extend(lca)]));
-        }
-      }
-    }
-
-    if (pparent[j] != -1) {
-      // set the ancestor of j
-      pancestor[j] = pparent[j];
-    }
-  }
-
-  // sum up the deltas
-  for (usize j = 0; j < n; ++j) {
-    if (parent[isize(j)] != I(-1)) {
-      pcounts[util::zero_extend(parent[isize(j)])] = util::wrapping_plus(
-        pcounts[util::zero_extend(parent[isize(j)])], pcounts[j]);
-    }
-  }
-}
-
-template<typename I>
-auto
-amd_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize /*n*/, isize nnz) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { nnz * isize{ sizeof(char) }, alignof(char) };
-}
-
-template<typename I>
-void
-amd(I* perm, SymbolicMatRef<I> mat, DynStackMut stack) noexcept
-{
-  // TODO: reimplement amd under BSD-3
-  // https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/master/AMD
-
-  isize n = mat.nrows();
-  isize nnz = mat.nnz();
-
-  Eigen::PermutationMatrix<-1, -1, I> perm_eigen;
-  auto _ = stack.make_new(proxsuite::linalg::veg::Tag<char>{}, nnz);
-
-  Eigen::AMDOrdering<I>{}(
-    Eigen::Map<Eigen::SparseMatrix<char, Eigen::ColMajor, I> const>{
-      n,
-      n,
-      nnz,
-      mat.col_ptrs(),
-      mat.row_indices(),
-      _.ptr(),
-      mat.nnz_per_col(),
-    }
-      .template selfadjointView<Eigen::Upper>(),
-
-    perm_eigen);
-  std::memmove( //
-    perm,
-    perm_eigen.indices().data(),
-    usize(n) * sizeof(I));
-}
-
-namespace _detail {
-template<typename I>
-void
-inv_perm(I* perm_inv, I const* perm, isize n) noexcept
-{
-  for (usize i = 0; i < usize(n); ++i) {
-    perm_inv[util::zero_extend(perm[i])] = I(i);
-  }
-}
-
-template<typename I>
-auto
-symmetric_permute_symbolic_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
-                               isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { n * isize{ sizeof(I) }, alignof(I) };
-}
-template<typename I>
-auto
-symmetric_permute_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return { n * isize{ sizeof(I) }, alignof(I) };
-}
-
-template<typename I>
-void
-symmetric_permute_common(usize n,
-                         I const* pperm_inv,
-                         SymbolicMatRef<I> old_a,
-                         I* pnew_ap,
-                         I* pcol_counts)
-{
-  for (usize old_j = 0; old_j < n; ++old_j) {
-    usize new_j = util::zero_extend(pperm_inv[old_j]);
-
-    auto col_start = old_a.col_start(old_j);
-    auto col_end = old_a.col_end(old_j);
-
-    for (usize p = col_start; p < col_end; ++p) {
-      usize old_i = util::zero_extend(old_a.row_indices()[p]);
-
-      if (old_i <= old_j) {
-        usize new_i = util::zero_extend(pperm_inv[old_i]);
-        util::wrapping_inc(mut(pcol_counts[new_i > new_j ? new_i : new_j]));
-      }
-    }
-  }
-
-  pnew_ap[0] = I(0);
-  for (usize i = 0; i < n; ++i) {
-    pnew_ap[i + 1] =
-      util::checked_non_negative_plus(pnew_ap[i], pcol_counts[i]);
-    pcol_counts[i] = pnew_ap[i];
-  }
-}
-
-template<typename I>
-void
-symmetric_permute_symbolic(SymbolicMatMut<I> new_a,
-                           SymbolicMatRef<I> old_a,
-                           I const* perm_inv,
-                           DynStackMut stack) noexcept
-{
-
-  usize n = usize(new_a.nrows());
-
-  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, isize(n));
-  I* pcol_counts = _work.ptr_mut();
-
-  VEG_ASSERT(new_a.is_compressed());
-  auto pold_ai = old_a.row_indices();
-
-  auto pnew_ap = new_a.col_ptrs_mut();
-  auto pnew_ai = new_a.row_indices_mut();
-
-  auto pperm_inv = perm_inv;
-
-  _detail::symmetric_permute_common(n, pperm_inv, old_a, pnew_ap, pcol_counts);
-
-  auto pcurrent_row_index = pcol_counts;
-
-  for (usize old_j = 0; old_j < n; ++old_j) {
-    usize new_j = util::zero_extend(pperm_inv[old_j]);
-
-    auto col_start = old_a.col_start(old_j);
-    auto col_end = old_a.col_end(old_j);
-
-    for (usize p = col_start; p < col_end; ++p) {
-      usize old_i = util::zero_extend(pold_ai[p]);
-
-      if (old_i <= old_j) {
-        usize new_i = util::zero_extend(pperm_inv[old_i]);
-
-        usize new_max = new_i > new_j ? new_i : new_j;
-        usize new_min = new_i < new_j ? new_i : new_j;
-
-        auto row_idx = pcurrent_row_index[new_max];
-        pnew_ai[row_idx] = I(new_min);
-        pcurrent_row_index[new_max] = util::wrapping_plus(row_idx, I(1));
-      }
-    }
-  }
-}
-
-template<typename T, typename I>
-void
-symmetric_permute(MatMut<T, I> new_a,
-                  MatRef<T, I> old_a,
-                  I const* perm_inv,
-                  DynStackMut stack) noexcept(VEG_CONCEPT(nothrow_copyable<T>))
-{
-  usize n = usize(new_a.nrows());
-  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, isize(n));
-  I* pcol_counts = _work.ptr_mut();
-
-  VEG_ASSERT(new_a.is_compressed());
-  auto pold_ai = old_a.row_indices();
-
-  auto pnew_ap = new_a.col_ptrs_mut();
-  auto pnew_ai = new_a.row_indices_mut();
-
-  auto pperm_inv = perm_inv;
-
-  _detail::symmetric_permute_common(
-    n, pperm_inv, old_a.symbolic(), pnew_ap, pcol_counts);
-
-  auto pcurrent_row_index = pcol_counts;
-
-  auto pold_ax = old_a.values();
-  auto pnew_ax = new_a.values_mut();
-  for (usize old_j = 0; old_j < n; ++old_j) {
-    usize new_j = util::zero_extend(pperm_inv[old_j]);
-
-    auto col_start = old_a.col_start(old_j);
-    auto col_end = old_a.col_end(old_j);
-
-    for (usize p = col_start; p < col_end; ++p) {
-      usize old_i = util::zero_extend(pold_ai[p]);
-
-      if (old_i <= old_j) {
-        usize new_i = util::zero_extend(pperm_inv[old_i]);
-
-        usize new_max = new_i > new_j ? new_i : new_j;
-        usize new_min = new_i < new_j ? new_i : new_j;
-
-        auto row_idx = pcurrent_row_index[new_max];
-        pnew_ai[row_idx] = I(new_min);
-        pnew_ax[row_idx] = pold_ax[p];
-        pcurrent_row_index[new_max] = util::wrapping_plus(row_idx, I(1));
-      }
-    }
-  }
-}
-} // namespace _detail
-
-enum struct Ordering : unsigned char
-{
-  natural,
-  user_provided,
-  amd,
-  ENUM_END,
-};
-
-/*!
- * Computes the stack memory requirements of symbolic factorization.
- *
- * @param n dimension of the matrix to be factorized.
- * @param nnz number of non zeros of the matrix to be factorized.
- * @param o the kind of permutation that is applied to the matrix before
- * factorization.
- */
-template<typename I>
-auto
-factorize_symbolic_req(proxsuite::linalg::veg::Tag<I> tag,
-                       isize n,
-                       isize nnz,
-                       Ordering o) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  using proxsuite::linalg::veg::dynstack::StackReq;
-  constexpr isize sz{ sizeof(I) };
-  constexpr isize al{ alignof(I) };
-
-  StackReq perm_req{ 0, al };
-  StackReq amd_req{ 0, al };
-  switch (o) {
-    case Ordering::natural:
-      break;
-    case Ordering::amd:
-      amd_req =
-        StackReq{ n * sz, al } & StackReq{ sparse::amd_req(tag, n, nnz) };
-      HEDLEY_FALL_THROUGH;
-    case Ordering::user_provided:
-      perm_req = perm_req & StackReq{ (n + 1 + nnz) * sz, al };
-      perm_req = perm_req & _detail::symmetric_permute_symbolic_req(tag, n);
-    default:
-      break;
-  }
-
-  StackReq parent_req = { n * sz, al };
-  StackReq post_req = { n * sz, al };
-
-  StackReq etree_req = sparse::etree_req(tag, n);
-  StackReq postorder_req = sparse::postorder_req(tag, n);
-  StackReq colcount_req = sparse::column_counts_req(tag, n, nnz);
-
-  return amd_req              //
-         | (perm_req          //
-            & (parent_req     //
-               & (etree_req   //
-                  | (post_req //
-                     & (postorder_req | colcount_req)))));
-}
-
-/*!
- * Performs symbolic factorization and computed the number of non-zeros in each
- * column of the cholesky factor of dimension `n`.
- *
- * @param nnz_per_col storage for non-zeros per column, of size `n`
- * @param etree storage for elimination tree, of size `n`
- * @param perm_inv storage for inverse permutation, of size `n`
- * @param perm optionally user-provided permutation, either null or of size `n`
- * @param a matrix to be symbolically factorized
- * @param stack temporary allocation stack
- */
-template<typename I>
-void
-factorize_symbolic_non_zeros(I* nnz_per_col,
-                             I* etree,
-                             I* perm_inv,
-                             I const* perm,
-                             SymbolicMatRef<I> a,
-                             DynStackMut stack) noexcept
-{
-
-  bool id_perm = perm_inv == nullptr;
-  bool user_perm = perm != nullptr;
-
-  Ordering o = user_perm ? Ordering::user_provided
-               : id_perm ? Ordering::natural
-                         : Ordering::amd;
-
-  proxsuite::linalg::veg::Tag<I> tag{};
-
-  usize n = usize(a.ncols());
-
-  switch (o) {
-    case Ordering::natural:
-      break;
-
-    case Ordering::amd: {
-      auto amd_perm = stack.make_new_for_overwrite(tag, isize(n));
-      sparse::amd(amd_perm.ptr_mut(), a, stack);
-      perm = amd_perm.ptr();
-    }
-      HEDLEY_FALL_THROUGH;
-    case Ordering::user_provided: {
-      _detail::inv_perm(perm_inv, perm, isize(n));
-    }
-    default:
-      break;
-  }
-
-  auto _permuted_a_col_ptrs =
-    stack //
-      .make_new_for_overwrite(tag, id_perm ? 0 : (a.ncols() + 1));
-  auto _permuted_a_row_indices =
-    stack //
-      .make_new_for_overwrite(tag, id_perm ? 0 : (a.nnz()));
-
-  if (!id_perm) {
-    _permuted_a_col_ptrs.as_mut()[0] = 0;
-    _permuted_a_col_ptrs.as_mut()[isize(n)] = I(a.nnz());
-    SymbolicMatMut<I> permuted_a{
-      from_raw_parts,
-      isize(n),
-      isize(n),
-      a.nnz(),
-      _permuted_a_col_ptrs.ptr_mut(),
-      nullptr,
-      _permuted_a_row_indices.ptr_mut(),
-    };
-    _detail::symmetric_permute_symbolic(permuted_a, a, perm_inv, stack);
-  }
-
-  SymbolicMatRef<I> permuted_a = id_perm ? a
-                                         : SymbolicMatRef<I>{
-                                             from_raw_parts,
-                                             isize(n),
-                                             isize(n),
-                                             a.nnz(),
-                                             _permuted_a_col_ptrs.ptr(),
-                                             nullptr,
-                                             _permuted_a_row_indices.ptr(),
-                                           };
-
-  sparse::etree(etree, permuted_a, stack);
-
-  auto _post = stack.make_new_for_overwrite(tag, isize(n));
-  sparse::postorder(_post.ptr_mut(), etree, isize(n), stack);
-  sparse::column_counts(nnz_per_col, permuted_a, etree, _post.ptr(), stack);
-}
-
-/*!
- * Performs symbolic factorization and computed the column pointers for each
- * column of the cholesky factor of dimension `n`.
- *
- * @param col_ptrs storage for column pointers, of size `n + 1`
- * @param etree storage for elimination tree, of size `n`
- * @param perm_inv storage for inverse permutation, of size `n`
- * @param perm optionally user-provided permutation, either null or of size `n`
- * @param a matrix to be symbolically factorized
- * @param stack temporary allocation stack
- */
-template<typename I>
-void
-factorize_symbolic_col_counts(I* col_ptrs,
-                              I* etree,
-                              I* perm_inv,
-                              I const* perm,
-                              SymbolicMatRef<I> a,
-                              DynStackMut stack) noexcept
-{
-
-  sparse::factorize_symbolic_non_zeros( //
-    col_ptrs + 1,
-    etree,
-    perm_inv,
-    perm,
-    a,
-    stack);
-
-  usize n = usize(a.ncols());
-  auto pcol_ptrs = col_ptrs;
-  pcol_ptrs[0] = I(0);
-  for (usize i = 0; i < n; ++i) {
-    pcol_ptrs[i + 1] =
-      util::checked_non_negative_plus(pcol_ptrs[i + 1], pcol_ptrs[i]);
-  }
-}
-
-/*!
- * Computes the stack memory requirements of numerical factorization.
- *
- * @param n dimension of the matrix to be factorized.
- * @param a_nnz number of non zeros of the matrix to be factorized.
- * @param o the kind of permutation that is applied to the matrix before
- * factorization.
- */
-template<typename T, typename I>
-auto
-factorize_numeric_req(proxsuite::linalg::veg::Tag<T> /*ttag*/,
-                      proxsuite::linalg::veg::Tag<I> /*itag*/,
-                      isize n,
-                      isize a_nnz,
-                      Ordering o) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  using proxsuite::linalg::veg::dynstack::StackReq;
-
-  constexpr isize sz{ sizeof(I) };
-  constexpr isize al{ alignof(I) };
-
-  constexpr isize tsz{ sizeof(T) };
-  constexpr isize tal{ alignof(T) };
-
-  bool id_perm = o == Ordering::natural;
-
-  auto symb_perm_req = StackReq{ sz * (id_perm ? 0 : (n + 1 + a_nnz)), al };
-  auto num_perm_req = StackReq{ tsz * (id_perm ? 0 : a_nnz), tal };
-  return num_perm_req                         //
-         & (StackReq{ tsz * n, tal }          //
-            & (symb_perm_req                  //
-               & (StackReq{ 2 * n * sz, al }  //
-                  & (StackReq{ n * tsz, tal } //
-                     & StackReq{ n * isize{ sizeof(bool) }, alignof(bool) }))));
-}
-
-/*!
- * Performs numerical `LDLT` factorization, assuming the symbolic factorization
- * and column counts have already been computed. `L` and `D` are stored in the
- * same matrix, with the elements of `D` replacing the implicit diagonal `1`
- * element of each column of `L`.
- *
- * @param values pointer to the values of the factorization
- * @param row_indices pointer to the row indices of the factorization
- * @param diag_to_add pointer to a vector that is added to the diagonal of the
- * matrix during factorization, if `diag_to_add` and `perm` are both non null
- * @param perm pointer to the pre-computed permutation that is applied to
- * `diag`.
- * @param col_ptrs pointer to the already computed column pointers
- * @param etree pointer to the already computed elimination tree
- * @param perm_inv pointer to the already computed inverse permutation. Must be
- * the inverse of `perm`
- * @param a matrix to be factorized
- * @param stack temporary allocation stack
- */
-template<typename T, typename I>
-void
-factorize_numeric( //
-  T* values,
-  I* row_indices,
-  proxsuite::linalg::veg::DoNotDeduce<T const*> diag_to_add,
-  proxsuite::linalg::veg::DoNotDeduce<I const*> perm,
-  I const* col_ptrs,
-  I const* etree,
-  I const* perm_inv,
-  MatRef<T, I> a,
-  DynStackMut stack) noexcept(false)
-{
-  using namespace _detail;
-  isize n = a.nrows();
-
-  bool id_perm = perm_inv == nullptr;
-
-  proxsuite::linalg::veg::Tag<I> tag{};
-
-  auto _permuted_a_values = stack.make_new_for_overwrite(
-    proxsuite::linalg::veg::Tag<T>{}, id_perm ? 0 : a.nnz());
-
-  auto _x = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<T>{}, n);
-
-  auto _permuted_a_col_ptrs =
-    stack.make_new_for_overwrite(tag, id_perm ? 0 : (a.ncols() + 1));
-  auto _permuted_a_row_indices =
-    stack.make_new_for_overwrite(tag, id_perm ? 0 : a.nnz());
-
-  if (!id_perm) {
-    _permuted_a_col_ptrs.as_mut()[0] = 0;
-    _permuted_a_col_ptrs.as_mut()[n] = I(a.nnz());
-    MatMut<T, I> permuted_a{
-      from_raw_parts,
-      n,
-      n,
-      a.nnz(),
-      _permuted_a_col_ptrs.ptr_mut(),
-      nullptr,
-      _permuted_a_row_indices.ptr_mut(),
-      _permuted_a_values.ptr_mut(),
-    };
-    _detail::symmetric_permute(permuted_a, a, perm_inv, stack);
-  }
-
-  MatRef<T, I> permuted_a = id_perm ? a
-                                    : MatRef<T, I>{
-                                        from_raw_parts,
-                                        isize(n),
-                                        isize(n),
-                                        a.nnz(),
-                                        _permuted_a_col_ptrs.ptr(),
-                                        nullptr,
-                                        _permuted_a_row_indices.ptr(),
-                                        _permuted_a_values.ptr(),
-                                      };
-
-  auto _current_row_index = stack.make_new_for_overwrite(tag, n);
-  auto _ereach_stack_storage = stack.make_new_for_overwrite(tag, n);
-
-  I* pcurrent_row_index = _current_row_index.ptr_mut();
-  T* px = _x.ptr_mut();
-
-  std::memcpy( //
-    pcurrent_row_index,
-    col_ptrs,
-    usize(n) * sizeof(I));
-  for (usize i = 0; i < usize(n); ++i) {
-    px[i] = 0;
-  }
-
-  // compute the iter-th row of L using the iter-th column of permuted_a
-  // the diagonal element is filled with the diagonal of D instead of 1
-  I const* plp = col_ptrs;
-
-  auto _marked = stack.make_new(proxsuite::linalg::veg::Tag<bool>{}, n);
-  for (usize iter = 0; iter < usize(n); ++iter) {
-    usize ereach_count = 0;
-    auto ereach_stack = _detail::ereach(ereach_count,
-                                        _ereach_stack_storage.ptr_mut(),
-                                        permuted_a.symbolic(),
-                                        etree,
-                                        isize(iter),
-                                        _marked.ptr_mut());
-
-    auto pereach_stack = ereach_stack;
-
-    I const* pai = permuted_a.row_indices();
-    T const* pax = permuted_a.values();
-
-    I* pli = row_indices;
-    T* plx = values;
-
-    {
-      auto col_start = permuted_a.col_start(iter);
-      auto col_end = permuted_a.col_end(iter);
-
-      // scatter permuted_a column into x
-      // untouched columns are already zeroed
-
-      for (usize p = col_start; p < col_end; ++p) {
-        auto i = util::zero_extend(pai[p]);
-        px[i] = pax[p];
-      }
-    }
-    T d = px[iter] + ((diag_to_add == nullptr || perm == nullptr)
-                        ? T(0)
-                        : diag_to_add[util::zero_extend(perm[iter])]);
-
-    // zero for next iteration
-    px[iter] = 0;
-
-    for (usize q = 0; q < ereach_count; ++q) {
-      usize j = util::zero_extend(pereach_stack[q]);
-      auto col_start = util::zero_extend(plp[j]);
-      auto row_idx = util::zero_extend(pcurrent_row_index[j]) + 1;
-
-      T const xj = px[j];
-      T const dj = plx[col_start];
-      T const lkj = xj / dj;
-
-      // zero for the next iteration
-      px[j] = 0;
-
-      // skip first element, to put diagonal there later
-      for (usize p = col_start + 1; p < row_idx; ++p) {
-        auto i = util::zero_extend(pli[p]);
-        px[i] -= plx[p] * xj;
-      }
-
-      d -= lkj * xj;
-
-      pli[row_idx] = I(iter);
-      plx[row_idx] = lkj;
-      pcurrent_row_index[j] = I(row_idx);
-    }
-    {
-      auto col_start = util::zero_extend(plp[iter]);
-      pli[col_start] = I(iter);
-      plx[col_start] = d;
-    }
-  }
-}
-} // namespace sparse
-} // namespace linalg
-} // namespace proxsuite
-#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP
+#define PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP
+
+#include "proxsuite/linalg/sparse/core.hpp"
+#include <Eigen/OrderingMethods>
+
+namespace proxsuite {
+namespace linalg {
+namespace sparse {
+
+template<typename I>
+auto
+transpose_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize nrows) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { nrows * isize(sizeof(I)), isize(alignof(I)) };
+}
+
+// at = a.T
+template<typename T, typename I>
+void
+transpose( //
+  MatMut<T, I> at,
+  MatRef<T, I> a,
+  DynStackMut stack) noexcept(VEG_CONCEPT(nothrow_copyable<T>))
+{
+  using namespace _detail;
+
+  VEG_ASSERT_ALL_OF( //
+    at.is_compressed(),
+    at.nrows() == a.ncols(),
+    at.ncols() == a.nrows(),
+    at.nnz() == a.nnz());
+
+  auto pai = a.row_indices();
+  auto pax = a.values();
+
+  auto patp = at.col_ptrs_mut();
+  auto pati = at.row_indices_mut();
+  auto patx = at.values_mut();
+
+  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, at.ncols());
+  auto work = _work.ptr_mut();
+
+  // work[i] = num zeros in ith row of A
+  if (a.is_compressed()) {
+    for (usize p = 0; p < usize(a.nnz()); ++p) {
+      util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
+    }
+  } else {
+    for (usize j = 0; j < a.ncols(); ++j) {
+      isize col_start = a.col_start(j);
+      isize col_end = a.col_end(j);
+      for (isize p = col_start; p < col_end; ++p) {
+        util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
+      }
+    }
+  }
+
+  // compute the cumulative sum
+  for (usize j = 0; j < usize(at.ncols()); ++j) {
+    patp[j + 1] = util::checked_non_negative_plus(patp[j], work[j]);
+    work[j] = patp[j];
+  }
+
+  for (usize j = 0; j < usize(a.ncols()); ++j) {
+    auto col_start = a.col_start(j);
+    auto col_end = a.col_end(j);
+    for (usize p = col_start; p < col_end; ++p) {
+      auto i = util::zero_extend(pai[p]);
+      auto q = util::zero_extend(work[i]);
+
+      pati[q] = j;
+      patx[q] = pax[p];
+      util::wrapping_inc(mut(work[i]));
+    }
+  }
+}
+
+template<typename I>
+auto
+transpose_symbolic_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
+                       isize nrows) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { nrows * isize(sizeof(I)), isize(alignof(I)) };
+}
+
+template<typename I>
+void
+transpose_symbolic( //
+  SymbolicMatMut<I> at,
+  SymbolicMatRef<I> a,
+  DynStackMut stack) noexcept
+{
+  using namespace _detail;
+
+  VEG_ASSERT_ALL_OF( //
+    at.is_compressed(),
+    at.nrows() == a.ncols(),
+    at.ncols() == a.nrows(),
+    at.nnz() == a.nnz());
+
+  auto pai = a.row_indices();
+
+  auto patp = at.col_ptrs_mut();
+  auto pati = at.row_indices_mut();
+
+  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, at.ncols());
+  auto work = _work.ptr_mut();
+
+  // work[i] = num zeros in ith row of A
+  for (usize p = 0; p < usize(a.nnz()); ++p) {
+    util::wrapping_inc(mut(work[util::zero_extend(pai[p])]));
+  }
+
+  // compute the cumulative sum
+  for (usize j = 0; j < usize(at.ncols()); ++j) {
+    patp[j + 1] = util::checked_non_negative_plus(patp[j], work[j]);
+    work[j] = patp[j];
+  }
+
+  for (usize j = 0; j < usize(a.ncols()); ++j) {
+    auto col_start = a.col_start(j);
+    auto col_end = a.col_end(j);
+    for (usize p = col_start; p < col_end; ++p) {
+      auto i = util::zero_extend(pai[p]);
+      auto q = util::zero_extend(work[i]);
+
+      pati[q] = I(j);
+      util::wrapping_inc(mut(work[i]));
+    }
+  }
+}
+
+/*!
+ * `l` is unit lower triangular whose diagonal elements are ignored.
+ * Solves `l×y = x` and store the solution in `x`.
+ *
+ * @param x RHS of the system, solution storage.
+ * @param l matrix to be inverted.
+ */
+template<typename T, typename I>
+void
+dense_lsolve(DenseVecMut<T> x, MatRef<T, I> l) noexcept(false)
+{
+  using namespace _detail;
+
+  VEG_ASSERT_ALL_OF( //
+    l.nrows() == l.ncols(),
+    x.nrows() == l.nrows()
+    /* l is unit lower triangular */
+  );
+
+  usize n = usize(l.nrows());
+
+  auto pli = l.row_indices();
+  auto plx = l.values();
+
+  auto px = x.as_slice_mut().ptr_mut();
+
+  for (usize j = 0; j < n; ++j) {
+    auto const xj = px[j];
+    auto col_start = l.col_start(j);
+    auto col_end = l.col_end(j);
+
+    // skip the diagonal entry
+    for (usize p = col_start + 1; p < col_end; ++p) {
+      auto i = util::zero_extend(pli[p]);
+      px[i] -= plx[p] * xj;
+    }
+  }
+}
+
+/*!
+ * `l` is unit lower triangular whose diagonal elements are ignored.
+ * Solves `l.T×y = x` and store the solution in `x`.
+ *
+ * @param x RHS of the system, solution storage.
+ * @param l matrix to be inverted.
+ */
+template<typename T, typename I>
+void
+dense_ltsolve(DenseVecMut<T> x, MatRef<T, I> l) noexcept(false)
+{
+  using namespace _detail;
+
+  VEG_ASSERT_ALL_OF( //
+    l.nrows() == l.ncols(),
+    x.nrows() == l.nrows()
+    /* l is unit lower triangular */
+  );
+
+  usize n = usize(l.nrows());
+
+  auto pli = l.row_indices();
+  auto plx = l.values();
+
+  auto px = x.as_slice_mut().ptr_mut();
+
+  usize j = n;
+  while (true) {
+    if (j == 0) {
+      break;
+    }
+    --j;
+
+    auto col_start = l.col_start(j);
+    auto col_end = l.col_end(j);
+    T acc0 = 0;
+    T acc1 = 0;
+    T acc2 = 0;
+    T acc3 = 0;
+
+    // skip the diagonal entry
+    usize pstart = col_start + 1;
+    usize pcount = col_end - pstart;
+
+    usize p = pstart;
+    for (; p < pstart + pcount / 4 * 4; p += 4) {
+      auto i0 = util::zero_extend(pli[p + 0]);
+      auto i1 = util::zero_extend(pli[p + 1]);
+      auto i2 = util::zero_extend(pli[p + 2]);
+      auto i3 = util::zero_extend(pli[p + 3]);
+      acc0 += plx[p + 0] * px[i0];
+      acc1 += plx[p + 1] * px[i1];
+      acc2 += plx[p + 2] * px[i2];
+      acc3 += plx[p + 3] * px[i3];
+    }
+    for (; p < pstart + pcount; ++p) {
+      auto i0 = util::zero_extend(pli[p + 0]);
+      acc0 += plx[p + 0] * px[i0];
+    }
+
+    acc0 = (acc0 + acc1) + (acc2 + acc3);
+
+    px[j] -= acc0;
+  }
+}
+
+/*!
+ * Computes the stack memory requirements of etree computation.
+ *
+ * @param n dimension of the matrix.
+ */
+template<typename I>
+auto
+etree_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { n * isize{ sizeof(I) }, alignof(I) };
+}
+
+/*!
+ * Computes the elimination tree of the cholesky factor  of `a` of size `n`.
+ * `a` is considered symmetric but should only contain terms from the upper
+ * triangular part.
+ *
+ * @param parent pointer to the elimination tree storage, of size `n`.
+ * @param a symbolic structure of the matrix to be factorized.
+ * @param stack temporary allocation stack
+ */
+template<typename I>
+VEG_INLINE void
+etree( //
+  I* parent,
+  SymbolicMatRef<I> a,
+  DynStackMut stack) noexcept
+{
+  using namespace _detail;
+
+  usize n = usize(a.ncols());
+  auto pai = a.row_indices();
+
+  auto _work =
+    stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{}, isize(n));
+  auto pancestors = _work.ptr_mut();
+
+  // for each column of a
+  for (usize k = 0; k < n; ++k) {
+    parent[k] = I(-1);
+    pancestors[k] = I(-1);
+    // assuming elimination subtree T_{k-1} is known, compute T_k
+
+    auto col_start = a.col_start(k);
+    auto col_end = a.col_end(k);
+
+    // for each non zero element of a
+    for (usize p = col_start; p < col_end; ++p) {
+      // get the row
+      auto i = util::zero_extend(pai[p]);
+      // skip if looking at lower triangular half
+      if (i >= k) {
+        continue;
+      }
+
+      // go up towards the root of the tree
+      usize node = i;
+      auto next = usize(-1);
+      while (true) {
+        if (node == usize(-1) || node >= k) {
+          break;
+        }
+
+        // use the highest known ancestor instead of the parent
+        next = util::sign_extend(pancestors[node]);
+
+        // set the highest known ancestor to k, since we know we're going
+        // to find it eventually
+        pancestors[node] = I(k);
+
+        // if there is no highest known ancestor, we must have hit the root of
+        // the tree
+        // set the parent to k
+        if (next == usize(-1)) {
+          parent[node] = I(k);
+          break;
+        }
+        // go to the highest ancestor
+        node = next;
+      }
+    }
+  }
+}
+
+namespace _detail {
+inline auto
+ereach_req(isize k) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { (k + 1) * isize{ sizeof(bool) }, alignof(bool) };
+}
+
+// compute the set of reachable nodes from the non zero pattern of a_{.,k}
+// not including the node k itself
+template<typename I>
+VEG_NODISCARD VEG_INLINE auto
+ereach(usize& count,
+       I* s,
+       SymbolicMatRef<I> a,
+       I const* parent,
+       isize k,
+       bool* pmarked) noexcept -> I*
+{
+
+  usize n = usize(a.ncols());
+  auto k_ = usize(k);
+
+  auto pai = a.row_indices();
+  auto pparent = parent;
+
+  auto col_start = a.col_start(k_);
+  auto col_end = a.col_end(k_);
+
+  pmarked[k_] = true;
+
+  usize top = n;
+
+  // for each non zero element of a_{.,k}
+  for (usize p = col_start; p < col_end; ++p) {
+    auto i = util::zero_extend(pai[p]);
+
+    // only triu part of a
+    if (i > k_) {
+      continue;
+    }
+
+    usize len = 0;
+    while (true) {
+      // if we reach a marked node
+      if (pmarked[i]) {
+        break;
+      }
+
+      // can't overwrite top of the stack since elements of s are unique
+      // and s is large enough to hold all the nodes
+      s[isize(len)] = I(i);
+      util::wrapping_inc(mut(len));
+
+      // mark node i as reached
+      pmarked[i] = true;
+      i = util::sign_extend(pparent[i]);
+    }
+
+    // make sure that we can memmove
+    std::memmove( //
+      s + (top - len),
+      s,
+      usize(len) * sizeof(I));
+
+    // move down the top of the stack
+    top = util::wrapping_plus(top, -len);
+  }
+
+  for (usize q = top; q < n; ++q) {
+    pmarked[s[q]] = false;
+  }
+  pmarked[k_] = false;
+
+  // [top, end[
+  count = n - top;
+  return s + top;
+}
+} // namespace _detail
+
+namespace _detail {
+// return the next start_index
+template<typename I>
+VEG_INLINE auto
+postorder_depth_first_search( //
+  I* post,
+  usize root,
+  usize start_index,
+  I* pstack,
+  I* pfirst_child,
+  I* pnext_child) noexcept -> usize
+{
+  using namespace _detail;
+
+  usize top = 0;
+  pstack[0] = I(root);
+
+  // stack is non empty
+  while (top != usize(-1)) {
+    auto current_node = util::zero_extend(pstack[top]);
+    auto current_child = util::sign_extend(pfirst_child[current_node]);
+
+    // no more children
+    if (current_child == usize(-1)) {
+      post[start_index] = I(current_node);
+      ++start_index;
+
+      // pop node from the stack
+      util::wrapping_dec(mut(top));
+    } else {
+      // add current child to the stack
+      util::wrapping_inc(mut(top));
+      pstack[top] = I(current_child);
+
+      // next child is now the first child
+      pfirst_child[current_node] = pnext_child[current_child];
+    }
+  }
+  return start_index;
+}
+} // namespace _detail
+
+/*!
+ * Computes the memory requirements of the postordering of the cholesky
+ * factorization.
+ *
+ * @param n dimension of the matrix to be factorized.
+ */
+template<typename I>
+auto
+postorder_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { (3 * n) * isize(sizeof(I)), alignof(I) };
+}
+
+/*!
+ * Computes the postordering of the cholesky factorization of dimension `n`.
+ *
+ * @param post storage for the postordering, of size `n`
+ * @param parent pointer to the elimination tree
+ * @param n dimension of the matrix to be factorized
+ * @param stack temporary allocation stack
+ */
+template<typename I>
+void
+postorder(I* post, I const* parent, isize n, DynStackMut stack) noexcept
+{
+  using namespace _detail;
+
+  auto _work = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{},
+                                            3 * isize(n));
+  I* pwork = _work.ptr_mut();
+
+  I* pstack = pwork;
+  I* pfirst_child = pstack + n;
+  I* pnext_child = pfirst_child + n;
+
+  // no children are found yet
+  for (usize j = 0; j < usize(n); ++j) {
+    pfirst_child[j] = I(-1);
+  }
+
+  for (usize _j = 0; _j < usize(n); ++_j) {
+    // traverse in reverse order, since the children appear in reverse order
+    // of insertion in the linked list
+    usize j = usize(n) - 1 - _j;
+
+    // if not a root node
+    if (parent[isize(j)] != I(-1)) {
+      // next child of this node is the previous first child
+      pnext_child[j] = pfirst_child[util::zero_extend(parent[isize(j)])];
+      // set this node to be the new first child
+      pfirst_child[util::zero_extend(parent[isize(j)])] = I(j);
+    }
+  }
+
+  usize start_index = 0;
+  for (usize root = 0; root < usize(n); ++root) {
+    if (parent[isize(root)] == I(-1)) {
+      start_index = _detail::postorder_depth_first_search(
+        post, root, start_index, pstack, pfirst_child, pnext_child);
+    }
+  }
+}
+
+namespace _detail {
+// returns -2 if j is not a leaf
+// returns -1 if j is a first leaf
+// returns the least common ancestor of j and the previous j otherwise
+template<typename I>
+VEG_INLINE auto
+least_common_ancestor(usize i,
+                      usize j,
+                      I const* pfirst,
+                      I* pmax_first,
+                      I* pprev_leaf,
+                      I* pancestor) noexcept -> I
+{
+  using namespace _detail;
+
+  // if upper triangular part, or not a leaf
+  // leaves always have a new larger value of pfirst
+  // add 1 to get the correct result when comparing with -1
+  if (i <= j || util::wrapping_plus(pfirst[j], I(1)) <=
+                  util::wrapping_plus(pmax_first[i], I(1))) {
+    return I(-2);
+  }
+
+  // update the largest max_first
+  // no need to compare because the value of j increases
+  // inbetween successive calls, and so does first_j
+  pmax_first[i] = pfirst[j];
+
+  // get the previous j
+  usize j_prev = util::sign_extend(pprev_leaf[i]);
+
+  // set the previous j to the current j
+  pprev_leaf[i] = I(j);
+
+  // if first leaf
+  if (j_prev == usize(-1)) {
+    return I(-1);
+  }
+
+  // else, subsequent leaf
+  // get the least common ancestor of j and j_prev
+  usize lca = j_prev;
+  while (true) {
+    if (lca == util::zero_extend(pancestor[lca])) {
+      break;
+    }
+    lca = util::zero_extend(pancestor[lca]);
+  }
+
+  // compress the path to speed up the subsequent calls
+  // to this function
+  usize node = j_prev;
+  while (true) {
+    if (node == lca) {
+      break;
+    }
+    usize next = util::zero_extend(pancestor[node]);
+    pancestor[node] = I(lca);
+    node = next;
+  }
+
+  return I(lca);
+}
+} // namespace _detail
+
+template<typename I>
+auto
+column_counts_req(proxsuite::linalg::veg::Tag<I> tag,
+                  isize n,
+                  isize nnz) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  using proxsuite::linalg::veg::dynstack::StackReq;
+  return StackReq{
+    isize{ sizeof(I) } * (1 + 5 * n + nnz),
+    alignof(I),
+  } & sparse::transpose_symbolic_req(tag, n);
+}
+
+template<typename I>
+void
+column_counts(I* counts,
+              SymbolicMatRef<I> a,
+              I const* parent,
+              I const* post,
+              DynStackMut stack) noexcept
+{
+  // https://youtu.be/uZKJPTo4dZs
+  using namespace _detail;
+  usize n = usize(a.nrows());
+  auto _at_work = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<I>{},
+                                               1 + 5 * isize(n) + a.nnz());
+  auto pat_work = _at_work.ptr_mut();
+  pat_work[0] = 0;
+  pat_work[n] = I(a.nnz());
+
+  SymbolicMatMut<I> at{
+    from_raw_parts, isize(n), isize(n),         a.nnz(),
+    pat_work,       nullptr,  pat_work + n + 1,
+  };
+  sparse::transpose_symbolic(at, a, stack);
+
+  auto patp = at.col_ptrs();
+  auto pati = at.row_indices();
+
+  auto pwork = pat_work + n + 1 + a.nnz();
+
+  auto pdelta = counts;
+
+  auto pfirst = pwork;
+  auto pmax_first = pwork + n;
+  auto pprev_leaf = pwork + 2 * n;
+  auto pancestor = pwork + 3 * n;
+
+  auto pcounts = counts;
+  auto ppost = post;
+  auto pparent = parent;
+
+  for (usize i = 0; i < 3 * n; ++i) {
+    pwork[i] = I(-1);
+  }
+  for (usize i = 0; i < n; ++i) {
+    pancestor[i] = I(i);
+  }
+
+  // for each column in a
+  for (usize k = 0; k < n; ++k) {
+    // in postordered fashion
+    auto j = util::zero_extend(ppost[k]);
+
+    // if first_j isn't computed, j must be a leaf
+    // because if it's not a leaf then first_j will be initialized from
+    // the init loop of its first descendant
+    //
+    // in which case initialize delta_j to 1
+    pdelta[j] = (pfirst[j] == I(-1)) ? I(1) : I(0);
+
+    // init loop
+    while (true) {
+      // while j is not a root, and the first descendant of j isn't computed
+      // set the first descendant of j to k, as well as all of its ancestors
+      // that don't yet have a first descendant
+      if (j == usize(-1) || pfirst[j] != I(-1)) {
+        break;
+      }
+      pfirst[j] = I(k);
+      j = util::sign_extend(pparent[j]);
+    }
+  }
+
+  // for each node
+  for (usize k = 0; k < n; ++k) {
+    // in postordered fashion
+    auto j = util::zero_extend(ppost[k]);
+
+    // if this node is the child of some other node
+    if (pparent[j] != I(-1)) {
+      // decrement the delta of that node
+      // corresponding to the correction term e_j
+      util::wrapping_dec(mut(pdelta[util::zero_extend(pparent[j])]));
+    }
+
+    auto col_start = util::zero_extend(patp[j]);
+    auto col_end = util::zero_extend(patp[j + 1]);
+
+    // iterate over lower triangular half of a
+    for (usize p = col_start; p < col_end; ++p) {
+      auto i = util::zero_extend(pati[p]);
+      I lca = _detail::least_common_ancestor( //
+        i,
+        j,
+        pfirst,
+        pmax_first,
+        pprev_leaf,
+        pancestor);
+
+      // if j is a leaf of T^i
+      if (lca != I(-2)) {
+        util::wrapping_inc(mut(pdelta[j]));
+
+        // if j is a subsequent leaf
+        if (lca != I(-1)) {
+          util::wrapping_dec(mut(pdelta[util::zero_extend(lca)]));
+        }
+      }
+    }
+
+    if (pparent[j] != -1) {
+      // set the ancestor of j
+      pancestor[j] = pparent[j];
+    }
+  }
+
+  // sum up the deltas
+  for (usize j = 0; j < n; ++j) {
+    if (parent[isize(j)] != I(-1)) {
+      pcounts[util::zero_extend(parent[isize(j)])] = util::wrapping_plus(
+        pcounts[util::zero_extend(parent[isize(j)])], pcounts[j]);
+    }
+  }
+}
+
+template<typename I>
+auto
+amd_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize /*n*/, isize nnz) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { nnz * isize{ sizeof(char) }, alignof(char) };
+}
+
+template<typename I>
+void
+amd(I* perm, SymbolicMatRef<I> mat, DynStackMut stack) noexcept
+{
+  // TODO: reimplement amd under BSD-3
+  // https://github.com/DrTimothyAldenDavis/SuiteSparse/tree/master/AMD
+
+  isize n = mat.nrows();
+  isize nnz = mat.nnz();
+
+  Eigen::PermutationMatrix<-1, -1, I> perm_eigen;
+  auto _ = stack.make_new(proxsuite::linalg::veg::Tag<char>{}, nnz);
+
+  Eigen::AMDOrdering<I>{}(
+    Eigen::Map<Eigen::SparseMatrix<char, Eigen::ColMajor, I> const>{
+      n,
+      n,
+      nnz,
+      mat.col_ptrs(),
+      mat.row_indices(),
+      _.ptr(),
+      mat.nnz_per_col(),
+    }
+      .template selfadjointView<Eigen::Upper>(),
+
+    perm_eigen);
+  std::memmove( //
+    perm,
+    perm_eigen.indices().data(),
+    usize(n) * sizeof(I));
+}
+
+namespace _detail {
+template<typename I>
+void
+inv_perm(I* perm_inv, I const* perm, isize n) noexcept
+{
+  for (usize i = 0; i < usize(n); ++i) {
+    perm_inv[util::zero_extend(perm[i])] = I(i);
+  }
+}
+
+template<typename I>
+auto
+symmetric_permute_symbolic_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
+                               isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { n * isize{ sizeof(I) }, alignof(I) };
+}
+template<typename I>
+auto
+symmetric_permute_req(proxsuite::linalg::veg::Tag<I> /*tag*/, isize n) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return { n * isize{ sizeof(I) }, alignof(I) };
+}
+
+template<typename I>
+void
+symmetric_permute_common(usize n,
+                         I const* pperm_inv,
+                         SymbolicMatRef<I> old_a,
+                         I* pnew_ap,
+                         I* pcol_counts)
+{
+  for (usize old_j = 0; old_j < n; ++old_j) {
+    usize new_j = util::zero_extend(pperm_inv[old_j]);
+
+    auto col_start = old_a.col_start(old_j);
+    auto col_end = old_a.col_end(old_j);
+
+    for (usize p = col_start; p < col_end; ++p) {
+      usize old_i = util::zero_extend(old_a.row_indices()[p]);
+
+      if (old_i <= old_j) {
+        usize new_i = util::zero_extend(pperm_inv[old_i]);
+        util::wrapping_inc(mut(pcol_counts[new_i > new_j ? new_i : new_j]));
+      }
+    }
+  }
+
+  pnew_ap[0] = I(0);
+  for (usize i = 0; i < n; ++i) {
+    pnew_ap[i + 1] =
+      util::checked_non_negative_plus(pnew_ap[i], pcol_counts[i]);
+    pcol_counts[i] = pnew_ap[i];
+  }
+}
+
+template<typename I>
+void
+symmetric_permute_symbolic(SymbolicMatMut<I> new_a,
+                           SymbolicMatRef<I> old_a,
+                           I const* perm_inv,
+                           DynStackMut stack) noexcept
+{
+
+  usize n = usize(new_a.nrows());
+
+  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, isize(n));
+  I* pcol_counts = _work.ptr_mut();
+
+  VEG_ASSERT(new_a.is_compressed());
+  auto pold_ai = old_a.row_indices();
+
+  auto pnew_ap = new_a.col_ptrs_mut();
+  auto pnew_ai = new_a.row_indices_mut();
+
+  auto pperm_inv = perm_inv;
+
+  _detail::symmetric_permute_common(n, pperm_inv, old_a, pnew_ap, pcol_counts);
+
+  auto pcurrent_row_index = pcol_counts;
+
+  for (usize old_j = 0; old_j < n; ++old_j) {
+    usize new_j = util::zero_extend(pperm_inv[old_j]);
+
+    auto col_start = old_a.col_start(old_j);
+    auto col_end = old_a.col_end(old_j);
+
+    for (usize p = col_start; p < col_end; ++p) {
+      usize old_i = util::zero_extend(pold_ai[p]);
+
+      if (old_i <= old_j) {
+        usize new_i = util::zero_extend(pperm_inv[old_i]);
+
+        usize new_max = new_i > new_j ? new_i : new_j;
+        usize new_min = new_i < new_j ? new_i : new_j;
+
+        auto row_idx = pcurrent_row_index[new_max];
+        pnew_ai[row_idx] = I(new_min);
+        pcurrent_row_index[new_max] = util::wrapping_plus(row_idx, I(1));
+      }
+    }
+  }
+}
+
+template<typename T, typename I>
+void
+symmetric_permute(MatMut<T, I> new_a,
+                  MatRef<T, I> old_a,
+                  I const* perm_inv,
+                  DynStackMut stack) noexcept(VEG_CONCEPT(nothrow_copyable<T>))
+{
+  usize n = usize(new_a.nrows());
+  auto _work = stack.make_new(proxsuite::linalg::veg::Tag<I>{}, isize(n));
+  I* pcol_counts = _work.ptr_mut();
+
+  VEG_ASSERT(new_a.is_compressed());
+  auto pold_ai = old_a.row_indices();
+
+  auto pnew_ap = new_a.col_ptrs_mut();
+  auto pnew_ai = new_a.row_indices_mut();
+
+  auto pperm_inv = perm_inv;
+
+  _detail::symmetric_permute_common(
+    n, pperm_inv, old_a.symbolic(), pnew_ap, pcol_counts);
+
+  auto pcurrent_row_index = pcol_counts;
+
+  auto pold_ax = old_a.values();
+  auto pnew_ax = new_a.values_mut();
+  for (usize old_j = 0; old_j < n; ++old_j) {
+    usize new_j = util::zero_extend(pperm_inv[old_j]);
+
+    auto col_start = old_a.col_start(old_j);
+    auto col_end = old_a.col_end(old_j);
+
+    for (usize p = col_start; p < col_end; ++p) {
+      usize old_i = util::zero_extend(pold_ai[p]);
+
+      if (old_i <= old_j) {
+        usize new_i = util::zero_extend(pperm_inv[old_i]);
+
+        usize new_max = new_i > new_j ? new_i : new_j;
+        usize new_min = new_i < new_j ? new_i : new_j;
+
+        auto row_idx = pcurrent_row_index[new_max];
+        pnew_ai[row_idx] = I(new_min);
+        pnew_ax[row_idx] = pold_ax[p];
+        pcurrent_row_index[new_max] = util::wrapping_plus(row_idx, I(1));
+      }
+    }
+  }
+}
+} // namespace _detail
+
+enum struct Ordering : unsigned char
+{
+  natural,
+  user_provided,
+  amd,
+  ENUM_END,
+};
+
+/*!
+ * Computes the stack memory requirements of symbolic factorization.
+ *
+ * @param n dimension of the matrix to be factorized.
+ * @param nnz number of non zeros of the matrix to be factorized.
+ * @param o the kind of permutation that is applied to the matrix before
+ * factorization.
+ */
+template<typename I>
+auto
+factorize_symbolic_req(proxsuite::linalg::veg::Tag<I> tag,
+                       isize n,
+                       isize nnz,
+                       Ordering o) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  using proxsuite::linalg::veg::dynstack::StackReq;
+  constexpr isize sz{ sizeof(I) };
+  constexpr isize al{ alignof(I) };
+
+  StackReq perm_req{ 0, al };
+  StackReq amd_req{ 0, al };
+  switch (o) {
+    case Ordering::natural:
+      break;
+    case Ordering::amd:
+      amd_req =
+        StackReq{ n * sz, al } & StackReq{ sparse::amd_req(tag, n, nnz) };
+      HEDLEY_FALL_THROUGH;
+    case Ordering::user_provided:
+      perm_req = perm_req & StackReq{ (n + 1 + nnz) * sz, al };
+      perm_req = perm_req & _detail::symmetric_permute_symbolic_req(tag, n);
+    default:
+      break;
+  }
+
+  StackReq parent_req = { n * sz, al };
+  StackReq post_req = { n * sz, al };
+
+  StackReq etree_req = sparse::etree_req(tag, n);
+  StackReq postorder_req = sparse::postorder_req(tag, n);
+  StackReq colcount_req = sparse::column_counts_req(tag, n, nnz);
+
+  return amd_req              //
+         | (perm_req          //
+            & (parent_req     //
+               & (etree_req   //
+                  | (post_req //
+                     & (postorder_req | colcount_req)))));
+}
+
+/*!
+ * Performs symbolic factorization and computed the number of non-zeros in each
+ * column of the cholesky factor of dimension `n`.
+ *
+ * @param nnz_per_col storage for non-zeros per column, of size `n`
+ * @param etree storage for elimination tree, of size `n`
+ * @param perm_inv storage for inverse permutation, of size `n`
+ * @param perm optionally user-provided permutation, either null or of size `n`
+ * @param a matrix to be symbolically factorized
+ * @param stack temporary allocation stack
+ */
+template<typename I>
+void
+factorize_symbolic_non_zeros(I* nnz_per_col,
+                             I* etree,
+                             I* perm_inv,
+                             I const* perm,
+                             SymbolicMatRef<I> a,
+                             DynStackMut stack) noexcept
+{
+
+  bool id_perm = perm_inv == nullptr;
+  bool user_perm = perm != nullptr;
+
+  Ordering o = user_perm ? Ordering::user_provided
+               : id_perm ? Ordering::natural
+                         : Ordering::amd;
+
+  proxsuite::linalg::veg::Tag<I> tag{};
+
+  usize n = usize(a.ncols());
+
+  switch (o) {
+    case Ordering::natural:
+      break;
+
+    case Ordering::amd: {
+      auto amd_perm = stack.make_new_for_overwrite(tag, isize(n));
+      sparse::amd(amd_perm.ptr_mut(), a, stack);
+      perm = amd_perm.ptr();
+    }
+      HEDLEY_FALL_THROUGH;
+    case Ordering::user_provided: {
+      _detail::inv_perm(perm_inv, perm, isize(n));
+    }
+    default:
+      break;
+  }
+
+  auto _permuted_a_col_ptrs =
+    stack //
+      .make_new_for_overwrite(tag, id_perm ? 0 : (a.ncols() + 1));
+  auto _permuted_a_row_indices =
+    stack //
+      .make_new_for_overwrite(tag, id_perm ? 0 : (a.nnz()));
+
+  if (!id_perm) {
+    _permuted_a_col_ptrs.as_mut()[0] = 0;
+    _permuted_a_col_ptrs.as_mut()[isize(n)] = I(a.nnz());
+    SymbolicMatMut<I> permuted_a{
+      from_raw_parts,
+      isize(n),
+      isize(n),
+      a.nnz(),
+      _permuted_a_col_ptrs.ptr_mut(),
+      nullptr,
+      _permuted_a_row_indices.ptr_mut(),
+    };
+    _detail::symmetric_permute_symbolic(permuted_a, a, perm_inv, stack);
+  }
+
+  SymbolicMatRef<I> permuted_a = id_perm ? a
+                                         : SymbolicMatRef<I>{
+                                             from_raw_parts,
+                                             isize(n),
+                                             isize(n),
+                                             a.nnz(),
+                                             _permuted_a_col_ptrs.ptr(),
+                                             nullptr,
+                                             _permuted_a_row_indices.ptr(),
+                                           };
+
+  sparse::etree(etree, permuted_a, stack);
+
+  auto _post = stack.make_new_for_overwrite(tag, isize(n));
+  sparse::postorder(_post.ptr_mut(), etree, isize(n), stack);
+  sparse::column_counts(nnz_per_col, permuted_a, etree, _post.ptr(), stack);
+}
+
+/*!
+ * Performs symbolic factorization and computed the column pointers for each
+ * column of the cholesky factor of dimension `n`.
+ *
+ * @param col_ptrs storage for column pointers, of size `n + 1`
+ * @param etree storage for elimination tree, of size `n`
+ * @param perm_inv storage for inverse permutation, of size `n`
+ * @param perm optionally user-provided permutation, either null or of size `n`
+ * @param a matrix to be symbolically factorized
+ * @param stack temporary allocation stack
+ */
+template<typename I>
+void
+factorize_symbolic_col_counts(I* col_ptrs,
+                              I* etree,
+                              I* perm_inv,
+                              I const* perm,
+                              SymbolicMatRef<I> a,
+                              DynStackMut stack) noexcept
+{
+
+  sparse::factorize_symbolic_non_zeros( //
+    col_ptrs + 1,
+    etree,
+    perm_inv,
+    perm,
+    a,
+    stack);
+
+  usize n = usize(a.ncols());
+  auto pcol_ptrs = col_ptrs;
+  pcol_ptrs[0] = I(0);
+  for (usize i = 0; i < n; ++i) {
+    pcol_ptrs[i + 1] =
+      util::checked_non_negative_plus(pcol_ptrs[i + 1], pcol_ptrs[i]);
+  }
+}
+
+/*!
+ * Computes the stack memory requirements of numerical factorization.
+ *
+ * @param n dimension of the matrix to be factorized.
+ * @param a_nnz number of non zeros of the matrix to be factorized.
+ * @param o the kind of permutation that is applied to the matrix before
+ * factorization.
+ */
+template<typename T, typename I>
+auto
+factorize_numeric_req(proxsuite::linalg::veg::Tag<T> /*ttag*/,
+                      proxsuite::linalg::veg::Tag<I> /*itag*/,
+                      isize n,
+                      isize a_nnz,
+                      Ordering o) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  using proxsuite::linalg::veg::dynstack::StackReq;
+
+  constexpr isize sz{ sizeof(I) };
+  constexpr isize al{ alignof(I) };
+
+  constexpr isize tsz{ sizeof(T) };
+  constexpr isize tal{ alignof(T) };
+
+  bool id_perm = o == Ordering::natural;
+
+  auto symb_perm_req = StackReq{ sz * (id_perm ? 0 : (n + 1 + a_nnz)), al };
+  auto num_perm_req = StackReq{ tsz * (id_perm ? 0 : a_nnz), tal };
+  return num_perm_req                         //
+         & (StackReq{ tsz * n, tal }          //
+            & (symb_perm_req                  //
+               & (StackReq{ 2 * n * sz, al }  //
+                  & (StackReq{ n * tsz, tal } //
+                     & StackReq{ n * isize{ sizeof(bool) }, alignof(bool) }))));
+}
+
+/*!
+ * Performs numerical `LDLT` factorization, assuming the symbolic factorization
+ * and column counts have already been computed. `L` and `D` are stored in the
+ * same matrix, with the elements of `D` replacing the implicit diagonal `1`
+ * element of each column of `L`.
+ *
+ * @param values pointer to the values of the factorization
+ * @param row_indices pointer to the row indices of the factorization
+ * @param diag_to_add pointer to a vector that is added to the diagonal of the
+ * matrix during factorization, if `diag_to_add` and `perm` are both non null
+ * @param perm pointer to the pre-computed permutation that is applied to
+ * `diag`.
+ * @param col_ptrs pointer to the already computed column pointers
+ * @param etree pointer to the already computed elimination tree
+ * @param perm_inv pointer to the already computed inverse permutation. Must be
+ * the inverse of `perm`
+ * @param a matrix to be factorized
+ * @param stack temporary allocation stack
+ */
+template<typename T, typename I>
+void
+factorize_numeric( //
+  T* values,
+  I* row_indices,
+  proxsuite::linalg::veg::DoNotDeduce<T const*> diag_to_add,
+  proxsuite::linalg::veg::DoNotDeduce<I const*> perm,
+  I const* col_ptrs,
+  I const* etree,
+  I const* perm_inv,
+  MatRef<T, I> a,
+  DynStackMut stack) noexcept(false)
+{
+  using namespace _detail;
+  isize n = a.nrows();
+
+  bool id_perm = perm_inv == nullptr;
+
+  proxsuite::linalg::veg::Tag<I> tag{};
+
+  auto _permuted_a_values = stack.make_new_for_overwrite(
+    proxsuite::linalg::veg::Tag<T>{}, id_perm ? 0 : a.nnz());
+
+  auto _x = stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<T>{}, n);
+
+  auto _permuted_a_col_ptrs =
+    stack.make_new_for_overwrite(tag, id_perm ? 0 : (a.ncols() + 1));
+  auto _permuted_a_row_indices =
+    stack.make_new_for_overwrite(tag, id_perm ? 0 : a.nnz());
+
+  if (!id_perm) {
+    _permuted_a_col_ptrs.as_mut()[0] = 0;
+    _permuted_a_col_ptrs.as_mut()[n] = I(a.nnz());
+    MatMut<T, I> permuted_a{
+      from_raw_parts,
+      n,
+      n,
+      a.nnz(),
+      _permuted_a_col_ptrs.ptr_mut(),
+      nullptr,
+      _permuted_a_row_indices.ptr_mut(),
+      _permuted_a_values.ptr_mut(),
+    };
+    _detail::symmetric_permute(permuted_a, a, perm_inv, stack);
+  }
+
+  MatRef<T, I> permuted_a = id_perm ? a
+                                    : MatRef<T, I>{
+                                        from_raw_parts,
+                                        isize(n),
+                                        isize(n),
+                                        a.nnz(),
+                                        _permuted_a_col_ptrs.ptr(),
+                                        nullptr,
+                                        _permuted_a_row_indices.ptr(),
+                                        _permuted_a_values.ptr(),
+                                      };
+
+  auto _current_row_index = stack.make_new_for_overwrite(tag, n);
+  auto _ereach_stack_storage = stack.make_new_for_overwrite(tag, n);
+
+  I* pcurrent_row_index = _current_row_index.ptr_mut();
+  T* px = _x.ptr_mut();
+
+  std::memcpy( //
+    pcurrent_row_index,
+    col_ptrs,
+    usize(n) * sizeof(I));
+  for (usize i = 0; i < usize(n); ++i) {
+    px[i] = 0;
+  }
+
+  // compute the iter-th row of L using the iter-th column of permuted_a
+  // the diagonal element is filled with the diagonal of D instead of 1
+  I const* plp = col_ptrs;
+
+  auto _marked = stack.make_new(proxsuite::linalg::veg::Tag<bool>{}, n);
+  for (usize iter = 0; iter < usize(n); ++iter) {
+    usize ereach_count = 0;
+    auto ereach_stack = _detail::ereach(ereach_count,
+                                        _ereach_stack_storage.ptr_mut(),
+                                        permuted_a.symbolic(),
+                                        etree,
+                                        isize(iter),
+                                        _marked.ptr_mut());
+
+    auto pereach_stack = ereach_stack;
+
+    I const* pai = permuted_a.row_indices();
+    T const* pax = permuted_a.values();
+
+    I* pli = row_indices;
+    T* plx = values;
+
+    {
+      auto col_start = permuted_a.col_start(iter);
+      auto col_end = permuted_a.col_end(iter);
+
+      // scatter permuted_a column into x
+      // untouched columns are already zeroed
+
+      for (usize p = col_start; p < col_end; ++p) {
+        auto i = util::zero_extend(pai[p]);
+        px[i] = pax[p];
+      }
+    }
+    T d = px[iter] + ((diag_to_add == nullptr || perm == nullptr)
+                        ? T(0)
+                        : diag_to_add[util::zero_extend(perm[iter])]);
+
+    // zero for next iteration
+    px[iter] = 0;
+
+    for (usize q = 0; q < ereach_count; ++q) {
+      usize j = util::zero_extend(pereach_stack[q]);
+      auto col_start = util::zero_extend(plp[j]);
+      auto row_idx = util::zero_extend(pcurrent_row_index[j]) + 1;
+
+      T const xj = px[j];
+      T const dj = plx[col_start];
+      T const lkj = xj / dj;
+
+      // zero for the next iteration
+      px[j] = 0;
+
+      // skip first element, to put diagonal there later
+      for (usize p = col_start + 1; p < row_idx; ++p) {
+        auto i = util::zero_extend(pli[p]);
+        px[i] -= plx[p] * xj;
+      }
+
+      d -= lkj * xj;
+
+      pli[row_idx] = I(iter);
+      plx[row_idx] = lkj;
+      pcurrent_row_index[j] = I(row_idx);
+    }
+    {
+      auto col_start = util::zero_extend(plp[iter]);
+      pli[col_start] = I(iter);
+      plx[col_start] = d;
+    }
+  }
+}
+} // namespace sparse
+} // namespace linalg
+} // namespace proxsuite
+#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_FACTORIZE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/sparse/rowmod.hpp

 * *Ordering differences only*

```diff
@@ -1,443 +1,443 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP
-#define PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP
-
-#include "proxsuite/linalg/sparse/update.hpp"
-#include <algorithm>
-
-namespace proxsuite {
-namespace linalg {
-namespace sparse {
-
-/*!
- * Computes the memory requirements for deleting a row and column for the ldlt
- * factors
- *
- * @param n : dimension of the matrix
- * @param max_nnz : upper bound of non zero counts over the columns of the
- * matrix. n is always a valid value.
- */
-template<typename T, typename I>
-auto
-delete_row_req( //
-  proxsuite::linalg::veg::Tag<T> /*tag*/,
-  proxsuite::linalg::veg::Tag<I> /*tag*/,
-  isize n,
-  isize max_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return sparse::rank1_update_req(proxsuite::linalg::veg::Tag<T>{},
-                                  proxsuite::linalg::veg::Tag<I>{},
-                                  n,
-                                  true,
-                                  max_nnz);
-}
-
-/*!
- * Given the ldlt factors of matrix a, computes the ldlt factors of the matrix a
- * with row and column at position pos replaced by those of the identity matrix
- * It returns a view of the updated factors.
- *
- * @param ld : the ldlt factors
- * @param etree pointer to the elimination tree
- * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
- * the permutation is assumed to be the identity.
- * @param pos position of the row and column to be deleted
- * @param stack is the memory stack
- */
-template<typename T, typename I>
-auto
-delete_row(MatMut<T, I> ld,
-           I* etree,
-           I const* perm_inv,
-           isize pos,
-           DynStackMut stack) noexcept(false) -> MatMut<T, I>
-{
-  // step 1: delete row k from each column
-  VEG_ASSERT(!ld.is_compressed());
-
-  // we're actually deleting perm_inv[k], so that k is deleted in the permuted
-  // matrix
-  usize permuted_pos =
-    perm_inv == nullptr ? usize(pos) : util::zero_extend(perm_inv[pos]);
-
-  auto petree = etree;
-  I* pldi = ld.row_indices_mut();
-  T* pldx = ld.values_mut();
-  I* pldnz = ld.nnz_per_col_mut();
-
-  for (usize j = 0; j < permuted_pos; ++j) {
-    auto col_start = ld.col_start(j) + 1;
-    auto col_end = ld.col_end(j);
-    // search for the first row in column j greater than or equal to k
-    auto it =
-      std::lower_bound(pldi + col_start, pldi + col_end, I(permuted_pos));
-
-    // if an element was found, and it is equal to k
-    if ((it != (pldi + col_end)) && *it == I(permuted_pos)) {
-      usize it_pos = usize(it - (pldi + col_start));
-      usize count = (col_end - col_start - it_pos);
-      // shift all the row indices back by one position
-      // to delete row k
-      std::memmove(it, it + 1, count * sizeof(I));
-      T* itx = pldx + col_start + it_pos;
-
-      VEG_CHECK_CONCEPT(trivially_copyable<T>);
-      // shift all the values back by one position
-      std::memmove(itx, itx + 1, count * sizeof(T));
-
-      // decrement the non zero count
-      --pldnz[j];
-      ld._set_nnz(ld.nnz() - 1);
-
-      // adjust the parent of j in the elimination tree if necessary
-      if (petree[j] == I(permuted_pos)) {
-        VEG_ASSERT(it_pos == 0);
-        if (pldnz[j] > 1) {
-          petree[j] = *it;
-        } else {
-          petree[j] = I(-1);
-        }
-      }
-    }
-  }
-
-  // step 2: set d_kk = 1
-  T d_old = ld.values()[ld.col_start(permuted_pos)];
-  ld.values_mut()[ld.col_start(permuted_pos)] = 1;
-
-  // step 3: perform rank update
-  isize len = isize(util::zero_extend(ld.nnz_per_col()[permuted_pos])) - 1;
-  ld = sparse::rank1_update<T, I>( //
-    ld,
-    etree,
-    static_cast<I const*>(nullptr),
-    VecRef<T, I>{
-      from_raw_parts,
-      ld.nrows(),
-      len,
-      pldi + ld.col_start(permuted_pos) + 1,
-      pldx + ld.col_start(permuted_pos) + 1,
-    },
-    d_old,
-    stack);
-  // step 4: delete col k_
-  ld.nnz_per_col_mut()[permuted_pos] = 1;
-  petree[permuted_pos] = I(-1);
-  return ld;
-}
-/*!
- * Computes the memory requirements for adding a row and column for the ldlt
- * factors
- *
- * @param n : dimension of the matrix
- * @param id_perm : whether the permutation corresponds to the identity
- * @param nnz : number of non zero elements in the added vector
- * @param max_nnz : upper bound of non zero counts over the columns of the
- * matrix. n is always a valid value.
- */
-template<typename T, typename I>
-auto
-add_row_req( //
-  proxsuite::linalg::veg::Tag<T> /*tag*/,
-  proxsuite::linalg::veg::Tag<I> /*tag*/,
-  isize n,
-  bool id_perm,
-  isize nnz,
-  isize max_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  using proxsuite::linalg::veg::dynstack::StackReq;
-  auto numerical_work = StackReq{ n * isize{ sizeof(T) }, isize{ alignof(T) } };
-  auto permuted_indices =
-    StackReq{ (id_perm ? 0 : nnz) * isize{ sizeof(I) }, isize{ alignof(I) } };
-  auto pattern_diff = StackReq{ n * isize{ sizeof(I) }, isize{ alignof(I) } };
-  auto merge =
-    merge_second_col_into_first_req(proxsuite::linalg::veg::Tag<I>{}, n);
-  auto update = sparse::rank1_update_req(proxsuite::linalg::veg::Tag<T>{},
-                                         proxsuite::linalg::veg::Tag<I>{},
-                                         n,
-                                         true,
-                                         max_nnz);
-
-  auto req = numerical_work;
-  req = req & permuted_indices;
-  req = req & pattern_diff;
-  req = req & merge;
-  req = req | update;
-
-  return req;
-}
-/*!
- * Given the ldlt factors of matrix a, computes the ldlt factors of the matrix a
- * with added row and column at position pos. It is assumed that the row and
- * column are empty except the diagonal element. It returns a view of the
- * updated factors.
- *
- * @param ld : the ldlt factors
- * @param etree pointer to the elimination tree
- * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
- * the permutation is assumed to be the identity.
- * @param pos position of the row and column to be added
- * @param new_col : new column to be added without the diagonal element (of size
- * nnz-1)
- * @param diag_element : diagonal element of the added row and column
- * @param stack is the memory stack
- */
-template<typename T, typename I>
-auto
-add_row(MatMut<T, I> ld,
-        I* etree,
-        I const* perm_inv,
-        isize pos,
-        VecRef<T, I> new_col,
-        proxsuite::linalg::veg::DoNotDeduce<T> diag_element,
-        DynStackMut stack) noexcept(false) -> MatMut<T, I>
-{
-  VEG_ASSERT(!ld.is_compressed());
-  bool id_perm = perm_inv == nullptr;
-  auto zx = util::zero_extend;
-
-  I* pldp = ld.col_ptrs_mut();
-  I* pldnz = ld.nnz_per_col_mut();
-  I* pldi = ld.row_indices_mut();
-  T* pldx = ld.values_mut();
-
-  // actually inserting in the position perm_inv[k] so that row k is added in
-  // the permuted matrix
-  usize permuted_pos = id_perm ? usize(pos) : zx(perm_inv[pos]);
-  VEG_ASSERT(pldnz[permuted_pos] == 1);
-
-  {
-    // allocate workspace for numerical step, storage for the k-th row and k-th
-    // column of the new matrix
-    auto _lx2_storage = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<T>{}, ld.nrows());
-    auto plx2_storage = _lx2_storage.ptr_mut();
-
-    // allocate workspace for permuted row indices of the new column if
-    // necessary
-    auto _new_col_permuted_indices = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<I>{}, id_perm ? isize(0) : new_col.nnz());
-
-    auto new_col_permuted_indices =
-      id_perm ? new_col.row_indices() : _new_col_permuted_indices.ptr();
-
-    // copy and sort permuted row indices
-    if (!id_perm) {
-      I* pnew_col_permuted_indices = _new_col_permuted_indices.ptr_mut();
-      for (usize k = 0; k < usize(new_col.nnz()); ++k) {
-        usize i = zx(new_col.row_indices()[k]);
-        pnew_col_permuted_indices[k] = perm_inv[i];
-      }
-      std::sort(pnew_col_permuted_indices,
-                pnew_col_permuted_indices + new_col.nnz());
-    }
-
-    // allocate workspace for non-zero pattern of k-th row
-    auto _l12_nnz_pattern = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<I>{}, isize(permuted_pos));
-    auto _difference = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<I>{}, ld.nrows() - isize(permuted_pos));
-    auto pdifference = _difference.ptr_mut();
-
-    auto pl12_nnz_pattern = _l12_nnz_pattern.ptr_mut();
-    usize l12_nnz_pattern_count = 0;
-
-    // the non-zero pattern is the set of columns reachable from the non-zero
-    // pattern of the added column through graph of L_{1..k,1..k}
-    // instead of graph traversal, we can use the k-th elimination subtree as we
-    // did in the initial factorization step
-
-    // for each row in the added column
-    {
-      auto _visited = stack.make_new(proxsuite::linalg::veg::Tag<bool>{},
-                                     isize(permuted_pos));
-      bool* visited = _visited.ptr_mut();
-      for (usize p = 0; p < usize(new_col.nnz()); ++p) {
-        auto j = zx(new_col_permuted_indices[p]);
-        if (j >= permuted_pos) {
-          break;
-        }
-
-        // add the ancestors of the corresponding column
-        // ancestors are not sorted, but they are added in topological order,
-        // which suffices for the triangular solve
-        while (true) {
-          if (visited[j]) {
-            break;
-          }
-          visited[j] = true;
-          pl12_nnz_pattern[l12_nnz_pattern_count] = I(j);
-          ++l12_nnz_pattern_count;
-
-          j = util::sign_extend(etree[j]);
-          if (j == usize(-1) || j >= permuted_pos || visited[j]) {
-            break;
-          }
-        }
-      }
-    }
-    std::sort(pl12_nnz_pattern, pl12_nnz_pattern + l12_nnz_pattern_count);
-
-    // zero the elements in the non-zero pattern of the solution (new k-th row)
-    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
-      plx2_storage[zx(pl12_nnz_pattern[p])] = 0;
-    }
-
-    // insert the rhs of the k-th row triangular system in the top part of the
-    // storage, and the bottom part of the added column in the bottom part of
-    // the storage
-    for (usize p = 0; p < usize(new_col.nnz()); ++p) {
-      auto j = zx(new_col.row_indices()[p]);
-      auto permuted_j = id_perm ? j : zx(perm_inv[j]);
-      plx2_storage[permuted_j] = new_col.values()[p];
-
-      // add the row indices of the bottom part of the added column, to the
-      // k-th column of L
-      if (permuted_j > permuted_pos) {
-        usize nz = zx(pldnz[permuted_pos]);
-        VEG_ASSERT(nz < (zx(pldp[permuted_pos + 1]) - zx(pldp[permuted_pos])));
-        pldi[zx(pldp[permuted_pos]) + nz] = I(permuted_j);
-        ++pldnz[permuted_pos];
-        ld._set_nnz(ld.nnz() + 1);
-      }
-    }
-    // sort the added row indices
-    std::sort(pldi + zx(pldp[permuted_pos]) + 1,
-              pldi + zx(pldp[permuted_pos]) + zx(pldnz[permuted_pos]));
-
-    // TODO: fuse loops?
-
-    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
-      usize j = zx(pl12_nnz_pattern[p]);
-      auto col_start = ld.col_start(j);
-      auto col_end = ld.col_end(j);
-
-      // update the pattern of the k-th column of L, with that of the bottom
-      // part of the j-th column of L, ignoring the elements less than or equal
-      // to k
-      VEG_BIND(auto,
-               (_, new_current_col, computed_difference),
-               sparse::merge_second_col_into_first(
-                 pdifference,
-                 static_cast<T*>(nullptr),
-                 pldi + (zx(pldp[permuted_pos]) + 1),
-                 isize(zx(pldp[permuted_pos + 1]) - zx(pldp[permuted_pos])) - 1,
-                 pldnz[permuted_pos] - 1,
-                 {
-                   unsafe,
-                   from_raw_parts,
-                   pldi + (zx(pldp[j]) + 1),
-                   isize(zx(pldnz[j])) - 1,
-                 },
-                 I(permuted_pos),
-                 false,
-                 stack));
-      (void)_;
-      (void)new_current_col;
-
-      // update column and global non-zero count
-      pldnz[permuted_pos] += I(computed_difference.len());
-      ld._set_nnz(ld.nnz() + computed_difference.len());
-
-      for (usize q = 0; q < usize(computed_difference.len()); ++q) {
-        plx2_storage[zx(computed_difference.ptr()[q])] = 0;
-      }
-
-      // perform triangular solve and matrix vector product simultaneously
-      auto const xj = plx2_storage[j];
-      for (usize q = col_start + 1; q < col_end; ++q) {
-        auto i = zx(pldi[q]);
-        plx2_storage[i] -= pldx[q] * xj;
-      }
-    }
-
-    // insert the k-th row into L
-    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
-      // for each column in the non-zero pattern of the k-th row
-
-      usize j = zx(pl12_nnz_pattern[p]);
-      auto col_start = ld.col_start(j);
-      auto col_end = ld.col_end(j);
-      T d = pldx[col_start];
-      T l12_elem = plx2_storage[j];
-      diag_element -= l12_elem * l12_elem / d;
-
-      // check that we have enough space to insert one element
-      VEG_ASSERT(zx(pldnz[j]) < (zx(pldp[j + 1]) - zx(pldp[j])));
-
-      // find the first element greater than k
-      auto it =
-        std::lower_bound(pldi + col_start, pldi + col_end, I(permuted_pos));
-
-      // if it is the first element, update the elimination tree so that k is
-      // the new parent of column j
-      if (it == (pldi + col_start + 1)) {
-        etree[j] = I(permuted_pos);
-      }
-
-      // shift the row indices  up by one position to provide enough space for
-      // the new element
-      std::memmove( //
-        it + 1,
-        it,
-        usize((pldi + col_end) - it) * sizeof(I));
-
-      VEG_CHECK_CONCEPT(trivially_copyable<T>);
-
-      // shift the values  up by one position to provide enough space for the
-      // new element
-      std::memmove( //
-        pldx + (it - pldi) + 1,
-        pldx + (it - pldi),
-        usize((pldi + col_end) - it) * sizeof(T));
-
-      // insert the new row index k
-      *it = I(permuted_pos);
-      // insert the new corresponding value
-      *(pldx + (it - pldi)) = l12_elem / d;
-      // update the non-zero count
-      ++pldnz[j];
-      ld._set_nnz(ld.nnz() + 1);
-    }
-
-    // insert the k-th column of L
-    {
-      usize col_start = ld.col_start(permuted_pos);
-      usize col_end = ld.col_end(permuted_pos);
-      pldx[col_start] = diag_element;
-      for (usize p = col_start + 1; p < col_end; ++p) {
-        pldx[p] = plx2_storage[zx(pldi[p])] / diag_element;
-      }
-    }
-  }
-
-  // set the parent of the k-th column of L
-  if (pldnz[permuted_pos] > 1) {
-    etree[permuted_pos] = pldi[ld.col_start(permuted_pos) + 1];
-  }
-
-  isize len = isize(util::zero_extend(ld.nnz_per_col()[permuted_pos])) - 1;
-  // perform the rank update with the newly added column
-  ld = sparse::rank1_update<T, I>(ld,
-                                  etree,
-                                  static_cast<I const*>(nullptr),
-                                  VecRef<T, I>{
-                                    from_raw_parts,
-                                    ld.nrows(),
-                                    len,
-                                    pldi + ld.col_start(permuted_pos) + 1,
-                                    pldx + ld.col_start(permuted_pos) + 1,
-                                  },
-                                  -diag_element,
-                                  stack);
-
-  return ld;
-}
-} // namespace sparse
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP
+#define PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP
+
+#include "proxsuite/linalg/sparse/update.hpp"
+#include <algorithm>
+
+namespace proxsuite {
+namespace linalg {
+namespace sparse {
+
+/*!
+ * Computes the memory requirements for deleting a row and column for the ldlt
+ * factors
+ *
+ * @param n : dimension of the matrix
+ * @param max_nnz : upper bound of non zero counts over the columns of the
+ * matrix. n is always a valid value.
+ */
+template<typename T, typename I>
+auto
+delete_row_req( //
+  proxsuite::linalg::veg::Tag<T> /*tag*/,
+  proxsuite::linalg::veg::Tag<I> /*tag*/,
+  isize n,
+  isize max_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return sparse::rank1_update_req(proxsuite::linalg::veg::Tag<T>{},
+                                  proxsuite::linalg::veg::Tag<I>{},
+                                  n,
+                                  true,
+                                  max_nnz);
+}
+
+/*!
+ * Given the ldlt factors of matrix a, computes the ldlt factors of the matrix a
+ * with row and column at position pos replaced by those of the identity matrix
+ * It returns a view of the updated factors.
+ *
+ * @param ld : the ldlt factors
+ * @param etree pointer to the elimination tree
+ * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
+ * the permutation is assumed to be the identity.
+ * @param pos position of the row and column to be deleted
+ * @param stack is the memory stack
+ */
+template<typename T, typename I>
+auto
+delete_row(MatMut<T, I> ld,
+           I* etree,
+           I const* perm_inv,
+           isize pos,
+           DynStackMut stack) noexcept(false) -> MatMut<T, I>
+{
+  // step 1: delete row k from each column
+  VEG_ASSERT(!ld.is_compressed());
+
+  // we're actually deleting perm_inv[k], so that k is deleted in the permuted
+  // matrix
+  usize permuted_pos =
+    perm_inv == nullptr ? usize(pos) : util::zero_extend(perm_inv[pos]);
+
+  auto petree = etree;
+  I* pldi = ld.row_indices_mut();
+  T* pldx = ld.values_mut();
+  I* pldnz = ld.nnz_per_col_mut();
+
+  for (usize j = 0; j < permuted_pos; ++j) {
+    auto col_start = ld.col_start(j) + 1;
+    auto col_end = ld.col_end(j);
+    // search for the first row in column j greater than or equal to k
+    auto it =
+      std::lower_bound(pldi + col_start, pldi + col_end, I(permuted_pos));
+
+    // if an element was found, and it is equal to k
+    if ((it != (pldi + col_end)) && *it == I(permuted_pos)) {
+      usize it_pos = usize(it - (pldi + col_start));
+      usize count = (col_end - col_start - it_pos);
+      // shift all the row indices back by one position
+      // to delete row k
+      std::memmove(it, it + 1, count * sizeof(I));
+      T* itx = pldx + col_start + it_pos;
+
+      VEG_CHECK_CONCEPT(trivially_copyable<T>);
+      // shift all the values back by one position
+      std::memmove(itx, itx + 1, count * sizeof(T));
+
+      // decrement the non zero count
+      --pldnz[j];
+      ld._set_nnz(ld.nnz() - 1);
+
+      // adjust the parent of j in the elimination tree if necessary
+      if (petree[j] == I(permuted_pos)) {
+        VEG_ASSERT(it_pos == 0);
+        if (pldnz[j] > 1) {
+          petree[j] = *it;
+        } else {
+          petree[j] = I(-1);
+        }
+      }
+    }
+  }
+
+  // step 2: set d_kk = 1
+  T d_old = ld.values()[ld.col_start(permuted_pos)];
+  ld.values_mut()[ld.col_start(permuted_pos)] = 1;
+
+  // step 3: perform rank update
+  isize len = isize(util::zero_extend(ld.nnz_per_col()[permuted_pos])) - 1;
+  ld = sparse::rank1_update<T, I>( //
+    ld,
+    etree,
+    static_cast<I const*>(nullptr),
+    VecRef<T, I>{
+      from_raw_parts,
+      ld.nrows(),
+      len,
+      pldi + ld.col_start(permuted_pos) + 1,
+      pldx + ld.col_start(permuted_pos) + 1,
+    },
+    d_old,
+    stack);
+  // step 4: delete col k_
+  ld.nnz_per_col_mut()[permuted_pos] = 1;
+  petree[permuted_pos] = I(-1);
+  return ld;
+}
+/*!
+ * Computes the memory requirements for adding a row and column for the ldlt
+ * factors
+ *
+ * @param n : dimension of the matrix
+ * @param id_perm : whether the permutation corresponds to the identity
+ * @param nnz : number of non zero elements in the added vector
+ * @param max_nnz : upper bound of non zero counts over the columns of the
+ * matrix. n is always a valid value.
+ */
+template<typename T, typename I>
+auto
+add_row_req( //
+  proxsuite::linalg::veg::Tag<T> /*tag*/,
+  proxsuite::linalg::veg::Tag<I> /*tag*/,
+  isize n,
+  bool id_perm,
+  isize nnz,
+  isize max_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  using proxsuite::linalg::veg::dynstack::StackReq;
+  auto numerical_work = StackReq{ n * isize{ sizeof(T) }, isize{ alignof(T) } };
+  auto permuted_indices =
+    StackReq{ (id_perm ? 0 : nnz) * isize{ sizeof(I) }, isize{ alignof(I) } };
+  auto pattern_diff = StackReq{ n * isize{ sizeof(I) }, isize{ alignof(I) } };
+  auto merge =
+    merge_second_col_into_first_req(proxsuite::linalg::veg::Tag<I>{}, n);
+  auto update = sparse::rank1_update_req(proxsuite::linalg::veg::Tag<T>{},
+                                         proxsuite::linalg::veg::Tag<I>{},
+                                         n,
+                                         true,
+                                         max_nnz);
+
+  auto req = numerical_work;
+  req = req & permuted_indices;
+  req = req & pattern_diff;
+  req = req & merge;
+  req = req | update;
+
+  return req;
+}
+/*!
+ * Given the ldlt factors of matrix a, computes the ldlt factors of the matrix a
+ * with added row and column at position pos. It is assumed that the row and
+ * column are empty except the diagonal element. It returns a view of the
+ * updated factors.
+ *
+ * @param ld : the ldlt factors
+ * @param etree pointer to the elimination tree
+ * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
+ * the permutation is assumed to be the identity.
+ * @param pos position of the row and column to be added
+ * @param new_col : new column to be added without the diagonal element (of size
+ * nnz-1)
+ * @param diag_element : diagonal element of the added row and column
+ * @param stack is the memory stack
+ */
+template<typename T, typename I>
+auto
+add_row(MatMut<T, I> ld,
+        I* etree,
+        I const* perm_inv,
+        isize pos,
+        VecRef<T, I> new_col,
+        proxsuite::linalg::veg::DoNotDeduce<T> diag_element,
+        DynStackMut stack) noexcept(false) -> MatMut<T, I>
+{
+  VEG_ASSERT(!ld.is_compressed());
+  bool id_perm = perm_inv == nullptr;
+  auto zx = util::zero_extend;
+
+  I* pldp = ld.col_ptrs_mut();
+  I* pldnz = ld.nnz_per_col_mut();
+  I* pldi = ld.row_indices_mut();
+  T* pldx = ld.values_mut();
+
+  // actually inserting in the position perm_inv[k] so that row k is added in
+  // the permuted matrix
+  usize permuted_pos = id_perm ? usize(pos) : zx(perm_inv[pos]);
+  VEG_ASSERT(pldnz[permuted_pos] == 1);
+
+  {
+    // allocate workspace for numerical step, storage for the k-th row and k-th
+    // column of the new matrix
+    auto _lx2_storage = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<T>{}, ld.nrows());
+    auto plx2_storage = _lx2_storage.ptr_mut();
+
+    // allocate workspace for permuted row indices of the new column if
+    // necessary
+    auto _new_col_permuted_indices = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<I>{}, id_perm ? isize(0) : new_col.nnz());
+
+    auto new_col_permuted_indices =
+      id_perm ? new_col.row_indices() : _new_col_permuted_indices.ptr();
+
+    // copy and sort permuted row indices
+    if (!id_perm) {
+      I* pnew_col_permuted_indices = _new_col_permuted_indices.ptr_mut();
+      for (usize k = 0; k < usize(new_col.nnz()); ++k) {
+        usize i = zx(new_col.row_indices()[k]);
+        pnew_col_permuted_indices[k] = perm_inv[i];
+      }
+      std::sort(pnew_col_permuted_indices,
+                pnew_col_permuted_indices + new_col.nnz());
+    }
+
+    // allocate workspace for non-zero pattern of k-th row
+    auto _l12_nnz_pattern = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<I>{}, isize(permuted_pos));
+    auto _difference = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<I>{}, ld.nrows() - isize(permuted_pos));
+    auto pdifference = _difference.ptr_mut();
+
+    auto pl12_nnz_pattern = _l12_nnz_pattern.ptr_mut();
+    usize l12_nnz_pattern_count = 0;
+
+    // the non-zero pattern is the set of columns reachable from the non-zero
+    // pattern of the added column through graph of L_{1..k,1..k}
+    // instead of graph traversal, we can use the k-th elimination subtree as we
+    // did in the initial factorization step
+
+    // for each row in the added column
+    {
+      auto _visited = stack.make_new(proxsuite::linalg::veg::Tag<bool>{},
+                                     isize(permuted_pos));
+      bool* visited = _visited.ptr_mut();
+      for (usize p = 0; p < usize(new_col.nnz()); ++p) {
+        auto j = zx(new_col_permuted_indices[p]);
+        if (j >= permuted_pos) {
+          break;
+        }
+
+        // add the ancestors of the corresponding column
+        // ancestors are not sorted, but they are added in topological order,
+        // which suffices for the triangular solve
+        while (true) {
+          if (visited[j]) {
+            break;
+          }
+          visited[j] = true;
+          pl12_nnz_pattern[l12_nnz_pattern_count] = I(j);
+          ++l12_nnz_pattern_count;
+
+          j = util::sign_extend(etree[j]);
+          if (j == usize(-1) || j >= permuted_pos || visited[j]) {
+            break;
+          }
+        }
+      }
+    }
+    std::sort(pl12_nnz_pattern, pl12_nnz_pattern + l12_nnz_pattern_count);
+
+    // zero the elements in the non-zero pattern of the solution (new k-th row)
+    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
+      plx2_storage[zx(pl12_nnz_pattern[p])] = 0;
+    }
+
+    // insert the rhs of the k-th row triangular system in the top part of the
+    // storage, and the bottom part of the added column in the bottom part of
+    // the storage
+    for (usize p = 0; p < usize(new_col.nnz()); ++p) {
+      auto j = zx(new_col.row_indices()[p]);
+      auto permuted_j = id_perm ? j : zx(perm_inv[j]);
+      plx2_storage[permuted_j] = new_col.values()[p];
+
+      // add the row indices of the bottom part of the added column, to the
+      // k-th column of L
+      if (permuted_j > permuted_pos) {
+        usize nz = zx(pldnz[permuted_pos]);
+        VEG_ASSERT(nz < (zx(pldp[permuted_pos + 1]) - zx(pldp[permuted_pos])));
+        pldi[zx(pldp[permuted_pos]) + nz] = I(permuted_j);
+        ++pldnz[permuted_pos];
+        ld._set_nnz(ld.nnz() + 1);
+      }
+    }
+    // sort the added row indices
+    std::sort(pldi + zx(pldp[permuted_pos]) + 1,
+              pldi + zx(pldp[permuted_pos]) + zx(pldnz[permuted_pos]));
+
+    // TODO: fuse loops?
+
+    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
+      usize j = zx(pl12_nnz_pattern[p]);
+      auto col_start = ld.col_start(j);
+      auto col_end = ld.col_end(j);
+
+      // update the pattern of the k-th column of L, with that of the bottom
+      // part of the j-th column of L, ignoring the elements less than or equal
+      // to k
+      VEG_BIND(auto,
+               (_, new_current_col, computed_difference),
+               sparse::merge_second_col_into_first(
+                 pdifference,
+                 static_cast<T*>(nullptr),
+                 pldi + (zx(pldp[permuted_pos]) + 1),
+                 isize(zx(pldp[permuted_pos + 1]) - zx(pldp[permuted_pos])) - 1,
+                 pldnz[permuted_pos] - 1,
+                 {
+                   unsafe,
+                   from_raw_parts,
+                   pldi + (zx(pldp[j]) + 1),
+                   isize(zx(pldnz[j])) - 1,
+                 },
+                 I(permuted_pos),
+                 false,
+                 stack));
+      (void)_;
+      (void)new_current_col;
+
+      // update column and global non-zero count
+      pldnz[permuted_pos] += I(computed_difference.len());
+      ld._set_nnz(ld.nnz() + computed_difference.len());
+
+      for (usize q = 0; q < usize(computed_difference.len()); ++q) {
+        plx2_storage[zx(computed_difference.ptr()[q])] = 0;
+      }
+
+      // perform triangular solve and matrix vector product simultaneously
+      auto const xj = plx2_storage[j];
+      for (usize q = col_start + 1; q < col_end; ++q) {
+        auto i = zx(pldi[q]);
+        plx2_storage[i] -= pldx[q] * xj;
+      }
+    }
+
+    // insert the k-th row into L
+    for (usize p = 0; p < l12_nnz_pattern_count; ++p) {
+      // for each column in the non-zero pattern of the k-th row
+
+      usize j = zx(pl12_nnz_pattern[p]);
+      auto col_start = ld.col_start(j);
+      auto col_end = ld.col_end(j);
+      T d = pldx[col_start];
+      T l12_elem = plx2_storage[j];
+      diag_element -= l12_elem * l12_elem / d;
+
+      // check that we have enough space to insert one element
+      VEG_ASSERT(zx(pldnz[j]) < (zx(pldp[j + 1]) - zx(pldp[j])));
+
+      // find the first element greater than k
+      auto it =
+        std::lower_bound(pldi + col_start, pldi + col_end, I(permuted_pos));
+
+      // if it is the first element, update the elimination tree so that k is
+      // the new parent of column j
+      if (it == (pldi + col_start + 1)) {
+        etree[j] = I(permuted_pos);
+      }
+
+      // shift the row indices  up by one position to provide enough space for
+      // the new element
+      std::memmove( //
+        it + 1,
+        it,
+        usize((pldi + col_end) - it) * sizeof(I));
+
+      VEG_CHECK_CONCEPT(trivially_copyable<T>);
+
+      // shift the values  up by one position to provide enough space for the
+      // new element
+      std::memmove( //
+        pldx + (it - pldi) + 1,
+        pldx + (it - pldi),
+        usize((pldi + col_end) - it) * sizeof(T));
+
+      // insert the new row index k
+      *it = I(permuted_pos);
+      // insert the new corresponding value
+      *(pldx + (it - pldi)) = l12_elem / d;
+      // update the non-zero count
+      ++pldnz[j];
+      ld._set_nnz(ld.nnz() + 1);
+    }
+
+    // insert the k-th column of L
+    {
+      usize col_start = ld.col_start(permuted_pos);
+      usize col_end = ld.col_end(permuted_pos);
+      pldx[col_start] = diag_element;
+      for (usize p = col_start + 1; p < col_end; ++p) {
+        pldx[p] = plx2_storage[zx(pldi[p])] / diag_element;
+      }
+    }
+  }
+
+  // set the parent of the k-th column of L
+  if (pldnz[permuted_pos] > 1) {
+    etree[permuted_pos] = pldi[ld.col_start(permuted_pos) + 1];
+  }
+
+  isize len = isize(util::zero_extend(ld.nnz_per_col()[permuted_pos])) - 1;
+  // perform the rank update with the newly added column
+  ld = sparse::rank1_update<T, I>(ld,
+                                  etree,
+                                  static_cast<I const*>(nullptr),
+                                  VecRef<T, I>{
+                                    from_raw_parts,
+                                    ld.nrows(),
+                                    len,
+                                    pldi + ld.col_start(permuted_pos) + 1,
+                                    pldx + ld.col_start(permuted_pos) + 1,
+                                  },
+                                  -diag_element,
+                                  stack);
+
+  return ld;
+}
+} // namespace sparse
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_ROWMOD_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/sparse/update.hpp

 * *Ordering differences only*

```diff
@@ -1,348 +1,348 @@
-/** \file */
-//
-// Copyright (c) 2022 INRIA
-//
-#ifndef PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP
-#define PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP
-
-#include "proxsuite/linalg/sparse/core.hpp"
-#include <proxsuite/linalg/veg/tuple.hpp>
-#include <algorithm>
-
-namespace proxsuite {
-namespace linalg {
-namespace sparse {
-
-/*
-calcule mémoire nécessaire pour la fonction merge_second_col_into_first
-*/
-template<typename I>
-auto
-merge_second_col_into_first_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
-                                isize second_size) noexcept
-  -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  return {
-    second_size * isize{ sizeof(I) },
-    alignof(I),
-  };
-}
-
-template<typename T, typename I>
-auto
-merge_second_col_into_first( //
-  I* difference,
-  T* first_values,
-  I* first_ptr,
-  PROXSUITE_MAYBE_UNUSED isize first_full_len,
-  isize first_initial_len,
-  Slice<I> second,
-  proxsuite::linalg::veg::DoNotDeduce<I> ignore_threshold_inclusive,
-  bool move_values,
-  DynStackMut stack) noexcept(false)
-  -> proxsuite::linalg::veg::Tuple<SliceMut<T>, SliceMut<I>, SliceMut<I>>
-{
-  VEG_CHECK_CONCEPT(trivially_copyable<I>);
-  VEG_CHECK_CONCEPT(trivially_copyable<T>);
-
-  if (second.len() == 0) {
-    return {
-      proxsuite::linalg::veg::tuplify,
-      { unsafe, from_raw_parts, first_values, first_initial_len },
-      { unsafe, from_raw_parts, first_ptr, first_initial_len },
-      { unsafe, from_raw_parts, difference, 0 },
-    };
-  }
-
-  I const* second_ptr = second.ptr();
-  usize second_len = usize(second.len());
-
-  usize index_second = 0;
-
-  for (; index_second < second_len; ++index_second) {
-    if (second_ptr[index_second] > ignore_threshold_inclusive) {
-      break;
-    }
-  }
-  auto ufirst_initial_len = usize(first_initial_len);
-
-  second_ptr += index_second;
-  second_len -= index_second;
-  index_second = 0;
-
-  proxsuite::linalg::veg::Tag<I> tag{};
-
-  auto _ins_pos = stack.make_new_for_overwrite(tag, isize(second_len));
-
-  I* insert_pos_ptr = _ins_pos.ptr_mut();
-  usize insert_count = 0;
-
-  for (usize index_first = 0; index_first < ufirst_initial_len; ++index_first) {
-    I current_first = first_ptr[index_first];
-    while (true) {
-      if (!(index_second < second_len)) {
-        break;
-      }
-
-      I current_second = second_ptr[index_second];
-      if (!(current_second < current_first)) {
-        break;
-      }
-
-      insert_pos_ptr[insert_count] = I(index_first);
-      difference[insert_count] = current_second;
-      ++insert_count;
-      ++index_second;
-    }
-
-    if (index_second == second_len) {
-      break;
-    }
-    if (second_ptr[index_second] == current_first) {
-      ++index_second;
-    }
-  }
-
-  usize remaining_insert_count = insert_count;
-  usize first_new_len =
-    ufirst_initial_len + insert_count + (second_len - index_second);
-  VEG_ASSERT(usize(first_full_len) >= first_new_len);
-
-  usize append_count = second_len - index_second;
-  std::memmove( //
-    difference + insert_count,
-    second_ptr + index_second,
-    append_count * sizeof(I));
-  std::memmove( //
-    first_ptr + (ufirst_initial_len + insert_count),
-    second_ptr + index_second,
-    append_count * sizeof(I));
-  if (move_values) {
-    for (usize i = 0; i < append_count; ++i) {
-      first_values[i + ufirst_initial_len + insert_count] = 0;
-    }
-  }
-
-  while (remaining_insert_count != 0) {
-
-    usize old_insert_pos = usize(insert_pos_ptr[remaining_insert_count - 1]);
-    usize range_size =
-      (remaining_insert_count == insert_count)
-        ? ufirst_initial_len - old_insert_pos
-        : usize(insert_pos_ptr[remaining_insert_count]) - old_insert_pos;
-
-    usize old_pos = old_insert_pos;
-    usize new_pos = old_pos + remaining_insert_count;
-
-    std::memmove( //
-      first_ptr + new_pos,
-      first_ptr + old_pos,
-      range_size * sizeof(I));
-    if (move_values) {
-      std::memmove( //
-        first_values + new_pos,
-        first_values + old_pos,
-        range_size * sizeof(T));
-      first_values[new_pos - 1] = 0;
-    }
-
-    first_ptr[new_pos - 1] = difference[remaining_insert_count - 1];
-    --remaining_insert_count;
-  }
-
-  return {
-    proxsuite::linalg::veg::tuplify,
-    { unsafe, from_raw_parts, first_values, isize(first_new_len) },
-    { unsafe, from_raw_parts, first_ptr, isize(first_new_len) },
-    { unsafe, from_raw_parts, difference, isize(insert_count + append_count) },
-  };
-}
-
-/*!
- * Computes the memory requirements for rank one update.
- *
- * @param n dimension of matrix
- * @param id_perm whether the permutation is implicitly the identity or not
- * @param col_nnz number of nnz elts in the update vector
- */
-template<typename T, typename I>
-auto
-rank1_update_req( //
-  proxsuite::linalg::veg::Tag<T> /*tag*/,
-  proxsuite::linalg::veg::Tag<I> /*tag*/,
-  isize n,
-  bool id_perm,
-  isize col_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
-{
-  using proxsuite::linalg::veg::dynstack::StackReq;
-  StackReq permuted_indices = { id_perm ? 0 : (col_nnz * isize{ sizeof(I) }),
-                                isize{ alignof(I) } };
-  StackReq difference = { n * isize{ sizeof(I) }, isize{ alignof(I) } };
-  difference = difference & difference;
-
-  StackReq merge = sparse::merge_second_col_into_first_req(
-    proxsuite::linalg::veg::Tag<I>{}, n);
-
-  StackReq numerical_workspace = { n * isize{ sizeof(T) },
-                                   isize{ alignof(T) } };
-
-  return permuted_indices & ((difference & merge) | numerical_workspace);
-}
-
-/*!
- * Performs a rank one update in place. Given ldlt factor l, and d, of a matrix
- * a, this computes the ldlt factors of a + alpha  w w.T It returns a view on
- * the updated factors.
- *
- * @param ld : ldlt factors of a (lower triangular with d on the diagonal)
- * @param etree pointer to the elimination tree
- * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
- * the permutation is assumed to be the identity.
- * @param w is the update vector
- * @param alpha is the update coefficient
- * @param stack is the memory stack
- */
-template<typename T, typename I>
-auto
-rank1_update(MatMut<T, I> ld,
-             I* etree,
-             I const* perm_inv,
-             VecRef<T, I> w,
-             proxsuite::linalg::veg::DoNotDeduce<T> alpha,
-             DynStackMut stack) noexcept(false) -> MatMut<T, I>
-{
-  VEG_ASSERT(!ld.is_compressed());
-
-  if (w.nnz() == 0) {
-    return ld;
-  }
-
-  proxsuite::linalg::veg::Tag<I> tag;
-  usize n = usize(ld.ncols());
-  bool id_perm = perm_inv == nullptr;
-
-  auto _w_permuted_indices =
-    stack.make_new_for_overwrite(tag, id_perm ? isize(0) : w.nnz());
-
-  auto w_permuted_indices =
-    id_perm ? w.row_indices() : _w_permuted_indices.ptr();
-  if (!id_perm) {
-    I* pw_permuted_indices = _w_permuted_indices.ptr_mut();
-    for (usize k = 0; k < usize(w.nnz()); ++k) {
-      usize i = util::zero_extend(w.row_indices()[k]);
-      pw_permuted_indices[k] = perm_inv[i];
-    }
-    std::sort(pw_permuted_indices, pw_permuted_indices + w.nnz());
-  }
-
-  auto sx = util::sign_extend;
-  auto zx = util::zero_extend;
-  // symbolic update
-  {
-    usize current_col = zx(w_permuted_indices[0]);
-
-    auto _difference =
-      stack.make_new_for_overwrite(tag, isize(n - current_col));
-    auto _difference_backup =
-      stack.make_new_for_overwrite(tag, isize(n - current_col));
-
-    auto merge_col = w_permuted_indices;
-    isize merge_col_len = w.nnz();
-    I* difference = _difference.ptr_mut();
-
-    while (true) {
-      usize old_parent = sx(etree[isize(current_col)]);
-
-      usize current_ptr_idx = zx(ld.col_ptrs()[isize(current_col)]);
-      usize next_ptr_idx = zx(ld.col_ptrs()[isize(current_col) + 1]);
-
-      VEG_BIND(auto,
-               (_, new_current_col, computed_difference),
-               sparse::merge_second_col_into_first(
-                 difference,
-                 ld.values_mut() + (current_ptr_idx + 1),
-                 ld.row_indices_mut() + (current_ptr_idx + 1),
-                 isize(next_ptr_idx - current_ptr_idx),
-                 isize(zx(ld.nnz_per_col()[isize(current_col)])) - 1,
-                 proxsuite::linalg::veg::Slice<I>{
-                   unsafe, from_raw_parts, merge_col, merge_col_len },
-                 I(current_col),
-                 true,
-                 stack));
-
-      (void)_;
-      ld._set_nnz(ld.nnz() + new_current_col.len() + 1 -
-                  isize(ld.nnz_per_col()[isize(current_col)]));
-      ld.nnz_per_col_mut()[isize(current_col)] = I(new_current_col.len() + 1);
-
-      usize new_parent =
-        (new_current_col.len() == 0) ? usize(-1) : sx(new_current_col[0]);
-
-      if (new_parent == usize(-1)) {
-        break;
-      }
-
-      if (new_parent == old_parent) {
-        merge_col = computed_difference.ptr();
-        merge_col_len = computed_difference.len();
-        difference = _difference_backup.ptr_mut();
-      } else {
-        merge_col = new_current_col.ptr();
-        merge_col_len = new_current_col.len();
-        difference = _difference.ptr_mut();
-        etree[isize(current_col)] = I(new_parent);
-      }
-
-      current_col = new_parent;
-    }
-  }
-
-  // numerical update
-  {
-    usize first_col = zx(w_permuted_indices[0]);
-    auto _work =
-      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<T>{}, isize(n));
-    T* pwork = _work.ptr_mut();
-
-    for (usize col = first_col; col != usize(-1); col = sx(etree[isize(col)])) {
-      pwork[col] = 0;
-    }
-    for (usize p = 0; p < usize(w.nnz()); ++p) {
-      pwork[id_perm ? zx(w.row_indices()[isize(p)])
-                    : zx(perm_inv[w.row_indices()[isize(p)]])] =
-        w.values()[isize(p)];
-    }
-
-    I const* pldi = ld.row_indices();
-    T* pldx = ld.values_mut();
-
-    for (usize col = first_col; col != usize(-1); col = sx(etree[isize(col)])) {
-      auto col_start = ld.col_start(col);
-      auto col_end = ld.col_end(col);
-
-      T w0 = pwork[col];
-      T old_d = pldx[col_start];
-      T new_d = old_d + alpha * w0 * w0;
-      T beta = alpha * w0 / new_d;
-      alpha = alpha - new_d * beta * beta;
-
-      pldx[col_start] = new_d;
-      pwork[col] -= w0;
-
-      for (usize p = col_start + 1; p < col_end; ++p) {
-        usize i = util::zero_extend(pldi[p]);
-
-        T tmp = pldx[p];
-        pwork[i] = pwork[i] - w0 * tmp;
-        pldx[p] = tmp + beta * pwork[i];
-      }
-    }
-  }
-
-  return ld;
-}
-} // namespace sparse
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP */
+/** \file */
+//
+// Copyright (c) 2022 INRIA
+//
+#ifndef PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP
+#define PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP
+
+#include "proxsuite/linalg/sparse/core.hpp"
+#include <proxsuite/linalg/veg/tuple.hpp>
+#include <algorithm>
+
+namespace proxsuite {
+namespace linalg {
+namespace sparse {
+
+/*
+calcule mémoire nécessaire pour la fonction merge_second_col_into_first
+*/
+template<typename I>
+auto
+merge_second_col_into_first_req(proxsuite::linalg::veg::Tag<I> /*tag*/,
+                                isize second_size) noexcept
+  -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  return {
+    second_size * isize{ sizeof(I) },
+    alignof(I),
+  };
+}
+
+template<typename T, typename I>
+auto
+merge_second_col_into_first( //
+  I* difference,
+  T* first_values,
+  I* first_ptr,
+  PROXSUITE_MAYBE_UNUSED isize first_full_len,
+  isize first_initial_len,
+  Slice<I> second,
+  proxsuite::linalg::veg::DoNotDeduce<I> ignore_threshold_inclusive,
+  bool move_values,
+  DynStackMut stack) noexcept(false)
+  -> proxsuite::linalg::veg::Tuple<SliceMut<T>, SliceMut<I>, SliceMut<I>>
+{
+  VEG_CHECK_CONCEPT(trivially_copyable<I>);
+  VEG_CHECK_CONCEPT(trivially_copyable<T>);
+
+  if (second.len() == 0) {
+    return {
+      proxsuite::linalg::veg::tuplify,
+      { unsafe, from_raw_parts, first_values, first_initial_len },
+      { unsafe, from_raw_parts, first_ptr, first_initial_len },
+      { unsafe, from_raw_parts, difference, 0 },
+    };
+  }
+
+  I const* second_ptr = second.ptr();
+  usize second_len = usize(second.len());
+
+  usize index_second = 0;
+
+  for (; index_second < second_len; ++index_second) {
+    if (second_ptr[index_second] > ignore_threshold_inclusive) {
+      break;
+    }
+  }
+  auto ufirst_initial_len = usize(first_initial_len);
+
+  second_ptr += index_second;
+  second_len -= index_second;
+  index_second = 0;
+
+  proxsuite::linalg::veg::Tag<I> tag{};
+
+  auto _ins_pos = stack.make_new_for_overwrite(tag, isize(second_len));
+
+  I* insert_pos_ptr = _ins_pos.ptr_mut();
+  usize insert_count = 0;
+
+  for (usize index_first = 0; index_first < ufirst_initial_len; ++index_first) {
+    I current_first = first_ptr[index_first];
+    while (true) {
+      if (!(index_second < second_len)) {
+        break;
+      }
+
+      I current_second = second_ptr[index_second];
+      if (!(current_second < current_first)) {
+        break;
+      }
+
+      insert_pos_ptr[insert_count] = I(index_first);
+      difference[insert_count] = current_second;
+      ++insert_count;
+      ++index_second;
+    }
+
+    if (index_second == second_len) {
+      break;
+    }
+    if (second_ptr[index_second] == current_first) {
+      ++index_second;
+    }
+  }
+
+  usize remaining_insert_count = insert_count;
+  usize first_new_len =
+    ufirst_initial_len + insert_count + (second_len - index_second);
+  VEG_ASSERT(usize(first_full_len) >= first_new_len);
+
+  usize append_count = second_len - index_second;
+  std::memmove( //
+    difference + insert_count,
+    second_ptr + index_second,
+    append_count * sizeof(I));
+  std::memmove( //
+    first_ptr + (ufirst_initial_len + insert_count),
+    second_ptr + index_second,
+    append_count * sizeof(I));
+  if (move_values) {
+    for (usize i = 0; i < append_count; ++i) {
+      first_values[i + ufirst_initial_len + insert_count] = 0;
+    }
+  }
+
+  while (remaining_insert_count != 0) {
+
+    usize old_insert_pos = usize(insert_pos_ptr[remaining_insert_count - 1]);
+    usize range_size =
+      (remaining_insert_count == insert_count)
+        ? ufirst_initial_len - old_insert_pos
+        : usize(insert_pos_ptr[remaining_insert_count]) - old_insert_pos;
+
+    usize old_pos = old_insert_pos;
+    usize new_pos = old_pos + remaining_insert_count;
+
+    std::memmove( //
+      first_ptr + new_pos,
+      first_ptr + old_pos,
+      range_size * sizeof(I));
+    if (move_values) {
+      std::memmove( //
+        first_values + new_pos,
+        first_values + old_pos,
+        range_size * sizeof(T));
+      first_values[new_pos - 1] = 0;
+    }
+
+    first_ptr[new_pos - 1] = difference[remaining_insert_count - 1];
+    --remaining_insert_count;
+  }
+
+  return {
+    proxsuite::linalg::veg::tuplify,
+    { unsafe, from_raw_parts, first_values, isize(first_new_len) },
+    { unsafe, from_raw_parts, first_ptr, isize(first_new_len) },
+    { unsafe, from_raw_parts, difference, isize(insert_count + append_count) },
+  };
+}
+
+/*!
+ * Computes the memory requirements for rank one update.
+ *
+ * @param n dimension of matrix
+ * @param id_perm whether the permutation is implicitly the identity or not
+ * @param col_nnz number of nnz elts in the update vector
+ */
+template<typename T, typename I>
+auto
+rank1_update_req( //
+  proxsuite::linalg::veg::Tag<T> /*tag*/,
+  proxsuite::linalg::veg::Tag<I> /*tag*/,
+  isize n,
+  bool id_perm,
+  isize col_nnz) noexcept -> proxsuite::linalg::veg::dynstack::StackReq
+{
+  using proxsuite::linalg::veg::dynstack::StackReq;
+  StackReq permuted_indices = { id_perm ? 0 : (col_nnz * isize{ sizeof(I) }),
+                                isize{ alignof(I) } };
+  StackReq difference = { n * isize{ sizeof(I) }, isize{ alignof(I) } };
+  difference = difference & difference;
+
+  StackReq merge = sparse::merge_second_col_into_first_req(
+    proxsuite::linalg::veg::Tag<I>{}, n);
+
+  StackReq numerical_workspace = { n * isize{ sizeof(T) },
+                                   isize{ alignof(T) } };
+
+  return permuted_indices & ((difference & merge) | numerical_workspace);
+}
+
+/*!
+ * Performs a rank one update in place. Given ldlt factor l, and d, of a matrix
+ * a, this computes the ldlt factors of a + alpha  w w.T It returns a view on
+ * the updated factors.
+ *
+ * @param ld : ldlt factors of a (lower triangular with d on the diagonal)
+ * @param etree pointer to the elimination tree
+ * @param perm_inv pointer to inverse permutation (for ex AMD). If this is null,
+ * the permutation is assumed to be the identity.
+ * @param w is the update vector
+ * @param alpha is the update coefficient
+ * @param stack is the memory stack
+ */
+template<typename T, typename I>
+auto
+rank1_update(MatMut<T, I> ld,
+             I* etree,
+             I const* perm_inv,
+             VecRef<T, I> w,
+             proxsuite::linalg::veg::DoNotDeduce<T> alpha,
+             DynStackMut stack) noexcept(false) -> MatMut<T, I>
+{
+  VEG_ASSERT(!ld.is_compressed());
+
+  if (w.nnz() == 0) {
+    return ld;
+  }
+
+  proxsuite::linalg::veg::Tag<I> tag;
+  usize n = usize(ld.ncols());
+  bool id_perm = perm_inv == nullptr;
+
+  auto _w_permuted_indices =
+    stack.make_new_for_overwrite(tag, id_perm ? isize(0) : w.nnz());
+
+  auto w_permuted_indices =
+    id_perm ? w.row_indices() : _w_permuted_indices.ptr();
+  if (!id_perm) {
+    I* pw_permuted_indices = _w_permuted_indices.ptr_mut();
+    for (usize k = 0; k < usize(w.nnz()); ++k) {
+      usize i = util::zero_extend(w.row_indices()[k]);
+      pw_permuted_indices[k] = perm_inv[i];
+    }
+    std::sort(pw_permuted_indices, pw_permuted_indices + w.nnz());
+  }
+
+  auto sx = util::sign_extend;
+  auto zx = util::zero_extend;
+  // symbolic update
+  {
+    usize current_col = zx(w_permuted_indices[0]);
+
+    auto _difference =
+      stack.make_new_for_overwrite(tag, isize(n - current_col));
+    auto _difference_backup =
+      stack.make_new_for_overwrite(tag, isize(n - current_col));
+
+    auto merge_col = w_permuted_indices;
+    isize merge_col_len = w.nnz();
+    I* difference = _difference.ptr_mut();
+
+    while (true) {
+      usize old_parent = sx(etree[isize(current_col)]);
+
+      usize current_ptr_idx = zx(ld.col_ptrs()[isize(current_col)]);
+      usize next_ptr_idx = zx(ld.col_ptrs()[isize(current_col) + 1]);
+
+      VEG_BIND(auto,
+               (_, new_current_col, computed_difference),
+               sparse::merge_second_col_into_first(
+                 difference,
+                 ld.values_mut() + (current_ptr_idx + 1),
+                 ld.row_indices_mut() + (current_ptr_idx + 1),
+                 isize(next_ptr_idx - current_ptr_idx),
+                 isize(zx(ld.nnz_per_col()[isize(current_col)])) - 1,
+                 proxsuite::linalg::veg::Slice<I>{
+                   unsafe, from_raw_parts, merge_col, merge_col_len },
+                 I(current_col),
+                 true,
+                 stack));
+
+      (void)_;
+      ld._set_nnz(ld.nnz() + new_current_col.len() + 1 -
+                  isize(ld.nnz_per_col()[isize(current_col)]));
+      ld.nnz_per_col_mut()[isize(current_col)] = I(new_current_col.len() + 1);
+
+      usize new_parent =
+        (new_current_col.len() == 0) ? usize(-1) : sx(new_current_col[0]);
+
+      if (new_parent == usize(-1)) {
+        break;
+      }
+
+      if (new_parent == old_parent) {
+        merge_col = computed_difference.ptr();
+        merge_col_len = computed_difference.len();
+        difference = _difference_backup.ptr_mut();
+      } else {
+        merge_col = new_current_col.ptr();
+        merge_col_len = new_current_col.len();
+        difference = _difference.ptr_mut();
+        etree[isize(current_col)] = I(new_parent);
+      }
+
+      current_col = new_parent;
+    }
+  }
+
+  // numerical update
+  {
+    usize first_col = zx(w_permuted_indices[0]);
+    auto _work =
+      stack.make_new_for_overwrite(proxsuite::linalg::veg::Tag<T>{}, isize(n));
+    T* pwork = _work.ptr_mut();
+
+    for (usize col = first_col; col != usize(-1); col = sx(etree[isize(col)])) {
+      pwork[col] = 0;
+    }
+    for (usize p = 0; p < usize(w.nnz()); ++p) {
+      pwork[id_perm ? zx(w.row_indices()[isize(p)])
+                    : zx(perm_inv[w.row_indices()[isize(p)]])] =
+        w.values()[isize(p)];
+    }
+
+    I const* pldi = ld.row_indices();
+    T* pldx = ld.values_mut();
+
+    for (usize col = first_col; col != usize(-1); col = sx(etree[isize(col)])) {
+      auto col_start = ld.col_start(col);
+      auto col_end = ld.col_end(col);
+
+      T w0 = pwork[col];
+      T old_d = pldx[col_start];
+      T new_d = old_d + alpha * w0 * w0;
+      T beta = alpha * w0 / new_d;
+      alpha = alpha - new_d * beta * beta;
+
+      pldx[col_start] = new_d;
+      pwork[col] -= w0;
+
+      for (usize p = col_start + 1; p < col_end; ++p) {
+        usize i = util::zero_extend(pldi[p]);
+
+        T tmp = pldx[p];
+        pwork[i] = pwork[i] - w0 * tmp;
+        pldx[p] = tmp + beta * pwork[i];
+      }
+    }
+  }
+
+  return ld;
+}
+} // namespace sparse
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_LINALG_SPARSE_LDLT_UPDATE_HPP */
```

## cmeel.prefix/include/proxsuite/linalg/veg/ref.hpp

 * *Ordering differences only*

```diff
@@ -1,148 +1,148 @@
-#ifndef VEG_REF_HPP_VQCOSD7RS
-#define VEG_REF_HPP_VQCOSD7RS
-
-#include "proxsuite/linalg/veg/type_traits/tags.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/memory/address.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace cmp {
-namespace ref {
-struct RefBase
-{};
-} // namespace ref
-namespace mut {
-struct RefMutBase
-{};
-} // namespace mut
-} // namespace cmp
-
-namespace nb {
-struct ref;
-struct mut;
-} // namespace nb
-
-template<typename T>
-struct Ref : cmp::ref::RefBase
-{
-private:
-  T const* ptr{};
-  VEG_INLINE constexpr Ref() = default;
-  VEG_INLINE constexpr Ref(T const* p) noexcept
-    : ptr{ p }
-  {
-  }
-  friend struct nb::ref;
-
-public:
-  VEG_NODISCARD VEG_INLINE constexpr auto get() const noexcept -> T const&
-  {
-    return *ptr;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator*() const noexcept -> T const&
-  {
-    return *ptr;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator->() const noexcept
-    -> T const*
-  {
-    return ptr;
-  }
-};
-namespace nb {
-struct ref
-{
-  template<typename T>
-  constexpr auto operator()(T const& r) const noexcept -> Ref<T>
-  {
-    return mem::addressof(r);
-  }
-};
-} // namespace nb
-
-template<typename T>
-struct RefMut : cmp::mut::RefMutBase
-{
-private:
-  T* ptr;
-  VEG_INLINE constexpr RefMut() = default;
-  VEG_INLINE constexpr RefMut(T* p) noexcept
-    : ptr{ p }
-  {
-  }
-
-  friend struct nb::mut;
-
-public:
-  VEG_INLINE constexpr auto as_const() const noexcept -> Ref<T>
-  {
-    return nb::ref{}(*ptr);
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto get() const noexcept -> T&
-  {
-    return *ptr;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator*() const noexcept -> T&
-  {
-    return *ptr;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator->() const noexcept -> T*
-  {
-    return ptr;
-  }
-};
-
-namespace nb {
-struct deref
-{
-  template<typename T>
-  constexpr auto operator()(Ref<T> r) const noexcept -> T const&
-  {
-    return r.get();
-  }
-};
-struct deref_mut
-{
-  template<typename T>
-  constexpr auto operator()(RefMut<T> r) const noexcept -> T&
-  {
-    return r.get();
-  }
-};
-
-struct mut
-{
-  VEG_TEMPLATE(typename T,
-               requires(!VEG_CONCEPT(const_type<meta::unref_t<T>>)),
-               constexpr auto
-               operator(),
-               (r, T&&))
-  const noexcept -> RefMut<meta::uncvref_t<T>> { return mem::addressof(r); }
-};
-struct clone
-{
-  VEG_TEMPLATE(typename T,
-               requires(VEG_CONCEPT(copyable<T>)),
-               VEG_INLINE constexpr auto
-               operator(),
-               (arg, Ref<T>))
-  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<T>))->T
-  {
-    return T(arg.get());
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(clone);
-VEG_NIEBLOID(deref);
-VEG_NIEBLOID(deref_mut);
-VEG_NIEBLOID(ref);
-VEG_NIEBLOID(mut);
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_REF_HPP_VQCOSD7RS */
+#ifndef VEG_REF_HPP_VQCOSD7RS
+#define VEG_REF_HPP_VQCOSD7RS
+
+#include "proxsuite/linalg/veg/type_traits/tags.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/memory/address.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace cmp {
+namespace ref {
+struct RefBase
+{};
+} // namespace ref
+namespace mut {
+struct RefMutBase
+{};
+} // namespace mut
+} // namespace cmp
+
+namespace nb {
+struct ref;
+struct mut;
+} // namespace nb
+
+template<typename T>
+struct Ref : cmp::ref::RefBase
+{
+private:
+  T const* ptr{};
+  VEG_INLINE constexpr Ref() = default;
+  VEG_INLINE constexpr Ref(T const* p) noexcept
+    : ptr{ p }
+  {
+  }
+  friend struct nb::ref;
+
+public:
+  VEG_NODISCARD VEG_INLINE constexpr auto get() const noexcept -> T const&
+  {
+    return *ptr;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator*() const noexcept -> T const&
+  {
+    return *ptr;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator->() const noexcept
+    -> T const*
+  {
+    return ptr;
+  }
+};
+namespace nb {
+struct ref
+{
+  template<typename T>
+  constexpr auto operator()(T const& r) const noexcept -> Ref<T>
+  {
+    return mem::addressof(r);
+  }
+};
+} // namespace nb
+
+template<typename T>
+struct RefMut : cmp::mut::RefMutBase
+{
+private:
+  T* ptr;
+  VEG_INLINE constexpr RefMut() = default;
+  VEG_INLINE constexpr RefMut(T* p) noexcept
+    : ptr{ p }
+  {
+  }
+
+  friend struct nb::mut;
+
+public:
+  VEG_INLINE constexpr auto as_const() const noexcept -> Ref<T>
+  {
+    return nb::ref{}(*ptr);
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto get() const noexcept -> T&
+  {
+    return *ptr;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator*() const noexcept -> T&
+  {
+    return *ptr;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator->() const noexcept -> T*
+  {
+    return ptr;
+  }
+};
+
+namespace nb {
+struct deref
+{
+  template<typename T>
+  constexpr auto operator()(Ref<T> r) const noexcept -> T const&
+  {
+    return r.get();
+  }
+};
+struct deref_mut
+{
+  template<typename T>
+  constexpr auto operator()(RefMut<T> r) const noexcept -> T&
+  {
+    return r.get();
+  }
+};
+
+struct mut
+{
+  VEG_TEMPLATE(typename T,
+               requires(!VEG_CONCEPT(const_type<meta::unref_t<T>>)),
+               constexpr auto
+               operator(),
+               (r, T&&))
+  const noexcept -> RefMut<meta::uncvref_t<T>> { return mem::addressof(r); }
+};
+struct clone
+{
+  VEG_TEMPLATE(typename T,
+               requires(VEG_CONCEPT(copyable<T>)),
+               VEG_INLINE constexpr auto
+               operator(),
+               (arg, Ref<T>))
+  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<T>))->T
+  {
+    return T(arg.get());
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(clone);
+VEG_NIEBLOID(deref);
+VEG_NIEBLOID(deref_mut);
+VEG_NIEBLOID(ref);
+VEG_NIEBLOID(mut);
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_REF_HPP_VQCOSD7RS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/slice.hpp

 * *Ordering differences only*

```diff
@@ -1,240 +1,240 @@
-#ifndef VEG_SLICE_HPP_GKSTE2JDS
-#define VEG_SLICE_HPP_GKSTE2JDS
-
-#include "proxsuite/linalg/veg/util/assert.hpp"
-#include "proxsuite/linalg/veg/util/get.hpp"
-#include "proxsuite/linalg/veg/internal/narrow.hpp"
-#include "proxsuite/linalg/veg/tuple.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <initializer_list>
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-template<typename T, usize N>
-using CArray = T[N];
-
-namespace _detail {
-namespace _slice {
-namespace adl {
-struct AdlBase
-{};
-} // namespace adl
-} // namespace _slice
-} // namespace _detail
-
-template<typename T>
-struct Slice : _detail::_slice::adl::AdlBase
-{
-private:
-  T const* data = nullptr;
-  isize size = 0;
-
-public:
-  VEG_INLINE
-  constexpr Slice() = default;
-
-  VEG_INLINE
-  constexpr Slice(Unsafe /*tag*/,
-                  FromRawParts /*tag*/,
-                  T const* data_,
-                  isize count) VEG_NOEXCEPT
-    : data{ data_ }
-    , size{ count }
-  {
-  }
-
-  VEG_NODISCARD
-  VEG_INLINE
-  constexpr auto ptr() const VEG_NOEXCEPT->T const* { return data; }
-  VEG_NODISCARD
-  VEG_INLINE
-  constexpr auto len() const VEG_NOEXCEPT->isize { return size; }
-
-  VEG_NODISCARD
-  VEG_INLINE
-  constexpr auto operator[](isize idx) const VEG_NOEXCEPT->T const&
-  {
-    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) < usize(len())),
-           *(data + idx);
-  }
-  VEG_NODISCARD
-  VEG_INLINE
-  constexpr auto get_unchecked(Unsafe /*tag*/,
-                               isize idx) const VEG_NOEXCEPT->Ref<T>
-  {
-    return ref(*(data + idx));
-  }
-
-  VEG_NODISCARD VEG_INLINE constexpr auto split_at(isize idx) const
-    VEG_NOEXCEPT->Tuple<Slice<T>, Slice<T>>
-  {
-    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) <= usize(len())),
-           Tuple<Slice<T>, Slice<T>>{
-             tuplify,
-             Slice<T>{
-               unsafe,
-               FromRawParts{},
-               data,
-               idx,
-             },
-             Slice<T>{
-               unsafe,
-               FromRawParts{},
-               data + idx,
-               size - idx,
-             },
-           };
-  }
-
-  VEG_NODISCARD VEG_INLINE auto as_bytes() const
-    VEG_NOEXCEPT->Slice<unsigned char>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      reinterpret_cast<unsigned char const*>(data),
-      isize(sizeof(T)) * size,
-    };
-  }
-};
-
-template<typename T>
-struct SliceMut : private Slice<T>
-{
-  VEG_INLINE
-  constexpr SliceMut() = default;
-
-  VEG_INLINE
-  constexpr SliceMut(Unsafe /*tag*/,
-                     FromRawParts /*tag*/,
-                     T const* data_,
-                     isize count) VEG_NOEXCEPT
-    : Slice<T>{
-      unsafe,
-      from_raw_parts,
-      data_,
-      count,
-    }
-  {
-  }
-
-  using Slice<T>::ptr;
-  using Slice<T>::as_bytes;
-  using Slice<T>::split_at;
-  using Slice<T>::len;
-  using Slice<T>::get_unchecked;
-
-  VEG_NODISCARD VEG_INLINE constexpr auto as_const() const noexcept -> Slice<T>
-  {
-    return *this;
-  }
-
-  VEG_NODISCARD
-  VEG_INLINE
-  VEG_CPP14(constexpr) auto operator[](isize idx) VEG_NOEXCEPT->T&
-  {
-    return const_cast<T&>(static_cast<Slice<T> const&>(*this)[idx]);
-  }
-  VEG_NODISCARD
-  VEG_INLINE
-  VEG_CPP14(constexpr) auto ptr_mut() VEG_NOEXCEPT->T*
-  {
-    return const_cast<T*>(ptr());
-  }
-  VEG_NODISCARD
-  VEG_INLINE
-  VEG_CPP14(constexpr)
-  auto get_mut_unchecked(Unsafe /*tag*/, isize idx) VEG_NOEXCEPT->RefMut<T>
-  {
-    return mut(const_cast<T&>(*(this->data + idx)));
-  }
-  VEG_NODISCARD VEG_INLINE auto as_mut_bytes()
-    VEG_NOEXCEPT->SliceMut<unsigned char>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      reinterpret_cast<unsigned char*>(ptr_mut()),
-      isize(sizeof(T)) * len(),
-    };
-  }
-
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto split_at_mut(isize idx)
-    VEG_NOEXCEPT->Tuple<SliceMut<T>, SliceMut<T>>
-  {
-    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) <= usize(len())),
-           Tuple<SliceMut<T>, SliceMut<T>>{
-             tuplify,
-             SliceMut<T>{
-               unsafe,
-               from_raw_parts,
-               ptr_mut(),
-               idx,
-             },
-             SliceMut<T>{
-               unsafe,
-               from_raw_parts,
-               ptr_mut() + idx,
-               len() - idx,
-             },
-           };
-  }
-};
-
-namespace array {
-template<typename T, isize N>
-struct Array
-{
-  static_assert(N > 0, ".");
-  T _[static_cast<usize>(N)];
-
-  constexpr auto as_ref() const -> Slice<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      static_cast<T const*>(_),
-      N,
-    };
-  }
-  VEG_CPP14(constexpr) auto as_mut() -> SliceMut<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      static_cast<T*>(_),
-      N,
-    };
-  }
-};
-} // namespace array
-using array::Array;
-
-namespace nb {
-struct init_list
-{
-  template<typename T>
-  VEG_CPP14(constexpr)
-  auto operator()(std::initializer_list<T> init_list) const noexcept -> Slice<T>
-  {
-    return {
-      unsafe,
-      from_raw_parts,
-      init_list.begin(),
-      isize(init_list.size()),
-    };
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(init_list);
-
-template<typename T>
-struct cpo::is_trivially_constructible<Slice<T>> : meta::bool_constant<true>
-{};
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_SLICE_HPP_GKSTE2JDS */
+#ifndef VEG_SLICE_HPP_GKSTE2JDS
+#define VEG_SLICE_HPP_GKSTE2JDS
+
+#include "proxsuite/linalg/veg/util/assert.hpp"
+#include "proxsuite/linalg/veg/util/get.hpp"
+#include "proxsuite/linalg/veg/internal/narrow.hpp"
+#include "proxsuite/linalg/veg/tuple.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <initializer_list>
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+template<typename T, usize N>
+using CArray = T[N];
+
+namespace _detail {
+namespace _slice {
+namespace adl {
+struct AdlBase
+{};
+} // namespace adl
+} // namespace _slice
+} // namespace _detail
+
+template<typename T>
+struct Slice : _detail::_slice::adl::AdlBase
+{
+private:
+  T const* data = nullptr;
+  isize size = 0;
+
+public:
+  VEG_INLINE
+  constexpr Slice() = default;
+
+  VEG_INLINE
+  constexpr Slice(Unsafe /*tag*/,
+                  FromRawParts /*tag*/,
+                  T const* data_,
+                  isize count) VEG_NOEXCEPT
+    : data{ data_ }
+    , size{ count }
+  {
+  }
+
+  VEG_NODISCARD
+  VEG_INLINE
+  constexpr auto ptr() const VEG_NOEXCEPT->T const* { return data; }
+  VEG_NODISCARD
+  VEG_INLINE
+  constexpr auto len() const VEG_NOEXCEPT->isize { return size; }
+
+  VEG_NODISCARD
+  VEG_INLINE
+  constexpr auto operator[](isize idx) const VEG_NOEXCEPT->T const&
+  {
+    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) < usize(len())),
+           *(data + idx);
+  }
+  VEG_NODISCARD
+  VEG_INLINE
+  constexpr auto get_unchecked(Unsafe /*tag*/,
+                               isize idx) const VEG_NOEXCEPT->Ref<T>
+  {
+    return ref(*(data + idx));
+  }
+
+  VEG_NODISCARD VEG_INLINE constexpr auto split_at(isize idx) const
+    VEG_NOEXCEPT->Tuple<Slice<T>, Slice<T>>
+  {
+    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) <= usize(len())),
+           Tuple<Slice<T>, Slice<T>>{
+             tuplify,
+             Slice<T>{
+               unsafe,
+               FromRawParts{},
+               data,
+               idx,
+             },
+             Slice<T>{
+               unsafe,
+               FromRawParts{},
+               data + idx,
+               size - idx,
+             },
+           };
+  }
+
+  VEG_NODISCARD VEG_INLINE auto as_bytes() const
+    VEG_NOEXCEPT->Slice<unsigned char>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      reinterpret_cast<unsigned char const*>(data),
+      isize(sizeof(T)) * size,
+    };
+  }
+};
+
+template<typename T>
+struct SliceMut : private Slice<T>
+{
+  VEG_INLINE
+  constexpr SliceMut() = default;
+
+  VEG_INLINE
+  constexpr SliceMut(Unsafe /*tag*/,
+                     FromRawParts /*tag*/,
+                     T const* data_,
+                     isize count) VEG_NOEXCEPT
+    : Slice<T>{
+      unsafe,
+      from_raw_parts,
+      data_,
+      count,
+    }
+  {
+  }
+
+  using Slice<T>::ptr;
+  using Slice<T>::as_bytes;
+  using Slice<T>::split_at;
+  using Slice<T>::len;
+  using Slice<T>::get_unchecked;
+
+  VEG_NODISCARD VEG_INLINE constexpr auto as_const() const noexcept -> Slice<T>
+  {
+    return *this;
+  }
+
+  VEG_NODISCARD
+  VEG_INLINE
+  VEG_CPP14(constexpr) auto operator[](isize idx) VEG_NOEXCEPT->T&
+  {
+    return const_cast<T&>(static_cast<Slice<T> const&>(*this)[idx]);
+  }
+  VEG_NODISCARD
+  VEG_INLINE
+  VEG_CPP14(constexpr) auto ptr_mut() VEG_NOEXCEPT->T*
+  {
+    return const_cast<T*>(ptr());
+  }
+  VEG_NODISCARD
+  VEG_INLINE
+  VEG_CPP14(constexpr)
+  auto get_mut_unchecked(Unsafe /*tag*/, isize idx) VEG_NOEXCEPT->RefMut<T>
+  {
+    return mut(const_cast<T&>(*(this->data + idx)));
+  }
+  VEG_NODISCARD VEG_INLINE auto as_mut_bytes()
+    VEG_NOEXCEPT->SliceMut<unsigned char>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      reinterpret_cast<unsigned char*>(ptr_mut()),
+      isize(sizeof(T)) * len(),
+    };
+  }
+
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto split_at_mut(isize idx)
+    VEG_NOEXCEPT->Tuple<SliceMut<T>, SliceMut<T>>
+  {
+    return VEG_INTERNAL_ASSERT_PRECONDITION(usize(idx) <= usize(len())),
+           Tuple<SliceMut<T>, SliceMut<T>>{
+             tuplify,
+             SliceMut<T>{
+               unsafe,
+               from_raw_parts,
+               ptr_mut(),
+               idx,
+             },
+             SliceMut<T>{
+               unsafe,
+               from_raw_parts,
+               ptr_mut() + idx,
+               len() - idx,
+             },
+           };
+  }
+};
+
+namespace array {
+template<typename T, isize N>
+struct Array
+{
+  static_assert(N > 0, ".");
+  T _[static_cast<usize>(N)];
+
+  constexpr auto as_ref() const -> Slice<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      static_cast<T const*>(_),
+      N,
+    };
+  }
+  VEG_CPP14(constexpr) auto as_mut() -> SliceMut<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      static_cast<T*>(_),
+      N,
+    };
+  }
+};
+} // namespace array
+using array::Array;
+
+namespace nb {
+struct init_list
+{
+  template<typename T>
+  VEG_CPP14(constexpr)
+  auto operator()(std::initializer_list<T> init_list) const noexcept -> Slice<T>
+  {
+    return {
+      unsafe,
+      from_raw_parts,
+      init_list.begin(),
+      isize(init_list.size()),
+    };
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(init_list);
+
+template<typename T>
+struct cpo::is_trivially_constructible<Slice<T>> : meta::bool_constant<true>
+{};
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_SLICE_HPP_GKSTE2JDS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/tuple.hpp

 * *Ordering differences only*

```diff
@@ -1,876 +1,876 @@
-#ifndef VEG_TUPLE_HPP_B8PHUNWES
-#define VEG_TUPLE_HPP_B8PHUNWES
-
-#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
-#include "proxsuite/linalg/veg/internal/dbg.hpp"
-#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
-#include "proxsuite/linalg/veg/util/get.hpp"
-#include "proxsuite/linalg/veg/internal/fix_index.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#if defined(__GLIBCXX__)
-namespace std /* NOLINT */ {
-_GLIBCXX_BEGIN_NAMESPACE_VERSION
-template<typename T>
-struct tuple_size;
-template<::proxsuite::linalg::veg::usize, typename T>
-struct tuple_element;
-_GLIBCXX_END_NAMESPACE_VERSION
-} // namespace std
-#else
-#include <utility> // std::tuple_{size,element}
-#endif
-
-/******************************************************************************/
-#define __VEG_IMPL_BIND(I, Tuple, Identifier) /* NOLINT */                     \
-  auto&& Identifier /* NOLINT */ =                                             \
-    ::proxsuite::linalg::veg::nb::get<I>{}(VEG_FWD(Tuple));
-
-#define __VEG_IMPL_BIND_ID_SEQ(/* NOLINT */                                    \
-                               CV_Auto,                                        \
-                               Identifiers,                                    \
-                               Tuple,                                          \
-                               Tuple_Size,                                     \
-                               TupleId)                                        \
-  CV_Auto TupleId = Tuple;                                                     \
-  static_assert(                                                               \
-    ::std::tuple_size<typename ::proxsuite::linalg::veg::meta::uncvref_t<      \
-        decltype(TupleId)>>::value == (Tuple_Size),                            \
-    "wrong number of identifiers");                                            \
-  __VEG_PP_TUPLE_FOR_EACH_I(__VEG_IMPL_BIND, TupleId, Identifiers)             \
-  VEG_NOM_SEMICOLON
-
-// example: difference vs c++17 structure bindings
-// auto get() -> tuple<A, B&, C&&>;
-//
-// auto [a, b, c] = get();
-// VEG_BIND(auto, (x, y, z), get());
-// decltype({a,b,c}) => {A,B&,C&&}     same as tuple_element<i, E>
-// decltype({x,y,z}) => {A&&,B&,C&&}   always a reference, lvalue if initializer
-//                                     expression or tuple_element<i, E> is an
-//                                     lvalue, rvalue otherwise.
-//
-#define VEG_BIND(CV_Auto, Identifiers, Tuple)                                  \
-  __VEG_IMPL_BIND_ID_SEQ(CV_Auto,                                              \
-                         Identifiers,                                          \
-                         Tuple,                                                \
-                         __VEG_PP_TUPLE_SIZE(Identifiers),                     \
-                         __VEG_PP_CAT(_dummy_tuple_variable_id_, __LINE__))
-/******************************************************************************/
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-template<typename T, usize I>
-using inner_ith = decltype(VEG_DECLVAL(T)[Fix<isize{ I }>{}]);
-
-template<typename... Ts>
-struct Tuple;
-
-namespace tuple {
-namespace nb {
-struct tuplify
-{
-  template<typename... Ts>
-  VEG_NODISCARD VEG_INLINE constexpr auto operator()(Ts... args) const
-    VEG_NOEXCEPT->proxsuite::linalg::veg::Tuple<Ts...>
-  {
-    return { tuplify{}, Ts(VEG_FWD(args))... };
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(tuplify);
-} // namespace tuple
-
-inline namespace tags {
-using Tuplify = tuple::nb::tuplify;
-using tuple::tuplify;
-} // namespace tags
-
-namespace tuple {
-using proxsuite::linalg::veg::Tuple;
-} // namespace tuple
-
-namespace tuple {
-template<typename ISeq, typename... Ts>
-struct IndexedTuple
-{};
-
-#if VEG_HAS_NO_UNIQUE_ADDRESS
-#define __VEG_IMPL_LEAF(Tuple, I, ...) /* NOLINT */                            \
-  (static_cast<                                                                \
-     ::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__> const&>(       \
-     (Tuple).inner)                                                            \
-     .leaf)
-#define __VEG_IMPL_LEAF_MUT(Tuple, I, ...) /* NOLINT */                        \
-  (static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&>(   \
-     (Tuple).inner)                                                            \
-     .leaf)
-#define __VEG_IMPL_LEAF_ONCE(Tuple, I, ...) /* NOLINT */                       \
-  (static_cast<__VA_ARGS__&&>(                                                 \
-    static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&&>( \
-      (Tuple).inner)                                                           \
-      .leaf))
-
-template<usize I, typename T>
-struct TupleLeaf
-{
-  VEG_NO_UNIQUE_ADDRESS T leaf;
-};
-#else
-
-#define __VEG_IMPL_LEAF(Tuple, I, ...) /* NOLINT */                            \
-  (static_cast<__VA_ARGS__ const&>(                                            \
-    static_cast<                                                               \
-      ::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__> const&>(      \
-      (Tuple).inner)                                                           \
-      .leaf_get()))
-
-#define __VEG_IMPL_LEAF_MUT(Tuple, I, ...) /* NOLINT */                        \
-  (static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&>(   \
-     (Tuple).inner)                                                            \
-     .leaf_get())
-
-#define __VEG_IMPL_LEAF_ONCE(Tuple, I, ...) /* NOLINT */                       \
-  (static_cast<__VA_ARGS__&&>(                                                 \
-    static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&&>( \
-      (Tuple).inner)                                                           \
-      .leaf_get()))
-
-template<typename T, bool = (VEG_CONCEPT(empty<T>) && !VEG_CONCEPT(final<T>))>
-struct TupleLeafImpl;
-
-template<typename T>
-struct TupleLeafImpl<T, true> : T
-{
-  template<typename Fn>
-  VEG_INLINE constexpr TupleLeafImpl(InPlace<void> /*tag*/, Fn fn)
-    VEG_NOEXCEPT_LIKE(VEG_FWD(fn)())
-    : T{ VEG_FWD(fn)() }
-  {
-  }
-  TupleLeafImpl() = default;
-  VEG_INLINE constexpr auto leaf_get() const VEG_NOEXCEPT->T&
-  {
-    return const_cast<T&>(static_cast<T const&>(*this));
-  }
-};
-template<typename T>
-struct TupleLeafImpl<T, false>
-{
-  T leaf;
-
-  template<typename Fn>
-  VEG_INLINE constexpr TupleLeafImpl(InPlace<void> /*tag*/, Fn fn)
-    VEG_NOEXCEPT_LIKE(VEG_FWD(fn)())
-    : leaf{ VEG_FWD(fn)() }
-  {
-  }
-  TupleLeafImpl() = default;
-
-  VEG_INLINE constexpr auto leaf_get() const VEG_NOEXCEPT->T&
-  {
-    return const_cast<T&>(leaf);
-  }
-};
-
-template<usize I, typename T>
-struct TupleLeaf : TupleLeafImpl<T>
-{
-  using TupleLeafImpl<T>::TupleLeafImpl;
-};
-#endif
-
-namespace nb {
-struct unpack
-{
-  VEG_TEMPLATE(
-    (typename Fn, typename... Ts, usize... Is),
-    requires(VEG_CONCEPT(
-      fn_once<Fn,
-              proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>,
-              Ts&&...>)),
-    VEG_INLINE constexpr auto
-    operator(),
-    (args,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ts...>&&),
-    (fn, Fn))
-  const VEG_NOEXCEPT_IF(
-    VEG_CONCEPT(nothrow_fn_once<
-                Fn,
-                proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>,
-                Ts&&...>))
-    ->proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>
-  {
-
-    return VEG_FWD(fn)(__VEG_IMPL_LEAF_ONCE(args, Is, Ts)...);
-  }
-};
-
-struct for_each_i
-{
-  VEG_TEMPLATE(
-    (typename Fn, typename... Ts, usize... Is),
-    requires(VEG_ALL_OF(VEG_CONCEPT(fn_once<inner_ith<Fn&, Is>, void, Ts>))),
-    VEG_INLINE VEG_CPP14(constexpr) void
-    operator(),
-    (args,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ts...>&&),
-    (fn, Fn))
-  const VEG_NOEXCEPT_IF(
-    VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<inner_ith<Fn, Is>, void, Ts>)))
-  {
-    VEG_EVAL_ALL(fn[Fix<isize{ Is }>{}](__VEG_IMPL_LEAF_ONCE(args, Is, Ts)));
-  }
-};
-
-struct for_each
-{
-  VEG_TEMPLATE(
-    (typename Fn, typename... Ts, usize... Is),
-    requires(VEG_ALL_OF(VEG_CONCEPT(fn_mut<Fn, void, Ts&&>))),
-    VEG_INLINE VEG_CPP14(constexpr) void
-    operator(),
-    (args,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ts...>&&),
-    (fn, Fn))
-  const VEG_NOEXCEPT_IF(VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_mut<Fn, void, Ts&&>)))
-  {
-    VEG_EVAL_ALL(fn(__VEG_IMPL_LEAF_ONCE(args, Is, Ts)));
-  }
-};
-
-struct map_i
-{
-  VEG_TEMPLATE(
-    (typename Fn, typename... Ts, usize... Is),
-    requires(VEG_ALL_OF(VEG_CONCEPT(
-      fn_once< //
-        inner_ith<Fn&, Is>,
-        proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>,
-        Ts>))),
-    VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
-    operator(),
-    (args,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ts...>&&),
-    (fn, Fn))
-  const VEG_NOEXCEPT_IF(
-    VEG_ALL_OF(VEG_CONCEPT(
-      nothrow_fn_once< //
-        inner_ith<Fn&, Is>,
-        proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>,
-        Ts>)))
-    ->Tuple<
-      proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>...>
-  {
-    return { inplace[tuplify{}],
-             _detail::WithArg<inner_ith<Fn&, Is>, Ts>{
-               fn[Fix<isize{ Is }>{}],
-               __VEG_IMPL_LEAF_ONCE(args, Is, Ts) }... };
-  }
-};
-
-struct map
-{
-  VEG_TEMPLATE(
-    (typename Fn, typename... Ts, usize... Is),
-    requires(VEG_ALL_OF(VEG_CONCEPT(
-      fn_mut<Fn,
-             proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>,
-             Ts&&>))),
-    VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
-    operator(),
-    (args,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ts...>&&),
-    (fn, Fn))
-  const VEG_NOEXCEPT_IF(
-    VEG_ALL_OF(VEG_CONCEPT(
-      nothrow_fn_mut<Fn,
-                     proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>,
-                     Ts&&>)))
-    ->Tuple<proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>...>
-  {
-    return {
-      inplace[tuplify{}],
-      _detail::WithArg<Fn&, Ts&&>{
-        fn,
-        __VEG_IMPL_LEAF_ONCE(args, Is, Ts),
-      }...,
-    };
-  }
-};
-} // namespace nb
-
-template<usize... Is, typename... Ts>
-struct IndexedTuple<meta::index_sequence<Is...>, Ts...>
-{
-  struct _ : TupleLeaf<Is, Ts>...
-  {
-#if !defined(VEG_WITH_CXX17_SUPPORT)
-#if VEG_HAS_NO_UNIQUE_ADDRESS
-    template<typename... Fns>
-    VEG_INLINE constexpr _(InPlace<void> /* unused */, Fns... fns) noexcept(
-      VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
-      : TupleLeaf<Is, Ts>{ VEG_FWD(fns)() }...
-    {
-    }
-#else
-    template<typename... Fns>
-    VEG_INLINE constexpr _(InPlace<void> /*unused*/, Fns... fns) noexcept(
-      VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
-      : TupleLeaf<Is, Ts>{ inplace, VEG_FWD(fns) }...
-    {
-    }
-#endif
-    _() = default;
-#endif
-  } inner;
-
-  IndexedTuple() = default;
-
-  VEG_INLINE constexpr IndexedTuple(Tuplify /*tag*/, Ts... args) VEG_NOEXCEPT
-    : inner
-  {
-#if !defined(VEG_WITH_CXX17_SUPPORT)
-    inplace, _detail::MoveFn<Ts>{ VEG_FWD(args) }...,
-#else
-#if VEG_HAS_NO_UNIQUE_ADDRESS
-    TupleLeaf<Is, Ts>{ Ts(VEG_FWD(args)) }...
-#else
-    TupleLeaf<Is, Ts>{ inplace, _detail::MoveFn<Ts>{ VEG_FWD(args) } }...
-#endif
-#endif
-  }
-  {
-  }
-
-  VEG_TEMPLATE((typename _, typename... Fns),
-               requires(VEG_CONCEPT(same<_, Tuplify>) &&
-                        VEG_ALL_OF(VEG_CONCEPT(fn_once<Fns, Ts>))),
-               VEG_INLINE constexpr IndexedTuple,
-               (/*tag*/, InPlace<_>),
-               (... fns, Fns))
-
-  VEG_NOEXCEPT_IF(VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
-    : inner
-  {
-#if !defined(VEG_WITH_CXX17_SUPPORT)
-    inplace, VEG_FWD(fns)...
-#else
-#if VEG_HAS_NO_UNIQUE_ADDRESS
-    TupleLeaf<Is, Ts>{ VEG_FWD(fns)() }...
-#else
-    TupleLeaf<Is, Ts>{ inplace, VEG_FWD(fns) }...
-#endif
-#endif
-  }
-  {
-  }
-
-  VEG_EXPLICIT_COPY(IndexedTuple);
-
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto as_ref() const
-    & VEG_NOEXCEPT->Tuple<Ref<Ts>...>
-  {
-    return {
-      tuplify,
-      ref(__VEG_IMPL_LEAF(*this, Is, Ts))...,
-    };
-  }
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto as_mut()
-    VEG_NOEXCEPT->Tuple<RefMut<Ts>...>
-  {
-    return {
-      tuplify,
-      mut(__VEG_IMPL_LEAF_MUT(*this, Is, Ts))...,
-    };
-  }
-
-  template<isize I>
-  void operator[](Fix<I> /*arg*/) const&& = delete;
-
-  VEG_TEMPLATE((isize I),
-               requires(static_cast<usize>(I) < sizeof...(Ts)),
-               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
-               operator[],
-               (/*arg*/, Fix<I>)) &&
-    VEG_NOEXCEPT_IF(
-      VEG_CONCEPT(nothrow_movable<ith<static_cast<usize>(I), Ts...>>))
-      -> ith<static_cast<usize>(I), Ts...>
-  {
-    return __VEG_IMPL_LEAF_ONCE(
-      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
-  }
-
-  VEG_TEMPLATE((isize I),
-               requires(static_cast<usize>(I) < sizeof...(Ts)),
-               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
-               operator[],
-               (/*arg*/, Fix<I>)) &
-    VEG_NOEXCEPT->ith<static_cast<usize>(I), Ts...>&
-  {
-    return __VEG_IMPL_LEAF_MUT(
-      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
-  }
-
-  VEG_TEMPLATE((isize I),
-               requires(static_cast<usize>(I) < sizeof...(Ts)),
-               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
-               operator[],
-               (/*arg*/, Fix<I>))
-  const & VEG_NOEXCEPT->ith<static_cast<usize>(I), Ts...> const&
-  {
-    return __VEG_IMPL_LEAF(
-      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
-  }
-};
-} // namespace tuple
-
-namespace _detail {
-namespace meta_ {
-
-struct NonTupleBaseInfoImpl
-{
-  static constexpr bool is_tuple = false;
-  static constexpr usize size = 0;
-  template<usize I>
-  using ith = void;
-  using seq = void;
-};
-
-template<typename... Ts>
-struct TupleBaseInfoImpl
-{
-  static constexpr bool is_tuple = true;
-  static constexpr usize size = sizeof...(Ts);
-  template<usize I>
-  using ith = proxsuite::linalg::veg::ith<I, Ts...>;
-  using seq = meta::type_sequence<Ts...>;
-  using Tuple = proxsuite::linalg::veg::Tuple<Ts...>;
-  using IndexedTuple = proxsuite::linalg::veg::tuple::
-    IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
-};
-
-struct is_tuple_helper
-{
-  static auto test(void*) -> NonTupleBaseInfoImpl;
-  template<usize... Is, typename... Ts>
-  static auto test(tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>*)
-    -> TupleBaseInfoImpl<Ts...>;
-};
-
-template<typename T>
-struct IndexedToTuple;
-
-template<usize... Is, typename... Ts>
-struct IndexedToTuple<tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
-{
-  using Type = Tuple<Ts...>;
-};
-} // namespace meta_
-} // namespace _detail
-
-namespace tuple {
-namespace meta {
-template<typename T>
-using TupleBaseInfo =
-  decltype(_detail::meta_::is_tuple_helper::test(static_cast<T*>(nullptr)));
-
-template<typename T>
-using is_tuple =
-  proxsuite::linalg::veg::meta::bool_constant<TupleBaseInfo<T>::is_tuple>;
-template<typename T>
-using tuple_size =
-  proxsuite::linalg::veg::meta::constant<usize, TupleBaseInfo<T>::size>;
-
-template<usize I, typename T>
-using tuple_element = typename TupleBaseInfo<T>::template ith<I>;
-
-} // namespace meta
-} // namespace tuple
-
-namespace concepts {
-namespace tuple {
-VEG_DEF_CONCEPT(typename T,
-                tuple,
-                proxsuite::linalg::veg::tuple::meta::is_tuple<T>::value);
-} // namespace tuple
-} // namespace concepts
-
-template<typename... Ts>
-struct Tuple
-  : tuple::IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>
-{
-
-  using Indexed =
-    tuple::IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
-
-  using Indexed::Indexed;
-
-  VEG_EXPLICIT_COPY(Tuple);
-};
-
-VEG_CPP17(template<typename... Ts> Tuple(Tuplify, Ts...) -> Tuple<Ts...>;)
-namespace tuple {
-
-template<usize I, usize... Is, typename... Ts>
-VEG_NODISCARD VEG_INLINE constexpr auto
-get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                        Ts...> const& tup) VEG_NOEXCEPT->ith<I, Ts...> const&
-{
-  return __VEG_IMPL_LEAF(tup, I, ith<I, Ts...>);
-}
-template<usize I, usize... Is, typename... Ts>
-VEG_NODISCARD VEG_INLINE constexpr auto
-get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                        Ts...>& tup) VEG_NOEXCEPT->ith<I, Ts...>&
-{
-  return __VEG_IMPL_LEAF_MUT(tup, I, ith<I, Ts...>);
-}
-template<usize I, usize... Is, typename... Ts>
-VEG_NODISCARD VEG_INLINE constexpr auto
-get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                        Ts...> const&& tup) VEG_NOEXCEPT->ith<I, Ts...> const&&
-{
-  return static_cast<ith<I, Ts...> const&&>(
-    __VEG_IMPL_LEAF(tup, I, ith<I, Ts...>));
-}
-template<usize I, usize... Is, typename... Ts>
-VEG_NODISCARD VEG_INLINE constexpr auto
-get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                        Ts...>&& tup) VEG_NOEXCEPT->ith<I, Ts...>&&
-{
-  return __VEG_IMPL_LEAF_ONCE(tup, I, ith<I, Ts...>);
-}
-
-} // namespace tuple
-
-namespace _detail {
-namespace _tuple {
-template<usize... Is, typename... Ts>
-VEG_INLINE static constexpr auto
-tuple_fwd(tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>&& tup)
-  VEG_NOEXCEPT->Tuple<Ts&&...>
-{
-  return {
-    ((void)(tup), tuplify),
-    __VEG_IMPL_LEAF_ONCE(tup, Is, Ts)...,
-  };
-}
-
-} // namespace _tuple
-} // namespace _detail
-
-namespace tuple {
-namespace nb {
-struct with
-{
-  VEG_TEMPLATE(
-    typename... Fns,
-    requires(VEG_ALL_OF(VEG_CONCEPT(
-      fn_once<Fns, proxsuite::linalg::veg::meta::invoke_result_t<Fns>>))),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator(),
-    (... args, Fns))
-  const VEG_NOEXCEPT_IF(
-    VEG_ALL_OF(VEG_CONCEPT(
-      nothrow_fn_once<Fns,
-                      proxsuite::linalg::veg::meta::invoke_result_t<Fns>>)))
-    ->proxsuite::linalg::veg::Tuple<
-      proxsuite::linalg::veg::meta::invoke_result_t<Fns>...>
-  {
-    return { inplace[tuplify{}], VEG_FWD(args)... };
-  }
-};
-
-struct zip
-{
-
-  template<typename... Tuples>
-  using PreZip =
-    proxsuite::linalg::veg::meta::type_sequence_zip<Tuple, Tuples...>;
-
-  template<typename... Tuples>
-  using Zip = proxsuite::linalg::veg::meta::
-    detected_t<PreZip, typename meta::TupleBaseInfo<Tuples>::Tuple...>;
-
-  VEG_TEMPLATE(
-    (typename... Tuples),
-    requires(VEG_ALL_OF(VEG_CONCEPT(tuple::tuple<Tuples>)) &&
-             VEG_CONCEPT(all_same<tuple::meta::tuple_size<Tuples>...>)),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator(),
-    (... tups, Tuples))
-  const VEG_NOEXCEPT->Zip<Tuples...>
-  {
-    return zip::apply(
-      static_cast<typename meta::TupleBaseInfo<Tuples>::IndexedTuple&&>(
-        tups)...);
-  }
-
-private:
-  template<typename... Tuples>
-  VEG_INLINE static constexpr auto pre_apply(
-    proxsuite::linalg::veg::meta::true_type /*unused*/,
-    Tuples&&... tups) VEG_NOEXCEPT->Zip<Tuples...>
-  {
-    return zip::apply(VEG_FWD(tups)...);
-  }
-  template<typename... Tuples>
-  VEG_INLINE static constexpr auto pre_apply(
-    proxsuite::linalg::veg::meta::false_type /*unused*/,
-    Tuples&&... tups) VEG_NOEXCEPT->Zip<Tuples...>
-  {
-    return zip::from_ref_to_result(
-      Tag<proxsuite::linalg::veg::meta::type_sequence_zip<
-        Tuple,
-        typename _detail::meta_::IndexedToTuple<Tuples>::Type...>>{},
-      zip::apply(_detail::_tuple::tuple_fwd(VEG_FWD(tups))...));
-  }
-
-  VEG_INLINE static auto apply() VEG_NOEXCEPT->Tuple<> { return {}; }
-
-  template<usize I, typename T>
-  struct Helper
-  {
-    template<typename... Ts>
-    using Type = Tuple<T, meta::tuple_element<I, Ts>...>;
-
-    template<typename... Ts>
-    VEG_INLINE constexpr auto apply(Ts&&... tups) const
-      VEG_NOEXCEPT->Type<Ts...>
-    {
-      return {
-        tuplify{},
-        VEG_FWD(first),
-        __VEG_IMPL_LEAF_ONCE(tups, I, meta::tuple_element<I, Ts>)...,
-      };
-    }
-    T&& first;
-  };
-
-  template<usize... Is, typename... Ts, typename... Tuples>
-  VEG_INLINE static constexpr auto apply(
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>
-      first,
-    Tuples... rest) VEG_NOEXCEPT->Tuple< //
-    typename Helper<Is, Ts>::            //
-    template Type<Tuples...>...>
-  {
-    return {
-      ((void)first, tuplify{}),
-      Helper<Is, Ts>{ __VEG_IMPL_LEAF_ONCE(first, Is, Ts) }
-        .template apply<Tuples...>(VEG_FWD(rest)...)...,
-    };
-  }
-
-  template<typename ISeq, typename... InnerTargets>
-  struct ConverterImpl;
-  template<typename OuterTarget>
-  struct Converter;
-
-  template<usize... Is, typename... InnerTargets>
-  struct ConverterImpl<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                       InnerTargets...>
-  {
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                 InnerTargets&&...>&& refs;
-
-    VEG_INLINE constexpr auto operator()() const
-      && VEG_NOEXCEPT->Tuple<InnerTargets...>
-    {
-
-      return {
-        inplace[tuplify{}],
-        _detail::MoveFn<InnerTargets>{
-          __VEG_IMPL_LEAF_ONCE(refs, Is, InnerTargets) }...,
-      };
-    }
-  };
-
-  template<typename... InnerTargets>
-  struct Converter<Tuple<InnerTargets...>>
-  {
-    using Type =
-      ConverterImpl<proxsuite::linalg::veg::meta::make_index_sequence<sizeof...(
-                      InnerTargets)>,
-                    InnerTargets...>;
-  };
-
-  template<usize... Is, typename... Tups, typename... OuterTargets>
-  VEG_INLINE static constexpr auto from_ref_to_result(
-    Tag<Tuple<OuterTargets...>> /*tag*/,
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Tups...>
-      zipped_refs) VEG_NOEXCEPT->Tuple<OuterTargets...>
-  {
-    return {
-      ((void)zipped_refs, inplace[tuplify{}]),
-      typename Converter<OuterTargets>::Type{
-        __VEG_IMPL_LEAF_ONCE(zipped_refs, Is, Tups),
-      }...,
-    };
-  }
-};
-
-struct cat
-{
-
-  template<typename... Tuples>
-  using PreConcat =
-    proxsuite::linalg::veg::meta::type_sequence_cat<Tuple, Tuples...>;
-  template<typename... Tuples>
-  using Concat = proxsuite::linalg::veg::meta::
-    detected_t<PreConcat, typename meta::TupleBaseInfo<Tuples>::Tuple...>;
-
-  VEG_TEMPLATE((typename... Tuples),
-               requires(VEG_ALL_OF(VEG_CONCEPT(tuple::tuple<Tuples>))),
-               VEG_NODISCARD VEG_INLINE constexpr auto
-               operator(),
-               (... tups, Tuples))
-  const VEG_NOEXCEPT->Concat<Tuples...>
-  {
-    return cat::apply(
-      static_cast<typename meta::TupleBaseInfo<Tuples>::IndexedTuple&&>(
-        tups)...);
-  }
-
-private:
-  template<typename... Tuples>
-  VEG_INLINE static constexpr auto pre_apply(
-    proxsuite::linalg::veg::meta::true_type /*unused*/,
-    Tuples&&... tups) VEG_NOEXCEPT->Concat<Tuples...>
-  {
-    return cat::apply(VEG_FWD(tups)...);
-  }
-
-  template<typename... Tuples>
-  VEG_INLINE static constexpr auto pre_apply(
-    proxsuite::linalg::veg::meta::false_type /*unused*/,
-    Tuples&&... tups) VEG_NOEXCEPT->Concat<Tuples...>
-  {
-    return cat::template from_ref_to_result(
-      Tag<proxsuite::linalg::veg::meta::type_sequence_cat<Tuple, Tuples...>>{},
-      cat::apply(_detail::_tuple::tuple_fwd(VEG_FWD(tups))...));
-  }
-
-  template<typename... Targets, usize... Is, typename... Refs>
-  VEG_INLINE static constexpr auto from_ref_to_result(
-    Tag<Tuple<Targets...>> /*tag*/,
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Refs...>
-      refs) VEG_NOEXCEPT->proxsuite::linalg::veg::Tuple<Targets...>
-  {
-    return {
-      inplace[tuplify{}],
-      _detail::MoveFn<Targets>{ __VEG_IMPL_LEAF_ONCE(refs, Is, Targets) }...,
-    };
-  }
-
-  VEG_INLINE static auto apply() VEG_NOEXCEPT->Tuple<> { return {}; }
-
-  template<usize... Is, typename... Ts, typename... Tuples>
-  VEG_INLINE static constexpr auto apply(
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>&&
-      first,
-    Tuples&&... rest)
-    VEG_NOEXCEPT->proxsuite::linalg::veg::meta::type_sequence_cat<
-      Tuple,
-      Tuple<Ts...>,
-      typename _detail::meta_::IndexedToTuple<Tuples>::Type...>
-  {
-    return cat::apply2(VEG_FWD(first), cat::apply(VEG_FWD(rest)...));
-  }
-
-  template<usize... Is, typename... Ts, usize... Js, typename... Us>
-  VEG_INLINE static constexpr auto apply2(
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>&&
-      first,
-    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Js...>, Us...>&&
-      second) VEG_NOEXCEPT->Tuple<Ts..., Us...>
-  {
-    return {
-      tuplify{},
-      __VEG_IMPL_LEAF_ONCE(first, Is, Ts)...,
-      __VEG_IMPL_LEAF_ONCE(second, Js, Us)...,
-    };
-  }
-};
-
-struct deref_assign
-{
-  VEG_TEMPLATE(
-    (typename... Ts, typename... Us, usize... Is),
-    requires(VEG_ALL_OF(VEG_CONCEPT(assignable<Ts&, Us const&>))),
-    VEG_INLINE VEG_CPP14(constexpr) void
-    operator(),
-    (ts,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  RefMut<Ts>...>),
-    (us,
-     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
-                  Ref<Us>...>))
-  const VEG_NOEXCEPT_IF(
-    VEG_ALL_OF(VEG_CONCEPT(nothrow_assignable<Ts&, Us const&>)))
-  {
-    VEG_EVAL_ALL(__VEG_IMPL_LEAF_MUT(ts, Is, RefMut<Ts>).get() =
-                   __VEG_IMPL_LEAF(us, Is, Ref<Us>).get());
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(with);
-
-VEG_NIEBLOID(zip);
-VEG_NIEBLOID(cat);
-
-VEG_NIEBLOID(unpack);
-
-VEG_NIEBLOID(for_each);
-VEG_NIEBLOID(for_each_i);
-VEG_NIEBLOID(map);
-VEG_NIEBLOID(map_i);
-
-VEG_NIEBLOID(deref_assign);
-} // namespace tuple
-
-namespace cpo {
-template<usize... Is, typename... Ts>
-struct is_trivially_relocatable<
-  tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
-  : meta::bool_constant<(VEG_ALL_OF(is_trivially_relocatable<Ts>::value))>
-{};
-template<usize... Is, typename... Ts>
-struct is_trivially_constructible<
-  tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
-  : meta::bool_constant<(VEG_ALL_OF(is_trivially_constructible<Ts>::value))>
-{};
-
-template<typename... Ts>
-struct is_trivially_relocatable<tuple::Tuple<Ts...>>
-  : meta::bool_constant<(VEG_ALL_OF(is_trivially_relocatable<Ts>::value))>
-{};
-template<typename... Ts>
-struct is_trivially_constructible<tuple::Tuple<Ts...>>
-  : meta::bool_constant<(VEG_ALL_OF(is_trivially_constructible<Ts>::value))>
-{};
-} // namespace cpo
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-template<typename... Ts>
-struct std::tuple_size<proxsuite::linalg::veg::Tuple<Ts...>>
-  : ::proxsuite::linalg::veg::meta::constant<proxsuite::linalg::veg::usize,
-                                             sizeof...(Ts)>
-{};
-template<proxsuite::linalg::veg::usize I, typename... Ts>
-struct std::tuple_element<I, proxsuite::linalg::veg::Tuple<Ts...>>
-{
-  using type = proxsuite::linalg::veg::ith<I, Ts...>;
-};
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_TUPLE_HPP_B8PHUNWES */
+#ifndef VEG_TUPLE_HPP_B8PHUNWES
+#define VEG_TUPLE_HPP_B8PHUNWES
+
+#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
+#include "proxsuite/linalg/veg/internal/dbg.hpp"
+#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
+#include "proxsuite/linalg/veg/util/get.hpp"
+#include "proxsuite/linalg/veg/internal/fix_index.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#if defined(__GLIBCXX__)
+namespace std /* NOLINT */ {
+_GLIBCXX_BEGIN_NAMESPACE_VERSION
+template<typename T>
+struct tuple_size;
+template<::proxsuite::linalg::veg::usize, typename T>
+struct tuple_element;
+_GLIBCXX_END_NAMESPACE_VERSION
+} // namespace std
+#else
+#include <utility> // std::tuple_{size,element}
+#endif
+
+/******************************************************************************/
+#define __VEG_IMPL_BIND(I, Tuple, Identifier) /* NOLINT */                     \
+  auto&& Identifier /* NOLINT */ =                                             \
+    ::proxsuite::linalg::veg::nb::get<I>{}(VEG_FWD(Tuple));
+
+#define __VEG_IMPL_BIND_ID_SEQ(/* NOLINT */                                    \
+                               CV_Auto,                                        \
+                               Identifiers,                                    \
+                               Tuple,                                          \
+                               Tuple_Size,                                     \
+                               TupleId)                                        \
+  CV_Auto TupleId = Tuple;                                                     \
+  static_assert(                                                               \
+    ::std::tuple_size<typename ::proxsuite::linalg::veg::meta::uncvref_t<      \
+        decltype(TupleId)>>::value == (Tuple_Size),                            \
+    "wrong number of identifiers");                                            \
+  __VEG_PP_TUPLE_FOR_EACH_I(__VEG_IMPL_BIND, TupleId, Identifiers)             \
+  VEG_NOM_SEMICOLON
+
+// example: difference vs c++17 structure bindings
+// auto get() -> tuple<A, B&, C&&>;
+//
+// auto [a, b, c] = get();
+// VEG_BIND(auto, (x, y, z), get());
+// decltype({a,b,c}) => {A,B&,C&&}     same as tuple_element<i, E>
+// decltype({x,y,z}) => {A&&,B&,C&&}   always a reference, lvalue if initializer
+//                                     expression or tuple_element<i, E> is an
+//                                     lvalue, rvalue otherwise.
+//
+#define VEG_BIND(CV_Auto, Identifiers, Tuple)                                  \
+  __VEG_IMPL_BIND_ID_SEQ(CV_Auto,                                              \
+                         Identifiers,                                          \
+                         Tuple,                                                \
+                         __VEG_PP_TUPLE_SIZE(Identifiers),                     \
+                         __VEG_PP_CAT(_dummy_tuple_variable_id_, __LINE__))
+/******************************************************************************/
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+template<typename T, usize I>
+using inner_ith = decltype(VEG_DECLVAL(T)[Fix<isize{ I }>{}]);
+
+template<typename... Ts>
+struct Tuple;
+
+namespace tuple {
+namespace nb {
+struct tuplify
+{
+  template<typename... Ts>
+  VEG_NODISCARD VEG_INLINE constexpr auto operator()(Ts... args) const
+    VEG_NOEXCEPT->proxsuite::linalg::veg::Tuple<Ts...>
+  {
+    return { tuplify{}, Ts(VEG_FWD(args))... };
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(tuplify);
+} // namespace tuple
+
+inline namespace tags {
+using Tuplify = tuple::nb::tuplify;
+using tuple::tuplify;
+} // namespace tags
+
+namespace tuple {
+using proxsuite::linalg::veg::Tuple;
+} // namespace tuple
+
+namespace tuple {
+template<typename ISeq, typename... Ts>
+struct IndexedTuple
+{};
+
+#if VEG_HAS_NO_UNIQUE_ADDRESS
+#define __VEG_IMPL_LEAF(Tuple, I, ...) /* NOLINT */                            \
+  (static_cast<                                                                \
+     ::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__> const&>(       \
+     (Tuple).inner)                                                            \
+     .leaf)
+#define __VEG_IMPL_LEAF_MUT(Tuple, I, ...) /* NOLINT */                        \
+  (static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&>(   \
+     (Tuple).inner)                                                            \
+     .leaf)
+#define __VEG_IMPL_LEAF_ONCE(Tuple, I, ...) /* NOLINT */                       \
+  (static_cast<__VA_ARGS__&&>(                                                 \
+    static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&&>( \
+      (Tuple).inner)                                                           \
+      .leaf))
+
+template<usize I, typename T>
+struct TupleLeaf
+{
+  VEG_NO_UNIQUE_ADDRESS T leaf;
+};
+#else
+
+#define __VEG_IMPL_LEAF(Tuple, I, ...) /* NOLINT */                            \
+  (static_cast<__VA_ARGS__ const&>(                                            \
+    static_cast<                                                               \
+      ::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__> const&>(      \
+      (Tuple).inner)                                                           \
+      .leaf_get()))
+
+#define __VEG_IMPL_LEAF_MUT(Tuple, I, ...) /* NOLINT */                        \
+  (static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&>(   \
+     (Tuple).inner)                                                            \
+     .leaf_get())
+
+#define __VEG_IMPL_LEAF_ONCE(Tuple, I, ...) /* NOLINT */                       \
+  (static_cast<__VA_ARGS__&&>(                                                 \
+    static_cast<::proxsuite::linalg::veg::tuple::TupleLeaf<I, __VA_ARGS__>&&>( \
+      (Tuple).inner)                                                           \
+      .leaf_get()))
+
+template<typename T, bool = (VEG_CONCEPT(empty<T>) && !VEG_CONCEPT(final<T>))>
+struct TupleLeafImpl;
+
+template<typename T>
+struct TupleLeafImpl<T, true> : T
+{
+  template<typename Fn>
+  VEG_INLINE constexpr TupleLeafImpl(InPlace<void> /*tag*/, Fn fn)
+    VEG_NOEXCEPT_LIKE(VEG_FWD(fn)())
+    : T{ VEG_FWD(fn)() }
+  {
+  }
+  TupleLeafImpl() = default;
+  VEG_INLINE constexpr auto leaf_get() const VEG_NOEXCEPT->T&
+  {
+    return const_cast<T&>(static_cast<T const&>(*this));
+  }
+};
+template<typename T>
+struct TupleLeafImpl<T, false>
+{
+  T leaf;
+
+  template<typename Fn>
+  VEG_INLINE constexpr TupleLeafImpl(InPlace<void> /*tag*/, Fn fn)
+    VEG_NOEXCEPT_LIKE(VEG_FWD(fn)())
+    : leaf{ VEG_FWD(fn)() }
+  {
+  }
+  TupleLeafImpl() = default;
+
+  VEG_INLINE constexpr auto leaf_get() const VEG_NOEXCEPT->T&
+  {
+    return const_cast<T&>(leaf);
+  }
+};
+
+template<usize I, typename T>
+struct TupleLeaf : TupleLeafImpl<T>
+{
+  using TupleLeafImpl<T>::TupleLeafImpl;
+};
+#endif
+
+namespace nb {
+struct unpack
+{
+  VEG_TEMPLATE(
+    (typename Fn, typename... Ts, usize... Is),
+    requires(VEG_CONCEPT(
+      fn_once<Fn,
+              proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>,
+              Ts&&...>)),
+    VEG_INLINE constexpr auto
+    operator(),
+    (args,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ts...>&&),
+    (fn, Fn))
+  const VEG_NOEXCEPT_IF(
+    VEG_CONCEPT(nothrow_fn_once<
+                Fn,
+                proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>,
+                Ts&&...>))
+    ->proxsuite::linalg::veg::meta::invoke_result_t<Fn, Ts&&...>
+  {
+
+    return VEG_FWD(fn)(__VEG_IMPL_LEAF_ONCE(args, Is, Ts)...);
+  }
+};
+
+struct for_each_i
+{
+  VEG_TEMPLATE(
+    (typename Fn, typename... Ts, usize... Is),
+    requires(VEG_ALL_OF(VEG_CONCEPT(fn_once<inner_ith<Fn&, Is>, void, Ts>))),
+    VEG_INLINE VEG_CPP14(constexpr) void
+    operator(),
+    (args,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ts...>&&),
+    (fn, Fn))
+  const VEG_NOEXCEPT_IF(
+    VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<inner_ith<Fn, Is>, void, Ts>)))
+  {
+    VEG_EVAL_ALL(fn[Fix<isize{ Is }>{}](__VEG_IMPL_LEAF_ONCE(args, Is, Ts)));
+  }
+};
+
+struct for_each
+{
+  VEG_TEMPLATE(
+    (typename Fn, typename... Ts, usize... Is),
+    requires(VEG_ALL_OF(VEG_CONCEPT(fn_mut<Fn, void, Ts&&>))),
+    VEG_INLINE VEG_CPP14(constexpr) void
+    operator(),
+    (args,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ts...>&&),
+    (fn, Fn))
+  const VEG_NOEXCEPT_IF(VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_mut<Fn, void, Ts&&>)))
+  {
+    VEG_EVAL_ALL(fn(__VEG_IMPL_LEAF_ONCE(args, Is, Ts)));
+  }
+};
+
+struct map_i
+{
+  VEG_TEMPLATE(
+    (typename Fn, typename... Ts, usize... Is),
+    requires(VEG_ALL_OF(VEG_CONCEPT(
+      fn_once< //
+        inner_ith<Fn&, Is>,
+        proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>,
+        Ts>))),
+    VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
+    operator(),
+    (args,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ts...>&&),
+    (fn, Fn))
+  const VEG_NOEXCEPT_IF(
+    VEG_ALL_OF(VEG_CONCEPT(
+      nothrow_fn_once< //
+        inner_ith<Fn&, Is>,
+        proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>,
+        Ts>)))
+    ->Tuple<
+      proxsuite::linalg::veg::meta::invoke_result_t<inner_ith<Fn&, Is>, Ts>...>
+  {
+    return { inplace[tuplify{}],
+             _detail::WithArg<inner_ith<Fn&, Is>, Ts>{
+               fn[Fix<isize{ Is }>{}],
+               __VEG_IMPL_LEAF_ONCE(args, Is, Ts) }... };
+  }
+};
+
+struct map
+{
+  VEG_TEMPLATE(
+    (typename Fn, typename... Ts, usize... Is),
+    requires(VEG_ALL_OF(VEG_CONCEPT(
+      fn_mut<Fn,
+             proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>,
+             Ts&&>))),
+    VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
+    operator(),
+    (args,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ts...>&&),
+    (fn, Fn))
+  const VEG_NOEXCEPT_IF(
+    VEG_ALL_OF(VEG_CONCEPT(
+      nothrow_fn_mut<Fn,
+                     proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>,
+                     Ts&&>)))
+    ->Tuple<proxsuite::linalg::veg::meta::invoke_result_t<Fn&, Ts&&>...>
+  {
+    return {
+      inplace[tuplify{}],
+      _detail::WithArg<Fn&, Ts&&>{
+        fn,
+        __VEG_IMPL_LEAF_ONCE(args, Is, Ts),
+      }...,
+    };
+  }
+};
+} // namespace nb
+
+template<usize... Is, typename... Ts>
+struct IndexedTuple<meta::index_sequence<Is...>, Ts...>
+{
+  struct _ : TupleLeaf<Is, Ts>...
+  {
+#if !defined(VEG_WITH_CXX17_SUPPORT)
+#if VEG_HAS_NO_UNIQUE_ADDRESS
+    template<typename... Fns>
+    VEG_INLINE constexpr _(InPlace<void> /* unused */, Fns... fns) noexcept(
+      VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
+      : TupleLeaf<Is, Ts>{ VEG_FWD(fns)() }...
+    {
+    }
+#else
+    template<typename... Fns>
+    VEG_INLINE constexpr _(InPlace<void> /*unused*/, Fns... fns) noexcept(
+      VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
+      : TupleLeaf<Is, Ts>{ inplace, VEG_FWD(fns) }...
+    {
+    }
+#endif
+    _() = default;
+#endif
+  } inner;
+
+  IndexedTuple() = default;
+
+  VEG_INLINE constexpr IndexedTuple(Tuplify /*tag*/, Ts... args) VEG_NOEXCEPT
+    : inner
+  {
+#if !defined(VEG_WITH_CXX17_SUPPORT)
+    inplace, _detail::MoveFn<Ts>{ VEG_FWD(args) }...,
+#else
+#if VEG_HAS_NO_UNIQUE_ADDRESS
+    TupleLeaf<Is, Ts>{ Ts(VEG_FWD(args)) }...
+#else
+    TupleLeaf<Is, Ts>{ inplace, _detail::MoveFn<Ts>{ VEG_FWD(args) } }...
+#endif
+#endif
+  }
+  {
+  }
+
+  VEG_TEMPLATE((typename _, typename... Fns),
+               requires(VEG_CONCEPT(same<_, Tuplify>) &&
+                        VEG_ALL_OF(VEG_CONCEPT(fn_once<Fns, Ts>))),
+               VEG_INLINE constexpr IndexedTuple,
+               (/*tag*/, InPlace<_>),
+               (... fns, Fns))
+
+  VEG_NOEXCEPT_IF(VEG_ALL_OF(VEG_CONCEPT(nothrow_fn_once<Fns, Ts>)))
+    : inner
+  {
+#if !defined(VEG_WITH_CXX17_SUPPORT)
+    inplace, VEG_FWD(fns)...
+#else
+#if VEG_HAS_NO_UNIQUE_ADDRESS
+    TupleLeaf<Is, Ts>{ VEG_FWD(fns)() }...
+#else
+    TupleLeaf<Is, Ts>{ inplace, VEG_FWD(fns) }...
+#endif
+#endif
+  }
+  {
+  }
+
+  VEG_EXPLICIT_COPY(IndexedTuple);
+
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto as_ref() const
+    & VEG_NOEXCEPT->Tuple<Ref<Ts>...>
+  {
+    return {
+      tuplify,
+      ref(__VEG_IMPL_LEAF(*this, Is, Ts))...,
+    };
+  }
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto as_mut()
+    VEG_NOEXCEPT->Tuple<RefMut<Ts>...>
+  {
+    return {
+      tuplify,
+      mut(__VEG_IMPL_LEAF_MUT(*this, Is, Ts))...,
+    };
+  }
+
+  template<isize I>
+  void operator[](Fix<I> /*arg*/) const&& = delete;
+
+  VEG_TEMPLATE((isize I),
+               requires(static_cast<usize>(I) < sizeof...(Ts)),
+               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
+               operator[],
+               (/*arg*/, Fix<I>)) &&
+    VEG_NOEXCEPT_IF(
+      VEG_CONCEPT(nothrow_movable<ith<static_cast<usize>(I), Ts...>>))
+      -> ith<static_cast<usize>(I), Ts...>
+  {
+    return __VEG_IMPL_LEAF_ONCE(
+      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
+  }
+
+  VEG_TEMPLATE((isize I),
+               requires(static_cast<usize>(I) < sizeof...(Ts)),
+               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
+               operator[],
+               (/*arg*/, Fix<I>)) &
+    VEG_NOEXCEPT->ith<static_cast<usize>(I), Ts...>&
+  {
+    return __VEG_IMPL_LEAF_MUT(
+      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
+  }
+
+  VEG_TEMPLATE((isize I),
+               requires(static_cast<usize>(I) < sizeof...(Ts)),
+               VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto
+               operator[],
+               (/*arg*/, Fix<I>))
+  const & VEG_NOEXCEPT->ith<static_cast<usize>(I), Ts...> const&
+  {
+    return __VEG_IMPL_LEAF(
+      *this, static_cast<usize>(I), ith<static_cast<usize>(I), Ts...>);
+  }
+};
+} // namespace tuple
+
+namespace _detail {
+namespace meta_ {
+
+struct NonTupleBaseInfoImpl
+{
+  static constexpr bool is_tuple = false;
+  static constexpr usize size = 0;
+  template<usize I>
+  using ith = void;
+  using seq = void;
+};
+
+template<typename... Ts>
+struct TupleBaseInfoImpl
+{
+  static constexpr bool is_tuple = true;
+  static constexpr usize size = sizeof...(Ts);
+  template<usize I>
+  using ith = proxsuite::linalg::veg::ith<I, Ts...>;
+  using seq = meta::type_sequence<Ts...>;
+  using Tuple = proxsuite::linalg::veg::Tuple<Ts...>;
+  using IndexedTuple = proxsuite::linalg::veg::tuple::
+    IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
+};
+
+struct is_tuple_helper
+{
+  static auto test(void*) -> NonTupleBaseInfoImpl;
+  template<usize... Is, typename... Ts>
+  static auto test(tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>*)
+    -> TupleBaseInfoImpl<Ts...>;
+};
+
+template<typename T>
+struct IndexedToTuple;
+
+template<usize... Is, typename... Ts>
+struct IndexedToTuple<tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
+{
+  using Type = Tuple<Ts...>;
+};
+} // namespace meta_
+} // namespace _detail
+
+namespace tuple {
+namespace meta {
+template<typename T>
+using TupleBaseInfo =
+  decltype(_detail::meta_::is_tuple_helper::test(static_cast<T*>(nullptr)));
+
+template<typename T>
+using is_tuple =
+  proxsuite::linalg::veg::meta::bool_constant<TupleBaseInfo<T>::is_tuple>;
+template<typename T>
+using tuple_size =
+  proxsuite::linalg::veg::meta::constant<usize, TupleBaseInfo<T>::size>;
+
+template<usize I, typename T>
+using tuple_element = typename TupleBaseInfo<T>::template ith<I>;
+
+} // namespace meta
+} // namespace tuple
+
+namespace concepts {
+namespace tuple {
+VEG_DEF_CONCEPT(typename T,
+                tuple,
+                proxsuite::linalg::veg::tuple::meta::is_tuple<T>::value);
+} // namespace tuple
+} // namespace concepts
+
+template<typename... Ts>
+struct Tuple
+  : tuple::IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>
+{
+
+  using Indexed =
+    tuple::IndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
+
+  using Indexed::Indexed;
+
+  VEG_EXPLICIT_COPY(Tuple);
+};
+
+VEG_CPP17(template<typename... Ts> Tuple(Tuplify, Ts...) -> Tuple<Ts...>;)
+namespace tuple {
+
+template<usize I, usize... Is, typename... Ts>
+VEG_NODISCARD VEG_INLINE constexpr auto
+get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                        Ts...> const& tup) VEG_NOEXCEPT->ith<I, Ts...> const&
+{
+  return __VEG_IMPL_LEAF(tup, I, ith<I, Ts...>);
+}
+template<usize I, usize... Is, typename... Ts>
+VEG_NODISCARD VEG_INLINE constexpr auto
+get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                        Ts...>& tup) VEG_NOEXCEPT->ith<I, Ts...>&
+{
+  return __VEG_IMPL_LEAF_MUT(tup, I, ith<I, Ts...>);
+}
+template<usize I, usize... Is, typename... Ts>
+VEG_NODISCARD VEG_INLINE constexpr auto
+get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                        Ts...> const&& tup) VEG_NOEXCEPT->ith<I, Ts...> const&&
+{
+  return static_cast<ith<I, Ts...> const&&>(
+    __VEG_IMPL_LEAF(tup, I, ith<I, Ts...>));
+}
+template<usize I, usize... Is, typename... Ts>
+VEG_NODISCARD VEG_INLINE constexpr auto
+get(tuple::IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                        Ts...>&& tup) VEG_NOEXCEPT->ith<I, Ts...>&&
+{
+  return __VEG_IMPL_LEAF_ONCE(tup, I, ith<I, Ts...>);
+}
+
+} // namespace tuple
+
+namespace _detail {
+namespace _tuple {
+template<usize... Is, typename... Ts>
+VEG_INLINE static constexpr auto
+tuple_fwd(tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>&& tup)
+  VEG_NOEXCEPT->Tuple<Ts&&...>
+{
+  return {
+    ((void)(tup), tuplify),
+    __VEG_IMPL_LEAF_ONCE(tup, Is, Ts)...,
+  };
+}
+
+} // namespace _tuple
+} // namespace _detail
+
+namespace tuple {
+namespace nb {
+struct with
+{
+  VEG_TEMPLATE(
+    typename... Fns,
+    requires(VEG_ALL_OF(VEG_CONCEPT(
+      fn_once<Fns, proxsuite::linalg::veg::meta::invoke_result_t<Fns>>))),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator(),
+    (... args, Fns))
+  const VEG_NOEXCEPT_IF(
+    VEG_ALL_OF(VEG_CONCEPT(
+      nothrow_fn_once<Fns,
+                      proxsuite::linalg::veg::meta::invoke_result_t<Fns>>)))
+    ->proxsuite::linalg::veg::Tuple<
+      proxsuite::linalg::veg::meta::invoke_result_t<Fns>...>
+  {
+    return { inplace[tuplify{}], VEG_FWD(args)... };
+  }
+};
+
+struct zip
+{
+
+  template<typename... Tuples>
+  using PreZip =
+    proxsuite::linalg::veg::meta::type_sequence_zip<Tuple, Tuples...>;
+
+  template<typename... Tuples>
+  using Zip = proxsuite::linalg::veg::meta::
+    detected_t<PreZip, typename meta::TupleBaseInfo<Tuples>::Tuple...>;
+
+  VEG_TEMPLATE(
+    (typename... Tuples),
+    requires(VEG_ALL_OF(VEG_CONCEPT(tuple::tuple<Tuples>)) &&
+             VEG_CONCEPT(all_same<tuple::meta::tuple_size<Tuples>...>)),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator(),
+    (... tups, Tuples))
+  const VEG_NOEXCEPT->Zip<Tuples...>
+  {
+    return zip::apply(
+      static_cast<typename meta::TupleBaseInfo<Tuples>::IndexedTuple&&>(
+        tups)...);
+  }
+
+private:
+  template<typename... Tuples>
+  VEG_INLINE static constexpr auto pre_apply(
+    proxsuite::linalg::veg::meta::true_type /*unused*/,
+    Tuples&&... tups) VEG_NOEXCEPT->Zip<Tuples...>
+  {
+    return zip::apply(VEG_FWD(tups)...);
+  }
+  template<typename... Tuples>
+  VEG_INLINE static constexpr auto pre_apply(
+    proxsuite::linalg::veg::meta::false_type /*unused*/,
+    Tuples&&... tups) VEG_NOEXCEPT->Zip<Tuples...>
+  {
+    return zip::from_ref_to_result(
+      Tag<proxsuite::linalg::veg::meta::type_sequence_zip<
+        Tuple,
+        typename _detail::meta_::IndexedToTuple<Tuples>::Type...>>{},
+      zip::apply(_detail::_tuple::tuple_fwd(VEG_FWD(tups))...));
+  }
+
+  VEG_INLINE static auto apply() VEG_NOEXCEPT->Tuple<> { return {}; }
+
+  template<usize I, typename T>
+  struct Helper
+  {
+    template<typename... Ts>
+    using Type = Tuple<T, meta::tuple_element<I, Ts>...>;
+
+    template<typename... Ts>
+    VEG_INLINE constexpr auto apply(Ts&&... tups) const
+      VEG_NOEXCEPT->Type<Ts...>
+    {
+      return {
+        tuplify{},
+        VEG_FWD(first),
+        __VEG_IMPL_LEAF_ONCE(tups, I, meta::tuple_element<I, Ts>)...,
+      };
+    }
+    T&& first;
+  };
+
+  template<usize... Is, typename... Ts, typename... Tuples>
+  VEG_INLINE static constexpr auto apply(
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>
+      first,
+    Tuples... rest) VEG_NOEXCEPT->Tuple< //
+    typename Helper<Is, Ts>::            //
+    template Type<Tuples...>...>
+  {
+    return {
+      ((void)first, tuplify{}),
+      Helper<Is, Ts>{ __VEG_IMPL_LEAF_ONCE(first, Is, Ts) }
+        .template apply<Tuples...>(VEG_FWD(rest)...)...,
+    };
+  }
+
+  template<typename ISeq, typename... InnerTargets>
+  struct ConverterImpl;
+  template<typename OuterTarget>
+  struct Converter;
+
+  template<usize... Is, typename... InnerTargets>
+  struct ConverterImpl<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                       InnerTargets...>
+  {
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                 InnerTargets&&...>&& refs;
+
+    VEG_INLINE constexpr auto operator()() const
+      && VEG_NOEXCEPT->Tuple<InnerTargets...>
+    {
+
+      return {
+        inplace[tuplify{}],
+        _detail::MoveFn<InnerTargets>{
+          __VEG_IMPL_LEAF_ONCE(refs, Is, InnerTargets) }...,
+      };
+    }
+  };
+
+  template<typename... InnerTargets>
+  struct Converter<Tuple<InnerTargets...>>
+  {
+    using Type =
+      ConverterImpl<proxsuite::linalg::veg::meta::make_index_sequence<sizeof...(
+                      InnerTargets)>,
+                    InnerTargets...>;
+  };
+
+  template<usize... Is, typename... Tups, typename... OuterTargets>
+  VEG_INLINE static constexpr auto from_ref_to_result(
+    Tag<Tuple<OuterTargets...>> /*tag*/,
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Tups...>
+      zipped_refs) VEG_NOEXCEPT->Tuple<OuterTargets...>
+  {
+    return {
+      ((void)zipped_refs, inplace[tuplify{}]),
+      typename Converter<OuterTargets>::Type{
+        __VEG_IMPL_LEAF_ONCE(zipped_refs, Is, Tups),
+      }...,
+    };
+  }
+};
+
+struct cat
+{
+
+  template<typename... Tuples>
+  using PreConcat =
+    proxsuite::linalg::veg::meta::type_sequence_cat<Tuple, Tuples...>;
+  template<typename... Tuples>
+  using Concat = proxsuite::linalg::veg::meta::
+    detected_t<PreConcat, typename meta::TupleBaseInfo<Tuples>::Tuple...>;
+
+  VEG_TEMPLATE((typename... Tuples),
+               requires(VEG_ALL_OF(VEG_CONCEPT(tuple::tuple<Tuples>))),
+               VEG_NODISCARD VEG_INLINE constexpr auto
+               operator(),
+               (... tups, Tuples))
+  const VEG_NOEXCEPT->Concat<Tuples...>
+  {
+    return cat::apply(
+      static_cast<typename meta::TupleBaseInfo<Tuples>::IndexedTuple&&>(
+        tups)...);
+  }
+
+private:
+  template<typename... Tuples>
+  VEG_INLINE static constexpr auto pre_apply(
+    proxsuite::linalg::veg::meta::true_type /*unused*/,
+    Tuples&&... tups) VEG_NOEXCEPT->Concat<Tuples...>
+  {
+    return cat::apply(VEG_FWD(tups)...);
+  }
+
+  template<typename... Tuples>
+  VEG_INLINE static constexpr auto pre_apply(
+    proxsuite::linalg::veg::meta::false_type /*unused*/,
+    Tuples&&... tups) VEG_NOEXCEPT->Concat<Tuples...>
+  {
+    return cat::template from_ref_to_result(
+      Tag<proxsuite::linalg::veg::meta::type_sequence_cat<Tuple, Tuples...>>{},
+      cat::apply(_detail::_tuple::tuple_fwd(VEG_FWD(tups))...));
+  }
+
+  template<typename... Targets, usize... Is, typename... Refs>
+  VEG_INLINE static constexpr auto from_ref_to_result(
+    Tag<Tuple<Targets...>> /*tag*/,
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Refs...>
+      refs) VEG_NOEXCEPT->proxsuite::linalg::veg::Tuple<Targets...>
+  {
+    return {
+      inplace[tuplify{}],
+      _detail::MoveFn<Targets>{ __VEG_IMPL_LEAF_ONCE(refs, Is, Targets) }...,
+    };
+  }
+
+  VEG_INLINE static auto apply() VEG_NOEXCEPT->Tuple<> { return {}; }
+
+  template<usize... Is, typename... Ts, typename... Tuples>
+  VEG_INLINE static constexpr auto apply(
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>&&
+      first,
+    Tuples&&... rest)
+    VEG_NOEXCEPT->proxsuite::linalg::veg::meta::type_sequence_cat<
+      Tuple,
+      Tuple<Ts...>,
+      typename _detail::meta_::IndexedToTuple<Tuples>::Type...>
+  {
+    return cat::apply2(VEG_FWD(first), cat::apply(VEG_FWD(rest)...));
+  }
+
+  template<usize... Is, typename... Ts, usize... Js, typename... Us>
+  VEG_INLINE static constexpr auto apply2(
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>, Ts...>&&
+      first,
+    IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Js...>, Us...>&&
+      second) VEG_NOEXCEPT->Tuple<Ts..., Us...>
+  {
+    return {
+      tuplify{},
+      __VEG_IMPL_LEAF_ONCE(first, Is, Ts)...,
+      __VEG_IMPL_LEAF_ONCE(second, Js, Us)...,
+    };
+  }
+};
+
+struct deref_assign
+{
+  VEG_TEMPLATE(
+    (typename... Ts, typename... Us, usize... Is),
+    requires(VEG_ALL_OF(VEG_CONCEPT(assignable<Ts&, Us const&>))),
+    VEG_INLINE VEG_CPP14(constexpr) void
+    operator(),
+    (ts,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  RefMut<Ts>...>),
+    (us,
+     IndexedTuple<proxsuite::linalg::veg::meta::index_sequence<Is...>,
+                  Ref<Us>...>))
+  const VEG_NOEXCEPT_IF(
+    VEG_ALL_OF(VEG_CONCEPT(nothrow_assignable<Ts&, Us const&>)))
+  {
+    VEG_EVAL_ALL(__VEG_IMPL_LEAF_MUT(ts, Is, RefMut<Ts>).get() =
+                   __VEG_IMPL_LEAF(us, Is, Ref<Us>).get());
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(with);
+
+VEG_NIEBLOID(zip);
+VEG_NIEBLOID(cat);
+
+VEG_NIEBLOID(unpack);
+
+VEG_NIEBLOID(for_each);
+VEG_NIEBLOID(for_each_i);
+VEG_NIEBLOID(map);
+VEG_NIEBLOID(map_i);
+
+VEG_NIEBLOID(deref_assign);
+} // namespace tuple
+
+namespace cpo {
+template<usize... Is, typename... Ts>
+struct is_trivially_relocatable<
+  tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
+  : meta::bool_constant<(VEG_ALL_OF(is_trivially_relocatable<Ts>::value))>
+{};
+template<usize... Is, typename... Ts>
+struct is_trivially_constructible<
+  tuple::IndexedTuple<meta::index_sequence<Is...>, Ts...>>
+  : meta::bool_constant<(VEG_ALL_OF(is_trivially_constructible<Ts>::value))>
+{};
+
+template<typename... Ts>
+struct is_trivially_relocatable<tuple::Tuple<Ts...>>
+  : meta::bool_constant<(VEG_ALL_OF(is_trivially_relocatable<Ts>::value))>
+{};
+template<typename... Ts>
+struct is_trivially_constructible<tuple::Tuple<Ts...>>
+  : meta::bool_constant<(VEG_ALL_OF(is_trivially_constructible<Ts>::value))>
+{};
+} // namespace cpo
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+template<typename... Ts>
+struct std::tuple_size<proxsuite::linalg::veg::Tuple<Ts...>>
+  : ::proxsuite::linalg::veg::meta::constant<proxsuite::linalg::veg::usize,
+                                             sizeof...(Ts)>
+{};
+template<proxsuite::linalg::veg::usize I, typename... Ts>
+struct std::tuple_element<I, proxsuite::linalg::veg::Tuple<Ts...>>
+{
+  using type = proxsuite::linalg::veg::ith<I, Ts...>;
+};
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_TUPLE_HPP_B8PHUNWES */
```

## cmeel.prefix/include/proxsuite/linalg/veg/vec.hpp

 * *Ordering differences only*

```diff
@@ -1,1034 +1,1034 @@
-#ifndef VEG_VECTOR_HPP_QWFSH3ROS
-#define VEG_VECTOR_HPP_QWFSH3ROS
-
-#include "proxsuite/linalg/veg/internal/delete_special_members.hpp"
-#include "proxsuite/linalg/veg/memory/alloc.hpp"
-#include "proxsuite/linalg/veg/internal/collection_algo.hpp"
-#include "proxsuite/linalg/veg/internal/narrow.hpp"
-#include "proxsuite/linalg/veg/slice.hpp"
-#include "proxsuite/linalg/veg/util/unreachable.hpp"
-
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-namespace _vector {
-namespace adl {
-struct AdlBase
-{};
-} // namespace adl
-} // namespace _vector
-} // namespace _detail
-
-namespace _detail {
-template<typename T>
-VEG_INLINE constexpr auto
-min2(T a, T b) noexcept -> T
-{
-  return (static_cast<T const&>(a) < static_cast<T const&>(b)) ? VEG_FWD(a)
-                                                               : VEG_FWD(b);
-}
-template<typename T>
-VEG_INLINE constexpr auto
-max2(T a, T b) noexcept -> T
-{
-  return (static_cast<T const&>(a) < static_cast<T const&>(b)) ? VEG_FWD(b)
-                                                               : VEG_FWD(a);
-}
-
-namespace _collections {
-VEG_INLINE constexpr auto
-vector_grow_compute(usize current_cap) noexcept -> usize
-{
-  return current_cap + current_cap;
-}
-// new_cap must be larger than current_cap
-VEG_INLINE constexpr auto
-vector_grow_choose(usize current_cap, usize new_cap) noexcept -> usize
-{
-  return _detail::max2(_collections::vector_grow_compute(current_cap), new_cap);
-}
-
-template<typename T>
-auto
-relocate(void* out, void const* in, usize nbytes) noexcept -> void*;
-
-struct relocate_pointer_trivial
-{
-  static constexpr void* (*value)(void*, void const*, usize) = &mem::memmove;
-};
-template<typename T, bool = cpo::is_trivially_relocatable<T>::value>
-struct relocate_pointer : relocate_pointer_trivial
-{};
-
-template<typename T>
-struct relocate_pointer<T, false>
-{
-  static constexpr void* (*value)(void*,
-                                  void const*,
-                                  usize) = _collections::relocate<T>;
-};
-} // namespace _collections
-} // namespace _detail
-
-namespace collections {
-template<typename T>
-struct relocate_pointer : _detail::_collections::relocate_pointer<T>
-{};
-} // namespace collections
-
-namespace vector {
-template<typename T>
-struct RawVector
-{
-  T* data;
-  T* end;
-  T* end_alloc;
-
-  VEG_INLINE constexpr auto len() const noexcept -> usize
-  {
-    return static_cast<usize>(end - data);
-  }
-  VEG_INLINE constexpr auto cap() const noexcept -> usize
-  {
-    return static_cast<usize>(end_alloc - data);
-  }
-};
-} // namespace vector
-
-namespace _detail {
-namespace _collections {
-template<bool IsNoExcept>
-struct CloneImpl;
-
-template<bool NoThrow, typename T, typename A, typename C>
-struct CloneFn
-{
-  RefMut<A> alloc;
-  RefMut<C> cloner;
-  T const* in;
-  VEG_CPP14(constexpr)
-  VEG_INLINE auto operator()() VEG_NOEXCEPT_IF(NoThrow) -> T
-  {
-    return mem::Cloner<C>::clone(cloner, ref(*in), alloc);
-  }
-};
-
-template<>
-struct CloneImpl<true>
-{
-  template<typename T, typename A, typename C>
-  static VEG_CPP14(constexpr) void fn( //
-    RefMut<A> alloc,
-    RefMut<C> cloner,
-    T* out,
-    T* out_end,
-    T const* in) VEG_NOEXCEPT
-  {
-    for (; out < out_end; ++out, ++in) {
-      mem::construct_with(out, CloneFn<true, T, A, C>{ alloc, cloner, in });
-    }
-  }
-};
-
-template<>
-struct CloneImpl<false>
-{
-  template<typename T, typename A, typename C>
-  static void fn( //
-    RefMut<A> alloc,
-    RefMut<C> cloner,
-    T* out,
-    T* out_end,
-    T const* in) VEG_NOEXCEPT_IF(false)
-  {
-
-    Defer<Cleanup<T, A, C>> _{ { alloc, cloner, out, out_end } };
-    for (; _.fn.ptr < _.fn.ptr_end; ++_.fn.ptr, ++in) {
-      mem::construct_with(_.fn.ptr,
-                          CloneFn<false, T, A, C>{
-                            _.fn.alloc,
-                            _.fn.cloner,
-                            in,
-                          });
-    }
-  }
-};
-
-template<typename T, typename A, typename C>
-VEG_CPP14(constexpr)
-void slice_clone(RefMut<A> alloc,
-                 RefMut<C> cloner,
-                 T* out,
-                 T* out_end,
-                 T const* in)
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_clone<C, T, A>))
-{
-  CloneImpl<VEG_CONCEPT(alloc::nothrow_clone<C, T, A>)>::fn(
-    alloc, cloner, out, out_end, in);
-}
-
-template<typename T, typename A, typename C>
-VEG_CPP14(constexpr)
-void slice_clone_from(RefMut<A> alloc,
-                      RefMut<C> cloner,
-                      T* out,
-                      T* out_end,
-                      T const* in) VEG_NOEXCEPT_IF(true)
-{
-  while (true) {
-    if (out == out_end) {
-      break;
-    }
-    mem::Cloner<C>::clone_from( //
-      RefMut<C>(cloner),
-      mut(*out),
-      ref(*in),
-      RefMut<A>(alloc));
-    ++out;
-    ++in;
-  }
-}
-
-template<typename T>
-auto
-relocate(void* out, void const* in, usize nbytes) noexcept -> void*
-{
-  T* out_T = static_cast<T*>(out);
-  T* in_T = const_cast<T*>(static_cast<T const*>(in));
-  usize n = nbytes / sizeof(T);
-
-  for (usize i = 0; i < n; ++i) {
-    mem::construct_at(out_T + i, static_cast<T&&>(in_T[i]));
-    in_T[i].~T();
-  }
-
-  return out;
-}
-
-template<typename T>
-auto
-relocate_backward(void* out, void const* in, usize nbytes) noexcept -> void*
-{
-  T* out_T = static_cast<T*>(out);
-  T* in_T = const_cast<T*>(static_cast<T const*>(in));
-  usize n = nbytes / sizeof(T);
-
-  for (usize i = 0; i < n; ++i) {
-    mem::construct_at(out_T + (n - i - 1), static_cast<T&&>(in_T[n - i - 1]));
-    in_T[n - i - 1].~T();
-  }
-
-  return out;
-}
-
-template<typename A>
-struct AllocCleanup
-{
-  RefMut<A> alloc;
-  void* data;
-  mem::Layout layout;
-
-  VEG_INLINE VEG_CPP14(constexpr) void operator()()
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_dealloc<A>))
-  {
-    if (data != nullptr) {
-      mem::Alloc<A>::dealloc(
-        RefMut<A>(alloc), static_cast<void*>(data), mem::Layout(layout));
-    }
-  }
-};
-
-template<typename T, typename A, typename C>
-auto
-alloc_and_copy(RefMut<A> alloc, RefMut<C> cloner, T const* data, usize len)
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
-                  VEG_CONCEPT(alloc::nothrow_clone<C, T, A>)) -> mem::AllocBlock
-{
-
-  mem::AllocBlock block = mem::Alloc<A>::alloc(
-    RefMut<A>(alloc), mem::Layout{ sizeof(T) * usize(len), alignof(T) });
-
-  // if copying fails, this takes care of deallocating
-  Defer<AllocCleanup<A>> _{ {
-    alloc,
-    block.data,
-    mem::Layout{ block.byte_cap, alignof(T) },
-  } };
-
-  // copy construct elements
-  _collections::slice_clone(_.fn.alloc,
-                            cloner,
-                            static_cast<T*>(block.data),
-                            static_cast<T*>(block.data) + len,
-                            data);
-
-  _.fn.data = nullptr;
-  return block;
-}
-
-template<typename T, typename A, typename C>
-auto
-realloc_and_append( //
-  RefMut<A> alloc,
-  RefMut<C> cloner,
-  mem::AllocBlock out,
-  usize out_len,
-  T const* in,
-  usize in_len) VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
-                                VEG_CONCEPT(alloc::nothrow_clone<C, T, A>))
-  -> mem::AllocBlock
-{
-
-  if (in_len == 0) {
-    return out;
-  }
-
-  if (out.byte_cap >= (in_len + out_len) * sizeof(T)) {
-    mem::AllocBlock block = mem::Alloc<A>::grow(
-      RefMut<A>(alloc),
-      static_cast<void*>(out.data),
-      mem::Layout{ out.byte_cap, alignof(T) },
-      out_len * sizeof(T),
-      mem::RelocFn{ collections::relocate_pointer<T>::value });
-
-    // if copying fails, this takes care of deallocating
-    Defer<AllocCleanup<A>> _{ {
-      alloc,
-      block.data,
-      mem::Layout{ block.byte_cap, alignof(T) },
-    } };
-    // if copying fails, this takes care of destroying
-    Defer<Cleanup<T, A, C>> destroy{ {
-      _.fn.alloc,
-      cloner,
-      static_cast<T*>(block.data),
-      static_cast<T*>(block.data) + out_len,
-    } };
-
-    // copy construct elements
-    _collections::slice_clone( //
-      destroy.fn.alloc,
-      destroy.fn.cloner,
-      static_cast<T*>(block.data) + out_len,
-      static_cast<T*>(block.data) + in_len,
-      in);
-    // disable destruction
-    destroy.fn.ptr = nullptr;
-    destroy.fn.ptr_end = nullptr;
-    // disable deallocation
-    _.fn.data = nullptr;
-    out = block;
-  } else {
-    // copy construct elements
-    _collections::slice_clone( //
-      alloc,
-      cloner,
-      static_cast<T*>(out.data) + out_len,
-      static_cast<T*>(out.data) + in_len,
-      in);
-  }
-  return out;
-}
-
-template<bool TrivialAssign>
-struct CloneFromImpl;
-
-template<>
-struct CloneFromImpl<false>
-{
-  template<typename T, typename A, typename C>
-  static void fn(RefMut<A> lhs_alloc,
-                 RefMut<C> cloner,
-                 vector::RawVector<T>& lhs_raw,
-                 Ref<A> rhs_alloc,
-                 vector::RawVector<T> const rhs_raw)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&    //
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&       //
-                    VEG_CONCEPT(alloc::nothrow_clone<C, T, A>) && //
-                    VEG_CONCEPT(alloc::nothrow_clone_from<C, T, A>))
-  {
-
-    vector::RawVector<T> lhs_copy = lhs_raw;
-    usize rhs_len = (rhs_raw.end - rhs_raw.data);
-
-    if (!(lhs_alloc == rhs_alloc)) {
-      T* data = lhs_copy.data;
-      T* data_end = lhs_copy.end;
-
-      // clean up old alloc
-      _collections::backward_destroy(lhs_alloc, cloner, data, data_end);
-
-      // assign before deallocation in case it fails
-      lhs_raw = {};
-      lhs_copy = {};
-
-      // don't need to deallocate on backward_destroy failure, since lhs can
-      // still access and reuse the allocation
-      mem::Alloc<A>::dealloc( //
-        RefMut<A>(lhs_alloc),
-        static_cast<void*>(data),
-        mem::Layout{ (lhs_copy.end_alloc - lhs_copy.data) * sizeof(T),
-                     alignof(T) });
-    }
-
-    lhs_alloc.get() = rhs_alloc.get();
-
-    if (lhs_raw.data == nullptr) {
-      usize len = rhs_raw.end - rhs_raw.data;
-
-      mem::AllocBlock blk =
-        _collections::alloc_and_copy(lhs_alloc, cloner, rhs_raw.data, len);
-      T* data = static_cast<T*>(blk.data);
-      lhs_raw = {
-        data,
-        data + len,
-        data + blk.byte_cap / sizeof(T),
-      };
-      return;
-    }
-
-    usize assign_len = _detail::min2(lhs_copy.len(), rhs_raw.len());
-    // copy assign until the shared len
-    _collections::slice_clone_from( //
-      lhs_alloc,
-      cloner,
-      lhs_copy.data,
-      lhs_copy.data + assign_len,
-      rhs_raw.data);
-
-    // destroy from the shared len until end of lhs
-    lhs_raw.end = lhs_raw.data + assign_len;
-    _collections::backward_destroy( //
-      lhs_alloc,
-      cloner,
-      lhs_copy.data + assign_len,
-      lhs_copy.end);
-
-    // pass allocation to realloc_and_append
-
-    lhs_raw = {};
-    // realloc and copy construct new elements until end of rhs
-    mem::AllocBlock block = _collections::realloc_and_append(
-      lhs_alloc,
-      cloner,
-      mem::AllocBlock{
-        lhs_copy.data,
-        (lhs_copy.end_alloc - lhs_copy.data) * sizeof(T),
-      },                         // out
-      assign_len,                // out_len
-      rhs_raw.data + assign_len, // in
-      rhs_len - assign_len);     // in_len
-
-    lhs_raw = vector::RawVector<T>{
-      static_cast<T*>(block.data),
-      static_cast<T*>(block.data) + rhs_len,
-      static_cast<T*>(block.data) + block.byte_cap / sizeof(T),
-    };
-  }
-};
-template<>
-struct CloneFromImpl<true>
-{
-  template<typename T, typename A, typename C>
-  static void fn(RefMut<A> lhs_alloc,
-                 RefMut<C> cloner,
-                 vector::RawVector<T>& lhs_raw,
-                 Ref<A> rhs_alloc,
-                 vector::RawVector<T> const rhs_raw)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) && //
-                    VEG_CONCEPT(alloc::nothrow_dealloc<A>) &&
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-
-    vector::RawVector<T> lhs_copy = lhs_raw;
-
-    bool need_to_realloc = (!(lhs_alloc.get() == rhs_alloc.get()) ||
-                            (lhs_copy.cap() < rhs_raw.len()));
-    if (need_to_realloc) {
-      T* data = lhs_copy.data;
-      usize cap = lhs_copy.cap();
-
-      // assign before deallocation in case it fails
-      lhs_raw = {};
-      mem::Alloc<A>::dealloc( //
-        RefMut<A>(lhs_alloc),
-        static_cast<void*>(data),
-        mem::Layout{ cap * sizeof(T), alignof(T) });
-      lhs_copy = {};
-    }
-
-    lhs_alloc.get() = rhs_alloc.get();
-
-    // allocate and copy all elements
-    if (need_to_realloc) {
-      mem::AllocBlock block = _collections::alloc_and_copy( //
-        lhs_alloc,
-        cloner,
-        rhs_raw.data,
-        rhs_raw.len());
-      lhs_raw.data = static_cast<T*>(block.data);
-      lhs_raw.end_alloc = lhs_raw.data + block.byte_cap / sizeof(T);
-    } else {
-      _collections::slice_clone( //
-        lhs_alloc,
-        cloner,
-        lhs_copy.data,
-        lhs_copy.data + rhs_raw.len(),
-        rhs_raw.data);
-    }
-    lhs_raw.end = lhs_raw.data + rhs_raw.len();
-  }
-};
-
-template<typename T, typename A, typename C>
-VEG_INLINE void
-clone_from(RefMut<A> lhs_alloc,
-           RefMut<C> cloner,
-           vector::RawVector<T>& lhs_raw,
-           Ref<A> rhs_alloc,
-           vector::RawVector<T> const rhs_raw)
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&    //
-                  VEG_CONCEPT(alloc::nothrow_alloc<A>) &&       //
-                  VEG_CONCEPT(alloc::nothrow_clone<C, T, A>) && //
-                  VEG_CONCEPT(alloc::nothrow_clone_from<C, T, A>))
-{
-  _collections::CloneFromImpl<
-    mem::Cloner<C>::template trivial_clone<T>::value>::fn(lhs_alloc,
-                                                          cloner,
-                                                          lhs_raw,
-                                                          rhs_alloc,
-                                                          rhs_raw);
-}
-} // namespace _collections
-} // namespace _detail
-
-namespace _detail {
-namespace _vector {
-
-template<typename T>
-struct RawVectorMoveRaii /* NOLINT */
-{
-  vector::RawVector<T> _ = {};
-
-  RawVectorMoveRaii() = default;
-  RawVectorMoveRaii(FromRawParts /*tag*/,
-                    vector::RawVector<T> inner) VEG_NOEXCEPT : _{ inner } {};
-  VEG_INLINE VEG_CPP14(constexpr)
-    RawVectorMoveRaii(RawVectorMoveRaii&& rhs) VEG_NOEXCEPT : _{ rhs._ }
-  {
-    rhs._ = {};
-  }
-  VEG_INLINE VEG_CPP14(constexpr)
-    RawVectorMoveRaii(RawVectorMoveRaii const& /*rhs*/) VEG_NOEXCEPT
-  {
-  }
-};
-
-template<typename T, typename A>
-struct VecAlloc
-  :
-  // alloc manager needs to be constructed first
-  Tuple<A, RawVectorMoveRaii<T>>
-{
-  using Tuple<A, RawVectorMoveRaii<T>>::Tuple;
-
-public:
-  VecAlloc(VecAlloc const&) = default;
-  VecAlloc(VecAlloc&&) = default;
-  auto operator=(VecAlloc const&) -> VecAlloc& = default;
-  auto operator=(VecAlloc&&) -> VecAlloc& = default;
-
-  VEG_INLINE ~VecAlloc() VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_dealloc<A>))
-  {
-    vector::RawVector<T> raw = (*this)[1_c]._;
-    if ((raw.data != nullptr) && (raw.end_alloc != 0)) {
-
-      // FIXME: if asan is enabled, before sanitizing make sure that:
-      //  - begin is 8 byte aligned
-      //  - either:
-      //    - end is 8 byte aligned
-      //    - A is the SystemAlloc
-#if VEG_HAS_ASAN
-      _detail::__sanitizer_annotate_contiguous_container( //
-        raw.data,
-        raw.end_alloc,
-        raw.data,
-        raw.end_alloc);
-#endif
-
-      mem::Alloc<A>::dealloc(
-        mut((*this)[0_c]),
-        static_cast<void*>(raw.data),
-        mem::Layout{ usize(raw.end_alloc - raw.data) * sizeof(T), alignof(T) });
-    }
-  }
-};
-} // namespace _vector
-} // namespace _detail
-
-#if VEG_HAS_ASAN
-#define __VEG_ASAN_ANNOTATE() /* NOLINT */                                     \
-  if (ptr() != nullptr) {                                                      \
-    _detail::__sanitizer_annotate_contiguous_container(                        \
-      ptr(), ptr() + capacity(), ptr() + len(), ptr() + capacity());           \
-  }                                                                            \
-  auto&& _veglib_asan = defer([&]() noexcept {                                 \
-    if (ptr() != nullptr) {                                                    \
-      _detail::__sanitizer_annotate_contiguous_container(                      \
-        ptr(), ptr() + capacity(), ptr() + capacity(), ptr() + len());         \
-    }                                                                          \
-  });                                                                          \
-  (void)_veglib_asan
-#else
-#define __VEG_ASAN_ANNOTATE() /* NOLINT */ (void)0;
-#endif
-
-namespace _detail {
-namespace _collections {
-template<typename T,
-         typename A = mem::SystemAlloc,
-         mem::DtorAvailable Dtor = mem::DtorAvailableFor<T>::value,
-         mem::CopyAvailable Copy = mem::CopyAvailableFor<T>::value>
-struct VecImpl
-{
-private:
-  _detail::_vector::VecAlloc<T, A> _;
-
-public:
-  VEG_NODISCARD VEG_INLINE
-    VEG_CPP14(constexpr) auto alloc_ref() const VEG_NOEXCEPT->Ref<A>
-  {
-    return ref(_[0_c]);
-  }
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto raw_ref() const
-    VEG_NOEXCEPT->Ref<vector::RawVector<T>>
-  {
-    return ref(_[1_c]._);
-  }
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto alloc_mut(Unsafe /*tag*/)
-    VEG_NOEXCEPT->RefMut<A>
-  {
-    return mut(_[0_c]);
-  }
-  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto raw_mut(Unsafe /*tag*/)
-    VEG_NOEXCEPT->RefMut<vector::RawVector<T>>
-  {
-    return mut(_[1_c]._);
-  }
-
-private:
-  VEG_INLINE void _reserve_grow_exact_impl(Unsafe /*tag*/, usize new_cap)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
-  {
-    __VEG_ASAN_ANNOTATE();
-
-    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
-    auto len = usize(this->len());
-
-    mem::AllocBlock new_block = mem::Alloc<A>::grow(
-      this->alloc_mut(unsafe),
-      static_cast<void*>(raw.data),
-      mem::Layout{
-        usize(byte_capacity()),
-        alignof(T),
-      },
-      new_cap * sizeof(T),
-      mem::RelocFn{ collections::relocate_pointer<T>::value });
-
-    T* data = static_cast<T*>(new_block.data);
-    raw = {
-      data,
-      data + len,
-      data + new_block.byte_cap / sizeof(T),
-    };
-  }
-  VEG_INLINE void _reserve_grow_exact(Unsafe /*tag*/, isize new_cap)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
-  {
-    isize old_len = len();
-    this->_reserve_grow_exact_impl(unsafe, usize(new_cap));
-    meta::unreachable_if(capacity() < new_cap);
-    meta::unreachable_if(len() != old_len);
-  }
-  VEG_INLINE void _reserve_one_more(Unsafe /*tag*/)
-  {
-    this->_reserve_grow_exact(
-      unsafe,
-      1 + isize(_detail::_collections::vector_grow_compute(usize(capacity()))));
-  }
-
-  static_assert(VEG_CONCEPT(nothrow_move_assignable<A>), ".");
-  static_assert(VEG_CONCEPT(nothrow_movable<A>), ".");
-
-public:
-  VEG_INLINE ~VecImpl()
-    VEG_NOEXCEPT_IF(Dtor == mem::DtorAvailable::yes_nothrow &&
-                    VEG_CONCEPT(alloc::nothrow_dealloc<A>))
-  {
-    static_assert(Dtor == mem::DtorAvailableFor<T>::value, ".");
-    vector::RawVector<T> raw = this->raw_ref().get();
-    if (raw.data != nullptr) {
-      this->clear();
-    }
-  }
-
-  VEG_INLINE VecImpl() = default;
-
-  VEG_INLINE
-  VecImpl(Unsafe /*unsafe*/,
-          FromRawParts /*tag*/,
-          vector::RawVector<T> rawvec,
-          A alloc) VEG_NOEXCEPT
-    : _{
-      tuplify,
-      VEG_FWD(alloc),
-      _detail::_vector::RawVectorMoveRaii<T>{ from_raw_parts, rawvec },
-    }
-  {
-  }
-
-  VEG_INLINE VecImpl(VecImpl&&) = default;
-  VEG_INLINE auto operator=(VecImpl&& rhs) -> VecImpl&
-  {
-    {
-      auto cleanup = static_cast<VecImpl&&>(*this);
-    }
-
-    // can't fail
-    this->alloc_mut(unsafe).get() =
-      static_cast<A&&>(rhs.alloc_mut(unsafe).get());
-    this->raw_mut(unsafe).get() = rhs.raw_ref().get();
-    rhs.raw_mut(unsafe).get() = {};
-
-    return *this;
-  };
-
-  explicit VecImpl(VecImpl const& rhs)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<A>) && //
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
-                    Copy == mem::CopyAvailable::yes_nothrow)
-    : _{ rhs._ }
-  {
-    static_assert(Copy == mem::CopyAvailableFor<T>::value, ".");
-    __VEG_ASAN_ANNOTATE();
-    vector::RawVector<T> rhs_raw = rhs.raw_ref().get();
-    mem::AllocBlock blk =
-      _detail::_collections::alloc_and_copy(this->alloc_mut(unsafe),
-                                            mut(mem::DefaultCloner{}),
-                                            rhs_raw.data,
-                                            usize(rhs.len()));
-
-    T* data = static_cast<T*>(blk.data);
-    this->raw_mut(unsafe).get() = vector::RawVector<T>{
-      data,
-      data + usize(rhs.len()),
-      data + blk.byte_cap / sizeof(T),
-    };
-  }
-
-  auto operator=(VecImpl const& rhs)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
-                    Copy == mem::CopyAvailable::yes_nothrow) -> VecImpl&
-  {
-    static_assert(Copy == mem::CopyAvailableFor<T>::value, ".");
-    if (this != mem::addressof(rhs)) {
-      __VEG_ASAN_ANNOTATE();
-
-      _detail::_collections::clone_from(this->alloc_mut(unsafe),
-                                        mut(mem::DefaultCloner{}),
-                                        this->raw_mut(unsafe).get(),
-                                        rhs.alloc_ref(),
-                                        rhs.raw_ref().get());
-    }
-    return *this;
-  }
-
-  VEG_INLINE void reserve_exact(isize new_cap)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
-  {
-    if (new_cap > capacity()) {
-      this->_reserve_grow_exact(unsafe, new_cap);
-    }
-  }
-  VEG_INLINE void reserve(isize new_cap)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
-  {
-    auto cap = capacity();
-    if (new_cap > cap) {
-      this->reserve_exact(isize(
-        _detail::_collections::vector_grow_choose(usize(cap), usize(new_cap))));
-    }
-  }
-
-  VEG_INLINE void pop_several_unchecked(Unsafe unsafe, isize n)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
-  {
-    VEG_DEBUG_ASSERT_ALL_OF(0 <= n, n <= len());
-    __VEG_ASAN_ANNOTATE();
-
-    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
-
-    T* end = raw.end;
-    raw.end -= n;
-    _detail::_collections::backward_destroy(
-      this->alloc_mut(unsafe), mut(mem::DefaultCloner{}), end - n, end);
-  }
-
-  VEG_INLINE void pop_several(isize n)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
-  {
-    VEG_ASSERT_ALL_OF(0 <= n, n <= len());
-    pop_several_unchecked(unsafe, n);
-  }
-
-  VEG_INLINE auto pop_unchecked(Unsafe /*unsafe*/)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
-  {
-    VEG_DEBUG_ASSERT(1 <= len());
-    T* last = raw_ref().get().end - 1;
-    T t = static_cast<T&&>(*last);
-    --raw_mut(unsafe).get().end;
-    mem::destroy_at(last);
-    return t;
-  }
-  VEG_INLINE auto pop_mid_unchecked(Unsafe /*unsafe*/, isize i)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
-  {
-    VEG_DEBUG_ASSERT(0 <= i);
-    VEG_DEBUG_ASSERT(i < len());
-    T* elem = raw_ref().get().data + i;
-    T t = static_cast<T&&>(*elem);
-
-    // this block does not throw
-    {
-      mem::destroy_at(elem);
-      _detail::_collections::relocate<T>( //
-        elem,
-        elem + 1,
-        sizeof(T) * usize(len() - i - 1));
-    }
-    --raw_mut(unsafe).get().end;
-
-    return t;
-  }
-
-  VEG_INLINE auto pop() VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
-  {
-    VEG_ASSERT(1 <= len());
-    return pop_unchecked(unsafe);
-  }
-  VEG_INLINE auto pop_mid(isize i)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
-  {
-    VEG_ASSERT(0 <= i);
-    VEG_ASSERT(i < len());
-    return pop_mid_unchecked(unsafe, i);
-  }
-
-  VEG_INLINE void clear() VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
-  {
-    pop_several_unchecked(unsafe, len());
-  }
-
-  VEG_TEMPLATE(typename U = T,
-               requires(VEG_CONCEPT(constructible<U>)),
-               void resize,
-               (n, isize))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
-                  VEG_CONCEPT(nothrow_constructible<T>))
-  {
-
-    vector::RawVector<T>& raw = raw_mut(unsafe).get();
-
-    if (n > len()) {
-      reserve(n);
-      {
-        __VEG_ASAN_ANNOTATE();
-        ::new (static_cast<void*>(ptr_mut() + len())) T[usize(n - len())]{};
-        raw.end = raw.data + n;
-      }
-    } else {
-      pop_several_unchecked(unsafe, len() - n);
-    }
-  }
-
-  VEG_TEMPLATE(typename U = T,
-               requires(VEG_CONCEPT(constructible<U>)),
-               void resize_for_overwrite,
-               (n, isize))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
-                  VEG_CONCEPT(nothrow_constructible<T>))
-  {
-
-    vector::RawVector<T>& raw = raw_mut(unsafe).get();
-
-    if (n > len()) {
-      reserve(n);
-      {
-        __VEG_ASAN_ANNOTATE();
-        ::new (static_cast<void*>(ptr_mut() + len())) T[usize(n - len())];
-        raw.end = raw.data + n;
-      }
-    } else {
-      pop_several_unchecked(unsafe, len() - n);
-    }
-  }
-
-  VEG_TEMPLATE(typename Fn,
-               requires(VEG_CONCEPT(fn_once<Fn, T>)),
-               VEG_INLINE void push_mid_with,
-               (fn, Fn),
-               (i, isize))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
-                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-    static_assert(VEG_CONCEPT(nothrow_fn_once<Fn, T>), ".");
-
-    VEG_ASSERT_ALL_OF(0 <= i, i <= len());
-
-    reserve(len() + 1);
-    {
-      __VEG_ASAN_ANNOTATE();
-      vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
-      T* elem = raw.data + i;
-      _detail::_collections::relocate_backward<T>( //
-        elem + 1,
-        elem,
-        sizeof(T) * usize(raw.end - elem));
-      mem::construct_with(elem, VEG_FWD(fn));
-      ++raw.end;
-    }
-  }
-  VEG_INLINE void push_mid(T value, isize i)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>) &&
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-    this->push_mid_with(_detail::MoveFn<T>{ VEG_FWD(value) }, i);
-  }
-
-  VEG_TEMPLATE(typename Fn,
-               requires(VEG_CONCEPT(fn_once<Fn, T>)),
-               VEG_INLINE void push_with_unchecked,
-               (/*tag*/, Unsafe),
-               (fn, Fn))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
-                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-    __VEG_ASAN_ANNOTATE();
-
-    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
-    mem::construct_with(raw.end, VEG_FWD(fn));
-    ++raw.end;
-  }
-
-  VEG_TEMPLATE(typename Fn,
-               requires(VEG_CONCEPT(fn_once<Fn, T>)),
-               VEG_INLINE void push_with,
-               (fn, Fn))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
-                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-    vector::RawVector<T> raw = this->raw_ref().get();
-    if (HEDLEY_UNLIKELY(raw.end == raw.end_alloc)) {
-      this->_reserve_one_more(unsafe);
-    }
-    this->push_with_unchecked(unsafe, VEG_FWD(fn));
-  }
-  VEG_INLINE void push(T value)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>) &&
-                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
-  {
-    this->push_with(_detail::MoveFn<T>{ VEG_FWD(value) });
-  }
-  VEG_INLINE void push_unchecked(Unsafe /*tag*/, T value)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>))
-  {
-    this->push_with_unchecked(unsafe, _detail::MoveFn<T>{ VEG_FWD(value) });
-  }
-
-  VEG_NODISCARD VEG_INLINE auto as_ref() const VEG_NOEXCEPT->Slice<T>
-  {
-    return { unsafe, from_raw_parts, ptr(), len() };
-  }
-  VEG_NODISCARD VEG_INLINE auto as_mut() VEG_NOEXCEPT->SliceMut<T>
-  {
-    return { unsafe, from_raw_parts, ptr_mut(), len() };
-  }
-
-  VEG_NODISCARD VEG_INLINE auto ptr() const VEG_NOEXCEPT->T const*
-  {
-    return this->raw_ref().get().data;
-  }
-  VEG_NODISCARD VEG_INLINE auto ptr_mut() VEG_NOEXCEPT->T*
-  {
-    return const_cast<T*>(this->ptr());
-  }
-  VEG_NODISCARD VEG_INLINE auto len() const VEG_NOEXCEPT->isize
-  {
-    auto& raw = this->raw_ref().get();
-    return isize(raw.end - raw.data);
-  }
-  VEG_NODISCARD VEG_INLINE auto capacity() const VEG_NOEXCEPT->isize
-  {
-    auto& raw = this->raw_ref().get();
-    return isize(raw.end_alloc - raw.data);
-  }
-  VEG_NODISCARD VEG_INLINE auto byte_capacity() const VEG_NOEXCEPT->isize
-  {
-    auto& raw = this->raw_ref().get();
-    return meta::is_consteval()
-             ? (raw.end_alloc - raw.data) * isize(sizeof(T))
-             : (reinterpret_cast<char const*>(raw.end_alloc) -
-                reinterpret_cast<char const*>(raw.data));
-  }
-  VEG_NODISCARD VEG_INLINE auto operator[](isize i) const VEG_NOEXCEPT->T const&
-  {
-    VEG_ASSERT(usize(i) < usize(len()));
-    return this->ptr()[i];
-  }
-  VEG_NODISCARD VEG_INLINE auto operator[](isize i) VEG_NOEXCEPT->T&
-  {
-    return const_cast<T&>(static_cast<VecImpl const*>(this)->operator[](i));
-  }
-};
-} // namespace _collections
-} // namespace _detail
-
-template <
-		typename T,
-		typename A = mem::SystemAlloc,
-		mem::DtorAvailable Dtor = mem::DtorAvailableFor<T>::value,
-		mem::CopyAvailable Copy = mem::CopyAvailableFor<T>::value>
-struct Vec : private _detail::_vector::adl::AdlBase,
-						 private meta::if_t< //
-								 Copy == mem::CopyAvailable::no,
-								 _detail::NoCopy,
-								 _detail::Empty>,
-						 public _detail::_collections::VecImpl<T, A, Dtor, Copy>
-{
-
-  using _detail::_collections::VecImpl<T, A, Dtor, Copy>::VecImpl;
-  Vec() = default;
-  VEG_EXPLICIT_COPY(Vec);
-};
-
-template<typename T, typename A>
-struct cpo::is_trivially_relocatable<Vec<T, A>>
-  : cpo::is_trivially_relocatable<A>
-{};
-template<typename T, typename A>
-struct cpo::is_trivially_constructible<Vec<T, A>>
-  : cpo::is_trivially_constructible<A>
-{};
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#undef __VEG_ASAN_ANNOTATE
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_VECTOR_HPP_QWFSH3ROS */
+#ifndef VEG_VECTOR_HPP_QWFSH3ROS
+#define VEG_VECTOR_HPP_QWFSH3ROS
+
+#include "proxsuite/linalg/veg/internal/delete_special_members.hpp"
+#include "proxsuite/linalg/veg/memory/alloc.hpp"
+#include "proxsuite/linalg/veg/internal/collection_algo.hpp"
+#include "proxsuite/linalg/veg/internal/narrow.hpp"
+#include "proxsuite/linalg/veg/slice.hpp"
+#include "proxsuite/linalg/veg/util/unreachable.hpp"
+
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+namespace _vector {
+namespace adl {
+struct AdlBase
+{};
+} // namespace adl
+} // namespace _vector
+} // namespace _detail
+
+namespace _detail {
+template<typename T>
+VEG_INLINE constexpr auto
+min2(T a, T b) noexcept -> T
+{
+  return (static_cast<T const&>(a) < static_cast<T const&>(b)) ? VEG_FWD(a)
+                                                               : VEG_FWD(b);
+}
+template<typename T>
+VEG_INLINE constexpr auto
+max2(T a, T b) noexcept -> T
+{
+  return (static_cast<T const&>(a) < static_cast<T const&>(b)) ? VEG_FWD(b)
+                                                               : VEG_FWD(a);
+}
+
+namespace _collections {
+VEG_INLINE constexpr auto
+vector_grow_compute(usize current_cap) noexcept -> usize
+{
+  return current_cap + current_cap;
+}
+// new_cap must be larger than current_cap
+VEG_INLINE constexpr auto
+vector_grow_choose(usize current_cap, usize new_cap) noexcept -> usize
+{
+  return _detail::max2(_collections::vector_grow_compute(current_cap), new_cap);
+}
+
+template<typename T>
+auto
+relocate(void* out, void const* in, usize nbytes) noexcept -> void*;
+
+struct relocate_pointer_trivial
+{
+  static constexpr void* (*value)(void*, void const*, usize) = &mem::memmove;
+};
+template<typename T, bool = cpo::is_trivially_relocatable<T>::value>
+struct relocate_pointer : relocate_pointer_trivial
+{};
+
+template<typename T>
+struct relocate_pointer<T, false>
+{
+  static constexpr void* (*value)(void*,
+                                  void const*,
+                                  usize) = _collections::relocate<T>;
+};
+} // namespace _collections
+} // namespace _detail
+
+namespace collections {
+template<typename T>
+struct relocate_pointer : _detail::_collections::relocate_pointer<T>
+{};
+} // namespace collections
+
+namespace vector {
+template<typename T>
+struct RawVector
+{
+  T* data;
+  T* end;
+  T* end_alloc;
+
+  VEG_INLINE constexpr auto len() const noexcept -> usize
+  {
+    return static_cast<usize>(end - data);
+  }
+  VEG_INLINE constexpr auto cap() const noexcept -> usize
+  {
+    return static_cast<usize>(end_alloc - data);
+  }
+};
+} // namespace vector
+
+namespace _detail {
+namespace _collections {
+template<bool IsNoExcept>
+struct CloneImpl;
+
+template<bool NoThrow, typename T, typename A, typename C>
+struct CloneFn
+{
+  RefMut<A> alloc;
+  RefMut<C> cloner;
+  T const* in;
+  VEG_CPP14(constexpr)
+  VEG_INLINE auto operator()() VEG_NOEXCEPT_IF(NoThrow) -> T
+  {
+    return mem::Cloner<C>::clone(cloner, ref(*in), alloc);
+  }
+};
+
+template<>
+struct CloneImpl<true>
+{
+  template<typename T, typename A, typename C>
+  static VEG_CPP14(constexpr) void fn( //
+    RefMut<A> alloc,
+    RefMut<C> cloner,
+    T* out,
+    T* out_end,
+    T const* in) VEG_NOEXCEPT
+  {
+    for (; out < out_end; ++out, ++in) {
+      mem::construct_with(out, CloneFn<true, T, A, C>{ alloc, cloner, in });
+    }
+  }
+};
+
+template<>
+struct CloneImpl<false>
+{
+  template<typename T, typename A, typename C>
+  static void fn( //
+    RefMut<A> alloc,
+    RefMut<C> cloner,
+    T* out,
+    T* out_end,
+    T const* in) VEG_NOEXCEPT_IF(false)
+  {
+
+    Defer<Cleanup<T, A, C>> _{ { alloc, cloner, out, out_end } };
+    for (; _.fn.ptr < _.fn.ptr_end; ++_.fn.ptr, ++in) {
+      mem::construct_with(_.fn.ptr,
+                          CloneFn<false, T, A, C>{
+                            _.fn.alloc,
+                            _.fn.cloner,
+                            in,
+                          });
+    }
+  }
+};
+
+template<typename T, typename A, typename C>
+VEG_CPP14(constexpr)
+void slice_clone(RefMut<A> alloc,
+                 RefMut<C> cloner,
+                 T* out,
+                 T* out_end,
+                 T const* in)
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_clone<C, T, A>))
+{
+  CloneImpl<VEG_CONCEPT(alloc::nothrow_clone<C, T, A>)>::fn(
+    alloc, cloner, out, out_end, in);
+}
+
+template<typename T, typename A, typename C>
+VEG_CPP14(constexpr)
+void slice_clone_from(RefMut<A> alloc,
+                      RefMut<C> cloner,
+                      T* out,
+                      T* out_end,
+                      T const* in) VEG_NOEXCEPT_IF(true)
+{
+  while (true) {
+    if (out == out_end) {
+      break;
+    }
+    mem::Cloner<C>::clone_from( //
+      RefMut<C>(cloner),
+      mut(*out),
+      ref(*in),
+      RefMut<A>(alloc));
+    ++out;
+    ++in;
+  }
+}
+
+template<typename T>
+auto
+relocate(void* out, void const* in, usize nbytes) noexcept -> void*
+{
+  T* out_T = static_cast<T*>(out);
+  T* in_T = const_cast<T*>(static_cast<T const*>(in));
+  usize n = nbytes / sizeof(T);
+
+  for (usize i = 0; i < n; ++i) {
+    mem::construct_at(out_T + i, static_cast<T&&>(in_T[i]));
+    in_T[i].~T();
+  }
+
+  return out;
+}
+
+template<typename T>
+auto
+relocate_backward(void* out, void const* in, usize nbytes) noexcept -> void*
+{
+  T* out_T = static_cast<T*>(out);
+  T* in_T = const_cast<T*>(static_cast<T const*>(in));
+  usize n = nbytes / sizeof(T);
+
+  for (usize i = 0; i < n; ++i) {
+    mem::construct_at(out_T + (n - i - 1), static_cast<T&&>(in_T[n - i - 1]));
+    in_T[n - i - 1].~T();
+  }
+
+  return out;
+}
+
+template<typename A>
+struct AllocCleanup
+{
+  RefMut<A> alloc;
+  void* data;
+  mem::Layout layout;
+
+  VEG_INLINE VEG_CPP14(constexpr) void operator()()
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_dealloc<A>))
+  {
+    if (data != nullptr) {
+      mem::Alloc<A>::dealloc(
+        RefMut<A>(alloc), static_cast<void*>(data), mem::Layout(layout));
+    }
+  }
+};
+
+template<typename T, typename A, typename C>
+auto
+alloc_and_copy(RefMut<A> alloc, RefMut<C> cloner, T const* data, usize len)
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
+                  VEG_CONCEPT(alloc::nothrow_clone<C, T, A>)) -> mem::AllocBlock
+{
+
+  mem::AllocBlock block = mem::Alloc<A>::alloc(
+    RefMut<A>(alloc), mem::Layout{ sizeof(T) * usize(len), alignof(T) });
+
+  // if copying fails, this takes care of deallocating
+  Defer<AllocCleanup<A>> _{ {
+    alloc,
+    block.data,
+    mem::Layout{ block.byte_cap, alignof(T) },
+  } };
+
+  // copy construct elements
+  _collections::slice_clone(_.fn.alloc,
+                            cloner,
+                            static_cast<T*>(block.data),
+                            static_cast<T*>(block.data) + len,
+                            data);
+
+  _.fn.data = nullptr;
+  return block;
+}
+
+template<typename T, typename A, typename C>
+auto
+realloc_and_append( //
+  RefMut<A> alloc,
+  RefMut<C> cloner,
+  mem::AllocBlock out,
+  usize out_len,
+  T const* in,
+  usize in_len) VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
+                                VEG_CONCEPT(alloc::nothrow_clone<C, T, A>))
+  -> mem::AllocBlock
+{
+
+  if (in_len == 0) {
+    return out;
+  }
+
+  if (out.byte_cap >= (in_len + out_len) * sizeof(T)) {
+    mem::AllocBlock block = mem::Alloc<A>::grow(
+      RefMut<A>(alloc),
+      static_cast<void*>(out.data),
+      mem::Layout{ out.byte_cap, alignof(T) },
+      out_len * sizeof(T),
+      mem::RelocFn{ collections::relocate_pointer<T>::value });
+
+    // if copying fails, this takes care of deallocating
+    Defer<AllocCleanup<A>> _{ {
+      alloc,
+      block.data,
+      mem::Layout{ block.byte_cap, alignof(T) },
+    } };
+    // if copying fails, this takes care of destroying
+    Defer<Cleanup<T, A, C>> destroy{ {
+      _.fn.alloc,
+      cloner,
+      static_cast<T*>(block.data),
+      static_cast<T*>(block.data) + out_len,
+    } };
+
+    // copy construct elements
+    _collections::slice_clone( //
+      destroy.fn.alloc,
+      destroy.fn.cloner,
+      static_cast<T*>(block.data) + out_len,
+      static_cast<T*>(block.data) + in_len,
+      in);
+    // disable destruction
+    destroy.fn.ptr = nullptr;
+    destroy.fn.ptr_end = nullptr;
+    // disable deallocation
+    _.fn.data = nullptr;
+    out = block;
+  } else {
+    // copy construct elements
+    _collections::slice_clone( //
+      alloc,
+      cloner,
+      static_cast<T*>(out.data) + out_len,
+      static_cast<T*>(out.data) + in_len,
+      in);
+  }
+  return out;
+}
+
+template<bool TrivialAssign>
+struct CloneFromImpl;
+
+template<>
+struct CloneFromImpl<false>
+{
+  template<typename T, typename A, typename C>
+  static void fn(RefMut<A> lhs_alloc,
+                 RefMut<C> cloner,
+                 vector::RawVector<T>& lhs_raw,
+                 Ref<A> rhs_alloc,
+                 vector::RawVector<T> const rhs_raw)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&    //
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&       //
+                    VEG_CONCEPT(alloc::nothrow_clone<C, T, A>) && //
+                    VEG_CONCEPT(alloc::nothrow_clone_from<C, T, A>))
+  {
+
+    vector::RawVector<T> lhs_copy = lhs_raw;
+    usize rhs_len = (rhs_raw.end - rhs_raw.data);
+
+    if (!(lhs_alloc == rhs_alloc)) {
+      T* data = lhs_copy.data;
+      T* data_end = lhs_copy.end;
+
+      // clean up old alloc
+      _collections::backward_destroy(lhs_alloc, cloner, data, data_end);
+
+      // assign before deallocation in case it fails
+      lhs_raw = {};
+      lhs_copy = {};
+
+      // don't need to deallocate on backward_destroy failure, since lhs can
+      // still access and reuse the allocation
+      mem::Alloc<A>::dealloc( //
+        RefMut<A>(lhs_alloc),
+        static_cast<void*>(data),
+        mem::Layout{ (lhs_copy.end_alloc - lhs_copy.data) * sizeof(T),
+                     alignof(T) });
+    }
+
+    lhs_alloc.get() = rhs_alloc.get();
+
+    if (lhs_raw.data == nullptr) {
+      usize len = rhs_raw.end - rhs_raw.data;
+
+      mem::AllocBlock blk =
+        _collections::alloc_and_copy(lhs_alloc, cloner, rhs_raw.data, len);
+      T* data = static_cast<T*>(blk.data);
+      lhs_raw = {
+        data,
+        data + len,
+        data + blk.byte_cap / sizeof(T),
+      };
+      return;
+    }
+
+    usize assign_len = _detail::min2(lhs_copy.len(), rhs_raw.len());
+    // copy assign until the shared len
+    _collections::slice_clone_from( //
+      lhs_alloc,
+      cloner,
+      lhs_copy.data,
+      lhs_copy.data + assign_len,
+      rhs_raw.data);
+
+    // destroy from the shared len until end of lhs
+    lhs_raw.end = lhs_raw.data + assign_len;
+    _collections::backward_destroy( //
+      lhs_alloc,
+      cloner,
+      lhs_copy.data + assign_len,
+      lhs_copy.end);
+
+    // pass allocation to realloc_and_append
+
+    lhs_raw = {};
+    // realloc and copy construct new elements until end of rhs
+    mem::AllocBlock block = _collections::realloc_and_append(
+      lhs_alloc,
+      cloner,
+      mem::AllocBlock{
+        lhs_copy.data,
+        (lhs_copy.end_alloc - lhs_copy.data) * sizeof(T),
+      },                         // out
+      assign_len,                // out_len
+      rhs_raw.data + assign_len, // in
+      rhs_len - assign_len);     // in_len
+
+    lhs_raw = vector::RawVector<T>{
+      static_cast<T*>(block.data),
+      static_cast<T*>(block.data) + rhs_len,
+      static_cast<T*>(block.data) + block.byte_cap / sizeof(T),
+    };
+  }
+};
+template<>
+struct CloneFromImpl<true>
+{
+  template<typename T, typename A, typename C>
+  static void fn(RefMut<A> lhs_alloc,
+                 RefMut<C> cloner,
+                 vector::RawVector<T>& lhs_raw,
+                 Ref<A> rhs_alloc,
+                 vector::RawVector<T> const rhs_raw)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) && //
+                    VEG_CONCEPT(alloc::nothrow_dealloc<A>) &&
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+
+    vector::RawVector<T> lhs_copy = lhs_raw;
+
+    bool need_to_realloc = (!(lhs_alloc.get() == rhs_alloc.get()) ||
+                            (lhs_copy.cap() < rhs_raw.len()));
+    if (need_to_realloc) {
+      T* data = lhs_copy.data;
+      usize cap = lhs_copy.cap();
+
+      // assign before deallocation in case it fails
+      lhs_raw = {};
+      mem::Alloc<A>::dealloc( //
+        RefMut<A>(lhs_alloc),
+        static_cast<void*>(data),
+        mem::Layout{ cap * sizeof(T), alignof(T) });
+      lhs_copy = {};
+    }
+
+    lhs_alloc.get() = rhs_alloc.get();
+
+    // allocate and copy all elements
+    if (need_to_realloc) {
+      mem::AllocBlock block = _collections::alloc_and_copy( //
+        lhs_alloc,
+        cloner,
+        rhs_raw.data,
+        rhs_raw.len());
+      lhs_raw.data = static_cast<T*>(block.data);
+      lhs_raw.end_alloc = lhs_raw.data + block.byte_cap / sizeof(T);
+    } else {
+      _collections::slice_clone( //
+        lhs_alloc,
+        cloner,
+        lhs_copy.data,
+        lhs_copy.data + rhs_raw.len(),
+        rhs_raw.data);
+    }
+    lhs_raw.end = lhs_raw.data + rhs_raw.len();
+  }
+};
+
+template<typename T, typename A, typename C>
+VEG_INLINE void
+clone_from(RefMut<A> lhs_alloc,
+           RefMut<C> cloner,
+           vector::RawVector<T>& lhs_raw,
+           Ref<A> rhs_alloc,
+           vector::RawVector<T> const rhs_raw)
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&    //
+                  VEG_CONCEPT(alloc::nothrow_alloc<A>) &&       //
+                  VEG_CONCEPT(alloc::nothrow_clone<C, T, A>) && //
+                  VEG_CONCEPT(alloc::nothrow_clone_from<C, T, A>))
+{
+  _collections::CloneFromImpl<
+    mem::Cloner<C>::template trivial_clone<T>::value>::fn(lhs_alloc,
+                                                          cloner,
+                                                          lhs_raw,
+                                                          rhs_alloc,
+                                                          rhs_raw);
+}
+} // namespace _collections
+} // namespace _detail
+
+namespace _detail {
+namespace _vector {
+
+template<typename T>
+struct RawVectorMoveRaii /* NOLINT */
+{
+  vector::RawVector<T> _ = {};
+
+  RawVectorMoveRaii() = default;
+  RawVectorMoveRaii(FromRawParts /*tag*/,
+                    vector::RawVector<T> inner) VEG_NOEXCEPT : _{ inner } {};
+  VEG_INLINE VEG_CPP14(constexpr)
+    RawVectorMoveRaii(RawVectorMoveRaii&& rhs) VEG_NOEXCEPT : _{ rhs._ }
+  {
+    rhs._ = {};
+  }
+  VEG_INLINE VEG_CPP14(constexpr)
+    RawVectorMoveRaii(RawVectorMoveRaii const& /*rhs*/) VEG_NOEXCEPT
+  {
+  }
+};
+
+template<typename T, typename A>
+struct VecAlloc
+  :
+  // alloc manager needs to be constructed first
+  Tuple<A, RawVectorMoveRaii<T>>
+{
+  using Tuple<A, RawVectorMoveRaii<T>>::Tuple;
+
+public:
+  VecAlloc(VecAlloc const&) = default;
+  VecAlloc(VecAlloc&&) = default;
+  auto operator=(VecAlloc const&) -> VecAlloc& = default;
+  auto operator=(VecAlloc&&) -> VecAlloc& = default;
+
+  VEG_INLINE ~VecAlloc() VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_dealloc<A>))
+  {
+    vector::RawVector<T> raw = (*this)[1_c]._;
+    if ((raw.data != nullptr) && (raw.end_alloc != 0)) {
+
+      // FIXME: if asan is enabled, before sanitizing make sure that:
+      //  - begin is 8 byte aligned
+      //  - either:
+      //    - end is 8 byte aligned
+      //    - A is the SystemAlloc
+#if VEG_HAS_ASAN
+      _detail::__sanitizer_annotate_contiguous_container( //
+        raw.data,
+        raw.end_alloc,
+        raw.data,
+        raw.end_alloc);
+#endif
+
+      mem::Alloc<A>::dealloc(
+        mut((*this)[0_c]),
+        static_cast<void*>(raw.data),
+        mem::Layout{ usize(raw.end_alloc - raw.data) * sizeof(T), alignof(T) });
+    }
+  }
+};
+} // namespace _vector
+} // namespace _detail
+
+#if VEG_HAS_ASAN
+#define __VEG_ASAN_ANNOTATE() /* NOLINT */                                     \
+  if (ptr() != nullptr) {                                                      \
+    _detail::__sanitizer_annotate_contiguous_container(                        \
+      ptr(), ptr() + capacity(), ptr() + len(), ptr() + capacity());           \
+  }                                                                            \
+  auto&& _veglib_asan = defer([&]() noexcept {                                 \
+    if (ptr() != nullptr) {                                                    \
+      _detail::__sanitizer_annotate_contiguous_container(                      \
+        ptr(), ptr() + capacity(), ptr() + capacity(), ptr() + len());         \
+    }                                                                          \
+  });                                                                          \
+  (void)_veglib_asan
+#else
+#define __VEG_ASAN_ANNOTATE() /* NOLINT */ (void)0;
+#endif
+
+namespace _detail {
+namespace _collections {
+template<typename T,
+         typename A = mem::SystemAlloc,
+         mem::DtorAvailable Dtor = mem::DtorAvailableFor<T>::value,
+         mem::CopyAvailable Copy = mem::CopyAvailableFor<T>::value>
+struct VecImpl
+{
+private:
+  _detail::_vector::VecAlloc<T, A> _;
+
+public:
+  VEG_NODISCARD VEG_INLINE
+    VEG_CPP14(constexpr) auto alloc_ref() const VEG_NOEXCEPT->Ref<A>
+  {
+    return ref(_[0_c]);
+  }
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto raw_ref() const
+    VEG_NOEXCEPT->Ref<vector::RawVector<T>>
+  {
+    return ref(_[1_c]._);
+  }
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto alloc_mut(Unsafe /*tag*/)
+    VEG_NOEXCEPT->RefMut<A>
+  {
+    return mut(_[0_c]);
+  }
+  VEG_NODISCARD VEG_INLINE VEG_CPP14(constexpr) auto raw_mut(Unsafe /*tag*/)
+    VEG_NOEXCEPT->RefMut<vector::RawVector<T>>
+  {
+    return mut(_[1_c]._);
+  }
+
+private:
+  VEG_INLINE void _reserve_grow_exact_impl(Unsafe /*tag*/, usize new_cap)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
+  {
+    __VEG_ASAN_ANNOTATE();
+
+    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
+    auto len = usize(this->len());
+
+    mem::AllocBlock new_block = mem::Alloc<A>::grow(
+      this->alloc_mut(unsafe),
+      static_cast<void*>(raw.data),
+      mem::Layout{
+        usize(byte_capacity()),
+        alignof(T),
+      },
+      new_cap * sizeof(T),
+      mem::RelocFn{ collections::relocate_pointer<T>::value });
+
+    T* data = static_cast<T*>(new_block.data);
+    raw = {
+      data,
+      data + len,
+      data + new_block.byte_cap / sizeof(T),
+    };
+  }
+  VEG_INLINE void _reserve_grow_exact(Unsafe /*tag*/, isize new_cap)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
+  {
+    isize old_len = len();
+    this->_reserve_grow_exact_impl(unsafe, usize(new_cap));
+    meta::unreachable_if(capacity() < new_cap);
+    meta::unreachable_if(len() != old_len);
+  }
+  VEG_INLINE void _reserve_one_more(Unsafe /*tag*/)
+  {
+    this->_reserve_grow_exact(
+      unsafe,
+      1 + isize(_detail::_collections::vector_grow_compute(usize(capacity()))));
+  }
+
+  static_assert(VEG_CONCEPT(nothrow_move_assignable<A>), ".");
+  static_assert(VEG_CONCEPT(nothrow_movable<A>), ".");
+
+public:
+  VEG_INLINE ~VecImpl()
+    VEG_NOEXCEPT_IF(Dtor == mem::DtorAvailable::yes_nothrow &&
+                    VEG_CONCEPT(alloc::nothrow_dealloc<A>))
+  {
+    static_assert(Dtor == mem::DtorAvailableFor<T>::value, ".");
+    vector::RawVector<T> raw = this->raw_ref().get();
+    if (raw.data != nullptr) {
+      this->clear();
+    }
+  }
+
+  VEG_INLINE VecImpl() = default;
+
+  VEG_INLINE
+  VecImpl(Unsafe /*unsafe*/,
+          FromRawParts /*tag*/,
+          vector::RawVector<T> rawvec,
+          A alloc) VEG_NOEXCEPT
+    : _{
+      tuplify,
+      VEG_FWD(alloc),
+      _detail::_vector::RawVectorMoveRaii<T>{ from_raw_parts, rawvec },
+    }
+  {
+  }
+
+  VEG_INLINE VecImpl(VecImpl&&) = default;
+  VEG_INLINE auto operator=(VecImpl&& rhs) -> VecImpl&
+  {
+    {
+      auto cleanup = static_cast<VecImpl&&>(*this);
+    }
+
+    // can't fail
+    this->alloc_mut(unsafe).get() =
+      static_cast<A&&>(rhs.alloc_mut(unsafe).get());
+    this->raw_mut(unsafe).get() = rhs.raw_ref().get();
+    rhs.raw_mut(unsafe).get() = {};
+
+    return *this;
+  };
+
+  explicit VecImpl(VecImpl const& rhs)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<A>) && //
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
+                    Copy == mem::CopyAvailable::yes_nothrow)
+    : _{ rhs._ }
+  {
+    static_assert(Copy == mem::CopyAvailableFor<T>::value, ".");
+    __VEG_ASAN_ANNOTATE();
+    vector::RawVector<T> rhs_raw = rhs.raw_ref().get();
+    mem::AllocBlock blk =
+      _detail::_collections::alloc_and_copy(this->alloc_mut(unsafe),
+                                            mut(mem::DefaultCloner{}),
+                                            rhs_raw.data,
+                                            usize(rhs.len()));
+
+    T* data = static_cast<T*>(blk.data);
+    this->raw_mut(unsafe).get() = vector::RawVector<T>{
+      data,
+      data + usize(rhs.len()),
+      data + blk.byte_cap / sizeof(T),
+    };
+  }
+
+  auto operator=(VecImpl const& rhs)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<A>) &&
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>) &&
+                    Copy == mem::CopyAvailable::yes_nothrow) -> VecImpl&
+  {
+    static_assert(Copy == mem::CopyAvailableFor<T>::value, ".");
+    if (this != mem::addressof(rhs)) {
+      __VEG_ASAN_ANNOTATE();
+
+      _detail::_collections::clone_from(this->alloc_mut(unsafe),
+                                        mut(mem::DefaultCloner{}),
+                                        this->raw_mut(unsafe).get(),
+                                        rhs.alloc_ref(),
+                                        rhs.raw_ref().get());
+    }
+    return *this;
+  }
+
+  VEG_INLINE void reserve_exact(isize new_cap)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
+  {
+    if (new_cap > capacity()) {
+      this->_reserve_grow_exact(unsafe, new_cap);
+    }
+  }
+  VEG_INLINE void reserve(isize new_cap)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>))
+  {
+    auto cap = capacity();
+    if (new_cap > cap) {
+      this->reserve_exact(isize(
+        _detail::_collections::vector_grow_choose(usize(cap), usize(new_cap))));
+    }
+  }
+
+  VEG_INLINE void pop_several_unchecked(Unsafe unsafe, isize n)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
+  {
+    VEG_DEBUG_ASSERT_ALL_OF(0 <= n, n <= len());
+    __VEG_ASAN_ANNOTATE();
+
+    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
+
+    T* end = raw.end;
+    raw.end -= n;
+    _detail::_collections::backward_destroy(
+      this->alloc_mut(unsafe), mut(mem::DefaultCloner{}), end - n, end);
+  }
+
+  VEG_INLINE void pop_several(isize n)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
+  {
+    VEG_ASSERT_ALL_OF(0 <= n, n <= len());
+    pop_several_unchecked(unsafe, n);
+  }
+
+  VEG_INLINE auto pop_unchecked(Unsafe /*unsafe*/)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
+  {
+    VEG_DEBUG_ASSERT(1 <= len());
+    T* last = raw_ref().get().end - 1;
+    T t = static_cast<T&&>(*last);
+    --raw_mut(unsafe).get().end;
+    mem::destroy_at(last);
+    return t;
+  }
+  VEG_INLINE auto pop_mid_unchecked(Unsafe /*unsafe*/, isize i)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
+  {
+    VEG_DEBUG_ASSERT(0 <= i);
+    VEG_DEBUG_ASSERT(i < len());
+    T* elem = raw_ref().get().data + i;
+    T t = static_cast<T&&>(*elem);
+
+    // this block does not throw
+    {
+      mem::destroy_at(elem);
+      _detail::_collections::relocate<T>( //
+        elem,
+        elem + 1,
+        sizeof(T) * usize(len() - i - 1));
+    }
+    --raw_mut(unsafe).get().end;
+
+    return t;
+  }
+
+  VEG_INLINE auto pop() VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
+  {
+    VEG_ASSERT(1 <= len());
+    return pop_unchecked(unsafe);
+  }
+  VEG_INLINE auto pop_mid(isize i)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>)) -> T
+  {
+    VEG_ASSERT(0 <= i);
+    VEG_ASSERT(i < len());
+    return pop_mid_unchecked(unsafe, i);
+  }
+
+  VEG_INLINE void clear() VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
+  {
+    pop_several_unchecked(unsafe, len());
+  }
+
+  VEG_TEMPLATE(typename U = T,
+               requires(VEG_CONCEPT(constructible<U>)),
+               void resize,
+               (n, isize))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
+                  VEG_CONCEPT(nothrow_constructible<T>))
+  {
+
+    vector::RawVector<T>& raw = raw_mut(unsafe).get();
+
+    if (n > len()) {
+      reserve(n);
+      {
+        __VEG_ASAN_ANNOTATE();
+        ::new (static_cast<void*>(ptr_mut() + len())) T[usize(n - len())]{};
+        raw.end = raw.data + n;
+      }
+    } else {
+      pop_several_unchecked(unsafe, len() - n);
+    }
+  }
+
+  VEG_TEMPLATE(typename U = T,
+               requires(VEG_CONCEPT(constructible<U>)),
+               void resize_for_overwrite,
+               (n, isize))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_grow<A>) &&
+                  VEG_CONCEPT(nothrow_constructible<T>))
+  {
+
+    vector::RawVector<T>& raw = raw_mut(unsafe).get();
+
+    if (n > len()) {
+      reserve(n);
+      {
+        __VEG_ASAN_ANNOTATE();
+        ::new (static_cast<void*>(ptr_mut() + len())) T[usize(n - len())];
+        raw.end = raw.data + n;
+      }
+    } else {
+      pop_several_unchecked(unsafe, len() - n);
+    }
+  }
+
+  VEG_TEMPLATE(typename Fn,
+               requires(VEG_CONCEPT(fn_once<Fn, T>)),
+               VEG_INLINE void push_mid_with,
+               (fn, Fn),
+               (i, isize))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
+                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+    static_assert(VEG_CONCEPT(nothrow_fn_once<Fn, T>), ".");
+
+    VEG_ASSERT_ALL_OF(0 <= i, i <= len());
+
+    reserve(len() + 1);
+    {
+      __VEG_ASAN_ANNOTATE();
+      vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
+      T* elem = raw.data + i;
+      _detail::_collections::relocate_backward<T>( //
+        elem + 1,
+        elem,
+        sizeof(T) * usize(raw.end - elem));
+      mem::construct_with(elem, VEG_FWD(fn));
+      ++raw.end;
+    }
+  }
+  VEG_INLINE void push_mid(T value, isize i)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>) &&
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+    this->push_mid_with(_detail::MoveFn<T>{ VEG_FWD(value) }, i);
+  }
+
+  VEG_TEMPLATE(typename Fn,
+               requires(VEG_CONCEPT(fn_once<Fn, T>)),
+               VEG_INLINE void push_with_unchecked,
+               (/*tag*/, Unsafe),
+               (fn, Fn))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
+                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+    __VEG_ASAN_ANNOTATE();
+
+    vector::RawVector<T>& raw = this->raw_mut(unsafe).get();
+    mem::construct_with(raw.end, VEG_FWD(fn));
+    ++raw.end;
+  }
+
+  VEG_TEMPLATE(typename Fn,
+               requires(VEG_CONCEPT(fn_once<Fn, T>)),
+               VEG_INLINE void push_with,
+               (fn, Fn))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>) &&
+                  VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+    vector::RawVector<T> raw = this->raw_ref().get();
+    if (HEDLEY_UNLIKELY(raw.end == raw.end_alloc)) {
+      this->_reserve_one_more(unsafe);
+    }
+    this->push_with_unchecked(unsafe, VEG_FWD(fn));
+  }
+  VEG_INLINE void push(T value)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>) &&
+                    VEG_CONCEPT(alloc::nothrow_alloc<A>))
+  {
+    this->push_with(_detail::MoveFn<T>{ VEG_FWD(value) });
+  }
+  VEG_INLINE void push_unchecked(Unsafe /*tag*/, T value)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<T>))
+  {
+    this->push_with_unchecked(unsafe, _detail::MoveFn<T>{ VEG_FWD(value) });
+  }
+
+  VEG_NODISCARD VEG_INLINE auto as_ref() const VEG_NOEXCEPT->Slice<T>
+  {
+    return { unsafe, from_raw_parts, ptr(), len() };
+  }
+  VEG_NODISCARD VEG_INLINE auto as_mut() VEG_NOEXCEPT->SliceMut<T>
+  {
+    return { unsafe, from_raw_parts, ptr_mut(), len() };
+  }
+
+  VEG_NODISCARD VEG_INLINE auto ptr() const VEG_NOEXCEPT->T const*
+  {
+    return this->raw_ref().get().data;
+  }
+  VEG_NODISCARD VEG_INLINE auto ptr_mut() VEG_NOEXCEPT->T*
+  {
+    return const_cast<T*>(this->ptr());
+  }
+  VEG_NODISCARD VEG_INLINE auto len() const VEG_NOEXCEPT->isize
+  {
+    auto& raw = this->raw_ref().get();
+    return isize(raw.end - raw.data);
+  }
+  VEG_NODISCARD VEG_INLINE auto capacity() const VEG_NOEXCEPT->isize
+  {
+    auto& raw = this->raw_ref().get();
+    return isize(raw.end_alloc - raw.data);
+  }
+  VEG_NODISCARD VEG_INLINE auto byte_capacity() const VEG_NOEXCEPT->isize
+  {
+    auto& raw = this->raw_ref().get();
+    return meta::is_consteval()
+             ? (raw.end_alloc - raw.data) * isize(sizeof(T))
+             : (reinterpret_cast<char const*>(raw.end_alloc) -
+                reinterpret_cast<char const*>(raw.data));
+  }
+  VEG_NODISCARD VEG_INLINE auto operator[](isize i) const VEG_NOEXCEPT->T const&
+  {
+    VEG_ASSERT(usize(i) < usize(len()));
+    return this->ptr()[i];
+  }
+  VEG_NODISCARD VEG_INLINE auto operator[](isize i) VEG_NOEXCEPT->T&
+  {
+    return const_cast<T&>(static_cast<VecImpl const*>(this)->operator[](i));
+  }
+};
+} // namespace _collections
+} // namespace _detail
+
+template <
+		typename T,
+		typename A = mem::SystemAlloc,
+		mem::DtorAvailable Dtor = mem::DtorAvailableFor<T>::value,
+		mem::CopyAvailable Copy = mem::CopyAvailableFor<T>::value>
+struct Vec : private _detail::_vector::adl::AdlBase,
+						 private meta::if_t< //
+								 Copy == mem::CopyAvailable::no,
+								 _detail::NoCopy,
+								 _detail::Empty>,
+						 public _detail::_collections::VecImpl<T, A, Dtor, Copy>
+{
+
+  using _detail::_collections::VecImpl<T, A, Dtor, Copy>::VecImpl;
+  Vec() = default;
+  VEG_EXPLICIT_COPY(Vec);
+};
+
+template<typename T, typename A>
+struct cpo::is_trivially_relocatable<Vec<T, A>>
+  : cpo::is_trivially_relocatable<A>
+{};
+template<typename T, typename A>
+struct cpo::is_trivially_constructible<Vec<T, A>>
+  : cpo::is_trivially_constructible<A>
+{};
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#undef __VEG_ASAN_ANNOTATE
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_VECTOR_HPP_QWFSH3ROS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/assert_impl.hpp

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-#ifndef VEG_ASSERT_HPP_VQDAJ2IBS
-#define VEG_ASSERT_HPP_VQDAJ2IBS
-
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/util/defer.hpp"
-#include "proxsuite/linalg/veg/internal/dbg.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <cassert>
-
-#define VEG_ASSERT(...) assert((__VA_ARGS__))
-
-#define VEG_ASSERT_ALL_OF(...)                                                 \
-  assert(::proxsuite::linalg::veg::_detail::all_of({ __VA_ARGS__ }))
-
-#define VEG_UNIMPLEMENTED()                                                    \
-  VEG_ASSERT(false);                                                           \
-  HEDLEY_UNREACHABLE()
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_ASSERT_HPP_VQDAJ2IBS */
+#ifndef VEG_ASSERT_HPP_VQDAJ2IBS
+#define VEG_ASSERT_HPP_VQDAJ2IBS
+
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/util/defer.hpp"
+#include "proxsuite/linalg/veg/internal/dbg.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <cassert>
+
+#define VEG_ASSERT(...) assert((__VA_ARGS__))
+
+#define VEG_ASSERT_ALL_OF(...)                                                 \
+  assert(::proxsuite::linalg::veg::_detail::all_of({ __VA_ARGS__ }))
+
+#define VEG_UNIMPLEMENTED()                                                    \
+  VEG_ASSERT(false);                                                           \
+  HEDLEY_UNREACHABLE()
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_ASSERT_HPP_VQDAJ2IBS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/collection_algo.hpp

 * *Ordering differences only*

```diff
@@ -1,93 +1,93 @@
-#ifndef VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS
-#define VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS
-
-#include "proxsuite/linalg/veg/memory/alloc.hpp"
-#include "proxsuite/linalg/veg/util/defer.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-namespace _collections {
-template<bool IsNoExcept>
-struct DestroyImpl;
-
-template<>
-struct DestroyImpl<true>
-{
-  template<typename T, typename A, typename C>
-  VEG_INLINE static VEG_CPP14(constexpr) void fn(RefMut<A> alloc,
-                                                 RefMut<C> cloner,
-                                                 T* ptr,
-                                                 T* ptr_end) VEG_NOEXCEPT
-  {
-    while (true) {
-      if (ptr_end <= ptr) {
-        break;
-      }
-      --ptr_end;
-      mem::Cloner<C>::destroy( //
-        RefMut<C>(cloner),
-        static_cast<T*>(ptr_end),
-        RefMut<A>(alloc));
-    }
-  }
-};
-
-template<typename T, typename A, typename C>
-struct Cleanup
-{
-  RefMut<A> alloc;
-  RefMut<C> cloner;
-  T* ptr;
-  T* ptr_end;
-
-  VEG_CPP14(constexpr) void operator()() noexcept
-  {
-    DestroyImpl<true>::fn(alloc, cloner, ptr, ptr_end);
-  }
-};
-
-template<>
-struct DestroyImpl<false>
-{
-  template<typename T, typename A, typename C>
-  VEG_INLINE static VEG_CPP20(constexpr) void fn(RefMut<A> alloc,
-                                                 RefMut<C> cloner,
-                                                 T* ptr,
-                                                 T* ptr_end)
-    VEG_NOEXCEPT_IF(false)
-  {
-
-    Defer<Cleanup<T, A, C>> _{ { alloc, cloner, ptr, ptr_end } };
-
-    while (true) {
-      if (_.fn.ptr_end <= _.fn.ptr) {
-        break;
-      }
-      --_.fn.ptr_end;
-      mem::Cloner<C>::destroy( //
-        RefMut<C>(_.fn.cloner),
-        static_cast<T*>(_.fn.ptr_end),
-        RefMut<A>(_.fn.alloc));
-    }
-  }
-};
-
-template<typename T, typename A, typename C>
-VEG_CPP14(constexpr)
-void backward_destroy(RefMut<A> alloc, RefMut<C> cloner, T* ptr, T* ptr_end)
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_destroy<C, T, A>))
-{
-  DestroyImpl<VEG_CONCEPT(alloc::nothrow_destroy<C, T, A>)>::fn(
-    alloc, cloner, ptr, ptr_end);
-}
-} // namespace _collections
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS */
+#ifndef VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS
+#define VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS
+
+#include "proxsuite/linalg/veg/memory/alloc.hpp"
+#include "proxsuite/linalg/veg/util/defer.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+namespace _collections {
+template<bool IsNoExcept>
+struct DestroyImpl;
+
+template<>
+struct DestroyImpl<true>
+{
+  template<typename T, typename A, typename C>
+  VEG_INLINE static VEG_CPP14(constexpr) void fn(RefMut<A> alloc,
+                                                 RefMut<C> cloner,
+                                                 T* ptr,
+                                                 T* ptr_end) VEG_NOEXCEPT
+  {
+    while (true) {
+      if (ptr_end <= ptr) {
+        break;
+      }
+      --ptr_end;
+      mem::Cloner<C>::destroy( //
+        RefMut<C>(cloner),
+        static_cast<T*>(ptr_end),
+        RefMut<A>(alloc));
+    }
+  }
+};
+
+template<typename T, typename A, typename C>
+struct Cleanup
+{
+  RefMut<A> alloc;
+  RefMut<C> cloner;
+  T* ptr;
+  T* ptr_end;
+
+  VEG_CPP14(constexpr) void operator()() noexcept
+  {
+    DestroyImpl<true>::fn(alloc, cloner, ptr, ptr_end);
+  }
+};
+
+template<>
+struct DestroyImpl<false>
+{
+  template<typename T, typename A, typename C>
+  VEG_INLINE static VEG_CPP20(constexpr) void fn(RefMut<A> alloc,
+                                                 RefMut<C> cloner,
+                                                 T* ptr,
+                                                 T* ptr_end)
+    VEG_NOEXCEPT_IF(false)
+  {
+
+    Defer<Cleanup<T, A, C>> _{ { alloc, cloner, ptr, ptr_end } };
+
+    while (true) {
+      if (_.fn.ptr_end <= _.fn.ptr) {
+        break;
+      }
+      --_.fn.ptr_end;
+      mem::Cloner<C>::destroy( //
+        RefMut<C>(_.fn.cloner),
+        static_cast<T*>(_.fn.ptr_end),
+        RefMut<A>(_.fn.alloc));
+    }
+  }
+};
+
+template<typename T, typename A, typename C>
+VEG_CPP14(constexpr)
+void backward_destroy(RefMut<A> alloc, RefMut<C> cloner, T* ptr, T* ptr_end)
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(alloc::nothrow_destroy<C, T, A>))
+{
+  DestroyImpl<VEG_CONCEPT(alloc::nothrow_destroy<C, T, A>)>::fn(
+    alloc, cloner, ptr, ptr_end);
+}
+} // namespace _collections
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_CONTAINER_ALGOS_HPP_SGBCMQAYS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/dbg.hpp

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-#ifndef VEG_FMT_HPP_GQU8XFRUS
-#define VEG_FMT_HPP_GQU8XFRUS
-
-#include "proxsuite/linalg/veg/type_traits/primitives.hpp"
-#include "proxsuite/linalg/veg/internal/terminate.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/ref.hpp"
-#include "proxsuite/linalg/veg/type_traits/primitives.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#include <cstring>
-#include <cstdio>
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_FMT_HPP_GQU8XFRUS */
+#ifndef VEG_FMT_HPP_GQU8XFRUS
+#define VEG_FMT_HPP_GQU8XFRUS
+
+#include "proxsuite/linalg/veg/type_traits/primitives.hpp"
+#include "proxsuite/linalg/veg/internal/terminate.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/ref.hpp"
+#include "proxsuite/linalg/veg/type_traits/primitives.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#include <cstring>
+#include <cstdio>
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_FMT_HPP_GQU8XFRUS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/delete_special_members.hpp

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-#ifndef VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS
-#define VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS
-
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-struct NoDefaultCtor
-{
-  NoDefaultCtor() = delete;
-};
-struct NoMoveAssign
-{
-  NoMoveAssign() = default;
-  ~NoMoveAssign() = default;
-  NoMoveAssign(NoMoveAssign const&) = default;
-  NoMoveAssign(NoMoveAssign&&) = default;
-  auto operator=(NoMoveAssign const&) -> NoMoveAssign& = default;
-  auto operator=(NoMoveAssign&&) -> NoMoveAssign& = delete;
-};
-struct NoCopyAssign
-{
-  NoCopyAssign() = default;
-  ~NoCopyAssign() = default;
-  NoCopyAssign(NoCopyAssign const&) = default;
-  NoCopyAssign(NoCopyAssign&&) = default;
-  auto operator=(NoCopyAssign const&) -> NoCopyAssign& = delete;
-  auto operator=(NoCopyAssign&&) -> NoCopyAssign& = default;
-};
-struct NoMoveCtor
-{
-  NoMoveCtor() = default;
-  ~NoMoveCtor() = default;
-  NoMoveCtor(NoMoveCtor const&) = default;
-  NoMoveCtor(NoMoveCtor&&) = delete;
-  auto operator=(NoMoveCtor const&) -> NoMoveCtor& = default;
-  auto operator=(NoMoveCtor&&) -> NoMoveCtor& = default;
-};
-struct NoCopyCtor
-{
-  NoCopyCtor() = default;
-  ~NoCopyCtor() = default;
-  NoCopyCtor(NoCopyCtor const&) = delete;
-  NoCopyCtor(NoCopyCtor&&) = default;
-  auto operator=(NoCopyCtor const&) -> NoCopyCtor& = default;
-  auto operator=(NoCopyCtor&&) -> NoCopyCtor& = default;
-};
-
-struct NoMove
-{
-  NoMove() = default;
-  ~NoMove() = default;
-  NoMove(NoMove const&) = default;
-  NoMove(NoMove&&) = delete;
-  auto operator=(NoMove const&) -> NoMove& = default;
-  auto operator=(NoMove&&) -> NoMove& = delete;
-};
-struct NoCopy
-{
-  NoCopy() = default;
-  ~NoCopy() = default;
-  NoCopy(NoCopy const&) = delete;
-  NoCopy(NoCopy&&) = default;
-  auto operator=(NoCopy const&) -> NoCopy& = delete;
-  auto operator=(NoCopy&&) -> NoCopy& = default;
-};
-
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS */
+#ifndef VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS
+#define VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS
+
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+struct NoDefaultCtor
+{
+  NoDefaultCtor() = delete;
+};
+struct NoMoveAssign
+{
+  NoMoveAssign() = default;
+  ~NoMoveAssign() = default;
+  NoMoveAssign(NoMoveAssign const&) = default;
+  NoMoveAssign(NoMoveAssign&&) = default;
+  auto operator=(NoMoveAssign const&) -> NoMoveAssign& = default;
+  auto operator=(NoMoveAssign&&) -> NoMoveAssign& = delete;
+};
+struct NoCopyAssign
+{
+  NoCopyAssign() = default;
+  ~NoCopyAssign() = default;
+  NoCopyAssign(NoCopyAssign const&) = default;
+  NoCopyAssign(NoCopyAssign&&) = default;
+  auto operator=(NoCopyAssign const&) -> NoCopyAssign& = delete;
+  auto operator=(NoCopyAssign&&) -> NoCopyAssign& = default;
+};
+struct NoMoveCtor
+{
+  NoMoveCtor() = default;
+  ~NoMoveCtor() = default;
+  NoMoveCtor(NoMoveCtor const&) = default;
+  NoMoveCtor(NoMoveCtor&&) = delete;
+  auto operator=(NoMoveCtor const&) -> NoMoveCtor& = default;
+  auto operator=(NoMoveCtor&&) -> NoMoveCtor& = default;
+};
+struct NoCopyCtor
+{
+  NoCopyCtor() = default;
+  ~NoCopyCtor() = default;
+  NoCopyCtor(NoCopyCtor const&) = delete;
+  NoCopyCtor(NoCopyCtor&&) = default;
+  auto operator=(NoCopyCtor const&) -> NoCopyCtor& = default;
+  auto operator=(NoCopyCtor&&) -> NoCopyCtor& = default;
+};
+
+struct NoMove
+{
+  NoMove() = default;
+  ~NoMove() = default;
+  NoMove(NoMove const&) = default;
+  NoMove(NoMove&&) = delete;
+  auto operator=(NoMove const&) -> NoMove& = default;
+  auto operator=(NoMove&&) -> NoMove& = delete;
+};
+struct NoCopy
+{
+  NoCopy() = default;
+  ~NoCopy() = default;
+  NoCopy(NoCopy const&) = delete;
+  NoCopy(NoCopy&&) = default;
+  auto operator=(NoCopy const&) -> NoCopy& = delete;
+  auto operator=(NoCopy&&) -> NoCopy& = default;
+};
+
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_DELETE_SPECIAL_MEMBERS_HPP_2HKRCVWUS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/dyn_index.hpp

 * *Ordering differences only*

```diff
@@ -1,292 +1,292 @@
-#ifndef VEG_META_INT_DYN_HPP_GC385NKBS
-#define VEG_META_INT_DYN_HPP_GC385NKBS
-
-#include "proxsuite/linalg/veg/util/assert.hpp"
-#include "proxsuite/linalg/veg/internal/fix_index.hpp"
-#include "proxsuite/linalg/veg/internal/narrow.hpp"
-#include "proxsuite/linalg/veg/util/compare.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-
-template<Ternary T>
-struct Boolean;
-
-template<>
-struct Boolean<maybe>
-{
-  using type = maybe_c;
-
-  constexpr Boolean() = default;
-  constexpr Boolean /* NOLINT(hicpp-explicit-conversions) */ (bool _val)
-    VEG_NOEXCEPT : val{ _val }
-  {
-  }
-  template<Ternary T>
-  VEG_INLINE constexpr Boolean /* NOLINT(hicpp-explicit-conversions)
-                                */
-    (Boolean<T> /*arg*/) VEG_NOEXCEPT : val(T == yes)
-  {
-  }
-
-  VEG_NODISCARD VEG_INLINE constexpr friend auto operator!(Boolean arg)
-    VEG_NOEXCEPT->Boolean
-  {
-    return { !arg.val };
-  }
-  VEG_NODISCARD VEG_INLINE explicit constexpr operator bool() const VEG_NOEXCEPT
-  {
-    return val;
-  }
-
-private:
-  bool val = false;
-};
-
-struct Dyn
-{
-  constexpr Dyn() = default;
-  constexpr Dyn /* NOLINT(hicpp-explicit-conversions) */ (isize val)
-    VEG_NOEXCEPT : m_val(val)
-  {
-  }
-  template<isize N>
-  constexpr Dyn /* NOLINT(hicpp-explicit-conversions) */ (Fix<N> /*arg*/)
-    VEG_NOEXCEPT : m_val(N)
-  {
-  }
-
-  VEG_NODISCARD VEG_INLINE explicit constexpr operator isize() const
-    VEG_NOEXCEPT
-  {
-    return m_val;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator+() const VEG_NOEXCEPT->Dyn
-  {
-    return *this;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator-() const VEG_NOEXCEPT->Dyn
-  {
-    return Dyn{ -m_val };
-  }
-
-#define VEG_OP(Op, Name, TypeName)                                             \
-  VEG_TEMPLATE((typename R),                                                   \
-               requires(VEG_CONCEPT(index<R>)),                                \
-               VEG_NODISCARD VEG_INLINE constexpr auto                         \
-               operator Op,                                                    \
-               (b, R))                                                         \
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::TypeName        \
-  {                                                                            \
-    return _detail::binary_traits<Dyn, R>::Name##_fn(*this, b);                \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-  VEG_OP(+, add, Add);
-  VEG_OP(-, sub, Sub);
-  VEG_OP(*, mul, Mul);
-
-#undef VEG_OP
-
-  VEG_TEMPLATE(
-    (typename R),
-    requires(VEG_CONCEPT(index<R>) &&
-             VEG_CONCEPT(index<typename _detail::binary_traits<Dyn, R>::Div>)),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator/,
-    (b, R))
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::Div
-  {
-    return _detail::binary_traits<Dyn, R>::div_fn(*this, b);
-  }
-
-  VEG_TEMPLATE(
-    (typename R),
-    requires(VEG_CONCEPT(index<R>) &&
-             VEG_CONCEPT(index<typename _detail::binary_traits<Dyn, R>::Mod>)),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator%,
-    (b, R))
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::Mod
-  {
-    return _detail::binary_traits<Dyn, R>::mod_fn(*this, b);
-  }
-
-#define VEG_CMP(Name, TypeName, Op)                                            \
-  VEG_TEMPLATE((typename R),                                                   \
-               requires(VEG_CONCEPT(index<R>)),                                \
-               VEG_NODISCARD VEG_INLINE constexpr auto                         \
-               operator Op, /* NOLINT */                                       \
-               (b, R))                                                         \
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::TypeName        \
-  {                                                                            \
-    return _detail::binary_traits<Dyn, R>::cmp_##Name##_fn(*this, b);          \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-  VEG_CMP(eq, CmpEq, ==);
-  VEG_CMP(neq, CmpNEq, !=);
-  VEG_CMP(lt, CmpLT, <);
-  VEG_CMP(le, CmpLE, <=);
-  VEG_CMP(gt, CmpGT, >);
-  VEG_CMP(ge, CmpGE, >=);
-
-#undef VEG_CMP
-private:
-  isize m_val = 0;
-};
-
-template<Ternary T>
-VEG_INLINE constexpr Boolean<T>::Boolean(Boolean<maybe> /*b*/,
-                                         Unsafe /*tag*/) VEG_NOEXCEPT
-{
-}
-template<Ternary T>
-VEG_INLINE constexpr Boolean<T>::Boolean // NOLINT(hicpp-explicit-conversions)
-  (Boolean<maybe> b) VEG_NOEXCEPT
-  : Boolean(((void)VEG_INTERNAL_ASSERT_PRECONDITION(b.val == (T == yes)), b),
-            unsafe)
-{
-}
-
-template<isize N>
-VEG_INLINE constexpr Fix<N>::Fix(Dyn /*arg*/, Unsafe /*tag*/) VEG_NOEXCEPT
-{
-}
-template<isize N>
-VEG_INLINE constexpr Fix<N>::Fix // NOLINT(hicpp-explicit-conversions)
-  (Dyn arg) VEG_NOEXCEPT
-  : Fix((VEG_INTERNAL_ASSERT_PRECONDITION(isize(arg) == N), arg), unsafe)
-{
-}
-
-namespace _detail {
-
-template<>
-struct binary_traits<Dyn, Dyn>
-{
-#define VEG_OP(Name, TypeName, Op)                                             \
-  using TypeName /* NOLINT(bugprone-macro-parentheses) */ = Dyn;               \
-  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Dyn a, Dyn b)       \
-    VEG_NOEXCEPT->TypeName                                                     \
-  {                                                                            \
-    return { isize(usize(isize(a)) Op usize(isize(b))) };                      \
-  }                                                                            \
-  static_assert(true, "")
-
-#define VEG_CMP(Name, TypeName, Op)                                            \
-  using TypeName /* NOLINT(bugprone-macro-parentheses) */ = Boolean<maybe>;    \
-  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Dyn a, Dyn b)       \
-    VEG_NOEXCEPT->TypeName                                                     \
-  {                                                                            \
-    return (isize(a) Op isize(b));                                             \
-  }                                                                            \
-  static_assert(true, "")
-
-  VEG_OP(add, Add, +);
-  VEG_OP(sub, Sub, -);
-  VEG_OP(mul, Mul, *);
-  VEG_CMP(cmp_eq, CmpEq, ==);
-  VEG_CMP(cmp_neq, CmpNEq, !=);
-  VEG_CMP(cmp_lt, CmpLT, <);
-  VEG_CMP(cmp_le, CmpLE, <=);
-  VEG_CMP(cmp_gt, CmpGT, >);
-  VEG_CMP(cmp_ge, CmpGE, >=);
-
-  using Div = Dyn;
-  using Mod = Dyn;
-
-  VEG_NODISCARD static constexpr auto div_fn(Dyn a, Dyn b) VEG_NOEXCEPT->Div
-  {
-    return VEG_INTERNAL_ASSERT_PRECONDITION(isize(b) != isize(0)),
-           isize(a) / isize(b);
-  }
-  VEG_NODISCARD static constexpr auto mod_fn(Dyn a, Dyn b) VEG_NOEXCEPT->Mod
-  {
-
-    return VEG_INTERNAL_ASSERT_PRECONDITION(isize(b) != isize(0)),
-           isize(a) % isize(b);
-  }
-
-#undef VEG_OP
-#undef VEG_CMP
-};
-
-template<isize N>
-struct binary_traits<Fix<N>, Dyn> : binary_traits<Dyn, Dyn>
-{};
-
-template<>
-struct binary_traits<Fix<0>, Dyn> : binary_traits<Dyn, Dyn>
-{
-  using Mul = Fix<0>;
-  VEG_NODISCARD
-  constexpr VEG_INLINE static auto mul_fn(Fix<0> /*a*/,
-                                          Dyn /*b*/) VEG_NOEXCEPT->Mul
-  {
-    return {};
-  }
-};
-
-template<isize N>
-struct binary_traits<Dyn, Fix<N>> : binary_traits<Dyn, Dyn>
-{
-  using Mul = typename binary_traits<Fix<N>, Dyn>::Mul;
-  VEG_INLINE static constexpr auto mul_fn(Dyn a, Fix<N> /*b*/) VEG_NOEXCEPT->Mul
-  {
-    return binary_traits<Fix<N>, Dyn>::mul_fn({}, a);
-  }
-
-  using Div = meta::if_t<N == 0, void, Dyn>;
-  using Mod = meta::if_t<N == 0, void, Dyn>;
-
-  VEG_NODISCARD VEG_INLINE static constexpr auto div_fn(Dyn a, Fix<N> /*b*/)
-    VEG_NOEXCEPT->Div
-  {
-    return Div(isize(a) / N);
-  }
-  VEG_NODISCARD VEG_INLINE static constexpr auto mod_fn(Dyn a, Fix<N> /*b*/)
-    VEG_NOEXCEPT->Mod
-  {
-    return Mod(isize(a) % N);
-  }
-};
-
-} // namespace _detail
-
-inline namespace literals {
-VEG_INLINE constexpr auto operator"" _v(unsigned long long n) VEG_NOEXCEPT->Dyn
-{
-  return isize(n);
-}
-} // namespace literals
-
-template<>
-struct fmt::Debug<Boolean<maybe>>
-{
-  static void to_string(fmt::Buffer& out, Ref<Boolean<maybe>> val)
-  {
-    out.insert(out.size(), "maybe[", 6);
-    Debug<bool>::to_string(out, ref(bool(val.get())));
-    out.insert(out.size(), "]", 1);
-  }
-};
-
-template<>
-struct fmt::Debug<Dyn>
-{
-  static void to_string(fmt::Buffer& out, Ref<Dyn> val)
-  {
-    out.insert(out.size(), "Dyn[", 4);
-    Debug<isize>::to_string(out, ref(isize(val.get())));
-    out.insert(out.size(), "]", 1);
-  }
-};
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_META_INT_DYN_HPP_GC385NKBS */
+#ifndef VEG_META_INT_DYN_HPP_GC385NKBS
+#define VEG_META_INT_DYN_HPP_GC385NKBS
+
+#include "proxsuite/linalg/veg/util/assert.hpp"
+#include "proxsuite/linalg/veg/internal/fix_index.hpp"
+#include "proxsuite/linalg/veg/internal/narrow.hpp"
+#include "proxsuite/linalg/veg/util/compare.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+
+template<Ternary T>
+struct Boolean;
+
+template<>
+struct Boolean<maybe>
+{
+  using type = maybe_c;
+
+  constexpr Boolean() = default;
+  constexpr Boolean /* NOLINT(hicpp-explicit-conversions) */ (bool _val)
+    VEG_NOEXCEPT : val{ _val }
+  {
+  }
+  template<Ternary T>
+  VEG_INLINE constexpr Boolean /* NOLINT(hicpp-explicit-conversions)
+                                */
+    (Boolean<T> /*arg*/) VEG_NOEXCEPT : val(T == yes)
+  {
+  }
+
+  VEG_NODISCARD VEG_INLINE constexpr friend auto operator!(Boolean arg)
+    VEG_NOEXCEPT->Boolean
+  {
+    return { !arg.val };
+  }
+  VEG_NODISCARD VEG_INLINE explicit constexpr operator bool() const VEG_NOEXCEPT
+  {
+    return val;
+  }
+
+private:
+  bool val = false;
+};
+
+struct Dyn
+{
+  constexpr Dyn() = default;
+  constexpr Dyn /* NOLINT(hicpp-explicit-conversions) */ (isize val)
+    VEG_NOEXCEPT : m_val(val)
+  {
+  }
+  template<isize N>
+  constexpr Dyn /* NOLINT(hicpp-explicit-conversions) */ (Fix<N> /*arg*/)
+    VEG_NOEXCEPT : m_val(N)
+  {
+  }
+
+  VEG_NODISCARD VEG_INLINE explicit constexpr operator isize() const
+    VEG_NOEXCEPT
+  {
+    return m_val;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator+() const VEG_NOEXCEPT->Dyn
+  {
+    return *this;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator-() const VEG_NOEXCEPT->Dyn
+  {
+    return Dyn{ -m_val };
+  }
+
+#define VEG_OP(Op, Name, TypeName)                                             \
+  VEG_TEMPLATE((typename R),                                                   \
+               requires(VEG_CONCEPT(index<R>)),                                \
+               VEG_NODISCARD VEG_INLINE constexpr auto                         \
+               operator Op,                                                    \
+               (b, R))                                                         \
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::TypeName        \
+  {                                                                            \
+    return _detail::binary_traits<Dyn, R>::Name##_fn(*this, b);                \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+  VEG_OP(+, add, Add);
+  VEG_OP(-, sub, Sub);
+  VEG_OP(*, mul, Mul);
+
+#undef VEG_OP
+
+  VEG_TEMPLATE(
+    (typename R),
+    requires(VEG_CONCEPT(index<R>) &&
+             VEG_CONCEPT(index<typename _detail::binary_traits<Dyn, R>::Div>)),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator/,
+    (b, R))
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::Div
+  {
+    return _detail::binary_traits<Dyn, R>::div_fn(*this, b);
+  }
+
+  VEG_TEMPLATE(
+    (typename R),
+    requires(VEG_CONCEPT(index<R>) &&
+             VEG_CONCEPT(index<typename _detail::binary_traits<Dyn, R>::Mod>)),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator%,
+    (b, R))
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::Mod
+  {
+    return _detail::binary_traits<Dyn, R>::mod_fn(*this, b);
+  }
+
+#define VEG_CMP(Name, TypeName, Op)                                            \
+  VEG_TEMPLATE((typename R),                                                   \
+               requires(VEG_CONCEPT(index<R>)),                                \
+               VEG_NODISCARD VEG_INLINE constexpr auto                         \
+               operator Op, /* NOLINT */                                       \
+               (b, R))                                                         \
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Dyn, R>::TypeName        \
+  {                                                                            \
+    return _detail::binary_traits<Dyn, R>::cmp_##Name##_fn(*this, b);          \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+  VEG_CMP(eq, CmpEq, ==);
+  VEG_CMP(neq, CmpNEq, !=);
+  VEG_CMP(lt, CmpLT, <);
+  VEG_CMP(le, CmpLE, <=);
+  VEG_CMP(gt, CmpGT, >);
+  VEG_CMP(ge, CmpGE, >=);
+
+#undef VEG_CMP
+private:
+  isize m_val = 0;
+};
+
+template<Ternary T>
+VEG_INLINE constexpr Boolean<T>::Boolean(Boolean<maybe> /*b*/,
+                                         Unsafe /*tag*/) VEG_NOEXCEPT
+{
+}
+template<Ternary T>
+VEG_INLINE constexpr Boolean<T>::Boolean // NOLINT(hicpp-explicit-conversions)
+  (Boolean<maybe> b) VEG_NOEXCEPT
+  : Boolean(((void)VEG_INTERNAL_ASSERT_PRECONDITION(b.val == (T == yes)), b),
+            unsafe)
+{
+}
+
+template<isize N>
+VEG_INLINE constexpr Fix<N>::Fix(Dyn /*arg*/, Unsafe /*tag*/) VEG_NOEXCEPT
+{
+}
+template<isize N>
+VEG_INLINE constexpr Fix<N>::Fix // NOLINT(hicpp-explicit-conversions)
+  (Dyn arg) VEG_NOEXCEPT
+  : Fix((VEG_INTERNAL_ASSERT_PRECONDITION(isize(arg) == N), arg), unsafe)
+{
+}
+
+namespace _detail {
+
+template<>
+struct binary_traits<Dyn, Dyn>
+{
+#define VEG_OP(Name, TypeName, Op)                                             \
+  using TypeName /* NOLINT(bugprone-macro-parentheses) */ = Dyn;               \
+  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Dyn a, Dyn b)       \
+    VEG_NOEXCEPT->TypeName                                                     \
+  {                                                                            \
+    return { isize(usize(isize(a)) Op usize(isize(b))) };                      \
+  }                                                                            \
+  static_assert(true, "")
+
+#define VEG_CMP(Name, TypeName, Op)                                            \
+  using TypeName /* NOLINT(bugprone-macro-parentheses) */ = Boolean<maybe>;    \
+  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Dyn a, Dyn b)       \
+    VEG_NOEXCEPT->TypeName                                                     \
+  {                                                                            \
+    return (isize(a) Op isize(b));                                             \
+  }                                                                            \
+  static_assert(true, "")
+
+  VEG_OP(add, Add, +);
+  VEG_OP(sub, Sub, -);
+  VEG_OP(mul, Mul, *);
+  VEG_CMP(cmp_eq, CmpEq, ==);
+  VEG_CMP(cmp_neq, CmpNEq, !=);
+  VEG_CMP(cmp_lt, CmpLT, <);
+  VEG_CMP(cmp_le, CmpLE, <=);
+  VEG_CMP(cmp_gt, CmpGT, >);
+  VEG_CMP(cmp_ge, CmpGE, >=);
+
+  using Div = Dyn;
+  using Mod = Dyn;
+
+  VEG_NODISCARD static constexpr auto div_fn(Dyn a, Dyn b) VEG_NOEXCEPT->Div
+  {
+    return VEG_INTERNAL_ASSERT_PRECONDITION(isize(b) != isize(0)),
+           isize(a) / isize(b);
+  }
+  VEG_NODISCARD static constexpr auto mod_fn(Dyn a, Dyn b) VEG_NOEXCEPT->Mod
+  {
+
+    return VEG_INTERNAL_ASSERT_PRECONDITION(isize(b) != isize(0)),
+           isize(a) % isize(b);
+  }
+
+#undef VEG_OP
+#undef VEG_CMP
+};
+
+template<isize N>
+struct binary_traits<Fix<N>, Dyn> : binary_traits<Dyn, Dyn>
+{};
+
+template<>
+struct binary_traits<Fix<0>, Dyn> : binary_traits<Dyn, Dyn>
+{
+  using Mul = Fix<0>;
+  VEG_NODISCARD
+  constexpr VEG_INLINE static auto mul_fn(Fix<0> /*a*/,
+                                          Dyn /*b*/) VEG_NOEXCEPT->Mul
+  {
+    return {};
+  }
+};
+
+template<isize N>
+struct binary_traits<Dyn, Fix<N>> : binary_traits<Dyn, Dyn>
+{
+  using Mul = typename binary_traits<Fix<N>, Dyn>::Mul;
+  VEG_INLINE static constexpr auto mul_fn(Dyn a, Fix<N> /*b*/) VEG_NOEXCEPT->Mul
+  {
+    return binary_traits<Fix<N>, Dyn>::mul_fn({}, a);
+  }
+
+  using Div = meta::if_t<N == 0, void, Dyn>;
+  using Mod = meta::if_t<N == 0, void, Dyn>;
+
+  VEG_NODISCARD VEG_INLINE static constexpr auto div_fn(Dyn a, Fix<N> /*b*/)
+    VEG_NOEXCEPT->Div
+  {
+    return Div(isize(a) / N);
+  }
+  VEG_NODISCARD VEG_INLINE static constexpr auto mod_fn(Dyn a, Fix<N> /*b*/)
+    VEG_NOEXCEPT->Mod
+  {
+    return Mod(isize(a) % N);
+  }
+};
+
+} // namespace _detail
+
+inline namespace literals {
+VEG_INLINE constexpr auto operator"" _v(unsigned long long n) VEG_NOEXCEPT->Dyn
+{
+  return isize(n);
+}
+} // namespace literals
+
+template<>
+struct fmt::Debug<Boolean<maybe>>
+{
+  static void to_string(fmt::Buffer& out, Ref<Boolean<maybe>> val)
+  {
+    out.insert(out.size(), "maybe[", 6);
+    Debug<bool>::to_string(out, ref(bool(val.get())));
+    out.insert(out.size(), "]", 1);
+  }
+};
+
+template<>
+struct fmt::Debug<Dyn>
+{
+  static void to_string(fmt::Buffer& out, Ref<Dyn> val)
+  {
+    out.insert(out.size(), "Dyn[", 4);
+    Debug<isize>::to_string(out, ref(isize(val.get())));
+    out.insert(out.size(), "]", 1);
+  }
+};
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_META_INT_DYN_HPP_GC385NKBS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/epilogue.hpp

 * *Ordering differences only*

```diff
@@ -1,31 +1,31 @@
-#ifndef VEG_PROLOGUE
-#error "missing prologue"
-#endif
-#undef VEG_PROLOGUE
-
-#undef VEG_HAS_BUILTIN_OR_0
-#undef VEG_HAS_BUILTIN_OR_1
-#undef VEG_HAS_BUILTIN_OR
-#undef VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT
-#undef VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD
-#undef VEG_CPP14
-#undef VEG_CPP17
-#undef VEG_CPP20
-#undef VEG_HAS_BUILTIN
-#undef VEG_IGNORE_CPP14_EXTENSION_WARNING
-#undef VEG_ABI
-#undef VEG_ABI_VERSION
-#undef VEG_DOC
-#undef VEG_DOC_LOCATION
-#undef VEG_DOC_FN
-#undef VEG_DOC_CTOR
-#undef VEG_DOC_CLASS
-
-#undef VEG_NOEXCEPT
-#undef VEG_NOEXCEPT_IF
-#undef VEG_IS_NOEXCEPT
-#undef VEG_ALWAYS_NOEXCEPT
-
-#undef VEG_INTERNAL_ASSERT_INVARIANT
-#undef VEG_INTERNAL_ASSERT_PRECONDITION
-#undef VEG_INTERNAL_ASSERT_PRECONDITIONS
+#ifndef VEG_PROLOGUE
+#error "missing prologue"
+#endif
+#undef VEG_PROLOGUE
+
+#undef VEG_HAS_BUILTIN_OR_0
+#undef VEG_HAS_BUILTIN_OR_1
+#undef VEG_HAS_BUILTIN_OR
+#undef VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT
+#undef VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD
+#undef VEG_CPP14
+#undef VEG_CPP17
+#undef VEG_CPP20
+#undef VEG_HAS_BUILTIN
+#undef VEG_IGNORE_CPP14_EXTENSION_WARNING
+#undef VEG_ABI
+#undef VEG_ABI_VERSION
+#undef VEG_DOC
+#undef VEG_DOC_LOCATION
+#undef VEG_DOC_FN
+#undef VEG_DOC_CTOR
+#undef VEG_DOC_CLASS
+
+#undef VEG_NOEXCEPT
+#undef VEG_NOEXCEPT_IF
+#undef VEG_IS_NOEXCEPT
+#undef VEG_ALWAYS_NOEXCEPT
+
+#undef VEG_INTERNAL_ASSERT_INVARIANT
+#undef VEG_INTERNAL_ASSERT_PRECONDITION
+#undef VEG_INTERNAL_ASSERT_PRECONDITIONS
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/fix_index.hpp

```diff
@@ -1,339 +1,339 @@
-#ifndef VEG_META_INT_FIX_HPP_7S9Y48TFS
-#define VEG_META_INT_FIX_HPP_7S9Y48TFS
-
-#include "proxsuite/linalg/veg/type_traits/tags.hpp"
-#include "proxsuite/linalg/veg/internal/std.hpp"
-#include "proxsuite/linalg/veg/internal/dbg.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-struct Dyn;
-template<isize N>
-struct Fix;
-
-namespace _detail {
-template<typename L, typename R>
-struct binary_traits
-{
-  using Add = void;
-  using Sub = void;
-  using Mul = void;
-  using Div = void;
-  using Mod = void;
-
-  using CmpEq = void;
-  using CmpNEq = void;
-  using CmpLT = void;
-  using CmpLE = void;
-  using CmpGT = void;
-  using CmpGE = void;
-};
-
-namespace idx {
-namespace adl {
-template<typename T>
-struct IdxBase
-{};
-} // namespace adl
-} // namespace idx
-namespace _meta {
-template<typename T>
-struct is_fix : false_type
-{};
-template<isize N>
-struct is_fix<Fix<N>> : true_type
-{};
-} // namespace _meta
-} // namespace _detail
-
-namespace concepts {
-VEG_DEF_CONCEPT(typename T,
-                index,
-                VEG_CONCEPT(same<T, Dyn>) || _detail::_meta::is_fix<T>::value);
-} // namespace concepts
-
-enum struct Ternary : unsigned char
-{
-  no,
-  maybe,
-  yes,
-};
-
-constexpr auto no = Ternary::no;
-constexpr auto maybe = Ternary::maybe;
-constexpr auto yes = Ternary::yes;
-using no_c = meta::constant<Ternary, Ternary::no>;
-using maybe_c = meta::constant<Ternary, Ternary::maybe>;
-using yes_c = meta::constant<Ternary, Ternary::yes>;
-
-template<Ternary T>
-struct Boolean;
-
-template<Ternary T>
-struct Boolean
-{
-  constexpr Boolean() VEG_NOEXCEPT = default;
-  using type = meta::constant<Ternary, T>;
-
-  VEG_INLINE constexpr Boolean(Boolean<maybe> /*b*/,
-                               Unsafe /*tag*/) VEG_NOEXCEPT;
-  VEG_INLINE constexpr Boolean // NOLINT(hicpp-explicit-conversions)
-    (Boolean<maybe> b) VEG_NOEXCEPT;
-
-  VEG_NODISCARD VEG_INLINE constexpr friend auto operator!(Boolean /*arg*/)
-    VEG_NOEXCEPT->Boolean<T == yes ? no : yes>
-  {
-    return {};
-  }
-  VEG_NODISCARD VEG_INLINE explicit constexpr operator bool() const VEG_NOEXCEPT
-  {
-    return T == yes;
-  }
-};
-
-template<isize N>
-struct Fix : _detail::idx::adl::IdxBase<Fix<N>>
-{
-  constexpr Fix() VEG_NOEXCEPT = default;
-  VEG_INLINE constexpr Fix(Dyn /*arg*/, Unsafe /*tag*/) VEG_NOEXCEPT;
-  VEG_INLINE constexpr Fix // NOLINT(hicpp-explicit-conversions)
-    (Dyn arg) VEG_NOEXCEPT;
-  VEG_TEMPLATE((isize M),
-               requires((M != N)),
-               constexpr Fix,
-               (/*arg*/, Fix<M>)) = delete;
-
-  VEG_NODISCARD VEG_INLINE explicit constexpr operator isize() const
-    VEG_NOEXCEPT
-  {
-    return N;
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator+() const VEG_NOEXCEPT->Fix
-  {
-    return {};
-  }
-  VEG_NODISCARD VEG_INLINE constexpr auto operator-() const
-    VEG_NOEXCEPT->Fix<-N>
-  {
-    return {};
-  }
-
-#define VEG_OP(Op, Name, TypeName)                                             \
-  VEG_TEMPLATE((typename R),                                                   \
-               requires(VEG_CONCEPT(index<R>)),                                \
-               VEG_NODISCARD VEG_INLINE constexpr auto                         \
-               operator Op,                                                    \
-               (b, R))                                                         \
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::TypeName        \
-  {                                                                            \
-    return _detail::binary_traits<Fix, R>::Name##_fn(*this, b);                \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-  VEG_OP(+, add, Add);
-  VEG_OP(-, sub, Sub);
-  VEG_OP(*, mul, Mul);
-
-#undef VEG_OP
-
-  VEG_TEMPLATE(
-    (typename R),
-    requires(VEG_CONCEPT(index<R>) &&
-             VEG_CONCEPT(index<typename _detail::binary_traits<Fix, R>::Div>)),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator/,
-    (b, R))
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::Div
-  {
-    return _detail::binary_traits<Fix, R>::div_fn(*this, b);
-  }
-
-  VEG_TEMPLATE(
-    (typename R),
-    requires(VEG_CONCEPT(index<R>) &&
-             VEG_CONCEPT(index<typename _detail::binary_traits<Fix, R>::Mod>)),
-    VEG_NODISCARD VEG_INLINE constexpr auto
-    operator%,
-    (b, R))
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::Mod
-  {
-    return _detail::binary_traits<Fix, R>::mod_fn(*this, b);
-  }
-
-#define VEG_CMP(Name, TypeName, Op)                                            \
-  VEG_TEMPLATE((typename R),                                                   \
-               requires(VEG_CONCEPT(index<R>)),                                \
-               VEG_NODISCARD VEG_INLINE constexpr auto                         \
-               operator Op, /* NOLINT */                                       \
-               (b, R))                                                         \
-  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::TypeName        \
-  {                                                                            \
-    return _detail::binary_traits<Fix, R>::cmp_##Name##_fn(*this, b);          \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-  VEG_CMP(eq, CmpEq, ==);
-  VEG_CMP(neq, CmpNEq, !=);
-  VEG_CMP(lt, CmpLT, <);
-  VEG_CMP(le, CmpLE, <=);
-  VEG_CMP(gt, CmpGT, >);
-  VEG_CMP(ge, CmpGE, >=);
-
-#undef VEG_CMP
-
-#undef VEG_CMP
-};
-
-namespace _detail {
-struct Error
-{
-  constexpr auto operator()(u64 const* fail = nullptr) const VEG_NOEXCEPT->u64
-  {
-    return *fail;
-  }
-};
-
-using parser = auto(*)(char, Error) -> u64;
-constexpr auto
-parse_digit_2(char c, Error e) VEG_NOEXCEPT->u64
-{
-  return (c == '0') ? 0 : (c == '1' ? 1 : e());
-}
-constexpr auto
-parse_digit_8(char c, Error e) VEG_NOEXCEPT->u64
-{
-  return (c >= '0' && c <= '7') ? u64(c - '0') : e();
-}
-constexpr auto
-parse_digit_10(char c, Error e) VEG_NOEXCEPT->u64
-{
-  return (c >= '0' && c <= '9') ? u64(c - '0') : e();
-}
-constexpr auto
-parse_digit_16(char c, Error e) VEG_NOEXCEPT->u64
-{
-  return (c >= '0' && c <= '9') //
-           ? u64(c - '0')
-           : (c >= 'a' && c <= 'f') //
-               ? u64(c - 'a')
-               : (c >= 'A' && c <= 'F') //
-                   ? u64(c - 'A')
-                   : e();
-}
-
-constexpr auto
-parse_digit(u64 radix) VEG_NOEXCEPT->parser
-{
-  return radix == 2
-           ? parse_digit_2
-           : (radix == 8
-                ? parse_digit_8
-                : (radix == 10 ? parse_digit_10
-                               : (radix == 16 ? parse_digit_16 : nullptr)));
-}
-
-constexpr auto
-parse_num(char const* str, u64 len, u64 radix, Error e) VEG_NOEXCEPT->u64
-{
-  return (len == 0) ? 0
-                    : radix * parse_num(str, len - 1, radix, e) +
-                        (parse_digit(radix)(str[len - 1], e));
-}
-
-constexpr auto
-parse_int(char const* str, u64 len, Error e) VEG_NOEXCEPT->u64
-{
-  return (len == 0) //
-           ? e()
-           : ((str[0] == '0') //
-                ? ((len == 1) //
-                     ? 0
-                     : (str[1] == 'b' || str[1] == 'B') //
-                         ? parse_num(str + 2, len - 2, 2, e)
-                         : (str[1] == 'x' || str[1] == 'X') //
-                             ? parse_num(str + 2, len - 2, 16, e)
-                             : parse_num(str + 1, len - 1, 8, e))
-                : parse_num(str, len, 10, e));
-}
-
-template<char... Chars>
-struct char_seq
-{
-  static constexpr char value[] = { Chars... };
-};
-
-template<isize N, isize M>
-struct binary_traits<Fix<N>, Fix<M>>
-{
-
-#define VEG_OP(Name, TypeName, Op)                                             \
-  using TypeName /* NOLINT(bugprone-macro-parentheses) */ =                    \
-    Fix<isize(usize(isize{ N }) Op usize(isize{ M }))>;                        \
-  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Fix<N>, Fix<M>)     \
-    VEG_NOEXCEPT->TypeName                                                     \
-  {                                                                            \
-    return {};                                                                 \
-  }                                                                            \
-  static_assert(true, "")
-
-#define VEG_CMP(Name, TypeName, Op)                                            \
-  using TypeName /* NOLINT(bugprone-macro-parentheses) */ =                    \
-    Boolean<(N Op M) ? yes : no>;                                              \
-  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Fix<N>, Fix<M>)     \
-    VEG_NOEXCEPT->TypeName                                                     \
-  {                                                                            \
-    return {};                                                                 \
-  }                                                                            \
-  static_assert(true, "")
-
-  VEG_OP(add, Add, +);
-  VEG_OP(sub, Sub, -);
-  VEG_OP(mul, Mul, *);
-  VEG_CMP(cmp_eq, CmpEq, ==);
-  VEG_CMP(cmp_neq, CmpNEq, !=);
-  VEG_CMP(cmp_lt, CmpLT, <);
-  VEG_CMP(cmp_le, CmpLE, <=);
-  VEG_CMP(cmp_gt, CmpGT, >);
-  VEG_CMP(cmp_ge, CmpGE, >=);
-
-  using Div = meta::if_t<M == 0, void, Fix<N / (M != 0 ? M : 1)>>;
-  using Mod = meta::if_t<M == 0, void, Fix<N % (M != 0 ? M : 1)>>;
-
-  VEG_NODISCARD VEG_INLINE static constexpr auto div_fn(Fix<N> /*a*/,
-                                                        Fix<M> /*b*/)
-    VEG_NOEXCEPT->Div
-  {
-    return Div();
-  }
-  VEG_NODISCARD VEG_INLINE static constexpr auto mod_fn(Fix<N> /*a*/,
-                                                        Fix<M> /*b*/)
-    VEG_NOEXCEPT->Mod
-  {
-    return Mod();
-  }
-
-#undef VEG_OP
-#undef VEG_CMP
-};
-namespace idx {
-namespace adl {
-} // namespace adl
-} // namespace idx
-} // namespace _detail
-
-inline namespace literals {
-template<char... Chars>
-VEG_INLINE constexpr auto operator"" _c() VEG_NOEXCEPT
-{
-  return Fix<_detail::parse_int(
-    _detail::char_seq<Chars...>::value, sizeof...(Chars), _detail::Error{})>{};
-}
-} // namespace literals
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_META_INT_FIX_HPP_7S9Y48TFS */
+#ifndef VEG_META_INT_FIX_HPP_7S9Y48TFS
+#define VEG_META_INT_FIX_HPP_7S9Y48TFS
+
+#include "proxsuite/linalg/veg/type_traits/tags.hpp"
+#include "proxsuite/linalg/veg/internal/std.hpp"
+#include "proxsuite/linalg/veg/internal/dbg.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+struct Dyn;
+template<isize N>
+struct Fix;
+
+namespace _detail {
+template<typename L, typename R>
+struct binary_traits
+{
+  using Add = void;
+  using Sub = void;
+  using Mul = void;
+  using Div = void;
+  using Mod = void;
+
+  using CmpEq = void;
+  using CmpNEq = void;
+  using CmpLT = void;
+  using CmpLE = void;
+  using CmpGT = void;
+  using CmpGE = void;
+};
+
+namespace idx {
+namespace adl {
+template<typename T>
+struct IdxBase
+{};
+} // namespace adl
+} // namespace idx
+namespace _meta {
+template<typename T>
+struct is_fix : false_type
+{};
+template<isize N>
+struct is_fix<Fix<N>> : true_type
+{};
+} // namespace _meta
+} // namespace _detail
+
+namespace concepts {
+VEG_DEF_CONCEPT(typename T,
+                index,
+                VEG_CONCEPT(same<T, Dyn>) || _detail::_meta::is_fix<T>::value);
+} // namespace concepts
+
+enum struct Ternary : unsigned char
+{
+  no,
+  maybe,
+  yes,
+};
+
+constexpr auto no = Ternary::no;
+constexpr auto maybe = Ternary::maybe;
+constexpr auto yes = Ternary::yes;
+using no_c = meta::constant<Ternary, Ternary::no>;
+using maybe_c = meta::constant<Ternary, Ternary::maybe>;
+using yes_c = meta::constant<Ternary, Ternary::yes>;
+
+template<Ternary T>
+struct Boolean;
+
+template<Ternary T>
+struct Boolean
+{
+  constexpr Boolean() VEG_NOEXCEPT = default;
+  using type = meta::constant<Ternary, T>;
+
+  VEG_INLINE constexpr Boolean(Boolean<maybe> /*b*/,
+                               Unsafe /*tag*/) VEG_NOEXCEPT;
+  VEG_INLINE constexpr Boolean // NOLINT(hicpp-explicit-conversions)
+    (Boolean<maybe> b) VEG_NOEXCEPT;
+
+  VEG_NODISCARD VEG_INLINE constexpr friend auto operator!(Boolean /*arg*/)
+    VEG_NOEXCEPT->Boolean<T == yes ? no : yes>
+  {
+    return {};
+  }
+  VEG_NODISCARD VEG_INLINE explicit constexpr operator bool() const VEG_NOEXCEPT
+  {
+    return T == yes;
+  }
+};
+
+template<isize N>
+struct Fix : _detail::idx::adl::IdxBase<Fix<N>>
+{
+  constexpr Fix() VEG_NOEXCEPT = default;
+  VEG_INLINE constexpr Fix(Dyn /*arg*/, Unsafe /*tag*/) VEG_NOEXCEPT;
+  VEG_INLINE constexpr Fix // NOLINT(hicpp-explicit-conversions)
+    (Dyn arg) VEG_NOEXCEPT;
+  VEG_TEMPLATE((isize M),
+               requires((M != N)),
+               constexpr Fix,
+               (/*arg*/, Fix<M>)) = delete;
+
+  VEG_NODISCARD VEG_INLINE explicit constexpr operator isize() const
+    VEG_NOEXCEPT
+  {
+    return N;
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator+() const VEG_NOEXCEPT->Fix
+  {
+    return {};
+  }
+  VEG_NODISCARD VEG_INLINE constexpr auto operator-() const
+    VEG_NOEXCEPT->Fix<-N>
+  {
+    return {};
+  }
+
+#define VEG_OP(Op, Name, TypeName)                                             \
+  VEG_TEMPLATE((typename R),                                                   \
+               requires(VEG_CONCEPT(index<R>)),                                \
+               VEG_NODISCARD VEG_INLINE constexpr auto                         \
+               operator Op,                                                    \
+               (b, R))                                                         \
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::TypeName        \
+  {                                                                            \
+    return _detail::binary_traits<Fix, R>::Name##_fn(*this, b);                \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+  VEG_OP(+, add, Add);
+  VEG_OP(-, sub, Sub);
+  VEG_OP(*, mul, Mul);
+
+#undef VEG_OP
+
+  VEG_TEMPLATE(
+    (typename R),
+    requires(VEG_CONCEPT(index<R>) &&
+             VEG_CONCEPT(index<typename _detail::binary_traits<Fix, R>::Div>)),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator/,
+    (b, R))
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::Div
+  {
+    return _detail::binary_traits<Fix, R>::div_fn(*this, b);
+  }
+
+  VEG_TEMPLATE(
+    (typename R),
+    requires(VEG_CONCEPT(index<R>) &&
+             VEG_CONCEPT(index<typename _detail::binary_traits<Fix, R>::Mod>)),
+    VEG_NODISCARD VEG_INLINE constexpr auto
+    operator%,
+    (b, R))
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::Mod
+  {
+    return _detail::binary_traits<Fix, R>::mod_fn(*this, b);
+  }
+
+#define VEG_CMP(Name, TypeName, Op)                                            \
+  VEG_TEMPLATE((typename R),                                                   \
+               requires(VEG_CONCEPT(index<R>)),                                \
+               VEG_NODISCARD VEG_INLINE constexpr auto                         \
+               operator Op, /* NOLINT */                                       \
+               (b, R))                                                         \
+  const VEG_NOEXCEPT->typename _detail::binary_traits<Fix, R>::TypeName        \
+  {                                                                            \
+    return _detail::binary_traits<Fix, R>::cmp_##Name##_fn(*this, b);          \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+  VEG_CMP(eq, CmpEq, ==);
+  VEG_CMP(neq, CmpNEq, !=);
+  VEG_CMP(lt, CmpLT, <);
+  VEG_CMP(le, CmpLE, <=);
+  VEG_CMP(gt, CmpGT, >);
+  VEG_CMP(ge, CmpGE, >=);
+
+#undef VEG_CMP
+
+#undef VEG_CMP
+};
+
+namespace _detail {
+struct Error
+{
+  constexpr auto operator()(u64 const* fail = nullptr) const VEG_NOEXCEPT->u64
+  {
+    return *fail;
+  }
+};
+
+using parser = auto (*)(char, Error) -> u64;
+constexpr auto
+parse_digit_2(char c, Error e) VEG_NOEXCEPT->u64
+{
+  return (c == '0') ? 0 : (c == '1' ? 1 : e());
+}
+constexpr auto
+parse_digit_8(char c, Error e) VEG_NOEXCEPT->u64
+{
+  return (c >= '0' && c <= '7') ? u64(c - '0') : e();
+}
+constexpr auto
+parse_digit_10(char c, Error e) VEG_NOEXCEPT->u64
+{
+  return (c >= '0' && c <= '9') ? u64(c - '0') : e();
+}
+constexpr auto
+parse_digit_16(char c, Error e) VEG_NOEXCEPT->u64
+{
+  return (c >= '0' && c <= '9') //
+           ? u64(c - '0')
+           : (c >= 'a' && c <= 'f') //
+               ? u64(c - 'a')
+               : (c >= 'A' && c <= 'F') //
+                   ? u64(c - 'A')
+                   : e();
+}
+
+constexpr auto
+parse_digit(u64 radix) VEG_NOEXCEPT->parser
+{
+  return radix == 2
+           ? parse_digit_2
+           : (radix == 8
+                ? parse_digit_8
+                : (radix == 10 ? parse_digit_10
+                               : (radix == 16 ? parse_digit_16 : nullptr)));
+}
+
+constexpr auto
+parse_num(char const* str, u64 len, u64 radix, Error e) VEG_NOEXCEPT->u64
+{
+  return (len == 0) ? 0
+                    : radix * parse_num(str, len - 1, radix, e) +
+                        (parse_digit(radix)(str[len - 1], e));
+}
+
+constexpr auto
+parse_int(char const* str, u64 len, Error e) VEG_NOEXCEPT->u64
+{
+  return (len == 0) //
+           ? e()
+           : ((str[0] == '0') //
+                ? ((len == 1) //
+                     ? 0
+                     : (str[1] == 'b' || str[1] == 'B') //
+                         ? parse_num(str + 2, len - 2, 2, e)
+                         : (str[1] == 'x' || str[1] == 'X') //
+                             ? parse_num(str + 2, len - 2, 16, e)
+                             : parse_num(str + 1, len - 1, 8, e))
+                : parse_num(str, len, 10, e));
+}
+
+template<char... Chars>
+struct char_seq
+{
+  static constexpr char value[] = { Chars... };
+};
+
+template<isize N, isize M>
+struct binary_traits<Fix<N>, Fix<M>>
+{
+
+#define VEG_OP(Name, TypeName, Op)                                             \
+  using TypeName /* NOLINT(bugprone-macro-parentheses) */ =                    \
+    Fix<isize(usize(isize{ N }) Op usize(isize{ M }))>;                        \
+  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Fix<N>, Fix<M>)     \
+    VEG_NOEXCEPT->TypeName                                                     \
+  {                                                                            \
+    return {};                                                                 \
+  }                                                                            \
+  static_assert(true, "")
+
+#define VEG_CMP(Name, TypeName, Op)                                            \
+  using TypeName /* NOLINT(bugprone-macro-parentheses) */ =                    \
+    Boolean<(N Op M) ? yes : no>;                                              \
+  VEG_NODISCARD VEG_INLINE static constexpr auto Name##_fn(Fix<N>, Fix<M>)     \
+    VEG_NOEXCEPT->TypeName                                                     \
+  {                                                                            \
+    return {};                                                                 \
+  }                                                                            \
+  static_assert(true, "")
+
+  VEG_OP(add, Add, +);
+  VEG_OP(sub, Sub, -);
+  VEG_OP(mul, Mul, *);
+  VEG_CMP(cmp_eq, CmpEq, ==);
+  VEG_CMP(cmp_neq, CmpNEq, !=);
+  VEG_CMP(cmp_lt, CmpLT, <);
+  VEG_CMP(cmp_le, CmpLE, <=);
+  VEG_CMP(cmp_gt, CmpGT, >);
+  VEG_CMP(cmp_ge, CmpGE, >=);
+
+  using Div = meta::if_t<M == 0, void, Fix<N / (M != 0 ? M : 1)>>;
+  using Mod = meta::if_t<M == 0, void, Fix<N % (M != 0 ? M : 1)>>;
+
+  VEG_NODISCARD VEG_INLINE static constexpr auto div_fn(Fix<N> /*a*/,
+                                                        Fix<M> /*b*/)
+    VEG_NOEXCEPT->Div
+  {
+    return Div();
+  }
+  VEG_NODISCARD VEG_INLINE static constexpr auto mod_fn(Fix<N> /*a*/,
+                                                        Fix<M> /*b*/)
+    VEG_NOEXCEPT->Mod
+  {
+    return Mod();
+  }
+
+#undef VEG_OP
+#undef VEG_CMP
+};
+namespace idx {
+namespace adl {
+} // namespace adl
+} // namespace idx
+} // namespace _detail
+
+inline namespace literals {
+template<char... Chars>
+VEG_INLINE constexpr auto operator"" _c() VEG_NOEXCEPT
+{
+  return Fix<_detail::parse_int(
+    _detail::char_seq<Chars...>::value, sizeof...(Chars), _detail::Error{})>{};
+}
+} // namespace literals
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_META_INT_FIX_HPP_7S9Y48TFS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/has_asan.hpp

 * *Ordering differences only*

```diff
@@ -1,17 +1,17 @@
-#ifndef VEG_HAS_ASAN_HPP_AWVAMMSFS
-#define VEG_HAS_ASAN_HPP_AWVAMMSFS
-
-#if defined(__clang__)
-#if __has_feature(address_sanitizer)
-#define VEG_HAS_ASAN 1
-#else
-#define VEG_HAS_ASAN 0
-#endif
-
-#elif defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1
-#define VEG_HAS_ASAN 1
-#else
-#define VEG_HAS_ASAN 0
-#endif
-
-#endif /* end of include guard VEG_HAS_ASAN_HPP_AWVAMMSFS */
+#ifndef VEG_HAS_ASAN_HPP_AWVAMMSFS
+#define VEG_HAS_ASAN_HPP_AWVAMMSFS
+
+#if defined(__clang__)
+#if __has_feature(address_sanitizer)
+#define VEG_HAS_ASAN 1
+#else
+#define VEG_HAS_ASAN 0
+#endif
+
+#elif defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1
+#define VEG_HAS_ASAN 1
+#else
+#define VEG_HAS_ASAN 0
+#endif
+
+#endif /* end of include guard VEG_HAS_ASAN_HPP_AWVAMMSFS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/integer_seq.hpp

 * *Ordering differences only*

```diff
@@ -1,248 +1,248 @@
-#ifndef VEG_INTEGER_SEQ_HPP_JBT0EKAQS
-#define VEG_INTEGER_SEQ_HPP_JBT0EKAQS
-
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/internal/macros.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace meta {
-
-template<typename T, T N>
-using make_integer_sequence = _detail::_meta::make_integer_sequence<T, N>*;
-template<usize N>
-using make_index_sequence = _detail::_meta::make_integer_sequence<usize, N>*;
-
-template<typename T, T... Nums>
-using integer_sequence = _detail::_meta::integer_sequence<T, Nums...>*;
-template<usize... Nums>
-using index_sequence = integer_sequence<usize, Nums...>;
-template<typename... Ts>
-using type_sequence = _detail::_meta::type_sequence<Ts...>*;
-
-template<typename Seq, typename... Bs>
-struct and_test : false_type
-{};
-template<typename Seq, typename... Bs>
-struct or_test : true_type
-{};
-
-template<usize Is, typename T>
-using indexed = T;
-
-template<typename... Ts>
-struct pack_size
-{
-  static constexpr usize value = sizeof...(Ts);
-};
-template<usize... Is>
-struct and_test<index_sequence<Is...>, indexed<Is, true_type>...> : true_type
-{};
-template<usize... Is>
-struct or_test<index_sequence<Is...>, indexed<Is, false_type>...> : false_type
-{};
-
-} // namespace meta
-namespace _detail {
-namespace _meta {
-using namespace meta;
-
-template<typename ISeq, typename... Ts>
-struct all_same_impl : false_type
-{};
-template<usize... Is, typename T>
-struct all_same_impl<meta::index_sequence<Is...>,
-                     discard_1st<decltype(Is), T>...> : true_type
-{};
-
-template<>
-struct all_same_impl<meta::index_sequence<>> : true_type
-{};
-} // namespace _meta
-} // namespace _detail
-
-namespace concepts {
-VEG_DEF_CONCEPT(
-  typename... Ts,
-  all_same,
-  _detail::_meta::all_same_impl<meta::make_index_sequence<sizeof...(Ts)>,
-                                Ts...>::value);
-} // namespace concepts
-
-namespace _detail {
-namespace _meta {
-template<template<typename...> class F, typename Seq>
-struct apply_type_seq;
-template<template<typename...> class F, typename... Ts>
-struct apply_type_seq<F, meta::type_sequence<Ts...>>
-{
-  using type = F<Ts...>;
-};
-
-template<typename Valid, template<typename...> class F, typename... Seqs>
-struct concat_type_seq;
-
-template<typename Valid, template<typename...> class F, typename... Seqs>
-struct zip_type_seq;
-template<template<typename...> class F, typename... Seqs>
-struct zip_type_seq2;
-
-template<template<typename...> class F>
-struct zip_type_seq<meta::true_type, F>
-{
-  using type = F<>;
-};
-
-template<template<typename...> class F, typename... Ts>
-struct zip_type_seq<meta::true_type, F, F<Ts...>>
-{
-  using type = F<F<Ts>...>;
-};
-
-template<template<typename...> class F, typename... Ts, typename... Zipped>
-struct zip_type_seq2<F, F<Ts...>, F<Zipped...>>
-{
-  using type =
-    F<typename concat_type_seq<true_type, F, F<Ts>, Zipped>::type...>;
-};
-
-template<template<typename...> class F, typename T>
-struct specializes : meta::false_type
-{};
-template<template<typename...> class F, typename... Ts>
-struct specializes<F, F<Ts...>> : meta::true_type
-{};
-
-template<template<typename...> class F, typename T>
-struct specialize_len : meta::constant<usize, 0>
-{};
-template<template<typename...> class F, typename... Ts>
-struct specialize_len<F, F<Ts...>> : meta::constant<usize, sizeof...(Ts)>
-{};
-
-template<template<typename...> class F,
-         typename... Ts,
-         typename Seq,
-         typename... Seqs>
-struct zip_type_seq<meta::true_type, F, F<Ts...>, Seq, Seqs...>
-{
-  using type = typename zip_type_seq2<
-    F,
-    F<Ts...>,
-    typename zip_type_seq<meta::true_type, F, Seq, Seqs...>::type>::type;
-};
-
-template<template<typename...> class F>
-struct concat_type_seq<true_type, F>
-{
-  using type = F<>;
-};
-
-template<template<typename...> class F, typename... Ts>
-struct concat_type_seq<true_type, F, F<Ts...>>
-{
-  using type = F<Ts...>;
-};
-
-template<template<typename...> class F, typename... Ts, typename... Us>
-struct concat_type_seq<true_type, F, F<Ts...>, F<Us...>>
-{
-  using type = F<Ts..., Us...>;
-};
-
-template<template<typename...> class F,
-         typename... Ts,
-         typename... Us,
-         typename... Vs,
-         typename... Seqs>
-struct concat_type_seq<true_type, F, F<Ts...>, F<Us...>, F<Vs...>, Seqs...>
-{
-  using type = typename concat_type_seq<
-    true_type,
-    F,
-    F<Ts..., Us..., Vs...>,
-    typename concat_type_seq<true_type, F, Seqs...>::type>::type;
-};
-} // namespace _meta
-} // namespace _detail
-namespace meta {
-template<template<typename... F> class F, typename... Seqs>
-using type_sequence_cat = typename _detail::_meta::concat_type_seq<
-  bool_constant<VEG_ALL_OF(_detail::_meta::specializes<F, Seqs>::value)>,
-  F,
-  Seqs...>::type;
-
-template<template<typename...> class F, typename... Seqs>
-using type_sequence_zip = typename _detail::_meta::zip_type_seq<
-  meta::bool_constant<
-    VEG_ALL_OF(_detail::_meta::specializes<F, Seqs>::value) &&
-    VEG_CONCEPT(
-      all_same<
-        constant<usize, _detail::_meta::specialize_len<F, Seqs>::value>...>)>,
-  F,
-  Seqs...>::type;
-
-template<template<typename...> class F, typename Seq>
-using type_sequence_apply =
-  typename _detail::_meta::apply_type_seq<F, Seq>::type;
-} // namespace meta
-
-namespace _detail {
-
-template<usize I, typename T>
-struct HollowLeaf
-{};
-
-template<typename ISeq, typename... Ts>
-struct HollowIndexedTuple;
-template<usize... Is, typename... Ts>
-struct HollowIndexedTuple<meta::index_sequence<Is...>, Ts...>
-  : HollowLeaf<Is, Ts>...
-{};
-
-template<usize I, typename T>
-auto
-get_type(HollowLeaf<I, T> const*) VEG_NOEXCEPT->T;
-template<typename T, usize I>
-auto
-get_idx(HollowLeaf<I, T> const*) VEG_NOEXCEPT->meta::constant<usize, I>;
-
-template<usize I>
-struct pack_ith_elem
-{
-  template<typename... Ts>
-  using Type = decltype(_detail::get_type<I>(
-    static_cast<
-      HollowIndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>*>(
-      nullptr)));
-};
-
-template<typename T>
-struct pack_idx_elem
-{
-  template<typename... Ts>
-  using Type = decltype(_detail::get_idx<T>(
-    static_cast<
-      HollowIndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>*>(
-      nullptr)));
-};
-} // namespace _detail
-
-template<typename T, typename... Ts>
-using position_of = typename _detail::pack_idx_elem<T>::template Type<Ts...>;
-
-#if VEG_HAS_BUILTIN(__type_pack_element)
-template<usize I, typename... Ts>
-using ith = __type_pack_element<I, Ts...>;
-#else
-template<usize I, typename... Ts>
-using ith = typename _detail::pack_ith_elem<I>::template Type<Ts...>;
-#endif
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_INTEGER_SEQ_HPP_JBT0EKAQS */
+#ifndef VEG_INTEGER_SEQ_HPP_JBT0EKAQS
+#define VEG_INTEGER_SEQ_HPP_JBT0EKAQS
+
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/internal/macros.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace meta {
+
+template<typename T, T N>
+using make_integer_sequence = _detail::_meta::make_integer_sequence<T, N>*;
+template<usize N>
+using make_index_sequence = _detail::_meta::make_integer_sequence<usize, N>*;
+
+template<typename T, T... Nums>
+using integer_sequence = _detail::_meta::integer_sequence<T, Nums...>*;
+template<usize... Nums>
+using index_sequence = integer_sequence<usize, Nums...>;
+template<typename... Ts>
+using type_sequence = _detail::_meta::type_sequence<Ts...>*;
+
+template<typename Seq, typename... Bs>
+struct and_test : false_type
+{};
+template<typename Seq, typename... Bs>
+struct or_test : true_type
+{};
+
+template<usize Is, typename T>
+using indexed = T;
+
+template<typename... Ts>
+struct pack_size
+{
+  static constexpr usize value = sizeof...(Ts);
+};
+template<usize... Is>
+struct and_test<index_sequence<Is...>, indexed<Is, true_type>...> : true_type
+{};
+template<usize... Is>
+struct or_test<index_sequence<Is...>, indexed<Is, false_type>...> : false_type
+{};
+
+} // namespace meta
+namespace _detail {
+namespace _meta {
+using namespace meta;
+
+template<typename ISeq, typename... Ts>
+struct all_same_impl : false_type
+{};
+template<usize... Is, typename T>
+struct all_same_impl<meta::index_sequence<Is...>,
+                     discard_1st<decltype(Is), T>...> : true_type
+{};
+
+template<>
+struct all_same_impl<meta::index_sequence<>> : true_type
+{};
+} // namespace _meta
+} // namespace _detail
+
+namespace concepts {
+VEG_DEF_CONCEPT(
+  typename... Ts,
+  all_same,
+  _detail::_meta::all_same_impl<meta::make_index_sequence<sizeof...(Ts)>,
+                                Ts...>::value);
+} // namespace concepts
+
+namespace _detail {
+namespace _meta {
+template<template<typename...> class F, typename Seq>
+struct apply_type_seq;
+template<template<typename...> class F, typename... Ts>
+struct apply_type_seq<F, meta::type_sequence<Ts...>>
+{
+  using type = F<Ts...>;
+};
+
+template<typename Valid, template<typename...> class F, typename... Seqs>
+struct concat_type_seq;
+
+template<typename Valid, template<typename...> class F, typename... Seqs>
+struct zip_type_seq;
+template<template<typename...> class F, typename... Seqs>
+struct zip_type_seq2;
+
+template<template<typename...> class F>
+struct zip_type_seq<meta::true_type, F>
+{
+  using type = F<>;
+};
+
+template<template<typename...> class F, typename... Ts>
+struct zip_type_seq<meta::true_type, F, F<Ts...>>
+{
+  using type = F<F<Ts>...>;
+};
+
+template<template<typename...> class F, typename... Ts, typename... Zipped>
+struct zip_type_seq2<F, F<Ts...>, F<Zipped...>>
+{
+  using type =
+    F<typename concat_type_seq<true_type, F, F<Ts>, Zipped>::type...>;
+};
+
+template<template<typename...> class F, typename T>
+struct specializes : meta::false_type
+{};
+template<template<typename...> class F, typename... Ts>
+struct specializes<F, F<Ts...>> : meta::true_type
+{};
+
+template<template<typename...> class F, typename T>
+struct specialize_len : meta::constant<usize, 0>
+{};
+template<template<typename...> class F, typename... Ts>
+struct specialize_len<F, F<Ts...>> : meta::constant<usize, sizeof...(Ts)>
+{};
+
+template<template<typename...> class F,
+         typename... Ts,
+         typename Seq,
+         typename... Seqs>
+struct zip_type_seq<meta::true_type, F, F<Ts...>, Seq, Seqs...>
+{
+  using type = typename zip_type_seq2<
+    F,
+    F<Ts...>,
+    typename zip_type_seq<meta::true_type, F, Seq, Seqs...>::type>::type;
+};
+
+template<template<typename...> class F>
+struct concat_type_seq<true_type, F>
+{
+  using type = F<>;
+};
+
+template<template<typename...> class F, typename... Ts>
+struct concat_type_seq<true_type, F, F<Ts...>>
+{
+  using type = F<Ts...>;
+};
+
+template<template<typename...> class F, typename... Ts, typename... Us>
+struct concat_type_seq<true_type, F, F<Ts...>, F<Us...>>
+{
+  using type = F<Ts..., Us...>;
+};
+
+template<template<typename...> class F,
+         typename... Ts,
+         typename... Us,
+         typename... Vs,
+         typename... Seqs>
+struct concat_type_seq<true_type, F, F<Ts...>, F<Us...>, F<Vs...>, Seqs...>
+{
+  using type = typename concat_type_seq<
+    true_type,
+    F,
+    F<Ts..., Us..., Vs...>,
+    typename concat_type_seq<true_type, F, Seqs...>::type>::type;
+};
+} // namespace _meta
+} // namespace _detail
+namespace meta {
+template<template<typename... F> class F, typename... Seqs>
+using type_sequence_cat = typename _detail::_meta::concat_type_seq<
+  bool_constant<VEG_ALL_OF(_detail::_meta::specializes<F, Seqs>::value)>,
+  F,
+  Seqs...>::type;
+
+template<template<typename...> class F, typename... Seqs>
+using type_sequence_zip = typename _detail::_meta::zip_type_seq<
+  meta::bool_constant<
+    VEG_ALL_OF(_detail::_meta::specializes<F, Seqs>::value) &&
+    VEG_CONCEPT(
+      all_same<
+        constant<usize, _detail::_meta::specialize_len<F, Seqs>::value>...>)>,
+  F,
+  Seqs...>::type;
+
+template<template<typename...> class F, typename Seq>
+using type_sequence_apply =
+  typename _detail::_meta::apply_type_seq<F, Seq>::type;
+} // namespace meta
+
+namespace _detail {
+
+template<usize I, typename T>
+struct HollowLeaf
+{};
+
+template<typename ISeq, typename... Ts>
+struct HollowIndexedTuple;
+template<usize... Is, typename... Ts>
+struct HollowIndexedTuple<meta::index_sequence<Is...>, Ts...>
+  : HollowLeaf<Is, Ts>...
+{};
+
+template<usize I, typename T>
+auto
+get_type(HollowLeaf<I, T> const*) VEG_NOEXCEPT->T;
+template<typename T, usize I>
+auto
+get_idx(HollowLeaf<I, T> const*) VEG_NOEXCEPT->meta::constant<usize, I>;
+
+template<usize I>
+struct pack_ith_elem
+{
+  template<typename... Ts>
+  using Type = decltype(_detail::get_type<I>(
+    static_cast<
+      HollowIndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>*>(
+      nullptr)));
+};
+
+template<typename T>
+struct pack_idx_elem
+{
+  template<typename... Ts>
+  using Type = decltype(_detail::get_idx<T>(
+    static_cast<
+      HollowIndexedTuple<meta::make_index_sequence<sizeof...(Ts)>, Ts...>*>(
+      nullptr)));
+};
+} // namespace _detail
+
+template<typename T, typename... Ts>
+using position_of = typename _detail::pack_idx_elem<T>::template Type<Ts...>;
+
+#if VEG_HAS_BUILTIN(__type_pack_element)
+template<usize I, typename... Ts>
+using ith = __type_pack_element<I, Ts...>;
+#else
+template<usize I, typename... Ts>
+using ith = typename _detail::pack_ith_elem<I>::template Type<Ts...>;
+#endif
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_INTEGER_SEQ_HPP_JBT0EKAQS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/macros.hpp

```diff
@@ -1,1312 +1,1317 @@
-#ifndef VEG_MACROS_HPP_HSTLSKZXS
-#define VEG_MACROS_HPP_HSTLSKZXS
-#include "proxsuite/linalg/veg/internal/external/hedley.ext.hpp"
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/internal/preprocessor.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <initializer_list>
-
-////////////////////////////////////////////////////////////////////////////////
-
-#if _MSC_VER
-#define PROXSUITE_PRETTY_FUNCTION __FUNCSIG__
-#else
-#define PROXSUITE_PRETTY_FUNCTION __PRETTY_FUNCTION__
-#endif
-
-#define PROXSUITE_THROW_PRETTY(condition, exception, message)                  \
-  if (condition) {                                                             \
-    std::ostringstream ss;                                                     \
-    ss << "From file: " << __FILE__ << "\n";                                   \
-    ss << "in function: " << PROXSUITE_PRETTY_FUNCTION << "\n";                \
-    ss << "at line: " << __LINE__ << "\n";                                     \
-    ss << message << "\n";                                                     \
-    throw exception(ss.str());                                                 \
-  }
-
-#define PROXSUITE_CHECK_ARGUMENT_SIZE(size, expected_size, message)            \
-  if (size != expected_size) {                                                 \
-    std::ostringstream oss;                                                    \
-    oss << "wrong argument size: expected " << expected_size << ", got "       \
-        << size << "\n";                                                       \
-    oss << "hint: " << message << std::endl;                                   \
-    PROXSUITE_THROW_PRETTY(true, std::invalid_argument, oss.str());            \
-  }
-
-#if HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                     \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define VEG_DEPRECATED(Reason) __declspec(deprecated(Reason))
-#elif HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) ||               \
-  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_ARM_VERSION_CHECK(5, 6, 0) ||                                         \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) ||                                     \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) || HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||  \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(18, 1, 0) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
-#define VEG_DEPRECATED(Reason) __attribute__((__deprecated__(Reason)))
-#elif defined(VEG_WITH_CXX14_SUPPORT)
-#define VEG_DEPRECATED(Reason)                                                 \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(Reason)]])
-#elif HEDLEY_HAS_ATTRIBUTE(deprecated) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) || \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||   \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define VEG_DEPRECATED(Reason) __attribute__((__deprecated__))
-#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
-  HEDLEY_PELLES_VERSION_CHECK(6, 50, 0) ||                                     \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define VEG_DEPRECATED(Reason) __declspec(deprecated)
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define VEG_DEPRECATED(Reason) _Pragma("deprecated")
-#else
-#define VEG_DEPRECATED(Reason)
-#endif
-
-/// \brief Helper to declare that a parameter is unused
-#define VEG_UNUSED_VARIABLE(var) (void)(var)
-#ifdef NDEBUG
-#define VEG_ONLY_USED_FOR_DEBUG(var) VEG_UNUSED_VARIABLE(var)
-#else
-#define VEG_ONLY_USED_FOR_DEBUG(var)
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-
-#if defined(__clang__)
-#define VEG_WRAP_SILENCE_WARNING(...)                                          \
-  HEDLEY_DIAGNOSTIC_PUSH _Pragma(                                              \
-    "clang diagnostic ignored \"-Wc++17-extensions\"")                         \
-    __VA_ARGS__ HEDLEY_DIAGNOSTIC_POP
-#else
-#define VEG_WRAP_SILENCE_WARNING(...) __VA_ARGS__
-#endif
-
-#ifndef VEG_HAS_NO_UNIQUE_ADDRESS
-#define VEG_HAS_NO_UNIQUE_ADDRESS 0
-#endif
-
-#if VEG_HAS_NO_UNIQUE_ADDRESS
-#ifdef _MSC_VER
-#define VEG_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
-#else
-#define VEG_NO_UNIQUE_ADDRESS [[no_unique_address]]
-#endif
-#else
-#define VEG_NO_UNIQUE_ADDRESS
-#endif
-
-#ifndef VEG_INLINE
-
-#if defined(NDEBUG) || defined(__OPTIMIZE__)
-#define VEG_INLINE HEDLEY_ALWAYS_INLINE
-#else
-#define VEG_INLINE inline
-#endif
-
-#endif
-
-#define VEG_NO_INLINE HEDLEY_NEVER_INLINE
-
-#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
-#define VEG_HAS_CONCEPTS 1
-#else
-#define VEG_HAS_CONCEPTS 0
-#endif
-
-#if defined(VEG_WITH_CXX17_SUPPORT)
-#define VEG_DECLVAL(...) (static_cast<__VA_ARGS__ (*)() noexcept>(nullptr)())
-#else
-#define VEG_DECLVAL(...)                                                       \
-  (::proxsuite::linalg::veg::_detail::_meta::declval<__VA_ARGS__>())
-#endif
-
-#if defined(__clang__)
-#define VEG_ARROW(...)                                                         \
-  __attribute__((always_inline)) noexcept(noexcept((__VA_ARGS__)))             \
-    ->decltype((__VA_ARGS__))                                                  \
-  {                                                                            \
-    return __VA_ARGS__;                                                        \
-  }
-#elif defined(__GNUC__) && (__GNUC__ >= 9)
-#define VEG_ARROW(...)                                                         \
-  noexcept(noexcept((__VA_ARGS__))) __attribute__((always_inline))             \
-    ->decltype((__VA_ARGS__))                                                  \
-  {                                                                            \
-    return __VA_ARGS__;                                                        \
-  }
-#else
-#define VEG_ARROW(...)                                                         \
-  noexcept(noexcept((__VA_ARGS__)))->decltype((__VA_ARGS__))                   \
-  {                                                                            \
-    return __VA_ARGS__;                                                        \
-  }
-#endif
-
-#define VEG_LAZY_BY_REF(...) [&]() VEG_ARROW(__VA_ARGS__)
-
-#define VEG_LIFT(...)                                                          \
-  [&](auto&&... args) VEG_ARROW((__VA_ARGS__)(VEG_FWD(args)...))
-
-#define VEG_DEDUCE_RET(...)                                                    \
-  noexcept(noexcept(__VA_ARGS__))->decltype(__VA_ARGS__)                       \
-  {                                                                            \
-    return __VA_ARGS__;                                                        \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-
-#if defined(VEG_WITH_CXX17_SUPPORT)
-#define VEG_HAS_FOLD_EXPR 1
-#define VEG_ALL_OF(...) (__VA_ARGS__ && ... && true)
-#define VEG_ANY_OF(...) (__VA_ARGS__ || ... || false)
-#elif defined(__clang__)
-#define VEG_HAS_FOLD_EXPR 1
-#define VEG_ALL_OF(...) VEG_WRAP_SILENCE_WARNING((__VA_ARGS__ && ... && true))
-#define VEG_ANY_OF(...) VEG_WRAP_SILENCE_WARNING((__VA_ARGS__ || ... || false))
-#else
-#define VEG_HAS_FOLD_EXPR 0
-#define VEG_ALL_OF(...)                                                        \
-  ::proxsuite::linalg::veg::meta::and_test<                                    \
-    ::proxsuite::linalg::veg::meta::make_index_sequence<                       \
-      ::proxsuite::linalg::veg::meta::pack_size<decltype((                     \
-        void)(__VA_ARGS__))...>::value>,                                       \
-    ::proxsuite::linalg::veg::meta::bool_constant<(__VA_ARGS__)>...>::value
-#define VEG_ANY_OF(...)                                                        \
-  ::proxsuite::linalg::veg::meta::or_test<                                     \
-    ::proxsuite::linalg::veg::meta::make_index_sequence<                       \
-      ::proxsuite::linalg::veg::meta::pack_size<decltype((                     \
-        void)(__VA_ARGS__))...>::value>,                                       \
-    ::proxsuite::linalg::veg::meta::bool_constant<(__VA_ARGS__)>...>::value
-#endif
-
-#define VEG_EVAL_ALL(...)                                                      \
-  ((void)(::proxsuite::linalg::veg::_detail::EmptyArr{                         \
-    ::proxsuite::linalg::veg::_detail::Empty{},                                \
-    ((void)(__VA_ARGS__), ::proxsuite::linalg::veg::_detail::Empty{})... }))
-
-////////////////////////////////////////////////////////////////////////////////
-
-#if VEG_HAS_CONCEPTS
-
-#define __VEG_IMPL_AND(_, Param) &&__VEG_PP_UNWRAP(Param)
-#define __VEG_IMPL_OR(_, Param) || __VEG_PP_UNWRAP(Param)
-
-#define __VEG_IMPL_CONJUNCTION(First, ...)                                     \
-  (__VEG_PP_UNWRAP(First)                                                      \
-     __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_AND, _, (__VA_ARGS__)))
-
-#define __VEG_IMPL_DISJUNCTION(First, ...)                                     \
-  (__VEG_PP_UNWRAP(First)                                                      \
-     __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_OR, _, (__VA_ARGS__)))
-
-#define VEG_DEF_CONCEPT(Tpl, Name, ...)                                        \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  concept Name = __VA_ARGS__;                                                  \
-  VEG_NOM_SEMICOLON
-
-#define VEG_CHECK_CONCEPT_MACRO(Namespace, ...)                                \
-  static_assert(Namespace::__VA_ARGS__,                                        \
-                __VEG_PP_STRINGIZE(__VA_ARGS__) " failed")
-#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__
-
-#define VEG_DEF_CONCEPT_CONJUNCTION(Tpl, Name, Terms)                          \
-  VEG_DEF_CONCEPT(Tpl, Name, __VEG_IMPL_CONJUNCTION Terms)
-#define VEG_DEF_CONCEPT_DISJUNCTION(Tpl, Name, Terms)                          \
-  VEG_DEF_CONCEPT(Tpl, Name, __VEG_IMPL_DISJUNCTION Terms)
-
-#define VEG_CONCEPT_EXPR(Tpl, TplNames, Name, Expr, ...)                       \
-  namespace _veg_detail {                                                      \
-  template<typename ExprType, __VEG_PP_REMOVE_PAREN1(Tpl)>                     \
-  concept test_return_##Name = __VA_ARGS__;                                    \
-  }                                                                            \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  concept Name = _veg_detail::test_return_                                     \
-  ##Name<decltype((Expr)), __VEG_PP_REMOVE_PAREN1(TplNames)>;                  \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  concept xnothrow_##Name = noexcept(Expr);                                    \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  concept nothrow_##Name = noexcept(Expr);                                     \
-  VEG_NOM_SEMICOLON
-
-#else
-
-#if defined(VEG_WITH_CXX14_SUPPORT)
-#define __VEG_IMPL_DEF_CONCEPT(Tpl, Name, Value, ...)                          \
-  namespace _ {                                                                \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  struct Name : __VA_ARGS__                                                    \
-  {};                                                                          \
-  }                                                                            \
-  namespace {                                                                  \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  constexpr bool const& Name =                                                 \
-    ::proxsuite::linalg::veg::meta::bool_constant<Value>::value;               \
-  }                                                                            \
-  VEG_NOM_SEMICOLON
-#else
-#define __VEG_IMPL_DEF_CONCEPT(Tpl, Name, Value, ...)                          \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  struct Name : __VA_ARGS__                                                    \
-  {}
-#endif
-
-#ifdef __clang__
-#define __VEG_NO_WARNING_PRAGMA_PUSH                                           \
-  HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic ignored \"-Wconversion\"")
-#define __VEG_NO_WARNING_PRAGMA_POP HEDLEY_DIAGNOSTIC_POP
-#else
-#define __VEG_NO_WARNING_PRAGMA_PUSH
-#define __VEG_NO_WARNING_PRAGMA_POP
-#endif
-
-#define VEG_CONCEPT_EXPR(Tpl, TplNames, Name, Expr, ...)                       \
-  namespace _veg_detail {                                                      \
-  template<typename _veg_Enable, __VEG_PP_REMOVE_PAREN1(Tpl)>                  \
-  struct test_sfinae_##Name                                                    \
-  {                                                                            \
-    using TestExpr = ::proxsuite::linalg::veg::meta::false_type;               \
-    using NothrowTestExpr = ::proxsuite::linalg::veg::meta::false_type;        \
-  };                                                                           \
-  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
-  struct test_sfinae_##Name<                                                   \
-    ::proxsuite::linalg::veg::meta::void_t<decltype((Expr))>,                  \
-    __VEG_PP_REMOVE_PAREN1(TplNames)>                                          \
-  {                                                                            \
-    using ExprType = decltype((Expr));                                         \
-    using TestExpr =                                                           \
-      ::proxsuite::linalg::veg::meta::bool_constant<__VA_ARGS__>;              \
-    using NothrowTestExpr = ::proxsuite::linalg::veg::meta::bool_constant<     \
-      (TestExpr::value) && __VEG_NO_WARNING_PRAGMA_PUSH noexcept(Expr)         \
-                             __VEG_NO_WARNING_PRAGMA_POP>;                     \
-  };                                                                           \
-  }                                                                            \
-  VEG_DEF_CONCEPT(                                                             \
-    Tpl,                                                                       \
-    Name,                                                                      \
-    _veg_detail::test_sfinae_##Name<void, __VEG_PP_REMOVE_PAREN1(TplNames)>::  \
-      TestExpr::value);                                                        \
-  VEG_DEF_CONCEPT(Tpl, nothrow_##Name, noexcept(Expr));                        \
-  VEG_DEF_CONCEPT(                                                             \
-    Tpl,                                                                       \
-    xnothrow_##Name,                                                           \
-    _veg_detail::test_sfinae_##Name<void, __VEG_PP_REMOVE_PAREN1(TplNames)>::  \
-      NothrowTestExpr::value);                                                 \
-  VEG_NOM_SEMICOLON
-
-#if defined(VEG_WITH_CXX14_SUPPORT)
-#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__
-#define __VEG_IMPL_ADD_VALUE(I, _, Param) (Param)
-#define __VEG_IMPL_TRAIT(Param) __VEG_PP_HEAD Param _::__VEG_PP_TAIL Param
-#else
-#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__::value
-#define __VEG_IMPL_ADD_VALUE(I, _, Param)                                      \
-  ((__VEG_PP_REMOVE_PAREN(Param)::value))
-#define __VEG_IMPL_TRAIT(Param) __VEG_PP_UNWRAP(Param)
-#endif
-#define __VEG_IMPL_PUT_TRAIT(I, _, Param) __VEG_IMPL_TRAIT(Param)
-
-#define VEG_CHECK_CONCEPT_MACRO(Namespace, ...)                                \
-  static_assert(decltype(Namespace::check_##__VA_ARGS__())::value,             \
-                __VEG_PP_STRINGIZE(__VA_ARGS__) " failed")
-#define VEG_DEF_CONCEPT(Tpl, Name, ...)                                        \
-  __VEG_IMPL_DEF_CONCEPT(                                                      \
-    Tpl,                                                                       \
-    Name,                                                                      \
-    (__VA_ARGS__),                                                             \
-    ::proxsuite::linalg::veg::meta::bool_constant<__VA_ARGS__>);               \
-  VEG_TEMPLATE(                                                                \
-    Tpl, requires(__VA_ARGS__), constexpr auto check_##Name, (_ = 0, int))     \
-  noexcept -> ::proxsuite::linalg::veg::meta::true_type
-
-#define __VEG_IMPL_SFINAE(_, Param)                                            \
-  , ::proxsuite::linalg::veg::meta::                                           \
-      enable_if_t<__VEG_PP_ID(__VEG_PP_UNWRAP Param), int> = 0
-
-#define __VEG_IMPL_OVERLOAD(Name_Tpl, Param)                                   \
-  template<__VEG_PP_REMOVE_PAREN(__VEG_PP_TAIL Name_Tpl),                      \
-           typename ::proxsuite::linalg::veg::_detail::_meta::                 \
-             enable_if<__VEG_PP_ID(__VEG_PP_UNWRAP Param), int>::type = 0>     \
-  auto __VEG_PP_CAT(check_, __VEG_PP_HEAD Name_Tpl)() noexcept                 \
-    -> ::proxsuite::linalg::veg::meta::true_type;
-
-#define VEG_DEF_CONCEPT_BOOL_CONJUNCTION_IMPL(Tpl, Name, Base, Seq)            \
-  __VEG_IMPL_DEF_CONCEPT(Tpl,                                                  \
-                         Name,                                                 \
-                         (__VEG_PP_REMOVE_PAREN1(Base)::value),                \
-                         __VEG_PP_REMOVE_PAREN1(Base));                        \
-  template<__VEG_PP_REMOVE_PAREN(Tpl)                                          \
-             __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_SFINAE, _, Seq)>               \
-  auto check_##Name() noexcept -> ::proxsuite::linalg::veg::meta::true_type
-#define VEG_DEF_CONCEPT_BOOL_DISJUNCTION_IMPL(Tpl, Name, Base, Seq)            \
-  __VEG_IMPL_DEF_CONCEPT(Tpl,                                                  \
-                         Name,                                                 \
-                         (__VEG_PP_REMOVE_PAREN1(Base)::value),                \
-                         __VEG_PP_REMOVE_PAREN1(Base));                        \
-  __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_OVERLOAD, (Name, Tpl), Seq)               \
-  VEG_NOM_SEMICOLON
-
-#define VEG_DEF_CONCEPT_CONJUNCTION(Tpl, Name, Terms)                          \
-  VEG_DEF_CONCEPT_BOOL_CONJUNCTION_IMPL(                                       \
-    Tpl,                                                                       \
-    Name,                                                                      \
-    (__VEG_IMPL_CONJUNCTION(Terms)),                                           \
-    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_ADD_VALUE, _, Terms))
-
-#define VEG_DEF_CONCEPT_DISJUNCTION(Tpl, Name, Terms)                          \
-  VEG_DEF_CONCEPT_BOOL_DISJUNCTION_IMPL(                                       \
-    Tpl,                                                                       \
-    Name,                                                                      \
-    (__VEG_IMPL_DISJUNCTION(Terms)),                                           \
-    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_ADD_VALUE, _, Terms))
-
-#define __VEG_IMPL_CONJUNCTION(Tuple)                                          \
-  ::proxsuite::linalg::veg::meta::conjunction<__VEG_PP_REMOVE_PAREN(           \
-    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PUT_TRAIT, _, Tuple))>
-#define __VEG_IMPL_DISJUNCTION(Tuple)                                          \
-  ::proxsuite::linalg::veg::meta::disjunction<__VEG_PP_REMOVE_PAREN(           \
-    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PUT_TRAIT, _, Tuple))>
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-
-#define VEG_TEMPLATE(TParams, Constraint, Attr_Name, ...)                      \
-  __VEG_IMPL_TEMPLATE(Attr_Name,                                               \
-                      TParams,                                                 \
-                      __VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint),           \
-                      __VA_ARGS__)
-
-#if VEG_HAS_CONCEPTS
-#define VEG_CONSTRAINED_MEMBER_FN(Constraint, Attr_Name, Params, ...)          \
-  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PARAM_EXPAND, _, Params)     \
-  __VA_ARGS__                                                                  \
-  requires __VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint)
-
-#define VEG_TEMPLATE_CVT(TParams, Constraint, Attr, ...)                       \
-  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
-  Constraint Attr operator __VA_ARGS__()
-#else
-#define VEG_CONSTRAINED_MEMBER_FN(Constraint, Attr_Name, Params, ...)          \
-  VEG_TEMPLATE(                                                                \
-    (int _ = 0),                                                               \
-    requires(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint) &&                  \
-             ::proxsuite::linalg::veg::meta::bool_constant<(_ == 0)>::value),  \
-    Attr_Name,                                                                 \
-    __VEG_PP_REMOVE_PAREN(Params))                                             \
-  __VA_ARGS__
-
-#define VEG_TEMPLATE_CVT(TParams, Constraint, Attr, ...)                       \
-  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
-  Attr operator ::proxsuite::linalg::veg::meta::enable_if_t<                   \
-    (__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint)),                           \
-    __VA_ARGS__>()
-#endif
-
-#if VEG_HAS_CONCEPTS && defined(__cpp_conditional_explicit) &&                 \
-  (__cpp_conditional_explicit >= 201806L)
-#define VEG_TEMPLATE_EXPLICIT(                                                 \
-  TParams, Constraint, Explicit_Cond, Attr_Name, Params, ...)                  \
-  VEG_TEMPLATE(TParams,                                                        \
-               Constraint,                                                     \
-               Explicit_Cond Attr_Name,                                        \
-               __VEG_PP_REMOVE_PAREN(Params))                                  \
-  __VA_ARGS__
-
-#define VEG_TEMPLATE_CVT_EXPLICIT(                                             \
-  TParams, Constraint, Explicit_Cond, Attr, Type, ...)                         \
-  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
-  Constraint Explicit_Cond Attr operator __VEG_PP_REMOVE_PAREN(Type)()         \
-    __VA_ARGS__
-
-#else
-#define VEG_TEMPLATE_EXPLICIT(                                                 \
-  TParams, Constraint, Explicit_Cond, Attr_Name, Params, ...)                  \
-  VEG_TEMPLATE(                                                                \
-    (__VEG_PP_REMOVE_PAREN TParams,                                            \
-     ::proxsuite::linalg::veg::meta::                                          \
-       enable_if_t<(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)), int> =  \
-         0),                                                                   \
-    Constraint,                                                                \
-    explicit Attr_Name,                                                        \
-    __VEG_PP_REMOVE_PAREN(Params))                                             \
-  __VA_ARGS__                                                                  \
-  VEG_TEMPLATE((__VEG_PP_REMOVE_PAREN TParams,                                 \
-                ::proxsuite::linalg::veg::meta::enable_if_t<                   \
-                  !(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)),         \
-                  unsigned> = 0),                                              \
-               Constraint,                                                     \
-               Attr_Name,                                                      \
-               __VEG_PP_REMOVE_PAREN(Params))                                  \
-  __VA_ARGS__
-
-#define VEG_TEMPLATE_CVT_EXPLICIT(                                             \
-  TParams, Constraint, Explicit_Cond, Attr, Type, ...)                         \
-  VEG_TEMPLATE_CVT(                                                            \
-    (__VEG_PP_REMOVE_PAREN TParams,                                            \
-     ::proxsuite::linalg::veg::meta::                                          \
-       enable_if_t<(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)), int> =  \
-         0),                                                                   \
-    Constraint,                                                                \
-    explicit Attr,                                                             \
-    __VEG_PP_REMOVE_PAREN(Type))                                               \
-  __VA_ARGS__                                                                  \
-                                                                               \
-  VEG_TEMPLATE_CVT((__VEG_PP_REMOVE_PAREN TParams,                             \
-                    ::proxsuite::linalg::veg::meta::enable_if_t<               \
-                      !(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)),     \
-                      unsigned> = 0),                                          \
-                   Constraint,                                                 \
-                   Attr,                                                       \
-                   __VEG_PP_REMOVE_PAREN(Type))                                \
-  __VA_ARGS__
-#endif
-
-#define __VEG_IMPL_PREFIX_requires
-#define __VEG_IMPL_PREFIX_explicit
-
-#define __VEG_IMPL_PARAM_EXPAND(I, _, Param)                                   \
-  __VEG_PP_TAIL Param __VEG_PP_HEAD Param
-#if VEG_HAS_CONCEPTS
-#define __VEG_IMPL_TEMPLATE(Attr_Name, TParams, Constraint, ...)               \
-  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
-    requires Constraint                                                        \
-  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(                                        \
-    __VEG_IMPL_PARAM_EXPAND, _, (__VA_ARGS__))
-#else
-
-#define __VEG_IMPL_TEMPLATE2_HELPER_0(Constraint, Param)                       \
-  __VEG_PP_TAIL Param __VEG_PP_HEAD Param
-
-#define __VEG_IMPL_TEMPLATE2_HELPER_1(Constraint, Param)                       \
-  ::proxsuite::linalg::veg::meta::enable_if_t<(Constraint),                    \
-                                              __VEG_PP_TAIL Param>             \
-    __VEG_PP_HEAD Param
-
-#define __VEG_IMPL_TEMPLATE2_HELPER(I, Constraint, Param)                      \
-  __VEG_PP_CAT2(__VEG_IMPL_TEMPLATE2_HELPER_,                                  \
-                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_INC(I)))                      \
-  (Constraint, Param)
-
-#define __VEG_IMPL_TEMPLATE(Attr_Name, TParams, Constraint, ...)               \
-  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
-  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(                                        \
-    __VEG_IMPL_TEMPLATE2_HELPER, Constraint, (__VA_ARGS__))
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-
-#if defined(VEG_WITH_CXX17_SUPPORT)
-#define VEG_INLINE_VAR(Name, Obj)                                              \
-  inline constexpr auto const& Name =                                          \
-    ::proxsuite::linalg::veg::meta::static_const<Obj>::value;                  \
-  static_assert((void(Name), true), ".")
-
-#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) /* NOLINT */                   \
-  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
-  inline constexpr auto const& Name =                                          \
-    ::proxsuite::linalg::veg::meta::static_const<__VA_ARGS__>::value;          \
-  VEG_NOM_SEMICOLON /* NOLINT */
-#else
-#define VEG_INLINE_VAR(Name, Obj)                                              \
-  namespace /* NOLINT */ {                                                     \
-  constexpr auto const& Name =                                                 \
-    ::proxsuite::linalg::veg::meta::static_const<Obj>::value;                  \
-  }                                                                            \
-  static_assert((void(Name), true), ".")
-
-#if defined(VEG_WITH_CXX14_SUPPORT)
-#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) /* NOLINT */                   \
-  namespace /* NOLINT */ {                      /* NOLINT */                   \
-  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
-  constexpr auto const& Name = /* NOLINT */                                    \
-    ::proxsuite::linalg::veg::meta::static_const<                              \
-      __VA_ARGS__>::value; /* NOLINT                                           \
-                            */                                                 \
-  }                                                                            \
-  VEG_NOM_SEMICOLON /* NOLINT */
-#else
-#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) VEG_NOM_SEMICOLON
-#endif
-#endif
-
-#define VEG_NIEBLOID(Name) VEG_INLINE_VAR(Name, nb::Name) // NOLINT
-
-#define VEG_NIEBLOID_TEMPLATE(Tpl, Name, ...)                                  \
-  VEG_INLINE_VAR_TEMPLATE(Tpl, Name, nb::Name<__VA_ARGS__>) // NOLINT
-
-#define VEG_TAG(Name, Type)                                                    \
-  namespace _ {                                                                \
-  template<int I>                                                              \
-  struct Type                                                                  \
-  {                                                                            \
-    explicit Type() = default;                                                 \
-  };                                                                           \
-  }                                                                            \
-  using Type = _::Type<0>;                                                     \
-  VEG_INLINE_VAR(Name, Type)
-
-#define VEG_TAG_TEMPLATE(Tpl, Name, Type, ...)                                 \
-  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
-  struct Type                                                                  \
-  {                                                                            \
-    explicit Type() = default;                                                 \
-  };                                                                           \
-  VEG_INLINE_VAR_TEMPLATE(Tpl, Name, Type<__VA_ARGS__>)
-
-#define VEG_FWD(X) static_cast<decltype(X)&&>(X)
-#define VEG_FWD2(X) static_cast<decltype(X)>(static_cast<decltype(X)&&>(X))
-
-// disallows moving const rvalues
-#define VEG_MOV(X)                                                             \
-  static_cast<typename ::proxsuite::linalg::veg::uncvref_t<decltype(X)>&&>(X)
-
-#ifdef VEG_NO_INSTANTIATE
-#define VEG_INSTANTIATE(Fn, ...) VEG_NOM_SEMICOLON
-#define VEG_INSTANTIATE_CLASS(Class, ...) VEG_NOM_SEMICOLON
-#else
-#define VEG_INSTANTIATE(Fn, ...)                                               \
-  __VEG_IMPL_INSTANTIATE(                                                      \
-    Fn,                                                                        \
-    __VEG_PP_CAT(__VEG_PP_CAT(_dummy_explicit_instantiation, __LINE__),        \
-                 __VEG_PP_CAT(_, __COUNTER__)),                                \
-    __VA_ARGS__)
-#define __VEG_IMPL_INSTANTIATE(Fn, Name, ...)                                  \
-  template<typename... Ts>                                                     \
-  struct Name                                                                  \
-  {                                                                            \
-    void apply(Ts&&... args)                                                   \
-    {                                                                          \
-      Fn(VEG_FWD(args)...);                                                    \
-    }                                                                          \
-  };                                                                           \
-  template struct Name<__VA_ARGS__>
-
-#define VEG_INSTANTIATE_CLASS(Class, ...) template struct Class<__VA_ARGS__>
-#endif
-
-#define VEG_NOM_SEMICOLON static_assert(true, ".")
-#define VEG_ID(id) __VEG_PP_CAT(id, __COUNTER__)
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-template<typename T>
-struct Slice;
-
-namespace meta {
-template<typename...>
-using void_t = void;
-} // namespace meta
-namespace _detail {
-template<typename T>
-struct Wrapper
-{
-  T inner;
-};
-namespace _meta {
-
-template<bool B, typename T = void>
-struct enable_if
-{
-  using type = T;
-};
-template<typename T>
-struct enable_if<false, T>
-{};
-
-template<typename U, typename V>
-using discard_1st = V;
-
-template<typename T>
-struct uncvlref;
-template<typename T>
-struct uncvlref<T&>
-{
-  using type = T;
-};
-template<typename T>
-struct uncvlref<T const&>
-{
-  using type = T;
-};
-template<typename T>
-struct uncvlref<T volatile&>
-{
-  using type = T;
-};
-template<typename T>
-struct uncvlref<T volatile const&>
-{
-  using type = T;
-};
-
-template<typename T>
-struct unref;
-template<typename T>
-struct unref<T&>
-{
-  using type = T;
-};
-
-template<typename T>
-auto
-declval() VEG_ALWAYS_NOEXCEPT->T;
-} // namespace _meta
-} // namespace _detail
-
-namespace meta {
-template<typename T>
-struct static_const
-{
-  static constexpr T value{};
-};
-
-template<typename T>
-constexpr T static_const<T>::value; // NOLINT(readability-redundant-declaration)
-} // namespace meta
-
-template<typename... Ts>
-struct incomplete_t;
-
-template<typename... Types, typename... Args>
-auto
-print_types_halt(Args&&...) -> incomplete_t<Types..., Args...>;
-template<typename... Types, typename... Args>
-VEG_DEPRECATED("")
-VEG_CPP14(constexpr) void print_types(Args&&... /*unused*/)
-{
-}
-
-namespace nb {
-struct unused
-{
-  template<typename... Ts>
-  VEG_CPP14(constexpr)
-  void operator()(Ts const&... /*unused*/) const VEG_NOEXCEPT
-  {
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(unused);
-
-using usize = decltype(sizeof(0));
-namespace _detail {
-
-template<isize I>
-struct EmptyI
-{};
-
-using Empty = EmptyI<0>;
-using EmptyArr = Empty[];
-namespace _meta {
-
-template<typename T, T... Nums>
-struct integer_sequence;
-
-#if VEG_HAS_BUILTIN(__make_integer_seq)
-
-template<typename T, T N>
-using make_integer_sequence = __make_integer_seq<integer_sequence, T, N>;
-
-#elif __GNUC__ >= 8
-
-template<typename T, T N>
-using make_integer_sequence = integer_sequence<T, __integer_pack(N)...>;
-
-#else
-
-namespace _detail {
-
-template<typename Seq1, typename Seq2>
-struct _merge;
-
-template<typename Seq1, typename Seq2>
-struct _merge_p1;
-
-template<typename T, T... Nums1, T... Nums2>
-struct _merge<integer_sequence<T, Nums1...>, integer_sequence<T, Nums2...>>
-{
-  using type = integer_sequence<T, Nums1..., (sizeof...(Nums1) + Nums2)...>;
-};
-
-template<typename T, T... Nums1, T... Nums2>
-struct _merge_p1<integer_sequence<T, Nums1...>, integer_sequence<T, Nums2...>>
-{
-  using type = integer_sequence<T,
-                                Nums1...,
-                                (sizeof...(Nums1) + Nums2)...,
-                                sizeof...(Nums1) + sizeof...(Nums2)>;
-};
-
-template<typename T, usize N, bool Even = (N % 2) == 0>
-struct _make_integer_sequence
-{
-  using type =
-    typename _merge<typename _make_integer_sequence<T, N / 2>::type,
-                    typename _make_integer_sequence<T, N / 2>::type>::type;
-};
-
-template<typename T, usize N>
-struct _make_integer_sequence<T, N, false>
-{
-  using type =
-    typename _merge_p1<typename _make_integer_sequence<T, N / 2>::type,
-                       typename _make_integer_sequence<T, N / 2>::type>::type;
-};
-
-template<typename T>
-struct _make_integer_sequence<T, 0>
-{
-  using type = integer_sequence<T>;
-};
-template<typename T>
-struct _make_integer_sequence<T, 1>
-{
-  using type = integer_sequence<T, 0>;
-};
-
-} // namespace _detail
-
-template<typename T, T N>
-using make_integer_sequence =
-  typename _detail::_make_integer_sequence<T, N>::type;
-
-#endif
-
-#define VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(Tpl, Name, ...)                    \
-  VEG_DEF_CONCEPT(                                                             \
-    Tpl,                                                                       \
-    Name,                                                                      \
-    VEG_HAS_BUILTIN_OR(__is_##Name,                                            \
-                       __is_##Name(__VA_ARGS__),                               \
-                       (_detail::_meta::is_##Name<__VA_ARGS__>::value)))
-
-template<usize N>
-using make_index_sequence = make_integer_sequence<usize, N>;
-
-template<typename... Ts>
-struct type_sequence;
-
-} // namespace _meta
-
-template<usize I, typename T>
-struct SimpleLeaf
-{
-  T inner;
-};
-
-template<typename Seq, typename... Ts>
-struct SimpleITuple;
-
-template<usize... Is, typename... Ts>
-struct SimpleITuple<_meta::integer_sequence<usize, Is...>, Ts...>
-  : SimpleLeaf<Is, Ts>...
-{
-#if !defined(VEG_WITH_CXX17_SUPPORT)
-  constexpr SimpleITuple(Ts... args) noexcept
-    : SimpleLeaf<Is, Ts>{ Ts(VEG_FWD(args)) }...
-  {
-  }
-#endif
-};
-
-template<typename... Ts>
-using SimpleTuple =
-  SimpleITuple<_meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
-
-template<typename... Ts>
-constexpr auto
-make_simple_tuple(Empty /*dummy*/, Ts... args) noexcept -> SimpleTuple<Ts...>
-{
-#if !defined(VEG_WITH_CXX17_SUPPORT)
-  return { Ts(VEG_FWD(args))... };
-#else
-  return { { Ts(VEG_FWD(args)) }... };
-#endif
-}
-
-template<typename T>
-struct mem_ptr_type;
-template<typename C, typename Mem>
-struct mem_ptr_type<Mem C::*>
-{
-  using Type = Mem;
-};
-
-constexpr auto
-all_of_slice(bool const* arr, usize size) VEG_NOEXCEPT->bool
-{
-  return size == 0 ? true
-                   : (arr[0] && _detail::all_of_slice(arr + 1, size - 1));
-}
-template<usize N>
-inline constexpr auto
-all_of(bool const (&lst)[N]) VEG_NOEXCEPT->bool
-{
-  return _detail::all_of_slice(lst, N);
-}
-
-template<typename T>
-struct member_extract_access
-{
-  template<typename U, typename = U>
-  struct DetectImpl
-  {
-    static constexpr bool value = false;
-    using Type = void;
-  };
-  template<typename U>
-  struct DetectImpl<U, typename U::_veglib_impl_member_extract::Type>
-  {
-    static constexpr bool value = true;
-    using Type = typename U::_veglib_impl_member_extract;
-  };
-
-  using Detect = DetectImpl<T>;
-  static constexpr bool value = Detect::value;
-  using Type = typename Detect::Type;
-};
-} // namespace _detail
-namespace meta {
-template<bool B, typename T = void>
-using enable_if_t =
-  _detail::_meta::discard_1st<typename _detail::_meta::enable_if<B, void>::type,
-                              T>;
-
-template<typename T>
-using uncvref_t = typename _detail::_meta::uncvlref<T&>::type;
-} // namespace meta
-using meta::uncvref_t;
-
-namespace meta {
-template<typename T, T Value>
-struct constant
-{
-  static constexpr T value = Value;
-};
-template<typename T, T Value>
-constexpr T constant<T, Value>::value;
-template<bool B>
-using bool_constant = constant<bool, B>;
-
-using true_type = bool_constant<true>;
-using false_type = bool_constant<false>;
-} // namespace meta
-namespace _detail {
-namespace _meta {
-
-struct wrapper_base
-{
-  static auto test(...) -> meta::false_type;
-};
-template<typename T>
-struct wrapper : wrapper_base
-{
-  using wrapper_base::test;
-  static auto test(wrapper<T>*) -> meta::true_type;
-};
-template<typename T, typename U>
-using is_same = decltype(wrapper<T>::test(static_cast<wrapper<U>*>(nullptr)));
-} // namespace _meta
-} // namespace _detail
-namespace concepts {
-VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL((typename T, typename U), same, T, U);
-} // namespace concepts
-
-enum struct CharUnit : unsigned char
-{
-  SPACE = 0x20,
-  EXCLAMATION_MARK = 0x21,
-  DOUBLE_QUOTE = 0x22,
-  NUMBER = 0x23,
-  DOLLAR = 0x24,
-  PERCENT = 0x25,
-  AMPERSAND = 0x26,
-  SINGLE_QUOTE = 0x27,
-  LEFT_PARENTHESIS = 0x28,
-  RIGHT_PARENTHESIS = 0x29,
-  ASTERISK = 0x2A,
-  PLUS = 0x2B,
-  COMMA = 0x2C,
-  MINUS = 0x2D,
-  PERIOD = 0x2E,
-  SLASH = 0x2F,
-  ZERO = 0x30,
-  ONE = 0x31,
-  TWO = 0x32,
-  THREE = 0x33,
-  FOUR = 0x34,
-  FIVE = 0x35,
-  SIX = 0x36,
-  SEVEN = 0x37,
-  EIGHT = 0x38,
-  NINE = 0x39,
-  COLON = 0x3A,
-  SEMICOLON = 0x3B,
-  LESS_THAN = 0x3C,
-  EQUALITY_SIGN = 0x3D,
-  GREATER_THAN = 0x3E,
-  QUESTION_MARK = 0x3F,
-  AT_SIGN = 0x40,
-  UPPERCASE_A = 0x41,
-  UPPERCASE_B = 0x42,
-  UPPERCASE_C = 0x43,
-  UPPERCASE_D = 0x44,
-  UPPERCASE_E = 0x45,
-  UPPERCASE_F = 0x46,
-  UPPERCASE_G = 0x47,
-  UPPERCASE_H = 0x48,
-  UPPERCASE_I = 0x49,
-  UPPERCASE_J = 0x4A,
-  UPPERCASE_K = 0x4B,
-  UPPERCASE_L = 0x4C,
-  UPPERCASE_M = 0x4D,
-  UPPERCASE_N = 0x4E,
-  UPPERCASE_O = 0x4F,
-  UPPERCASE_P = 0x50,
-  UPPERCASE_Q = 0x51,
-  UPPERCASE_R = 0x52,
-  UPPERCASE_S = 0x53,
-  UPPERCASE_T = 0x54,
-  UPPERCASE_U = 0x55,
-  UPPERCASE_V = 0x56,
-  UPPERCASE_W = 0x57,
-  UPPERCASE_X = 0x58,
-  UPPERCASE_Y = 0x59,
-  UPPERCASE_Z = 0x5A,
-  LEFT_SQUARE_BRACKET = 0x5B,
-  BACKSLASH = 0x5C,
-  RIGHT_SQUARE_BRACKET = 0x5D,
-  CARET = 0x5F,
-  GRAVE = 0x60,
-  LOWERCASE_A = 0x61,
-  LOWERCASE_B = 0x62,
-  LOWERCASE_C = 0x63,
-  LOWERCASE_D = 0x64,
-  LOWERCASE_E = 0x65,
-  LOWERCASE_F = 0x66,
-  LOWERCASE_G = 0x67,
-  LOWERCASE_H = 0x68,
-  LOWERCASE_I = 0x69,
-  LOWERCASE_J = 0x6A,
-  LOWERCASE_K = 0x6B,
-  LOWERCASE_L = 0x6C,
-  LOWERCASE_M = 0x6D,
-  LOWERCASE_N = 0x6E,
-  LOWERCASE_O = 0x6F,
-  LOWERCASE_P = 0x70,
-  LOWERCASE_Q = 0x71,
-  LOWERCASE_R = 0x72,
-  LOWERCASE_S = 0x73,
-  LOWERCASE_T = 0x74,
-  LOWERCASE_U = 0x75,
-  LOWERCASE_V = 0x76,
-  LOWERCASE_W = 0x77,
-  LOWERCASE_X = 0x78,
-  LOWERCASE_Y = 0x79,
-  LOWERCASE_Z = 0x7A,
-  LEFT_CURLY_BRACKET = 0x7B,
-  VERTICAL_BAR = 0x7C,
-  RIGHT_CURLY_BRACKET = 0x7D,
-  TILDE = 0x7E,
-};
-
-inline namespace tags {
-VEG_TAG(from_raw_parts, FromRawParts);
-
-VEG_TAG(safe, Safe);
-VEG_TAG(unsafe, Unsafe);
-} // namespace tags
-
-struct Str
-{
-private:
-  struct
-  {
-    CharUnit const* ptr;
-    isize len;
-  } _ = {};
-
-public:
-  VEG_INLINE constexpr Str(Unsafe /*unsafe*/,
-                           FromRawParts /*from_raw_parts*/,
-                           CharUnit const* ptr,
-                           isize len) noexcept
-    : _{ ptr, len } {};
-  VEG_INLINE constexpr auto as_slice() const noexcept -> Slice<CharUnit>;
-};
-
-template<CharUnit... Cs>
-struct StrLiteralConstant
-{
-private:
-  static constexpr CharUnit literal[sizeof...(Cs)] = { Cs... };
-
-public:
-  VEG_INLINE constexpr auto as_slice() const noexcept -> Slice<CharUnit>;
-  VEG_INLINE constexpr auto as_str() const noexcept -> Str
-  {
-    return { unsafe, from_raw_parts, literal, isize{ sizeof...(Cs) } };
-  }
-};
-
-template<CharUnit... Cs>
-constexpr CharUnit StrLiteralConstant<Cs...>::literal[sizeof...(Cs)];
-
-namespace _detail {
-using NativeChar8 = meta::uncvref_t<decltype(u8""[0])>;
-
-template<typename T, usize N>
-struct Array_
-{
-  T _[N];
-};
-template<typename T>
-constexpr auto
-assert_complete() noexcept -> bool
-{
-  static_assert(sizeof(T) != 0, ".");
-  return true;
-}
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#if defined(__clang__) || (defined(VEG_WITH_CXX14_SUPPORT) && defined(__GNUC__))
-HEDLEY_DIAGNOSTIC_PUSH
-#pragma GCC diagnostic ignored "-Wpedantic"
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
-#endif
-
-template<typename Char,
-         Char... Cs>
-constexpr auto operator""__veglib_const_literal_gnuc() noexcept // NOLINT
-  -> proxsuite::linalg::veg::StrLiteralConstant<
-    proxsuite::linalg::veg::CharUnit(Cs)...>
-{
-  return {};
-}
-
-HEDLEY_DIAGNOSTIC_POP
-
-#define __VEG_IMPL_UTF8_CONST(Literal) /* NOLINT */                            \
-  (u8##Literal##__veglib_const_literal_gnuc)
-
-#elif (defined(__clang__) && defined(VEG_WITH_CXX20_SUPPORT)) ||               \
-  (defined(__cpp_nontype_template_args) &&                                     \
-   (__cpp_nontype_template_args >= 201911L))
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-template<isize N>
-struct StrLiteralImpl
-{
-  proxsuite::linalg::veg::CharUnit _[N];
-
-  template<typename Char>
-  constexpr StrLiteralImpl(Char const* s)
-  {
-    for (isize i = 0; i < N; ++i) {
-      _[i] = proxsuite::linalg::veg::CharUnit(s[i]);
-    }
-  }
-};
-template<typename Char, isize N>
-StrLiteralImpl(Char const (&)[N]) -> StrLiteralImpl<N - 1>;
-
-template<typename T>
-struct StrLiteralLen;
-
-template<isize N>
-struct StrLiteralLen<StrLiteralImpl<N>>
-{
-  static constexpr usize value{ N };
-};
-template<isize N>
-struct StrLiteralLen<StrLiteralImpl<N> const>
-{
-  static constexpr usize value{ N };
-};
-
-template<typename Seq, auto Literal>
-struct StrLiteralExpand;
-
-template<usize... Is, StrLiteralImpl<static_cast<isize>(sizeof...(Is))> L>
-struct StrLiteralExpand<_meta::integer_sequence<usize, Is...>, L>
-{
-  using Type = StrLiteralConstant<L._[Is]...>;
-};
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-template<proxsuite::linalg::veg::_detail::StrLiteralImpl S>
-constexpr auto operator""__veglib_const_literal_cpp20() noexcept ->
-  typename proxsuite::linalg::veg::_detail::StrLiteralExpand< //
-    proxsuite::linalg::veg::_detail::_meta::make_index_sequence<
-      proxsuite::linalg::veg::_detail::StrLiteralLen<decltype(S)>::value>,
-    S>::Type
-{
-  return {};
-}
-#define __VEG_IMPL_UTF8_CONST(Literal)                                         \
-  (u8##Literal##__veglib_const_literal_cpp20)
-
-#else
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-
-template<typename LiteralType, typename Seq>
-struct ExtractCharsImpl;
-
-template<typename LiteralType, usize... Is>
-struct ExtractCharsImpl<LiteralType, _meta::integer_sequence<usize, Is...>>
-{
-  using Type = StrLiteralConstant<CharUnit(LiteralType::value[Is])...>;
-};
-
-template<typename LiteralType, typename Seq>
-struct ExtractCharsImplExpr;
-
-template<typename LiteralType, usize... Is>
-struct ExtractCharsImplExpr<LiteralType, _meta::integer_sequence<usize, Is...>>
-{
-  using Type = StrLiteralConstant<CharUnit(LiteralType::value()[Is])...>;
-};
-
-template<typename LiteralType>
-auto
-extract_chars(LiteralType /*unused*/) -> typename ExtractCharsImpl<
-  LiteralType,
-  _meta::make_index_sequence<LiteralType::Size::value>>::Type
-{
-  return {};
-}
-
-template<typename LiteralType>
-auto
-extract_chars_expr(LiteralType /*unused*/) -> typename ExtractCharsImplExpr<
-  LiteralType,
-  _meta::make_index_sequence<LiteralType::Size::value>>::Type
-{
-  return {};
-}
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#define __VEG_IMPL_UTF8_CONST(Literal)                                         \
-  (::proxsuite::linalg::veg::_detail::extract_chars_expr(                      \
-    []() /* NOLINT */ noexcept {                                               \
-      struct __VEG_PP_CAT(_veglib_type, __LINE__)                              \
-      {                                                                        \
-        static constexpr auto value() noexcept -> decltype(Literal)            \
-        {                                                                      \
-          return Literal;                                                      \
-        }                                                                      \
-        using Size = ::proxsuite::linalg::veg::meta::constant<                 \
-          ::proxsuite::linalg::veg::usize,                                     \
-          sizeof(value()) / sizeof(value()[0]) - 1>;                           \
-      };                                                                       \
-      return __VEG_PP_CAT(_veglib_type, __LINE__){};                           \
-    }()))
-#endif
-
-#define VEG_DECLTYPE_VOID(...) decltype(void(__VA_ARGS__))
-#define VEG_BOOL_NOEXCEPT(...)                                                 \
-  ::proxsuite::linalg::veg::meta::bool_constant<noexcept(__VA_ARGS__)>
-
-#define VEG_CHECK_CONCEPT(...)                                                 \
-  VEG_CHECK_CONCEPT_MACRO(::proxsuite::linalg::veg::concepts, __VA_ARGS__)
-#define VEG_CONCEPT(...)                                                       \
-  VEG_CONCEPT_MACRO(::proxsuite::linalg::veg::concepts, __VA_ARGS__)
-
-#define __VEG_IMPL_GET_MEMBER_PTR(_, MemberPtr) /* NOLINT */ , &Type::MemberPtr
-#define __VEG_IMPL_GET_MEMBER_NAME_PTR(_, MemberPtr) /* NOLINT */              \
-  static_cast<::proxsuite::linalg::veg::_detail::NativeChar8 const*>(          \
-    __VEG_PP_CAT(u8, __VEG_PP_STRINGIZE(MemberPtr))),
-#define __VEG_IMPL_GET_MEMBER_NAME_LEN(_, MemberPtr) /* NOLINT */              \
-  (sizeof(__VEG_PP_CAT(u8, __VEG_PP_STRINGIZE(MemberPtr))) - 1),
-
-#define __VEG_IMPL_STRUCT_SETUP(PClass, ...) /* NOLINT */                      \
-  void _veg_lib_name_test()&& noexcept                                         \
-  {                                                                            \
-    static_assert(                                                             \
-      VEG_CONCEPT(same<decltype(this), __VEG_PP_REMOVE_PAREN(PClass)*>),       \
-      "struct mismatch in VEG_REFLECT");                                       \
-  }                                                                            \
-  struct _veglib_impl_member_extract                                           \
-  {                                                                            \
-    using Type = __VEG_PP_REMOVE_PAREN(PClass);                                \
-    using MemberTuple =                                                        \
-      decltype(::proxsuite::linalg::veg::_detail::make_simple_tuple(           \
-        ::proxsuite::linalg::veg::_detail::Empty {                             \
-        } __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_GET_MEMBER_PTR,                   \
-                                  _,                                           \
-                                  (__VA_ARGS__))));                            \
-    static constexpr auto member_pointers() noexcept -> MemberTuple            \
-    {                                                                          \
-      return ::proxsuite::linalg::veg::_detail::make_simple_tuple(             \
-        ::proxsuite::linalg::veg::_detail::Empty {} __VEG_PP_TUPLE_FOR_EACH(   \
-          __VEG_IMPL_GET_MEMBER_PTR, _, (__VA_ARGS__)));                       \
-    }                                                                          \
-    static constexpr auto class_name_ptr() noexcept                            \
-      -> ::proxsuite::linalg::veg::_detail::NativeChar8 const*                 \
-    {                                                                          \
-      return __VEG_PP_CAT(u8,                                                  \
-                          __VEG_PP_STRINGIZE(__VEG_PP_REMOVE_PAREN(PClass)));  \
-    }                                                                          \
-    static constexpr auto class_name_len() noexcept                            \
-      -> ::proxsuite::linalg::veg::usize                                       \
-    {                                                                          \
-      return sizeof(__VEG_PP_CAT(                                              \
-               u8, __VEG_PP_STRINGIZE(__VEG_PP_REMOVE_PAREN(PClass)))) -       \
-             1;                                                                \
-    }                                                                          \
-    static constexpr auto member_name_ptrs() noexcept                          \
-      -> ::proxsuite::linalg::veg::_detail::Array_<                            \
-        ::proxsuite::linalg::veg::_detail::NativeChar8 const*,                 \
-        __VEG_PP_TUPLE_SIZE((__VA_ARGS__))>                                    \
-    {                                                                          \
-      return { { __VEG_PP_TUPLE_FOR_EACH(                                      \
-        __VEG_IMPL_GET_MEMBER_NAME_PTR, _, (__VA_ARGS__)) } };                 \
-    }                                                                          \
-    static constexpr auto member_name_lens() noexcept                          \
-      -> ::proxsuite::linalg::veg::_detail::Array_<                            \
-        ::proxsuite::linalg::veg::usize,                                       \
-        __VEG_PP_TUPLE_SIZE((__VA_ARGS__))>                                    \
-    {                                                                          \
-      return { { __VEG_PP_TUPLE_FOR_EACH(                                      \
-        __VEG_IMPL_GET_MEMBER_NAME_LEN, _, (__VA_ARGS__)) } };                 \
-    }                                                                          \
-  };                                                                           \
-  friend struct ::proxsuite::linalg::veg::_detail::member_extract_access<      \
-    __VEG_PP_REMOVE_PAREN(PClass)>;                                            \
-  VEG_NOM_SEMICOLON
-
-#define VEG_REFLECT(PClass, ...) __VEG_IMPL_STRUCT_SETUP(PClass, __VA_ARGS__)
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_MACROS_HPP_HSTLSKZXS */
+#ifndef VEG_MACROS_HPP_HSTLSKZXS
+#define VEG_MACROS_HPP_HSTLSKZXS
+#include "proxsuite/linalg/veg/internal/external/hedley.ext.hpp"
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/internal/preprocessor.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <initializer_list>
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if _MSC_VER
+#define PROXSUITE_PRETTY_FUNCTION __FUNCSIG__
+#else
+#define PROXSUITE_PRETTY_FUNCTION __PRETTY_FUNCTION__
+#endif
+
+#define PROXSUITE_THROW_PRETTY(condition, exception, message)                  \
+  if (condition) {                                                             \
+    std::ostringstream ss;                                                     \
+    ss << "From file: " << __FILE__ << "\n";                                   \
+    ss << "in function: " << PROXSUITE_PRETTY_FUNCTION << "\n";                \
+    ss << "at line: " << __LINE__ << "\n";                                     \
+    ss << message << "\n";                                                     \
+    throw exception(ss.str());                                                 \
+  }
+
+#define PROXSUITE_CHECK_ARGUMENT_SIZE(size, expected_size, message)            \
+  if (size != expected_size) {                                                 \
+    std::ostringstream oss;                                                    \
+    oss << "wrong argument size: expected " << expected_size << ", got "       \
+        << size << "\n";                                                       \
+    oss << "hint: " << message << std::endl;                                   \
+    PROXSUITE_THROW_PRETTY(true, std::invalid_argument, oss.str());            \
+  }
+
+#if HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                     \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define VEG_DEPRECATED(Reason) __declspec(deprecated(Reason))
+#elif HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) ||               \
+  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_ARM_VERSION_CHECK(5, 6, 0) ||                                         \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) ||                                     \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) || HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||  \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(18, 1, 0) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
+#define VEG_DEPRECATED(Reason) __attribute__((__deprecated__(Reason)))
+#elif defined(VEG_WITH_CXX14_SUPPORT)
+#define VEG_DEPRECATED(Reason)                                                 \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated(Reason)]])
+#elif HEDLEY_HAS_ATTRIBUTE(deprecated) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) || \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||   \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define VEG_DEPRECATED(Reason) __attribute__((__deprecated__))
+#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
+  HEDLEY_PELLES_VERSION_CHECK(6, 50, 0) ||                                     \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define VEG_DEPRECATED(Reason) __declspec(deprecated)
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define VEG_DEPRECATED(Reason) _Pragma("deprecated")
+#else
+#define VEG_DEPRECATED(Reason)
+#endif
+
+/// \brief Helper to declare that a parameter is unused
+#define VEG_UNUSED_VARIABLE(var) (void)(var)
+#ifdef NDEBUG
+#define VEG_ONLY_USED_FOR_DEBUG(var) VEG_UNUSED_VARIABLE(var)
+#else
+#define VEG_ONLY_USED_FOR_DEBUG(var)
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if defined(__clang__)
+#define VEG_WRAP_SILENCE_WARNING(...)                                          \
+  HEDLEY_DIAGNOSTIC_PUSH _Pragma(                                              \
+    "clang diagnostic ignored \"-Wc++17-extensions\"")                         \
+    __VA_ARGS__ HEDLEY_DIAGNOSTIC_POP
+#else
+#define VEG_WRAP_SILENCE_WARNING(...) __VA_ARGS__
+#endif
+
+#ifndef VEG_HAS_NO_UNIQUE_ADDRESS
+#define VEG_HAS_NO_UNIQUE_ADDRESS 0
+#endif
+
+#if VEG_HAS_NO_UNIQUE_ADDRESS
+#ifdef _MSC_VER
+#define VEG_NO_UNIQUE_ADDRESS [[msvc::no_unique_address]]
+#else
+#define VEG_NO_UNIQUE_ADDRESS [[no_unique_address]]
+#endif
+#else
+#define VEG_NO_UNIQUE_ADDRESS
+#endif
+
+#ifndef VEG_INLINE
+
+#if defined(NDEBUG) || defined(__OPTIMIZE__)
+#define VEG_INLINE HEDLEY_ALWAYS_INLINE
+#else
+#define VEG_INLINE inline
+#endif
+
+#endif
+
+#define VEG_NO_INLINE HEDLEY_NEVER_INLINE
+
+#if defined(__cpp_concepts) && __cpp_concepts >= 201907L
+#define VEG_HAS_CONCEPTS 1
+#else
+#define VEG_HAS_CONCEPTS 0
+#endif
+
+#if defined(VEG_WITH_CXX17_SUPPORT)
+#define VEG_DECLVAL(...) (static_cast<__VA_ARGS__ (*)() noexcept>(nullptr)())
+#else
+#define VEG_DECLVAL(...)                                                       \
+  (::proxsuite::linalg::veg::_detail::_meta::declval<__VA_ARGS__>())
+#endif
+
+#if defined(__clang__)
+#define VEG_ARROW(...)                                                         \
+  __attribute__((always_inline)) noexcept(noexcept((__VA_ARGS__)))             \
+    ->decltype((__VA_ARGS__))                                                  \
+  {                                                                            \
+    return __VA_ARGS__;                                                        \
+  }
+#elif defined(__GNUC__) && (__GNUC__ >= 9)
+#define VEG_ARROW(...)                                                         \
+  noexcept(noexcept((__VA_ARGS__))) __attribute__((always_inline))             \
+    ->decltype((__VA_ARGS__))                                                  \
+  {                                                                            \
+    return __VA_ARGS__;                                                        \
+  }
+#else
+#define VEG_ARROW(...)                                                         \
+  noexcept(noexcept((__VA_ARGS__)))->decltype((__VA_ARGS__))                   \
+  {                                                                            \
+    return __VA_ARGS__;                                                        \
+  }
+#endif
+
+#define VEG_LAZY_BY_REF(...) [&]() VEG_ARROW(__VA_ARGS__)
+
+#define VEG_LIFT(...)                                                          \
+  [&](auto&&... args) VEG_ARROW((__VA_ARGS__)(VEG_FWD(args)...))
+
+#define VEG_DEDUCE_RET(...)                                                    \
+  noexcept(noexcept(__VA_ARGS__))->decltype(__VA_ARGS__)                       \
+  {                                                                            \
+    return __VA_ARGS__;                                                        \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+
+#if defined(VEG_WITH_CXX17_SUPPORT)
+#define VEG_HAS_FOLD_EXPR 1
+#define VEG_ALL_OF(...) (__VA_ARGS__ && ... && true)
+#define VEG_ANY_OF(...) (__VA_ARGS__ || ... || false)
+#elif defined(__clang__)
+#define VEG_HAS_FOLD_EXPR 1
+#define VEG_ALL_OF(...) VEG_WRAP_SILENCE_WARNING((__VA_ARGS__ && ... && true))
+#define VEG_ANY_OF(...) VEG_WRAP_SILENCE_WARNING((__VA_ARGS__ || ... || false))
+#else
+#define VEG_HAS_FOLD_EXPR 0
+#define VEG_ALL_OF(...)                                                        \
+  ::proxsuite::linalg::veg::meta::and_test<                                    \
+    ::proxsuite::linalg::veg::meta::make_index_sequence<                       \
+      ::proxsuite::linalg::veg::meta::pack_size<decltype((                     \
+        void)(__VA_ARGS__))...>::value>,                                       \
+    ::proxsuite::linalg::veg::meta::bool_constant<(__VA_ARGS__)>...>::value
+#define VEG_ANY_OF(...)                                                        \
+  ::proxsuite::linalg::veg::meta::or_test<                                     \
+    ::proxsuite::linalg::veg::meta::make_index_sequence<                       \
+      ::proxsuite::linalg::veg::meta::pack_size<decltype((                     \
+        void)(__VA_ARGS__))...>::value>,                                       \
+    ::proxsuite::linalg::veg::meta::bool_constant<(__VA_ARGS__)>...>::value
+#endif
+
+#define VEG_EVAL_ALL(...)                                                      \
+  ((void)(::proxsuite::linalg::veg::_detail::EmptyArr{                         \
+    ::proxsuite::linalg::veg::_detail::Empty{},                                \
+    ((void)(__VA_ARGS__), ::proxsuite::linalg::veg::_detail::Empty{})... }))
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if VEG_HAS_CONCEPTS
+
+#define __VEG_IMPL_AND(_, Param) &&__VEG_PP_UNWRAP(Param)
+#define __VEG_IMPL_OR(_, Param) || __VEG_PP_UNWRAP(Param)
+
+#define __VEG_IMPL_CONJUNCTION(First, ...)                                     \
+  (__VEG_PP_UNWRAP(First)                                                      \
+     __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_AND, _, (__VA_ARGS__)))
+
+#define __VEG_IMPL_DISJUNCTION(First, ...)                                     \
+  (__VEG_PP_UNWRAP(First)                                                      \
+     __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_OR, _, (__VA_ARGS__)))
+
+#define VEG_DEF_CONCEPT(Tpl, Name, ...)                                        \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  concept Name = __VA_ARGS__;                                                  \
+  VEG_NOM_SEMICOLON
+
+#define VEG_CHECK_CONCEPT_MACRO(Namespace, ...)                                \
+  static_assert(Namespace::__VA_ARGS__,                                        \
+                __VEG_PP_STRINGIZE(__VA_ARGS__) " failed")
+#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__
+
+#define VEG_DEF_CONCEPT_CONJUNCTION(Tpl, Name, Terms)                          \
+  VEG_DEF_CONCEPT(Tpl, Name, __VEG_IMPL_CONJUNCTION Terms)
+#define VEG_DEF_CONCEPT_DISJUNCTION(Tpl, Name, Terms)                          \
+  VEG_DEF_CONCEPT(Tpl, Name, __VEG_IMPL_DISJUNCTION Terms)
+
+#define VEG_CONCEPT_EXPR(Tpl, TplNames, Name, Expr, ...)                       \
+  namespace _veg_detail {                                                      \
+  template<typename ExprType, __VEG_PP_REMOVE_PAREN1(Tpl)>                     \
+  concept test_return_##Name = __VA_ARGS__;                                    \
+  }                                                                            \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  concept Name =                                                               \
+    _veg_detail::test_return_##Name<decltype((Expr)),                          \
+                                    __VEG_PP_REMOVE_PAREN1(TplNames)>;         \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  concept xnothrow_##Name = noexcept(Expr);                                    \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  concept nothrow_##Name = noexcept(Expr);                                     \
+  VEG_NOM_SEMICOLON
+
+#else
+
+#if defined(VEG_WITH_CXX14_SUPPORT)
+#define __VEG_IMPL_DEF_CONCEPT(Tpl, Name, Value, ...)                          \
+  namespace _ {                                                                \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  struct Name : __VA_ARGS__                                                    \
+  {};                                                                          \
+  }                                                                            \
+  namespace {                                                                  \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  constexpr bool const& Name =                                                 \
+    ::proxsuite::linalg::veg::meta::bool_constant<Value>::value;               \
+  }                                                                            \
+  VEG_NOM_SEMICOLON
+#else
+#define __VEG_IMPL_DEF_CONCEPT(Tpl, Name, Value, ...)                          \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  struct Name : __VA_ARGS__                                                    \
+  {}
+#endif
+
+#ifdef __clang__
+#define __VEG_NO_WARNING_PRAGMA_PUSH                                           \
+  HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic ignored \"-Wconversion\"")
+#define __VEG_NO_WARNING_PRAGMA_POP HEDLEY_DIAGNOSTIC_POP
+#else
+#define __VEG_NO_WARNING_PRAGMA_PUSH
+#define __VEG_NO_WARNING_PRAGMA_POP
+#endif
+
+#define VEG_CONCEPT_EXPR(Tpl, TplNames, Name, Expr, ...)                       \
+  namespace _veg_detail {                                                      \
+  template<typename _veg_Enable, __VEG_PP_REMOVE_PAREN1(Tpl)>                  \
+  struct test_sfinae_##Name                                                    \
+  {                                                                            \
+    using TestExpr = ::proxsuite::linalg::veg::meta::false_type;               \
+    using NothrowTestExpr = ::proxsuite::linalg::veg::meta::false_type;        \
+  };                                                                           \
+  template<__VEG_PP_REMOVE_PAREN1(Tpl)>                                        \
+  struct test_sfinae_##Name<                                                   \
+    ::proxsuite::linalg::veg::meta::void_t<decltype((Expr))>,                  \
+    __VEG_PP_REMOVE_PAREN1(TplNames)>                                          \
+  {                                                                            \
+    using ExprType = decltype((Expr));                                         \
+    using TestExpr =                                                           \
+      ::proxsuite::linalg::veg::meta::bool_constant<__VA_ARGS__>;              \
+    using NothrowTestExpr = ::proxsuite::linalg::veg::meta::bool_constant<     \
+      (TestExpr::value) && __VEG_NO_WARNING_PRAGMA_PUSH noexcept(Expr)         \
+                             __VEG_NO_WARNING_PRAGMA_POP>;                     \
+  };                                                                           \
+  }                                                                            \
+  VEG_DEF_CONCEPT(                                                             \
+    Tpl,                                                                       \
+    Name,                                                                      \
+    _veg_detail::test_sfinae_##Name<void, __VEG_PP_REMOVE_PAREN1(TplNames)>::  \
+      TestExpr::value);                                                        \
+  VEG_DEF_CONCEPT(Tpl, nothrow_##Name, noexcept(Expr));                        \
+  VEG_DEF_CONCEPT(                                                             \
+    Tpl,                                                                       \
+    xnothrow_##Name,                                                           \
+    _veg_detail::test_sfinae_##Name<void, __VEG_PP_REMOVE_PAREN1(TplNames)>::  \
+      NothrowTestExpr::value);                                                 \
+  VEG_NOM_SEMICOLON
+
+#if defined(VEG_WITH_CXX14_SUPPORT)
+#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__
+#define __VEG_IMPL_ADD_VALUE(I, _, Param) (Param)
+#define __VEG_IMPL_TRAIT(Param) __VEG_PP_HEAD Param _::__VEG_PP_TAIL Param
+#else
+#define VEG_CONCEPT_MACRO(Namespace, ...) Namespace::__VA_ARGS__::value
+#define __VEG_IMPL_ADD_VALUE(I, _, Param)                                      \
+  ((__VEG_PP_REMOVE_PAREN(Param)::value))
+#define __VEG_IMPL_TRAIT(Param) __VEG_PP_UNWRAP(Param)
+#endif
+#define __VEG_IMPL_PUT_TRAIT(I, _, Param) __VEG_IMPL_TRAIT(Param)
+
+#define VEG_CHECK_CONCEPT_MACRO(Namespace, ...)                                \
+  static_assert(decltype(Namespace::check_##__VA_ARGS__())::value,             \
+                __VEG_PP_STRINGIZE(__VA_ARGS__) " failed")
+#define VEG_DEF_CONCEPT(Tpl, Name, ...)                                        \
+  __VEG_IMPL_DEF_CONCEPT(                                                      \
+    Tpl,                                                                       \
+    Name,                                                                      \
+    (__VA_ARGS__),                                                             \
+    ::proxsuite::linalg::veg::meta::bool_constant<__VA_ARGS__>);               \
+  VEG_TEMPLATE(Tpl,                                                            \
+               requires(__VA_ARGS__),                                          \
+               constexpr auto check_##Name,                                    \
+               (_ = 0, int)) noexcept                                          \
+    -> ::proxsuite::linalg::veg::meta::true_type
+
+#define __VEG_IMPL_SFINAE(_, Param)                                            \
+  , ::proxsuite::linalg::veg::meta::                                           \
+      enable_if_t<__VEG_PP_ID(__VEG_PP_UNWRAP Param), int> = 0
+
+#define __VEG_IMPL_OVERLOAD(Name_Tpl, Param)                                   \
+  template<__VEG_PP_REMOVE_PAREN(__VEG_PP_TAIL Name_Tpl),                      \
+           typename ::proxsuite::linalg::veg::_detail::_meta::                 \
+             enable_if<__VEG_PP_ID(__VEG_PP_UNWRAP Param), int>::type = 0>     \
+  auto __VEG_PP_CAT(check_, __VEG_PP_HEAD Name_Tpl)() noexcept                 \
+    -> ::proxsuite::linalg::veg::meta::true_type;
+
+#define VEG_DEF_CONCEPT_BOOL_CONJUNCTION_IMPL(Tpl, Name, Base, Seq)            \
+  __VEG_IMPL_DEF_CONCEPT(Tpl,                                                  \
+                         Name,                                                 \
+                         (__VEG_PP_REMOVE_PAREN1(Base)::value),                \
+                         __VEG_PP_REMOVE_PAREN1(Base));                        \
+  template<__VEG_PP_REMOVE_PAREN(Tpl)                                          \
+             __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_SFINAE, _, Seq)>               \
+  auto check_##Name() noexcept -> ::proxsuite::linalg::veg::meta::true_type
+#define VEG_DEF_CONCEPT_BOOL_DISJUNCTION_IMPL(Tpl, Name, Base, Seq)            \
+  __VEG_IMPL_DEF_CONCEPT(Tpl,                                                  \
+                         Name,                                                 \
+                         (__VEG_PP_REMOVE_PAREN1(Base)::value),                \
+                         __VEG_PP_REMOVE_PAREN1(Base));                        \
+  __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_OVERLOAD, (Name, Tpl), Seq)               \
+  VEG_NOM_SEMICOLON
+
+#define VEG_DEF_CONCEPT_CONJUNCTION(Tpl, Name, Terms)                          \
+  VEG_DEF_CONCEPT_BOOL_CONJUNCTION_IMPL(                                       \
+    Tpl,                                                                       \
+    Name,                                                                      \
+    (__VEG_IMPL_CONJUNCTION(Terms)),                                           \
+    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_ADD_VALUE, _, Terms))
+
+#define VEG_DEF_CONCEPT_DISJUNCTION(Tpl, Name, Terms)                          \
+  VEG_DEF_CONCEPT_BOOL_DISJUNCTION_IMPL(                                       \
+    Tpl,                                                                       \
+    Name,                                                                      \
+    (__VEG_IMPL_DISJUNCTION(Terms)),                                           \
+    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_ADD_VALUE, _, Terms))
+
+#define __VEG_IMPL_CONJUNCTION(Tuple)                                          \
+  ::proxsuite::linalg::veg::meta::conjunction<__VEG_PP_REMOVE_PAREN(           \
+    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PUT_TRAIT, _, Tuple))>
+#define __VEG_IMPL_DISJUNCTION(Tuple)                                          \
+  ::proxsuite::linalg::veg::meta::disjunction<__VEG_PP_REMOVE_PAREN(           \
+    __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PUT_TRAIT, _, Tuple))>
+
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+#define VEG_TEMPLATE(TParams, Constraint, Attr_Name, ...)                      \
+  __VEG_IMPL_TEMPLATE(Attr_Name,                                               \
+                      TParams,                                                 \
+                      __VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint),           \
+                      __VA_ARGS__)
+
+#if VEG_HAS_CONCEPTS
+#define VEG_CONSTRAINED_MEMBER_FN(Constraint, Attr_Name, Params, ...)          \
+  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(__VEG_IMPL_PARAM_EXPAND, _, Params)     \
+  __VA_ARGS__                                                                  \
+  requires __VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint)
+
+#define VEG_TEMPLATE_CVT(TParams, Constraint, Attr, ...)                       \
+  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
+  Constraint Attr operator __VA_ARGS__()
+#else
+#define VEG_CONSTRAINED_MEMBER_FN(Constraint, Attr_Name, Params, ...)          \
+  VEG_TEMPLATE(                                                                \
+    (int _ = 0),                                                               \
+    requires(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint) &&                  \
+             ::proxsuite::linalg::veg::meta::bool_constant<(_ == 0)>::value),  \
+    Attr_Name,                                                                 \
+    __VEG_PP_REMOVE_PAREN(Params))                                             \
+  __VA_ARGS__
+
+#define VEG_TEMPLATE_CVT(TParams, Constraint, Attr, ...)                       \
+  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
+  Attr operator ::proxsuite::linalg::veg::meta::enable_if_t<                   \
+    (__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Constraint)),                           \
+    __VA_ARGS__>()
+#endif
+
+#if VEG_HAS_CONCEPTS && defined(__cpp_conditional_explicit) &&                 \
+  (__cpp_conditional_explicit >= 201806L)
+#define VEG_TEMPLATE_EXPLICIT(                                                 \
+  TParams, Constraint, Explicit_Cond, Attr_Name, Params, ...)                  \
+  VEG_TEMPLATE(TParams,                                                        \
+               Constraint,                                                     \
+               Explicit_Cond Attr_Name,                                        \
+               __VEG_PP_REMOVE_PAREN(Params))                                  \
+  __VA_ARGS__
+
+#define VEG_TEMPLATE_CVT_EXPLICIT(                                             \
+  TParams, Constraint, Explicit_Cond, Attr, Type, ...)                         \
+  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
+  Constraint Explicit_Cond Attr operator __VEG_PP_REMOVE_PAREN(Type)()         \
+    __VA_ARGS__
+
+#else
+#define VEG_TEMPLATE_EXPLICIT(                                                 \
+  TParams, Constraint, Explicit_Cond, Attr_Name, Params, ...)                  \
+  VEG_TEMPLATE(                                                                \
+    (__VEG_PP_REMOVE_PAREN TParams,                                            \
+     ::proxsuite::linalg::veg::meta::                                          \
+       enable_if_t<(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)), int> =  \
+         0),                                                                   \
+    Constraint,                                                                \
+    explicit Attr_Name,                                                        \
+    __VEG_PP_REMOVE_PAREN(Params))                                             \
+  __VA_ARGS__                                                                  \
+  VEG_TEMPLATE((__VEG_PP_REMOVE_PAREN TParams,                                 \
+                ::proxsuite::linalg::veg::meta::enable_if_t<                   \
+                  !(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)),         \
+                  unsigned> = 0),                                              \
+               Constraint,                                                     \
+               Attr_Name,                                                      \
+               __VEG_PP_REMOVE_PAREN(Params))                                  \
+  __VA_ARGS__
+
+#define VEG_TEMPLATE_CVT_EXPLICIT(                                             \
+  TParams, Constraint, Explicit_Cond, Attr, Type, ...)                         \
+  VEG_TEMPLATE_CVT(                                                            \
+    (__VEG_PP_REMOVE_PAREN TParams,                                            \
+     ::proxsuite::linalg::veg::meta::                                          \
+       enable_if_t<(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)), int> =  \
+         0),                                                                   \
+    Constraint,                                                                \
+    explicit Attr,                                                             \
+    __VEG_PP_REMOVE_PAREN(Type))                                               \
+  __VA_ARGS__                                                                  \
+                                                                               \
+  VEG_TEMPLATE_CVT((__VEG_PP_REMOVE_PAREN TParams,                             \
+                    ::proxsuite::linalg::veg::meta::enable_if_t<               \
+                      !(__VEG_PP_CAT2(__VEG_IMPL_PREFIX_, Explicit_Cond)),     \
+                      unsigned> = 0),                                          \
+                   Constraint,                                                 \
+                   Attr,                                                       \
+                   __VEG_PP_REMOVE_PAREN(Type))                                \
+  __VA_ARGS__
+#endif
+
+#define __VEG_IMPL_PREFIX_requires
+#define __VEG_IMPL_PREFIX_explicit
+
+#define __VEG_IMPL_PARAM_EXPAND(I, _, Param)                                   \
+  __VEG_PP_TAIL Param __VEG_PP_HEAD Param
+#if VEG_HAS_CONCEPTS
+#define __VEG_IMPL_TEMPLATE(Attr_Name, TParams, Constraint, ...)               \
+  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
+    requires Constraint                                                        \
+  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(                                        \
+    __VEG_IMPL_PARAM_EXPAND, _, (__VA_ARGS__))
+#else
+
+#define __VEG_IMPL_TEMPLATE2_HELPER_0(Constraint, Param)                       \
+  __VEG_PP_TAIL Param __VEG_PP_HEAD Param
+
+#define __VEG_IMPL_TEMPLATE2_HELPER_1(Constraint, Param)                       \
+  ::proxsuite::linalg::veg::meta::enable_if_t<(Constraint),                    \
+                                              __VEG_PP_TAIL Param>             \
+    __VEG_PP_HEAD Param
+
+#define __VEG_IMPL_TEMPLATE2_HELPER(I, Constraint, Param)                      \
+  __VEG_PP_CAT2(__VEG_IMPL_TEMPLATE2_HELPER_,                                  \
+                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_INC(I)))                      \
+  (Constraint, Param)
+
+#define __VEG_IMPL_TEMPLATE(Attr_Name, TParams, Constraint, ...)               \
+  template<__VEG_PP_REMOVE_PAREN(TParams)>                                     \
+  Attr_Name __VEG_PP_TUPLE_TRANSFORM_I(                                        \
+    __VEG_IMPL_TEMPLATE2_HELPER, Constraint, (__VA_ARGS__))
+
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+#if defined(VEG_WITH_CXX17_SUPPORT)
+#define VEG_INLINE_VAR(Name, Obj)                                              \
+  inline constexpr auto const& Name =                                          \
+    ::proxsuite::linalg::veg::meta::static_const<Obj>::value;                  \
+  static_assert((void(Name), true), ".")
+
+#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) /* NOLINT */                   \
+  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
+  inline constexpr auto const& Name =                                          \
+    ::proxsuite::linalg::veg::meta::static_const<__VA_ARGS__>::value;          \
+  VEG_NOM_SEMICOLON /* NOLINT */
+#else
+#define VEG_INLINE_VAR(Name, Obj)                                              \
+  namespace /* NOLINT */ {                                                     \
+  constexpr auto const& Name =                                                 \
+    ::proxsuite::linalg::veg::meta::static_const<Obj>::value;                  \
+  }                                                                            \
+  static_assert((void(Name), true), ".")
+
+#if defined(VEG_WITH_CXX14_SUPPORT)
+#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) /* NOLINT */                   \
+  namespace /* NOLINT */ {                      /* NOLINT */                   \
+  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
+  constexpr auto const& Name = /* NOLINT */                                    \
+    ::proxsuite::linalg::veg::meta::static_const<                              \
+      __VA_ARGS__>::value; /* NOLINT                                           \
+                            */                                                 \
+  }                                                                            \
+  VEG_NOM_SEMICOLON /* NOLINT */
+#else
+#define VEG_INLINE_VAR_TEMPLATE(Tpl, Name, ...) VEG_NOM_SEMICOLON
+#endif
+#endif
+
+#define VEG_NIEBLOID(Name) VEG_INLINE_VAR(Name, nb::Name) // NOLINT
+
+#define VEG_NIEBLOID_TEMPLATE(Tpl, Name, ...)                                  \
+  VEG_INLINE_VAR_TEMPLATE(Tpl, Name, nb::Name<__VA_ARGS__>) // NOLINT
+
+#define VEG_TAG(Name, Type)                                                    \
+  namespace _ {                                                                \
+  template<int I>                                                              \
+  struct Type                                                                  \
+  {                                                                            \
+    explicit Type() = default;                                                 \
+  };                                                                           \
+  }                                                                            \
+  using Type = _::Type<0>;                                                     \
+  VEG_INLINE_VAR(Name, Type)
+
+#define VEG_TAG_TEMPLATE(Tpl, Name, Type, ...)                                 \
+  template<__VEG_PP_REMOVE_PAREN(Tpl)>                                         \
+  struct Type                                                                  \
+  {                                                                            \
+    explicit Type() = default;                                                 \
+  };                                                                           \
+  VEG_INLINE_VAR_TEMPLATE(Tpl, Name, Type<__VA_ARGS__>)
+
+#define VEG_FWD(X) static_cast<decltype(X)&&>(X)
+#define VEG_FWD2(X) static_cast<decltype(X)>(static_cast<decltype(X)&&>(X))
+
+// disallows moving const rvalues
+#define VEG_MOV(X)                                                             \
+  static_cast<typename ::proxsuite::linalg::veg::uncvref_t<decltype(X)>&&>(X)
+
+#ifdef VEG_NO_INSTANTIATE
+#define VEG_INSTANTIATE(Fn, ...) VEG_NOM_SEMICOLON
+#define VEG_INSTANTIATE_CLASS(Class, ...) VEG_NOM_SEMICOLON
+#else
+#define VEG_INSTANTIATE(Fn, ...)                                               \
+  __VEG_IMPL_INSTANTIATE(                                                      \
+    Fn,                                                                        \
+    __VEG_PP_CAT(__VEG_PP_CAT(_dummy_explicit_instantiation, __LINE__),        \
+                 __VEG_PP_CAT(_, __COUNTER__)),                                \
+    __VA_ARGS__)
+#define __VEG_IMPL_INSTANTIATE(Fn, Name, ...)                                  \
+  template<typename... Ts>                                                     \
+  struct Name                                                                  \
+  {                                                                            \
+    void apply(Ts&&... args)                                                   \
+    {                                                                          \
+      Fn(VEG_FWD(args)...);                                                    \
+    }                                                                          \
+  };                                                                           \
+  template struct Name<__VA_ARGS__>
+
+#define VEG_INSTANTIATE_CLASS(Class, ...) template struct Class<__VA_ARGS__>
+#endif
+
+#define VEG_NOM_SEMICOLON static_assert(true, ".")
+#define VEG_ID(id) __VEG_PP_CAT(id, __COUNTER__)
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+template<typename T>
+struct Slice;
+
+namespace meta {
+template<typename...>
+using void_t = void;
+} // namespace meta
+namespace _detail {
+template<typename T>
+struct Wrapper
+{
+  T inner;
+};
+namespace _meta {
+
+template<bool B, typename T = void>
+struct enable_if
+{
+  using type = T;
+};
+template<typename T>
+struct enable_if<false, T>
+{};
+
+template<typename U, typename V>
+using discard_1st = V;
+
+template<typename T>
+struct uncvlref;
+template<typename T>
+struct uncvlref<T&>
+{
+  using type = T;
+};
+template<typename T>
+struct uncvlref<T const&>
+{
+  using type = T;
+};
+template<typename T>
+struct uncvlref<T volatile&>
+{
+  using type = T;
+};
+template<typename T>
+struct uncvlref<T volatile const&>
+{
+  using type = T;
+};
+
+template<typename T>
+struct unref;
+template<typename T>
+struct unref<T&>
+{
+  using type = T;
+};
+
+template<typename T>
+auto
+declval() VEG_ALWAYS_NOEXCEPT->T;
+} // namespace _meta
+} // namespace _detail
+
+namespace meta {
+template<typename T>
+struct static_const
+{
+  static constexpr T value{};
+};
+
+template<typename T>
+constexpr T static_const<T>::value; // NOLINT(readability-redundant-declaration)
+} // namespace meta
+
+template<typename... Ts>
+struct incomplete_t;
+
+template<typename... Types, typename... Args>
+auto
+print_types_halt(Args&&...) -> incomplete_t<Types..., Args...>;
+template<typename... Types, typename... Args>
+VEG_DEPRECATED("")
+VEG_CPP14(constexpr) void print_types(Args&&... /*unused*/)
+{
+}
+
+namespace nb {
+struct unused
+{
+  template<typename... Ts>
+  VEG_CPP14(constexpr)
+  void operator()(Ts const&... /*unused*/) const VEG_NOEXCEPT
+  {
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(unused);
+
+using usize = decltype(sizeof(0));
+namespace _detail {
+
+template<isize I>
+struct EmptyI
+{};
+
+using Empty = EmptyI<0>;
+using EmptyArr = Empty[];
+namespace _meta {
+
+template<typename T, T... Nums>
+struct integer_sequence;
+
+#if VEG_HAS_BUILTIN(__make_integer_seq)
+
+template<typename T, T N>
+using make_integer_sequence = __make_integer_seq<integer_sequence, T, N>;
+
+#elif __GNUC__ >= 8
+
+template<typename T, T N>
+using make_integer_sequence = integer_sequence<T, __integer_pack(N)...>;
+
+#else
+
+namespace _detail {
+
+template<typename Seq1, typename Seq2>
+struct _merge;
+
+template<typename Seq1, typename Seq2>
+struct _merge_p1;
+
+template<typename T, T... Nums1, T... Nums2>
+struct _merge<integer_sequence<T, Nums1...>, integer_sequence<T, Nums2...>>
+{
+  using type = integer_sequence<T, Nums1..., (sizeof...(Nums1) + Nums2)...>;
+};
+
+template<typename T, T... Nums1, T... Nums2>
+struct _merge_p1<integer_sequence<T, Nums1...>, integer_sequence<T, Nums2...>>
+{
+  using type = integer_sequence<T,
+                                Nums1...,
+                                (sizeof...(Nums1) + Nums2)...,
+                                sizeof...(Nums1) + sizeof...(Nums2)>;
+};
+
+template<typename T, usize N, bool Even = (N % 2) == 0>
+struct _make_integer_sequence
+{
+  using type =
+    typename _merge<typename _make_integer_sequence<T, N / 2>::type,
+                    typename _make_integer_sequence<T, N / 2>::type>::type;
+};
+
+template<typename T, usize N>
+struct _make_integer_sequence<T, N, false>
+{
+  using type =
+    typename _merge_p1<typename _make_integer_sequence<T, N / 2>::type,
+                       typename _make_integer_sequence<T, N / 2>::type>::type;
+};
+
+template<typename T>
+struct _make_integer_sequence<T, 0>
+{
+  using type = integer_sequence<T>;
+};
+template<typename T>
+struct _make_integer_sequence<T, 1>
+{
+  using type = integer_sequence<T, 0>;
+};
+
+} // namespace _detail
+
+template<typename T, T N>
+using make_integer_sequence =
+  typename _detail::_make_integer_sequence<T, N>::type;
+
+#endif
+
+#define VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(Tpl, Name, ...)                    \
+  VEG_DEF_CONCEPT(                                                             \
+    Tpl,                                                                       \
+    Name,                                                                      \
+    VEG_HAS_BUILTIN_OR(__is_##Name,                                            \
+                       __is_##Name(__VA_ARGS__),                               \
+                       (_detail::_meta::is_##Name<__VA_ARGS__>::value)))
+
+template<usize N>
+using make_index_sequence = make_integer_sequence<usize, N>;
+
+template<typename... Ts>
+struct type_sequence;
+
+} // namespace _meta
+
+template<usize I, typename T>
+struct SimpleLeaf
+{
+  T inner;
+};
+
+template<typename Seq, typename... Ts>
+struct SimpleITuple;
+
+template<usize... Is, typename... Ts>
+struct SimpleITuple<_meta::integer_sequence<usize, Is...>, Ts...>
+  : SimpleLeaf<Is, Ts>...
+{
+#if !defined(VEG_WITH_CXX17_SUPPORT)
+  constexpr SimpleITuple(Ts... args) noexcept
+    : SimpleLeaf<Is, Ts>{ Ts(VEG_FWD(args)) }...
+  {
+  }
+#endif
+};
+
+template<typename... Ts>
+using SimpleTuple =
+  SimpleITuple<_meta::make_index_sequence<sizeof...(Ts)>, Ts...>;
+
+template<typename... Ts>
+constexpr auto
+make_simple_tuple(Empty /*dummy*/, Ts... args) noexcept -> SimpleTuple<Ts...>
+{
+#if !defined(VEG_WITH_CXX17_SUPPORT)
+  return { Ts(VEG_FWD(args))... };
+#else
+  return { { Ts(VEG_FWD(args)) }... };
+#endif
+}
+
+template<typename T>
+struct mem_ptr_type;
+template<typename C, typename Mem>
+struct mem_ptr_type<Mem C::*>
+{
+  using Type = Mem;
+};
+
+constexpr auto
+all_of_slice(bool const* arr, usize size) VEG_NOEXCEPT->bool
+{
+  return size == 0 ? true
+                   : (arr[0] && _detail::all_of_slice(arr + 1, size - 1));
+}
+template<usize N>
+inline constexpr auto
+all_of(bool const (&lst)[N]) VEG_NOEXCEPT->bool
+{
+  return _detail::all_of_slice(lst, N);
+}
+
+template<typename T>
+struct member_extract_access
+{
+  template<typename U, typename = U>
+  struct DetectImpl
+  {
+    static constexpr bool value = false;
+    using Type = void;
+  };
+  template<typename U>
+  struct DetectImpl<U, typename U::_veglib_impl_member_extract::Type>
+  {
+    static constexpr bool value = true;
+    using Type = typename U::_veglib_impl_member_extract;
+  };
+
+  using Detect = DetectImpl<T>;
+  static constexpr bool value = Detect::value;
+  using Type = typename Detect::Type;
+};
+} // namespace _detail
+namespace meta {
+template<bool B, typename T = void>
+using enable_if_t =
+  _detail::_meta::discard_1st<typename _detail::_meta::enable_if<B, void>::type,
+                              T>;
+
+template<typename T>
+using uncvref_t = typename _detail::_meta::uncvlref<T&>::type;
+} // namespace meta
+using meta::uncvref_t;
+
+namespace meta {
+template<typename T, T Value>
+struct constant
+{
+  static constexpr T value = Value;
+};
+template<typename T, T Value>
+constexpr T constant<T, Value>::value;
+template<bool B>
+using bool_constant = constant<bool, B>;
+
+using true_type = bool_constant<true>;
+using false_type = bool_constant<false>;
+} // namespace meta
+namespace _detail {
+namespace _meta {
+
+struct wrapper_base
+{
+  static auto test(...) -> meta::false_type;
+};
+template<typename T>
+struct wrapper : wrapper_base
+{
+  using wrapper_base::test;
+  static auto test(wrapper<T>*) -> meta::true_type;
+};
+template<typename T, typename U>
+using is_same = decltype(wrapper<T>::test(static_cast<wrapper<U>*>(nullptr)));
+} // namespace _meta
+} // namespace _detail
+namespace concepts {
+VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL((typename T, typename U), same, T, U);
+} // namespace concepts
+
+enum struct CharUnit : unsigned char
+{
+  SPACE = 0x20,
+  EXCLAMATION_MARK = 0x21,
+  DOUBLE_QUOTE = 0x22,
+  NUMBER = 0x23,
+  DOLLAR = 0x24,
+  PERCENT = 0x25,
+  AMPERSAND = 0x26,
+  SINGLE_QUOTE = 0x27,
+  LEFT_PARENTHESIS = 0x28,
+  RIGHT_PARENTHESIS = 0x29,
+  ASTERISK = 0x2A,
+  PLUS = 0x2B,
+  COMMA = 0x2C,
+  MINUS = 0x2D,
+  PERIOD = 0x2E,
+  SLASH = 0x2F,
+  ZERO = 0x30,
+  ONE = 0x31,
+  TWO = 0x32,
+  THREE = 0x33,
+  FOUR = 0x34,
+  FIVE = 0x35,
+  SIX = 0x36,
+  SEVEN = 0x37,
+  EIGHT = 0x38,
+  NINE = 0x39,
+  COLON = 0x3A,
+  SEMICOLON = 0x3B,
+  LESS_THAN = 0x3C,
+  EQUALITY_SIGN = 0x3D,
+  GREATER_THAN = 0x3E,
+  QUESTION_MARK = 0x3F,
+  AT_SIGN = 0x40,
+  UPPERCASE_A = 0x41,
+  UPPERCASE_B = 0x42,
+  UPPERCASE_C = 0x43,
+  UPPERCASE_D = 0x44,
+  UPPERCASE_E = 0x45,
+  UPPERCASE_F = 0x46,
+  UPPERCASE_G = 0x47,
+  UPPERCASE_H = 0x48,
+  UPPERCASE_I = 0x49,
+  UPPERCASE_J = 0x4A,
+  UPPERCASE_K = 0x4B,
+  UPPERCASE_L = 0x4C,
+  UPPERCASE_M = 0x4D,
+  UPPERCASE_N = 0x4E,
+  UPPERCASE_O = 0x4F,
+  UPPERCASE_P = 0x50,
+  UPPERCASE_Q = 0x51,
+  UPPERCASE_R = 0x52,
+  UPPERCASE_S = 0x53,
+  UPPERCASE_T = 0x54,
+  UPPERCASE_U = 0x55,
+  UPPERCASE_V = 0x56,
+  UPPERCASE_W = 0x57,
+  UPPERCASE_X = 0x58,
+  UPPERCASE_Y = 0x59,
+  UPPERCASE_Z = 0x5A,
+  LEFT_SQUARE_BRACKET = 0x5B,
+  BACKSLASH = 0x5C,
+  RIGHT_SQUARE_BRACKET = 0x5D,
+  CARET = 0x5F,
+  GRAVE = 0x60,
+  LOWERCASE_A = 0x61,
+  LOWERCASE_B = 0x62,
+  LOWERCASE_C = 0x63,
+  LOWERCASE_D = 0x64,
+  LOWERCASE_E = 0x65,
+  LOWERCASE_F = 0x66,
+  LOWERCASE_G = 0x67,
+  LOWERCASE_H = 0x68,
+  LOWERCASE_I = 0x69,
+  LOWERCASE_J = 0x6A,
+  LOWERCASE_K = 0x6B,
+  LOWERCASE_L = 0x6C,
+  LOWERCASE_M = 0x6D,
+  LOWERCASE_N = 0x6E,
+  LOWERCASE_O = 0x6F,
+  LOWERCASE_P = 0x70,
+  LOWERCASE_Q = 0x71,
+  LOWERCASE_R = 0x72,
+  LOWERCASE_S = 0x73,
+  LOWERCASE_T = 0x74,
+  LOWERCASE_U = 0x75,
+  LOWERCASE_V = 0x76,
+  LOWERCASE_W = 0x77,
+  LOWERCASE_X = 0x78,
+  LOWERCASE_Y = 0x79,
+  LOWERCASE_Z = 0x7A,
+  LEFT_CURLY_BRACKET = 0x7B,
+  VERTICAL_BAR = 0x7C,
+  RIGHT_CURLY_BRACKET = 0x7D,
+  TILDE = 0x7E,
+};
+
+inline namespace tags {
+VEG_TAG(from_raw_parts, FromRawParts);
+
+VEG_TAG(safe, Safe);
+VEG_TAG(unsafe, Unsafe);
+} // namespace tags
+
+struct Str
+{
+private:
+  struct
+  {
+    CharUnit const* ptr;
+    isize len;
+  } _ = {};
+
+public:
+  VEG_INLINE constexpr Str(Unsafe /*unsafe*/,
+                           FromRawParts /*from_raw_parts*/,
+                           CharUnit const* ptr,
+                           isize len) noexcept
+    : _{ ptr, len } {};
+  VEG_INLINE constexpr auto as_slice() const noexcept -> Slice<CharUnit>;
+};
+
+template<CharUnit... Cs>
+struct StrLiteralConstant
+{
+private:
+  static constexpr CharUnit literal[sizeof...(Cs)] = { Cs... };
+
+public:
+  VEG_INLINE constexpr auto as_slice() const noexcept -> Slice<CharUnit>;
+  VEG_INLINE constexpr auto as_str() const noexcept -> Str
+  {
+    return { unsafe, from_raw_parts, literal, isize{ sizeof...(Cs) } };
+  }
+};
+
+template<CharUnit... Cs>
+constexpr CharUnit StrLiteralConstant<Cs...>::literal[sizeof...(Cs)];
+
+namespace _detail {
+using NativeChar8 = meta::uncvref_t<decltype(u8""[0])>;
+
+template<typename T, usize N>
+struct Array_
+{
+  T _[N];
+};
+template<typename T>
+constexpr auto
+assert_complete() noexcept -> bool
+{
+  static_assert(sizeof(T) != 0, ".");
+  return true;
+}
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#if defined(__clang__) || (defined(VEG_WITH_CXX14_SUPPORT) && defined(__GNUC__))
+HEDLEY_DIAGNOSTIC_PUSH
+#pragma GCC diagnostic ignored "-Wpedantic"
+#ifdef __clang__
+#pragma clang diagnostic ignored "-Wgnu-string-literal-operator-template"
+#endif
+
+template<typename Char,
+         Char... Cs>
+constexpr auto
+operator""__veglib_const_literal_gnuc() noexcept // NOLINT
+  -> proxsuite::linalg::veg::StrLiteralConstant<
+    proxsuite::linalg::veg::CharUnit(Cs)...>
+{
+  return {};
+}
+
+HEDLEY_DIAGNOSTIC_POP
+
+#define __VEG_IMPL_UTF8_CONST(Literal) /* NOLINT */                            \
+  (u8##Literal##__veglib_const_literal_gnuc)
+
+#elif (defined(__clang__) && defined(VEG_WITH_CXX20_SUPPORT)) ||               \
+  (defined(__cpp_nontype_template_args) &&                                     \
+   (__cpp_nontype_template_args >= 201911L))
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+template<isize N>
+struct StrLiteralImpl
+{
+  proxsuite::linalg::veg::CharUnit _[N];
+
+  template<typename Char>
+  constexpr StrLiteralImpl(Char const* s)
+  {
+    for (isize i = 0; i < N; ++i) {
+      _[i] = proxsuite::linalg::veg::CharUnit(s[i]);
+    }
+  }
+};
+template<typename Char, isize N>
+StrLiteralImpl(Char const (&)[N]) -> StrLiteralImpl<N - 1>;
+
+template<typename T>
+struct StrLiteralLen;
+
+template<isize N>
+struct StrLiteralLen<StrLiteralImpl<N>>
+{
+  static constexpr usize value{ N };
+};
+template<isize N>
+struct StrLiteralLen<StrLiteralImpl<N> const>
+{
+  static constexpr usize value{ N };
+};
+
+template<typename Seq, auto Literal>
+struct StrLiteralExpand;
+
+template<usize... Is, StrLiteralImpl<static_cast<isize>(sizeof...(Is))> L>
+struct StrLiteralExpand<_meta::integer_sequence<usize, Is...>, L>
+{
+  using Type = StrLiteralConstant<L._[Is]...>;
+};
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+template<proxsuite::linalg::veg::_detail::StrLiteralImpl S>
+constexpr auto
+operator""__veglib_const_literal_cpp20() noexcept ->
+  typename proxsuite::linalg::veg::_detail::StrLiteralExpand< //
+    proxsuite::linalg::veg::_detail::_meta::make_index_sequence<
+      proxsuite::linalg::veg::_detail::StrLiteralLen<decltype(S)>::value>,
+    S>::Type
+{
+  return {};
+}
+#define __VEG_IMPL_UTF8_CONST(Literal)                                         \
+  (u8##Literal##__veglib_const_literal_cpp20)
+
+#else
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+
+template<typename LiteralType, typename Seq>
+struct ExtractCharsImpl;
+
+template<typename LiteralType, usize... Is>
+struct ExtractCharsImpl<LiteralType, _meta::integer_sequence<usize, Is...>>
+{
+  using Type = StrLiteralConstant<CharUnit(LiteralType::value[Is])...>;
+};
+
+template<typename LiteralType, typename Seq>
+struct ExtractCharsImplExpr;
+
+template<typename LiteralType, usize... Is>
+struct ExtractCharsImplExpr<LiteralType, _meta::integer_sequence<usize, Is...>>
+{
+  using Type = StrLiteralConstant<CharUnit(LiteralType::value()[Is])...>;
+};
+
+template<typename LiteralType>
+auto
+extract_chars(LiteralType /*unused*/) -> typename ExtractCharsImpl<
+  LiteralType,
+  _meta::make_index_sequence<LiteralType::Size::value>>::Type
+{
+  return {};
+}
+
+template<typename LiteralType>
+auto
+extract_chars_expr(LiteralType /*unused*/) -> typename ExtractCharsImplExpr<
+  LiteralType,
+  _meta::make_index_sequence<LiteralType::Size::value>>::Type
+{
+  return {};
+}
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#define __VEG_IMPL_UTF8_CONST(Literal)                                         \
+  (::proxsuite::linalg::veg::_detail::extract_chars_expr(                      \
+    []() /* NOLINT */ noexcept {                                               \
+      struct __VEG_PP_CAT(_veglib_type, __LINE__)                              \
+      {                                                                        \
+        static constexpr auto value() noexcept -> decltype(Literal)            \
+        {                                                                      \
+          return Literal;                                                      \
+        }                                                                      \
+        using Size = ::proxsuite::linalg::veg::meta::constant<                 \
+          ::proxsuite::linalg::veg::usize,                                     \
+          sizeof(value()) / sizeof(value()[0]) - 1>;                           \
+      };                                                                       \
+      return __VEG_PP_CAT(_veglib_type, __LINE__){};                           \
+    }()))
+#endif
+
+#define VEG_DECLTYPE_VOID(...) decltype(void(__VA_ARGS__))
+#define VEG_BOOL_NOEXCEPT(...)                                                 \
+  ::proxsuite::linalg::veg::meta::bool_constant<noexcept(__VA_ARGS__)>
+
+#define VEG_CHECK_CONCEPT(...)                                                 \
+  VEG_CHECK_CONCEPT_MACRO(::proxsuite::linalg::veg::concepts, __VA_ARGS__)
+#define VEG_CONCEPT(...)                                                       \
+  VEG_CONCEPT_MACRO(::proxsuite::linalg::veg::concepts, __VA_ARGS__)
+
+#define __VEG_IMPL_GET_MEMBER_PTR(_, MemberPtr) /* NOLINT */ , &Type::MemberPtr
+#define __VEG_IMPL_GET_MEMBER_NAME_PTR(_, MemberPtr) /* NOLINT */              \
+  static_cast<::proxsuite::linalg::veg::_detail::NativeChar8 const*>(          \
+    __VEG_PP_CAT(u8, __VEG_PP_STRINGIZE(MemberPtr))),
+#define __VEG_IMPL_GET_MEMBER_NAME_LEN(_, MemberPtr) /* NOLINT */              \
+  (sizeof(__VEG_PP_CAT(u8, __VEG_PP_STRINGIZE(MemberPtr))) - 1),
+
+#define __VEG_IMPL_STRUCT_SETUP(PClass, ...) /* NOLINT */                      \
+  void _veg_lib_name_test()&& noexcept                                         \
+  {                                                                            \
+    static_assert(                                                             \
+      VEG_CONCEPT(same<decltype(this), __VEG_PP_REMOVE_PAREN(PClass)*>),       \
+      "struct mismatch in VEG_REFLECT");                                       \
+  }                                                                            \
+  struct _veglib_impl_member_extract                                           \
+  {                                                                            \
+    using Type = __VEG_PP_REMOVE_PAREN(PClass);                                \
+    using MemberTuple =                                                        \
+      decltype(::proxsuite::linalg::veg::_detail::make_simple_tuple(           \
+        ::proxsuite::linalg::veg::_detail::Empty {                             \
+        } __VEG_PP_TUPLE_FOR_EACH(__VEG_IMPL_GET_MEMBER_PTR,                   \
+                                  _,                                           \
+                                  (__VA_ARGS__))));                            \
+    static constexpr auto member_pointers() noexcept -> MemberTuple            \
+    {                                                                          \
+      return ::proxsuite::linalg::veg::_detail::make_simple_tuple(             \
+        ::proxsuite::linalg::veg::_detail::Empty {} __VEG_PP_TUPLE_FOR_EACH(   \
+          __VEG_IMPL_GET_MEMBER_PTR, _, (__VA_ARGS__)));                       \
+    }                                                                          \
+    static constexpr auto class_name_ptr() noexcept                            \
+      -> ::proxsuite::linalg::veg::_detail::NativeChar8 const*                 \
+    {                                                                          \
+      return __VEG_PP_CAT(u8,                                                  \
+                          __VEG_PP_STRINGIZE(__VEG_PP_REMOVE_PAREN(PClass)));  \
+    }                                                                          \
+    static constexpr auto class_name_len() noexcept                            \
+      -> ::proxsuite::linalg::veg::usize                                       \
+    {                                                                          \
+      return sizeof(__VEG_PP_CAT(                                              \
+               u8, __VEG_PP_STRINGIZE(__VEG_PP_REMOVE_PAREN(PClass)))) -       \
+             1;                                                                \
+    }                                                                          \
+    static constexpr auto member_name_ptrs() noexcept                          \
+      -> ::proxsuite::linalg::veg::_detail::Array_<                            \
+        ::proxsuite::linalg::veg::_detail::NativeChar8 const*,                 \
+        __VEG_PP_TUPLE_SIZE((__VA_ARGS__))>                                    \
+    {                                                                          \
+      return { { __VEG_PP_TUPLE_FOR_EACH(                                      \
+        __VEG_IMPL_GET_MEMBER_NAME_PTR, _, (__VA_ARGS__)) } };                 \
+    }                                                                          \
+    static constexpr auto member_name_lens() noexcept                          \
+      -> ::proxsuite::linalg::veg::_detail::Array_<                            \
+        ::proxsuite::linalg::veg::usize,                                       \
+        __VEG_PP_TUPLE_SIZE((__VA_ARGS__))>                                    \
+    {                                                                          \
+      return { { __VEG_PP_TUPLE_FOR_EACH(                                      \
+        __VEG_IMPL_GET_MEMBER_NAME_LEN, _, (__VA_ARGS__)) } };                 \
+    }                                                                          \
+  };                                                                           \
+  friend struct ::proxsuite::linalg::veg::_detail::member_extract_access<      \
+    __VEG_PP_REMOVE_PAREN(PClass)>;                                            \
+  VEG_NOM_SEMICOLON
+
+#define VEG_REFLECT(PClass, ...) __VEG_IMPL_STRUCT_SETUP(PClass, __VA_ARGS__)
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_MACROS_HPP_HSTLSKZXS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/narrow.hpp

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-#ifndef VEG_NARROW_HPP_H0EXKJTAS
-#define VEG_NARROW_HPP_H0EXKJTAS
-
-#include "proxsuite/fwd.hpp"
-#include "proxsuite/linalg/veg/util/assert.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include "proxsuite/helpers/common.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace nb {
-template<typename To>
-struct narrow
-{
-  VEG_TEMPLATE((typename From),
-               requires VEG_CONCEPT(integral<From>) &&
-                 VEG_CONCEPT(integral<To>),
-               constexpr auto
-               operator(),
-               (from, From))
-  const VEG_NOEXCEPT->To
-  {
-#if defined(VEG_WITH_CXX14_SUPPORT)
-
-    To to = static_cast<To>(from);
-    PROXSUITE_MAYBE_UNUSED From roundtrip_from =
-      static_cast<From>(static_cast<To>(from));
-    VEG_INTERNAL_ASSERT_PRECONDITION(roundtrip_from == from);
-    return to;
-
-#else
-    return VEG_INTERNAL_ASSERT_PRECONDITION(
-             static_cast<From>(static_cast<To>(from)) == from),
-           static_cast<To>(from);
-#endif
-  }
-};
-} // namespace nb
-VEG_NIEBLOID_TEMPLATE(typename To, narrow, To);
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_NARROW_HPP_H0EXKJTAS */
+#ifndef VEG_NARROW_HPP_H0EXKJTAS
+#define VEG_NARROW_HPP_H0EXKJTAS
+
+#include "proxsuite/fwd.hpp"
+#include "proxsuite/linalg/veg/util/assert.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include "proxsuite/helpers/common.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace nb {
+template<typename To>
+struct narrow
+{
+  VEG_TEMPLATE((typename From),
+               requires VEG_CONCEPT(integral<From>) &&
+                 VEG_CONCEPT(integral<To>),
+               constexpr auto
+               operator(),
+               (from, From))
+  const VEG_NOEXCEPT->To
+  {
+#if defined(VEG_WITH_CXX14_SUPPORT)
+
+    To to = static_cast<To>(from);
+    PROXSUITE_MAYBE_UNUSED From roundtrip_from =
+      static_cast<From>(static_cast<To>(from));
+    VEG_INTERNAL_ASSERT_PRECONDITION(roundtrip_from == from);
+    return to;
+
+#else
+    return VEG_INTERNAL_ASSERT_PRECONDITION(
+             static_cast<From>(static_cast<To>(from)) == from),
+           static_cast<To>(from);
+#endif
+  }
+};
+} // namespace nb
+VEG_NIEBLOID_TEMPLATE(typename To, narrow, To);
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_NARROW_HPP_H0EXKJTAS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/preprocessor.hpp

 * *Ordering differences only*

```diff
@@ -1,434 +1,434 @@
-#ifndef VEG_PREPROCESSOR_HPP_U2V3WRWYS
-#define VEG_PREPROCESSOR_HPP_U2V3WRWYS
-
-// clang-format off
-#define __VEG_IMPL_PP_COUNT(Arg_0, Arg_1, Arg_2, Arg_3, Arg_4, Arg_5, Arg_6, Arg_7, Arg_8, Arg_9, Arg_10, Arg_11, Arg_12, Arg_13, Arg_14, Arg_15, Arg_16, Arg_17, Arg_18, Arg_19, Arg_20, Arg_21, Arg_22, Arg_23, Arg_24, Arg_25, Arg_26, Arg_27, Arg_28, Arg_29, Arg_30, Arg_31, N, ...) N
-
-#define __VEG_IMPL_PP_IS_1_1 1
-#define __VEG_IMPL_PP_IS_1_2 0
-#define __VEG_IMPL_PP_IS_1_3 0
-#define __VEG_IMPL_PP_IS_1_4 0
-#define __VEG_IMPL_PP_IS_1_5 0
-#define __VEG_IMPL_PP_IS_1_6 0
-#define __VEG_IMPL_PP_IS_1_7 0
-#define __VEG_IMPL_PP_IS_1_8 0
-#define __VEG_IMPL_PP_IS_1_9 0
-#define __VEG_IMPL_PP_IS_1_10 0
-#define __VEG_IMPL_PP_IS_1_11 0
-#define __VEG_IMPL_PP_IS_1_12 0
-#define __VEG_IMPL_PP_IS_1_13 0
-#define __VEG_IMPL_PP_IS_1_14 0
-#define __VEG_IMPL_PP_IS_1_15 0
-#define __VEG_IMPL_PP_IS_1_16 0
-#define __VEG_IMPL_PP_IS_1_17 0
-#define __VEG_IMPL_PP_IS_1_18 0
-#define __VEG_IMPL_PP_IS_1_19 0
-#define __VEG_IMPL_PP_IS_1_20 0
-#define __VEG_IMPL_PP_IS_1_21 0
-#define __VEG_IMPL_PP_IS_1_22 0
-#define __VEG_IMPL_PP_IS_1_23 0
-#define __VEG_IMPL_PP_IS_1_24 0
-#define __VEG_IMPL_PP_IS_1_25 0
-#define __VEG_IMPL_PP_IS_1_26 0
-#define __VEG_IMPL_PP_IS_1_27 0
-#define __VEG_IMPL_PP_IS_1_28 0
-#define __VEG_IMPL_PP_IS_1_29 0
-#define __VEG_IMPL_PP_IS_1_30 0
-#define __VEG_IMPL_PP_IS_1_31 0
-#define __VEG_IMPL_PP_IS_1_32 0
-#define __VEG_IMPL_PP_IS_1_33 0
-
-#define __VEG_IMPL_PP_DEC_1 0
-#define __VEG_IMPL_PP_DEC_2 1
-#define __VEG_IMPL_PP_DEC_3 2
-#define __VEG_IMPL_PP_DEC_4 3
-#define __VEG_IMPL_PP_DEC_5 4
-#define __VEG_IMPL_PP_DEC_6 5
-#define __VEG_IMPL_PP_DEC_7 6
-#define __VEG_IMPL_PP_DEC_8 7
-#define __VEG_IMPL_PP_DEC_9 8
-#define __VEG_IMPL_PP_DEC_10 9
-#define __VEG_IMPL_PP_DEC_11 10
-#define __VEG_IMPL_PP_DEC_12 11
-#define __VEG_IMPL_PP_DEC_13 12
-#define __VEG_IMPL_PP_DEC_14 13
-#define __VEG_IMPL_PP_DEC_15 14
-#define __VEG_IMPL_PP_DEC_16 15
-#define __VEG_IMPL_PP_DEC_17 16
-#define __VEG_IMPL_PP_DEC_18 17
-#define __VEG_IMPL_PP_DEC_19 18
-#define __VEG_IMPL_PP_DEC_20 19
-#define __VEG_IMPL_PP_DEC_21 20
-#define __VEG_IMPL_PP_DEC_22 21
-#define __VEG_IMPL_PP_DEC_23 22
-#define __VEG_IMPL_PP_DEC_24 23
-#define __VEG_IMPL_PP_DEC_25 24
-#define __VEG_IMPL_PP_DEC_26 25
-#define __VEG_IMPL_PP_DEC_27 26
-#define __VEG_IMPL_PP_DEC_28 27
-#define __VEG_IMPL_PP_DEC_29 28
-#define __VEG_IMPL_PP_DEC_30 29
-#define __VEG_IMPL_PP_DEC_31 30
-#define __VEG_IMPL_PP_DEC_32 31
-#define __VEG_IMPL_PP_DEC_33 32
-
-#define __VEG_IMPL_PP_INC_0 1
-#define __VEG_IMPL_PP_INC_1 2
-#define __VEG_IMPL_PP_INC_2 3
-#define __VEG_IMPL_PP_INC_3 4
-#define __VEG_IMPL_PP_INC_4 5
-#define __VEG_IMPL_PP_INC_5 6
-#define __VEG_IMPL_PP_INC_6 7
-#define __VEG_IMPL_PP_INC_7 8
-#define __VEG_IMPL_PP_INC_8 9
-#define __VEG_IMPL_PP_INC_9 10
-#define __VEG_IMPL_PP_INC_10 11
-#define __VEG_IMPL_PP_INC_11 12
-#define __VEG_IMPL_PP_INC_12 13
-#define __VEG_IMPL_PP_INC_13 14
-#define __VEG_IMPL_PP_INC_14 15
-#define __VEG_IMPL_PP_INC_15 16
-#define __VEG_IMPL_PP_INC_16 17
-#define __VEG_IMPL_PP_INC_17 18
-#define __VEG_IMPL_PP_INC_18 19
-#define __VEG_IMPL_PP_INC_19 20
-#define __VEG_IMPL_PP_INC_20 21
-#define __VEG_IMPL_PP_INC_21 22
-#define __VEG_IMPL_PP_INC_22 23
-#define __VEG_IMPL_PP_INC_23 24
-#define __VEG_IMPL_PP_INC_24 25
-#define __VEG_IMPL_PP_INC_25 26
-#define __VEG_IMPL_PP_INC_26 27
-#define __VEG_IMPL_PP_INC_27 28
-#define __VEG_IMPL_PP_INC_28 29
-#define __VEG_IMPL_PP_INC_29 30
-#define __VEG_IMPL_PP_INC_30 31
-#define __VEG_IMPL_PP_INC_31 32
-#define __VEG_IMPL_PP_INC_32 33
-
-#define __VEG_IMPL_PP_DEC_I(X) __VEG_IMPL_PP_DEC_##X
-#define __VEG_IMPL_PP_DEC(X) __VEG_IMPL_PP_DEC_I(X)
-#define __VEG_IMPL_PP_INC_I(X) __VEG_IMPL_PP_INC_##X
-#define __VEG_IMPL_PP_INC(X) __VEG_IMPL_PP_INC_I(X)
-#define __VEG_IMPL_PP_IS_1_I(X) __VEG_IMPL_PP_IS_1_##X
-#define __VEG_IMPL_PP_IS_1(X) __VEG_IMPL_PP_IS_1_I(X)
-
-#define __VEG_IMPL_PP_COMMA_IF_NOT_0_1
-#define __VEG_IMPL_PP_COMMA_IF_NOT_0_0 ,
-#define __VEG_PP_COMMA_IF_NOT_0(X) __VEG_PP_CAT2(__VEG_IMPL_PP_COMMA_IF_NOT_0_, __VEG_PP_IS_0(X))
-
-#define __VEG_PP_IS_1(X) __VEG_IMPL_PP_IS_1_I(X)
-#define __VEG_PP_IS_0(X) __VEG_PP_IS_1(__VEG_IMPL_PP_INC_I(X))
-
-#define __VEG_PP_ID(X) X
-
-#define __VEG_IMPL_PP_VARIADIC_SIZE(...) __VEG_PP_ID(__VEG_IMPL_PP_COUNT(__VA_ARGS__, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))
-
-#define __VEG_IMPL_PP_MAKE_TUPLE0 ()
-#define __VEG_IMPL_PP_MAKE_TUPLE1 (0)
-#define __VEG_IMPL_PP_MAKE_TUPLE2 (0, 1)
-#define __VEG_IMPL_PP_MAKE_TUPLE3 (0, 1, 2)
-#define __VEG_IMPL_PP_MAKE_TUPLE4 (0, 1, 2, 3)
-#define __VEG_IMPL_PP_MAKE_TUPLE5 (0, 1, 2, 3, 4)
-#define __VEG_IMPL_PP_MAKE_TUPLE6 (0, 1, 2, 3, 4, 5)
-#define __VEG_IMPL_PP_MAKE_TUPLE7 (0, 1, 2, 3, 4, 5, 6)
-#define __VEG_IMPL_PP_MAKE_TUPLE8 (0, 1, 2, 3, 4, 5, 6, 7)
-#define __VEG_IMPL_PP_MAKE_TUPLE9 (0, 1, 2, 3, 4, 5, 6, 7, 8)
-#define __VEG_IMPL_PP_MAKE_TUPLE10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
-#define __VEG_IMPL_PP_MAKE_TUPLE11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
-#define __VEG_IMPL_PP_MAKE_TUPLE12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
-#define __VEG_IMPL_PP_MAKE_TUPLE13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
-#define __VEG_IMPL_PP_MAKE_TUPLE14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)
-#define __VEG_IMPL_PP_MAKE_TUPLE15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
-#define __VEG_IMPL_PP_MAKE_TUPLE16 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
-#define __VEG_IMPL_PP_MAKE_TUPLE17 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
-#define __VEG_IMPL_PP_MAKE_TUPLE18 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)
-#define __VEG_IMPL_PP_MAKE_TUPLE19 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)
-#define __VEG_IMPL_PP_MAKE_TUPLE20 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
-#define __VEG_IMPL_PP_MAKE_TUPLE21 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
-#define __VEG_IMPL_PP_MAKE_TUPLE22 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)
-#define __VEG_IMPL_PP_MAKE_TUPLE23 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)
-#define __VEG_IMPL_PP_MAKE_TUPLE24 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)
-#define __VEG_IMPL_PP_MAKE_TUPLE25 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)
-#define __VEG_IMPL_PP_MAKE_TUPLE26 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25)
-#define __VEG_IMPL_PP_MAKE_TUPLE27 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)
-#define __VEG_IMPL_PP_MAKE_TUPLE28 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27)
-#define __VEG_IMPL_PP_MAKE_TUPLE29 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28)
-#define __VEG_IMPL_PP_MAKE_TUPLE30 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29)
-#define __VEG_IMPL_PP_MAKE_TUPLE31 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30)
-#define __VEG_IMPL_PP_MAKE_TUPLE32 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31)
-// clang-format on
-
-#define __VEG_IMPL_PP_CAT(A, ...) A##__VA_ARGS__
-#define __VEG_IMPL_PP_CAT2(A, ...) A##__VA_ARGS__
-#define __VEG_IMPL_PP_CAT3(A, ...) A##__VA_ARGS__
-
-#define __VEG_IMPL_PP_CONSUME(X)
-
-#define __VEG_IMPL_PP_SEQ_HEAD_1(X)
-#define __VEG_IMPL_PP_SEQ_HEAD_0(X) X __VEG_IMPL_PP_SEQ_HEAD_1(
-
-#define __VEG_IMPL_PP_HEAD_0(arg, ...) arg
-#define __VEG_IMPL_PP_TAIL_0(arg, ...) __VA_ARGS__
-#define __VEG_IMPL_PP_HEAD_1(arg) arg
-#define __VEG_IMPL_PP_TAIL_1(arg)
-
-#define __VEG_IMPL_PP_STRINGIZE(...) #__VA_ARGS__
-
-#define __VEG_IMPL_PP_REMOVE_PAREN1(...) __VEG_IMPL_PP_REMOVE_PAREN1 __VA_ARGS__
-#define __VEG_IMPL_PP_REMOVE_PAREN2(...)                                       \
-  __VEG_PP_CAT(__VEG_IMPL_PP, __VA_ARGS__)
-#define __VEG_IMPL_PP__VEG_IMPL_PP_REMOVE_PAREN1
-
-#define __VEG_IMPL_PP_REMOVE_PAREN11(...)                                      \
-  __VEG_IMPL_PP_REMOVE_PAREN11 __VA_ARGS__
-#define __VEG_IMPL_PP_REMOVE_PAREN21(...)                                      \
-  __VEG_PP_CAT(__VEG_IMPL_PP, __VA_ARGS__)
-#define __VEG_IMPL_PP__VEG_IMPL_PP_REMOVE_PAREN11
-
-#define __VEG_PP_MAKE_TUPLE(N) __VEG_PP_CAT2(__VEG_IMPL_PP_MAKE_TUPLE, N)
-
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_1(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_REMOVE_PAREN1(Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_2(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_1(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_3(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_2(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_4(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_3(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_5(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_4(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_6(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_5(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_7(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_6(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_8(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_7(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_9(Macro, Data, Tuple)                     \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_8(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_10(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_9(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_11(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_10(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_12(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_11(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_13(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_12(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_14(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_13(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_15(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_14(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_16(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_15(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_17(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_16(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_18(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_17(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_19(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_18(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_20(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_19(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_21(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_20(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_22(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_21(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_23(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_22(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_24(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_23(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_25(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_24(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_26(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_25(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_27(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_26(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_28(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_27(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_29(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_28(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_30(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_29(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_31(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_30(Macro, Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_32(Macro, Data, Tuple)                    \
-  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
-    __VEG_IMPL_PP_TUPLE_FOR_EACH_31(Macro, Data, (__VEG_PP_TAIL Tuple))
-
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_1(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_REMOVE_PAREN1(Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_2(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_1(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_3(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_2(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_4(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_3(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_5(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_4(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_6(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_5(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_7(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_6(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_8(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_7(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_9(Macro, Start, Data, Tuple)            \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_8(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_10(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_9(    \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_11(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_10(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_12(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_11(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_13(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_12(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_14(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_13(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_15(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_14(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_16(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_15(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_17(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_16(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_18(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_17(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_19(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_18(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_20(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_19(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_21(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_20(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_22(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_21(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_23(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_22(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_24(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_23(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_25(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_24(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_26(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_25(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_27(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_26(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_28(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_27(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_29(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_28(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_30(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_29(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_31(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_30(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_32(Macro, Start, Data, Tuple)           \
-  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_31(   \
-    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
-
-#define __VEG_IMPL_PP_TRANSFORM_HELPER(I, Macro_Data, Elem)                    \
-  , __VEG_PP_HEAD Macro_Data(                                                  \
-      __VEG_IMPL_PP_INC(I), __VEG_PP_TAIL Macro_Data, Elem)
-
-#define __VEG_IMPL_PP_TRANSFORM_0(Macro, Data, Tuple)                          \
-  (Macro(0, Data, __VEG_PP_HEAD Tuple) __VEG_PP_TUPLE_FOR_EACH_I(              \
-    __VEG_IMPL_PP_TRANSFORM_HELPER, (Macro, Data), (__VEG_PP_TAIL Tuple)))
-
-#define __VEG_IMPL_PP_TRANSFORM_1(Macro, Data, Tuple)                          \
-  (Macro(0, Data, __VEG_PP_REMOVE_PAREN1(Tuple)))
-
-#define __VEG_PP_TUPLE_FOR_EACH_I(Macro, Data, Tuple)                          \
-  __VEG_PP_CAT2(__VEG_IMPL_PP_TUPLE_FOR_EACH_I_, __VEG_PP_TUPLE_SIZE(Tuple))   \
-  (Macro, 0, Data, Tuple)
-#define __VEG_PP_TUPLE_FOR_EACH(Macro, Data, Tuple)                            \
-  __VEG_PP_CAT2(__VEG_IMPL_PP_TUPLE_FOR_EACH_, __VEG_PP_TUPLE_SIZE(Tuple))     \
-  (Macro, Data, Tuple)
-
-#define __VEG_PP_TUPLE_TRANSFORM_I(Macro, Data, Tuple)                         \
-  __VEG_PP_CAT2(__VEG_IMPL_PP_TRANSFORM_,                                      \
-                __VEG_IMPL_PP_IS_1(__VEG_PP_TUPLE_SIZE(Tuple)))                \
-  (Macro, Data, Tuple)
-
-#define __VEG_PP_TUPLE_SIZE(Tuple)                                             \
-  __VEG_PP_ID(__VEG_IMPL_PP_VARIADIC_SIZE Tuple)
-#define __VEG_PP_SEQ_HEAD(Seq)                                                 \
-        __VEG_IMPL_PP_SEQ_HEAD_0 Seq)
-#define __VEG_PP_SEQ_TAIL(Seq) __VEG_IMPL_PP_CONSUME Seq
-
-#define __VEG_PP_HEAD(...)                                                     \
-  __VEG_PP_CAT2(__VEG_IMPL_PP_HEAD_,                                           \
-                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_VARIADIC_SIZE(__VA_ARGS__)))  \
-  (__VA_ARGS__)
-#define __VEG_PP_TAIL(...)                                                     \
-  __VEG_PP_CAT2(__VEG_IMPL_PP_TAIL_,                                           \
-                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_VARIADIC_SIZE(__VA_ARGS__)))  \
-  (__VA_ARGS__)
-
-#define __VEG_PP_STRINGIZE(...) __VEG_IMPL_PP_STRINGIZE(__VA_ARGS__)
-#define __VEG_PP_CAT(A, ...) __VEG_IMPL_PP_CAT(A, __VA_ARGS__)
-#define __VEG_PP_CAT2(A, ...) __VEG_IMPL_PP_CAT2(A, __VA_ARGS__)
-#define __VEG_PP_CAT3(A, ...) __VEG_IMPL_PP_CAT3(A, __VA_ARGS__)
-#define __VEG_PP_REMOVE_PAREN(...)                                             \
-  __VEG_IMPL_PP_REMOVE_PAREN2(                                                 \
-    __VEG_PP_ID(__VEG_IMPL_PP_REMOVE_PAREN1 __VA_ARGS__))
-#define __VEG_PP_REMOVE_PAREN1(...)                                            \
-  __VEG_IMPL_PP_REMOVE_PAREN21(                                                \
-    __VEG_PP_ID(__VEG_IMPL_PP_REMOVE_PAREN11 __VA_ARGS__))
-#define __VEG_PP_UNWRAP(...)                                                   \
-  __VEG_PP_ID(__VEG_PP_HEAD __VA_ARGS__ __VEG_PP_TAIL __VA_ARGS__)
-
-#endif /* end of include guard VEG_PREPROCESSOR_HPP_U2V3WRWYS */
+#ifndef VEG_PREPROCESSOR_HPP_U2V3WRWYS
+#define VEG_PREPROCESSOR_HPP_U2V3WRWYS
+
+// clang-format off
+#define __VEG_IMPL_PP_COUNT(Arg_0, Arg_1, Arg_2, Arg_3, Arg_4, Arg_5, Arg_6, Arg_7, Arg_8, Arg_9, Arg_10, Arg_11, Arg_12, Arg_13, Arg_14, Arg_15, Arg_16, Arg_17, Arg_18, Arg_19, Arg_20, Arg_21, Arg_22, Arg_23, Arg_24, Arg_25, Arg_26, Arg_27, Arg_28, Arg_29, Arg_30, Arg_31, N, ...) N
+
+#define __VEG_IMPL_PP_IS_1_1 1
+#define __VEG_IMPL_PP_IS_1_2 0
+#define __VEG_IMPL_PP_IS_1_3 0
+#define __VEG_IMPL_PP_IS_1_4 0
+#define __VEG_IMPL_PP_IS_1_5 0
+#define __VEG_IMPL_PP_IS_1_6 0
+#define __VEG_IMPL_PP_IS_1_7 0
+#define __VEG_IMPL_PP_IS_1_8 0
+#define __VEG_IMPL_PP_IS_1_9 0
+#define __VEG_IMPL_PP_IS_1_10 0
+#define __VEG_IMPL_PP_IS_1_11 0
+#define __VEG_IMPL_PP_IS_1_12 0
+#define __VEG_IMPL_PP_IS_1_13 0
+#define __VEG_IMPL_PP_IS_1_14 0
+#define __VEG_IMPL_PP_IS_1_15 0
+#define __VEG_IMPL_PP_IS_1_16 0
+#define __VEG_IMPL_PP_IS_1_17 0
+#define __VEG_IMPL_PP_IS_1_18 0
+#define __VEG_IMPL_PP_IS_1_19 0
+#define __VEG_IMPL_PP_IS_1_20 0
+#define __VEG_IMPL_PP_IS_1_21 0
+#define __VEG_IMPL_PP_IS_1_22 0
+#define __VEG_IMPL_PP_IS_1_23 0
+#define __VEG_IMPL_PP_IS_1_24 0
+#define __VEG_IMPL_PP_IS_1_25 0
+#define __VEG_IMPL_PP_IS_1_26 0
+#define __VEG_IMPL_PP_IS_1_27 0
+#define __VEG_IMPL_PP_IS_1_28 0
+#define __VEG_IMPL_PP_IS_1_29 0
+#define __VEG_IMPL_PP_IS_1_30 0
+#define __VEG_IMPL_PP_IS_1_31 0
+#define __VEG_IMPL_PP_IS_1_32 0
+#define __VEG_IMPL_PP_IS_1_33 0
+
+#define __VEG_IMPL_PP_DEC_1 0
+#define __VEG_IMPL_PP_DEC_2 1
+#define __VEG_IMPL_PP_DEC_3 2
+#define __VEG_IMPL_PP_DEC_4 3
+#define __VEG_IMPL_PP_DEC_5 4
+#define __VEG_IMPL_PP_DEC_6 5
+#define __VEG_IMPL_PP_DEC_7 6
+#define __VEG_IMPL_PP_DEC_8 7
+#define __VEG_IMPL_PP_DEC_9 8
+#define __VEG_IMPL_PP_DEC_10 9
+#define __VEG_IMPL_PP_DEC_11 10
+#define __VEG_IMPL_PP_DEC_12 11
+#define __VEG_IMPL_PP_DEC_13 12
+#define __VEG_IMPL_PP_DEC_14 13
+#define __VEG_IMPL_PP_DEC_15 14
+#define __VEG_IMPL_PP_DEC_16 15
+#define __VEG_IMPL_PP_DEC_17 16
+#define __VEG_IMPL_PP_DEC_18 17
+#define __VEG_IMPL_PP_DEC_19 18
+#define __VEG_IMPL_PP_DEC_20 19
+#define __VEG_IMPL_PP_DEC_21 20
+#define __VEG_IMPL_PP_DEC_22 21
+#define __VEG_IMPL_PP_DEC_23 22
+#define __VEG_IMPL_PP_DEC_24 23
+#define __VEG_IMPL_PP_DEC_25 24
+#define __VEG_IMPL_PP_DEC_26 25
+#define __VEG_IMPL_PP_DEC_27 26
+#define __VEG_IMPL_PP_DEC_28 27
+#define __VEG_IMPL_PP_DEC_29 28
+#define __VEG_IMPL_PP_DEC_30 29
+#define __VEG_IMPL_PP_DEC_31 30
+#define __VEG_IMPL_PP_DEC_32 31
+#define __VEG_IMPL_PP_DEC_33 32
+
+#define __VEG_IMPL_PP_INC_0 1
+#define __VEG_IMPL_PP_INC_1 2
+#define __VEG_IMPL_PP_INC_2 3
+#define __VEG_IMPL_PP_INC_3 4
+#define __VEG_IMPL_PP_INC_4 5
+#define __VEG_IMPL_PP_INC_5 6
+#define __VEG_IMPL_PP_INC_6 7
+#define __VEG_IMPL_PP_INC_7 8
+#define __VEG_IMPL_PP_INC_8 9
+#define __VEG_IMPL_PP_INC_9 10
+#define __VEG_IMPL_PP_INC_10 11
+#define __VEG_IMPL_PP_INC_11 12
+#define __VEG_IMPL_PP_INC_12 13
+#define __VEG_IMPL_PP_INC_13 14
+#define __VEG_IMPL_PP_INC_14 15
+#define __VEG_IMPL_PP_INC_15 16
+#define __VEG_IMPL_PP_INC_16 17
+#define __VEG_IMPL_PP_INC_17 18
+#define __VEG_IMPL_PP_INC_18 19
+#define __VEG_IMPL_PP_INC_19 20
+#define __VEG_IMPL_PP_INC_20 21
+#define __VEG_IMPL_PP_INC_21 22
+#define __VEG_IMPL_PP_INC_22 23
+#define __VEG_IMPL_PP_INC_23 24
+#define __VEG_IMPL_PP_INC_24 25
+#define __VEG_IMPL_PP_INC_25 26
+#define __VEG_IMPL_PP_INC_26 27
+#define __VEG_IMPL_PP_INC_27 28
+#define __VEG_IMPL_PP_INC_28 29
+#define __VEG_IMPL_PP_INC_29 30
+#define __VEG_IMPL_PP_INC_30 31
+#define __VEG_IMPL_PP_INC_31 32
+#define __VEG_IMPL_PP_INC_32 33
+
+#define __VEG_IMPL_PP_DEC_I(X) __VEG_IMPL_PP_DEC_##X
+#define __VEG_IMPL_PP_DEC(X) __VEG_IMPL_PP_DEC_I(X)
+#define __VEG_IMPL_PP_INC_I(X) __VEG_IMPL_PP_INC_##X
+#define __VEG_IMPL_PP_INC(X) __VEG_IMPL_PP_INC_I(X)
+#define __VEG_IMPL_PP_IS_1_I(X) __VEG_IMPL_PP_IS_1_##X
+#define __VEG_IMPL_PP_IS_1(X) __VEG_IMPL_PP_IS_1_I(X)
+
+#define __VEG_IMPL_PP_COMMA_IF_NOT_0_1
+#define __VEG_IMPL_PP_COMMA_IF_NOT_0_0 ,
+#define __VEG_PP_COMMA_IF_NOT_0(X) __VEG_PP_CAT2(__VEG_IMPL_PP_COMMA_IF_NOT_0_, __VEG_PP_IS_0(X))
+
+#define __VEG_PP_IS_1(X) __VEG_IMPL_PP_IS_1_I(X)
+#define __VEG_PP_IS_0(X) __VEG_PP_IS_1(__VEG_IMPL_PP_INC_I(X))
+
+#define __VEG_PP_ID(X) X
+
+#define __VEG_IMPL_PP_VARIADIC_SIZE(...) __VEG_PP_ID(__VEG_IMPL_PP_COUNT(__VA_ARGS__, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0))
+
+#define __VEG_IMPL_PP_MAKE_TUPLE0 ()
+#define __VEG_IMPL_PP_MAKE_TUPLE1 (0)
+#define __VEG_IMPL_PP_MAKE_TUPLE2 (0, 1)
+#define __VEG_IMPL_PP_MAKE_TUPLE3 (0, 1, 2)
+#define __VEG_IMPL_PP_MAKE_TUPLE4 (0, 1, 2, 3)
+#define __VEG_IMPL_PP_MAKE_TUPLE5 (0, 1, 2, 3, 4)
+#define __VEG_IMPL_PP_MAKE_TUPLE6 (0, 1, 2, 3, 4, 5)
+#define __VEG_IMPL_PP_MAKE_TUPLE7 (0, 1, 2, 3, 4, 5, 6)
+#define __VEG_IMPL_PP_MAKE_TUPLE8 (0, 1, 2, 3, 4, 5, 6, 7)
+#define __VEG_IMPL_PP_MAKE_TUPLE9 (0, 1, 2, 3, 4, 5, 6, 7, 8)
+#define __VEG_IMPL_PP_MAKE_TUPLE10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
+#define __VEG_IMPL_PP_MAKE_TUPLE11 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
+#define __VEG_IMPL_PP_MAKE_TUPLE12 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)
+#define __VEG_IMPL_PP_MAKE_TUPLE13 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)
+#define __VEG_IMPL_PP_MAKE_TUPLE14 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)
+#define __VEG_IMPL_PP_MAKE_TUPLE15 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
+#define __VEG_IMPL_PP_MAKE_TUPLE16 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
+#define __VEG_IMPL_PP_MAKE_TUPLE17 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)
+#define __VEG_IMPL_PP_MAKE_TUPLE18 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)
+#define __VEG_IMPL_PP_MAKE_TUPLE19 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)
+#define __VEG_IMPL_PP_MAKE_TUPLE20 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
+#define __VEG_IMPL_PP_MAKE_TUPLE21 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
+#define __VEG_IMPL_PP_MAKE_TUPLE22 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)
+#define __VEG_IMPL_PP_MAKE_TUPLE23 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)
+#define __VEG_IMPL_PP_MAKE_TUPLE24 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)
+#define __VEG_IMPL_PP_MAKE_TUPLE25 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)
+#define __VEG_IMPL_PP_MAKE_TUPLE26 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25)
+#define __VEG_IMPL_PP_MAKE_TUPLE27 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)
+#define __VEG_IMPL_PP_MAKE_TUPLE28 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27)
+#define __VEG_IMPL_PP_MAKE_TUPLE29 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28)
+#define __VEG_IMPL_PP_MAKE_TUPLE30 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29)
+#define __VEG_IMPL_PP_MAKE_TUPLE31 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30)
+#define __VEG_IMPL_PP_MAKE_TUPLE32 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31)
+// clang-format on
+
+#define __VEG_IMPL_PP_CAT(A, ...) A##__VA_ARGS__
+#define __VEG_IMPL_PP_CAT2(A, ...) A##__VA_ARGS__
+#define __VEG_IMPL_PP_CAT3(A, ...) A##__VA_ARGS__
+
+#define __VEG_IMPL_PP_CONSUME(X)
+
+#define __VEG_IMPL_PP_SEQ_HEAD_1(X)
+#define __VEG_IMPL_PP_SEQ_HEAD_0(X) X __VEG_IMPL_PP_SEQ_HEAD_1(
+
+#define __VEG_IMPL_PP_HEAD_0(arg, ...) arg
+#define __VEG_IMPL_PP_TAIL_0(arg, ...) __VA_ARGS__
+#define __VEG_IMPL_PP_HEAD_1(arg) arg
+#define __VEG_IMPL_PP_TAIL_1(arg)
+
+#define __VEG_IMPL_PP_STRINGIZE(...) #__VA_ARGS__
+
+#define __VEG_IMPL_PP_REMOVE_PAREN1(...) __VEG_IMPL_PP_REMOVE_PAREN1 __VA_ARGS__
+#define __VEG_IMPL_PP_REMOVE_PAREN2(...)                                       \
+  __VEG_PP_CAT(__VEG_IMPL_PP, __VA_ARGS__)
+#define __VEG_IMPL_PP__VEG_IMPL_PP_REMOVE_PAREN1
+
+#define __VEG_IMPL_PP_REMOVE_PAREN11(...)                                      \
+  __VEG_IMPL_PP_REMOVE_PAREN11 __VA_ARGS__
+#define __VEG_IMPL_PP_REMOVE_PAREN21(...)                                      \
+  __VEG_PP_CAT(__VEG_IMPL_PP, __VA_ARGS__)
+#define __VEG_IMPL_PP__VEG_IMPL_PP_REMOVE_PAREN11
+
+#define __VEG_PP_MAKE_TUPLE(N) __VEG_PP_CAT2(__VEG_IMPL_PP_MAKE_TUPLE, N)
+
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_1(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_REMOVE_PAREN1(Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_2(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_1(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_3(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_2(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_4(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_3(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_5(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_4(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_6(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_5(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_7(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_6(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_8(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_7(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_9(Macro, Data, Tuple)                     \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_8(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_10(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_9(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_11(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_10(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_12(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_11(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_13(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_12(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_14(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_13(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_15(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_14(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_16(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_15(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_17(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_16(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_18(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_17(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_19(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_18(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_20(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_19(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_21(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_20(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_22(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_21(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_23(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_22(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_24(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_23(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_25(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_24(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_26(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_25(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_27(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_26(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_28(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_27(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_29(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_28(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_30(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_29(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_31(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_30(Macro, Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_32(Macro, Data, Tuple)                    \
+  Macro(Data, __VEG_PP_HEAD Tuple)                                             \
+    __VEG_IMPL_PP_TUPLE_FOR_EACH_31(Macro, Data, (__VEG_PP_TAIL Tuple))
+
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_1(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_REMOVE_PAREN1(Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_2(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_1(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_3(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_2(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_4(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_3(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_5(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_4(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_6(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_5(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_7(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_6(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_8(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_7(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_9(Macro, Start, Data, Tuple)            \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_8(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_10(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_9(    \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_11(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_10(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_12(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_11(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_13(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_12(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_14(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_13(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_15(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_14(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_16(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_15(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_17(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_16(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_18(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_17(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_19(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_18(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_20(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_19(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_21(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_20(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_22(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_21(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_23(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_22(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_24(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_23(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_25(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_24(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_26(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_25(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_27(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_26(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_28(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_27(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_29(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_28(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_30(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_29(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_31(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_30(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+#define __VEG_IMPL_PP_TUPLE_FOR_EACH_I_32(Macro, Start, Data, Tuple)           \
+  Macro(Start, Data, __VEG_PP_HEAD Tuple) __VEG_IMPL_PP_TUPLE_FOR_EACH_I_31(   \
+    Macro, __VEG_IMPL_PP_INC(Start), Data, (__VEG_PP_TAIL Tuple))
+
+#define __VEG_IMPL_PP_TRANSFORM_HELPER(I, Macro_Data, Elem)                    \
+  , __VEG_PP_HEAD Macro_Data(                                                  \
+      __VEG_IMPL_PP_INC(I), __VEG_PP_TAIL Macro_Data, Elem)
+
+#define __VEG_IMPL_PP_TRANSFORM_0(Macro, Data, Tuple)                          \
+  (Macro(0, Data, __VEG_PP_HEAD Tuple) __VEG_PP_TUPLE_FOR_EACH_I(              \
+    __VEG_IMPL_PP_TRANSFORM_HELPER, (Macro, Data), (__VEG_PP_TAIL Tuple)))
+
+#define __VEG_IMPL_PP_TRANSFORM_1(Macro, Data, Tuple)                          \
+  (Macro(0, Data, __VEG_PP_REMOVE_PAREN1(Tuple)))
+
+#define __VEG_PP_TUPLE_FOR_EACH_I(Macro, Data, Tuple)                          \
+  __VEG_PP_CAT2(__VEG_IMPL_PP_TUPLE_FOR_EACH_I_, __VEG_PP_TUPLE_SIZE(Tuple))   \
+  (Macro, 0, Data, Tuple)
+#define __VEG_PP_TUPLE_FOR_EACH(Macro, Data, Tuple)                            \
+  __VEG_PP_CAT2(__VEG_IMPL_PP_TUPLE_FOR_EACH_, __VEG_PP_TUPLE_SIZE(Tuple))     \
+  (Macro, Data, Tuple)
+
+#define __VEG_PP_TUPLE_TRANSFORM_I(Macro, Data, Tuple)                         \
+  __VEG_PP_CAT2(__VEG_IMPL_PP_TRANSFORM_,                                      \
+                __VEG_IMPL_PP_IS_1(__VEG_PP_TUPLE_SIZE(Tuple)))                \
+  (Macro, Data, Tuple)
+
+#define __VEG_PP_TUPLE_SIZE(Tuple)                                             \
+  __VEG_PP_ID(__VEG_IMPL_PP_VARIADIC_SIZE Tuple)
+#define __VEG_PP_SEQ_HEAD(Seq)                                                 \
+        __VEG_IMPL_PP_SEQ_HEAD_0 Seq)
+#define __VEG_PP_SEQ_TAIL(Seq) __VEG_IMPL_PP_CONSUME Seq
+
+#define __VEG_PP_HEAD(...)                                                     \
+  __VEG_PP_CAT2(__VEG_IMPL_PP_HEAD_,                                           \
+                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_VARIADIC_SIZE(__VA_ARGS__)))  \
+  (__VA_ARGS__)
+#define __VEG_PP_TAIL(...)                                                     \
+  __VEG_PP_CAT2(__VEG_IMPL_PP_TAIL_,                                           \
+                __VEG_IMPL_PP_IS_1(__VEG_IMPL_PP_VARIADIC_SIZE(__VA_ARGS__)))  \
+  (__VA_ARGS__)
+
+#define __VEG_PP_STRINGIZE(...) __VEG_IMPL_PP_STRINGIZE(__VA_ARGS__)
+#define __VEG_PP_CAT(A, ...) __VEG_IMPL_PP_CAT(A, __VA_ARGS__)
+#define __VEG_PP_CAT2(A, ...) __VEG_IMPL_PP_CAT2(A, __VA_ARGS__)
+#define __VEG_PP_CAT3(A, ...) __VEG_IMPL_PP_CAT3(A, __VA_ARGS__)
+#define __VEG_PP_REMOVE_PAREN(...)                                             \
+  __VEG_IMPL_PP_REMOVE_PAREN2(                                                 \
+    __VEG_PP_ID(__VEG_IMPL_PP_REMOVE_PAREN1 __VA_ARGS__))
+#define __VEG_PP_REMOVE_PAREN1(...)                                            \
+  __VEG_IMPL_PP_REMOVE_PAREN21(                                                \
+    __VEG_PP_ID(__VEG_IMPL_PP_REMOVE_PAREN11 __VA_ARGS__))
+#define __VEG_PP_UNWRAP(...)                                                   \
+  __VEG_PP_ID(__VEG_PP_HEAD __VA_ARGS__ __VEG_PP_TAIL __VA_ARGS__)
+
+#endif /* end of include guard VEG_PREPROCESSOR_HPP_U2V3WRWYS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/prologue.hpp

 * *Ordering differences only*

```diff
@@ -1,157 +1,157 @@
-#ifdef VEG_PROLOGUE
-#error "missing epilogue"
-#endif
-#define VEG_PROLOGUE
-
-#if (__cplusplus >= 202002L || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002))
-#define VEG_WITH_CXX20_SUPPORT
-#endif
-
-#if (__cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703))
-#define VEG_WITH_CXX17_SUPPORT
-#endif
-
-#if (__cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201403))
-#define VEG_WITH_CXX14_SUPPORT
-#endif
-
-#if (__cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1600))
-#define VEG_WITH_CXX11_SUPPORT
-#endif
-
-#define VEG_ALWAYS_NOEXCEPT noexcept
-
-#ifdef __VEG_DISABLE_NOEXCEPT
-#define VEG_NOEXCEPT noexcept(false)
-#define VEG_NOEXCEPT_IF(...)                                                   \
-  noexcept(VEG_WRAP_SILENCE_WARNING((__VA_ARGS__)) && false)
-#define VEG_IS_NOEXCEPT(Expr) noexcept(Expr)
-#else
-#define VEG_NOEXCEPT noexcept(true)
-#define VEG_NOEXCEPT_IF(...) noexcept(VEG_WRAP_SILENCE_WARNING(__VA_ARGS__))
-#define VEG_IS_NOEXCEPT(Expr) noexcept(Expr)
-#endif
-#define VEG_NOEXCEPT_LIKE(Expr) VEG_NOEXCEPT_IF(VEG_IS_NOEXCEPT(Expr))
-
-#define VEG_HAS_BUILTIN_OR_0(True, False) __VEG_PP_REMOVE_PAREN(False)
-#define VEG_HAS_BUILTIN_OR_1(True, False) __VEG_PP_REMOVE_PAREN(True)
-#define VEG_HAS_BUILTIN_OR(Builtin, True, False)                               \
-  __VEG_PP_CAT(VEG_HAS_BUILTIN_OR_, VEG_HAS_BUILTIN(Builtin))(True, False)
-#define VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(Tpl, Trait, Std_Trait, ...)      \
-  VEG_DEF_CONCEPT(                                                             \
-    Tpl,                                                                       \
-    Trait,                                                                     \
-    VEG_HAS_BUILTIN_OR(__VEG_PP_CAT(__, Std_Trait),                            \
-                       ((::proxsuite::linalg::veg::_detail::assert_complete<   \
-                           ::proxsuite::linalg::veg::_detail::Wrapper<         \
-                             __VEG_PP_HEAD(__VA_ARGS__)>>(),                   \
-                         __VEG_PP_CAT(__, Std_Trait)(__VA_ARGS__))),           \
-                       (::std::Std_Trait<__VA_ARGS__>::value)))
-#define VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(Tpl, Trait, ...)                   \
-  VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(                                       \
-    Tpl, Trait, __VEG_PP_CAT(is_, Trait), __VA_ARGS__)
-
-#define VEG_EXPLICIT_COPY(Class)                                               \
-  ~Class() = default;                                                          \
-  Class(Class&&) = default;                                                    \
-  explicit Class(Class const&) = default;                                      \
-  auto operator=(Class&&)&->Class& = default;                                  \
-  auto operator=(Class const&)&->Class& = default
-
-#define VEG_NO_COPY(Class)                                                     \
-  ~Class() = default;                                                          \
-  Class(Class&&) = default;                                                    \
-  Class(Class const&) = delete;                                                \
-  auto operator=(Class&&)&->Class& = default;                                  \
-  auto operator=(Class const&)&->Class& = delete
-
-#ifdef VEG_WITH_CXX14_SUPPORT
-#define VEG_CPP14(...) __VA_ARGS__
-#else
-#define VEG_CPP14(...)
-#endif
-
-#ifdef VEG_WITH_CXX17_SUPPORT
-#define VEG_CPP17(...) __VA_ARGS__
-#else
-#define VEG_CPP17(...)
-#endif
-
-#ifdef VEG_WITH_CXX20_SUPPORT
-#define VEG_CPP20(...) __VA_ARGS__
-#else
-#define VEG_CPP20(...)
-#endif
-
-#if defined(__has_builtin)
-#define VEG_HAS_BUILTIN(x) __has_builtin(x)
-#else
-#define VEG_HAS_BUILTIN(x) 0
-#endif
-
-#ifdef VEG_WITH_CXX17_SUPPORT
-#define VEG_NODISCARD [[nodiscard]]
-#elif defined(__clang__)
-#define VEG_NODISCARD HEDLEY_WARN_UNUSED_RESULT
-#else
-#define VEG_NODISCARD
-#endif
-
-#define VEG_INTERNAL_ASSERT_PRECONDITION VEG_ASSERT
-#define VEG_INTERNAL_ASSERT_PRECONDITIONS VEG_ASSERT_ALL_OF
-
-#ifdef __VEG_INTERNAL_ASSERTIONS
-#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
-  VEG_ASSERT_ELSE("inner assertion failed", __VA_ARGS__)
-#else
-#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
-  (VEG_DEBUG_ASSERT_ELSE("inner assertion failed", __VA_ARGS__),               \
-   HEDLEY_UNREACHABLE())
-#endif
-
-#ifdef __VEG_DISABLE_NOEXCEPT
-#undef VEG_INTERNAL_ASSERT_PRECONDITION
-#undef VEG_INTERNAL_ASSERT_PRECONDITIONS
-#undef VEG_INTERNAL_ASSERT_INVARIANT
-
-#define VEG_INTERNAL_ASSERT_PRECONDITIONS(...)                                 \
-  VEG_INTERNAL_ASSERT_PRECONDITION(                                            \
-    ::proxsuite::linalg::veg::_detail::all_of({ __VA_ARGS__ }))
-
-#define VEG_INTERNAL_ASSERT_PRECONDITION(Cond)                                 \
-  (bool(Cond) ? (void)0 : ((throw 0) /* NOLINT */, (void)0))
-#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
-  (bool(__VA_ARGS__) ? (void)0 : ((throw 0), (void)0))
-#endif
-
-#ifdef VEG_WITH_CXX14_SUPPORT
-
-#define VEG_IGNORE_CPP14_EXTENSION_WARNING(...) __VA_ARGS__
-#else
-#define VEG_IGNORE_CPP14_EXTENSION_WARNING(...)
-#endif
-
-#ifdef VEG_WITH_CXX20_SUPPORT
-#define VEG_ABI _20
-#elif defined(VEG_WITH_CXX17_SUPPORT)
-#define VEG_ABI _17
-#elif defined(VEG_WITH_CXX14_SUPPORT)
-#define VEG_ABI _14
-#elif defined(VEG_WITH_CXX11_SUPPORT)
-#define VEG_ABI _11
-#else
-#error "[veg] c++ standards earlier than c++11 are not supported"
-#endif
-
-#define VEG_ABI_VERSION v0
-
-#ifdef VEG_MODE_DOCS
-#define VEG_DOC(...) __VA_ARGS__
-#define VEG_DOC_LOCATION char loc[__LINE__] = __FILE__
-#else
-#define VEG_DOC(...)
-#define VEG_DOC_LOCATION VEG_NOM_SEMICOLON
-#endif
-#define VEG_DOC_FN VEG_DOC_LOCATION;    /* proxsuite::linalg::veg::@func */
-#define VEG_DOC_CTOR VEG_DOC_LOCATION;  /* proxsuite::linalg::veg::@ctor */
-#define VEG_DOC_CLASS VEG_DOC_LOCATION; /* proxsuite::linalg::veg::@class */
+#ifdef VEG_PROLOGUE
+#error "missing epilogue"
+#endif
+#define VEG_PROLOGUE
+
+#if (__cplusplus >= 202002L || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002))
+#define VEG_WITH_CXX20_SUPPORT
+#endif
+
+#if (__cplusplus >= 201703L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703))
+#define VEG_WITH_CXX17_SUPPORT
+#endif
+
+#if (__cplusplus >= 201402L || (defined(_MSVC_LANG) && _MSVC_LANG >= 201403))
+#define VEG_WITH_CXX14_SUPPORT
+#endif
+
+#if (__cplusplus >= 201103L || (defined(_MSC_VER) && _MSC_VER >= 1600))
+#define VEG_WITH_CXX11_SUPPORT
+#endif
+
+#define VEG_ALWAYS_NOEXCEPT noexcept
+
+#ifdef __VEG_DISABLE_NOEXCEPT
+#define VEG_NOEXCEPT noexcept(false)
+#define VEG_NOEXCEPT_IF(...)                                                   \
+  noexcept(VEG_WRAP_SILENCE_WARNING((__VA_ARGS__)) && false)
+#define VEG_IS_NOEXCEPT(Expr) noexcept(Expr)
+#else
+#define VEG_NOEXCEPT noexcept(true)
+#define VEG_NOEXCEPT_IF(...) noexcept(VEG_WRAP_SILENCE_WARNING(__VA_ARGS__))
+#define VEG_IS_NOEXCEPT(Expr) noexcept(Expr)
+#endif
+#define VEG_NOEXCEPT_LIKE(Expr) VEG_NOEXCEPT_IF(VEG_IS_NOEXCEPT(Expr))
+
+#define VEG_HAS_BUILTIN_OR_0(True, False) __VEG_PP_REMOVE_PAREN(False)
+#define VEG_HAS_BUILTIN_OR_1(True, False) __VEG_PP_REMOVE_PAREN(True)
+#define VEG_HAS_BUILTIN_OR(Builtin, True, False)                               \
+  __VEG_PP_CAT(VEG_HAS_BUILTIN_OR_, VEG_HAS_BUILTIN(Builtin))(True, False)
+#define VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(Tpl, Trait, Std_Trait, ...)      \
+  VEG_DEF_CONCEPT(                                                             \
+    Tpl,                                                                       \
+    Trait,                                                                     \
+    VEG_HAS_BUILTIN_OR(__VEG_PP_CAT(__, Std_Trait),                            \
+                       ((::proxsuite::linalg::veg::_detail::assert_complete<   \
+                           ::proxsuite::linalg::veg::_detail::Wrapper<         \
+                             __VEG_PP_HEAD(__VA_ARGS__)>>(),                   \
+                         __VEG_PP_CAT(__, Std_Trait)(__VA_ARGS__))),           \
+                       (::std::Std_Trait<__VA_ARGS__>::value)))
+#define VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(Tpl, Trait, ...)                   \
+  VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(                                       \
+    Tpl, Trait, __VEG_PP_CAT(is_, Trait), __VA_ARGS__)
+
+#define VEG_EXPLICIT_COPY(Class)                                               \
+  ~Class() = default;                                                          \
+  Class(Class&&) = default;                                                    \
+  explicit Class(Class const&) = default;                                      \
+  auto operator=(Class&&)&->Class& = default;                                  \
+  auto operator=(Class const&)&->Class& = default
+
+#define VEG_NO_COPY(Class)                                                     \
+  ~Class() = default;                                                          \
+  Class(Class&&) = default;                                                    \
+  Class(Class const&) = delete;                                                \
+  auto operator=(Class&&)&->Class& = default;                                  \
+  auto operator=(Class const&)&->Class& = delete
+
+#ifdef VEG_WITH_CXX14_SUPPORT
+#define VEG_CPP14(...) __VA_ARGS__
+#else
+#define VEG_CPP14(...)
+#endif
+
+#ifdef VEG_WITH_CXX17_SUPPORT
+#define VEG_CPP17(...) __VA_ARGS__
+#else
+#define VEG_CPP17(...)
+#endif
+
+#ifdef VEG_WITH_CXX20_SUPPORT
+#define VEG_CPP20(...) __VA_ARGS__
+#else
+#define VEG_CPP20(...)
+#endif
+
+#if defined(__has_builtin)
+#define VEG_HAS_BUILTIN(x) __has_builtin(x)
+#else
+#define VEG_HAS_BUILTIN(x) 0
+#endif
+
+#ifdef VEG_WITH_CXX17_SUPPORT
+#define VEG_NODISCARD [[nodiscard]]
+#elif defined(__clang__)
+#define VEG_NODISCARD HEDLEY_WARN_UNUSED_RESULT
+#else
+#define VEG_NODISCARD
+#endif
+
+#define VEG_INTERNAL_ASSERT_PRECONDITION VEG_ASSERT
+#define VEG_INTERNAL_ASSERT_PRECONDITIONS VEG_ASSERT_ALL_OF
+
+#ifdef __VEG_INTERNAL_ASSERTIONS
+#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
+  VEG_ASSERT_ELSE("inner assertion failed", __VA_ARGS__)
+#else
+#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
+  (VEG_DEBUG_ASSERT_ELSE("inner assertion failed", __VA_ARGS__),               \
+   HEDLEY_UNREACHABLE())
+#endif
+
+#ifdef __VEG_DISABLE_NOEXCEPT
+#undef VEG_INTERNAL_ASSERT_PRECONDITION
+#undef VEG_INTERNAL_ASSERT_PRECONDITIONS
+#undef VEG_INTERNAL_ASSERT_INVARIANT
+
+#define VEG_INTERNAL_ASSERT_PRECONDITIONS(...)                                 \
+  VEG_INTERNAL_ASSERT_PRECONDITION(                                            \
+    ::proxsuite::linalg::veg::_detail::all_of({ __VA_ARGS__ }))
+
+#define VEG_INTERNAL_ASSERT_PRECONDITION(Cond)                                 \
+  (bool(Cond) ? (void)0 : ((throw 0) /* NOLINT */, (void)0))
+#define VEG_INTERNAL_ASSERT_INVARIANT(...)                                     \
+  (bool(__VA_ARGS__) ? (void)0 : ((throw 0), (void)0))
+#endif
+
+#ifdef VEG_WITH_CXX14_SUPPORT
+
+#define VEG_IGNORE_CPP14_EXTENSION_WARNING(...) __VA_ARGS__
+#else
+#define VEG_IGNORE_CPP14_EXTENSION_WARNING(...)
+#endif
+
+#ifdef VEG_WITH_CXX20_SUPPORT
+#define VEG_ABI _20
+#elif defined(VEG_WITH_CXX17_SUPPORT)
+#define VEG_ABI _17
+#elif defined(VEG_WITH_CXX14_SUPPORT)
+#define VEG_ABI _14
+#elif defined(VEG_WITH_CXX11_SUPPORT)
+#define VEG_ABI _11
+#else
+#error "[veg] c++ standards earlier than c++11 are not supported"
+#endif
+
+#define VEG_ABI_VERSION v0
+
+#ifdef VEG_MODE_DOCS
+#define VEG_DOC(...) __VA_ARGS__
+#define VEG_DOC_LOCATION char loc[__LINE__] = __FILE__
+#else
+#define VEG_DOC(...)
+#define VEG_DOC_LOCATION VEG_NOM_SEMICOLON
+#endif
+#define VEG_DOC_FN VEG_DOC_LOCATION;    /* proxsuite::linalg::veg::@func */
+#define VEG_DOC_CTOR VEG_DOC_LOCATION;  /* proxsuite::linalg::veg::@ctor */
+#define VEG_DOC_CLASS VEG_DOC_LOCATION; /* proxsuite::linalg::veg::@class */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/std.hpp

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-#ifndef VEG_STD_HPP_NS3C5ON6S
-#define VEG_STD_HPP_NS3C5ON6S
-
-#ifdef __has_include
-#define __VEG_HAS_INCLUDE(x) __has_include(x)
-#else
-#define __VEG_HAS_INCLUDE(x) 0
-#endif
-
-#include <cstdint>          // i64, u64
-#include <initializer_list> // std::initializer_list
-
-#endif /* end of include guard VEG_STD_HPP_NS3C5ON6S */
+#ifndef VEG_STD_HPP_NS3C5ON6S
+#define VEG_STD_HPP_NS3C5ON6S
+
+#ifdef __has_include
+#define __VEG_HAS_INCLUDE(x) __has_include(x)
+#else
+#define __VEG_HAS_INCLUDE(x) 0
+#endif
+
+#include <cstdint>          // i64, u64
+#include <initializer_list> // std::initializer_list
+
+#endif /* end of include guard VEG_STD_HPP_NS3C5ON6S */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/terminate.hpp

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-#ifndef VEG_TERMINATE_HPP_YMTONE4HS
-#define VEG_TERMINATE_HPP_YMTONE4HS
-
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <exception>
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-[[noreturn]] inline void
-terminate() noexcept
-{
-  std::terminate();
-}
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_TERMINATE_HPP_YMTONE4HS */
+#ifndef VEG_TERMINATE_HPP_YMTONE4HS
+#define VEG_TERMINATE_HPP_YMTONE4HS
+
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <exception>
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+[[noreturn]] inline void
+terminate() noexcept
+{
+  std::terminate();
+}
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_TERMINATE_HPP_YMTONE4HS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/typedefs.hpp

 * *Ordering differences only*

```diff
@@ -1,58 +1,58 @@
-#ifndef VEG_TYPEDEFS_HPP_2UKLEQTSS
-#define VEG_TYPEDEFS_HPP_2UKLEQTSS
-
-#include <cstdint>
-#include <cstddef>
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-namespace _meta {
-template<typename T>
-struct make_signed;
-template<>
-struct make_signed<unsigned char>
-{
-  using Type = signed char;
-};
-template<>
-struct make_signed<unsigned short>
-{
-  using Type = signed short;
-};
-template<>
-struct make_signed<unsigned int>
-{
-  using Type = signed int;
-};
-template<>
-struct make_signed<unsigned long>
-{
-  using Type = signed long;
-};
-template<>
-struct make_signed<unsigned long long>
-{
-  using Type = signed long long;
-};
-} // namespace _meta
-} // namespace _detail
-
-using usize = decltype(sizeof(0));
-using isize = _detail::_meta::make_signed<usize>::Type;
-
-using i64 = std::int64_t;
-using u64 = std::uint64_t;
-using i32 = std::int32_t;
-using u32 = std::uint32_t;
-using i16 = std::int16_t;
-using u16 = std::uint16_t;
-using u8 = std::uint8_t;
-using i8 = std::int8_t;
-
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#endif /* end of include guard VEG_TYPEDEFS_HPP_2UKLEQTSS */
+#ifndef VEG_TYPEDEFS_HPP_2UKLEQTSS
+#define VEG_TYPEDEFS_HPP_2UKLEQTSS
+
+#include <cstdint>
+#include <cstddef>
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+namespace _meta {
+template<typename T>
+struct make_signed;
+template<>
+struct make_signed<unsigned char>
+{
+  using Type = signed char;
+};
+template<>
+struct make_signed<unsigned short>
+{
+  using Type = signed short;
+};
+template<>
+struct make_signed<unsigned int>
+{
+  using Type = signed int;
+};
+template<>
+struct make_signed<unsigned long>
+{
+  using Type = signed long;
+};
+template<>
+struct make_signed<unsigned long long>
+{
+  using Type = signed long long;
+};
+} // namespace _meta
+} // namespace _detail
+
+using usize = decltype(sizeof(0));
+using isize = _detail::_meta::make_signed<usize>::Type;
+
+using i64 = std::int64_t;
+using u64 = std::uint64_t;
+using i32 = std::int32_t;
+using u32 = std::uint32_t;
+using i16 = std::int16_t;
+using u16 = std::uint16_t;
+using u8 = std::uint8_t;
+using i8 = std::int8_t;
+
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#endif /* end of include guard VEG_TYPEDEFS_HPP_2UKLEQTSS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/external/hedley.ext.hpp

```diff
@@ -1,2074 +1,2075 @@
-/* Hedley - https://nemequ.github.io/hedley
- * Created by Evan Nemerson <evan@nemerson.com>
- *
- * To the extent possible under law, the author(s) have dedicated all
- * copyright and related and neighboring rights to this software to
- * the public domain worldwide. This software is distributed without
- * any warranty.
- *
- * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
- * SPDX-License-Identifier: CC0-1.0
- */
-
-#if !defined(HEDLEY_VERSION) || (HEDLEY_VERSION < 14)
-#if defined(HEDLEY_VERSION)
-#undef HEDLEY_VERSION
-#endif
-#define HEDLEY_VERSION 14
-
-#if defined(HEDLEY_STRINGIFY_EX)
-#undef HEDLEY_STRINGIFY_EX
-#endif
-#define HEDLEY_STRINGIFY_EX(x) #x
-
-#if defined(HEDLEY_STRINGIFY)
-#undef HEDLEY_STRINGIFY
-#endif
-#define HEDLEY_STRINGIFY(x) HEDLEY_STRINGIFY_EX(x)
-
-#if defined(HEDLEY_CONCAT_EX)
-#undef HEDLEY_CONCAT_EX
-#endif
-#define HEDLEY_CONCAT_EX(a, b) a##b
-
-#if defined(HEDLEY_CONCAT)
-#undef HEDLEY_CONCAT
-#endif
-#define HEDLEY_CONCAT(a, b) HEDLEY_CONCAT_EX(a, b)
-
-#if defined(HEDLEY_CONCAT3_EX)
-#undef HEDLEY_CONCAT3_EX
-#endif
-#define HEDLEY_CONCAT3_EX(a, b, c) a##b##c
-
-#if defined(HEDLEY_CONCAT3)
-#undef HEDLEY_CONCAT3
-#endif
-#define HEDLEY_CONCAT3(a, b, c) HEDLEY_CONCAT3_EX(a, b, c)
-
-#if defined(HEDLEY_VERSION_ENCODE)
-#undef HEDLEY_VERSION_ENCODE
-#endif
-#define HEDLEY_VERSION_ENCODE(major, minor, revision)                          \
-  (((major)*1000000) + ((minor)*1000) + (revision))
-
-#if defined(HEDLEY_VERSION_DECODE_MAJOR)
-#undef HEDLEY_VERSION_DECODE_MAJOR
-#endif
-#define HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
-
-#if defined(HEDLEY_VERSION_DECODE_MINOR)
-#undef HEDLEY_VERSION_DECODE_MINOR
-#endif
-#define HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
-
-#if defined(HEDLEY_VERSION_DECODE_REVISION)
-#undef HEDLEY_VERSION_DECODE_REVISION
-#endif
-#define HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
-
-#if defined(HEDLEY_GNUC_VERSION)
-#undef HEDLEY_GNUC_VERSION
-#endif
-#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
-#define HEDLEY_GNUC_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
-#elif defined(__GNUC__)
-#define HEDLEY_GNUC_VERSION HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
-#endif
-
-#if defined(HEDLEY_GNUC_VERSION_CHECK)
-#undef HEDLEY_GNUC_VERSION_CHECK
-#endif
-#if defined(HEDLEY_GNUC_VERSION)
-#define HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)                         \
-  (HEDLEY_GNUC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_GNUC_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_MSVC_VERSION)
-#undef HEDLEY_MSVC_VERSION
-#endif
-#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
-#define HEDLEY_MSVC_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000,                              \
-                        (_MSC_FULL_VER % 10000000) / 100000,                   \
-                        (_MSC_FULL_VER % 100000) / 100)
-#elif defined(_MSC_FULL_VER) && !defined(__ICL)
-#define HEDLEY_MSVC_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000,                               \
-                        (_MSC_FULL_VER % 1000000) / 10000,                     \
-                        (_MSC_FULL_VER % 10000) / 10)
-#elif defined(_MSC_VER) && !defined(__ICL)
-#define HEDLEY_MSVC_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
-#endif
-
-#if defined(HEDLEY_MSVC_VERSION_CHECK)
-#undef HEDLEY_MSVC_VERSION_CHECK
-#endif
-#if !defined(HEDLEY_MSVC_VERSION)
-#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch) (0)
-#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
-#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
-  (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
-#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
-#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
-  (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
-#else
-#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
-  (_MSC_VER >= ((major * 100) + (minor)))
-#endif
-
-#if defined(HEDLEY_INTEL_VERSION)
-#undef HEDLEY_INTEL_VERSION
-#endif
-#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) &&           \
-  !defined(__ICL)
-#define HEDLEY_INTEL_VERSION                                                   \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    __INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
-#elif defined(__INTEL_COMPILER) && !defined(__ICL)
-#define HEDLEY_INTEL_VERSION                                                   \
-  HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
-#endif
-
-#if defined(HEDLEY_INTEL_VERSION_CHECK)
-#undef HEDLEY_INTEL_VERSION_CHECK
-#endif
-#if defined(HEDLEY_INTEL_VERSION)
-#define HEDLEY_INTEL_VERSION_CHECK(major, minor, patch)                        \
-  (HEDLEY_INTEL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_INTEL_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_INTEL_CL_VERSION)
-#undef HEDLEY_INTEL_CL_VERSION
-#endif
-#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) &&           \
-  defined(__ICL)
-#define HEDLEY_INTEL_CL_VERSION                                                \
-  HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
-#endif
-
-#if defined(HEDLEY_INTEL_CL_VERSION_CHECK)
-#undef HEDLEY_INTEL_CL_VERSION_CHECK
-#endif
-#if defined(HEDLEY_INTEL_CL_VERSION)
-#define HEDLEY_INTEL_CL_VERSION_CHECK(major, minor, patch)                     \
-  (HEDLEY_INTEL_CL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_INTEL_CL_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_PGI_VERSION)
-#undef HEDLEY_PGI_VERSION
-#endif
-#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) &&          \
-  defined(__PGIC_PATCHLEVEL__)
-#define HEDLEY_PGI_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
-#endif
-
-#if defined(HEDLEY_PGI_VERSION_CHECK)
-#undef HEDLEY_PGI_VERSION_CHECK
-#endif
-#if defined(HEDLEY_PGI_VERSION)
-#define HEDLEY_PGI_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_PGI_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_PGI_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_SUNPRO_VERSION)
-#undef HEDLEY_SUNPRO_VERSION
-#endif
-#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
-#define HEDLEY_SUNPRO_VERSION                                                  \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    (((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf),            \
-    (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf),              \
-    (__SUNPRO_C & 0xf) * 10)
-#elif defined(__SUNPRO_C)
-#define HEDLEY_SUNPRO_VERSION                                                  \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    (__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C)&0xf)
-#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
-#define HEDLEY_SUNPRO_VERSION                                                  \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    (((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf),          \
-    (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf),            \
-    (__SUNPRO_CC & 0xf) * 10)
-#elif defined(__SUNPRO_CC)
-#define HEDLEY_SUNPRO_VERSION                                                  \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    (__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC)&0xf)
-#endif
-
-#if defined(HEDLEY_SUNPRO_VERSION_CHECK)
-#undef HEDLEY_SUNPRO_VERSION_CHECK
-#endif
-#if defined(HEDLEY_SUNPRO_VERSION)
-#define HEDLEY_SUNPRO_VERSION_CHECK(major, minor, patch)                       \
-  (HEDLEY_SUNPRO_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_SUNPRO_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_EMSCRIPTEN_VERSION)
-#undef HEDLEY_EMSCRIPTEN_VERSION
-#endif
-#if defined(__EMSCRIPTEN__)
-#define HEDLEY_EMSCRIPTEN_VERSION                                              \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
-#endif
-
-#if defined(HEDLEY_EMSCRIPTEN_VERSION_CHECK)
-#undef HEDLEY_EMSCRIPTEN_VERSION_CHECK
-#endif
-#if defined(HEDLEY_EMSCRIPTEN_VERSION)
-#define HEDLEY_EMSCRIPTEN_VERSION_CHECK(major, minor, patch)                   \
-  (HEDLEY_EMSCRIPTEN_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_EMSCRIPTEN_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_ARM_VERSION)
-#undef HEDLEY_ARM_VERSION
-#endif
-#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
-#define HEDLEY_ARM_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000,                       \
-                        (__ARMCOMPILER_VERSION % 1000000) / 10000,             \
-                        (__ARMCOMPILER_VERSION % 10000) / 100)
-#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
-#define HEDLEY_ARM_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000,                             \
-                        (__ARMCC_VERSION % 1000000) / 10000,                   \
-                        (__ARMCC_VERSION % 10000) / 100)
-#endif
-
-#if defined(HEDLEY_ARM_VERSION_CHECK)
-#undef HEDLEY_ARM_VERSION_CHECK
-#endif
-#if defined(HEDLEY_ARM_VERSION)
-#define HEDLEY_ARM_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_ARM_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_ARM_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_IBM_VERSION)
-#undef HEDLEY_IBM_VERSION
-#endif
-#if defined(__ibmxl__)
-#define HEDLEY_IBM_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    __ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
-#elif defined(__xlC__) && defined(__xlC_ver__)
-#define HEDLEY_IBM_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
-#elif defined(__xlC__)
-#define HEDLEY_IBM_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
-#endif
-
-#if defined(HEDLEY_IBM_VERSION_CHECK)
-#undef HEDLEY_IBM_VERSION_CHECK
-#endif
-#if defined(HEDLEY_IBM_VERSION)
-#define HEDLEY_IBM_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_IBM_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_IBM_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_VERSION)
-#undef HEDLEY_TI_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) &&                                        \
-  (defined(__TMS470__) || defined(__TI_ARM__) || defined(__MSP430__) ||        \
-   defined(__TMS320C2000__))
-#if (__TI_COMPILER_VERSION__ >= 16000000)
-#define HEDLEY_TI_VERSION                                                      \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-#endif
-
-#if defined(HEDLEY_TI_VERSION_CHECK)
-#undef HEDLEY_TI_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_VERSION)
-#define HEDLEY_TI_VERSION_CHECK(major, minor, patch)                           \
-  (HEDLEY_TI_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_CL2000_VERSION)
-#undef HEDLEY_TI_CL2000_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
-#define HEDLEY_TI_CL2000_VERSION                                               \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_CL2000_VERSION_CHECK)
-#undef HEDLEY_TI_CL2000_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_CL2000_VERSION)
-#define HEDLEY_TI_CL2000_VERSION_CHECK(major, minor, patch)                    \
-  (HEDLEY_TI_CL2000_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_CL2000_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_CL430_VERSION)
-#undef HEDLEY_TI_CL430_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
-#define HEDLEY_TI_CL430_VERSION                                                \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_CL430_VERSION_CHECK)
-#undef HEDLEY_TI_CL430_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_CL430_VERSION)
-#define HEDLEY_TI_CL430_VERSION_CHECK(major, minor, patch)                     \
-  (HEDLEY_TI_CL430_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_CL430_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_ARMCL_VERSION)
-#undef HEDLEY_TI_ARMCL_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) &&                                        \
-  (defined(__TMS470__) || defined(__TI_ARM__))
-#define HEDLEY_TI_ARMCL_VERSION                                                \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_ARMCL_VERSION_CHECK)
-#undef HEDLEY_TI_ARMCL_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_ARMCL_VERSION)
-#define HEDLEY_TI_ARMCL_VERSION_CHECK(major, minor, patch)                     \
-  (HEDLEY_TI_ARMCL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_ARMCL_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_CL6X_VERSION)
-#undef HEDLEY_TI_CL6X_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
-#define HEDLEY_TI_CL6X_VERSION                                                 \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_CL6X_VERSION_CHECK)
-#undef HEDLEY_TI_CL6X_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_CL6X_VERSION)
-#define HEDLEY_TI_CL6X_VERSION_CHECK(major, minor, patch)                      \
-  (HEDLEY_TI_CL6X_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_CL6X_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_CL7X_VERSION)
-#undef HEDLEY_TI_CL7X_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
-#define HEDLEY_TI_CL7X_VERSION                                                 \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_CL7X_VERSION_CHECK)
-#undef HEDLEY_TI_CL7X_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_CL7X_VERSION)
-#define HEDLEY_TI_CL7X_VERSION_CHECK(major, minor, patch)                      \
-  (HEDLEY_TI_CL7X_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_CL7X_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TI_CLPRU_VERSION)
-#undef HEDLEY_TI_CLPRU_VERSION
-#endif
-#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
-#define HEDLEY_TI_CLPRU_VERSION                                                \
-  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
-                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
-                        (__TI_COMPILER_VERSION__ % 1000))
-#endif
-
-#if defined(HEDLEY_TI_CLPRU_VERSION_CHECK)
-#undef HEDLEY_TI_CLPRU_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TI_CLPRU_VERSION)
-#define HEDLEY_TI_CLPRU_VERSION_CHECK(major, minor, patch)                     \
-  (HEDLEY_TI_CLPRU_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TI_CLPRU_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_CRAY_VERSION)
-#undef HEDLEY_CRAY_VERSION
-#endif
-#if defined(_CRAYC)
-#if defined(_RELEASE_PATCHLEVEL)
-#define HEDLEY_CRAY_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
-#else
-#define HEDLEY_CRAY_VERSION                                                    \
-  HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
-#endif
-#endif
-
-#if defined(HEDLEY_CRAY_VERSION_CHECK)
-#undef HEDLEY_CRAY_VERSION_CHECK
-#endif
-#if defined(HEDLEY_CRAY_VERSION)
-#define HEDLEY_CRAY_VERSION_CHECK(major, minor, patch)                         \
-  (HEDLEY_CRAY_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_CRAY_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_IAR_VERSION)
-#undef HEDLEY_IAR_VERSION
-#endif
-#if defined(__IAR_SYSTEMS_ICC__)
-#if __VER__ > 1000
-#define HEDLEY_IAR_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    (__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
-#else
-#define HEDLEY_IAR_VERSION HEDLEY_VERSION_ENCODE(VER / 100, __VER__ % 100, 0)
-#endif
-#endif
-
-#if defined(HEDLEY_IAR_VERSION_CHECK)
-#undef HEDLEY_IAR_VERSION_CHECK
-#endif
-#if defined(HEDLEY_IAR_VERSION)
-#define HEDLEY_IAR_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_IAR_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_IAR_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_TINYC_VERSION)
-#undef HEDLEY_TINYC_VERSION
-#endif
-#if defined(__TINYC__)
-#define HEDLEY_TINYC_VERSION                                                   \
-  HEDLEY_VERSION_ENCODE(                                                       \
-    __TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
-#endif
-
-#if defined(HEDLEY_TINYC_VERSION_CHECK)
-#undef HEDLEY_TINYC_VERSION_CHECK
-#endif
-#if defined(HEDLEY_TINYC_VERSION)
-#define HEDLEY_TINYC_VERSION_CHECK(major, minor, patch)                        \
-  (HEDLEY_TINYC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_TINYC_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_DMC_VERSION)
-#undef HEDLEY_DMC_VERSION
-#endif
-#if defined(__DMC__)
-#define HEDLEY_DMC_VERSION                                                     \
-  HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
-#endif
-
-#if defined(HEDLEY_DMC_VERSION_CHECK)
-#undef HEDLEY_DMC_VERSION_CHECK
-#endif
-#if defined(HEDLEY_DMC_VERSION)
-#define HEDLEY_DMC_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_DMC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_DMC_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_COMPCERT_VERSION)
-#undef HEDLEY_COMPCERT_VERSION
-#endif
-#if defined(__COMPCERT_VERSION__)
-#define HEDLEY_COMPCERT_VERSION                                                \
-  HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000,                          \
-                        (__COMPCERT_VERSION__ / 100) % 100,                    \
-                        __COMPCERT_VERSION__ % 100)
-#endif
-
-#if defined(HEDLEY_COMPCERT_VERSION_CHECK)
-#undef HEDLEY_COMPCERT_VERSION_CHECK
-#endif
-#if defined(HEDLEY_COMPCERT_VERSION)
-#define HEDLEY_COMPCERT_VERSION_CHECK(major, minor, patch)                     \
-  (HEDLEY_COMPCERT_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_COMPCERT_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_PELLES_VERSION)
-#undef HEDLEY_PELLES_VERSION
-#endif
-#if defined(__POCC__)
-#define HEDLEY_PELLES_VERSION                                                  \
-  HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
-#endif
-
-#if defined(HEDLEY_PELLES_VERSION_CHECK)
-#undef HEDLEY_PELLES_VERSION_CHECK
-#endif
-#if defined(HEDLEY_PELLES_VERSION)
-#define HEDLEY_PELLES_VERSION_CHECK(major, minor, patch)                       \
-  (HEDLEY_PELLES_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_PELLES_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_GCC_VERSION)
-#undef HEDLEY_GCC_VERSION
-#endif
-#if defined(HEDLEY_GNUC_VERSION) && !defined(__clang__) &&                     \
-  !defined(HEDLEY_INTEL_VERSION) && !defined(HEDLEY_PGI_VERSION) &&            \
-  !defined(HEDLEY_ARM_VERSION) && !defined(HEDLEY_TI_VERSION) &&               \
-  !defined(HEDLEY_TI_ARMCL_VERSION) && !defined(HEDLEY_TI_CL430_VERSION) &&    \
-  !defined(HEDLEY_TI_CL2000_VERSION) && !defined(HEDLEY_TI_CL6X_VERSION) &&    \
-  !defined(HEDLEY_TI_CL7X_VERSION) && !defined(HEDLEY_TI_CLPRU_VERSION) &&     \
-  !defined(__COMPCERT__)
-#define HEDLEY_GCC_VERSION HEDLEY_GNUC_VERSION
-#endif
-
-#if defined(HEDLEY_GCC_VERSION_CHECK)
-#undef HEDLEY_GCC_VERSION_CHECK
-#endif
-#if defined(HEDLEY_GCC_VERSION)
-#define HEDLEY_GCC_VERSION_CHECK(major, minor, patch)                          \
-  (HEDLEY_GCC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
-#else
-#define HEDLEY_GCC_VERSION_CHECK(major, minor, patch) (0)
-#endif
-
-#if defined(HEDLEY_HAS_ATTRIBUTE)
-#undef HEDLEY_HAS_ATTRIBUTE
-#endif
-#if defined(__has_attribute)
-#define HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
-#else
-#define HEDLEY_HAS_ATTRIBUTE(attribute) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_ATTRIBUTE)
-#undef HEDLEY_GNUC_HAS_ATTRIBUTE
-#endif
-#if defined(__has_attribute)
-#define HEDLEY_GNUC_HAS_ATTRIBUTE(attribute, major, minor, patch)              \
-  __has_attribute(attribute)
-#else
-#define HEDLEY_GNUC_HAS_ATTRIBUTE(attribute, major, minor, patch)              \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_ATTRIBUTE)
-#undef HEDLEY_GCC_HAS_ATTRIBUTE
-#endif
-#if defined(__has_attribute)
-#define HEDLEY_GCC_HAS_ATTRIBUTE(attribute, major, minor, patch)               \
-  __has_attribute(attribute)
-#else
-#define HEDLEY_GCC_HAS_ATTRIBUTE(attribute, major, minor, patch)               \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_CPP_ATTRIBUTE)
-#undef HEDLEY_HAS_CPP_ATTRIBUTE
-#endif
-#if defined(__has_cpp_attribute) && defined(__cplusplus) &&                    \
-  (!defined(HEDLEY_SUNPRO_VERSION) || HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0))
-#define HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
-#else
-#define HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
-#endif
-
-#if defined(HEDLEY_HAS_CPP_ATTRIBUTE_NS)
-#undef HEDLEY_HAS_CPP_ATTRIBUTE_NS
-#endif
-#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
-#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute) (0)
-#elif !defined(HEDLEY_PGI_VERSION) && !defined(HEDLEY_IAR_VERSION) &&          \
-  (!defined(HEDLEY_SUNPRO_VERSION) ||                                          \
-   HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0)) &&                                   \
-  (!defined(HEDLEY_MSVC_VERSION) || HEDLEY_MSVC_VERSION_CHECK(19, 20, 0))
-#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute)                             \
-  HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
-#else
-#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
-#undef HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
-#endif
-#if defined(__has_cpp_attribute) && defined(__cplusplus)
-#define HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)          \
-  __has_cpp_attribute(attribute)
-#else
-#define HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)          \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
-#undef HEDLEY_GCC_HAS_CPP_ATTRIBUTE
-#endif
-#if defined(__has_cpp_attribute) && defined(__cplusplus)
-#define HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)           \
-  __has_cpp_attribute(attribute)
-#else
-#define HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)           \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_BUILTIN)
-#undef HEDLEY_HAS_BUILTIN
-#endif
-#if defined(__has_builtin)
-#define HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
-#else
-#define HEDLEY_HAS_BUILTIN(builtin) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_BUILTIN)
-#undef HEDLEY_GNUC_HAS_BUILTIN
-#endif
-#if defined(__has_builtin)
-#define HEDLEY_GNUC_HAS_BUILTIN(builtin, major, minor, patch)                  \
-  __has_builtin(builtin)
-#else
-#define HEDLEY_GNUC_HAS_BUILTIN(builtin, major, minor, patch)                  \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_BUILTIN)
-#undef HEDLEY_GCC_HAS_BUILTIN
-#endif
-#if defined(__has_builtin)
-#define HEDLEY_GCC_HAS_BUILTIN(builtin, major, minor, patch)                   \
-  __has_builtin(builtin)
-#else
-#define HEDLEY_GCC_HAS_BUILTIN(builtin, major, minor, patch)                   \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_FEATURE)
-#undef HEDLEY_HAS_FEATURE
-#endif
-#if defined(__has_feature)
-#define HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
-#else
-#define HEDLEY_HAS_FEATURE(feature) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_FEATURE)
-#undef HEDLEY_GNUC_HAS_FEATURE
-#endif
-#if defined(__has_feature)
-#define HEDLEY_GNUC_HAS_FEATURE(feature, major, minor, patch)                  \
-  __has_feature(feature)
-#else
-#define HEDLEY_GNUC_HAS_FEATURE(feature, major, minor, patch)                  \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_FEATURE)
-#undef HEDLEY_GCC_HAS_FEATURE
-#endif
-#if defined(__has_feature)
-#define HEDLEY_GCC_HAS_FEATURE(feature, major, minor, patch)                   \
-  __has_feature(feature)
-#else
-#define HEDLEY_GCC_HAS_FEATURE(feature, major, minor, patch)                   \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_EXTENSION)
-#undef HEDLEY_HAS_EXTENSION
-#endif
-#if defined(__has_extension)
-#define HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
-#else
-#define HEDLEY_HAS_EXTENSION(extension) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_EXTENSION)
-#undef HEDLEY_GNUC_HAS_EXTENSION
-#endif
-#if defined(__has_extension)
-#define HEDLEY_GNUC_HAS_EXTENSION(extension, major, minor, patch)              \
-  __has_extension(extension)
-#else
-#define HEDLEY_GNUC_HAS_EXTENSION(extension, major, minor, patch)              \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_EXTENSION)
-#undef HEDLEY_GCC_HAS_EXTENSION
-#endif
-#if defined(__has_extension)
-#define HEDLEY_GCC_HAS_EXTENSION(extension, major, minor, patch)               \
-  __has_extension(extension)
-#else
-#define HEDLEY_GCC_HAS_EXTENSION(extension, major, minor, patch)               \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
-#undef HEDLEY_HAS_DECLSPEC_ATTRIBUTE
-#endif
-#if defined(__has_declspec_attribute)
-#define HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)                               \
-  __has_declspec_attribute(attribute)
-#else
-#define HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
-#undef HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
-#endif
-#if defined(__has_declspec_attribute)
-#define HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)     \
-  __has_declspec_attribute(attribute)
-#else
-#define HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)     \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
-#undef HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
-#endif
-#if defined(__has_declspec_attribute)
-#define HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)      \
-  __has_declspec_attribute(attribute)
-#else
-#define HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)      \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_HAS_WARNING)
-#undef HEDLEY_HAS_WARNING
-#endif
-#if defined(__has_warning)
-#define HEDLEY_HAS_WARNING(warning) __has_warning(warning)
-#else
-#define HEDLEY_HAS_WARNING(warning) (0)
-#endif
-
-#if defined(HEDLEY_GNUC_HAS_WARNING)
-#undef HEDLEY_GNUC_HAS_WARNING
-#endif
-#if defined(__has_warning)
-#define HEDLEY_GNUC_HAS_WARNING(warning, major, minor, patch)                  \
-  __has_warning(warning)
-#else
-#define HEDLEY_GNUC_HAS_WARNING(warning, major, minor, patch)                  \
-  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_GCC_HAS_WARNING)
-#undef HEDLEY_GCC_HAS_WARNING
-#endif
-#if defined(__has_warning)
-#define HEDLEY_GCC_HAS_WARNING(warning, major, minor, patch)                   \
-  __has_warning(warning)
-#else
-#define HEDLEY_GCC_HAS_WARNING(warning, major, minor, patch)                   \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) ||            \
-  defined(__clang__) || HEDLEY_GCC_VERSION_CHECK(3, 0, 0) ||                   \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_IAR_VERSION_CHECK(8, 0, 0) || \
-  HEDLEY_PGI_VERSION_CHECK(18, 4, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(4, 7, 0) ||                                    \
-  HEDLEY_TI_CL430_VERSION_CHECK(2, 0, 1) ||                                    \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 1, 0) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 0, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
-  HEDLEY_CRAY_VERSION_CHECK(5, 0, 0) ||                                        \
-  HEDLEY_TINYC_VERSION_CHECK(0, 9, 17) ||                                      \
-  HEDLEY_SUNPRO_VERSION_CHECK(8, 0, 0) ||                                      \
-  (HEDLEY_IBM_VERSION_CHECK(10, 1, 0) && defined(__C99_PRAGMA_OPERATOR))
-#define HEDLEY_PRAGMA(value) _Pragma(#value)
-#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
-#define HEDLEY_PRAGMA(value) __pragma(value)
-#else
-#define HEDLEY_PRAGMA(value)
-#endif
-
-#if defined(HEDLEY_DIAGNOSTIC_PUSH)
-#undef HEDLEY_DIAGNOSTIC_PUSH
-#endif
-#if defined(HEDLEY_DIAGNOSTIC_POP)
-#undef HEDLEY_DIAGNOSTIC_POP
-#endif
-#if defined(__clang__)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
-#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
-#elif HEDLEY_GCC_VERSION_CHECK(4, 6, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
-#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
-#define HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
-#elif HEDLEY_ARM_VERSION_CHECK(5, 6, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
-#elif HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                    \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 4, 0) ||                                    \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 1, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
-#elif HEDLEY_PELLES_VERSION_CHECK(2, 90, 0)
-#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
-#define HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
-#else
-#define HEDLEY_DIAGNOSTIC_PUSH
-#define HEDLEY_DIAGNOSTIC_POP
-#endif
-
-/* HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
-   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
-#if defined(HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
-#undef HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
-#endif
-#if defined(__cplusplus)
-#if HEDLEY_HAS_WARNING("-Wc++98-compat")
-#if HEDLEY_HAS_WARNING("-Wc++17-extensions")
-#if HEDLEY_HAS_WARNING("-Wc++1z-extensions")
-#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
-    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"")                 \
-      _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"")               \
-        xpr HEDLEY_DIAGNOSTIC_POP
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
-    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"")                 \
-      xpr HEDLEY_DIAGNOSTIC_POP
-#endif
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
-    xpr HEDLEY_DIAGNOSTIC_POP
-#endif
-#endif
-#endif
-#if !defined(HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
-#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
-#endif
-
-#if defined(HEDLEY_CONST_CAST)
-#undef HEDLEY_CONST_CAST
-#endif
-#if defined(__cplusplus)
-#define HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
-#elif HEDLEY_HAS_WARNING("-Wcast-qual") ||                                     \
-  HEDLEY_GCC_VERSION_CHECK(4, 6, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_CONST_CAST(T, expr)                                             \
-  (__extension__({                                                             \
-    HEDLEY_DIAGNOSTIC_PUSH                                                     \
-    HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL((T)(expr));                            \
-    HEDLEY_DIAGNOSTIC_POP                                                      \
-  }))
-#else
-#define HEDLEY_CONST_CAST(T, expr) ((T)(expr))
-#endif
-
-#if defined(HEDLEY_REINTERPRET_CAST)
-#undef HEDLEY_REINTERPRET_CAST
-#endif
-#if defined(__cplusplus)
-#define HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
-#else
-#define HEDLEY_REINTERPRET_CAST(T, expr) ((T)(expr))
-#endif
-
-#if defined(HEDLEY_STATIC_CAST)
-#undef HEDLEY_STATIC_CAST
-#endif
-#if defined(__cplusplus)
-#define HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
-#else
-#define HEDLEY_STATIC_CAST(T, expr) ((T)(expr))
-#endif
-
-#if defined(HEDLEY_CPP_CAST)
-#undef HEDLEY_CPP_CAST
-#endif
-#if defined(__cplusplus)
-#if HEDLEY_HAS_WARNING("-Wold-style-cast")
-#define HEDLEY_CPP_CAST(T, expr)                                               \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wold-style-cast\"")((T)(expr))          \
-    HEDLEY_DIAGNOSTIC_POP
-#elif HEDLEY_IAR_VERSION_CHECK(8, 3, 0)
-#define HEDLEY_CPP_CAST(T, expr)                                               \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("diag_suppress=Pe137") HEDLEY_DIAGNOSTIC_POP
-#else
-#define HEDLEY_CPP_CAST(T, expr) ((T)(expr))
-#endif
-#else
-#define HEDLEY_CPP_CAST(T, expr) (expr)
-#endif
-
-#if defined(HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
-#undef HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
-#endif
-#if HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
-#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("warning(disable:1478 1786)")
-#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  __pragma(warning(disable : 1478 1786))
-#elif HEDLEY_PGI_VERSION_CHECK(20, 7, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("diag_suppress 1215,1216,1444,1445")
-#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
-#elif HEDLEY_GCC_VERSION_CHECK(4, 3, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
-#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable : 4996))
-#elif HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                    \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) && !defined(__cplusplus)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) && defined(__cplusplus)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
-  _Pragma("diag_suppress=Pe1444,Pe1215")
-#elif HEDLEY_PELLES_VERSION_CHECK(2, 90, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
-#endif
-
-#if defined(HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
-#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
-#endif
-#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
-  _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
-#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
-  _Pragma("warning(disable:161)")
-#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
-  __pragma(warning(disable : 161))
-#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
-#elif HEDLEY_GCC_VERSION_CHECK(4, 3, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
-  _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
-#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
-  __pragma(warning(disable : 4068))
-#elif HEDLEY_TI_VERSION_CHECK(16, 9, 0) ||                                     \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
-#elif HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
-#endif
-
-#if defined(HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
-#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
-#endif
-#if HEDLEY_HAS_WARNING("-Wunknown-attributes")
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
-#elif HEDLEY_GCC_VERSION_CHECK(4, 6, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
-#elif HEDLEY_INTEL_VERSION_CHECK(17, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("warning(disable:1292)")
-#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  __pragma(warning(disable : 1292))
-#elif HEDLEY_MSVC_VERSION_CHECK(19, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  __pragma(warning(disable : 5030))
-#elif HEDLEY_PGI_VERSION_CHECK(20, 7, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("diag_suppress 1097,1098")
-#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("diag_suppress 1097")
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 14, 0) && defined(__cplusplus)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("error_messages(off,attrskipunsup)")
-#elif HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||                                     \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("diag_suppress 1173")
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
-  _Pragma("diag_suppress=Pe1097")
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
-#endif
-
-#if defined(HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
-#undef HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
-#endif
-#if HEDLEY_HAS_WARNING("-Wcast-qual")
-#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
-  _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
-#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
-  _Pragma("warning(disable:2203 2331)")
-#elif HEDLEY_GCC_VERSION_CHECK(3, 0, 0)
-#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
-  _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
-#else
-#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
-#endif
-
-#if defined(HEDLEY_DEPRECATED)
-#undef HEDLEY_DEPRECATED
-#endif
-#if defined(HEDLEY_DEPRECATED_FOR)
-#undef HEDLEY_DEPRECATED_FOR
-#endif
-#if HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                     \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " #since))
-#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
-  __declspec(deprecated("Since " #since "; use " #replacement))
-#elif HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) ||               \
-  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_ARM_VERSION_CHECK(5, 6, 0) ||                                         \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) ||                                     \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) || HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||  \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(18, 1, 0) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
-#define HEDLEY_DEPRECATED(since)                                               \
-  __attribute__((__deprecated__("Since " #since)))
-#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
-  __attribute__((__deprecated__("Since " #since "; use " #replacement)))
-#elif defined(__cplusplus) && (__cplusplus >= 201402L)
-#define HEDLEY_DEPRECATED(since)                                               \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since"            \
-                                                            " " #since)]])
-#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(                                \
-    [[deprecated("Since " #since "; use " #replacement)]])
-#elif HEDLEY_HAS_ATTRIBUTE(deprecated) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) || \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||   \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
-#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
-  __attribute__((__deprecated__))
-#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
-  HEDLEY_PELLES_VERSION_CHECK(6, 50, 0) ||                                     \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_DEPRECATED(since) __declspec(deprecated)
-#define HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_DEPRECATED(since) _Pragma("deprecated")
-#define HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
-#else
-#define HEDLEY_DEPRECATED(since)
-#define HEDLEY_DEPRECATED_FOR(since, replacement)
-#endif
-
-#if defined(HEDLEY_UNAVAILABLE)
-#undef HEDLEY_UNAVAILABLE
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(warning) || HEDLEY_GCC_VERSION_CHECK(4, 3, 0) ||      \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_UNAVAILABLE(available_since)                                    \
-  __attribute__((__warning__("Not available until " #available_since)))
-#else
-#define HEDLEY_UNAVAILABLE(available_since)
-#endif
-
-#if defined(HEDLEY_WARN_UNUSED_RESULT)
-#undef HEDLEY_WARN_UNUSED_RESULT
-#endif
-#if defined(HEDLEY_WARN_UNUSED_RESULT_MSG)
-#undef HEDLEY_WARN_UNUSED_RESULT_MSG
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(warn_unused_result) ||                                \
-  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
-  (HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0) && defined(__cplusplus)) ||           \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
-#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
-  __attribute__((__warn_unused_result__))
-#elif (HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
-#define HEDLEY_WARN_UNUSED_RESULT                                              \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
-#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
-#elif HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
-#define HEDLEY_WARN_UNUSED_RESULT                                              \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
-#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
-#elif defined(_Check_return_) /* SAL */
-#define HEDLEY_WARN_UNUSED_RESULT _Check_return_
-#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
-#else
-#define HEDLEY_WARN_UNUSED_RESULT
-#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
-#endif
-
-#if defined(HEDLEY_SENTINEL)
-#undef HEDLEY_SENTINEL
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(sentinel) || HEDLEY_GCC_VERSION_CHECK(4, 0, 0) ||     \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(5, 4, 0)
-#define HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
-#else
-#define HEDLEY_SENTINEL(position)
-#endif
-
-#if defined(HEDLEY_NO_RETURN)
-#undef HEDLEY_NO_RETURN
-#endif
-#if HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_NO_RETURN __noreturn
-#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_NO_RETURN __attribute__((__noreturn__))
-#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
-#define HEDLEY_NO_RETURN _Noreturn
-#elif defined(__cplusplus) && (__cplusplus >= 201103L)
-#define HEDLEY_NO_RETURN                                                       \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
-#elif HEDLEY_HAS_ATTRIBUTE(noreturn) || HEDLEY_GCC_VERSION_CHECK(3, 2, 0) ||   \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_NO_RETURN __attribute__((__noreturn__))
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
-#define HEDLEY_NO_RETURN _Pragma("does_not_return")
-#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_NO_RETURN __declspec(noreturn)
-#elif HEDLEY_TI_CL6X_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)
-#define HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
-#elif HEDLEY_COMPCERT_VERSION_CHECK(3, 2, 0)
-#define HEDLEY_NO_RETURN __attribute((noreturn))
-#elif HEDLEY_PELLES_VERSION_CHECK(9, 0, 0)
-#define HEDLEY_NO_RETURN __declspec(noreturn)
-#else
-#define HEDLEY_NO_RETURN
-#endif
-
-#if defined(HEDLEY_NO_ESCAPE)
-#undef HEDLEY_NO_ESCAPE
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(noescape)
-#define HEDLEY_NO_ESCAPE __attribute__((__noescape__))
-#else
-#define HEDLEY_NO_ESCAPE
-#endif
-
-#if defined(HEDLEY_UNREACHABLE)
-#undef HEDLEY_UNREACHABLE
-#endif
-#if defined(HEDLEY_UNREACHABLE_RETURN)
-#undef HEDLEY_UNREACHABLE_RETURN
-#endif
-#if defined(HEDLEY_ASSUME)
-#undef HEDLEY_ASSUME
-#endif
-#if HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                    \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_ASSUME(expr) __assume(expr)
-#elif HEDLEY_HAS_BUILTIN(__builtin_assume)
-#define HEDLEY_ASSUME(expr) __builtin_assume(expr)
-#elif HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                               \
-  HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0)
-#if defined(__cplusplus)
-#define HEDLEY_ASSUME(expr) std::_nassert(expr)
-#else
-#define HEDLEY_ASSUME(expr) _nassert(expr)
-#endif
-#endif
-#if (HEDLEY_HAS_BUILTIN(__builtin_unreachable) &&                              \
-     (!defined(HEDLEY_ARM_VERSION))) ||                                        \
-  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_PGI_VERSION_CHECK(18, 10, 0) ||  \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_IBM_VERSION_CHECK(13, 1, 5)
-#define HEDLEY_UNREACHABLE() __builtin_unreachable()
-#elif defined(HEDLEY_ASSUME)
-#define HEDLEY_UNREACHABLE() HEDLEY_ASSUME(0)
-#endif
-#if !defined(HEDLEY_ASSUME)
-#if defined(HEDLEY_UNREACHABLE)
-#define HEDLEY_ASSUME(expr)                                                    \
-  HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (HEDLEY_UNREACHABLE(), 1)))
-#else
-#define HEDLEY_ASSUME(expr) HEDLEY_STATIC_CAST(void, expr)
-#endif
-#endif
-#if defined(HEDLEY_UNREACHABLE)
-#if HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                                 \
-  HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0)
-#define HEDLEY_UNREACHABLE_RETURN(value)                                       \
-  return (HEDLEY_STATIC_CAST(void, HEDLEY_ASSUME(0)), (value))
-#else
-#define HEDLEY_UNREACHABLE_RETURN(value) HEDLEY_UNREACHABLE()
-#endif
-#else
-#define HEDLEY_UNREACHABLE_RETURN(value) return (value)
-#endif
-#if !defined(HEDLEY_UNREACHABLE)
-#define HEDLEY_UNREACHABLE() HEDLEY_ASSUME(0)
-#endif
-
-HEDLEY_DIAGNOSTIC_PUSH
-#if HEDLEY_HAS_WARNING("-Wpedantic")
-#pragma clang diagnostic ignored "-Wpedantic"
-#endif
-#if HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
-#pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
-#endif
-#if HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros", 4, 0, 0)
-#if defined(__clang__)
-#pragma clang diagnostic ignored "-Wvariadic-macros"
-#elif defined(HEDLEY_GCC_VERSION)
-#pragma GCC diagnostic ignored "-Wvariadic-macros"
-#endif
-#endif
-#if defined(HEDLEY_NON_NULL)
-#undef HEDLEY_NON_NULL
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(nonnull) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||      \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0)
-#define HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
-#else
-#define HEDLEY_NON_NULL(...)
-#endif
-HEDLEY_DIAGNOSTIC_POP
-
-#if defined(HEDLEY_PRINTF_FORMAT)
-#undef HEDLEY_PRINTF_FORMAT
-#endif
-#if defined(__MINGW32__) && HEDLEY_GCC_HAS_ATTRIBUTE(format, 4, 4, 0) &&       \
-  !defined(__USE_MINGW_ANSI_STDIO)
-#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
-  __attribute__((__format__(ms_printf, string_idx, first_to_check)))
-#elif defined(__MINGW32__) && HEDLEY_GCC_HAS_ATTRIBUTE(format, 4, 4, 0) &&     \
-  defined(__USE_MINGW_ANSI_STDIO)
-#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
-  __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
-#elif HEDLEY_HAS_ATTRIBUTE(format) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||     \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(5, 6, 0) || \
-  HEDLEY_IBM_VERSION_CHECK(10, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||  \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
-  __attribute__((__format__(__printf__, string_idx, first_to_check)))
-#elif HEDLEY_PELLES_VERSION_CHECK(6, 0, 0)
-#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
-  __declspec(vaformat(printf, string_idx, first_to_check))
-#else
-#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)
-#endif
-
-#if defined(HEDLEY_CONSTEXPR)
-#undef HEDLEY_CONSTEXPR
-#endif
-#if defined(__cplusplus)
-#if __cplusplus >= 201103L
-#define HEDLEY_CONSTEXPR HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
-#endif
-#endif
-#if !defined(HEDLEY_CONSTEXPR)
-#define HEDLEY_CONSTEXPR
-#endif
-
-#if defined(HEDLEY_PREDICT)
-#undef HEDLEY_PREDICT
-#endif
-#if defined(HEDLEY_LIKELY)
-#undef HEDLEY_LIKELY
-#endif
-#if defined(HEDLEY_UNLIKELY)
-#undef HEDLEY_UNLIKELY
-#endif
-#if defined(HEDLEY_UNPREDICTABLE)
-#undef HEDLEY_UNPREDICTABLE
-#endif
-#if HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
-#define HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
-#endif
-#if (HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) &&                  \
-     !defined(HEDLEY_PGI_VERSION)) ||                                          \
-  HEDLEY_GCC_VERSION_CHECK(9, 0, 0)
-#define HEDLEY_PREDICT(expr, value, probability)                               \
-  __builtin_expect_with_probability((expr), (value), (probability))
-#define HEDLEY_PREDICT_TRUE(expr, probability)                                 \
-  __builtin_expect_with_probability(!!(expr), 1, (probability))
-#define HEDLEY_PREDICT_FALSE(expr, probability)                                \
-  __builtin_expect_with_probability(!!(expr), 0, (probability))
-#define HEDLEY_LIKELY(expr) __builtin_expect(!!(expr), 1)
-#define HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
-#elif (HEDLEY_HAS_BUILTIN(__builtin_expect) &&                                 \
-       !defined(HEDLEY_INTEL_CL_VERSION)) ||                                   \
-  HEDLEY_GCC_VERSION_CHECK(3, 0, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  (HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0) && defined(__cplusplus)) ||           \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(4, 7, 0) ||                                    \
-  HEDLEY_TI_CL430_VERSION_CHECK(3, 1, 0) ||                                    \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 1, 0) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
-  HEDLEY_TINYC_VERSION_CHECK(0, 9, 27) || HEDLEY_CRAY_VERSION_CHECK(8, 1, 0)
-#define HEDLEY_PREDICT(expr, expected, probability)                            \
-  (((probability) >= 0.9) ? __builtin_expect((expr), (expected))               \
-                          : (HEDLEY_STATIC_CAST(void, expected), (expr)))
-#define HEDLEY_PREDICT_TRUE(expr, probability)                                 \
-  (__extension__({                                                             \
-    double hedley_probability_ = (probability);                                \
-    ((hedley_probability_ >= 0.9)                                              \
-       ? __builtin_expect(!!(expr), 1)                                         \
-       : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0)         \
-                                       : !!(expr)));                           \
-  }))
-#define HEDLEY_PREDICT_FALSE(expr, probability)                                \
-  (__extension__({                                                             \
-    double hedley_probability_ = (probability);                                \
-    ((hedley_probability_ >= 0.9)                                              \
-       ? __builtin_expect(!!(expr), 0)                                         \
-       : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1)         \
-                                       : !!(expr)));                           \
-  }))
-#define HEDLEY_LIKELY(expr) __builtin_expect(!!(expr), 1)
-#define HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
-#else
-#define HEDLEY_PREDICT(expr, expected, probability)                            \
-  (HEDLEY_STATIC_CAST(void, expected), (expr))
-#define HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
-#define HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
-#define HEDLEY_LIKELY(expr) (!!(expr))
-#define HEDLEY_UNLIKELY(expr) (!!(expr))
-#endif
-#if !defined(HEDLEY_UNPREDICTABLE)
-#define HEDLEY_UNPREDICTABLE(expr) HEDLEY_PREDICT(expr, 1, 0.5)
-#endif
-
-#if defined(HEDLEY_MALLOC)
-#undef HEDLEY_MALLOC
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(malloc) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||       \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(12, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_MALLOC __attribute__((__malloc__))
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
-#define HEDLEY_MALLOC _Pragma("returns_new_memory")
-#elif HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_MALLOC __declspec(restrict)
-#else
-#define HEDLEY_MALLOC
-#endif
-
-#if defined(HEDLEY_PURE)
-#undef HEDLEY_PURE
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(pure) || HEDLEY_GCC_VERSION_CHECK(2, 96, 0) ||        \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_PURE __attribute__((__pure__))
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
-#define HEDLEY_PURE _Pragma("does_not_write_global_data")
-#elif defined(__cplusplus) && (HEDLEY_TI_CL430_VERSION_CHECK(2, 0, 1) ||       \
-                               HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0) ||        \
-                               HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0))
-#define HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
-#else
-#define HEDLEY_PURE
-#endif
-
-#if defined(HEDLEY_CONST)
-#undef HEDLEY_CONST
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(const) || HEDLEY_GCC_VERSION_CHECK(2, 5, 0) ||        \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
-#define HEDLEY_CONST __attribute__((__const__))
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
-#define HEDLEY_CONST _Pragma("no_side_effect")
-#else
-#define HEDLEY_CONST HEDLEY_PURE
-#endif
-
-#if defined(HEDLEY_RESTRICT)
-#undef HEDLEY_RESTRICT
-#endif
-#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&              \
-  !defined(__cplusplus)
-#define HEDLEY_RESTRICT restrict
-#elif HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||                                     \
-  HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                       \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) ||                                       \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 4) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 1, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  (HEDLEY_SUNPRO_VERSION_CHECK(5, 14, 0) && defined(__cplusplus)) ||           \
-  HEDLEY_IAR_VERSION_CHECK(8, 0, 0) || defined(__clang__)
-#define HEDLEY_RESTRICT __restrict
-#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 3, 0) && !defined(__cplusplus)
-#define HEDLEY_RESTRICT _Restrict
-#else
-#define HEDLEY_RESTRICT
-#endif
-
-#if defined(HEDLEY_INLINE)
-#undef HEDLEY_INLINE
-#endif
-#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) ||            \
-  (defined(__cplusplus) && (__cplusplus >= 199711L))
-#define HEDLEY_INLINE inline
-#elif defined(HEDLEY_GCC_VERSION) || HEDLEY_ARM_VERSION_CHECK(6, 2, 0)
-#define HEDLEY_INLINE __inline__
-#elif HEDLEY_MSVC_VERSION_CHECK(12, 0, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) ||                                         \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 1, 0) ||                                    \
-  HEDLEY_TI_CL430_VERSION_CHECK(3, 1, 0) ||                                    \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_INLINE __inline
-#else
-#define HEDLEY_INLINE
-#endif
-
-#if defined(HEDLEY_ALWAYS_INLINE)
-#undef HEDLEY_ALWAYS_INLINE
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(always_inline) ||                                     \
-  HEDLEY_GCC_VERSION_CHECK(4, 0, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) HEDLEY_INLINE
-#elif HEDLEY_MSVC_VERSION_CHECK(12, 0, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_ALWAYS_INLINE __forceinline
-#elif defined(__cplusplus) && (HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||       \
-                               HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||       \
-                               HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||      \
-                               HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||        \
-                               HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||        \
-                               HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0))
-#define HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
-#else
-#define HEDLEY_ALWAYS_INLINE HEDLEY_INLINE
-#endif
-
-#if defined(HEDLEY_NEVER_INLINE)
-#undef HEDLEY_NEVER_INLINE
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(noinline) || HEDLEY_GCC_VERSION_CHECK(4, 0, 0) ||     \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
-  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
-  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
-  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
-  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
-  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
-   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
-  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
-  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
-  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
-#define HEDLEY_NEVER_INLINE __attribute__((__noinline__))
-#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_NEVER_INLINE __declspec(noinline)
-#elif HEDLEY_PGI_VERSION_CHECK(10, 2, 0)
-#define HEDLEY_NEVER_INLINE _Pragma("noinline")
-#elif HEDLEY_TI_CL6X_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)
-#define HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_NEVER_INLINE _Pragma("inline=never")
-#elif HEDLEY_COMPCERT_VERSION_CHECK(3, 2, 0)
-#define HEDLEY_NEVER_INLINE __attribute((noinline))
-#elif HEDLEY_PELLES_VERSION_CHECK(9, 0, 0)
-#define HEDLEY_NEVER_INLINE __declspec(noinline)
-#else
-#define HEDLEY_NEVER_INLINE
-#endif
-
-#if defined(HEDLEY_PRIVATE)
-#undef HEDLEY_PRIVATE
-#endif
-#if defined(HEDLEY_PUBLIC)
-#undef HEDLEY_PUBLIC
-#endif
-#if defined(HEDLEY_IMPORT)
-#undef HEDLEY_IMPORT
-#endif
-#if defined(_WIN32) || defined(__CYGWIN__)
-#define HEDLEY_PRIVATE
-#define HEDLEY_PUBLIC __declspec(dllexport)
-#define HEDLEY_IMPORT __declspec(dllimport)
-#else
-#if HEDLEY_HAS_ATTRIBUTE(visibility) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||   \
-  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || \
-  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) ||                                        \
-  (defined(__TI_EABI__) && ((HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&          \
-                             defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||         \
-                            HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0)))
-#define HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
-#define HEDLEY_PUBLIC __attribute__((__visibility__("default")))
-#else
-#define HEDLEY_PRIVATE
-#define HEDLEY_PUBLIC
-#endif
-#define HEDLEY_IMPORT extern
-#endif
-
-#if defined(HEDLEY_NO_THROW)
-#undef HEDLEY_NO_THROW
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(nothrow) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||      \
-  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_NO_THROW __attribute__((__nothrow__))
-#elif HEDLEY_MSVC_VERSION_CHECK(13, 1, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
-  HEDLEY_ARM_VERSION_CHECK(4, 1, 0)
-#define HEDLEY_NO_THROW __declspec(nothrow)
-#else
-#define HEDLEY_NO_THROW
-#endif
-
-#if defined(HEDLEY_FALL_THROUGH)
-#undef HEDLEY_FALL_THROUGH
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(fallthrough) || HEDLEY_GCC_VERSION_CHECK(7, 0, 0)
-#define HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
-#elif HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang, fallthrough)
-#define HEDLEY_FALL_THROUGH                                                    \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
-#elif HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
-#define HEDLEY_FALL_THROUGH                                                    \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
-#elif defined(__fallthrough) /* SAL */
-#define HEDLEY_FALL_THROUGH __fallthrough
-#else
-#define HEDLEY_FALL_THROUGH
-#endif
-
-#if defined(HEDLEY_RETURNS_NON_NULL)
-#undef HEDLEY_RETURNS_NON_NULL
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || HEDLEY_GCC_VERSION_CHECK(4, 9, 0)
-#define HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
-#elif defined(_Ret_notnull_) /* SAL */
-#define HEDLEY_RETURNS_NON_NULL _Ret_notnull_
-#else
-#define HEDLEY_RETURNS_NON_NULL
-#endif
-
-#if defined(HEDLEY_ARRAY_PARAM)
-#undef HEDLEY_ARRAY_PARAM
-#endif
-#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&              \
-  !defined(__STDC_NO_VLA__) && !defined(__cplusplus) &&                        \
-  !defined(HEDLEY_PGI_VERSION) && !defined(HEDLEY_TINYC_VERSION)
-#define HEDLEY_ARRAY_PARAM(name) (name)
-#else
-#define HEDLEY_ARRAY_PARAM(name)
-#endif
-
-#if defined(HEDLEY_IS_CONSTANT)
-#undef HEDLEY_IS_CONSTANT
-#endif
-#if defined(HEDLEY_REQUIRE_CONSTEXPR)
-#undef HEDLEY_REQUIRE_CONSTEXPR
-#endif
-/* HEDLEY_IS_CONSTEXPR_ is for
-   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
-#if defined(HEDLEY_IS_CONSTEXPR_)
-#undef HEDLEY_IS_CONSTEXPR_
-#endif
-#if HEDLEY_HAS_BUILTIN(__builtin_constant_p) ||                                \
-  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_TINYC_VERSION_CHECK(0, 9, 19) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || \
-  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) ||                                        \
-  HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||                                     \
-  (HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0) && !defined(__cplusplus)) ||          \
-  HEDLEY_CRAY_VERSION_CHECK(8, 1, 0)
-#define HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
-#endif
-#if !defined(__cplusplus)
-#if HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) ||                        \
-  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
-  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) || HEDLEY_CRAY_VERSION_CHECK(8, 1, 0) ||  \
-  HEDLEY_ARM_VERSION_CHECK(5, 4, 0) || HEDLEY_TINYC_VERSION_CHECK(0, 9, 24)
-#if defined(__INTPTR_TYPE__)
-#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
-  __builtin_types_compatible_p(                                                \
-    __typeof__((1 ? (void*)((__INTPTR_TYPE__)((expr)*0)) : (int*)0)), int*)
-#else
-#include <stdint.h>
-#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
-  __builtin_types_compatible_p(                                                \
-    __typeof__((1 ? (void*)((intptr_t)((expr)*0)) : (int*)0)), int*)
-#endif
-#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) &&           \
-       !defined(HEDLEY_SUNPRO_VERSION) && !defined(HEDLEY_PGI_VERSION) &&      \
-       !defined(HEDLEY_IAR_VERSION)) ||                                        \
-  HEDLEY_HAS_EXTENSION(c_generic_selections) ||                                \
-  HEDLEY_GCC_VERSION_CHECK(4, 9, 0) || HEDLEY_INTEL_VERSION_CHECK(17, 0, 0) || \
-  HEDLEY_IBM_VERSION_CHECK(12, 1, 0) || HEDLEY_ARM_VERSION_CHECK(5, 3, 0)
-#if defined(__INTPTR_TYPE__)
-#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
-  _Generic(                                                                    \
-    (1 ? (void*)((__INTPTR_TYPE__)((expr)*0)) : (int*)0), int* : 1, void* : 0)
-#else
-#include <stdint.h>
-#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
-  _Generic((1 ? (void*)((intptr_t)*0) : (int*)0), int* : 1, void* : 0)
-#endif
-#elif defined(HEDLEY_GCC_VERSION) || defined(HEDLEY_INTEL_VERSION) ||          \
-  defined(HEDLEY_TINYC_VERSION) || defined(HEDLEY_TI_ARMCL_VERSION) ||         \
-  HEDLEY_TI_CL430_VERSION_CHECK(18, 12, 0) ||                                  \
-  defined(HEDLEY_TI_CL2000_VERSION) || defined(HEDLEY_TI_CL6X_VERSION) ||      \
-  defined(HEDLEY_TI_CL7X_VERSION) || defined(HEDLEY_TI_CLPRU_VERSION) ||       \
-  defined(__clang__)
-#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
-  (sizeof(void) != sizeof(*(1 ? ((void*)((expr)*0L))                           \
-                              : ((struct { char v[sizeof(void) * 2]; }*)1))))
-#endif
-#endif
-#if defined(HEDLEY_IS_CONSTEXPR_)
-#if !defined(HEDLEY_IS_CONSTANT)
-#define HEDLEY_IS_CONSTANT(expr) HEDLEY_IS_CONSTEXPR_(expr)
-#endif
-#define HEDLEY_REQUIRE_CONSTEXPR(expr)                                         \
-  (HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
-#else
-#if !defined(HEDLEY_IS_CONSTANT)
-#define HEDLEY_IS_CONSTANT(expr) (0)
-#endif
-#define HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
-#endif
-
-#if defined(HEDLEY_BEGIN_C_DECLS)
-#undef HEDLEY_BEGIN_C_DECLS
-#endif
-#if defined(HEDLEY_END_C_DECLS)
-#undef HEDLEY_END_C_DECLS
-#endif
-#if defined(HEDLEY_C_DECL)
-#undef HEDLEY_C_DECL
-#endif
-#if defined(__cplusplus)
-#define HEDLEY_BEGIN_C_DECLS                                                   \
-  extern "C"                                                                   \
-  {
-#define HEDLEY_END_C_DECLS }
-#define HEDLEY_C_DECL extern "C"
-#else
-#define HEDLEY_BEGIN_C_DECLS
-#define HEDLEY_END_C_DECLS
-#define HEDLEY_C_DECL
-#endif
-
-#if defined(HEDLEY_STATIC_ASSERT)
-#undef HEDLEY_STATIC_ASSERT
-#endif
-#if !defined(__cplusplus) &&                                                   \
-  ((defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) ||             \
-   (HEDLEY_HAS_FEATURE(c_static_assert) &&                                     \
-    !defined(HEDLEY_INTEL_CL_VERSION)) ||                                      \
-   HEDLEY_GCC_VERSION_CHECK(6, 0, 0) ||                                        \
-   HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || defined(_Static_assert))
-#define HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
-#elif (defined(__cplusplus) && (__cplusplus >= 201103L)) ||                    \
-  HEDLEY_MSVC_VERSION_CHECK(16, 0, 0) ||                                       \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_STATIC_ASSERT(expr, message)                                    \
-  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
-#else
-#define HEDLEY_STATIC_ASSERT(expr, message)
-#endif
-
-#if defined(HEDLEY_NULL)
-#undef HEDLEY_NULL
-#endif
-#if defined(__cplusplus)
-#if __cplusplus >= 201103L
-#define HEDLEY_NULL HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
-#elif defined(NULL)
-#define HEDLEY_NULL NULL
-#else
-#define HEDLEY_NULL HEDLEY_STATIC_CAST(void*, 0)
-#endif
-#elif defined(NULL)
-#define HEDLEY_NULL NULL
-#else
-#define HEDLEY_NULL ((void*)0)
-#endif
-
-#if defined(HEDLEY_MESSAGE)
-#undef HEDLEY_MESSAGE
-#endif
-#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
-#define HEDLEY_MESSAGE(msg)                                                    \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                                    \
-  HEDLEY_PRAGMA(message msg)                                                   \
-  HEDLEY_DIAGNOSTIC_POP
-#elif HEDLEY_GCC_VERSION_CHECK(4, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message msg)
-#elif HEDLEY_CRAY_VERSION_CHECK(5, 0, 0)
-#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(_CRI message msg)
-#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
-#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message(msg))
-#elif HEDLEY_PELLES_VERSION_CHECK(2, 0, 0)
-#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message(msg))
-#else
-#define HEDLEY_MESSAGE(msg)
-#endif
-
-#if defined(HEDLEY_WARNING)
-#undef HEDLEY_WARNING
-#endif
-#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
-#define HEDLEY_WARNING(msg)                                                    \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                                    \
-  HEDLEY_PRAGMA(clang warning msg)                                             \
-  HEDLEY_DIAGNOSTIC_POP
-#elif HEDLEY_GCC_VERSION_CHECK(4, 8, 0) ||                                     \
-  HEDLEY_PGI_VERSION_CHECK(18, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
-#define HEDLEY_WARNING(msg) HEDLEY_PRAGMA(GCC warning msg)
-#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0) ||                                   \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_WARNING(msg) HEDLEY_PRAGMA(message(msg))
-#else
-#define HEDLEY_WARNING(msg) HEDLEY_MESSAGE(msg)
-#endif
-
-#if defined(HEDLEY_REQUIRE)
-#undef HEDLEY_REQUIRE
-#endif
-#if defined(HEDLEY_REQUIRE_MSG)
-#undef HEDLEY_REQUIRE_MSG
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(diagnose_if)
-#if HEDLEY_HAS_WARNING("-Wgcc-compat")
-#define HEDLEY_REQUIRE(expr)                                                   \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wgcc-compat\"")                         \
-    __attribute__((diagnose_if(!(expr), #expr, "error")))                      \
-    HEDLEY_DIAGNOSTIC_POP
-#define HEDLEY_REQUIRE_MSG(expr, msg)                                          \
-  HEDLEY_DIAGNOSTIC_PUSH                                                       \
-  _Pragma("clang diagnostic ignored \"-Wgcc-compat\"")                         \
-    __attribute__((diagnose_if(!(expr), msg, "error"))) HEDLEY_DIAGNOSTIC_POP
-#else
-#define HEDLEY_REQUIRE(expr)                                                   \
-  __attribute__((diagnose_if(!(expr), #expr, "error")))
-#define HEDLEY_REQUIRE_MSG(expr, msg)                                          \
-  __attribute__((diagnose_if(!(expr), msg, "error")))
-#endif
-#else
-#define HEDLEY_REQUIRE(expr)
-#define HEDLEY_REQUIRE_MSG(expr, msg)
-#endif
-
-#if defined(HEDLEY_FLAGS)
-#undef HEDLEY_FLAGS
-#endif
-#if HEDLEY_HAS_ATTRIBUTE(flag_enum)
-#define HEDLEY_FLAGS __attribute__((__flag_enum__))
-#else
-#define HEDLEY_FLAGS
-#endif
-
-#if defined(HEDLEY_FLAGS_CAST)
-#undef HEDLEY_FLAGS_CAST
-#endif
-#if HEDLEY_INTEL_VERSION_CHECK(19, 0, 0)
-#define HEDLEY_FLAGS_CAST(T, expr)                                             \
-  (__extension__({                                                             \
-    HEDLEY_DIAGNOSTIC_PUSH                                                     \
-    _Pragma("warning(disable:188)")((T)(expr));                                \
-    HEDLEY_DIAGNOSTIC_POP                                                      \
-  }))
-#else
-#define HEDLEY_FLAGS_CAST(T, expr) HEDLEY_STATIC_CAST(T, expr)
-#endif
-
-#if defined(HEDLEY_EMPTY_BASES)
-#undef HEDLEY_EMPTY_BASES
-#endif
-#if (HEDLEY_MSVC_VERSION_CHECK(19, 0, 23918) &&                                \
-     !HEDLEY_MSVC_VERSION_CHECK(20, 0, 0)) ||                                  \
-  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
-#define HEDLEY_EMPTY_BASES __declspec(empty_bases)
-#else
-#define HEDLEY_EMPTY_BASES
-#endif
-
-/* Remaining macros are deprecated. */
-
-#if defined(HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
-#undef HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
-#endif
-#if defined(__clang__)
-#define HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major, minor, patch) (0)
-#else
-#define HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major, minor, patch)                \
-  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
-#endif
-
-#if defined(HEDLEY_CLANG_HAS_ATTRIBUTE)
-#undef HEDLEY_CLANG_HAS_ATTRIBUTE
-#endif
-#define HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) HEDLEY_HAS_ATTRIBUTE(attribute)
-
-#if defined(HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
-#undef HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
-#endif
-#define HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute)                              \
-  HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
-
-#if defined(HEDLEY_CLANG_HAS_BUILTIN)
-#undef HEDLEY_CLANG_HAS_BUILTIN
-#endif
-#define HEDLEY_CLANG_HAS_BUILTIN(builtin) HEDLEY_HAS_BUILTIN(builtin)
-
-#if defined(HEDLEY_CLANG_HAS_FEATURE)
-#undef HEDLEY_CLANG_HAS_FEATURE
-#endif
-#define HEDLEY_CLANG_HAS_FEATURE(feature) HEDLEY_HAS_FEATURE(feature)
-
-#if defined(HEDLEY_CLANG_HAS_EXTENSION)
-#undef HEDLEY_CLANG_HAS_EXTENSION
-#endif
-#define HEDLEY_CLANG_HAS_EXTENSION(extension) HEDLEY_HAS_EXTENSION(extension)
-
-#if defined(HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
-#undef HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
-#endif
-#define HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute)                         \
-  HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
-
-#if defined(HEDLEY_CLANG_HAS_WARNING)
-#undef HEDLEY_CLANG_HAS_WARNING
-#endif
-#define HEDLEY_CLANG_HAS_WARNING(warning) HEDLEY_HAS_WARNING(warning)
-
-#endif /* !defined(HEDLEY_VERSION) || (HEDLEY_VERSION < X) */
+/* Hedley - https://nemequ.github.io/hedley
+ * Created by Evan Nemerson <evan@nemerson.com>
+ *
+ * To the extent possible under law, the author(s) have dedicated all
+ * copyright and related and neighboring rights to this software to
+ * the public domain worldwide. This software is distributed without
+ * any warranty.
+ *
+ * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.
+ * SPDX-License-Identifier: CC0-1.0
+ */
+
+#if !defined(HEDLEY_VERSION) || (HEDLEY_VERSION < 14)
+#if defined(HEDLEY_VERSION)
+#undef HEDLEY_VERSION
+#endif
+#define HEDLEY_VERSION 14
+
+#if defined(HEDLEY_STRINGIFY_EX)
+#undef HEDLEY_STRINGIFY_EX
+#endif
+#define HEDLEY_STRINGIFY_EX(x) #x
+
+#if defined(HEDLEY_STRINGIFY)
+#undef HEDLEY_STRINGIFY
+#endif
+#define HEDLEY_STRINGIFY(x) HEDLEY_STRINGIFY_EX(x)
+
+#if defined(HEDLEY_CONCAT_EX)
+#undef HEDLEY_CONCAT_EX
+#endif
+#define HEDLEY_CONCAT_EX(a, b) a##b
+
+#if defined(HEDLEY_CONCAT)
+#undef HEDLEY_CONCAT
+#endif
+#define HEDLEY_CONCAT(a, b) HEDLEY_CONCAT_EX(a, b)
+
+#if defined(HEDLEY_CONCAT3_EX)
+#undef HEDLEY_CONCAT3_EX
+#endif
+#define HEDLEY_CONCAT3_EX(a, b, c) a##b##c
+
+#if defined(HEDLEY_CONCAT3)
+#undef HEDLEY_CONCAT3
+#endif
+#define HEDLEY_CONCAT3(a, b, c) HEDLEY_CONCAT3_EX(a, b, c)
+
+#if defined(HEDLEY_VERSION_ENCODE)
+#undef HEDLEY_VERSION_ENCODE
+#endif
+#define HEDLEY_VERSION_ENCODE(major, minor, revision)                          \
+  (((major)*1000000) + ((minor)*1000) + (revision))
+
+#if defined(HEDLEY_VERSION_DECODE_MAJOR)
+#undef HEDLEY_VERSION_DECODE_MAJOR
+#endif
+#define HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)
+
+#if defined(HEDLEY_VERSION_DECODE_MINOR)
+#undef HEDLEY_VERSION_DECODE_MINOR
+#endif
+#define HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)
+
+#if defined(HEDLEY_VERSION_DECODE_REVISION)
+#undef HEDLEY_VERSION_DECODE_REVISION
+#endif
+#define HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)
+
+#if defined(HEDLEY_GNUC_VERSION)
+#undef HEDLEY_GNUC_VERSION
+#endif
+#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
+#define HEDLEY_GNUC_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
+#elif defined(__GNUC__)
+#define HEDLEY_GNUC_VERSION HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
+#endif
+
+#if defined(HEDLEY_GNUC_VERSION_CHECK)
+#undef HEDLEY_GNUC_VERSION_CHECK
+#endif
+#if defined(HEDLEY_GNUC_VERSION)
+#define HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)                         \
+  (HEDLEY_GNUC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_GNUC_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_MSVC_VERSION)
+#undef HEDLEY_MSVC_VERSION
+#endif
+#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
+#define HEDLEY_MSVC_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000,                              \
+                        (_MSC_FULL_VER % 10000000) / 100000,                   \
+                        (_MSC_FULL_VER % 100000) / 100)
+#elif defined(_MSC_FULL_VER) && !defined(__ICL)
+#define HEDLEY_MSVC_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000,                               \
+                        (_MSC_FULL_VER % 1000000) / 10000,                     \
+                        (_MSC_FULL_VER % 10000) / 10)
+#elif defined(_MSC_VER) && !defined(__ICL)
+#define HEDLEY_MSVC_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
+#endif
+
+#if defined(HEDLEY_MSVC_VERSION_CHECK)
+#undef HEDLEY_MSVC_VERSION_CHECK
+#endif
+#if !defined(HEDLEY_MSVC_VERSION)
+#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch) (0)
+#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
+#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
+  (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
+#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
+#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
+  (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
+#else
+#define HEDLEY_MSVC_VERSION_CHECK(major, minor, patch)                         \
+  (_MSC_VER >= ((major * 100) + (minor)))
+#endif
+
+#if defined(HEDLEY_INTEL_VERSION)
+#undef HEDLEY_INTEL_VERSION
+#endif
+#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) &&           \
+  !defined(__ICL)
+#define HEDLEY_INTEL_VERSION                                                   \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    __INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
+#elif defined(__INTEL_COMPILER) && !defined(__ICL)
+#define HEDLEY_INTEL_VERSION                                                   \
+  HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
+#endif
+
+#if defined(HEDLEY_INTEL_VERSION_CHECK)
+#undef HEDLEY_INTEL_VERSION_CHECK
+#endif
+#if defined(HEDLEY_INTEL_VERSION)
+#define HEDLEY_INTEL_VERSION_CHECK(major, minor, patch)                        \
+  (HEDLEY_INTEL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_INTEL_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_INTEL_CL_VERSION)
+#undef HEDLEY_INTEL_CL_VERSION
+#endif
+#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) &&           \
+  defined(__ICL)
+#define HEDLEY_INTEL_CL_VERSION                                                \
+  HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
+#endif
+
+#if defined(HEDLEY_INTEL_CL_VERSION_CHECK)
+#undef HEDLEY_INTEL_CL_VERSION_CHECK
+#endif
+#if defined(HEDLEY_INTEL_CL_VERSION)
+#define HEDLEY_INTEL_CL_VERSION_CHECK(major, minor, patch)                     \
+  (HEDLEY_INTEL_CL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_INTEL_CL_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_PGI_VERSION)
+#undef HEDLEY_PGI_VERSION
+#endif
+#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) &&          \
+  defined(__PGIC_PATCHLEVEL__)
+#define HEDLEY_PGI_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
+#endif
+
+#if defined(HEDLEY_PGI_VERSION_CHECK)
+#undef HEDLEY_PGI_VERSION_CHECK
+#endif
+#if defined(HEDLEY_PGI_VERSION)
+#define HEDLEY_PGI_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_PGI_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_PGI_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_SUNPRO_VERSION)
+#undef HEDLEY_SUNPRO_VERSION
+#endif
+#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
+#define HEDLEY_SUNPRO_VERSION                                                  \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    (((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf),            \
+    (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf),              \
+    (__SUNPRO_C & 0xf) * 10)
+#elif defined(__SUNPRO_C)
+#define HEDLEY_SUNPRO_VERSION                                                  \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    (__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C)&0xf)
+#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
+#define HEDLEY_SUNPRO_VERSION                                                  \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    (((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf),          \
+    (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf),            \
+    (__SUNPRO_CC & 0xf) * 10)
+#elif defined(__SUNPRO_CC)
+#define HEDLEY_SUNPRO_VERSION                                                  \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    (__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC)&0xf)
+#endif
+
+#if defined(HEDLEY_SUNPRO_VERSION_CHECK)
+#undef HEDLEY_SUNPRO_VERSION_CHECK
+#endif
+#if defined(HEDLEY_SUNPRO_VERSION)
+#define HEDLEY_SUNPRO_VERSION_CHECK(major, minor, patch)                       \
+  (HEDLEY_SUNPRO_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_SUNPRO_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_EMSCRIPTEN_VERSION)
+#undef HEDLEY_EMSCRIPTEN_VERSION
+#endif
+#if defined(__EMSCRIPTEN__)
+#define HEDLEY_EMSCRIPTEN_VERSION                                              \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    __EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
+#endif
+
+#if defined(HEDLEY_EMSCRIPTEN_VERSION_CHECK)
+#undef HEDLEY_EMSCRIPTEN_VERSION_CHECK
+#endif
+#if defined(HEDLEY_EMSCRIPTEN_VERSION)
+#define HEDLEY_EMSCRIPTEN_VERSION_CHECK(major, minor, patch)                   \
+  (HEDLEY_EMSCRIPTEN_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_EMSCRIPTEN_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_ARM_VERSION)
+#undef HEDLEY_ARM_VERSION
+#endif
+#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
+#define HEDLEY_ARM_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000,                       \
+                        (__ARMCOMPILER_VERSION % 1000000) / 10000,             \
+                        (__ARMCOMPILER_VERSION % 10000) / 100)
+#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
+#define HEDLEY_ARM_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000,                             \
+                        (__ARMCC_VERSION % 1000000) / 10000,                   \
+                        (__ARMCC_VERSION % 10000) / 100)
+#endif
+
+#if defined(HEDLEY_ARM_VERSION_CHECK)
+#undef HEDLEY_ARM_VERSION_CHECK
+#endif
+#if defined(HEDLEY_ARM_VERSION)
+#define HEDLEY_ARM_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_ARM_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_ARM_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_IBM_VERSION)
+#undef HEDLEY_IBM_VERSION
+#endif
+#if defined(__ibmxl__)
+#define HEDLEY_IBM_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    __ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
+#elif defined(__xlC__) && defined(__xlC_ver__)
+#define HEDLEY_IBM_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
+#elif defined(__xlC__)
+#define HEDLEY_IBM_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
+#endif
+
+#if defined(HEDLEY_IBM_VERSION_CHECK)
+#undef HEDLEY_IBM_VERSION_CHECK
+#endif
+#if defined(HEDLEY_IBM_VERSION)
+#define HEDLEY_IBM_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_IBM_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_IBM_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_VERSION)
+#undef HEDLEY_TI_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) &&                                        \
+  (defined(__TMS470__) || defined(__TI_ARM__) || defined(__MSP430__) ||        \
+   defined(__TMS320C2000__))
+#if (__TI_COMPILER_VERSION__ >= 16000000)
+#define HEDLEY_TI_VERSION                                                      \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+#endif
+
+#if defined(HEDLEY_TI_VERSION_CHECK)
+#undef HEDLEY_TI_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_VERSION)
+#define HEDLEY_TI_VERSION_CHECK(major, minor, patch)                           \
+  (HEDLEY_TI_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_CL2000_VERSION)
+#undef HEDLEY_TI_CL2000_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
+#define HEDLEY_TI_CL2000_VERSION                                               \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_CL2000_VERSION_CHECK)
+#undef HEDLEY_TI_CL2000_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_CL2000_VERSION)
+#define HEDLEY_TI_CL2000_VERSION_CHECK(major, minor, patch)                    \
+  (HEDLEY_TI_CL2000_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_CL2000_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_CL430_VERSION)
+#undef HEDLEY_TI_CL430_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
+#define HEDLEY_TI_CL430_VERSION                                                \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_CL430_VERSION_CHECK)
+#undef HEDLEY_TI_CL430_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_CL430_VERSION)
+#define HEDLEY_TI_CL430_VERSION_CHECK(major, minor, patch)                     \
+  (HEDLEY_TI_CL430_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_CL430_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_ARMCL_VERSION)
+#undef HEDLEY_TI_ARMCL_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) &&                                        \
+  (defined(__TMS470__) || defined(__TI_ARM__))
+#define HEDLEY_TI_ARMCL_VERSION                                                \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_ARMCL_VERSION_CHECK)
+#undef HEDLEY_TI_ARMCL_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_ARMCL_VERSION)
+#define HEDLEY_TI_ARMCL_VERSION_CHECK(major, minor, patch)                     \
+  (HEDLEY_TI_ARMCL_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_ARMCL_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_CL6X_VERSION)
+#undef HEDLEY_TI_CL6X_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
+#define HEDLEY_TI_CL6X_VERSION                                                 \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_CL6X_VERSION_CHECK)
+#undef HEDLEY_TI_CL6X_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_CL6X_VERSION)
+#define HEDLEY_TI_CL6X_VERSION_CHECK(major, minor, patch)                      \
+  (HEDLEY_TI_CL6X_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_CL6X_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_CL7X_VERSION)
+#undef HEDLEY_TI_CL7X_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
+#define HEDLEY_TI_CL7X_VERSION                                                 \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_CL7X_VERSION_CHECK)
+#undef HEDLEY_TI_CL7X_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_CL7X_VERSION)
+#define HEDLEY_TI_CL7X_VERSION_CHECK(major, minor, patch)                      \
+  (HEDLEY_TI_CL7X_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_CL7X_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TI_CLPRU_VERSION)
+#undef HEDLEY_TI_CLPRU_VERSION
+#endif
+#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
+#define HEDLEY_TI_CLPRU_VERSION                                                \
+  HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000,                     \
+                        (__TI_COMPILER_VERSION__ % 1000000) / 1000,            \
+                        (__TI_COMPILER_VERSION__ % 1000))
+#endif
+
+#if defined(HEDLEY_TI_CLPRU_VERSION_CHECK)
+#undef HEDLEY_TI_CLPRU_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TI_CLPRU_VERSION)
+#define HEDLEY_TI_CLPRU_VERSION_CHECK(major, minor, patch)                     \
+  (HEDLEY_TI_CLPRU_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TI_CLPRU_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_CRAY_VERSION)
+#undef HEDLEY_CRAY_VERSION
+#endif
+#if defined(_CRAYC)
+#if defined(_RELEASE_PATCHLEVEL)
+#define HEDLEY_CRAY_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
+#else
+#define HEDLEY_CRAY_VERSION                                                    \
+  HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
+#endif
+#endif
+
+#if defined(HEDLEY_CRAY_VERSION_CHECK)
+#undef HEDLEY_CRAY_VERSION_CHECK
+#endif
+#if defined(HEDLEY_CRAY_VERSION)
+#define HEDLEY_CRAY_VERSION_CHECK(major, minor, patch)                         \
+  (HEDLEY_CRAY_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_CRAY_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_IAR_VERSION)
+#undef HEDLEY_IAR_VERSION
+#endif
+#if defined(__IAR_SYSTEMS_ICC__)
+#if __VER__ > 1000
+#define HEDLEY_IAR_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    (__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
+#else
+#define HEDLEY_IAR_VERSION HEDLEY_VERSION_ENCODE(VER / 100, __VER__ % 100, 0)
+#endif
+#endif
+
+#if defined(HEDLEY_IAR_VERSION_CHECK)
+#undef HEDLEY_IAR_VERSION_CHECK
+#endif
+#if defined(HEDLEY_IAR_VERSION)
+#define HEDLEY_IAR_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_IAR_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_IAR_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_TINYC_VERSION)
+#undef HEDLEY_TINYC_VERSION
+#endif
+#if defined(__TINYC__)
+#define HEDLEY_TINYC_VERSION                                                   \
+  HEDLEY_VERSION_ENCODE(                                                       \
+    __TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
+#endif
+
+#if defined(HEDLEY_TINYC_VERSION_CHECK)
+#undef HEDLEY_TINYC_VERSION_CHECK
+#endif
+#if defined(HEDLEY_TINYC_VERSION)
+#define HEDLEY_TINYC_VERSION_CHECK(major, minor, patch)                        \
+  (HEDLEY_TINYC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_TINYC_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_DMC_VERSION)
+#undef HEDLEY_DMC_VERSION
+#endif
+#if defined(__DMC__)
+#define HEDLEY_DMC_VERSION                                                     \
+  HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
+#endif
+
+#if defined(HEDLEY_DMC_VERSION_CHECK)
+#undef HEDLEY_DMC_VERSION_CHECK
+#endif
+#if defined(HEDLEY_DMC_VERSION)
+#define HEDLEY_DMC_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_DMC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_DMC_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_COMPCERT_VERSION)
+#undef HEDLEY_COMPCERT_VERSION
+#endif
+#if defined(__COMPCERT_VERSION__)
+#define HEDLEY_COMPCERT_VERSION                                                \
+  HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000,                          \
+                        (__COMPCERT_VERSION__ / 100) % 100,                    \
+                        __COMPCERT_VERSION__ % 100)
+#endif
+
+#if defined(HEDLEY_COMPCERT_VERSION_CHECK)
+#undef HEDLEY_COMPCERT_VERSION_CHECK
+#endif
+#if defined(HEDLEY_COMPCERT_VERSION)
+#define HEDLEY_COMPCERT_VERSION_CHECK(major, minor, patch)                     \
+  (HEDLEY_COMPCERT_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_COMPCERT_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_PELLES_VERSION)
+#undef HEDLEY_PELLES_VERSION
+#endif
+#if defined(__POCC__)
+#define HEDLEY_PELLES_VERSION                                                  \
+  HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
+#endif
+
+#if defined(HEDLEY_PELLES_VERSION_CHECK)
+#undef HEDLEY_PELLES_VERSION_CHECK
+#endif
+#if defined(HEDLEY_PELLES_VERSION)
+#define HEDLEY_PELLES_VERSION_CHECK(major, minor, patch)                       \
+  (HEDLEY_PELLES_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_PELLES_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_GCC_VERSION)
+#undef HEDLEY_GCC_VERSION
+#endif
+#if defined(HEDLEY_GNUC_VERSION) && !defined(__clang__) &&                     \
+  !defined(HEDLEY_INTEL_VERSION) && !defined(HEDLEY_PGI_VERSION) &&            \
+  !defined(HEDLEY_ARM_VERSION) && !defined(HEDLEY_TI_VERSION) &&               \
+  !defined(HEDLEY_TI_ARMCL_VERSION) && !defined(HEDLEY_TI_CL430_VERSION) &&    \
+  !defined(HEDLEY_TI_CL2000_VERSION) && !defined(HEDLEY_TI_CL6X_VERSION) &&    \
+  !defined(HEDLEY_TI_CL7X_VERSION) && !defined(HEDLEY_TI_CLPRU_VERSION) &&     \
+  !defined(__COMPCERT__)
+#define HEDLEY_GCC_VERSION HEDLEY_GNUC_VERSION
+#endif
+
+#if defined(HEDLEY_GCC_VERSION_CHECK)
+#undef HEDLEY_GCC_VERSION_CHECK
+#endif
+#if defined(HEDLEY_GCC_VERSION)
+#define HEDLEY_GCC_VERSION_CHECK(major, minor, patch)                          \
+  (HEDLEY_GCC_VERSION >= HEDLEY_VERSION_ENCODE(major, minor, patch))
+#else
+#define HEDLEY_GCC_VERSION_CHECK(major, minor, patch) (0)
+#endif
+
+#if defined(HEDLEY_HAS_ATTRIBUTE)
+#undef HEDLEY_HAS_ATTRIBUTE
+#endif
+#if defined(__has_attribute)
+#define HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
+#else
+#define HEDLEY_HAS_ATTRIBUTE(attribute) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_ATTRIBUTE)
+#undef HEDLEY_GNUC_HAS_ATTRIBUTE
+#endif
+#if defined(__has_attribute)
+#define HEDLEY_GNUC_HAS_ATTRIBUTE(attribute, major, minor, patch)              \
+  __has_attribute(attribute)
+#else
+#define HEDLEY_GNUC_HAS_ATTRIBUTE(attribute, major, minor, patch)              \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_ATTRIBUTE)
+#undef HEDLEY_GCC_HAS_ATTRIBUTE
+#endif
+#if defined(__has_attribute)
+#define HEDLEY_GCC_HAS_ATTRIBUTE(attribute, major, minor, patch)               \
+  __has_attribute(attribute)
+#else
+#define HEDLEY_GCC_HAS_ATTRIBUTE(attribute, major, minor, patch)               \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_CPP_ATTRIBUTE)
+#undef HEDLEY_HAS_CPP_ATTRIBUTE
+#endif
+#if defined(__has_cpp_attribute) && defined(__cplusplus) &&                    \
+  (!defined(HEDLEY_SUNPRO_VERSION) || HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0))
+#define HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
+#else
+#define HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
+#endif
+
+#if defined(HEDLEY_HAS_CPP_ATTRIBUTE_NS)
+#undef HEDLEY_HAS_CPP_ATTRIBUTE_NS
+#endif
+#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
+#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute) (0)
+#elif !defined(HEDLEY_PGI_VERSION) && !defined(HEDLEY_IAR_VERSION) &&          \
+  (!defined(HEDLEY_SUNPRO_VERSION) ||                                          \
+   HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0)) &&                                   \
+  (!defined(HEDLEY_MSVC_VERSION) || HEDLEY_MSVC_VERSION_CHECK(19, 20, 0))
+#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute)                             \
+  HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
+#else
+#define HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns, attribute) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
+#undef HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
+#endif
+#if defined(__has_cpp_attribute) && defined(__cplusplus)
+#define HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)          \
+  __has_cpp_attribute(attribute)
+#else
+#define HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)          \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
+#undef HEDLEY_GCC_HAS_CPP_ATTRIBUTE
+#endif
+#if defined(__has_cpp_attribute) && defined(__cplusplus)
+#define HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)           \
+  __has_cpp_attribute(attribute)
+#else
+#define HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute, major, minor, patch)           \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_BUILTIN)
+#undef HEDLEY_HAS_BUILTIN
+#endif
+#if defined(__has_builtin)
+#define HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
+#else
+#define HEDLEY_HAS_BUILTIN(builtin) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_BUILTIN)
+#undef HEDLEY_GNUC_HAS_BUILTIN
+#endif
+#if defined(__has_builtin)
+#define HEDLEY_GNUC_HAS_BUILTIN(builtin, major, minor, patch)                  \
+  __has_builtin(builtin)
+#else
+#define HEDLEY_GNUC_HAS_BUILTIN(builtin, major, minor, patch)                  \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_BUILTIN)
+#undef HEDLEY_GCC_HAS_BUILTIN
+#endif
+#if defined(__has_builtin)
+#define HEDLEY_GCC_HAS_BUILTIN(builtin, major, minor, patch)                   \
+  __has_builtin(builtin)
+#else
+#define HEDLEY_GCC_HAS_BUILTIN(builtin, major, minor, patch)                   \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_FEATURE)
+#undef HEDLEY_HAS_FEATURE
+#endif
+#if defined(__has_feature)
+#define HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
+#else
+#define HEDLEY_HAS_FEATURE(feature) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_FEATURE)
+#undef HEDLEY_GNUC_HAS_FEATURE
+#endif
+#if defined(__has_feature)
+#define HEDLEY_GNUC_HAS_FEATURE(feature, major, minor, patch)                  \
+  __has_feature(feature)
+#else
+#define HEDLEY_GNUC_HAS_FEATURE(feature, major, minor, patch)                  \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_FEATURE)
+#undef HEDLEY_GCC_HAS_FEATURE
+#endif
+#if defined(__has_feature)
+#define HEDLEY_GCC_HAS_FEATURE(feature, major, minor, patch)                   \
+  __has_feature(feature)
+#else
+#define HEDLEY_GCC_HAS_FEATURE(feature, major, minor, patch)                   \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_EXTENSION)
+#undef HEDLEY_HAS_EXTENSION
+#endif
+#if defined(__has_extension)
+#define HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
+#else
+#define HEDLEY_HAS_EXTENSION(extension) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_EXTENSION)
+#undef HEDLEY_GNUC_HAS_EXTENSION
+#endif
+#if defined(__has_extension)
+#define HEDLEY_GNUC_HAS_EXTENSION(extension, major, minor, patch)              \
+  __has_extension(extension)
+#else
+#define HEDLEY_GNUC_HAS_EXTENSION(extension, major, minor, patch)              \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_EXTENSION)
+#undef HEDLEY_GCC_HAS_EXTENSION
+#endif
+#if defined(__has_extension)
+#define HEDLEY_GCC_HAS_EXTENSION(extension, major, minor, patch)               \
+  __has_extension(extension)
+#else
+#define HEDLEY_GCC_HAS_EXTENSION(extension, major, minor, patch)               \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
+#undef HEDLEY_HAS_DECLSPEC_ATTRIBUTE
+#endif
+#if defined(__has_declspec_attribute)
+#define HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)                               \
+  __has_declspec_attribute(attribute)
+#else
+#define HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
+#undef HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
+#endif
+#if defined(__has_declspec_attribute)
+#define HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)     \
+  __has_declspec_attribute(attribute)
+#else
+#define HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)     \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
+#undef HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
+#endif
+#if defined(__has_declspec_attribute)
+#define HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)      \
+  __has_declspec_attribute(attribute)
+#else
+#define HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute, major, minor, patch)      \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_HAS_WARNING)
+#undef HEDLEY_HAS_WARNING
+#endif
+#if defined(__has_warning)
+#define HEDLEY_HAS_WARNING(warning) __has_warning(warning)
+#else
+#define HEDLEY_HAS_WARNING(warning) (0)
+#endif
+
+#if defined(HEDLEY_GNUC_HAS_WARNING)
+#undef HEDLEY_GNUC_HAS_WARNING
+#endif
+#if defined(__has_warning)
+#define HEDLEY_GNUC_HAS_WARNING(warning, major, minor, patch)                  \
+  __has_warning(warning)
+#else
+#define HEDLEY_GNUC_HAS_WARNING(warning, major, minor, patch)                  \
+  HEDLEY_GNUC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_GCC_HAS_WARNING)
+#undef HEDLEY_GCC_HAS_WARNING
+#endif
+#if defined(__has_warning)
+#define HEDLEY_GCC_HAS_WARNING(warning, major, minor, patch)                   \
+  __has_warning(warning)
+#else
+#define HEDLEY_GCC_HAS_WARNING(warning, major, minor, patch)                   \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) ||            \
+  defined(__clang__) || HEDLEY_GCC_VERSION_CHECK(3, 0, 0) ||                   \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_IAR_VERSION_CHECK(8, 0, 0) || \
+  HEDLEY_PGI_VERSION_CHECK(18, 4, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(4, 7, 0) ||                                    \
+  HEDLEY_TI_CL430_VERSION_CHECK(2, 0, 1) ||                                    \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 1, 0) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 0, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
+  HEDLEY_CRAY_VERSION_CHECK(5, 0, 0) ||                                        \
+  HEDLEY_TINYC_VERSION_CHECK(0, 9, 17) ||                                      \
+  HEDLEY_SUNPRO_VERSION_CHECK(8, 0, 0) ||                                      \
+  (HEDLEY_IBM_VERSION_CHECK(10, 1, 0) && defined(__C99_PRAGMA_OPERATOR))
+#define HEDLEY_PRAGMA(value) _Pragma(#value)
+#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
+#define HEDLEY_PRAGMA(value) __pragma(value)
+#else
+#define HEDLEY_PRAGMA(value)
+#endif
+
+#if defined(HEDLEY_DIAGNOSTIC_PUSH)
+#undef HEDLEY_DIAGNOSTIC_PUSH
+#endif
+#if defined(HEDLEY_DIAGNOSTIC_POP)
+#undef HEDLEY_DIAGNOSTIC_POP
+#endif
+#if defined(__clang__)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
+#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
+#elif HEDLEY_GCC_VERSION_CHECK(4, 6, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
+#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
+#define HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
+#elif HEDLEY_ARM_VERSION_CHECK(5, 6, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
+#elif HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                    \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 4, 0) ||                                    \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 1, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
+#elif HEDLEY_PELLES_VERSION_CHECK(2, 90, 0)
+#define HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
+#define HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
+#else
+#define HEDLEY_DIAGNOSTIC_PUSH
+#define HEDLEY_DIAGNOSTIC_POP
+#endif
+
+/* HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
+   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
+#if defined(HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
+#undef HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
+#endif
+#if defined(__cplusplus)
+#if HEDLEY_HAS_WARNING("-Wc++98-compat")
+#if HEDLEY_HAS_WARNING("-Wc++17-extensions")
+#if HEDLEY_HAS_WARNING("-Wc++1z-extensions")
+#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
+    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"")                 \
+      _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"")               \
+        xpr HEDLEY_DIAGNOSTIC_POP
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
+    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"")                 \
+      xpr HEDLEY_DIAGNOSTIC_POP
+#endif
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr)                      \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wc++98-compat\"")                       \
+    xpr HEDLEY_DIAGNOSTIC_POP
+#endif
+#endif
+#endif
+#if !defined(HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
+#define HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
+#endif
+
+#if defined(HEDLEY_CONST_CAST)
+#undef HEDLEY_CONST_CAST
+#endif
+#if defined(__cplusplus)
+#define HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
+#elif HEDLEY_HAS_WARNING("-Wcast-qual") ||                                     \
+  HEDLEY_GCC_VERSION_CHECK(4, 6, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_CONST_CAST(T, expr)                                             \
+  (__extension__({                                                             \
+    HEDLEY_DIAGNOSTIC_PUSH                                                     \
+    HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL((T)(expr));                            \
+    HEDLEY_DIAGNOSTIC_POP                                                      \
+  }))
+#else
+#define HEDLEY_CONST_CAST(T, expr) ((T)(expr))
+#endif
+
+#if defined(HEDLEY_REINTERPRET_CAST)
+#undef HEDLEY_REINTERPRET_CAST
+#endif
+#if defined(__cplusplus)
+#define HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
+#else
+#define HEDLEY_REINTERPRET_CAST(T, expr) ((T)(expr))
+#endif
+
+#if defined(HEDLEY_STATIC_CAST)
+#undef HEDLEY_STATIC_CAST
+#endif
+#if defined(__cplusplus)
+#define HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
+#else
+#define HEDLEY_STATIC_CAST(T, expr) ((T)(expr))
+#endif
+
+#if defined(HEDLEY_CPP_CAST)
+#undef HEDLEY_CPP_CAST
+#endif
+#if defined(__cplusplus)
+#if HEDLEY_HAS_WARNING("-Wold-style-cast")
+#define HEDLEY_CPP_CAST(T, expr)                                               \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wold-style-cast\"")((T)(expr))          \
+    HEDLEY_DIAGNOSTIC_POP
+#elif HEDLEY_IAR_VERSION_CHECK(8, 3, 0)
+#define HEDLEY_CPP_CAST(T, expr)                                               \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("diag_suppress=Pe137") HEDLEY_DIAGNOSTIC_POP
+#else
+#define HEDLEY_CPP_CAST(T, expr) ((T)(expr))
+#endif
+#else
+#define HEDLEY_CPP_CAST(T, expr) (expr)
+#endif
+
+#if defined(HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
+#undef HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+#endif
+#if HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
+#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("warning(disable:1478 1786)")
+#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  __pragma(warning(disable : 1478 1786))
+#elif HEDLEY_PGI_VERSION_CHECK(20, 7, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("diag_suppress 1215,1216,1444,1445")
+#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
+#elif HEDLEY_GCC_VERSION_CHECK(4, 3, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
+#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable : 4996))
+#elif HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                    \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) && !defined(__cplusplus)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) && defined(__cplusplus)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED                                   \
+  _Pragma("diag_suppress=Pe1444,Pe1215")
+#elif HEDLEY_PELLES_VERSION_CHECK(2, 90, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+#endif
+
+#if defined(HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
+#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+#endif
+#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
+  _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
+#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
+  _Pragma("warning(disable:161)")
+#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
+  __pragma(warning(disable : 161))
+#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
+#elif HEDLEY_GCC_VERSION_CHECK(4, 3, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
+  _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
+#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                              \
+  __pragma(warning(disable : 4068))
+#elif HEDLEY_TI_VERSION_CHECK(16, 9, 0) ||                                     \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
+#elif HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+#endif
+
+#if defined(HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
+#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+#endif
+#if HEDLEY_HAS_WARNING("-Wunknown-attributes")
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
+#elif HEDLEY_GCC_VERSION_CHECK(4, 6, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
+#elif HEDLEY_INTEL_VERSION_CHECK(17, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("warning(disable:1292)")
+#elif HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  __pragma(warning(disable : 1292))
+#elif HEDLEY_MSVC_VERSION_CHECK(19, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  __pragma(warning(disable : 5030))
+#elif HEDLEY_PGI_VERSION_CHECK(20, 7, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("diag_suppress 1097,1098")
+#elif HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("diag_suppress 1097")
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 14, 0) && defined(__cplusplus)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("error_messages(off,attrskipunsup)")
+#elif HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||                                     \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("diag_suppress 1173")
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES                       \
+  _Pragma("diag_suppress=Pe1097")
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+#endif
+
+#if defined(HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
+#undef HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+#endif
+#if HEDLEY_HAS_WARNING("-Wcast-qual")
+#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
+  _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
+#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
+  _Pragma("warning(disable:2203 2331)")
+#elif HEDLEY_GCC_VERSION_CHECK(3, 0, 0)
+#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL                                    \
+  _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
+#else
+#define HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+#endif
+
+#if defined(HEDLEY_DEPRECATED)
+#undef HEDLEY_DEPRECATED
+#endif
+#if defined(HEDLEY_DEPRECATED_FOR)
+#undef HEDLEY_DEPRECATED_FOR
+#endif
+#if HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                     \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " #since))
+#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
+  __declspec(deprecated("Since " #since "; use " #replacement))
+#elif HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) ||               \
+  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_ARM_VERSION_CHECK(5, 6, 0) ||                                         \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 13, 0) ||                                     \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) || HEDLEY_TI_VERSION_CHECK(18, 1, 0) ||  \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(18, 1, 0) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 3, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 3, 0)
+#define HEDLEY_DEPRECATED(since)                                               \
+  __attribute__((__deprecated__("Since " #since)))
+#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
+  __attribute__((__deprecated__("Since " #since "; use " #replacement)))
+#elif defined(__cplusplus) && (__cplusplus >= 201402L)
+#define HEDLEY_DEPRECATED(since)                                               \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since"            \
+                                                            " " #since)]])
+#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(                                \
+    [[deprecated("Since " #since "; use " #replacement)]])
+#elif HEDLEY_HAS_ATTRIBUTE(deprecated) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) || \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||   \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
+#define HEDLEY_DEPRECATED_FOR(since, replacement)                              \
+  __attribute__((__deprecated__))
+#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
+  HEDLEY_PELLES_VERSION_CHECK(6, 50, 0) ||                                     \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_DEPRECATED(since) __declspec(deprecated)
+#define HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_DEPRECATED(since) _Pragma("deprecated")
+#define HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
+#else
+#define HEDLEY_DEPRECATED(since)
+#define HEDLEY_DEPRECATED_FOR(since, replacement)
+#endif
+
+#if defined(HEDLEY_UNAVAILABLE)
+#undef HEDLEY_UNAVAILABLE
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(warning) || HEDLEY_GCC_VERSION_CHECK(4, 3, 0) ||      \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_UNAVAILABLE(available_since)                                    \
+  __attribute__((__warning__("Not available until " #available_since)))
+#else
+#define HEDLEY_UNAVAILABLE(available_since)
+#endif
+
+#if defined(HEDLEY_WARN_UNUSED_RESULT)
+#undef HEDLEY_WARN_UNUSED_RESULT
+#endif
+#if defined(HEDLEY_WARN_UNUSED_RESULT_MSG)
+#undef HEDLEY_WARN_UNUSED_RESULT_MSG
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(warn_unused_result) ||                                \
+  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
+  (HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0) && defined(__cplusplus)) ||           \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
+#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
+  __attribute__((__warn_unused_result__))
+#elif (HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
+#define HEDLEY_WARN_UNUSED_RESULT                                              \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
+#elif HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
+#define HEDLEY_WARN_UNUSED_RESULT                                              \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)                                     \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
+#elif defined(_Check_return_) /* SAL */
+#define HEDLEY_WARN_UNUSED_RESULT _Check_return_
+#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
+#else
+#define HEDLEY_WARN_UNUSED_RESULT
+#define HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
+#endif
+
+#if defined(HEDLEY_SENTINEL)
+#undef HEDLEY_SENTINEL
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(sentinel) || HEDLEY_GCC_VERSION_CHECK(4, 0, 0) ||     \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(5, 4, 0)
+#define HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
+#else
+#define HEDLEY_SENTINEL(position)
+#endif
+
+#if defined(HEDLEY_NO_RETURN)
+#undef HEDLEY_NO_RETURN
+#endif
+#if HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_NO_RETURN __noreturn
+#elif HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_NO_RETURN __attribute__((__noreturn__))
+#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
+#define HEDLEY_NO_RETURN _Noreturn
+#elif defined(__cplusplus) && (__cplusplus >= 201103L)
+#define HEDLEY_NO_RETURN                                                       \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
+#elif HEDLEY_HAS_ATTRIBUTE(noreturn) || HEDLEY_GCC_VERSION_CHECK(3, 2, 0) ||   \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_NO_RETURN __attribute__((__noreturn__))
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
+#define HEDLEY_NO_RETURN _Pragma("does_not_return")
+#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_NO_RETURN __declspec(noreturn)
+#elif HEDLEY_TI_CL6X_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)
+#define HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
+#elif HEDLEY_COMPCERT_VERSION_CHECK(3, 2, 0)
+#define HEDLEY_NO_RETURN __attribute((noreturn))
+#elif HEDLEY_PELLES_VERSION_CHECK(9, 0, 0)
+#define HEDLEY_NO_RETURN __declspec(noreturn)
+#else
+#define HEDLEY_NO_RETURN
+#endif
+
+#if defined(HEDLEY_NO_ESCAPE)
+#undef HEDLEY_NO_ESCAPE
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(noescape)
+#define HEDLEY_NO_ESCAPE __attribute__((__noescape__))
+#else
+#define HEDLEY_NO_ESCAPE
+#endif
+
+#if defined(HEDLEY_UNREACHABLE)
+#undef HEDLEY_UNREACHABLE
+#endif
+#if defined(HEDLEY_UNREACHABLE_RETURN)
+#undef HEDLEY_UNREACHABLE_RETURN
+#endif
+#if defined(HEDLEY_ASSUME)
+#undef HEDLEY_ASSUME
+#endif
+#if HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                    \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_ASSUME(expr) __assume(expr)
+#elif HEDLEY_HAS_BUILTIN(__builtin_assume)
+#define HEDLEY_ASSUME(expr) __builtin_assume(expr)
+#elif HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                               \
+  HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0)
+#if defined(__cplusplus)
+#define HEDLEY_ASSUME(expr) std::_nassert(expr)
+#else
+#define HEDLEY_ASSUME(expr) _nassert(expr)
+#endif
+#endif
+#if (HEDLEY_HAS_BUILTIN(__builtin_unreachable) &&                              \
+     (!defined(HEDLEY_ARM_VERSION))) ||                                        \
+  HEDLEY_GCC_VERSION_CHECK(4, 5, 0) || HEDLEY_PGI_VERSION_CHECK(18, 10, 0) ||  \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_IBM_VERSION_CHECK(13, 1, 5)
+#define HEDLEY_UNREACHABLE() __builtin_unreachable()
+#elif defined(HEDLEY_ASSUME)
+#define HEDLEY_UNREACHABLE() HEDLEY_ASSUME(0)
+#endif
+#if !defined(HEDLEY_ASSUME)
+#if defined(HEDLEY_UNREACHABLE)
+#define HEDLEY_ASSUME(expr)                                                    \
+  HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (HEDLEY_UNREACHABLE(), 1)))
+#else
+#define HEDLEY_ASSUME(expr) HEDLEY_STATIC_CAST(void, expr)
+#endif
+#endif
+#if defined(HEDLEY_UNREACHABLE)
+#if HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                                 \
+  HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0)
+#define HEDLEY_UNREACHABLE_RETURN(value)                                       \
+  return (HEDLEY_STATIC_CAST(void, HEDLEY_ASSUME(0)), (value))
+#else
+#define HEDLEY_UNREACHABLE_RETURN(value) HEDLEY_UNREACHABLE()
+#endif
+#else
+#define HEDLEY_UNREACHABLE_RETURN(value) return (value)
+#endif
+#if !defined(HEDLEY_UNREACHABLE)
+#define HEDLEY_UNREACHABLE() HEDLEY_ASSUME(0)
+#endif
+
+HEDLEY_DIAGNOSTIC_PUSH
+#if HEDLEY_HAS_WARNING("-Wpedantic")
+#pragma clang diagnostic ignored "-Wpedantic"
+#endif
+#if HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
+#pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
+#endif
+#if HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros", 4, 0, 0)
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wvariadic-macros"
+#elif defined(HEDLEY_GCC_VERSION)
+#pragma GCC diagnostic ignored "-Wvariadic-macros"
+#endif
+#endif
+#if defined(HEDLEY_NON_NULL)
+#undef HEDLEY_NON_NULL
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(nonnull) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||      \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0)
+#define HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
+#else
+#define HEDLEY_NON_NULL(...)
+#endif
+HEDLEY_DIAGNOSTIC_POP
+
+#if defined(HEDLEY_PRINTF_FORMAT)
+#undef HEDLEY_PRINTF_FORMAT
+#endif
+#if defined(__MINGW32__) && HEDLEY_GCC_HAS_ATTRIBUTE(format, 4, 4, 0) &&       \
+  !defined(__USE_MINGW_ANSI_STDIO)
+#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
+  __attribute__((__format__(ms_printf, string_idx, first_to_check)))
+#elif defined(__MINGW32__) && HEDLEY_GCC_HAS_ATTRIBUTE(format, 4, 4, 0) &&     \
+  defined(__USE_MINGW_ANSI_STDIO)
+#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
+  __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
+#elif HEDLEY_HAS_ATTRIBUTE(format) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||     \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(5, 6, 0) || \
+  HEDLEY_IBM_VERSION_CHECK(10, 1, 0) || HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||  \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
+  __attribute__((__format__(__printf__, string_idx, first_to_check)))
+#elif HEDLEY_PELLES_VERSION_CHECK(6, 0, 0)
+#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)                       \
+  __declspec(vaformat(printf, string_idx, first_to_check))
+#else
+#define HEDLEY_PRINTF_FORMAT(string_idx, first_to_check)
+#endif
+
+#if defined(HEDLEY_CONSTEXPR)
+#undef HEDLEY_CONSTEXPR
+#endif
+#if defined(__cplusplus)
+#if __cplusplus >= 201103L
+#define HEDLEY_CONSTEXPR HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
+#endif
+#endif
+#if !defined(HEDLEY_CONSTEXPR)
+#define HEDLEY_CONSTEXPR
+#endif
+
+#if defined(HEDLEY_PREDICT)
+#undef HEDLEY_PREDICT
+#endif
+#if defined(HEDLEY_LIKELY)
+#undef HEDLEY_LIKELY
+#endif
+#if defined(HEDLEY_UNLIKELY)
+#undef HEDLEY_UNLIKELY
+#endif
+#if defined(HEDLEY_UNPREDICTABLE)
+#undef HEDLEY_UNPREDICTABLE
+#endif
+#if HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
+#define HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
+#endif
+#if (HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) &&                  \
+     !defined(HEDLEY_PGI_VERSION)) ||                                          \
+  HEDLEY_GCC_VERSION_CHECK(9, 0, 0)
+#define HEDLEY_PREDICT(expr, value, probability)                               \
+  __builtin_expect_with_probability((expr), (value), (probability))
+#define HEDLEY_PREDICT_TRUE(expr, probability)                                 \
+  __builtin_expect_with_probability(!!(expr), 1, (probability))
+#define HEDLEY_PREDICT_FALSE(expr, probability)                                \
+  __builtin_expect_with_probability(!!(expr), 0, (probability))
+#define HEDLEY_LIKELY(expr) __builtin_expect(!!(expr), 1)
+#define HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
+#elif (HEDLEY_HAS_BUILTIN(__builtin_expect) &&                                 \
+       !defined(HEDLEY_INTEL_CL_VERSION)) ||                                   \
+  HEDLEY_GCC_VERSION_CHECK(3, 0, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  (HEDLEY_SUNPRO_VERSION_CHECK(5, 15, 0) && defined(__cplusplus)) ||           \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(4, 7, 0) ||                                    \
+  HEDLEY_TI_CL430_VERSION_CHECK(3, 1, 0) ||                                    \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 1, 0) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
+  HEDLEY_TINYC_VERSION_CHECK(0, 9, 27) || HEDLEY_CRAY_VERSION_CHECK(8, 1, 0)
+#define HEDLEY_PREDICT(expr, expected, probability)                            \
+  (((probability) >= 0.9) ? __builtin_expect((expr), (expected))               \
+                          : (HEDLEY_STATIC_CAST(void, expected), (expr)))
+#define HEDLEY_PREDICT_TRUE(expr, probability)                                 \
+  (__extension__({                                                             \
+    double hedley_probability_ = (probability);                                \
+    ((hedley_probability_ >= 0.9)                                              \
+       ? __builtin_expect(!!(expr), 1)                                         \
+       : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0)         \
+                                       : !!(expr)));                           \
+  }))
+#define HEDLEY_PREDICT_FALSE(expr, probability)                                \
+  (__extension__({                                                             \
+    double hedley_probability_ = (probability);                                \
+    ((hedley_probability_ >= 0.9)                                              \
+       ? __builtin_expect(!!(expr), 0)                                         \
+       : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1)         \
+                                       : !!(expr)));                           \
+  }))
+#define HEDLEY_LIKELY(expr) __builtin_expect(!!(expr), 1)
+#define HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
+#else
+#define HEDLEY_PREDICT(expr, expected, probability)                            \
+  (HEDLEY_STATIC_CAST(void, expected), (expr))
+#define HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
+#define HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
+#define HEDLEY_LIKELY(expr) (!!(expr))
+#define HEDLEY_UNLIKELY(expr) (!!(expr))
+#endif
+#if !defined(HEDLEY_UNPREDICTABLE)
+#define HEDLEY_UNPREDICTABLE(expr) HEDLEY_PREDICT(expr, 1, 0.5)
+#endif
+
+#if defined(HEDLEY_MALLOC)
+#undef HEDLEY_MALLOC
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(malloc) || HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||       \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(12, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_MALLOC __attribute__((__malloc__))
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
+#define HEDLEY_MALLOC _Pragma("returns_new_memory")
+#elif HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_MALLOC __declspec(restrict)
+#else
+#define HEDLEY_MALLOC
+#endif
+
+#if defined(HEDLEY_PURE)
+#undef HEDLEY_PURE
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(pure) || HEDLEY_GCC_VERSION_CHECK(2, 96, 0) ||        \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_PURE __attribute__((__pure__))
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
+#define HEDLEY_PURE _Pragma("does_not_write_global_data")
+#elif defined(__cplusplus) && (HEDLEY_TI_CL430_VERSION_CHECK(2, 0, 1) ||       \
+                               HEDLEY_TI_CL6X_VERSION_CHECK(4, 0, 0) ||        \
+                               HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0))
+#define HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
+#else
+#define HEDLEY_PURE
+#endif
+
+#if defined(HEDLEY_CONST)
+#undef HEDLEY_CONST
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(const) || HEDLEY_GCC_VERSION_CHECK(2, 5, 0) ||        \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0) ||                                    \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0)
+#define HEDLEY_CONST __attribute__((__const__))
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0)
+#define HEDLEY_CONST _Pragma("no_side_effect")
+#else
+#define HEDLEY_CONST HEDLEY_PURE
+#endif
+
+#if defined(HEDLEY_RESTRICT)
+#undef HEDLEY_RESTRICT
+#endif
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&              \
+  !defined(__cplusplus)
+#define HEDLEY_RESTRICT restrict
+#elif HEDLEY_GCC_VERSION_CHECK(3, 1, 0) ||                                     \
+  HEDLEY_MSVC_VERSION_CHECK(14, 0, 0) ||                                       \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_PGI_VERSION_CHECK(17, 10, 0) ||                                       \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 4) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 1, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  (HEDLEY_SUNPRO_VERSION_CHECK(5, 14, 0) && defined(__cplusplus)) ||           \
+  HEDLEY_IAR_VERSION_CHECK(8, 0, 0) || defined(__clang__)
+#define HEDLEY_RESTRICT __restrict
+#elif HEDLEY_SUNPRO_VERSION_CHECK(5, 3, 0) && !defined(__cplusplus)
+#define HEDLEY_RESTRICT _Restrict
+#else
+#define HEDLEY_RESTRICT
+#endif
+
+#if defined(HEDLEY_INLINE)
+#undef HEDLEY_INLINE
+#endif
+#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) ||            \
+  (defined(__cplusplus) && (__cplusplus >= 199711L))
+#define HEDLEY_INLINE inline
+#elif defined(HEDLEY_GCC_VERSION) || HEDLEY_ARM_VERSION_CHECK(6, 2, 0)
+#define HEDLEY_INLINE __inline__
+#elif HEDLEY_MSVC_VERSION_CHECK(12, 0, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) ||                                         \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 1, 0) ||                                    \
+  HEDLEY_TI_CL430_VERSION_CHECK(3, 1, 0) ||                                    \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 2, 0) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(8, 0, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_INLINE __inline
+#else
+#define HEDLEY_INLINE
+#endif
+
+#if defined(HEDLEY_ALWAYS_INLINE)
+#undef HEDLEY_ALWAYS_INLINE
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(always_inline) ||                                     \
+  HEDLEY_GCC_VERSION_CHECK(4, 0, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) HEDLEY_INLINE
+#elif HEDLEY_MSVC_VERSION_CHECK(12, 0, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_ALWAYS_INLINE __forceinline
+#elif defined(__cplusplus) && (HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||       \
+                               HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||       \
+                               HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||      \
+                               HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||        \
+                               HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||        \
+                               HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0))
+#define HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
+#else
+#define HEDLEY_ALWAYS_INLINE HEDLEY_INLINE
+#endif
+
+#if defined(HEDLEY_NEVER_INLINE)
+#undef HEDLEY_NEVER_INLINE
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(noinline) || HEDLEY_GCC_VERSION_CHECK(4, 0, 0) ||     \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) ||                                      \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || HEDLEY_IBM_VERSION_CHECK(10, 1, 0) ||   \
+  HEDLEY_TI_VERSION_CHECK(15, 12, 0) ||                                        \
+  (HEDLEY_TI_ARMCL_VERSION_CHECK(4, 8, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_ARMCL_VERSION_CHECK(5, 2, 0) ||                                    \
+  (HEDLEY_TI_CL2000_VERSION_CHECK(6, 0, 0) &&                                  \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL2000_VERSION_CHECK(6, 4, 0) ||                                   \
+  (HEDLEY_TI_CL430_VERSION_CHECK(4, 0, 0) &&                                   \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL430_VERSION_CHECK(4, 3, 0) ||                                    \
+  (HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&                                    \
+   defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||                                   \
+  HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0) ||                                     \
+  HEDLEY_TI_CL7X_VERSION_CHECK(1, 2, 0) ||                                     \
+  HEDLEY_TI_CLPRU_VERSION_CHECK(2, 1, 0)
+#define HEDLEY_NEVER_INLINE __attribute__((__noinline__))
+#elif HEDLEY_MSVC_VERSION_CHECK(13, 10, 0) ||                                  \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_NEVER_INLINE __declspec(noinline)
+#elif HEDLEY_PGI_VERSION_CHECK(10, 2, 0)
+#define HEDLEY_NEVER_INLINE _Pragma("noinline")
+#elif HEDLEY_TI_CL6X_VERSION_CHECK(6, 0, 0) && defined(__cplusplus)
+#define HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_NEVER_INLINE _Pragma("inline=never")
+#elif HEDLEY_COMPCERT_VERSION_CHECK(3, 2, 0)
+#define HEDLEY_NEVER_INLINE __attribute((noinline))
+#elif HEDLEY_PELLES_VERSION_CHECK(9, 0, 0)
+#define HEDLEY_NEVER_INLINE __declspec(noinline)
+#else
+#define HEDLEY_NEVER_INLINE
+#endif
+
+#if defined(HEDLEY_PRIVATE)
+#undef HEDLEY_PRIVATE
+#endif
+#if defined(HEDLEY_PUBLIC)
+#undef HEDLEY_PUBLIC
+#endif
+#if defined(HEDLEY_IMPORT)
+#undef HEDLEY_IMPORT
+#endif
+#if defined(_WIN32) || defined(__CYGWIN__)
+#define HEDLEY_PRIVATE
+#define HEDLEY_PUBLIC __declspec(dllexport)
+#define HEDLEY_IMPORT __declspec(dllimport)
+#else
+#if HEDLEY_HAS_ATTRIBUTE(visibility) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||   \
+  HEDLEY_SUNPRO_VERSION_CHECK(5, 11, 0) ||                                     \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || \
+  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) ||                                        \
+  (defined(__TI_EABI__) && ((HEDLEY_TI_CL6X_VERSION_CHECK(7, 2, 0) &&          \
+                             defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) ||         \
+                            HEDLEY_TI_CL6X_VERSION_CHECK(7, 5, 0)))
+#define HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
+#define HEDLEY_PUBLIC __attribute__((__visibility__("default")))
+#else
+#define HEDLEY_PRIVATE
+#define HEDLEY_PUBLIC
+#endif
+#define HEDLEY_IMPORT extern
+#endif
+
+#if defined(HEDLEY_NO_THROW)
+#undef HEDLEY_NO_THROW
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(nothrow) || HEDLEY_GCC_VERSION_CHECK(3, 3, 0) ||      \
+  HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_NO_THROW __attribute__((__nothrow__))
+#elif HEDLEY_MSVC_VERSION_CHECK(13, 1, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0) ||                                 \
+  HEDLEY_ARM_VERSION_CHECK(4, 1, 0)
+#define HEDLEY_NO_THROW __declspec(nothrow)
+#else
+#define HEDLEY_NO_THROW
+#endif
+
+#if defined(HEDLEY_FALL_THROUGH)
+#undef HEDLEY_FALL_THROUGH
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(fallthrough) || HEDLEY_GCC_VERSION_CHECK(7, 0, 0)
+#define HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
+#elif HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang, fallthrough)
+#define HEDLEY_FALL_THROUGH                                                    \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
+#elif HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
+#define HEDLEY_FALL_THROUGH                                                    \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
+#elif defined(__fallthrough) /* SAL */
+#define HEDLEY_FALL_THROUGH __fallthrough
+#else
+#define HEDLEY_FALL_THROUGH
+#endif
+
+#if defined(HEDLEY_RETURNS_NON_NULL)
+#undef HEDLEY_RETURNS_NON_NULL
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || HEDLEY_GCC_VERSION_CHECK(4, 9, 0)
+#define HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
+#elif defined(_Ret_notnull_) /* SAL */
+#define HEDLEY_RETURNS_NON_NULL _Ret_notnull_
+#else
+#define HEDLEY_RETURNS_NON_NULL
+#endif
+
+#if defined(HEDLEY_ARRAY_PARAM)
+#undef HEDLEY_ARRAY_PARAM
+#endif
+#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) &&              \
+  !defined(__STDC_NO_VLA__) && !defined(__cplusplus) &&                        \
+  !defined(HEDLEY_PGI_VERSION) && !defined(HEDLEY_TINYC_VERSION)
+#define HEDLEY_ARRAY_PARAM(name) (name)
+#else
+#define HEDLEY_ARRAY_PARAM(name)
+#endif
+
+#if defined(HEDLEY_IS_CONSTANT)
+#undef HEDLEY_IS_CONSTANT
+#endif
+#if defined(HEDLEY_REQUIRE_CONSTEXPR)
+#undef HEDLEY_REQUIRE_CONSTEXPR
+#endif
+/* HEDLEY_IS_CONSTEXPR_ is for
+   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
+#if defined(HEDLEY_IS_CONSTEXPR_)
+#undef HEDLEY_IS_CONSTEXPR_
+#endif
+#if HEDLEY_HAS_BUILTIN(__builtin_constant_p) ||                                \
+  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_TINYC_VERSION_CHECK(0, 9, 19) || HEDLEY_ARM_VERSION_CHECK(4, 1, 0) || \
+  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) ||                                        \
+  HEDLEY_TI_CL6X_VERSION_CHECK(6, 1, 0) ||                                     \
+  (HEDLEY_SUNPRO_VERSION_CHECK(5, 10, 0) && !defined(__cplusplus)) ||          \
+  HEDLEY_CRAY_VERSION_CHECK(8, 1, 0)
+#define HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
+#endif
+#if !defined(__cplusplus)
+#if HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) ||                        \
+  HEDLEY_GCC_VERSION_CHECK(3, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || \
+  HEDLEY_IBM_VERSION_CHECK(13, 1, 0) || HEDLEY_CRAY_VERSION_CHECK(8, 1, 0) ||  \
+  HEDLEY_ARM_VERSION_CHECK(5, 4, 0) || HEDLEY_TINYC_VERSION_CHECK(0, 9, 24)
+#if defined(__INTPTR_TYPE__)
+#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
+  __builtin_types_compatible_p(                                                \
+    __typeof__((1 ? (void*)((__INTPTR_TYPE__)((expr)*0)) : (int*)0)), int*)
+#else
+#include <stdint.h>
+#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
+  __builtin_types_compatible_p(                                                \
+    __typeof__((1 ? (void*)((intptr_t)((expr)*0)) : (int*)0)), int*)
+#endif
+#elif (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) &&           \
+       !defined(HEDLEY_SUNPRO_VERSION) && !defined(HEDLEY_PGI_VERSION) &&      \
+       !defined(HEDLEY_IAR_VERSION)) ||                                        \
+  HEDLEY_HAS_EXTENSION(c_generic_selections) ||                                \
+  HEDLEY_GCC_VERSION_CHECK(4, 9, 0) || HEDLEY_INTEL_VERSION_CHECK(17, 0, 0) || \
+  HEDLEY_IBM_VERSION_CHECK(12, 1, 0) || HEDLEY_ARM_VERSION_CHECK(5, 3, 0)
+#if defined(__INTPTR_TYPE__)
+#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
+  _Generic((1 ? (void*)((__INTPTR_TYPE__)((expr)*0)) : (int*)0),               \
+    int*: 1,                                                                   \
+    void*: 0)
+#else
+#include <stdint.h>
+#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
+  _Generic((1 ? (void*)((intptr_t)*0) : (int*)0), int*: 1, void*: 0)
+#endif
+#elif defined(HEDLEY_GCC_VERSION) || defined(HEDLEY_INTEL_VERSION) ||          \
+  defined(HEDLEY_TINYC_VERSION) || defined(HEDLEY_TI_ARMCL_VERSION) ||         \
+  HEDLEY_TI_CL430_VERSION_CHECK(18, 12, 0) ||                                  \
+  defined(HEDLEY_TI_CL2000_VERSION) || defined(HEDLEY_TI_CL6X_VERSION) ||      \
+  defined(HEDLEY_TI_CL7X_VERSION) || defined(HEDLEY_TI_CLPRU_VERSION) ||       \
+  defined(__clang__)
+#define HEDLEY_IS_CONSTEXPR_(expr)                                             \
+  (sizeof(void) != sizeof(*(1 ? ((void*)((expr)*0L))                           \
+                              : ((struct { char v[sizeof(void) * 2]; }*)1))))
+#endif
+#endif
+#if defined(HEDLEY_IS_CONSTEXPR_)
+#if !defined(HEDLEY_IS_CONSTANT)
+#define HEDLEY_IS_CONSTANT(expr) HEDLEY_IS_CONSTEXPR_(expr)
+#endif
+#define HEDLEY_REQUIRE_CONSTEXPR(expr)                                         \
+  (HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
+#else
+#if !defined(HEDLEY_IS_CONSTANT)
+#define HEDLEY_IS_CONSTANT(expr) (0)
+#endif
+#define HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
+#endif
+
+#if defined(HEDLEY_BEGIN_C_DECLS)
+#undef HEDLEY_BEGIN_C_DECLS
+#endif
+#if defined(HEDLEY_END_C_DECLS)
+#undef HEDLEY_END_C_DECLS
+#endif
+#if defined(HEDLEY_C_DECL)
+#undef HEDLEY_C_DECL
+#endif
+#if defined(__cplusplus)
+#define HEDLEY_BEGIN_C_DECLS                                                   \
+  extern "C"                                                                   \
+  {
+#define HEDLEY_END_C_DECLS }
+#define HEDLEY_C_DECL extern "C"
+#else
+#define HEDLEY_BEGIN_C_DECLS
+#define HEDLEY_END_C_DECLS
+#define HEDLEY_C_DECL
+#endif
+
+#if defined(HEDLEY_STATIC_ASSERT)
+#undef HEDLEY_STATIC_ASSERT
+#endif
+#if !defined(__cplusplus) &&                                                   \
+  ((defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) ||             \
+   (HEDLEY_HAS_FEATURE(c_static_assert) &&                                     \
+    !defined(HEDLEY_INTEL_CL_VERSION)) ||                                      \
+   HEDLEY_GCC_VERSION_CHECK(6, 0, 0) ||                                        \
+   HEDLEY_INTEL_VERSION_CHECK(13, 0, 0) || defined(_Static_assert))
+#define HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
+#elif (defined(__cplusplus) && (__cplusplus >= 201103L)) ||                    \
+  HEDLEY_MSVC_VERSION_CHECK(16, 0, 0) ||                                       \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_STATIC_ASSERT(expr, message)                                    \
+  HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
+#else
+#define HEDLEY_STATIC_ASSERT(expr, message)
+#endif
+
+#if defined(HEDLEY_NULL)
+#undef HEDLEY_NULL
+#endif
+#if defined(__cplusplus)
+#if __cplusplus >= 201103L
+#define HEDLEY_NULL HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
+#elif defined(NULL)
+#define HEDLEY_NULL NULL
+#else
+#define HEDLEY_NULL HEDLEY_STATIC_CAST(void*, 0)
+#endif
+#elif defined(NULL)
+#define HEDLEY_NULL NULL
+#else
+#define HEDLEY_NULL ((void*)0)
+#endif
+
+#if defined(HEDLEY_MESSAGE)
+#undef HEDLEY_MESSAGE
+#endif
+#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+#define HEDLEY_MESSAGE(msg)                                                    \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                                    \
+  HEDLEY_PRAGMA(message msg)                                                   \
+  HEDLEY_DIAGNOSTIC_POP
+#elif HEDLEY_GCC_VERSION_CHECK(4, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message msg)
+#elif HEDLEY_CRAY_VERSION_CHECK(5, 0, 0)
+#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(_CRI message msg)
+#elif HEDLEY_IAR_VERSION_CHECK(8, 0, 0)
+#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message(msg))
+#elif HEDLEY_PELLES_VERSION_CHECK(2, 0, 0)
+#define HEDLEY_MESSAGE(msg) HEDLEY_PRAGMA(message(msg))
+#else
+#define HEDLEY_MESSAGE(msg)
+#endif
+
+#if defined(HEDLEY_WARNING)
+#undef HEDLEY_WARNING
+#endif
+#if HEDLEY_HAS_WARNING("-Wunknown-pragmas")
+#define HEDLEY_WARNING(msg)                                                    \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS                                    \
+  HEDLEY_PRAGMA(clang warning msg)                                             \
+  HEDLEY_DIAGNOSTIC_POP
+#elif HEDLEY_GCC_VERSION_CHECK(4, 8, 0) ||                                     \
+  HEDLEY_PGI_VERSION_CHECK(18, 4, 0) || HEDLEY_INTEL_VERSION_CHECK(13, 0, 0)
+#define HEDLEY_WARNING(msg) HEDLEY_PRAGMA(GCC warning msg)
+#elif HEDLEY_MSVC_VERSION_CHECK(15, 0, 0) ||                                   \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_WARNING(msg) HEDLEY_PRAGMA(message(msg))
+#else
+#define HEDLEY_WARNING(msg) HEDLEY_MESSAGE(msg)
+#endif
+
+#if defined(HEDLEY_REQUIRE)
+#undef HEDLEY_REQUIRE
+#endif
+#if defined(HEDLEY_REQUIRE_MSG)
+#undef HEDLEY_REQUIRE_MSG
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(diagnose_if)
+#if HEDLEY_HAS_WARNING("-Wgcc-compat")
+#define HEDLEY_REQUIRE(expr)                                                   \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wgcc-compat\"")                         \
+    __attribute__((diagnose_if(!(expr), #expr, "error")))                      \
+    HEDLEY_DIAGNOSTIC_POP
+#define HEDLEY_REQUIRE_MSG(expr, msg)                                          \
+  HEDLEY_DIAGNOSTIC_PUSH                                                       \
+  _Pragma("clang diagnostic ignored \"-Wgcc-compat\"")                         \
+    __attribute__((diagnose_if(!(expr), msg, "error"))) HEDLEY_DIAGNOSTIC_POP
+#else
+#define HEDLEY_REQUIRE(expr)                                                   \
+  __attribute__((diagnose_if(!(expr), #expr, "error")))
+#define HEDLEY_REQUIRE_MSG(expr, msg)                                          \
+  __attribute__((diagnose_if(!(expr), msg, "error")))
+#endif
+#else
+#define HEDLEY_REQUIRE(expr)
+#define HEDLEY_REQUIRE_MSG(expr, msg)
+#endif
+
+#if defined(HEDLEY_FLAGS)
+#undef HEDLEY_FLAGS
+#endif
+#if HEDLEY_HAS_ATTRIBUTE(flag_enum)
+#define HEDLEY_FLAGS __attribute__((__flag_enum__))
+#else
+#define HEDLEY_FLAGS
+#endif
+
+#if defined(HEDLEY_FLAGS_CAST)
+#undef HEDLEY_FLAGS_CAST
+#endif
+#if HEDLEY_INTEL_VERSION_CHECK(19, 0, 0)
+#define HEDLEY_FLAGS_CAST(T, expr)                                             \
+  (__extension__({                                                             \
+    HEDLEY_DIAGNOSTIC_PUSH                                                     \
+    _Pragma("warning(disable:188)")((T)(expr));                                \
+    HEDLEY_DIAGNOSTIC_POP                                                      \
+  }))
+#else
+#define HEDLEY_FLAGS_CAST(T, expr) HEDLEY_STATIC_CAST(T, expr)
+#endif
+
+#if defined(HEDLEY_EMPTY_BASES)
+#undef HEDLEY_EMPTY_BASES
+#endif
+#if (HEDLEY_MSVC_VERSION_CHECK(19, 0, 23918) &&                                \
+     !HEDLEY_MSVC_VERSION_CHECK(20, 0, 0)) ||                                  \
+  HEDLEY_INTEL_CL_VERSION_CHECK(2021, 1, 0)
+#define HEDLEY_EMPTY_BASES __declspec(empty_bases)
+#else
+#define HEDLEY_EMPTY_BASES
+#endif
+
+/* Remaining macros are deprecated. */
+
+#if defined(HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
+#undef HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
+#endif
+#if defined(__clang__)
+#define HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major, minor, patch) (0)
+#else
+#define HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major, minor, patch)                \
+  HEDLEY_GCC_VERSION_CHECK(major, minor, patch)
+#endif
+
+#if defined(HEDLEY_CLANG_HAS_ATTRIBUTE)
+#undef HEDLEY_CLANG_HAS_ATTRIBUTE
+#endif
+#define HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) HEDLEY_HAS_ATTRIBUTE(attribute)
+
+#if defined(HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
+#undef HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
+#endif
+#define HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute)                              \
+  HEDLEY_HAS_CPP_ATTRIBUTE(attribute)
+
+#if defined(HEDLEY_CLANG_HAS_BUILTIN)
+#undef HEDLEY_CLANG_HAS_BUILTIN
+#endif
+#define HEDLEY_CLANG_HAS_BUILTIN(builtin) HEDLEY_HAS_BUILTIN(builtin)
+
+#if defined(HEDLEY_CLANG_HAS_FEATURE)
+#undef HEDLEY_CLANG_HAS_FEATURE
+#endif
+#define HEDLEY_CLANG_HAS_FEATURE(feature) HEDLEY_HAS_FEATURE(feature)
+
+#if defined(HEDLEY_CLANG_HAS_EXTENSION)
+#undef HEDLEY_CLANG_HAS_EXTENSION
+#endif
+#define HEDLEY_CLANG_HAS_EXTENSION(extension) HEDLEY_HAS_EXTENSION(extension)
+
+#if defined(HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
+#undef HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
+#endif
+#define HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute)                         \
+  HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)
+
+#if defined(HEDLEY_CLANG_HAS_WARNING)
+#undef HEDLEY_CLANG_HAS_WARNING
+#endif
+#define HEDLEY_CLANG_HAS_WARNING(warning) HEDLEY_HAS_WARNING(warning)
+
+#endif /* !defined(HEDLEY_VERSION) || (HEDLEY_VERSION < X) */
```

## cmeel.prefix/include/proxsuite/linalg/veg/internal/external/unhedley.ext.hpp

 * *Ordering differences only*

```diff
@@ -1,148 +1,148 @@
-#undef HEDLEY_VERSION
-#undef HEDLEY_STRINGIFY_EX
-#undef HEDLEY_STRINGIFY
-#undef HEDLEY_CONCAT_EX
-#undef HEDLEY_CONCAT
-#undef HEDLEY_CONCAT3_EX
-#undef HEDLEY_CONCAT3
-#undef HEDLEY_VERSION_ENCODE
-#undef HEDLEY_VERSION_DECODE_MAJOR
-#undef HEDLEY_VERSION_DECODE_MINOR
-#undef HEDLEY_VERSION_DECODE_REVISION
-#undef HEDLEY_GNUC_VERSION
-#undef HEDLEY_GNUC_VERSION_CHECK
-#undef HEDLEY_MSVC_VERSION
-#undef HEDLEY_MSVC_VERSION_CHECK
-#undef HEDLEY_INTEL_VERSION
-#undef HEDLEY_INTEL_VERSION_CHECK
-#undef HEDLEY_INTEL_CL_VERSION
-#undef HEDLEY_INTEL_CL_VERSION_CHECK
-#undef HEDLEY_PGI_VERSION
-#undef HEDLEY_PGI_VERSION_CHECK
-#undef HEDLEY_SUNPRO_VERSION
-#undef HEDLEY_SUNPRO_VERSION_CHECK
-#undef HEDLEY_EMSCRIPTEN_VERSION
-#undef HEDLEY_EMSCRIPTEN_VERSION_CHECK
-#undef HEDLEY_ARM_VERSION
-#undef HEDLEY_ARM_VERSION_CHECK
-#undef HEDLEY_IBM_VERSION
-#undef HEDLEY_IBM_VERSION_CHECK
-#undef HEDLEY_TI_VERSION
-#undef HEDLEY_TI_VERSION_CHECK
-#undef HEDLEY_TI_CL2000_VERSION
-#undef HEDLEY_TI_CL2000_VERSION_CHECK
-#undef HEDLEY_TI_CL430_VERSION
-#undef HEDLEY_TI_CL430_VERSION_CHECK
-#undef HEDLEY_TI_ARMCL_VERSION
-#undef HEDLEY_TI_ARMCL_VERSION_CHECK
-#undef HEDLEY_TI_CL6X_VERSION
-#undef HEDLEY_TI_CL6X_VERSION_CHECK
-#undef HEDLEY_TI_CL7X_VERSION
-#undef HEDLEY_TI_CL7X_VERSION_CHECK
-#undef HEDLEY_TI_CLPRU_VERSION
-#undef HEDLEY_TI_CLPRU_VERSION_CHECK
-#undef HEDLEY_CRAY_VERSION
-#undef HEDLEY_CRAY_VERSION_CHECK
-#undef HEDLEY_IAR_VERSION
-#undef HEDLEY_IAR_VERSION_CHECK
-#undef HEDLEY_TINYC_VERSION
-#undef HEDLEY_TINYC_VERSION_CHECK
-#undef HEDLEY_DMC_VERSION
-#undef HEDLEY_DMC_VERSION_CHECK
-#undef HEDLEY_COMPCERT_VERSION
-#undef HEDLEY_COMPCERT_VERSION_CHECK
-#undef HEDLEY_PELLES_VERSION
-#undef HEDLEY_PELLES_VERSION_CHECK
-#undef HEDLEY_GCC_VERSION
-#undef HEDLEY_GCC_VERSION_CHECK
-#undef HEDLEY_HAS_ATTRIBUTE
-#undef HEDLEY_GNUC_HAS_ATTRIBUTE
-#undef HEDLEY_GCC_HAS_ATTRIBUTE
-#undef HEDLEY_HAS_CPP_ATTRIBUTE
-#undef HEDLEY_HAS_CPP_ATTRIBUTE_NS
-#undef HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
-#undef HEDLEY_GCC_HAS_CPP_ATTRIBUTE
-#undef HEDLEY_HAS_BUILTIN
-#undef HEDLEY_GNUC_HAS_BUILTIN
-#undef HEDLEY_GCC_HAS_BUILTIN
-#undef HEDLEY_HAS_FEATURE
-#undef HEDLEY_GNUC_HAS_FEATURE
-#undef HEDLEY_GCC_HAS_FEATURE
-#undef HEDLEY_HAS_EXTENSION
-#undef HEDLEY_GNUC_HAS_EXTENSION
-#undef HEDLEY_GCC_HAS_EXTENSION
-#undef HEDLEY_HAS_DECLSPEC_ATTRIBUTE
-#undef HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
-#undef HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
-#undef HEDLEY_HAS_WARNING
-#undef HEDLEY_GNUC_HAS_WARNING
-#undef HEDLEY_GCC_HAS_WARNING
-#undef HEDLEY_PRAGMA
-#undef HEDLEY_DIAGNOSTIC_PUSH
-#undef HEDLEY_DIAGNOSTIC_POP
-#undef HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
-#undef HEDLEY_CONST_CAST
-#undef HEDLEY_REINTERPRET_CAST
-#undef HEDLEY_STATIC_CAST
-#undef HEDLEY_CPP_CAST
-#undef HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
-#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
-#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
-#undef HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
-#undef HEDLEY_DEPRECATED
-#undef HEDLEY_DEPRECATED_FOR
-#undef HEDLEY_UNAVAILABLE
-#undef HEDLEY_WARN_UNUSED_RESULT
-#undef HEDLEY_WARN_UNUSED_RESULT_MSG
-#undef HEDLEY_SENTINEL
-#undef HEDLEY_NO_RETURN
-#undef HEDLEY_NO_ESCAPE
-#undef HEDLEY_ASSUME
-#undef HEDLEY_UNREACHABLE
-#undef HEDLEY_UNREACHABLE_RETURN
-#undef HEDLEY_NON_NULL
-#undef HEDLEY_PRINTF_FORMAT
-#undef HEDLEY_CONSTEXPR
-#undef HEDLEY_UNPREDICTABLE
-#undef HEDLEY_PREDICT
-#undef HEDLEY_PREDICT_TRUE
-#undef HEDLEY_PREDICT_FALSE
-#undef HEDLEY_LIKELY
-#undef HEDLEY_UNLIKELY
-#undef HEDLEY_MALLOC
-#undef HEDLEY_PURE
-#undef HEDLEY_CONST
-#undef HEDLEY_RESTRICT
-#undef HEDLEY_INLINE
-#undef HEDLEY_ALWAYS_INLINE
-#undef HEDLEY_NEVER_INLINE
-#undef HEDLEY_PRIVATE
-#undef HEDLEY_PUBLIC
-#undef HEDLEY_IMPORT
-#undef HEDLEY_NO_THROW
-#undef HEDLEY_FALL_THROUGH
-#undef HEDLEY_RETURNS_NON_NULL
-#undef HEDLEY_ARRAY_PARAM
-#undef HEDLEY_IS_CONSTANT
-#undef HEDLEY_IS_CONSTEXPR_
-#undef HEDLEY_REQUIRE_CONSTEXPR
-#undef HEDLEY_BEGIN_C_DECLS
-#undef HEDLEY_END_C_DECLS
-#undef HEDLEY_C_DECL
-#undef HEDLEY_STATIC_ASSERT
-#undef HEDLEY_NULL
-#undef HEDLEY_MESSAGE
-#undef HEDLEY_WARNING
-#undef HEDLEY_REQUIRE
-#undef HEDLEY_REQUIRE_MSG
-#undef HEDLEY_FLAGS
-#undef HEDLEY_FLAGS_CAST
-#undef HEDLEY_EMPTY_BASES
-#undef HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
-#undef HEDLEY_CLANG_HAS_ATTRIBUTE
-#undef HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
-#undef HEDLEY_CLANG_HAS_BUILTIN
-#undef HEDLEY_CLANG_HAS_FEATURE
-#undef HEDLEY_CLANG_HAS_EXTENSION
-#undef HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE
-#undef HEDLEY_CLANG_HAS_WARNING
+#undef HEDLEY_VERSION
+#undef HEDLEY_STRINGIFY_EX
+#undef HEDLEY_STRINGIFY
+#undef HEDLEY_CONCAT_EX
+#undef HEDLEY_CONCAT
+#undef HEDLEY_CONCAT3_EX
+#undef HEDLEY_CONCAT3
+#undef HEDLEY_VERSION_ENCODE
+#undef HEDLEY_VERSION_DECODE_MAJOR
+#undef HEDLEY_VERSION_DECODE_MINOR
+#undef HEDLEY_VERSION_DECODE_REVISION
+#undef HEDLEY_GNUC_VERSION
+#undef HEDLEY_GNUC_VERSION_CHECK
+#undef HEDLEY_MSVC_VERSION
+#undef HEDLEY_MSVC_VERSION_CHECK
+#undef HEDLEY_INTEL_VERSION
+#undef HEDLEY_INTEL_VERSION_CHECK
+#undef HEDLEY_INTEL_CL_VERSION
+#undef HEDLEY_INTEL_CL_VERSION_CHECK
+#undef HEDLEY_PGI_VERSION
+#undef HEDLEY_PGI_VERSION_CHECK
+#undef HEDLEY_SUNPRO_VERSION
+#undef HEDLEY_SUNPRO_VERSION_CHECK
+#undef HEDLEY_EMSCRIPTEN_VERSION
+#undef HEDLEY_EMSCRIPTEN_VERSION_CHECK
+#undef HEDLEY_ARM_VERSION
+#undef HEDLEY_ARM_VERSION_CHECK
+#undef HEDLEY_IBM_VERSION
+#undef HEDLEY_IBM_VERSION_CHECK
+#undef HEDLEY_TI_VERSION
+#undef HEDLEY_TI_VERSION_CHECK
+#undef HEDLEY_TI_CL2000_VERSION
+#undef HEDLEY_TI_CL2000_VERSION_CHECK
+#undef HEDLEY_TI_CL430_VERSION
+#undef HEDLEY_TI_CL430_VERSION_CHECK
+#undef HEDLEY_TI_ARMCL_VERSION
+#undef HEDLEY_TI_ARMCL_VERSION_CHECK
+#undef HEDLEY_TI_CL6X_VERSION
+#undef HEDLEY_TI_CL6X_VERSION_CHECK
+#undef HEDLEY_TI_CL7X_VERSION
+#undef HEDLEY_TI_CL7X_VERSION_CHECK
+#undef HEDLEY_TI_CLPRU_VERSION
+#undef HEDLEY_TI_CLPRU_VERSION_CHECK
+#undef HEDLEY_CRAY_VERSION
+#undef HEDLEY_CRAY_VERSION_CHECK
+#undef HEDLEY_IAR_VERSION
+#undef HEDLEY_IAR_VERSION_CHECK
+#undef HEDLEY_TINYC_VERSION
+#undef HEDLEY_TINYC_VERSION_CHECK
+#undef HEDLEY_DMC_VERSION
+#undef HEDLEY_DMC_VERSION_CHECK
+#undef HEDLEY_COMPCERT_VERSION
+#undef HEDLEY_COMPCERT_VERSION_CHECK
+#undef HEDLEY_PELLES_VERSION
+#undef HEDLEY_PELLES_VERSION_CHECK
+#undef HEDLEY_GCC_VERSION
+#undef HEDLEY_GCC_VERSION_CHECK
+#undef HEDLEY_HAS_ATTRIBUTE
+#undef HEDLEY_GNUC_HAS_ATTRIBUTE
+#undef HEDLEY_GCC_HAS_ATTRIBUTE
+#undef HEDLEY_HAS_CPP_ATTRIBUTE
+#undef HEDLEY_HAS_CPP_ATTRIBUTE_NS
+#undef HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
+#undef HEDLEY_GCC_HAS_CPP_ATTRIBUTE
+#undef HEDLEY_HAS_BUILTIN
+#undef HEDLEY_GNUC_HAS_BUILTIN
+#undef HEDLEY_GCC_HAS_BUILTIN
+#undef HEDLEY_HAS_FEATURE
+#undef HEDLEY_GNUC_HAS_FEATURE
+#undef HEDLEY_GCC_HAS_FEATURE
+#undef HEDLEY_HAS_EXTENSION
+#undef HEDLEY_GNUC_HAS_EXTENSION
+#undef HEDLEY_GCC_HAS_EXTENSION
+#undef HEDLEY_HAS_DECLSPEC_ATTRIBUTE
+#undef HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
+#undef HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
+#undef HEDLEY_HAS_WARNING
+#undef HEDLEY_GNUC_HAS_WARNING
+#undef HEDLEY_GCC_HAS_WARNING
+#undef HEDLEY_PRAGMA
+#undef HEDLEY_DIAGNOSTIC_PUSH
+#undef HEDLEY_DIAGNOSTIC_POP
+#undef HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
+#undef HEDLEY_CONST_CAST
+#undef HEDLEY_REINTERPRET_CAST
+#undef HEDLEY_STATIC_CAST
+#undef HEDLEY_CPP_CAST
+#undef HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
+#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
+#undef HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
+#undef HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
+#undef HEDLEY_DEPRECATED
+#undef HEDLEY_DEPRECATED_FOR
+#undef HEDLEY_UNAVAILABLE
+#undef HEDLEY_WARN_UNUSED_RESULT
+#undef HEDLEY_WARN_UNUSED_RESULT_MSG
+#undef HEDLEY_SENTINEL
+#undef HEDLEY_NO_RETURN
+#undef HEDLEY_NO_ESCAPE
+#undef HEDLEY_ASSUME
+#undef HEDLEY_UNREACHABLE
+#undef HEDLEY_UNREACHABLE_RETURN
+#undef HEDLEY_NON_NULL
+#undef HEDLEY_PRINTF_FORMAT
+#undef HEDLEY_CONSTEXPR
+#undef HEDLEY_UNPREDICTABLE
+#undef HEDLEY_PREDICT
+#undef HEDLEY_PREDICT_TRUE
+#undef HEDLEY_PREDICT_FALSE
+#undef HEDLEY_LIKELY
+#undef HEDLEY_UNLIKELY
+#undef HEDLEY_MALLOC
+#undef HEDLEY_PURE
+#undef HEDLEY_CONST
+#undef HEDLEY_RESTRICT
+#undef HEDLEY_INLINE
+#undef HEDLEY_ALWAYS_INLINE
+#undef HEDLEY_NEVER_INLINE
+#undef HEDLEY_PRIVATE
+#undef HEDLEY_PUBLIC
+#undef HEDLEY_IMPORT
+#undef HEDLEY_NO_THROW
+#undef HEDLEY_FALL_THROUGH
+#undef HEDLEY_RETURNS_NON_NULL
+#undef HEDLEY_ARRAY_PARAM
+#undef HEDLEY_IS_CONSTANT
+#undef HEDLEY_IS_CONSTEXPR_
+#undef HEDLEY_REQUIRE_CONSTEXPR
+#undef HEDLEY_BEGIN_C_DECLS
+#undef HEDLEY_END_C_DECLS
+#undef HEDLEY_C_DECL
+#undef HEDLEY_STATIC_ASSERT
+#undef HEDLEY_NULL
+#undef HEDLEY_MESSAGE
+#undef HEDLEY_WARNING
+#undef HEDLEY_REQUIRE
+#undef HEDLEY_REQUIRE_MSG
+#undef HEDLEY_FLAGS
+#undef HEDLEY_FLAGS_CAST
+#undef HEDLEY_EMPTY_BASES
+#undef HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
+#undef HEDLEY_CLANG_HAS_ATTRIBUTE
+#undef HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
+#undef HEDLEY_CLANG_HAS_BUILTIN
+#undef HEDLEY_CLANG_HAS_FEATURE
+#undef HEDLEY_CLANG_HAS_EXTENSION
+#undef HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE
+#undef HEDLEY_CLANG_HAS_WARNING
```

## cmeel.prefix/include/proxsuite/linalg/veg/memory/address.hpp

 * *Ordering differences only*

```diff
@@ -1,97 +1,97 @@
-#ifndef VEG_ADDRESS_HPP_ZP6FDIHZS
-#define VEG_ADDRESS_HPP_ZP6FDIHZS
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/std.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#if !VEG_HAS_BUILTIN(__builtin_addressof)
-
-// std::addressof
-#if __VEG_HAS_INCLUDE(<bits / move.h>)
-#include <bits/move.h>
-#else
-#include <memory>
-#endif
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-
-#if !(VEG_HAS_BUILTIN(__builtin_addressof) || defined(VEG_WITH_CXX17_SUPPORT))
-
-namespace _detail {
-namespace _mem {
-struct member_addr
-{
-  template<typename T>
-  using type = decltype(void(VEG_DECLVAL(T&).operator&()));
-
-  template<typename T>
-  VEG_INLINE static auto apply(T& var) VEG_NOEXCEPT->T*
-  {
-    using char_ref = char&;
-    return static_cast<T*>(static_cast<void*>(&char_ref(var)));
-  }
-};
-struct adl_addr : member_addr
-{
-  template<typename T>
-  using type = decltype(void(operator&(VEG_DECLVAL(T&))));
-};
-struct builtin_addr : meta::true_type
-{
-  template<typename T>
-  VEG_INLINE static constexpr auto apply(T& var) VEG_NOEXCEPT->T*
-  {
-    return &var;
-  }
-};
-template<typename T>
-struct has_member_addr
-  : meta::bool_constant<VEG_CONCEPT(detected<member_addr::type, T&>)>
-  , member_addr
-{};
-template<typename T>
-struct has_adl_addr
-  : meta::bool_constant<VEG_CONCEPT(detected<adl_addr::type, T&>)>
-  , adl_addr
-{};
-
-template<typename T>
-struct addr_impl
-  : meta::disjunction<has_member_addr<T>, has_adl_addr<T>, builtin_addr>
-{};
-
-} // namespace _mem
-} // namespace _detail
-
-#endif
-
-namespace mem {
-namespace nb {
-struct addressof
-{
-  template<typename T>
-  VEG_INLINE constexpr auto operator()(T&& var) const
-    VEG_NOEXCEPT->meta::unref_t<T>*
-  {
-#if VEG_HAS_BUILTIN(__builtin_addressof)
-    return __builtin_addressof(var);
-#elif defined(VEG_WITH_CXX17_SUPPORT)
-    return ::std::addressof(var);
-#else
-    return _detail::_mem::addr_impl<T>::apply(var);
-#endif
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(addressof);
-} // namespace mem
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_ADDRESS_HPP_ZP6FDIHZS */
+#ifndef VEG_ADDRESS_HPP_ZP6FDIHZS
+#define VEG_ADDRESS_HPP_ZP6FDIHZS
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/std.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#if !VEG_HAS_BUILTIN(__builtin_addressof)
+
+// std::addressof
+#if __VEG_HAS_INCLUDE(<bits / move.h>)
+#include <bits/move.h>
+#else
+#include <memory>
+#endif
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+
+#if !(VEG_HAS_BUILTIN(__builtin_addressof) || defined(VEG_WITH_CXX17_SUPPORT))
+
+namespace _detail {
+namespace _mem {
+struct member_addr
+{
+  template<typename T>
+  using type = decltype(void(VEG_DECLVAL(T&).operator&()));
+
+  template<typename T>
+  VEG_INLINE static auto apply(T& var) VEG_NOEXCEPT->T*
+  {
+    using char_ref = char&;
+    return static_cast<T*>(static_cast<void*>(&char_ref(var)));
+  }
+};
+struct adl_addr : member_addr
+{
+  template<typename T>
+  using type = decltype(void(operator&(VEG_DECLVAL(T&))));
+};
+struct builtin_addr : meta::true_type
+{
+  template<typename T>
+  VEG_INLINE static constexpr auto apply(T& var) VEG_NOEXCEPT->T*
+  {
+    return &var;
+  }
+};
+template<typename T>
+struct has_member_addr
+  : meta::bool_constant<VEG_CONCEPT(detected<member_addr::type, T&>)>
+  , member_addr
+{};
+template<typename T>
+struct has_adl_addr
+  : meta::bool_constant<VEG_CONCEPT(detected<adl_addr::type, T&>)>
+  , adl_addr
+{};
+
+template<typename T>
+struct addr_impl
+  : meta::disjunction<has_member_addr<T>, has_adl_addr<T>, builtin_addr>
+{};
+
+} // namespace _mem
+} // namespace _detail
+
+#endif
+
+namespace mem {
+namespace nb {
+struct addressof
+{
+  template<typename T>
+  VEG_INLINE constexpr auto operator()(T&& var) const
+    VEG_NOEXCEPT->meta::unref_t<T>*
+  {
+#if VEG_HAS_BUILTIN(__builtin_addressof)
+    return __builtin_addressof(var);
+#elif defined(VEG_WITH_CXX17_SUPPORT)
+    return ::std::addressof(var);
+#else
+    return _detail::_mem::addr_impl<T>::apply(var);
+#endif
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(addressof);
+} // namespace mem
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_ADDRESS_HPP_ZP6FDIHZS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/memory/alloc.hpp

 * *Ordering differences only*

```diff
@@ -1,352 +1,352 @@
-#ifndef VEG_ALLOC_HPP_TAWYRUICS
-#define VEG_ALLOC_HPP_TAWYRUICS
-
-#include "proxsuite/fwd.hpp"
-#include "proxsuite/linalg/veg/ref.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/internal/macros.hpp"
-#include "proxsuite/linalg/veg/memory/placement.hpp"
-#include "proxsuite/linalg/veg/type_traits/alloc.hpp"
-
-#include <cstddef> // std::max_align_t
-#include <cstdlib> // std::{malloc, free, realloc}, ::{aligned_alloc, free}
-#ifndef __APPLE__
-#include <malloc.h> // ::malloc_usable_size
-#else
-#include <AvailabilityMacros.h>
-#include <malloc/malloc.h>
-#define malloc_usable_size malloc_size
-#endif
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-
-#ifdef __APPLE__
-namespace alignment {
-
-#if MAC_OS_X_VERSION_MIN_REQUIRED >= 101500 &&                                 \
-  (defined(_LIBCPP_HAS_ALIGNED_ALLOC) || defined(_LIBCPP_HAS_C11_FEATURES)) && \
-  defined(PROXSUITE_WITH_CPP_17)
-VEG_INLINE void*
-aligned_alloc(std::size_t alignment, std::size_t size)
-{
-  return std::aligned_alloc(alignment, size);
-}
-#elif MAC_OS_X_VERSION_MIN_REQUIRED >= 1090
-VEG_INLINE void*
-aligned_alloc(std::size_t alignment, std::size_t size)
-{
-  if (alignment < sizeof(void*)) {
-    alignment = sizeof(void*);
-  }
-  void* p;
-  if (::posix_memalign(&p, alignment, size) != 0) {
-    p = 0;
-  }
-  return p;
-}
-#endif
-
-} // namespace alignment
-#endif
-
-// Support aligned_alloc for c++14, code from boost/align.
-namespace alignment {
-namespace detail {
-// Source: https://www.boost.org/doc/libs/1_65_0/boost/align/detail/min_size.hpp
-template<std::size_t A, std::size_t B>
-struct min_size : std::integral_constant<std::size_t, (A < B) ? A : B>
-{};
-
-template<class T>
-struct offset_value
-{
-  char value;
-  T object;
-};
-
-// Source:
-// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/alignment_of.hpp
-template<class T>
-struct alignment_of : min_size<sizeof(T), sizeof(offset_value<T>) - sizeof(T)>
-{};
-
-// Source:
-// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/is_alignment.hpp
-constexpr inline bool
-is_alignment(std::size_t value)
-{
-  return (value > 0) && ((value & (value - 1)) == 0);
-}
-
-// Source: https://www.boost.org/doc/libs/1_74_0/boost/align/detail/align.hpp
-inline void*
-align(std::size_t alignment, std::size_t size, void*& ptr, std::size_t& space)
-{
-  assert(is_alignment(alignment));
-  char* p = reinterpret_cast<char*>(
-    ~(alignment - 1) & (reinterpret_cast<std::size_t>(ptr) + alignment - 1));
-  assert((p - static_cast<char*>(ptr)) >= 0);
-  std::size_t n = std::size_t(p - static_cast<char*>(ptr));
-  if (size + n <= space) {
-    ptr = p;
-    space -= n;
-    return p;
-  }
-  return 0;
-}
-
-// Source:
-// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/aligned_alloc.hpp
-inline void*
-aligned_alloc(std::size_t alignment, std::size_t size)
-{
-  assert(is_alignment(alignment));
-  enum
-  {
-    N = alignment_of<void*>::value
-  };
-  if (alignment < N) {
-    alignment = N;
-  }
-  std::size_t n = size + alignment - N;
-  void* p = std::malloc(sizeof(void*) + n);
-  if (p) {
-    void* r = static_cast<char*>(p) + sizeof(void*);
-    (void)align(alignment, size, r, n);
-    *(static_cast<void**>(r) - 1) = p;
-    p = r;
-  }
-  return p;
-}
-} // namespace detail
-} // namespace alignment
-
-namespace mem {
-enum struct CopyAvailable
-{
-  no,
-  yes_maythrow,
-  yes_nothrow,
-};
-enum struct DtorAvailable
-{
-  no,
-  yes_maythrow,
-  yes_nothrow,
-};
-template<typename T>
-struct CopyAvailableFor
-  : meta::constant<mem::CopyAvailable,
-                   (VEG_CONCEPT(nothrow_copyable<T>) &&
-                    VEG_CONCEPT(nothrow_copy_assignable<T>))
-                     ? CopyAvailable::yes_nothrow
-                   : (VEG_CONCEPT(copyable<T>) &&
-                      VEG_CONCEPT(copy_assignable<T>))
-                     ? CopyAvailable::yes_maythrow
-                     : CopyAvailable::no>
-{};
-template<typename T>
-struct DtorAvailableFor
-  : meta::constant<mem::DtorAvailable,
-                   VEG_CONCEPT(nothrow_destructible<T>)
-                     ? DtorAvailable::yes_nothrow
-                     : DtorAvailable::yes_maythrow>
-{};
-
-VEG_INLINE auto
-aligned_alloc(usize align, usize size) noexcept -> void*
-{
-  usize const mask = align - 1;
-#if defined(_WIN32)
-  return _aligned_malloc((size + mask) & ~mask, align);
-#elif defined(__APPLE__)
-#ifdef PROXSUITE_WITH_CPP_17
-  return alignment::aligned_alloc(align, (size + mask) & ~mask);
-#else
-  return alignment::detail::aligned_alloc(align, (size + mask) & ~mask);
-#endif
-#else
-#ifdef PROXSUITE_WITH_CPP_17
-  return std::aligned_alloc(align, (size + mask) & ~mask);
-#else
-  return alignment::detail::aligned_alloc(align, (size + mask) & ~mask);
-#endif
-#endif
-}
-
-VEG_INLINE void
-aligned_free(usize /*align*/, void* ptr) noexcept
-{
-#ifndef _WIN32
-  std::free(ptr);
-#else
-  _aligned_free(ptr);
-#endif
-}
-
-struct SystemAlloc
-{
-  constexpr friend auto operator==(SystemAlloc /*unused*/,
-                                   SystemAlloc /*unused*/) noexcept -> bool
-  {
-    return true;
-  }
-};
-template<>
-struct Alloc<SystemAlloc>
-{
-  static constexpr usize max_base_align = alignof(std::max_align_t);
-
-  VEG_INLINE static void dealloc(RefMut<SystemAlloc> /*alloc*/,
-                                 void* ptr,
-                                 Layout layout) noexcept
-  {
-    (layout.align <= max_base_align) ? std::free(ptr)
-                                     : mem::aligned_free(layout.align, ptr);
-  }
-  VEG_NODISCARD VEG_INLINE static auto alloc(RefMut<SystemAlloc> /*alloc*/,
-                                             Layout layout) noexcept
-    -> mem::AllocBlock
-  {
-    void* ptr = (layout.align <= max_base_align)
-                  ? std::malloc(layout.byte_size)
-                  : mem::aligned_alloc(layout.align, layout.byte_size);
-    if (HEDLEY_UNLIKELY(ptr == nullptr)) {
-      _detail::terminate();
-    }
-#ifndef _WIN32
-    return { ptr, ::malloc_usable_size(ptr) };
-#else
-    return { ptr, _msize(ptr) };
-#endif
-  }
-  VEG_NODISCARD VEG_NO_INLINE static auto realloc(RefMut<SystemAlloc> /*alloc*/,
-                                                  void* ptr,
-                                                  Layout layout,
-                                                  usize new_size,
-                                                  usize copy_size,
-                                                  RelocFn reloc) noexcept
-    -> mem::AllocBlock
-  {
-    void* new_ptr; // NOLINT
-    bool typical_align = layout.align <= max_base_align;
-    bool trivial_reloc = reloc.is_trivial();
-    bool use_realloc = typical_align && trivial_reloc;
-
-    if (use_realloc) {
-      new_ptr = std::realloc(ptr, new_size);
-    } else {
-      new_ptr = mem::aligned_alloc(layout.align, new_size);
-    }
-
-    if (HEDLEY_UNLIKELY(new_ptr == nullptr)) {
-      _detail::terminate();
-    }
-
-    if (!use_realloc) {
-      reloc(new_ptr, ptr, copy_size);
-      mem::aligned_free(layout.align, ptr);
-    }
-#ifndef _WIN32
-    return { new_ptr, ::malloc_usable_size(new_ptr) };
-#else
-    return { new_ptr, _msize(new_ptr) };
-#endif
-  }
-  VEG_NODISCARD VEG_INLINE auto try_grow_in_place(
-    void* /*ptr*/,
-    Layout /*layout*/,
-    usize /*new_size*/) const noexcept -> bool
-  {
-    return false;
-  }
-  VEG_NODISCARD VEG_INLINE static auto grow(RefMut<SystemAlloc> alloc,
-                                            void* ptr,
-                                            Layout layout,
-                                            usize new_size,
-                                            RelocFn reloc) noexcept
-    -> mem::AllocBlock
-  {
-    return realloc(
-      VEG_FWD(alloc), ptr, layout, new_size, layout.byte_size, reloc);
-  }
-  VEG_NODISCARD VEG_INLINE static auto shrink(RefMut<SystemAlloc> alloc,
-                                              void* ptr,
-                                              Layout layout,
-                                              usize new_size,
-                                              RelocFn reloc) noexcept
-    -> mem::AllocBlock
-  {
-    return realloc(VEG_FWD(alloc), ptr, layout, new_size, new_size, reloc);
-  }
-};
-
-struct DefaultCloner
-{};
-template<>
-struct Cloner<DefaultCloner>
-{
-  template<typename T>
-  using trivial_clone = meta::bool_constant<VEG_CONCEPT(trivially_copyable<T>)>;
-
-  template<typename T, typename Alloc>
-  VEG_INLINE static void destroy(RefMut<DefaultCloner> /*cloner*/,
-                                 T* ptr,
-                                 RefMut<Alloc> /*alloc*/)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
-  {
-    mem::destroy_at(ptr);
-  }
-  VEG_TEMPLATE((typename T, typename Alloc),
-               requires(VEG_CONCEPT(copyable<T>)),
-               VEG_NODISCARD VEG_INLINE static auto clone,
-               (/*cloner*/, RefMut<DefaultCloner>),
-               (rhs, Ref<T>),
-               (/*alloc*/, RefMut<Alloc>))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<T>))->T { return T(rhs.get()); }
-  VEG_TEMPLATE((typename T, typename Alloc),
-               requires(VEG_CONCEPT(copyable<T>)),
-               VEG_INLINE static void clone_from,
-               (/*cloner*/, RefMut<DefaultCloner>),
-               (lhs, RefMut<T>),
-               (rhs, Ref<T>),
-               (/*alloc*/, RefMut<Alloc>))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<T>))
-  {
-    lhs.get() = rhs.get();
-  }
-};
-
-VEG_INLINE_VAR(system_alloc, SystemAlloc);
-VEG_INLINE_VAR(default_cloner, DefaultCloner);
-} // namespace mem
-
-namespace _detail {
-namespace _mem {
-template<typename A>
-struct ManagedAlloc /* NOLINT */
-{
-  void* data;
-  mem::Layout layout;
-  RefMut<A> alloc;
-
-  VEG_INLINE ~ManagedAlloc()
-  {
-    if (data != nullptr) {
-      mem::Alloc<A>::dealloc(VEG_FWD(alloc), VEG_FWD(data), VEG_FWD(layout));
-    }
-  }
-};
-} // namespace _mem
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_ALLOC_HPP_TAWYRUICS */
+#ifndef VEG_ALLOC_HPP_TAWYRUICS
+#define VEG_ALLOC_HPP_TAWYRUICS
+
+#include "proxsuite/fwd.hpp"
+#include "proxsuite/linalg/veg/ref.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/internal/macros.hpp"
+#include "proxsuite/linalg/veg/memory/placement.hpp"
+#include "proxsuite/linalg/veg/type_traits/alloc.hpp"
+
+#include <cstddef> // std::max_align_t
+#include <cstdlib> // std::{malloc, free, realloc}, ::{aligned_alloc, free}
+#ifndef __APPLE__
+#include <malloc.h> // ::malloc_usable_size
+#else
+#include <AvailabilityMacros.h>
+#include <malloc/malloc.h>
+#define malloc_usable_size malloc_size
+#endif
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+
+#ifdef __APPLE__
+namespace alignment {
+
+#if MAC_OS_X_VERSION_MIN_REQUIRED >= 101500 &&                                 \
+  (defined(_LIBCPP_HAS_ALIGNED_ALLOC) || defined(_LIBCPP_HAS_C11_FEATURES)) && \
+  defined(PROXSUITE_WITH_CPP_17)
+VEG_INLINE void*
+aligned_alloc(std::size_t alignment, std::size_t size)
+{
+  return std::aligned_alloc(alignment, size);
+}
+#elif MAC_OS_X_VERSION_MIN_REQUIRED >= 1090
+VEG_INLINE void*
+aligned_alloc(std::size_t alignment, std::size_t size)
+{
+  if (alignment < sizeof(void*)) {
+    alignment = sizeof(void*);
+  }
+  void* p;
+  if (::posix_memalign(&p, alignment, size) != 0) {
+    p = 0;
+  }
+  return p;
+}
+#endif
+
+} // namespace alignment
+#endif
+
+// Support aligned_alloc for c++14, code from boost/align.
+namespace alignment {
+namespace detail {
+// Source: https://www.boost.org/doc/libs/1_65_0/boost/align/detail/min_size.hpp
+template<std::size_t A, std::size_t B>
+struct min_size : std::integral_constant<std::size_t, (A < B) ? A : B>
+{};
+
+template<class T>
+struct offset_value
+{
+  char value;
+  T object;
+};
+
+// Source:
+// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/alignment_of.hpp
+template<class T>
+struct alignment_of : min_size<sizeof(T), sizeof(offset_value<T>) - sizeof(T)>
+{};
+
+// Source:
+// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/is_alignment.hpp
+constexpr inline bool
+is_alignment(std::size_t value)
+{
+  return (value > 0) && ((value & (value - 1)) == 0);
+}
+
+// Source: https://www.boost.org/doc/libs/1_74_0/boost/align/detail/align.hpp
+inline void*
+align(std::size_t alignment, std::size_t size, void*& ptr, std::size_t& space)
+{
+  assert(is_alignment(alignment));
+  char* p = reinterpret_cast<char*>(
+    ~(alignment - 1) & (reinterpret_cast<std::size_t>(ptr) + alignment - 1));
+  assert((p - static_cast<char*>(ptr)) >= 0);
+  std::size_t n = std::size_t(p - static_cast<char*>(ptr));
+  if (size + n <= space) {
+    ptr = p;
+    space -= n;
+    return p;
+  }
+  return 0;
+}
+
+// Source:
+// https://www.boost.org/doc/libs/1_65_0/boost/align/detail/aligned_alloc.hpp
+inline void*
+aligned_alloc(std::size_t alignment, std::size_t size)
+{
+  assert(is_alignment(alignment));
+  enum
+  {
+    N = alignment_of<void*>::value
+  };
+  if (alignment < N) {
+    alignment = N;
+  }
+  std::size_t n = size + alignment - N;
+  void* p = std::malloc(sizeof(void*) + n);
+  if (p) {
+    void* r = static_cast<char*>(p) + sizeof(void*);
+    (void)align(alignment, size, r, n);
+    *(static_cast<void**>(r) - 1) = p;
+    p = r;
+  }
+  return p;
+}
+} // namespace detail
+} // namespace alignment
+
+namespace mem {
+enum struct CopyAvailable
+{
+  no,
+  yes_maythrow,
+  yes_nothrow,
+};
+enum struct DtorAvailable
+{
+  no,
+  yes_maythrow,
+  yes_nothrow,
+};
+template<typename T>
+struct CopyAvailableFor
+  : meta::constant<mem::CopyAvailable,
+                   (VEG_CONCEPT(nothrow_copyable<T>) &&
+                    VEG_CONCEPT(nothrow_copy_assignable<T>))
+                     ? CopyAvailable::yes_nothrow
+                   : (VEG_CONCEPT(copyable<T>) &&
+                      VEG_CONCEPT(copy_assignable<T>))
+                     ? CopyAvailable::yes_maythrow
+                     : CopyAvailable::no>
+{};
+template<typename T>
+struct DtorAvailableFor
+  : meta::constant<mem::DtorAvailable,
+                   VEG_CONCEPT(nothrow_destructible<T>)
+                     ? DtorAvailable::yes_nothrow
+                     : DtorAvailable::yes_maythrow>
+{};
+
+VEG_INLINE auto
+aligned_alloc(usize align, usize size) noexcept -> void*
+{
+  usize const mask = align - 1;
+#if defined(_WIN32)
+  return _aligned_malloc((size + mask) & ~mask, align);
+#elif defined(__APPLE__)
+#ifdef PROXSUITE_WITH_CPP_17
+  return alignment::aligned_alloc(align, (size + mask) & ~mask);
+#else
+  return alignment::detail::aligned_alloc(align, (size + mask) & ~mask);
+#endif
+#else
+#ifdef PROXSUITE_WITH_CPP_17
+  return std::aligned_alloc(align, (size + mask) & ~mask);
+#else
+  return alignment::detail::aligned_alloc(align, (size + mask) & ~mask);
+#endif
+#endif
+}
+
+VEG_INLINE void
+aligned_free(usize /*align*/, void* ptr) noexcept
+{
+#ifndef _WIN32
+  std::free(ptr);
+#else
+  _aligned_free(ptr);
+#endif
+}
+
+struct SystemAlloc
+{
+  constexpr friend auto operator==(SystemAlloc /*unused*/,
+                                   SystemAlloc /*unused*/) noexcept -> bool
+  {
+    return true;
+  }
+};
+template<>
+struct Alloc<SystemAlloc>
+{
+  static constexpr usize max_base_align = alignof(std::max_align_t);
+
+  VEG_INLINE static void dealloc(RefMut<SystemAlloc> /*alloc*/,
+                                 void* ptr,
+                                 Layout layout) noexcept
+  {
+    (layout.align <= max_base_align) ? std::free(ptr)
+                                     : mem::aligned_free(layout.align, ptr);
+  }
+  VEG_NODISCARD VEG_INLINE static auto alloc(RefMut<SystemAlloc> /*alloc*/,
+                                             Layout layout) noexcept
+    -> mem::AllocBlock
+  {
+    void* ptr = (layout.align <= max_base_align)
+                  ? std::malloc(layout.byte_size)
+                  : mem::aligned_alloc(layout.align, layout.byte_size);
+    if (HEDLEY_UNLIKELY(ptr == nullptr)) {
+      _detail::terminate();
+    }
+#ifndef _WIN32
+    return { ptr, ::malloc_usable_size(ptr) };
+#else
+    return { ptr, _msize(ptr) };
+#endif
+  }
+  VEG_NODISCARD VEG_NO_INLINE static auto realloc(RefMut<SystemAlloc> /*alloc*/,
+                                                  void* ptr,
+                                                  Layout layout,
+                                                  usize new_size,
+                                                  usize copy_size,
+                                                  RelocFn reloc) noexcept
+    -> mem::AllocBlock
+  {
+    void* new_ptr; // NOLINT
+    bool typical_align = layout.align <= max_base_align;
+    bool trivial_reloc = reloc.is_trivial();
+    bool use_realloc = typical_align && trivial_reloc;
+
+    if (use_realloc) {
+      new_ptr = std::realloc(ptr, new_size);
+    } else {
+      new_ptr = mem::aligned_alloc(layout.align, new_size);
+    }
+
+    if (HEDLEY_UNLIKELY(new_ptr == nullptr)) {
+      _detail::terminate();
+    }
+
+    if (!use_realloc) {
+      reloc(new_ptr, ptr, copy_size);
+      mem::aligned_free(layout.align, ptr);
+    }
+#ifndef _WIN32
+    return { new_ptr, ::malloc_usable_size(new_ptr) };
+#else
+    return { new_ptr, _msize(new_ptr) };
+#endif
+  }
+  VEG_NODISCARD VEG_INLINE auto try_grow_in_place(
+    void* /*ptr*/,
+    Layout /*layout*/,
+    usize /*new_size*/) const noexcept -> bool
+  {
+    return false;
+  }
+  VEG_NODISCARD VEG_INLINE static auto grow(RefMut<SystemAlloc> alloc,
+                                            void* ptr,
+                                            Layout layout,
+                                            usize new_size,
+                                            RelocFn reloc) noexcept
+    -> mem::AllocBlock
+  {
+    return realloc(
+      VEG_FWD(alloc), ptr, layout, new_size, layout.byte_size, reloc);
+  }
+  VEG_NODISCARD VEG_INLINE static auto shrink(RefMut<SystemAlloc> alloc,
+                                              void* ptr,
+                                              Layout layout,
+                                              usize new_size,
+                                              RelocFn reloc) noexcept
+    -> mem::AllocBlock
+  {
+    return realloc(VEG_FWD(alloc), ptr, layout, new_size, new_size, reloc);
+  }
+};
+
+struct DefaultCloner
+{};
+template<>
+struct Cloner<DefaultCloner>
+{
+  template<typename T>
+  using trivial_clone = meta::bool_constant<VEG_CONCEPT(trivially_copyable<T>)>;
+
+  template<typename T, typename Alloc>
+  VEG_INLINE static void destroy(RefMut<DefaultCloner> /*cloner*/,
+                                 T* ptr,
+                                 RefMut<Alloc> /*alloc*/)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
+  {
+    mem::destroy_at(ptr);
+  }
+  VEG_TEMPLATE((typename T, typename Alloc),
+               requires(VEG_CONCEPT(copyable<T>)),
+               VEG_NODISCARD VEG_INLINE static auto clone,
+               (/*cloner*/, RefMut<DefaultCloner>),
+               (rhs, Ref<T>),
+               (/*alloc*/, RefMut<Alloc>))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copyable<T>))->T { return T(rhs.get()); }
+  VEG_TEMPLATE((typename T, typename Alloc),
+               requires(VEG_CONCEPT(copyable<T>)),
+               VEG_INLINE static void clone_from,
+               (/*cloner*/, RefMut<DefaultCloner>),
+               (lhs, RefMut<T>),
+               (rhs, Ref<T>),
+               (/*alloc*/, RefMut<Alloc>))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_copy_assignable<T>))
+  {
+    lhs.get() = rhs.get();
+  }
+};
+
+VEG_INLINE_VAR(system_alloc, SystemAlloc);
+VEG_INLINE_VAR(default_cloner, DefaultCloner);
+} // namespace mem
+
+namespace _detail {
+namespace _mem {
+template<typename A>
+struct ManagedAlloc /* NOLINT */
+{
+  void* data;
+  mem::Layout layout;
+  RefMut<A> alloc;
+
+  VEG_INLINE ~ManagedAlloc()
+  {
+    if (data != nullptr) {
+      mem::Alloc<A>::dealloc(VEG_FWD(alloc), VEG_FWD(data), VEG_FWD(layout));
+    }
+  }
+};
+} // namespace _mem
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_ALLOC_HPP_TAWYRUICS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/memory/dynamic_stack.hpp

 * *Ordering differences only*

```diff
@@ -1,504 +1,504 @@
-#ifndef VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS
-#define VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS
-
-#include "proxsuite/fwd.hpp"
-#include "proxsuite/linalg/veg/util/assert.hpp"
-#include "proxsuite/linalg/veg/internal/collection_algo.hpp"
-#include "proxsuite/linalg/veg/memory/alloc.hpp"
-#include "proxsuite/linalg/veg/memory/placement.hpp"
-#include "proxsuite/linalg/veg/slice.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/memory/placement.hpp"
-#include "proxsuite/linalg/veg/memory/address.hpp"
-#include "proxsuite/linalg/veg/internal/narrow.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-namespace _dynstack {
-constexpr auto
-max2(isize a, isize b) noexcept -> isize
-{
-  return (a > b) ? a : b;
-}
-constexpr auto
-round_up_pow2(isize a, isize b) noexcept -> isize
-{
-  return isize((usize(a) + ~(0 - usize(b))) & (0 - usize(b)));
-}
-} // namespace _dynstack
-} // namespace _detail
-namespace dynstack {
-struct StackReq
-{
-  isize size_bytes;
-  isize align;
-
-  constexpr friend auto operator==(StackReq a, StackReq b) noexcept -> bool
-  {
-    return a.size_bytes == b.size_bytes && a.align == b.align;
-  }
-
-  constexpr friend auto operator&(StackReq a, StackReq b) noexcept -> StackReq
-  {
-    using namespace _detail::_dynstack;
-    return {
-      round_up_pow2(   //
-        round_up_pow2( //
-          a.size_bytes,
-          b.align) +
-          b.size_bytes,
-        (max2)(a.align, b.align)),
-      (max2)(a.align, b.align),
-    };
-  }
-  constexpr friend auto operator|(StackReq a, StackReq b) noexcept -> StackReq
-  {
-    using namespace _detail::_dynstack;
-    return {
-      (max2)( //
-        round_up_pow2(a.size_bytes, max2(a.align, b.align)),
-        round_up_pow2(b.size_bytes, max2(a.align, b.align))),
-      (max2)(a.align, b.align),
-    };
-  }
-
-  constexpr auto alloc_req() const noexcept -> isize
-  {
-    return size_bytes + align - 1;
-  }
-
-  template<typename T>
-  static constexpr auto with_len(proxsuite::linalg::veg::Tag<T> /*tag*/,
-                                 isize len) noexcept -> StackReq
-  {
-    return {
-      isize{ sizeof(T) } * len,
-      isize{ alignof(T) },
-    };
-  }
-
-  static VEG_CPP14(constexpr) auto and_(Slice<StackReq> reqs) noexcept
-    -> StackReq
-  {
-    StackReq req{ 0, 1 };
-    for (isize i = 0; i < reqs.len(); ++i) {
-      req = req & reqs.ptr()[i];
-    }
-    return req;
-  }
-
-  static VEG_CPP14(constexpr) auto or_(Slice<StackReq> reqs) noexcept
-    -> StackReq
-  {
-    StackReq req{ 0, 1 };
-    for (isize i = 0; i < reqs.len(); ++i) {
-      req = req | reqs.ptr()[i];
-    }
-    return req;
-  }
-};
-
-template<typename T>
-struct DynStackArray;
-template<typename T>
-struct DynStackAlloc;
-} // namespace dynstack
-
-namespace _detail {
-// if possible:
-// aligns the pointer
-// then advances it by `size` bytes, and decreases `space` by `size`
-// returns the previous aligned value
-//
-// otherwise, if there is not enough space for aligning or advancing the
-// pointer, returns nullptr and the values are left unmodified
-inline auto
-align_next(isize alignment, isize size, void*& ptr, isize& space)
-  VEG_ALWAYS_NOEXCEPT->void*
-{
-  static_assert(sizeof(std::uintptr_t) >= sizeof(void*),
-                "std::uintptr_t can't hold a pointer value");
-
-  using byte_ptr = unsigned char*;
-
-  // assert alignment is power of two
-  VEG_ASSERT_ALL_OF( //
-    (alignment > isize{ 0 }),
-    ((u64(alignment) & (u64(alignment) - 1)) == u64(0)));
-
-  if (space < size) {
-    return nullptr;
-  }
-
-  std::uintptr_t lo_mask = usize(alignment) - 1;
-  std::uintptr_t hi_mask = ~lo_mask;
-
-  auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
-  auto* const byteptr = static_cast<byte_ptr>(ptr);
-
-  auto offset = ((intptr + usize(alignment) - 1) & hi_mask) - intptr;
-
-  if (usize(space) - usize(size) < offset) {
-    return nullptr;
-  }
-
-  void* const rv = byteptr + offset;
-
-  ptr = byteptr + (offset + usize(size));
-  space = space - (isize(offset) + (size));
-
-  return rv;
-}
-} // namespace _detail
-
-namespace _detail {
-namespace _dynstack {
-template<typename T, bool = VEG_CONCEPT(trivially_destructible<T>)>
-struct DynStackArrayDtor
-{};
-
-template<typename T>
-struct DynStackArrayDtor<T, false>
-{
-  DynStackArrayDtor() = default;
-  DynStackArrayDtor(DynStackArrayDtor const&) = default;
-  DynStackArrayDtor(DynStackArrayDtor&&) = default;
-  auto operator=(DynStackArrayDtor const&) -> DynStackArrayDtor& = default;
-  auto operator=(DynStackArrayDtor&&) -> DynStackArrayDtor& = default;
-  VEG_INLINE ~DynStackArrayDtor()
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
-  {
-    auto& self = static_cast<dynstack::DynStackArray<T>&>(*this);
-    using Base = typename dynstack::DynStackAlloc<T>::Base const&;
-    proxsuite::linalg::veg::_detail::_collections::backward_destroy(
-      mut(mem::SystemAlloc{}),
-      mut(mem::DefaultCloner{}),
-      self.ptr_mut(),
-      self.ptr_mut() + Base(self).len);
-  }
-};
-
-struct cleanup;
-struct DynAllocBase;
-
-struct default_init_fn
-{
-  template<typename T>
-  auto make(void* ptr, isize len) -> T*
-  {
-    return ::new (ptr) T[usize(len)];
-  }
-};
-
-struct zero_init_fn
-{
-  template<typename T>
-  auto make(void* ptr, isize len) -> T*
-  {
-    return ::new (ptr) T[usize(len)]{};
-  }
-};
-
-struct no_init_fn
-{
-  template<typename T>
-  auto make(void* ptr, isize len) -> T*
-  {
-    return proxsuite::linalg::veg::mem::launder(static_cast<T*>(
-      static_cast<void*>(::new (ptr) unsigned char[usize(len) * sizeof(T)])));
-  }
-};
-
-} // namespace _dynstack
-} // namespace _detail
-
-namespace dynstack {
-struct DynStackMut
-{
-public:
-  DynStackMut(FromSliceMut /*tag*/, SliceMut<unsigned char> s) VEG_NOEXCEPT
-    : stack_data(s.ptr_mut())
-    , stack_bytes(s.len())
-  {
-  }
-
-  VEG_NODISCARD
-  auto remaining_bytes() const VEG_NOEXCEPT->isize
-  {
-    return isize(stack_bytes);
-  }
-  VEG_NODISCARD
-  auto ptr_mut() const VEG_NOEXCEPT->void* { return stack_data; }
-  VEG_NODISCARD
-  auto ptr() const VEG_NOEXCEPT->void const* { return stack_data; }
-
-private:
-  VEG_INLINE void assert_valid_len(PROXSUITE_MAYBE_UNUSED isize len)
-    VEG_NOEXCEPT
-  {
-    VEG_INTERNAL_ASSERT_PRECONDITIONS(isize(len) >= 0);
-  }
-
-public:
-  VEG_TEMPLATE((typename T),
-               requires VEG_CONCEPT(constructible<T>),
-               VEG_NODISCARD auto make_new,
-               (/*unused*/, Tag<T>),
-               (len, isize),
-               (align = alignof(T), isize))
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))->DynStackArray<T>
-  {
-    assert_valid_len(len);
-    DynStackArray<T> get{
-      *this, isize(len), align, _detail::_dynstack::zero_init_fn{}
-    };
-    VEG_ASSERT(get.ptr() != nullptr);
-    return VEG_FWD(get);
-  }
-
-  VEG_TEMPLATE((typename T),
-               requires VEG_CONCEPT(constructible<T>),
-               VEG_NODISCARD auto make_new_for_overwrite,
-               (/*unused*/, Tag<T>),
-               (len, isize),
-               (align = alignof(T), isize))
-
-  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))->DynStackArray<T>
-  {
-    assert_valid_len(len);
-    DynStackArray<T> get{
-      *this, isize(len), align, _detail::_dynstack::default_init_fn{}
-    };
-    VEG_ASSERT(get.ptr() != nullptr);
-    return VEG_FWD(get);
-  }
-
-  template<typename T>
-  VEG_NODISCARD auto make_alloc(Tag<T> /*unused*/,
-                                isize len,
-                                isize align = alignof(T))
-    VEG_NOEXCEPT->DynStackAlloc<T>
-  {
-    assert_valid_len(len);
-    DynStackAlloc<T> get{
-      *this, isize(len), align, _detail::_dynstack::no_init_fn{}
-    };
-    VEG_ASSERT(get.ptr() != nullptr);
-    return VEG_FWD(get);
-  }
-
-private:
-  void* stack_data;
-  isize stack_bytes;
-
-  template<typename T>
-  friend struct DynStackAlloc;
-  template<typename T>
-  friend struct DynStackArray;
-  friend struct _detail::_dynstack::cleanup;
-  friend struct _detail::_dynstack::DynAllocBase;
-};
-} // namespace dynstack
-
-namespace _detail {
-namespace _dynstack {
-
-struct cleanup
-{
-  bool const& success;
-  proxsuite::linalg::veg::dynstack::DynStackMut& parent;
-  void* old_data;
-  isize old_rem_bytes;
-
-  VEG_INLINE void operator()() const VEG_NOEXCEPT
-  {
-    if (!success) {
-      parent.stack_data = old_data;
-      parent.stack_bytes = old_rem_bytes;
-    }
-  }
-};
-
-struct DynAllocBase
-{
-  proxsuite::linalg::veg::dynstack::DynStackMut* parent;
-  void* old_pos;
-  void const volatile* data;
-  isize len;
-
-  void destroy(void const volatile* void_data_end) VEG_NOEXCEPT
-  {
-    if (data != nullptr) {
-      // in case resource lifetimes are reodered by moving ownership
-      PROXSUITE_MAYBE_UNUSED auto* parent_stack_data =
-        static_cast<unsigned char*>(parent->stack_data);
-      PROXSUITE_MAYBE_UNUSED auto* old_position =
-        static_cast<unsigned char*>(old_pos);
-      PROXSUITE_MAYBE_UNUSED auto* data_end =
-        static_cast<unsigned char*>(const_cast<void*>(void_data_end));
-
-      VEG_INTERNAL_ASSERT_PRECONDITIONS( //
-        parent_stack_data == data_end,
-        parent_stack_data >= old_position);
-
-      parent->stack_bytes +=
-        static_cast<isize>(static_cast<unsigned char*>(parent->stack_data) -
-                           static_cast<unsigned char*>(old_pos));
-      parent->stack_data = old_pos;
-    }
-  }
-};
-} // namespace _dynstack
-} // namespace _detail
-
-namespace dynstack {
-template<typename T>
-struct DynStackAlloc : _detail::_dynstack::DynAllocBase
-{
-private:
-  using Base = _detail::_dynstack::DynAllocBase;
-
-public:
-  VEG_INLINE ~DynStackAlloc() VEG_NOEXCEPT
-  {
-    Base::destroy(ptr_mut() + Base::len);
-  }
-
-  DynStackAlloc(DynStackAlloc const&) = delete;
-  DynStackAlloc(DynStackAlloc&& other) VEG_NOEXCEPT : Base{ Base(other) }
-  {
-    other.Base::len = 0;
-    other.Base::data = nullptr;
-  };
-
-  auto operator=(DynStackAlloc const&) -> DynStackAlloc& = delete;
-  auto operator=(DynStackAlloc&& rhs) VEG_NOEXCEPT->DynStackAlloc&
-  {
-    {
-      auto cleanup = static_cast<decltype(rhs)>(*this);
-    }
-    static_cast<Base&>(*this) = rhs;
-    static_cast<Base&>(rhs) = {};
-    return *this;
-  }
-
-  VEG_NODISCARD auto as_mut() VEG_NOEXCEPT->SliceMut<T>
-  {
-    return {
-      unsafe,
-      FromRawParts{},
-      ptr_mut(),
-      len(),
-    };
-  }
-
-  VEG_NODISCARD auto as_ref() const VEG_NOEXCEPT->Slice<T>
-  {
-    return {
-      unsafe,
-      FromRawParts{},
-      ptr(),
-      len(),
-    };
-  }
-
-  VEG_NODISCARD auto ptr_mut() VEG_NOEXCEPT->T*
-  {
-    return /* NOLINT(clang-analyzer-linalg.uninitialized.UndefReturn) */
-      static_cast<T*>(const_cast<void*>(Base::data));
-  }
-  VEG_NODISCARD auto ptr() const VEG_NOEXCEPT->T const*
-  {
-    return /* NOLINT(clang-analyzer-linalg.uninitialized.UndefReturn) */
-      static_cast<T const*>(const_cast<void const*>(Base::data));
-  }
-  VEG_NODISCARD auto len() const VEG_NOEXCEPT->isize
-  {
-    return isize(Base::len);
-  }
-
-private:
-  friend struct DynStackArray<T>;
-  friend struct DynStackMut;
-  friend struct _detail::_dynstack::DynStackArrayDtor<T>;
-
-  template<typename Fn>
-  DynStackAlloc(DynStackMut& parent_ref, isize alloc_size, isize align, Fn fn)
-    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))
-    : Base{
-      &parent_ref,
-      parent_ref.stack_data,
-      nullptr,
-      0,
-    }
-  {
-
-    void* const parent_data = parent_ref.stack_data;
-    isize const parent_bytes = parent_ref.stack_bytes;
-
-    void* const ptr = _detail::align_next(align,
-                                          alloc_size * isize(sizeof(T)),
-                                          parent_ref.stack_data,
-                                          parent_ref.stack_bytes);
-
-    if (ptr != nullptr) {
-      bool success = false;
-      auto&& cleanup = defer(_detail::_dynstack::cleanup{
-        success, *parent, parent_data, parent_bytes });
-      (void)cleanup;
-
-      Base::len = alloc_size;
-      Base::data = fn.template make<T>(ptr, alloc_size);
-
-      success = true;
-    }
-  }
-};
-
-template<typename T>
-struct DynStackArray
-  : private // destruction order matters
-    DynStackAlloc<T>
-  , _detail::_dynstack::DynStackArrayDtor<T>
-{
-private:
-  using Base = _detail::_dynstack::DynAllocBase;
-
-public:
-  using DynStackAlloc<T>::as_ref;
-  using DynStackAlloc<T>::as_mut;
-  using DynStackAlloc<T>::ptr;
-  using DynStackAlloc<T>::ptr_mut;
-  using DynStackAlloc<T>::len;
-
-  ~DynStackArray() = default;
-  DynStackArray(DynStackArray const&) = delete;
-  DynStackArray(DynStackArray&&) VEG_NOEXCEPT = default;
-  auto operator=(DynStackArray const&) -> DynStackArray& = delete;
-
-  auto operator=(DynStackArray&& rhs) VEG_NOEXCEPT->DynStackArray&
-  {
-    {
-      auto cleanup = static_cast<decltype(rhs)>(*this);
-    }
-    static_cast<Base&>(*this) = rhs;
-    static_cast<Base&>(rhs) = {};
-    return *this;
-  }
-
-private:
-  using DynStackAlloc<T>::DynStackAlloc;
-  friend struct DynStackMut;
-  friend struct _detail::_dynstack::DynStackArrayDtor<T>;
-};
-} // namespace dynstack
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS   \
-        */
+#ifndef VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS
+#define VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS
+
+#include "proxsuite/fwd.hpp"
+#include "proxsuite/linalg/veg/util/assert.hpp"
+#include "proxsuite/linalg/veg/internal/collection_algo.hpp"
+#include "proxsuite/linalg/veg/memory/alloc.hpp"
+#include "proxsuite/linalg/veg/memory/placement.hpp"
+#include "proxsuite/linalg/veg/slice.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/memory/placement.hpp"
+#include "proxsuite/linalg/veg/memory/address.hpp"
+#include "proxsuite/linalg/veg/internal/narrow.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+namespace _dynstack {
+constexpr auto
+max2(isize a, isize b) noexcept -> isize
+{
+  return (a > b) ? a : b;
+}
+constexpr auto
+round_up_pow2(isize a, isize b) noexcept -> isize
+{
+  return isize((usize(a) + ~(0 - usize(b))) & (0 - usize(b)));
+}
+} // namespace _dynstack
+} // namespace _detail
+namespace dynstack {
+struct StackReq
+{
+  isize size_bytes;
+  isize align;
+
+  constexpr friend auto operator==(StackReq a, StackReq b) noexcept -> bool
+  {
+    return a.size_bytes == b.size_bytes && a.align == b.align;
+  }
+
+  constexpr friend auto operator&(StackReq a, StackReq b) noexcept -> StackReq
+  {
+    using namespace _detail::_dynstack;
+    return {
+      round_up_pow2(   //
+        round_up_pow2( //
+          a.size_bytes,
+          b.align) +
+          b.size_bytes,
+        (max2)(a.align, b.align)),
+      (max2)(a.align, b.align),
+    };
+  }
+  constexpr friend auto operator|(StackReq a, StackReq b) noexcept -> StackReq
+  {
+    using namespace _detail::_dynstack;
+    return {
+      (max2)( //
+        round_up_pow2(a.size_bytes, max2(a.align, b.align)),
+        round_up_pow2(b.size_bytes, max2(a.align, b.align))),
+      (max2)(a.align, b.align),
+    };
+  }
+
+  constexpr auto alloc_req() const noexcept -> isize
+  {
+    return size_bytes + align - 1;
+  }
+
+  template<typename T>
+  static constexpr auto with_len(proxsuite::linalg::veg::Tag<T> /*tag*/,
+                                 isize len) noexcept -> StackReq
+  {
+    return {
+      isize{ sizeof(T) } * len,
+      isize{ alignof(T) },
+    };
+  }
+
+  static VEG_CPP14(constexpr) auto and_(Slice<StackReq> reqs) noexcept
+    -> StackReq
+  {
+    StackReq req{ 0, 1 };
+    for (isize i = 0; i < reqs.len(); ++i) {
+      req = req & reqs.ptr()[i];
+    }
+    return req;
+  }
+
+  static VEG_CPP14(constexpr) auto or_(Slice<StackReq> reqs) noexcept
+    -> StackReq
+  {
+    StackReq req{ 0, 1 };
+    for (isize i = 0; i < reqs.len(); ++i) {
+      req = req | reqs.ptr()[i];
+    }
+    return req;
+  }
+};
+
+template<typename T>
+struct DynStackArray;
+template<typename T>
+struct DynStackAlloc;
+} // namespace dynstack
+
+namespace _detail {
+// if possible:
+// aligns the pointer
+// then advances it by `size` bytes, and decreases `space` by `size`
+// returns the previous aligned value
+//
+// otherwise, if there is not enough space for aligning or advancing the
+// pointer, returns nullptr and the values are left unmodified
+inline auto
+align_next(isize alignment, isize size, void*& ptr, isize& space)
+  VEG_ALWAYS_NOEXCEPT->void*
+{
+  static_assert(sizeof(std::uintptr_t) >= sizeof(void*),
+                "std::uintptr_t can't hold a pointer value");
+
+  using byte_ptr = unsigned char*;
+
+  // assert alignment is power of two
+  VEG_ASSERT_ALL_OF( //
+    (alignment > isize{ 0 }),
+    ((u64(alignment) & (u64(alignment) - 1)) == u64(0)));
+
+  if (space < size) {
+    return nullptr;
+  }
+
+  std::uintptr_t lo_mask = usize(alignment) - 1;
+  std::uintptr_t hi_mask = ~lo_mask;
+
+  auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
+  auto* const byteptr = static_cast<byte_ptr>(ptr);
+
+  auto offset = ((intptr + usize(alignment) - 1) & hi_mask) - intptr;
+
+  if (usize(space) - usize(size) < offset) {
+    return nullptr;
+  }
+
+  void* const rv = byteptr + offset;
+
+  ptr = byteptr + (offset + usize(size));
+  space = space - (isize(offset) + (size));
+
+  return rv;
+}
+} // namespace _detail
+
+namespace _detail {
+namespace _dynstack {
+template<typename T, bool = VEG_CONCEPT(trivially_destructible<T>)>
+struct DynStackArrayDtor
+{};
+
+template<typename T>
+struct DynStackArrayDtor<T, false>
+{
+  DynStackArrayDtor() = default;
+  DynStackArrayDtor(DynStackArrayDtor const&) = default;
+  DynStackArrayDtor(DynStackArrayDtor&&) = default;
+  auto operator=(DynStackArrayDtor const&) -> DynStackArrayDtor& = default;
+  auto operator=(DynStackArrayDtor&&) -> DynStackArrayDtor& = default;
+  VEG_INLINE ~DynStackArrayDtor()
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>))
+  {
+    auto& self = static_cast<dynstack::DynStackArray<T>&>(*this);
+    using Base = typename dynstack::DynStackAlloc<T>::Base const&;
+    proxsuite::linalg::veg::_detail::_collections::backward_destroy(
+      mut(mem::SystemAlloc{}),
+      mut(mem::DefaultCloner{}),
+      self.ptr_mut(),
+      self.ptr_mut() + Base(self).len);
+  }
+};
+
+struct cleanup;
+struct DynAllocBase;
+
+struct default_init_fn
+{
+  template<typename T>
+  auto make(void* ptr, isize len) -> T*
+  {
+    return ::new (ptr) T[usize(len)];
+  }
+};
+
+struct zero_init_fn
+{
+  template<typename T>
+  auto make(void* ptr, isize len) -> T*
+  {
+    return ::new (ptr) T[usize(len)]{};
+  }
+};
+
+struct no_init_fn
+{
+  template<typename T>
+  auto make(void* ptr, isize len) -> T*
+  {
+    return proxsuite::linalg::veg::mem::launder(static_cast<T*>(
+      static_cast<void*>(::new (ptr) unsigned char[usize(len) * sizeof(T)])));
+  }
+};
+
+} // namespace _dynstack
+} // namespace _detail
+
+namespace dynstack {
+struct DynStackMut
+{
+public:
+  DynStackMut(FromSliceMut /*tag*/, SliceMut<unsigned char> s) VEG_NOEXCEPT
+    : stack_data(s.ptr_mut())
+    , stack_bytes(s.len())
+  {
+  }
+
+  VEG_NODISCARD
+  auto remaining_bytes() const VEG_NOEXCEPT->isize
+  {
+    return isize(stack_bytes);
+  }
+  VEG_NODISCARD
+  auto ptr_mut() const VEG_NOEXCEPT->void* { return stack_data; }
+  VEG_NODISCARD
+  auto ptr() const VEG_NOEXCEPT->void const* { return stack_data; }
+
+private:
+  VEG_INLINE void assert_valid_len(PROXSUITE_MAYBE_UNUSED isize len)
+    VEG_NOEXCEPT
+  {
+    VEG_INTERNAL_ASSERT_PRECONDITIONS(isize(len) >= 0);
+  }
+
+public:
+  VEG_TEMPLATE((typename T),
+               requires VEG_CONCEPT(constructible<T>),
+               VEG_NODISCARD auto make_new,
+               (/*unused*/, Tag<T>),
+               (len, isize),
+               (align = alignof(T), isize))
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))->DynStackArray<T>
+  {
+    assert_valid_len(len);
+    DynStackArray<T> get{
+      *this, isize(len), align, _detail::_dynstack::zero_init_fn{}
+    };
+    VEG_ASSERT(get.ptr() != nullptr);
+    return VEG_FWD(get);
+  }
+
+  VEG_TEMPLATE((typename T),
+               requires VEG_CONCEPT(constructible<T>),
+               VEG_NODISCARD auto make_new_for_overwrite,
+               (/*unused*/, Tag<T>),
+               (len, isize),
+               (align = alignof(T), isize))
+
+  VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))->DynStackArray<T>
+  {
+    assert_valid_len(len);
+    DynStackArray<T> get{
+      *this, isize(len), align, _detail::_dynstack::default_init_fn{}
+    };
+    VEG_ASSERT(get.ptr() != nullptr);
+    return VEG_FWD(get);
+  }
+
+  template<typename T>
+  VEG_NODISCARD auto make_alloc(Tag<T> /*unused*/,
+                                isize len,
+                                isize align = alignof(T))
+    VEG_NOEXCEPT->DynStackAlloc<T>
+  {
+    assert_valid_len(len);
+    DynStackAlloc<T> get{
+      *this, isize(len), align, _detail::_dynstack::no_init_fn{}
+    };
+    VEG_ASSERT(get.ptr() != nullptr);
+    return VEG_FWD(get);
+  }
+
+private:
+  void* stack_data;
+  isize stack_bytes;
+
+  template<typename T>
+  friend struct DynStackAlloc;
+  template<typename T>
+  friend struct DynStackArray;
+  friend struct _detail::_dynstack::cleanup;
+  friend struct _detail::_dynstack::DynAllocBase;
+};
+} // namespace dynstack
+
+namespace _detail {
+namespace _dynstack {
+
+struct cleanup
+{
+  bool const& success;
+  proxsuite::linalg::veg::dynstack::DynStackMut& parent;
+  void* old_data;
+  isize old_rem_bytes;
+
+  VEG_INLINE void operator()() const VEG_NOEXCEPT
+  {
+    if (!success) {
+      parent.stack_data = old_data;
+      parent.stack_bytes = old_rem_bytes;
+    }
+  }
+};
+
+struct DynAllocBase
+{
+  proxsuite::linalg::veg::dynstack::DynStackMut* parent;
+  void* old_pos;
+  void const volatile* data;
+  isize len;
+
+  void destroy(void const volatile* void_data_end) VEG_NOEXCEPT
+  {
+    if (data != nullptr) {
+      // in case resource lifetimes are reodered by moving ownership
+      PROXSUITE_MAYBE_UNUSED auto* parent_stack_data =
+        static_cast<unsigned char*>(parent->stack_data);
+      PROXSUITE_MAYBE_UNUSED auto* old_position =
+        static_cast<unsigned char*>(old_pos);
+      PROXSUITE_MAYBE_UNUSED auto* data_end =
+        static_cast<unsigned char*>(const_cast<void*>(void_data_end));
+
+      VEG_INTERNAL_ASSERT_PRECONDITIONS( //
+        parent_stack_data == data_end,
+        parent_stack_data >= old_position);
+
+      parent->stack_bytes +=
+        static_cast<isize>(static_cast<unsigned char*>(parent->stack_data) -
+                           static_cast<unsigned char*>(old_pos));
+      parent->stack_data = old_pos;
+    }
+  }
+};
+} // namespace _dynstack
+} // namespace _detail
+
+namespace dynstack {
+template<typename T>
+struct DynStackAlloc : _detail::_dynstack::DynAllocBase
+{
+private:
+  using Base = _detail::_dynstack::DynAllocBase;
+
+public:
+  VEG_INLINE ~DynStackAlloc() VEG_NOEXCEPT
+  {
+    Base::destroy(ptr_mut() + Base::len);
+  }
+
+  DynStackAlloc(DynStackAlloc const&) = delete;
+  DynStackAlloc(DynStackAlloc&& other) VEG_NOEXCEPT : Base{ Base(other) }
+  {
+    other.Base::len = 0;
+    other.Base::data = nullptr;
+  };
+
+  auto operator=(DynStackAlloc const&) -> DynStackAlloc& = delete;
+  auto operator=(DynStackAlloc&& rhs) VEG_NOEXCEPT->DynStackAlloc&
+  {
+    {
+      auto cleanup = static_cast<decltype(rhs)>(*this);
+    }
+    static_cast<Base&>(*this) = rhs;
+    static_cast<Base&>(rhs) = {};
+    return *this;
+  }
+
+  VEG_NODISCARD auto as_mut() VEG_NOEXCEPT->SliceMut<T>
+  {
+    return {
+      unsafe,
+      FromRawParts{},
+      ptr_mut(),
+      len(),
+    };
+  }
+
+  VEG_NODISCARD auto as_ref() const VEG_NOEXCEPT->Slice<T>
+  {
+    return {
+      unsafe,
+      FromRawParts{},
+      ptr(),
+      len(),
+    };
+  }
+
+  VEG_NODISCARD auto ptr_mut() VEG_NOEXCEPT->T*
+  {
+    return /* NOLINT(clang-analyzer-linalg.uninitialized.UndefReturn) */
+      static_cast<T*>(const_cast<void*>(Base::data));
+  }
+  VEG_NODISCARD auto ptr() const VEG_NOEXCEPT->T const*
+  {
+    return /* NOLINT(clang-analyzer-linalg.uninitialized.UndefReturn) */
+      static_cast<T const*>(const_cast<void const*>(Base::data));
+  }
+  VEG_NODISCARD auto len() const VEG_NOEXCEPT->isize
+  {
+    return isize(Base::len);
+  }
+
+private:
+  friend struct DynStackArray<T>;
+  friend struct DynStackMut;
+  friend struct _detail::_dynstack::DynStackArrayDtor<T>;
+
+  template<typename Fn>
+  DynStackAlloc(DynStackMut& parent_ref, isize alloc_size, isize align, Fn fn)
+    VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_constructible<T>))
+    : Base{
+      &parent_ref,
+      parent_ref.stack_data,
+      nullptr,
+      0,
+    }
+  {
+
+    void* const parent_data = parent_ref.stack_data;
+    isize const parent_bytes = parent_ref.stack_bytes;
+
+    void* const ptr = _detail::align_next(align,
+                                          alloc_size * isize(sizeof(T)),
+                                          parent_ref.stack_data,
+                                          parent_ref.stack_bytes);
+
+    if (ptr != nullptr) {
+      bool success = false;
+      auto&& cleanup = defer(_detail::_dynstack::cleanup{
+        success, *parent, parent_data, parent_bytes });
+      (void)cleanup;
+
+      Base::len = alloc_size;
+      Base::data = fn.template make<T>(ptr, alloc_size);
+
+      success = true;
+    }
+  }
+};
+
+template<typename T>
+struct DynStackArray
+  : private // destruction order matters
+    DynStackAlloc<T>
+  , _detail::_dynstack::DynStackArrayDtor<T>
+{
+private:
+  using Base = _detail::_dynstack::DynAllocBase;
+
+public:
+  using DynStackAlloc<T>::as_ref;
+  using DynStackAlloc<T>::as_mut;
+  using DynStackAlloc<T>::ptr;
+  using DynStackAlloc<T>::ptr_mut;
+  using DynStackAlloc<T>::len;
+
+  ~DynStackArray() = default;
+  DynStackArray(DynStackArray const&) = delete;
+  DynStackArray(DynStackArray&&) VEG_NOEXCEPT = default;
+  auto operator=(DynStackArray const&) -> DynStackArray& = delete;
+
+  auto operator=(DynStackArray&& rhs) VEG_NOEXCEPT->DynStackArray&
+  {
+    {
+      auto cleanup = static_cast<decltype(rhs)>(*this);
+    }
+    static_cast<Base&>(*this) = rhs;
+    static_cast<Base&>(rhs) = {};
+    return *this;
+  }
+
+private:
+  using DynStackAlloc<T>::DynStackAlloc;
+  friend struct DynStackMut;
+  friend struct _detail::_dynstack::DynStackArrayDtor<T>;
+};
+} // namespace dynstack
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_DYNAMIC_STACK_DYNAMIC_STACK_HPP_UBOMZFTOS   \
+        */
```

## cmeel.prefix/include/proxsuite/linalg/veg/memory/placement.hpp

 * *Ordering differences only*

```diff
@@ -1,202 +1,202 @@
-#ifndef VEG_PLACEMENT_HPP_LP0HMLTPS
-#define VEG_PLACEMENT_HPP_LP0HMLTPS
-
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/internal/std.hpp"
-#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
-#include "proxsuite/linalg/veg/memory/address.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <new>
-
-#if defined(VEG_WITH_CXX20_SUPPORT) && !VEG_HAS_BUILTIN(__builtin_bit_cast)
-#include <bit>
-#define VEG_HAS_BITCAST 1
-#define VEG_BITCAST(T, x) ::std::bit_cast<T>(x)
-#define VEG_BITCAST_CONSTEXPR constexpr
-#elif VEG_HAS_BUILTIN(__builtin_bit_cast)
-#define VEG_HAS_BITCAST 1
-#define VEG_BITCAST(T, x) __builtin_bit_cast(T, x)
-#define VEG_BITCAST_CONSTEXPR constexpr
-#else
-#include <cstring>
-#define VEG_HAS_BITCAST 0
-#define VEG_BITCAST_CONSTEXPR
-#endif
-
-// construct_at
-#if defined(VEG_WITH_CXX20_SUPPORT)
-
-// std::construct_at
-#if __VEG_HAS_INCLUDE(<bits / stl_construct.h>) &&                             \
-  __VEG_HAS_INCLUDE(<bits / stl_iterator_base_types.h>) &&                     \
-  __VEG_HAS_INCLUDE(<bits / stl_iterator_base_funcs.h>)
-#include <bits/stl_iterator_base_types.h>
-#include <bits/stl_iterator_base_funcs.h>
-#include <bits/stl_construct.h>
-#else
-#include <memory>
-#endif
-
-#endif
-
-#if VEG_HAS_BUILTIN(__builtin_launder) || __GNUC__ >= 7
-#define VEG_LAUNDER(p) (__builtin_launder(p))
-#elif defined(VEG_WITH_CXX17_SUPPORT)
-#include <new>
-#define VEG_LAUNDER(p) (::std::launder(p))
-#else
-#define VEG_LAUNDER(p) (+p)
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace mem {
-namespace nb {
-struct launder
-{
-  VEG_TEMPLATE(typename T,
-               requires(VEG_CONCEPT(complete<T>)),
-               VEG_INLINE constexpr auto
-               operator(),
-               (mem, T*))
-  const VEG_NOEXCEPT->T* { return VEG_LAUNDER(mem); }
-};
-#undef VEG_LAUNDER
-
-struct construct_at
-{
-  VEG_TEMPLATE((typename T, typename... Args),
-               requires(!VEG_CONCEPT(const_type<T>) &&
-                        VEG_CONCEPT(inplace_constructible<T, Args...>)),
-               VEG_INLINE VEG_CPP20(constexpr) auto
-               operator(),
-               (mem, T*),
-               (... args, Args&&))
-  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_inplace_constructible<T, Args...>))
-    ->T*
-  {
-#if defined(VEG_WITH_CXX20_SUPPORT)
-    return ::std::construct_at(mem, VEG_FWD(args)...);
-#else
-    return ::new (mem) T(VEG_FWD(args)...);
-#endif
-  }
-};
-
-struct construct_with
-{
-  VEG_TEMPLATE((typename T, typename Fn),
-               requires(!VEG_CONCEPT(const_type<T>) &&
-                        VEG_CONCEPT(fn_once<Fn, T>)),
-               VEG_INLINE VEG_CPP20(constexpr) auto
-               operator(),
-               (mem, T*),
-               (fn, Fn&&))
-  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>))->T*
-  {
-#if defined(VEG_WITH_CXX20_SUPPORT)
-    struct Convertor
-    {
-      Fn&& fn;
-      VEG_INLINE constexpr operator T() const&& VEG_NOEXCEPT_IF(
-        VEG_CONCEPT(nothrow_fn_once<Fn, T>))
-      {
-        return VEG_FWD(fn)();
-      }
-    };
-
-    return ::std::construct_at(mem, Convertor{ VEG_FWD(fn) });
-#else
-    return ::new (mem) T(VEG_FWD(fn)());
-#endif
-  }
-};
-
-struct destroy_at
-{
-  VEG_TEMPLATE((typename T),
-               requires(VEG_CONCEPT(complete<T>)),
-               VEG_INLINE VEG_CPP14(constexpr) void
-               operator(),
-               (mem, T*))
-  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>)) { mem->~T(); }
-};
-struct align_next
-{
-  auto operator()(usize alignment, void* ptr) const VEG_NOEXCEPT->void*
-  {
-    using byte_ptr = unsigned char*;
-    std::uintptr_t lo_mask = alignment - 1U;
-    std::uintptr_t hi_mask = ~lo_mask;
-    auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
-    auto* const byteptr = static_cast<byte_ptr>(ptr);
-    auto offset = ((intptr + alignment - 1U) & hi_mask) - intptr;
-
-    return byteptr + offset;
-  }
-  auto operator()(usize alignment,
-                  void const* ptr) const VEG_NOEXCEPT->void const*
-  {
-    return this->operator()(alignment, const_cast<void*>(ptr));
-  }
-};
-struct align_prev
-{
-  auto operator()(usize alignment, void* ptr) const VEG_NOEXCEPT->void*
-  {
-    using byte_ptr = unsigned char*;
-    std::uintptr_t lo_mask = alignment - 1U;
-    std::uintptr_t hi_mask = ~lo_mask;
-    auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
-    auto* const byteptr = static_cast<byte_ptr>(ptr);
-    auto offset = ((intptr)&hi_mask) - intptr;
-
-    return byteptr + offset;
-  }
-  auto operator()(usize alignment,
-                  void const* ptr) const VEG_NOEXCEPT->void const*
-  {
-    return this->operator()(alignment, const_cast<void*>(ptr));
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(align_next);
-VEG_NIEBLOID(align_prev);
-VEG_NIEBLOID(launder);
-VEG_NIEBLOID(construct_at);
-VEG_NIEBLOID(construct_with);
-VEG_NIEBLOID(destroy_at);
-
-namespace nb {
-template<typename To>
-struct bit_cast
-{
-  VEG_TEMPLATE(typename From,
-               requires((VEG_CONCEPT(trivially_copyable<From>) && //
-                         VEG_CONCEPT(trivially_copyable<To>) &&   //
-                         (sizeof(From) == sizeof(To)))),
-               VEG_INLINE VEG_BITCAST_CONSTEXPR auto
-               operator(),
-               (from, From const&))
-  const VEG_NOEXCEPT->To
-  {
-#if VEG_HAS_BITCAST
-    return VEG_BITCAST(To, from);
-#else
-    alignas(To) unsigned char buf[sizeof(To)];
-    To* ptr = reinterpret_cast<To*>(static_cast<unsigned char*>(buf));
-    ::std::memcpy(ptr, nb::addressof{}(from), sizeof(To));
-    return To(static_cast<To&&>(*nb::launder{}(ptr)));
-#endif
-  }
-};
-} // namespace nb
-VEG_NIEBLOID_TEMPLATE(typename To, bit_cast, To);
-} // namespace mem
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_PLACEMENT_HPP_LP0HMLTPS */
+#ifndef VEG_PLACEMENT_HPP_LP0HMLTPS
+#define VEG_PLACEMENT_HPP_LP0HMLTPS
+
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/internal/std.hpp"
+#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
+#include "proxsuite/linalg/veg/memory/address.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <new>
+
+#if defined(VEG_WITH_CXX20_SUPPORT) && !VEG_HAS_BUILTIN(__builtin_bit_cast)
+#include <bit>
+#define VEG_HAS_BITCAST 1
+#define VEG_BITCAST(T, x) ::std::bit_cast<T>(x)
+#define VEG_BITCAST_CONSTEXPR constexpr
+#elif VEG_HAS_BUILTIN(__builtin_bit_cast)
+#define VEG_HAS_BITCAST 1
+#define VEG_BITCAST(T, x) __builtin_bit_cast(T, x)
+#define VEG_BITCAST_CONSTEXPR constexpr
+#else
+#include <cstring>
+#define VEG_HAS_BITCAST 0
+#define VEG_BITCAST_CONSTEXPR
+#endif
+
+// construct_at
+#if defined(VEG_WITH_CXX20_SUPPORT)
+
+// std::construct_at
+#if __VEG_HAS_INCLUDE(<bits / stl_construct.h>) &&                             \
+  __VEG_HAS_INCLUDE(<bits / stl_iterator_base_types.h>) &&                     \
+  __VEG_HAS_INCLUDE(<bits / stl_iterator_base_funcs.h>)
+#include <bits/stl_iterator_base_types.h>
+#include <bits/stl_iterator_base_funcs.h>
+#include <bits/stl_construct.h>
+#else
+#include <memory>
+#endif
+
+#endif
+
+#if VEG_HAS_BUILTIN(__builtin_launder) || __GNUC__ >= 7
+#define VEG_LAUNDER(p) (__builtin_launder(p))
+#elif defined(VEG_WITH_CXX17_SUPPORT)
+#include <new>
+#define VEG_LAUNDER(p) (::std::launder(p))
+#else
+#define VEG_LAUNDER(p) (+p)
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace mem {
+namespace nb {
+struct launder
+{
+  VEG_TEMPLATE(typename T,
+               requires(VEG_CONCEPT(complete<T>)),
+               VEG_INLINE constexpr auto
+               operator(),
+               (mem, T*))
+  const VEG_NOEXCEPT->T* { return VEG_LAUNDER(mem); }
+};
+#undef VEG_LAUNDER
+
+struct construct_at
+{
+  VEG_TEMPLATE((typename T, typename... Args),
+               requires(!VEG_CONCEPT(const_type<T>) &&
+                        VEG_CONCEPT(inplace_constructible<T, Args...>)),
+               VEG_INLINE VEG_CPP20(constexpr) auto
+               operator(),
+               (mem, T*),
+               (... args, Args&&))
+  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_inplace_constructible<T, Args...>))
+    ->T*
+  {
+#if defined(VEG_WITH_CXX20_SUPPORT)
+    return ::std::construct_at(mem, VEG_FWD(args)...);
+#else
+    return ::new (mem) T(VEG_FWD(args)...);
+#endif
+  }
+};
+
+struct construct_with
+{
+  VEG_TEMPLATE((typename T, typename Fn),
+               requires(!VEG_CONCEPT(const_type<T>) &&
+                        VEG_CONCEPT(fn_once<Fn, T>)),
+               VEG_INLINE VEG_CPP20(constexpr) auto
+               operator(),
+               (mem, T*),
+               (fn, Fn&&))
+  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, T>))->T*
+  {
+#if defined(VEG_WITH_CXX20_SUPPORT)
+    struct Convertor
+    {
+      Fn&& fn;
+      VEG_INLINE constexpr operator T() const&& VEG_NOEXCEPT_IF(
+        VEG_CONCEPT(nothrow_fn_once<Fn, T>))
+      {
+        return VEG_FWD(fn)();
+      }
+    };
+
+    return ::std::construct_at(mem, Convertor{ VEG_FWD(fn) });
+#else
+    return ::new (mem) T(VEG_FWD(fn)());
+#endif
+  }
+};
+
+struct destroy_at
+{
+  VEG_TEMPLATE((typename T),
+               requires(VEG_CONCEPT(complete<T>)),
+               VEG_INLINE VEG_CPP14(constexpr) void
+               operator(),
+               (mem, T*))
+  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_destructible<T>)) { mem->~T(); }
+};
+struct align_next
+{
+  auto operator()(usize alignment, void* ptr) const VEG_NOEXCEPT->void*
+  {
+    using byte_ptr = unsigned char*;
+    std::uintptr_t lo_mask = alignment - 1U;
+    std::uintptr_t hi_mask = ~lo_mask;
+    auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
+    auto* const byteptr = static_cast<byte_ptr>(ptr);
+    auto offset = ((intptr + alignment - 1U) & hi_mask) - intptr;
+
+    return byteptr + offset;
+  }
+  auto operator()(usize alignment,
+                  void const* ptr) const VEG_NOEXCEPT->void const*
+  {
+    return this->operator()(alignment, const_cast<void*>(ptr));
+  }
+};
+struct align_prev
+{
+  auto operator()(usize alignment, void* ptr) const VEG_NOEXCEPT->void*
+  {
+    using byte_ptr = unsigned char*;
+    std::uintptr_t lo_mask = alignment - 1U;
+    std::uintptr_t hi_mask = ~lo_mask;
+    auto const intptr = reinterpret_cast<std::uintptr_t>(ptr);
+    auto* const byteptr = static_cast<byte_ptr>(ptr);
+    auto offset = ((intptr)&hi_mask) - intptr;
+
+    return byteptr + offset;
+  }
+  auto operator()(usize alignment,
+                  void const* ptr) const VEG_NOEXCEPT->void const*
+  {
+    return this->operator()(alignment, const_cast<void*>(ptr));
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(align_next);
+VEG_NIEBLOID(align_prev);
+VEG_NIEBLOID(launder);
+VEG_NIEBLOID(construct_at);
+VEG_NIEBLOID(construct_with);
+VEG_NIEBLOID(destroy_at);
+
+namespace nb {
+template<typename To>
+struct bit_cast
+{
+  VEG_TEMPLATE(typename From,
+               requires((VEG_CONCEPT(trivially_copyable<From>) && //
+                         VEG_CONCEPT(trivially_copyable<To>) &&   //
+                         (sizeof(From) == sizeof(To)))),
+               VEG_INLINE VEG_BITCAST_CONSTEXPR auto
+               operator(),
+               (from, From const&))
+  const VEG_NOEXCEPT->To
+  {
+#if VEG_HAS_BITCAST
+    return VEG_BITCAST(To, from);
+#else
+    alignas(To) unsigned char buf[sizeof(To)];
+    To* ptr = reinterpret_cast<To*>(static_cast<unsigned char*>(buf));
+    ::std::memcpy(ptr, nb::addressof{}(from), sizeof(To));
+    return To(static_cast<To&&>(*nb::launder{}(ptr)));
+#endif
+  }
+};
+} // namespace nb
+VEG_NIEBLOID_TEMPLATE(typename To, bit_cast, To);
+} // namespace mem
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_PLACEMENT_HPP_LP0HMLTPS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/memory/stack_alloc.hpp

 * *Ordering differences only*

```diff
@@ -1,239 +1,239 @@
-#ifndef VEG_STACK_ALLOC_HPP_UTBYR4Y5S
-#define VEG_STACK_ALLOC_HPP_UTBYR4Y5S
-
-#include "proxsuite/linalg/veg/slice.hpp"
-#include "proxsuite/linalg/veg/type_traits/alloc.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-
-namespace _detail {
-namespace _mem {
-
-template<usize MaxAlign>
-struct BumpAllocLayout
-{
-
-  mem::byte* current_ptr;
-  mem::byte* start_ptr;
-  mem::byte* end_ptr;
-
-  static auto _align(usize byte_size) noexcept -> usize
-  {
-    usize const actual_max_align =
-#if VEG_HAS_ASAN
-      MaxAlign > 8 ? MaxAlign : 8
-#else
-      MaxAlign
-#endif
-      ;
-
-    usize const mask = (actual_max_align - 1);
-    return (byte_size + mask) & ~mask;
-  }
-
-  auto _is_last(void* ptr, usize byte_size) noexcept -> bool
-  {
-    return ptr == (current_ptr - _align(byte_size));
-  }
-  void _assert_last(void* ptr, usize byte_size) noexcept
-  {
-    VEG_ASSERT(ptr == (current_ptr - _align(byte_size)));
-  }
-
-  void _dealloc_last_unchecked(void* ptr, mem::Layout layout)
-  {
-    VEG_DEBUG_ASSERT(ptr == (current_ptr - _align(layout.byte_size)));
-    (void)layout;
-    current_ptr = static_cast<mem::byte*>(ptr);
-  }
-
-  void _dealloc_any(void* ptr, mem::Layout layout) noexcept
-  {
-    if (_is_last(ptr, layout.byte_size)) {
-      _dealloc_last_unchecked(ptr, layout);
-    }
-  }
-
-  void _dealloc_last(void* ptr, mem::Layout layout)
-  {
-    _assert_last(ptr, layout.byte_size);
-    _dealloc_last_unchecked(ptr, layout);
-  }
-
-  auto _alloc(mem::Layout layout) noexcept -> mem::AllocBlock
-  {
-    auto given_bytes = _align(layout.byte_size);
-    auto rem_bytes = usize(end_ptr - current_ptr);
-    VEG_ASSERT_ALL_OF( //
-      (layout.align <= MaxAlign),
-      (given_bytes < rem_bytes));
-
-    mem::AllocBlock blk = { current_ptr, given_bytes };
-    current_ptr += given_bytes;
-    return blk;
-  }
-
-  auto _grow_last_unchecked(void* ptr, usize new_byte_size) noexcept
-    -> mem::AllocBlock
-  {
-    auto rem_bytes = usize(end_ptr - static_cast<mem::byte*>(ptr));
-    auto given_bytes = _align(new_byte_size);
-    (void)rem_bytes;
-    VEG_DEBUG_ASSERT(given_bytes < rem_bytes);
-    current_ptr = static_cast<mem::byte*>(ptr) + given_bytes;
-    return { ptr, given_bytes };
-  }
-
-  auto _grow_last(void* ptr,
-                  mem::Layout old_layout,
-                  usize new_byte_size,
-                  mem::RelocFn /*reloc*/) noexcept -> mem::AllocBlock
-  {
-    if (ptr == nullptr) {
-      mem::AllocBlock blk =
-        _alloc(mem::Layout{ new_byte_size, old_layout.align });
-      return blk;
-    }
-    _assert_last(ptr, old_layout.byte_size);
-    return _grow_last_unchecked(ptr, new_byte_size);
-  }
-
-  auto _grow_any(void* ptr,
-                 mem::Layout old_layout,
-                 usize new_byte_size,
-                 mem::RelocFn reloc) noexcept -> mem::AllocBlock
-  {
-    if (_is_last(ptr, old_layout.byte_size)) {
-      return _grow_last_unchecked(ptr, new_byte_size);
-    } else {
-      mem::AllocBlock blk =
-        _alloc(mem::Layout{ new_byte_size, old_layout.align });
-      reloc(blk.data, ptr, old_layout.byte_size);
-      return blk;
-    }
-  }
-};
-} // namespace _mem
-} // namespace _detail
-
-namespace mem {
-template<usize MaxAlign>
-struct BumpAlloc : private _detail::_mem::BumpAllocLayout<MaxAlign>
-{
-#if VEG_HAS_ASAN
-  static_assert(MaxAlign >= 8, ".");
-#endif
-
-  BumpAlloc(FromSliceMut /*tag*/, SliceMut<byte> s) noexcept
-    : _detail::_mem::BumpAllocLayout<MaxAlign>{
-      s.ptr_mut(),
-      s.ptr_mut(),
-      s.ptr_mut() + s.len(),
-    }
-  {
-
-    VEG_ASSERT_ALL_OF(
-      ((std::uintptr_t(s.ptr()) % MaxAlign) == std::uintptr_t(0)),
-      ((usize(s.len()) % usize(MaxAlign)) == usize(0)));
-  }
-};
-template<usize MaxAlign>
-struct StackAlloc : private BumpAlloc<MaxAlign>
-{
-  using BumpAlloc<MaxAlign>::BumpAlloc;
-};
-template<usize MaxAlign>
-struct MonotonicAlloc : private BumpAlloc<MaxAlign>
-{
-  using BumpAlloc<MaxAlign>::BumpAlloc;
-};
-
-template<usize MaxAlign>
-struct Alloc<BumpAlloc<MaxAlign>>
-{
-  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
-  using RefMut = proxsuite::linalg::veg::RefMut<BumpAlloc<MaxAlign>>;
-
-  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
-    -> AllocBlock
-  {
-    return ImplMut(ref.get())._alloc(layout);
-  }
-  VEG_INLINE static void dealloc(RefMut ref,
-                                 void* ptr,
-                                 mem::Layout layout) noexcept
-  {
-    ImplMut(ref.get())._dealloc_any(ptr, layout);
-  }
-  VEG_INLINE static auto grow(RefMut ref,
-                              void* ptr,
-                              mem::Layout old_layout,
-                              usize new_byte_size,
-                              RelocFn reloc) noexcept -> mem::AllocBlock
-  {
-    return ImplMut(ref.get())._grow_any(ptr, old_layout, new_byte_size, reloc);
-  }
-};
-
-template<usize MaxAlign>
-struct Alloc<StackAlloc<MaxAlign>>
-{
-  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
-  using RefMut = proxsuite::linalg::veg::RefMut<StackAlloc<MaxAlign>>;
-
-  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
-    -> AllocBlock
-  {
-    return ImplMut(ref.get())._alloc(layout);
-  }
-  VEG_INLINE static void dealloc(RefMut ref,
-                                 void* ptr,
-                                 mem::Layout layout) noexcept
-  {
-    ImplMut(ref.get())._dealloc_last(ptr, layout);
-  }
-  VEG_INLINE static auto grow(RefMut ref,
-                              void* ptr,
-                              mem::Layout old_layout,
-                              usize new_byte_size,
-                              RelocFn reloc) noexcept -> mem::AllocBlock
-  {
-    return ImplMut(ref.get())._grow_last(ptr, old_layout, new_byte_size, reloc);
-  }
-};
-
-template<usize MaxAlign>
-struct Alloc<MonotonicAlloc<MaxAlign>>
-{
-  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
-  using RefMut = proxsuite::linalg::veg::RefMut<MonotonicAlloc<MaxAlign>>;
-
-  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
-    -> AllocBlock
-  {
-    return ImplMut(ref.get())._alloc(layout);
-  }
-  VEG_INLINE static void dealloc(RefMut /*ref*/,
-                                 void* /*ptr*/,
-                                 mem::Layout /*layout*/) noexcept
-  {
-  }
-  VEG_INLINE static auto grow(RefMut ref,
-                              void* ptr,
-                              mem::Layout old_layout,
-                              usize new_byte_size,
-                              RelocFn reloc) noexcept -> mem::AllocBlock
-  {
-    return ImplMut(ref.get())._grow_last(ptr, old_layout, new_byte_size, reloc);
-  }
-};
-} // namespace mem
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_STACK_ALLOC_HPP_UTBYR4Y5S */
+#ifndef VEG_STACK_ALLOC_HPP_UTBYR4Y5S
+#define VEG_STACK_ALLOC_HPP_UTBYR4Y5S
+
+#include "proxsuite/linalg/veg/slice.hpp"
+#include "proxsuite/linalg/veg/type_traits/alloc.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+
+namespace _detail {
+namespace _mem {
+
+template<usize MaxAlign>
+struct BumpAllocLayout
+{
+
+  mem::byte* current_ptr;
+  mem::byte* start_ptr;
+  mem::byte* end_ptr;
+
+  static auto _align(usize byte_size) noexcept -> usize
+  {
+    usize const actual_max_align =
+#if VEG_HAS_ASAN
+      MaxAlign > 8 ? MaxAlign : 8
+#else
+      MaxAlign
+#endif
+      ;
+
+    usize const mask = (actual_max_align - 1);
+    return (byte_size + mask) & ~mask;
+  }
+
+  auto _is_last(void* ptr, usize byte_size) noexcept -> bool
+  {
+    return ptr == (current_ptr - _align(byte_size));
+  }
+  void _assert_last(void* ptr, usize byte_size) noexcept
+  {
+    VEG_ASSERT(ptr == (current_ptr - _align(byte_size)));
+  }
+
+  void _dealloc_last_unchecked(void* ptr, mem::Layout layout)
+  {
+    VEG_DEBUG_ASSERT(ptr == (current_ptr - _align(layout.byte_size)));
+    (void)layout;
+    current_ptr = static_cast<mem::byte*>(ptr);
+  }
+
+  void _dealloc_any(void* ptr, mem::Layout layout) noexcept
+  {
+    if (_is_last(ptr, layout.byte_size)) {
+      _dealloc_last_unchecked(ptr, layout);
+    }
+  }
+
+  void _dealloc_last(void* ptr, mem::Layout layout)
+  {
+    _assert_last(ptr, layout.byte_size);
+    _dealloc_last_unchecked(ptr, layout);
+  }
+
+  auto _alloc(mem::Layout layout) noexcept -> mem::AllocBlock
+  {
+    auto given_bytes = _align(layout.byte_size);
+    auto rem_bytes = usize(end_ptr - current_ptr);
+    VEG_ASSERT_ALL_OF( //
+      (layout.align <= MaxAlign),
+      (given_bytes < rem_bytes));
+
+    mem::AllocBlock blk = { current_ptr, given_bytes };
+    current_ptr += given_bytes;
+    return blk;
+  }
+
+  auto _grow_last_unchecked(void* ptr, usize new_byte_size) noexcept
+    -> mem::AllocBlock
+  {
+    auto rem_bytes = usize(end_ptr - static_cast<mem::byte*>(ptr));
+    auto given_bytes = _align(new_byte_size);
+    (void)rem_bytes;
+    VEG_DEBUG_ASSERT(given_bytes < rem_bytes);
+    current_ptr = static_cast<mem::byte*>(ptr) + given_bytes;
+    return { ptr, given_bytes };
+  }
+
+  auto _grow_last(void* ptr,
+                  mem::Layout old_layout,
+                  usize new_byte_size,
+                  mem::RelocFn /*reloc*/) noexcept -> mem::AllocBlock
+  {
+    if (ptr == nullptr) {
+      mem::AllocBlock blk =
+        _alloc(mem::Layout{ new_byte_size, old_layout.align });
+      return blk;
+    }
+    _assert_last(ptr, old_layout.byte_size);
+    return _grow_last_unchecked(ptr, new_byte_size);
+  }
+
+  auto _grow_any(void* ptr,
+                 mem::Layout old_layout,
+                 usize new_byte_size,
+                 mem::RelocFn reloc) noexcept -> mem::AllocBlock
+  {
+    if (_is_last(ptr, old_layout.byte_size)) {
+      return _grow_last_unchecked(ptr, new_byte_size);
+    } else {
+      mem::AllocBlock blk =
+        _alloc(mem::Layout{ new_byte_size, old_layout.align });
+      reloc(blk.data, ptr, old_layout.byte_size);
+      return blk;
+    }
+  }
+};
+} // namespace _mem
+} // namespace _detail
+
+namespace mem {
+template<usize MaxAlign>
+struct BumpAlloc : private _detail::_mem::BumpAllocLayout<MaxAlign>
+{
+#if VEG_HAS_ASAN
+  static_assert(MaxAlign >= 8, ".");
+#endif
+
+  BumpAlloc(FromSliceMut /*tag*/, SliceMut<byte> s) noexcept
+    : _detail::_mem::BumpAllocLayout<MaxAlign>{
+      s.ptr_mut(),
+      s.ptr_mut(),
+      s.ptr_mut() + s.len(),
+    }
+  {
+
+    VEG_ASSERT_ALL_OF(
+      ((std::uintptr_t(s.ptr()) % MaxAlign) == std::uintptr_t(0)),
+      ((usize(s.len()) % usize(MaxAlign)) == usize(0)));
+  }
+};
+template<usize MaxAlign>
+struct StackAlloc : private BumpAlloc<MaxAlign>
+{
+  using BumpAlloc<MaxAlign>::BumpAlloc;
+};
+template<usize MaxAlign>
+struct MonotonicAlloc : private BumpAlloc<MaxAlign>
+{
+  using BumpAlloc<MaxAlign>::BumpAlloc;
+};
+
+template<usize MaxAlign>
+struct Alloc<BumpAlloc<MaxAlign>>
+{
+  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
+  using RefMut = proxsuite::linalg::veg::RefMut<BumpAlloc<MaxAlign>>;
+
+  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
+    -> AllocBlock
+  {
+    return ImplMut(ref.get())._alloc(layout);
+  }
+  VEG_INLINE static void dealloc(RefMut ref,
+                                 void* ptr,
+                                 mem::Layout layout) noexcept
+  {
+    ImplMut(ref.get())._dealloc_any(ptr, layout);
+  }
+  VEG_INLINE static auto grow(RefMut ref,
+                              void* ptr,
+                              mem::Layout old_layout,
+                              usize new_byte_size,
+                              RelocFn reloc) noexcept -> mem::AllocBlock
+  {
+    return ImplMut(ref.get())._grow_any(ptr, old_layout, new_byte_size, reloc);
+  }
+};
+
+template<usize MaxAlign>
+struct Alloc<StackAlloc<MaxAlign>>
+{
+  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
+  using RefMut = proxsuite::linalg::veg::RefMut<StackAlloc<MaxAlign>>;
+
+  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
+    -> AllocBlock
+  {
+    return ImplMut(ref.get())._alloc(layout);
+  }
+  VEG_INLINE static void dealloc(RefMut ref,
+                                 void* ptr,
+                                 mem::Layout layout) noexcept
+  {
+    ImplMut(ref.get())._dealloc_last(ptr, layout);
+  }
+  VEG_INLINE static auto grow(RefMut ref,
+                              void* ptr,
+                              mem::Layout old_layout,
+                              usize new_byte_size,
+                              RelocFn reloc) noexcept -> mem::AllocBlock
+  {
+    return ImplMut(ref.get())._grow_last(ptr, old_layout, new_byte_size, reloc);
+  }
+};
+
+template<usize MaxAlign>
+struct Alloc<MonotonicAlloc<MaxAlign>>
+{
+  using ImplMut = _detail::_mem::BumpAllocLayout<MaxAlign>&;
+  using RefMut = proxsuite::linalg::veg::RefMut<MonotonicAlloc<MaxAlign>>;
+
+  VEG_INLINE static auto alloc(RefMut ref, mem::Layout layout) noexcept
+    -> AllocBlock
+  {
+    return ImplMut(ref.get())._alloc(layout);
+  }
+  VEG_INLINE static void dealloc(RefMut /*ref*/,
+                                 void* /*ptr*/,
+                                 mem::Layout /*layout*/) noexcept
+  {
+  }
+  VEG_INLINE static auto grow(RefMut ref,
+                              void* ptr,
+                              mem::Layout old_layout,
+                              usize new_byte_size,
+                              RelocFn reloc) noexcept -> mem::AllocBlock
+  {
+    return ImplMut(ref.get())._grow_last(ptr, old_layout, new_byte_size, reloc);
+  }
+};
+} // namespace mem
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_STACK_ALLOC_HPP_UTBYR4Y5S */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/alloc.hpp

 * *Ordering differences only*

```diff
@@ -1,169 +1,169 @@
-#ifndef VEG_ALLOC_HPP_QHYOV5XDS
-#define VEG_ALLOC_HPP_QHYOV5XDS
-
-#include "proxsuite/linalg/veg/internal/has_asan.hpp"
-#include "proxsuite/linalg/veg/ref.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/internal/macros.hpp"
-#include "proxsuite/linalg/veg/memory/placement.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-#include <cstring>
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace mem {
-template<typename T>
-struct Alloc
-{};
-template<typename T>
-struct Cloner
-{};
-} // namespace mem
-namespace _detail {
-
-#if VEG_HAS_ASAN
-extern "C" void __sanitizer_annotate_contiguous_container /* NOLINT */ (
-  const void* begin,
-  const void* end,
-  const void* old_mid,
-  const void* new_mid);
-#endif
-
-[[noreturn]] HEDLEY_NEVER_INLINE void
-throw_bad_alloc();
-[[noreturn]] inline void
-terminate() noexcept;
-namespace _mem {
-struct DeferUnreachable /* NOLINT */
-{
-  bool is_unreachable;
-  VEG_INLINE ~DeferUnreachable()
-  {
-    if (is_unreachable) {
-      HEDLEY_UNREACHABLE();
-    }
-  }
-};
-} // namespace _mem
-} // namespace _detail
-
-namespace mem {
-inline auto
-memmove(void* dest, void const* src, usize nbytes) noexcept -> void*
-{
-  if (dest != nullptr) {
-    return std::memmove(dest, src, nbytes);
-  } else {
-    return dest;
-  }
-}
-
-using byte = unsigned char;
-struct AllocBlock
-{
-  void* data;
-  usize byte_cap;
-};
-struct Layout
-{
-  usize byte_size;
-  usize align;
-};
-struct RelocFn
-{
-  void* (*fn)(void*, void const*, usize);
-
-  VEG_INLINE void operator()(void* dst, void* src, usize n) const noexcept
-  {
-    _detail::_mem::DeferUnreachable _{ true };
-    (*fn)(dst, src, n);
-    _.is_unreachable = false;
-  }
-  VEG_INLINE auto is_trivial() const noexcept -> bool
-  {
-    return fn == &mem::memmove;
-  }
-};
-} // namespace mem
-namespace concepts {
-namespace alloc {
-VEG_CONCEPT_EXPR((typename A),
-                 (A),
-                 dealloc,
-                 mem::Alloc<A>::dealloc( //
-                   VEG_DECLVAL(RefMut<A>),
-                   VEG_DECLVAL(void*),
-                   VEG_DECLVAL(mem::Layout)),
-                 true);
-
-VEG_CONCEPT_EXPR((typename A),
-                 (A),
-                 alloc,
-                 mem::Alloc<A>::alloc(VEG_DECLVAL(RefMut<A>),
-                                      VEG_DECLVAL(mem::Layout)),
-                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
-
-VEG_CONCEPT_EXPR((typename A),
-                 (A),
-                 owns_alloc,
-                 mem::Alloc<A>::owns(VEG_DECLVAL(Ref<A>),
-                                     VEG_DECLVAL(mem::Layout)),
-                 VEG_CONCEPT(same<ExprType, bool>));
-
-VEG_CONCEPT_EXPR((typename A),
-                 (A),
-                 grow,
-                 mem::Alloc<A>::grow(VEG_DECLVAL(RefMut<A>),
-                                     VEG_DECLVAL(void*),
-                                     VEG_DECLVAL(mem::Layout),
-                                     VEG_DECLVAL(usize),
-                                     VEG_DECLVAL(mem::RelocFn)),
-                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
-
-VEG_CONCEPT_EXPR((typename A),
-                 (A),
-                 shrink,
-                 mem::Alloc<A>::shrink(VEG_DECLVAL(RefMut<A>),
-                                       VEG_DECLVAL(void*),
-                                       VEG_DECLVAL(mem::Layout),
-                                       VEG_DECLVAL(usize),
-                                       VEG_DECLVAL(mem::RelocFn)),
-                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
-
-VEG_CONCEPT_EXPR((typename C, typename T, typename A),
-                 (C, T, A),
-                 destroy,
-                 mem::Cloner<C>::destroy( //
-                   VEG_DECLVAL(RefMut<C>),
-                   VEG_DECLVAL(T*),
-                   VEG_DECLVAL(RefMut<A>)),
-                 true);
-
-VEG_CONCEPT_EXPR((typename C, typename T, typename A),
-                 (C, T, A),
-                 clone,
-                 mem::Cloner<C>::clone( //
-                   VEG_DECLVAL(RefMut<C>),
-                   VEG_DECLVAL(Ref<T>),
-                   VEG_DECLVAL(RefMut<A>)),
-                 VEG_CONCEPT(same<ExprType, T>));
-
-VEG_CONCEPT_EXPR((typename C, typename T, typename A),
-                 (C, T, A),
-                 clone_from,
-                 mem::Cloner<C>::clone_from(VEG_DECLVAL(RefMut<C>),
-                                            VEG_DECLVAL(RefMut<T>),
-                                            VEG_DECLVAL(Ref<T>),
-                                            VEG_DECLVAL(RefMut<A>)),
-                 true);
-} // namespace alloc
-} // namespace concepts
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_ALLOC_HPP_QHYOV5XDS */
+#ifndef VEG_ALLOC_HPP_QHYOV5XDS
+#define VEG_ALLOC_HPP_QHYOV5XDS
+
+#include "proxsuite/linalg/veg/internal/has_asan.hpp"
+#include "proxsuite/linalg/veg/ref.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/type_traits/assignable.hpp"
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/internal/macros.hpp"
+#include "proxsuite/linalg/veg/memory/placement.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+#include <cstring>
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace mem {
+template<typename T>
+struct Alloc
+{};
+template<typename T>
+struct Cloner
+{};
+} // namespace mem
+namespace _detail {
+
+#if VEG_HAS_ASAN
+extern "C" void __sanitizer_annotate_contiguous_container /* NOLINT */ (
+  const void* begin,
+  const void* end,
+  const void* old_mid,
+  const void* new_mid);
+#endif
+
+[[noreturn]] HEDLEY_NEVER_INLINE void
+throw_bad_alloc();
+[[noreturn]] inline void
+terminate() noexcept;
+namespace _mem {
+struct DeferUnreachable /* NOLINT */
+{
+  bool is_unreachable;
+  VEG_INLINE ~DeferUnreachable()
+  {
+    if (is_unreachable) {
+      HEDLEY_UNREACHABLE();
+    }
+  }
+};
+} // namespace _mem
+} // namespace _detail
+
+namespace mem {
+inline auto
+memmove(void* dest, void const* src, usize nbytes) noexcept -> void*
+{
+  if (dest != nullptr) {
+    return std::memmove(dest, src, nbytes);
+  } else {
+    return dest;
+  }
+}
+
+using byte = unsigned char;
+struct AllocBlock
+{
+  void* data;
+  usize byte_cap;
+};
+struct Layout
+{
+  usize byte_size;
+  usize align;
+};
+struct RelocFn
+{
+  void* (*fn)(void*, void const*, usize);
+
+  VEG_INLINE void operator()(void* dst, void* src, usize n) const noexcept
+  {
+    _detail::_mem::DeferUnreachable _{ true };
+    (*fn)(dst, src, n);
+    _.is_unreachable = false;
+  }
+  VEG_INLINE auto is_trivial() const noexcept -> bool
+  {
+    return fn == &mem::memmove;
+  }
+};
+} // namespace mem
+namespace concepts {
+namespace alloc {
+VEG_CONCEPT_EXPR((typename A),
+                 (A),
+                 dealloc,
+                 mem::Alloc<A>::dealloc( //
+                   VEG_DECLVAL(RefMut<A>),
+                   VEG_DECLVAL(void*),
+                   VEG_DECLVAL(mem::Layout)),
+                 true);
+
+VEG_CONCEPT_EXPR((typename A),
+                 (A),
+                 alloc,
+                 mem::Alloc<A>::alloc(VEG_DECLVAL(RefMut<A>),
+                                      VEG_DECLVAL(mem::Layout)),
+                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
+
+VEG_CONCEPT_EXPR((typename A),
+                 (A),
+                 owns_alloc,
+                 mem::Alloc<A>::owns(VEG_DECLVAL(Ref<A>),
+                                     VEG_DECLVAL(mem::Layout)),
+                 VEG_CONCEPT(same<ExprType, bool>));
+
+VEG_CONCEPT_EXPR((typename A),
+                 (A),
+                 grow,
+                 mem::Alloc<A>::grow(VEG_DECLVAL(RefMut<A>),
+                                     VEG_DECLVAL(void*),
+                                     VEG_DECLVAL(mem::Layout),
+                                     VEG_DECLVAL(usize),
+                                     VEG_DECLVAL(mem::RelocFn)),
+                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
+
+VEG_CONCEPT_EXPR((typename A),
+                 (A),
+                 shrink,
+                 mem::Alloc<A>::shrink(VEG_DECLVAL(RefMut<A>),
+                                       VEG_DECLVAL(void*),
+                                       VEG_DECLVAL(mem::Layout),
+                                       VEG_DECLVAL(usize),
+                                       VEG_DECLVAL(mem::RelocFn)),
+                 VEG_CONCEPT(same<ExprType, mem::AllocBlock>));
+
+VEG_CONCEPT_EXPR((typename C, typename T, typename A),
+                 (C, T, A),
+                 destroy,
+                 mem::Cloner<C>::destroy( //
+                   VEG_DECLVAL(RefMut<C>),
+                   VEG_DECLVAL(T*),
+                   VEG_DECLVAL(RefMut<A>)),
+                 true);
+
+VEG_CONCEPT_EXPR((typename C, typename T, typename A),
+                 (C, T, A),
+                 clone,
+                 mem::Cloner<C>::clone( //
+                   VEG_DECLVAL(RefMut<C>),
+                   VEG_DECLVAL(Ref<T>),
+                   VEG_DECLVAL(RefMut<A>)),
+                 VEG_CONCEPT(same<ExprType, T>));
+
+VEG_CONCEPT_EXPR((typename C, typename T, typename A),
+                 (C, T, A),
+                 clone_from,
+                 mem::Cloner<C>::clone_from(VEG_DECLVAL(RefMut<C>),
+                                            VEG_DECLVAL(RefMut<T>),
+                                            VEG_DECLVAL(Ref<T>),
+                                            VEG_DECLVAL(RefMut<A>)),
+                 true);
+} // namespace alloc
+} // namespace concepts
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_ALLOC_HPP_QHYOV5XDS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/assignable.hpp

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-#ifndef VEG_ASSIGNABLE_HPP_4ZNCRTO7S
-#define VEG_ASSIGNABLE_HPP_4ZNCRTO7S
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#if !VEG_HAS_BUILTIN(__is_trivially_assignable) ||                             \
-  !VEG_HAS_BUILTIN(__is_assignable) ||                                         \
-  !VEG_HAS_BUILTIN(__is_nothrow_assignable)
-#include <type_traits>
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace concepts {
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename U), assignable, T, U);
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename U),
-                                    nothrow_assignable,
-                                    T&&,
-                                    U&&);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
-                                      trivially_copy_assignable,
-                                      is_trivially_assignable,
-                                      T&,
-                                      T const&);
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
-                                      trivially_move_assignable,
-                                      is_trivially_assignable,
-                                      T&,
-                                      T&&);
-
-VEG_DEF_CONCEPT(typename T, move_assignable, VEG_CONCEPT(assignable<T&, T&&>));
-VEG_DEF_CONCEPT(typename T,
-                nothrow_move_assignable,
-                VEG_CONCEPT(nothrow_assignable<T&, T&&>));
-
-VEG_DEF_CONCEPT(typename T,
-                copy_assignable,
-                VEG_CONCEPT(assignable<T&, T const&>));
-VEG_DEF_CONCEPT(typename T,
-                nothrow_copy_assignable,
-                VEG_CONCEPT(nothrow_assignable<T&, T const&>));
-
-} // namespace concepts
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_ASSIGNABLE_HPP_4ZNCRTO7S */
+#ifndef VEG_ASSIGNABLE_HPP_4ZNCRTO7S
+#define VEG_ASSIGNABLE_HPP_4ZNCRTO7S
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#if !VEG_HAS_BUILTIN(__is_trivially_assignable) ||                             \
+  !VEG_HAS_BUILTIN(__is_assignable) ||                                         \
+  !VEG_HAS_BUILTIN(__is_nothrow_assignable)
+#include <type_traits>
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace concepts {
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename U), assignable, T, U);
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename U),
+                                    nothrow_assignable,
+                                    T&&,
+                                    U&&);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
+                                      trivially_copy_assignable,
+                                      is_trivially_assignable,
+                                      T&,
+                                      T const&);
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
+                                      trivially_move_assignable,
+                                      is_trivially_assignable,
+                                      T&,
+                                      T&&);
+
+VEG_DEF_CONCEPT(typename T, move_assignable, VEG_CONCEPT(assignable<T&, T&&>));
+VEG_DEF_CONCEPT(typename T,
+                nothrow_move_assignable,
+                VEG_CONCEPT(nothrow_assignable<T&, T&&>));
+
+VEG_DEF_CONCEPT(typename T,
+                copy_assignable,
+                VEG_CONCEPT(assignable<T&, T const&>));
+VEG_DEF_CONCEPT(typename T,
+                nothrow_copy_assignable,
+                VEG_CONCEPT(nothrow_assignable<T&, T const&>));
+
+} // namespace concepts
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_ASSIGNABLE_HPP_4ZNCRTO7S */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/constructible.hpp

 * *Ordering differences only*

```diff
@@ -1,217 +1,217 @@
-#ifndef VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS
-#define VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#include <new>
-
-#if !VEG_HAS_BUILTIN(__has_trivial_destructor) ||                              \
-  !VEG_HAS_BUILTIN(__is_trivially_constructible) ||                            \
-  !VEG_HAS_BUILTIN(__is_constructible) ||                                      \
-  !VEG_HAS_BUILTIN(__is_nothrow_constructible) ||                              \
-  !VEG_HAS_BUILTIN(__is_trivially_copyable) ||                                 \
-  !VEG_HAS_BUILTIN(__is_trivial) || !VEG_HAS_BUILTIN(__is_final) ||            \
-  !VEG_HAS_BUILTIN(__is_empty)
-#include <type_traits>
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace concepts {
-
-#if VEG_HAS_BUILTIN(__is_final) || defined(VEG_WITH_CXX14_SUPPORT)
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, final, T);
-#else
-VEG_DEF_CONCEPT(typename T, final, (sizeof(T) < 0));
-#endif
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, empty, T);
-
-VEG_DEF_CONCEPT(typename T,
-                nothrow_destructible,
-                noexcept(static_cast<T*>(nullptr)->~T()));
-
-VEG_DEF_CONCEPT(
-  typename T,
-  trivially_destructible,
-  VEG_HAS_BUILTIN_OR(__has_trivial_destructor,
-                     ((_detail::assert_complete<_detail::Wrapper<T>>(),
-                       __has_trivial_destructor(T))),
-                     (std::is_trivially_destructible<T>::value)));
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, trivially_copyable, T);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
-                                      trivially_default_constructible,
-                                      is_trivially_constructible,
-                                      T);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
-                                      trivially_copy_constructible,
-                                      is_trivially_constructible,
-                                      T,
-                                      T const&);
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
-                                      trivially_move_constructible,
-                                      is_trivially_constructible,
-                                      T,
-                                      T&&);
-
-VEG_CONCEPT_EXPR((typename T, typename... Ts),
-                 (T, Ts...),
-                 inplace_constructible,
-                 new(static_cast<void*>(nullptr)) T(VEG_DECLVAL(Ts&&)...),
-                 true);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename... Ts),
-                                    constructible,
-                                    T,
-                                    Ts&&...);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename... Ts),
-                                    nothrow_constructible,
-                                    T,
-                                    Ts&&...);
-
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename From, typename To),
-                                    convertible,
-                                    From&&,
-                                    To);
-
-VEG_DEF_CONCEPT((typename T, typename U),
-                implicitly_constructible,
-                VEG_CONCEPT(convertible<U&&, T>));
-
-VEG_DEF_CONCEPT(typename T,
-                movable,
-                VEG_HAS_BUILTIN_OR(__is_constructiblex,
-                                   __is_constructible(T, T&&),
-                                   (VEG_CONCEPT(constructible<T, T&&>))));
-VEG_DEF_CONCEPT(
-  typename T,
-  nothrow_movable,
-  VEG_HAS_BUILTIN_OR(__is_nothrow_constructiblex,
-                     __is_nothrow_constructible(T, T&&),
-                     (VEG_CONCEPT(nothrow_constructible<T, T&&>))));
-
-VEG_DEF_CONCEPT(typename T, copyable, VEG_CONCEPT(constructible<T, T const&>));
-VEG_DEF_CONCEPT(typename T,
-                nothrow_copyable,
-                VEG_CONCEPT(nothrow_constructible<T, T const&>));
-
-} // namespace concepts
-namespace cpo {
-template<typename T>
-struct is_trivially_constructible;
-
-template<typename T>
-struct is_trivially_relocatable;
-} // namespace cpo
-
-namespace _detail {
-namespace _cpo {
-
-template<bool, template<typename> class Trait, typename T>
-struct extract_members_deduce_trait_impl : meta::false_type
-{};
-
-template<template<typename> class Trait, typename Tuple>
-struct member_trait_and;
-
-template<template<typename> class Trait,
-         usize... Is,
-         typename... Bases,
-         typename... Ts>
-struct member_trait_and<
-  Trait,
-  SimpleITuple<_meta::integer_sequence<usize, Is...>, Ts Bases::*...>>
-  : meta::bool_constant<VEG_ALL_OF(Trait<Ts>::value)>
-{};
-
-template<template<typename> class Trait, typename T>
-struct extract_members_deduce_trait_impl<true, Trait, T>
-  : member_trait_and<
-      Trait,
-      decltype(_detail::member_extract_access<T>::Type::member_pointers())>
-{};
-
-template<template<typename> class Trait, typename T>
-struct extract_members_deduce_trait
-  : extract_members_deduce_trait_impl<_detail::member_extract_access<T>::value,
-                                      Trait,
-                                      T>
-{};
-
-} // namespace _cpo
-} // namespace _detail
-
-namespace cpo {
-template<typename T>
-struct is_trivially_constructible
-  : meta::if_t<
-      VEG_CONCEPT(trivially_default_constructible<T>),
-      meta::true_type,
-      _detail::_cpo::extract_members_deduce_trait<is_trivially_relocatable, T>>
-{};
-
-template<typename T>
-struct is_trivially_relocatable
-  : meta::if_t<
-      VEG_CONCEPT(trivially_copyable<T>) &&
-        VEG_CONCEPT(trivially_move_constructible<T>),
-      meta::true_type,
-      _detail::_cpo::extract_members_deduce_trait<is_trivially_relocatable, T>>
-{};
-} // namespace cpo
-
-namespace _detail {
-template<typename T>
-struct DefaultFn
-{
-  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
-    VEG_CONCEPT(nothrow_constructible<T>)) -> T
-  {
-    return T();
-  }
-};
-template<typename T>
-struct MoveFn
-{
-  T&& value;
-  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
-    VEG_CONCEPT(nothrow_movable<T>)) -> T
-  {
-    return T(VEG_FWD(value));
-  }
-};
-template<typename T>
-struct CopyFn
-{
-  T const& value;
-  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
-    VEG_CONCEPT(nothrow_copyable<T>)) -> T
-  {
-    return T(value);
-  }
-};
-
-template<typename Fn, typename T>
-struct WithArg
-{
-  Fn&& fn;
-  T&& arg;
-  VEG_INLINE constexpr auto operator()() const&& -> decltype(VEG_FWD(fn)(
-    VEG_FWD(arg)))
-  {
-    return VEG_FWD(fn)(VEG_FWD(arg));
-  }
-};
-
-} // namespace _detail
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS */
+#ifndef VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS
+#define VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#include <new>
+
+#if !VEG_HAS_BUILTIN(__has_trivial_destructor) ||                              \
+  !VEG_HAS_BUILTIN(__is_trivially_constructible) ||                            \
+  !VEG_HAS_BUILTIN(__is_constructible) ||                                      \
+  !VEG_HAS_BUILTIN(__is_nothrow_constructible) ||                              \
+  !VEG_HAS_BUILTIN(__is_trivially_copyable) ||                                 \
+  !VEG_HAS_BUILTIN(__is_trivial) || !VEG_HAS_BUILTIN(__is_final) ||            \
+  !VEG_HAS_BUILTIN(__is_empty)
+#include <type_traits>
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace concepts {
+
+#if VEG_HAS_BUILTIN(__is_final) || defined(VEG_WITH_CXX14_SUPPORT)
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, final, T);
+#else
+VEG_DEF_CONCEPT(typename T, final, (sizeof(T) < 0));
+#endif
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, empty, T);
+
+VEG_DEF_CONCEPT(typename T,
+                nothrow_destructible,
+                noexcept(static_cast<T*>(nullptr)->~T()));
+
+VEG_DEF_CONCEPT(
+  typename T,
+  trivially_destructible,
+  VEG_HAS_BUILTIN_OR(__has_trivial_destructor,
+                     ((_detail::assert_complete<_detail::Wrapper<T>>(),
+                       __has_trivial_destructor(T))),
+                     (std::is_trivially_destructible<T>::value)));
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, trivially_copyable, T);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
+                                      trivially_default_constructible,
+                                      is_trivially_constructible,
+                                      T);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
+                                      trivially_copy_constructible,
+                                      is_trivially_constructible,
+                                      T,
+                                      T const&);
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_TRAIT(typename T,
+                                      trivially_move_constructible,
+                                      is_trivially_constructible,
+                                      T,
+                                      T&&);
+
+VEG_CONCEPT_EXPR((typename T, typename... Ts),
+                 (T, Ts...),
+                 inplace_constructible,
+                 new(static_cast<void*>(nullptr)) T(VEG_DECLVAL(Ts&&)...),
+                 true);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename... Ts),
+                                    constructible,
+                                    T,
+                                    Ts&&...);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename T, typename... Ts),
+                                    nothrow_constructible,
+                                    T,
+                                    Ts&&...);
+
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD((typename From, typename To),
+                                    convertible,
+                                    From&&,
+                                    To);
+
+VEG_DEF_CONCEPT((typename T, typename U),
+                implicitly_constructible,
+                VEG_CONCEPT(convertible<U&&, T>));
+
+VEG_DEF_CONCEPT(typename T,
+                movable,
+                VEG_HAS_BUILTIN_OR(__is_constructiblex,
+                                   __is_constructible(T, T&&),
+                                   (VEG_CONCEPT(constructible<T, T&&>))));
+VEG_DEF_CONCEPT(
+  typename T,
+  nothrow_movable,
+  VEG_HAS_BUILTIN_OR(__is_nothrow_constructiblex,
+                     __is_nothrow_constructible(T, T&&),
+                     (VEG_CONCEPT(nothrow_constructible<T, T&&>))));
+
+VEG_DEF_CONCEPT(typename T, copyable, VEG_CONCEPT(constructible<T, T const&>));
+VEG_DEF_CONCEPT(typename T,
+                nothrow_copyable,
+                VEG_CONCEPT(nothrow_constructible<T, T const&>));
+
+} // namespace concepts
+namespace cpo {
+template<typename T>
+struct is_trivially_constructible;
+
+template<typename T>
+struct is_trivially_relocatable;
+} // namespace cpo
+
+namespace _detail {
+namespace _cpo {
+
+template<bool, template<typename> class Trait, typename T>
+struct extract_members_deduce_trait_impl : meta::false_type
+{};
+
+template<template<typename> class Trait, typename Tuple>
+struct member_trait_and;
+
+template<template<typename> class Trait,
+         usize... Is,
+         typename... Bases,
+         typename... Ts>
+struct member_trait_and<
+  Trait,
+  SimpleITuple<_meta::integer_sequence<usize, Is...>, Ts Bases::*...>>
+  : meta::bool_constant<VEG_ALL_OF(Trait<Ts>::value)>
+{};
+
+template<template<typename> class Trait, typename T>
+struct extract_members_deduce_trait_impl<true, Trait, T>
+  : member_trait_and<
+      Trait,
+      decltype(_detail::member_extract_access<T>::Type::member_pointers())>
+{};
+
+template<template<typename> class Trait, typename T>
+struct extract_members_deduce_trait
+  : extract_members_deduce_trait_impl<_detail::member_extract_access<T>::value,
+                                      Trait,
+                                      T>
+{};
+
+} // namespace _cpo
+} // namespace _detail
+
+namespace cpo {
+template<typename T>
+struct is_trivially_constructible
+  : meta::if_t<
+      VEG_CONCEPT(trivially_default_constructible<T>),
+      meta::true_type,
+      _detail::_cpo::extract_members_deduce_trait<is_trivially_relocatable, T>>
+{};
+
+template<typename T>
+struct is_trivially_relocatable
+  : meta::if_t<
+      VEG_CONCEPT(trivially_copyable<T>) &&
+        VEG_CONCEPT(trivially_move_constructible<T>),
+      meta::true_type,
+      _detail::_cpo::extract_members_deduce_trait<is_trivially_relocatable, T>>
+{};
+} // namespace cpo
+
+namespace _detail {
+template<typename T>
+struct DefaultFn
+{
+  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
+    VEG_CONCEPT(nothrow_constructible<T>)) -> T
+  {
+    return T();
+  }
+};
+template<typename T>
+struct MoveFn
+{
+  T&& value;
+  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
+    VEG_CONCEPT(nothrow_movable<T>)) -> T
+  {
+    return T(VEG_FWD(value));
+  }
+};
+template<typename T>
+struct CopyFn
+{
+  T const& value;
+  VEG_INLINE constexpr auto operator()() const&& VEG_NOEXCEPT_IF(
+    VEG_CONCEPT(nothrow_copyable<T>)) -> T
+  {
+    return T(value);
+  }
+};
+
+template<typename Fn, typename T>
+struct WithArg
+{
+  Fn&& fn;
+  T&& arg;
+  VEG_INLINE constexpr auto operator()() const&& -> decltype(VEG_FWD(fn)(
+    VEG_FWD(arg)))
+  {
+    return VEG_FWD(fn)(VEG_FWD(arg));
+  }
+};
+
+} // namespace _detail
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_CONSTRUCTIBLE_HPP_D6CRVBJYS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/core.hpp

 * *Ordering differences only*

```diff
@@ -1,298 +1,298 @@
-#ifndef VEG_CORE_HPP_GJCBNFLAS
-#define VEG_CORE_HPP_GJCBNFLAS
-
-#include "proxsuite/linalg/veg/internal/typedefs.hpp"
-#include "proxsuite/linalg/veg/internal/integer_seq.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#if defined(VEG_WITH_CXX20_SUPPORT) &&                                         \
-  !VEG_HAS_BUILTIN(__builtin_is_constant_evaluated)
-#include <type_traits>
-#define VEG_HAS_CONSTEVAL 1
-#define VEG_IS_CONSTEVAL() ::std::is_constant_evaluated()
-#elif VEG_HAS_BUILTIN(__builtin_is_constant_evaluated)
-#define VEG_HAS_CONSTEVAL 1
-#define VEG_IS_CONSTEVAL() __builtin_is_constant_evaluated()
-#else
-#define VEG_HAS_CONSTEVAL 0
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace meta {
-namespace nb {
-struct is_consteval
-{
-  constexpr auto operator()() const noexcept -> bool
-  {
-#if VEG_HAS_CONSTEVAL
-    return VEG_IS_CONSTEVAL();
-#else
-    return true;
-#endif
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(is_consteval);
-} // namespace meta
-
-namespace _detail {
-namespace _meta {
-template<bool B>
-struct conditional_;
-template<>
-struct conditional_<true>
-{
-  template<typename T, typename F>
-  using type = T;
-};
-template<>
-struct conditional_<false>
-{
-  template<typename T, typename F>
-  using type = F;
-};
-struct none
-{};
-} // namespace _meta
-} // namespace _detail
-
-namespace meta {
-
-template<template<typename...> class F, typename... Ts>
-struct meta_apply
-{
-  using type = F<Ts...>;
-};
-template<template<typename...> class F>
-struct apply_wrapper
-{
-  template<typename... Ts>
-  using type = F<Ts...>;
-};
-template<typename T>
-struct type_identity
-{
-  using type = T;
-};
-template<typename T>
-using type_identity_t = typename type_identity<T>::type;
-
-template<bool B, typename T, typename F>
-using if_t = typename _detail::_meta::conditional_<B>::template type<T, F>;
-
-template<typename...>
-using void_t = void;
-
-template<typename... Preds>
-struct disjunction;
-template<typename... Preds>
-struct conjunction;
-
-template<>
-struct disjunction<> : false_type
-{};
-template<>
-struct conjunction<> : true_type
-{};
-
-template<typename First, typename... Preds>
-struct disjunction<First, Preds...>
-  : if_t<First::value, First, disjunction<Preds...>>
-{};
-
-template<typename First, typename... Preds>
-struct conjunction<First, Preds...>
-  : if_t<First::value, conjunction<Preds...>, First>
-{};
-} // namespace meta
-
-namespace _detail {
-namespace _meta {
-
-template<typename T>
-struct decay_helper : meta::type_identity<T>
-{};
-template<typename Ret, typename... Args>
-struct decay_helper<Ret(Args...)> : meta::type_identity<Ret (*)(Args...)>
-{};
-#if defined(VEG_WITH_CXX17_SUPPORT)
-template<typename Ret, typename... Args>
-struct decay_helper<Ret(Args...) noexcept>
-  : meta::type_identity<Ret (*)(Args...) noexcept>
-{};
-#endif
-template<typename T, usize N>
-struct decay_helper<T[N]> : meta::type_identity<T*>
-{};
-
-using namespace meta;
-
-#if defined(VEG_WITH_CXX14_SUPPORT)
-
-template<typename Enable, template<typename...> class Ftor, typename... Args>
-constexpr bool _is_detected_v = false;
-template<template<typename...> class Ftor, typename... Args>
-constexpr bool _is_detected_v<meta::void_t<Ftor<Args...>>, Ftor, Args...> =
-  true;
-
-template<template<typename...> class Op, typename... Args>
-constexpr bool is_detected_v = _is_detected_v<void, Op, Args...>;
-
-#else
-
-template<typename Enable, template<typename...> class Ftor, typename... Args>
-struct _detector
-{
-  using value_type = false_type;
-};
-template<template<typename...> class Ftor, typename... Args>
-struct _detector<meta::void_t<Ftor<Args...>>, Ftor, Args...>
-{
-  using value_type = true_type;
-};
-
-template<typename Default, template<typename...> class Ftor, typename... Args>
-struct detector : _detector<void, Ftor, Args...>
-{};
-
-template<template<typename...> class Op, typename... Args>
-using is_detected = typename detector<_meta::none, Op, Args...>::value_type;
-
-#endif
-
-template<typename T>
-struct is_pointer
-  : false_type
-  , type_identity<T>
-{};
-template<typename T>
-struct is_pointer<T*>
-  : true_type
-  , type_identity<T>
-{};
-
-template<typename Base>
-struct baseof_wrapper : wrapper_base
-{
-  using wrapper_base::test;
-  static auto test(Base const volatile*) -> true_type;
-};
-
-template<typename Base, typename Derived>
-using is_base_of =
-  decltype(baseof_wrapper<Base>::test(static_cast<Derived>(nullptr)));
-
-template<typename T>
-struct is_lvalue_reference : false_type
-{};
-template<typename T>
-struct is_lvalue_reference<T&> : true_type
-{};
-template<typename T>
-struct is_rvalue_reference : false_type
-{};
-template<typename T>
-struct is_rvalue_reference<T&&> : true_type
-{};
-
-template<typename T>
-struct is_const : false_type
-{};
-template<typename T>
-struct is_const<T const> : true_type
-{};
-
-template<typename T, typename = true_type>
-struct is_complete : false_type
-{};
-template<typename T>
-struct is_complete<T, bool_constant<sizeof(T) == sizeof(T)> /* NOLINT */>
-  : true_type
-{};
-
-} // namespace _meta
-} // namespace _detail
-
-namespace concepts {
-using meta::conjunction;
-using meta::disjunction;
-
-#if defined(VEG_WITH_CXX20_SUPPORT)
-VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
-                detected,
-                requires { typename Op<Args...>; });
-#elif defined(VEG_WITH_CXX14_SUPPORT)
-VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
-                detected,
-                _detail::_meta::is_detected_v<Op, Args...>);
-#else
-VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
-                detected,
-                _detail::_meta::is_detected<Op, Args...>::value);
-#endif
-
-VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL((typename T, typename U), base_of, T, U);
-
-VEG_DEF_CONCEPT(typename T,
-                const_type,
-                VEG_HAS_BUILTIN_OR(__is_const,
-                                   __is_const(T),
-                                   (_detail::_meta::is_const<T>::value)));
-VEG_DEF_CONCEPT(typename T,
-                void_type,
-                VEG_CONCEPT(same<void const volatile, T const volatile>));
-
-// can't use __is_pointer because of <bits/cpp_type_traits.h> header
-VEG_DEF_CONCEPT(typename T, pointer, _detail::_meta::is_pointer<T>::value);
-
-VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(typename T, lvalue_reference, T);
-VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(typename T, rvalue_reference, T);
-VEG_DEF_CONCEPT(typename T,
-                reference,
-                (VEG_CONCEPT(lvalue_reference<T>) ||
-                 VEG_CONCEPT(rvalue_reference<T>)));
-
-#if VEG_HAS_BUILTIN(__is_complete_type)
-VEG_DEF_CONCEPT(typename T, complete, __is_complete_type(T));
-#else
-VEG_DEF_CONCEPT(typename T, complete, _detail::_meta::is_complete<T>::value);
-#endif
-
-} // namespace concepts
-
-namespace meta {
-
-template<typename T>
-using unref_t = typename _detail::_meta::unref<T&>::type;
-template<typename T>
-using unptr_t = typename _detail::_meta::is_pointer<T>::type;
-
-template<typename Default, template<typename...> class Op, typename... Args>
-using detected_or_t = typename meta::if_t<VEG_CONCEPT(detected<Op, Args...>),
-                                          meta::meta_apply<Op, Args...>,
-                                          meta::type_identity<Default>>::type;
-
-template<template<typename...> class Op, typename... Args>
-using detected_t = detected_or_t<_detail::_meta::none, Op, Args...>;
-
-#ifdef __clang__
-template<template<typename...> class Op, typename... Args>
-using detected_return_t = Op<Args...>;
-#else
-template<template<typename...> class Op, typename... Args>
-using detected_return_t = detected_or_t<_detail::_meta::none, Op, Args...>;
-#endif
-
-template<typename T>
-using decay_t = typename _detail::_meta::decay_helper<uncvref_t<T>>::type;
-} // namespace meta
-template<typename T>
-using DoNotDeduce = meta::type_identity_t<T>;
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_CORE_HPP_GJCBNFLAS */
+#ifndef VEG_CORE_HPP_GJCBNFLAS
+#define VEG_CORE_HPP_GJCBNFLAS
+
+#include "proxsuite/linalg/veg/internal/typedefs.hpp"
+#include "proxsuite/linalg/veg/internal/integer_seq.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#if defined(VEG_WITH_CXX20_SUPPORT) &&                                         \
+  !VEG_HAS_BUILTIN(__builtin_is_constant_evaluated)
+#include <type_traits>
+#define VEG_HAS_CONSTEVAL 1
+#define VEG_IS_CONSTEVAL() ::std::is_constant_evaluated()
+#elif VEG_HAS_BUILTIN(__builtin_is_constant_evaluated)
+#define VEG_HAS_CONSTEVAL 1
+#define VEG_IS_CONSTEVAL() __builtin_is_constant_evaluated()
+#else
+#define VEG_HAS_CONSTEVAL 0
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace meta {
+namespace nb {
+struct is_consteval
+{
+  constexpr auto operator()() const noexcept -> bool
+  {
+#if VEG_HAS_CONSTEVAL
+    return VEG_IS_CONSTEVAL();
+#else
+    return true;
+#endif
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(is_consteval);
+} // namespace meta
+
+namespace _detail {
+namespace _meta {
+template<bool B>
+struct conditional_;
+template<>
+struct conditional_<true>
+{
+  template<typename T, typename F>
+  using type = T;
+};
+template<>
+struct conditional_<false>
+{
+  template<typename T, typename F>
+  using type = F;
+};
+struct none
+{};
+} // namespace _meta
+} // namespace _detail
+
+namespace meta {
+
+template<template<typename...> class F, typename... Ts>
+struct meta_apply
+{
+  using type = F<Ts...>;
+};
+template<template<typename...> class F>
+struct apply_wrapper
+{
+  template<typename... Ts>
+  using type = F<Ts...>;
+};
+template<typename T>
+struct type_identity
+{
+  using type = T;
+};
+template<typename T>
+using type_identity_t = typename type_identity<T>::type;
+
+template<bool B, typename T, typename F>
+using if_t = typename _detail::_meta::conditional_<B>::template type<T, F>;
+
+template<typename...>
+using void_t = void;
+
+template<typename... Preds>
+struct disjunction;
+template<typename... Preds>
+struct conjunction;
+
+template<>
+struct disjunction<> : false_type
+{};
+template<>
+struct conjunction<> : true_type
+{};
+
+template<typename First, typename... Preds>
+struct disjunction<First, Preds...>
+  : if_t<First::value, First, disjunction<Preds...>>
+{};
+
+template<typename First, typename... Preds>
+struct conjunction<First, Preds...>
+  : if_t<First::value, conjunction<Preds...>, First>
+{};
+} // namespace meta
+
+namespace _detail {
+namespace _meta {
+
+template<typename T>
+struct decay_helper : meta::type_identity<T>
+{};
+template<typename Ret, typename... Args>
+struct decay_helper<Ret(Args...)> : meta::type_identity<Ret (*)(Args...)>
+{};
+#if defined(VEG_WITH_CXX17_SUPPORT)
+template<typename Ret, typename... Args>
+struct decay_helper<Ret(Args...) noexcept>
+  : meta::type_identity<Ret (*)(Args...) noexcept>
+{};
+#endif
+template<typename T, usize N>
+struct decay_helper<T[N]> : meta::type_identity<T*>
+{};
+
+using namespace meta;
+
+#if defined(VEG_WITH_CXX14_SUPPORT)
+
+template<typename Enable, template<typename...> class Ftor, typename... Args>
+constexpr bool _is_detected_v = false;
+template<template<typename...> class Ftor, typename... Args>
+constexpr bool _is_detected_v<meta::void_t<Ftor<Args...>>, Ftor, Args...> =
+  true;
+
+template<template<typename...> class Op, typename... Args>
+constexpr bool is_detected_v = _is_detected_v<void, Op, Args...>;
+
+#else
+
+template<typename Enable, template<typename...> class Ftor, typename... Args>
+struct _detector
+{
+  using value_type = false_type;
+};
+template<template<typename...> class Ftor, typename... Args>
+struct _detector<meta::void_t<Ftor<Args...>>, Ftor, Args...>
+{
+  using value_type = true_type;
+};
+
+template<typename Default, template<typename...> class Ftor, typename... Args>
+struct detector : _detector<void, Ftor, Args...>
+{};
+
+template<template<typename...> class Op, typename... Args>
+using is_detected = typename detector<_meta::none, Op, Args...>::value_type;
+
+#endif
+
+template<typename T>
+struct is_pointer
+  : false_type
+  , type_identity<T>
+{};
+template<typename T>
+struct is_pointer<T*>
+  : true_type
+  , type_identity<T>
+{};
+
+template<typename Base>
+struct baseof_wrapper : wrapper_base
+{
+  using wrapper_base::test;
+  static auto test(Base const volatile*) -> true_type;
+};
+
+template<typename Base, typename Derived>
+using is_base_of =
+  decltype(baseof_wrapper<Base>::test(static_cast<Derived>(nullptr)));
+
+template<typename T>
+struct is_lvalue_reference : false_type
+{};
+template<typename T>
+struct is_lvalue_reference<T&> : true_type
+{};
+template<typename T>
+struct is_rvalue_reference : false_type
+{};
+template<typename T>
+struct is_rvalue_reference<T&&> : true_type
+{};
+
+template<typename T>
+struct is_const : false_type
+{};
+template<typename T>
+struct is_const<T const> : true_type
+{};
+
+template<typename T, typename = true_type>
+struct is_complete : false_type
+{};
+template<typename T>
+struct is_complete<T, bool_constant<sizeof(T) == sizeof(T)> /* NOLINT */>
+  : true_type
+{};
+
+} // namespace _meta
+} // namespace _detail
+
+namespace concepts {
+using meta::conjunction;
+using meta::disjunction;
+
+#if defined(VEG_WITH_CXX20_SUPPORT)
+VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
+                detected,
+                requires { typename Op<Args...>; });
+#elif defined(VEG_WITH_CXX14_SUPPORT)
+VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
+                detected,
+                _detail::_meta::is_detected_v<Op, Args...>);
+#else
+VEG_DEF_CONCEPT((template<typename...> class Op, typename... Args),
+                detected,
+                _detail::_meta::is_detected<Op, Args...>::value);
+#endif
+
+VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL((typename T, typename U), base_of, T, U);
+
+VEG_DEF_CONCEPT(typename T,
+                const_type,
+                VEG_HAS_BUILTIN_OR(__is_const,
+                                   __is_const(T),
+                                   (_detail::_meta::is_const<T>::value)));
+VEG_DEF_CONCEPT(typename T,
+                void_type,
+                VEG_CONCEPT(same<void const volatile, T const volatile>));
+
+// can't use __is_pointer because of <bits/cpp_type_traits.h> header
+VEG_DEF_CONCEPT(typename T, pointer, _detail::_meta::is_pointer<T>::value);
+
+VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(typename T, lvalue_reference, T);
+VEG_DEF_CONCEPT_BUILTIN_OR_INTERNAL(typename T, rvalue_reference, T);
+VEG_DEF_CONCEPT(typename T,
+                reference,
+                (VEG_CONCEPT(lvalue_reference<T>) ||
+                 VEG_CONCEPT(rvalue_reference<T>)));
+
+#if VEG_HAS_BUILTIN(__is_complete_type)
+VEG_DEF_CONCEPT(typename T, complete, __is_complete_type(T));
+#else
+VEG_DEF_CONCEPT(typename T, complete, _detail::_meta::is_complete<T>::value);
+#endif
+
+} // namespace concepts
+
+namespace meta {
+
+template<typename T>
+using unref_t = typename _detail::_meta::unref<T&>::type;
+template<typename T>
+using unptr_t = typename _detail::_meta::is_pointer<T>::type;
+
+template<typename Default, template<typename...> class Op, typename... Args>
+using detected_or_t = typename meta::if_t<VEG_CONCEPT(detected<Op, Args...>),
+                                          meta::meta_apply<Op, Args...>,
+                                          meta::type_identity<Default>>::type;
+
+template<template<typename...> class Op, typename... Args>
+using detected_t = detected_or_t<_detail::_meta::none, Op, Args...>;
+
+#ifdef __clang__
+template<template<typename...> class Op, typename... Args>
+using detected_return_t = Op<Args...>;
+#else
+template<template<typename...> class Op, typename... Args>
+using detected_return_t = detected_or_t<_detail::_meta::none, Op, Args...>;
+#endif
+
+template<typename T>
+using decay_t = typename _detail::_meta::decay_helper<uncvref_t<T>>::type;
+} // namespace meta
+template<typename T>
+using DoNotDeduce = meta::type_identity_t<T>;
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_CORE_HPP_GJCBNFLAS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/invocable.hpp

```diff
@@ -1,47 +1,47 @@
-#ifndef VEG_INVOCABLE_HPP_GVSWRKAYS
-#define VEG_INVOCABLE_HPP_GVSWRKAYS
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace _detail {
-namespace _meta {
-template<typename Fn, typename... Args>
-using call_expr = decltype(VEG_DECLVAL(Fn &&)(VEG_DECLVAL(Args &&)...));
-} // namespace _meta
-} // namespace _detail
-namespace meta {
-template<typename Fn, typename... Args>
-using invoke_result_t =
-  meta::detected_t<_detail::_meta::call_expr, Fn&&, Args&&...>;
-} // namespace meta
-
-namespace concepts {
-VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
-                 (Fn, Ret, Args...),
-                 fn_once,
-                 VEG_DECLVAL(Fn&&)(VEG_DECLVAL(Args&&)...),
-                 VEG_CONCEPT(same<ExprType, Ret>));
-
-VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
-                 (Fn, Ret, Args...),
-                 fn_mut,
-                 VEG_DECLVAL(Fn&)(VEG_DECLVAL(Args&&)...),
-                 VEG_CONCEPT(same<ExprType, Ret>));
-
-VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
-                 (Fn, Ret, Args...),
-                 fn,
-                 VEG_DECLVAL(Fn const&)(VEG_DECLVAL(Args&&)...),
-                 VEG_CONCEPT(same<ExprType, Ret>));
-} // namespace concepts
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_INVOCABLE_HPP_GVSWRKAYS */
+#ifndef VEG_INVOCABLE_HPP_GVSWRKAYS
+#define VEG_INVOCABLE_HPP_GVSWRKAYS
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace _detail {
+namespace _meta {
+template<typename Fn, typename... Args>
+using call_expr = decltype(VEG_DECLVAL(Fn&&)(VEG_DECLVAL(Args&&)...));
+} // namespace _meta
+} // namespace _detail
+namespace meta {
+template<typename Fn, typename... Args>
+using invoke_result_t =
+  meta::detected_t<_detail::_meta::call_expr, Fn&&, Args&&...>;
+} // namespace meta
+
+namespace concepts {
+VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
+                 (Fn, Ret, Args...),
+                 fn_once,
+                 VEG_DECLVAL(Fn&&)(VEG_DECLVAL(Args&&)...),
+                 VEG_CONCEPT(same<ExprType, Ret>));
+
+VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
+                 (Fn, Ret, Args...),
+                 fn_mut,
+                 VEG_DECLVAL(Fn&)(VEG_DECLVAL(Args&&)...),
+                 VEG_CONCEPT(same<ExprType, Ret>));
+
+VEG_CONCEPT_EXPR((typename Fn, typename Ret, typename... Args),
+                 (Fn, Ret, Args...),
+                 fn,
+                 VEG_DECLVAL(Fn const&)(VEG_DECLVAL(Args&&)...),
+                 VEG_CONCEPT(same<ExprType, Ret>));
+} // namespace concepts
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_INVOCABLE_HPP_GVSWRKAYS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/primitives.hpp

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-#ifndef VEG_PRIMITIVES_HPP_A8O6GDV1S
-#define VEG_PRIMITIVES_HPP_A8O6GDV1S
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-#if !VEG_HAS_BUILTIN(__is_integral) ||                                         \
-  !VEG_HAS_BUILTIN(__is_floating_point) || !(VEG_HAS_BUILTIN(__is_enum))
-#include <type_traits>
-#endif
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace concepts {
-namespace aux {
-VEG_DEF_CONCEPT(typename T, no_wraps_around, (T(-1) <= T(0)));
-VEG_DEF_CONCEPT(typename T, wraps_around, (T(-1) > T(0)));
-} // namespace aux
-
-VEG_DEF_CONCEPT(typename T,
-                enum_type,
-                VEG_HAS_BUILTIN_OR(__is_enum,
-                                   __is_enum(T),
-                                   std::is_enum<T>::value));
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, integral, T);
-VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, floating_point, T);
-VEG_DEF_CONCEPT_DISJUNCTION(typename T,
-                            arithmetic,
-                            ((, integral<T>), (, floating_point<T>)));
-VEG_DEF_CONCEPT_CONJUNCTION(typename T,
-                            signed_integral,
-                            ((, integral<T>), (aux::, no_wraps_around<T>)));
-VEG_DEF_CONCEPT_CONJUNCTION(typename T,
-                            unsigned_integral,
-                            ((, integral<T>), (aux::, wraps_around<T>)));
-} // namespace concepts
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_PRIMITIVES_HPP_A8O6GDV1S */
+#ifndef VEG_PRIMITIVES_HPP_A8O6GDV1S
+#define VEG_PRIMITIVES_HPP_A8O6GDV1S
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+#if !VEG_HAS_BUILTIN(__is_integral) ||                                         \
+  !VEG_HAS_BUILTIN(__is_floating_point) || !(VEG_HAS_BUILTIN(__is_enum))
+#include <type_traits>
+#endif
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace concepts {
+namespace aux {
+VEG_DEF_CONCEPT(typename T, no_wraps_around, (T(-1) <= T(0)));
+VEG_DEF_CONCEPT(typename T, wraps_around, (T(-1) > T(0)));
+} // namespace aux
+
+VEG_DEF_CONCEPT(typename T,
+                enum_type,
+                VEG_HAS_BUILTIN_OR(__is_enum,
+                                   __is_enum(T),
+                                   std::is_enum<T>::value));
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, integral, T);
+VEG_DEF_CONCEPT_FROM_BUILTIN_OR_STD(typename T, floating_point, T);
+VEG_DEF_CONCEPT_DISJUNCTION(typename T,
+                            arithmetic,
+                            ((, integral<T>), (, floating_point<T>)));
+VEG_DEF_CONCEPT_CONJUNCTION(typename T,
+                            signed_integral,
+                            ((, integral<T>), (aux::, no_wraps_around<T>)));
+VEG_DEF_CONCEPT_CONJUNCTION(typename T,
+                            unsigned_integral,
+                            ((, integral<T>), (aux::, wraps_around<T>)));
+} // namespace concepts
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_PRIMITIVES_HPP_A8O6GDV1S */
```

## cmeel.prefix/include/proxsuite/linalg/veg/type_traits/tags.hpp

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-#ifndef VEG_TAGS_HPP_FYDE7Q6ZS
-#define VEG_TAGS_HPP_FYDE7Q6ZS
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-inline namespace tags {
-VEG_TAG_TEMPLATE(typename T, tag, Tag, T);
-VEG_TAG(as_ref, AsRef);
-VEG_TAG(as_mut, AsMut);
-VEG_TAG(from, From);
-VEG_TAG(from_i, FromI);
-VEG_TAG(as_ref_once, AsRefOnce);
-
-VEG_TAG(from_alloc, FromAlloc);
-VEG_TAG(from_alloc_and_value, FromAllocAndValue);
-
-VEG_TAG(from_slice, FromSlice);
-VEG_TAG(from_slice_mut, FromSliceMut);
-template<typename Tag>
-struct InPlace
-{
-  InPlace() = default;
-};
-
-template<>
-struct InPlace<void>
-{
-  InPlace() = default;
-  template<typename Tag>
-  VEG_INLINE constexpr auto operator[](Tag /*tag*/) const noexcept
-    -> InPlace<Tag>
-  {
-    return InPlace<Tag>{};
-  }
-};
-VEG_INLINE_VAR(inplace, InPlace<void>);
-} // namespace tags
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_TAGS_HPP_FYDE7Q6ZS */
+#ifndef VEG_TAGS_HPP_FYDE7Q6ZS
+#define VEG_TAGS_HPP_FYDE7Q6ZS
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+inline namespace tags {
+VEG_TAG_TEMPLATE(typename T, tag, Tag, T);
+VEG_TAG(as_ref, AsRef);
+VEG_TAG(as_mut, AsMut);
+VEG_TAG(from, From);
+VEG_TAG(from_i, FromI);
+VEG_TAG(as_ref_once, AsRefOnce);
+
+VEG_TAG(from_alloc, FromAlloc);
+VEG_TAG(from_alloc_and_value, FromAllocAndValue);
+
+VEG_TAG(from_slice, FromSlice);
+VEG_TAG(from_slice_mut, FromSliceMut);
+template<typename Tag>
+struct InPlace
+{
+  InPlace() = default;
+};
+
+template<>
+struct InPlace<void>
+{
+  InPlace() = default;
+  template<typename Tag>
+  VEG_INLINE constexpr auto operator[](Tag /*tag*/) const noexcept
+    -> InPlace<Tag>
+  {
+    return InPlace<Tag>{};
+  }
+};
+VEG_INLINE_VAR(inplace, InPlace<void>);
+} // namespace tags
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_TAGS_HPP_FYDE7Q6ZS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/assert.hpp

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-#include "proxsuite/linalg/veg/internal/assert_impl.hpp"
-
-#ifdef VEG_DEBUG_ASSERT
-#undef VEG_DEBUG_ASSERT
-#endif
-#ifdef VEG_DEBUG_EXPECT
-#undef VEG_DEBUG_EXPECT
-#endif
-#ifdef VEG_DEBUG_ASSERT_ELSE
-#undef VEG_DEBUG_ASSERT_ELSE
-#endif
-#ifdef VEG_DEBUG_EXPECT_ELSE
-#undef VEG_DEBUG_EXPECT_ELSE
-#endif
-#ifdef VEG_DEBUG_ASSERT_ALL_OF
-#undef VEG_DEBUG_ASSERT_ALL_OF
-#endif
-#ifdef VEG_DEBUG_EXPECT_ALL_OF
-#undef VEG_DEBUG_EXPECT_ALL_OF
-#endif
-#ifdef VEG_DEBUG_ASSERT_ALL_OF_ELSE
-#undef VEG_DEBUG_ASSERT_ALL_OF_ELSE
-#endif
-#ifdef VEG_DEBUG_EXPECT_ALL_OF_ELSE
-#undef VEG_DEBUG_EXPECT_ALL_OF_ELSE
-#endif
-
-#ifdef NDEBUG
-#define VEG_DEBUG_ASSERT(...) ((void)(0))
-#define VEG_DEBUG_EXPECT(...) ((void)(0))
-#define VEG_DEBUG_ASSERT_ELSE(Message, ...) ((void)(0))
-#define VEG_DEBUG_EXPECT_ELSE(Message, ...) ((void)(0))
-#define VEG_DEBUG_ASSERT_ALL_OF(...) ((void)(0))
-#define VEG_DEBUG_EXPECT_ALL_OF(...) ((void)(0))
-#define VEG_DEBUG_ASSERT_ALL_OF_ELSE(...) ((void)(0))
-#define VEG_DEBUG_EXPECT_ALL_OF_ELSE(...) ((void)(0))
-#else
-#define VEG_DEBUG_ASSERT(...) VEG_ASSERT(__VA_ARGS__)
-#define VEG_DEBUG_EXPECT(...) VEG_EXPECT(__VA_ARGS__)
-#define VEG_DEBUG_ASSERT_ELSE(Message, ...)                                    \
-  VEG_ASSERT_ELSE(Message, __VA_ARGS__)
-#define VEG_DEBUG_EXPECT_ELSE(Message, ...)                                    \
-  VEG_EXPECT_ELSE(Message, __VA_ARGS__)
-#define VEG_DEBUG_ASSERT_ALL_OF(...) VEG_ASSERT_ALL_OF(__VA_ARGS__)
-#define VEG_DEBUG_EXPECT_ALL_OF(...) VEG_EXPECT_ALL_OF(__VA_ARGS__)
-#define VEG_DEBUG_ASSERT_ALL_OF_ELSE(...) VEG_ASSERT_ALL_OF_ELSE(__VA_ARGS__)
-#define VEG_DEBUG_EXPECT_ALL_OF_ELSE(...) VEG_EXPECT_ALL_OF_ELSE(__VA_ARGS__)
-#endif
+#include "proxsuite/linalg/veg/internal/assert_impl.hpp"
+
+#ifdef VEG_DEBUG_ASSERT
+#undef VEG_DEBUG_ASSERT
+#endif
+#ifdef VEG_DEBUG_EXPECT
+#undef VEG_DEBUG_EXPECT
+#endif
+#ifdef VEG_DEBUG_ASSERT_ELSE
+#undef VEG_DEBUG_ASSERT_ELSE
+#endif
+#ifdef VEG_DEBUG_EXPECT_ELSE
+#undef VEG_DEBUG_EXPECT_ELSE
+#endif
+#ifdef VEG_DEBUG_ASSERT_ALL_OF
+#undef VEG_DEBUG_ASSERT_ALL_OF
+#endif
+#ifdef VEG_DEBUG_EXPECT_ALL_OF
+#undef VEG_DEBUG_EXPECT_ALL_OF
+#endif
+#ifdef VEG_DEBUG_ASSERT_ALL_OF_ELSE
+#undef VEG_DEBUG_ASSERT_ALL_OF_ELSE
+#endif
+#ifdef VEG_DEBUG_EXPECT_ALL_OF_ELSE
+#undef VEG_DEBUG_EXPECT_ALL_OF_ELSE
+#endif
+
+#ifdef NDEBUG
+#define VEG_DEBUG_ASSERT(...) ((void)(0))
+#define VEG_DEBUG_EXPECT(...) ((void)(0))
+#define VEG_DEBUG_ASSERT_ELSE(Message, ...) ((void)(0))
+#define VEG_DEBUG_EXPECT_ELSE(Message, ...) ((void)(0))
+#define VEG_DEBUG_ASSERT_ALL_OF(...) ((void)(0))
+#define VEG_DEBUG_EXPECT_ALL_OF(...) ((void)(0))
+#define VEG_DEBUG_ASSERT_ALL_OF_ELSE(...) ((void)(0))
+#define VEG_DEBUG_EXPECT_ALL_OF_ELSE(...) ((void)(0))
+#else
+#define VEG_DEBUG_ASSERT(...) VEG_ASSERT(__VA_ARGS__)
+#define VEG_DEBUG_EXPECT(...) VEG_EXPECT(__VA_ARGS__)
+#define VEG_DEBUG_ASSERT_ELSE(Message, ...)                                    \
+  VEG_ASSERT_ELSE(Message, __VA_ARGS__)
+#define VEG_DEBUG_EXPECT_ELSE(Message, ...)                                    \
+  VEG_EXPECT_ELSE(Message, __VA_ARGS__)
+#define VEG_DEBUG_ASSERT_ALL_OF(...) VEG_ASSERT_ALL_OF(__VA_ARGS__)
+#define VEG_DEBUG_EXPECT_ALL_OF(...) VEG_EXPECT_ALL_OF(__VA_ARGS__)
+#define VEG_DEBUG_ASSERT_ALL_OF_ELSE(...) VEG_ASSERT_ALL_OF_ELSE(__VA_ARGS__)
+#define VEG_DEBUG_EXPECT_ALL_OF_ELSE(...) VEG_EXPECT_ALL_OF_ELSE(__VA_ARGS__)
+#endif
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/dbg.hpp

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-#ifndef VEG_DBG_HPP_Z7QC9XCHS
-#define VEG_DBG_HPP_Z7QC9XCHS
-
-#include "proxsuite/linalg/veg/internal/dbg.hpp"
-
-#endif /* end of include guard VEG_DBG_HPP_Z7QC9XCHS */
+#ifndef VEG_DBG_HPP_Z7QC9XCHS
+#define VEG_DBG_HPP_Z7QC9XCHS
+
+#include "proxsuite/linalg/veg/internal/dbg.hpp"
+
+#endif /* end of include guard VEG_DBG_HPP_Z7QC9XCHS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/defer.hpp

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-#ifndef VEG_DEFER_HPP_SQPONLRGS
-#define VEG_DEFER_HPP_SQPONLRGS
-
-#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
-#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-template<typename Fn>
-struct VEG_NODISCARD Defer
-{
-  Fn fn;
-  constexpr Defer(Fn _fn) VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<Fn>))
-    : fn(VEG_FWD(_fn))
-  {
-  }
-  Defer(Defer const&) = delete;
-  Defer(Defer&&) VEG_NOEXCEPT = delete;
-  auto operator=(Defer const&) -> Defer& = delete;
-  auto operator=(Defer&&) VEG_NOEXCEPT->Defer& = delete;
-  VEG_CPP20(constexpr)
-  VEG_INLINE ~Defer()
-    VEG_NOEXCEPT_IF(VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, void>)))
-  {
-    VEG_FWD(fn)();
-  }
-};
-VEG_CPP17(
-
-  template<typename Fn> Defer(Fn) -> Defer<Fn>;
-
-)
-
-namespace nb {
-struct defer
-{
-  VEG_TEMPLATE(typename Fn,
-               requires(VEG_CONCEPT(fn_once<Fn, void>)),
-               VEG_INLINE VEG_CPP20(constexpr) auto
-               operator(),
-               (fn, Fn&&))
-  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<Fn>))
-    ->proxsuite::linalg::veg::Defer<Fn>
-  {
-    return { VEG_FWD(fn) };
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(defer);
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_DEFER_HPP_SQPONLRGS */
+#ifndef VEG_DEFER_HPP_SQPONLRGS
+#define VEG_DEFER_HPP_SQPONLRGS
+
+#include "proxsuite/linalg/veg/type_traits/constructible.hpp"
+#include "proxsuite/linalg/veg/type_traits/invocable.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+template<typename Fn>
+struct VEG_NODISCARD Defer
+{
+  Fn fn;
+  constexpr Defer(Fn _fn) VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<Fn>))
+    : fn(VEG_FWD(_fn))
+  {
+  }
+  Defer(Defer const&) = delete;
+  Defer(Defer&&) VEG_NOEXCEPT = delete;
+  auto operator=(Defer const&) -> Defer& = delete;
+  auto operator=(Defer&&) VEG_NOEXCEPT->Defer& = delete;
+  VEG_CPP20(constexpr)
+  VEG_INLINE ~Defer()
+    VEG_NOEXCEPT_IF(VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_fn_once<Fn, void>)))
+  {
+    VEG_FWD(fn)();
+  }
+};
+VEG_CPP17(
+
+  template<typename Fn> Defer(Fn) -> Defer<Fn>;
+
+)
+
+namespace nb {
+struct defer
+{
+  VEG_TEMPLATE(typename Fn,
+               requires(VEG_CONCEPT(fn_once<Fn, void>)),
+               VEG_INLINE VEG_CPP20(constexpr) auto
+               operator(),
+               (fn, Fn&&))
+  const VEG_NOEXCEPT_IF(VEG_CONCEPT(nothrow_movable<Fn>))
+    ->proxsuite::linalg::veg::Defer<Fn>
+  {
+    return { VEG_FWD(fn) };
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(defer);
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_DEFER_HPP_SQPONLRGS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/dynstack_alloc.hpp

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-#ifndef VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS
-#define VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS
-
-#include "proxsuite/linalg/veg/vec.hpp"
-#include "proxsuite/linalg/veg/memory/dynamic_stack.hpp"
-
-#define __VEG_IMPL_MAKE_STACK(vec, stack, ...)                                 \
-  VEG_NOM_SEMICOLON;                                                           \
-  ::proxsuite::linalg::veg::Vec<unsigned char> vec;                            \
-  vec.resize_for_overwrite((__VA_ARGS__).alloc_req());                         \
-  ::proxsuite::linalg::veg::dynstack::DynStackMut stack{                       \
-    ::proxsuite::linalg::veg::tags::from_slice_mut, vec.as_mut()               \
-  };                                                                           \
-  VEG_NOM_SEMICOLON
-
-#define VEG_MAKE_STACK(stack, ...)                                             \
-  __VEG_IMPL_MAKE_STACK(VEG_ID(stack_storage), stack, __VA_ARGS__)
-
-#endif /* end of include guard VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS */
+#ifndef VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS
+#define VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS
+
+#include "proxsuite/linalg/veg/vec.hpp"
+#include "proxsuite/linalg/veg/memory/dynamic_stack.hpp"
+
+#define __VEG_IMPL_MAKE_STACK(vec, stack, ...)                                 \
+  VEG_NOM_SEMICOLON;                                                           \
+  ::proxsuite::linalg::veg::Vec<unsigned char> vec;                            \
+  vec.resize_for_overwrite((__VA_ARGS__).alloc_req());                         \
+  ::proxsuite::linalg::veg::dynstack::DynStackMut stack{                       \
+    ::proxsuite::linalg::veg::tags::from_slice_mut, vec.as_mut()               \
+  };                                                                           \
+  VEG_NOM_SEMICOLON
+
+#define VEG_MAKE_STACK(stack, ...)                                             \
+  __VEG_IMPL_MAKE_STACK(VEG_ID(stack_storage), stack, __VA_ARGS__)
+
+#endif /* end of include guard VEG_DYNSTACK_ALLOC_HPP_YYWN4MATS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/get.hpp

```diff
@@ -1,153 +1,153 @@
-#ifndef VEG_GET_HPP_QRS8GNSHS
-#define VEG_GET_HPP_QRS8GNSHS
-
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace meta {
-template<typename T>
-struct is_bounded_array : false_type
-{};
-template<typename T, usize N>
-struct is_bounded_array<T[N]> : true_type
-{};
-
-template<typename T>
-struct array_extent : constant<usize, 0>
-{};
-template<usize N, typename T>
-struct array_extent<T[N]> : constant<usize, N>
-{};
-} // namespace meta
-
-namespace _detail {
-namespace _meta {
-
-template<typename T>
-void
-get() = delete;
-
-struct array_get
-{
-  template<typename I, typename T>
-  using result_type = decltype(VEG_DECLVAL(T &&)[I::value]);
-
-  template<usize I, typename T>
-  VEG_INLINE static constexpr auto apply(T&& arr)
-    VEG_NOEXCEPT->decltype(VEG_FWD(arr)[I])
-  {
-    return VEG_FWD(arr)[I];
-  }
-};
-
-struct member_get
-{
-  template<typename I, typename T>
-  using result_type = decltype(VEG_DECLVAL(T &&).template get<I::value>());
-  template<usize I, typename T>
-  VEG_INLINE static constexpr auto apply(T&& arg)
-    VEG_DEDUCE_RET(VEG_FWD(arg).template get<I>());
-};
-struct adl_get
-{
-  template<typename I, typename T>
-  using result_type = decltype(get<I::value>(VEG_DECLVAL(T &&)));
-
-  template<usize I, typename T>
-  VEG_INLINE static constexpr auto apply(T&& arg)
-    VEG_DEDUCE_RET(get<I>(VEG_FWD(arg)));
-};
-
-struct none_found : true_type
-{
-  template<typename I, typename T>
-  using result_type = void;
-};
-
-template<typename I, typename T>
-using member_get_expr = decltype(VEG_DECLVAL(T &&).template get<I::value>());
-template<typename I, typename T>
-using adl_get_expr = decltype(get<I::value>(VEG_DECLVAL(T &&)));
-
-template<usize I, typename T>
-struct has_array_get
-  : meta::bool_constant<meta::is_bounded_array<meta::uncvref_t<T>>::value>
-  , array_get
-{};
-
-template<usize I, typename T>
-struct has_member_get
-  : bool_constant<VEG_CONCEPT(
-      detected<member_get::result_type, constant<usize, I>, T&&>)>
-  , member_get
-{};
-template<usize I, typename T>
-struct has_adl_get
-  : bool_constant<VEG_CONCEPT(
-      detected<adl_get::result_type, constant<usize, I>, T&&>)>
-  , adl_get
-{};
-
-} // namespace _meta
-} // namespace _detail
-
-namespace concepts {
-namespace aux {
-VEG_DEF_CONCEPT((usize I, usize N), less_than, (I < N));
-VEG_DEF_CONCEPT(typename T, bounded_array, meta::is_bounded_array<T>::value);
-} // namespace aux
-VEG_DEF_CONCEPT_CONJUNCTION(
-  (usize I, typename T),
-  array_gettable,
-  ((aux::, bounded_array<uncvref_t<T>>),
-   (aux::, less_than<I, meta::array_extent<uncvref_t<T>>::value>)));
-VEG_DEF_CONCEPT(
-  (usize I, typename T),
-  member_gettable,
-  VEG_CONCEPT(
-    detected<_detail::_meta::member_get_expr, meta::constant<usize, I>, T>));
-VEG_DEF_CONCEPT(
-  (usize I, typename T),
-  adl_gettable,
-  VEG_CONCEPT(
-    detected<_detail::_meta::adl_get_expr, meta::constant<usize, I>, T>));
-
-VEG_DEF_CONCEPT_DISJUNCTION((usize I, typename T),
-                            gettable,
-                            ((, array_gettable<I, T>),
-                             (, member_gettable<I, T>),
-                             (, adl_gettable<I, T>)));
-} // namespace concepts
-
-namespace nb {
-template<usize I>
-struct get
-{
-  VEG_TEMPLATE(
-    (typename T,
-     typename Impl = meta::disjunction<_detail::_meta::has_array_get<I, T>,
-                                       _detail::_meta::has_member_get<I, T>,
-                                       _detail::_meta::has_adl_get<I, T>,
-                                       _detail::_meta::none_found>),
-    requires(VEG_CONCEPT(gettable<I, T>)),
-    VEG_INLINE constexpr auto
-    operator(),
-    (arg, T&&))
-  const VEG_NOEXCEPT_IF(VEG_IS_NOEXCEPT(Impl::template apply<I>(VEG_FWD(arg))))
-    ->meta::detected_t<Impl::template result_type, meta::constant<usize, I>, T>
-  {
-    return Impl::template apply<I>(VEG_FWD(arg));
-  }
-};
-} // namespace nb
-
-VEG_NIEBLOID_TEMPLATE(usize I, get, I);
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_GET_HPP_QRS8GNSHS */
+#ifndef VEG_GET_HPP_QRS8GNSHS
+#define VEG_GET_HPP_QRS8GNSHS
+
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace meta {
+template<typename T>
+struct is_bounded_array : false_type
+{};
+template<typename T, usize N>
+struct is_bounded_array<T[N]> : true_type
+{};
+
+template<typename T>
+struct array_extent : constant<usize, 0>
+{};
+template<usize N, typename T>
+struct array_extent<T[N]> : constant<usize, N>
+{};
+} // namespace meta
+
+namespace _detail {
+namespace _meta {
+
+template<typename T>
+void
+get() = delete;
+
+struct array_get
+{
+  template<typename I, typename T>
+  using result_type = decltype(VEG_DECLVAL(T&&)[I::value]);
+
+  template<usize I, typename T>
+  VEG_INLINE static constexpr auto apply(T&& arr)
+    VEG_NOEXCEPT->decltype(VEG_FWD(arr)[I])
+  {
+    return VEG_FWD(arr)[I];
+  }
+};
+
+struct member_get
+{
+  template<typename I, typename T>
+  using result_type = decltype(VEG_DECLVAL(T&&).template get<I::value>());
+  template<usize I, typename T>
+  VEG_INLINE static constexpr auto apply(T&& arg)
+    VEG_DEDUCE_RET(VEG_FWD(arg).template get<I>());
+};
+struct adl_get
+{
+  template<typename I, typename T>
+  using result_type = decltype(get<I::value>(VEG_DECLVAL(T&&)));
+
+  template<usize I, typename T>
+  VEG_INLINE static constexpr auto apply(T&& arg)
+    VEG_DEDUCE_RET(get<I>(VEG_FWD(arg)));
+};
+
+struct none_found : true_type
+{
+  template<typename I, typename T>
+  using result_type = void;
+};
+
+template<typename I, typename T>
+using member_get_expr = decltype(VEG_DECLVAL(T&&).template get<I::value>());
+template<typename I, typename T>
+using adl_get_expr = decltype(get<I::value>(VEG_DECLVAL(T&&)));
+
+template<usize I, typename T>
+struct has_array_get
+  : meta::bool_constant<meta::is_bounded_array<meta::uncvref_t<T>>::value>
+  , array_get
+{};
+
+template<usize I, typename T>
+struct has_member_get
+  : bool_constant<VEG_CONCEPT(
+      detected<member_get::result_type, constant<usize, I>, T&&>)>
+  , member_get
+{};
+template<usize I, typename T>
+struct has_adl_get
+  : bool_constant<VEG_CONCEPT(
+      detected<adl_get::result_type, constant<usize, I>, T&&>)>
+  , adl_get
+{};
+
+} // namespace _meta
+} // namespace _detail
+
+namespace concepts {
+namespace aux {
+VEG_DEF_CONCEPT((usize I, usize N), less_than, (I < N));
+VEG_DEF_CONCEPT(typename T, bounded_array, meta::is_bounded_array<T>::value);
+} // namespace aux
+VEG_DEF_CONCEPT_CONJUNCTION(
+  (usize I, typename T),
+  array_gettable,
+  ((aux::, bounded_array<uncvref_t<T>>),
+   (aux::, less_than<I, meta::array_extent<uncvref_t<T>>::value>)));
+VEG_DEF_CONCEPT(
+  (usize I, typename T),
+  member_gettable,
+  VEG_CONCEPT(
+    detected<_detail::_meta::member_get_expr, meta::constant<usize, I>, T>));
+VEG_DEF_CONCEPT(
+  (usize I, typename T),
+  adl_gettable,
+  VEG_CONCEPT(
+    detected<_detail::_meta::adl_get_expr, meta::constant<usize, I>, T>));
+
+VEG_DEF_CONCEPT_DISJUNCTION((usize I, typename T),
+                            gettable,
+                            ((, array_gettable<I, T>),
+                             (, member_gettable<I, T>),
+                             (, adl_gettable<I, T>)));
+} // namespace concepts
+
+namespace nb {
+template<usize I>
+struct get
+{
+  VEG_TEMPLATE(
+    (typename T,
+     typename Impl = meta::disjunction<_detail::_meta::has_array_get<I, T>,
+                                       _detail::_meta::has_member_get<I, T>,
+                                       _detail::_meta::has_adl_get<I, T>,
+                                       _detail::_meta::none_found>),
+    requires(VEG_CONCEPT(gettable<I, T>)),
+    VEG_INLINE constexpr auto
+    operator(),
+    (arg, T&&))
+  const VEG_NOEXCEPT_IF(VEG_IS_NOEXCEPT(Impl::template apply<I>(VEG_FWD(arg))))
+    ->meta::detected_t<Impl::template result_type, meta::constant<usize, I>, T>
+  {
+    return Impl::template apply<I>(VEG_FWD(arg));
+  }
+};
+} // namespace nb
+
+VEG_NIEBLOID_TEMPLATE(usize I, get, I);
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_GET_HPP_QRS8GNSHS */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/index.hpp

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-#ifndef VEG_INDEX_HPP_UX3WGF18S
-#define VEG_INDEX_HPP_UX3WGF18S
-
-#include "proxsuite/linalg/veg/internal/dyn_index.hpp"
-
-#endif /* end of include guard VEG_INDEX_HPP_UX3WGF18S */
+#ifndef VEG_INDEX_HPP_UX3WGF18S
+#define VEG_INDEX_HPP_UX3WGF18S
+
+#include "proxsuite/linalg/veg/internal/dyn_index.hpp"
+
+#endif /* end of include guard VEG_INDEX_HPP_UX3WGF18S */
```

## cmeel.prefix/include/proxsuite/linalg/veg/util/unreachable.hpp

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-#ifndef VEG_UNREACHABLE_HPP_JNCM31VSS
-#define VEG_UNREACHABLE_HPP_JNCM31VSS
-
-#include "proxsuite/linalg/veg/internal/macros.hpp"
-#include "proxsuite/linalg/veg/internal/terminate.hpp"
-#include "proxsuite/linalg/veg/internal/prologue.hpp"
-
-namespace proxsuite {
-namespace linalg {
-namespace veg {
-namespace meta {
-namespace nb {
-struct unreachable
-{
-  [[noreturn]] VEG_INLINE void operator()() const VEG_NOEXCEPT
-  {
-#ifdef NDEBUG
-    HEDLEY_UNREACHABLE();
-#else
-    _detail::terminate();
-#endif
-  }
-};
-
-struct unreachable_if
-{
-  VEG_INLINE constexpr auto operator()(bool Cond) const VEG_NOEXCEPT->bool
-  {
-    return (Cond ? unreachable{}() : (void)0), Cond;
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(unreachable);
-VEG_NIEBLOID(unreachable_if);
-} // namespace meta
-} // namespace veg
-} // namespace linalg
-} // namespace proxsuite
-
-#include "proxsuite/linalg/veg/internal/epilogue.hpp"
-#endif /* end of include guard VEG_UNREACHABLE_HPP_JNCM31VSS */
+#ifndef VEG_UNREACHABLE_HPP_JNCM31VSS
+#define VEG_UNREACHABLE_HPP_JNCM31VSS
+
+#include "proxsuite/linalg/veg/internal/macros.hpp"
+#include "proxsuite/linalg/veg/internal/terminate.hpp"
+#include "proxsuite/linalg/veg/internal/prologue.hpp"
+
+namespace proxsuite {
+namespace linalg {
+namespace veg {
+namespace meta {
+namespace nb {
+struct unreachable
+{
+  [[noreturn]] VEG_INLINE void operator()() const VEG_NOEXCEPT
+  {
+#ifdef NDEBUG
+    HEDLEY_UNREACHABLE();
+#else
+    _detail::terminate();
+#endif
+  }
+};
+
+struct unreachable_if
+{
+  VEG_INLINE constexpr auto operator()(bool Cond) const VEG_NOEXCEPT->bool
+  {
+    return (Cond ? unreachable{}() : (void)0), Cond;
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(unreachable);
+VEG_NIEBLOID(unreachable_if);
+} // namespace meta
+} // namespace veg
+} // namespace linalg
+} // namespace proxsuite
+
+#include "proxsuite/linalg/veg/internal/epilogue.hpp"
+#endif /* end of include guard VEG_UNREACHABLE_HPP_JNCM31VSS */
```

## cmeel.prefix/include/proxsuite/proxqp/results.hpp

 * *Ordering differences only*

```diff
@@ -1,212 +1,212 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file results.hpp
- */
-#ifndef PROXSUITE_PROXQP_RESULTS_HPP
-#define PROXSUITE_PROXQP_RESULTS_HPP
-
-#include <proxsuite/helpers/optional.hpp>
-#include <Eigen/Core>
-#include <proxsuite/linalg/veg/type_traits/core.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include "proxsuite/proxqp/status.hpp"
-#include "proxsuite/proxqp/sparse/fwd.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-///
-/// @brief This class stores the results statistics of PROXQP solvers with
-/// sparse and dense backends.
-///
-/*!
- * Info class of dense and sparse solver.
- */
-template<typename T>
-struct Info
-{
-  ///// final proximal regularization parameters
-  T mu_eq;
-  T mu_eq_inv;
-  T mu_in;
-  T mu_in_inv;
-  T rho;
-  T nu;
-
-  ///// iteration count
-  sparse::isize iter;
-  sparse::isize iter_ext;
-  sparse::isize mu_updates;
-  sparse::isize rho_updates;
-  QPSolverOutput status;
-
-  //// timings
-  T setup_time;
-  T solve_time;
-  T run_time;
-  T objValue;
-  T pri_res;
-  T dua_res;
-  T duality_gap;
-  //// sparse backend used by solver, either CholeskySparse or MatrixFree
-  SparseBackend sparse_backend;
-};
-///
-/// @brief This class stores all the results of PROXQP solvers with sparse and
-/// dense backends.
-///
-/*!
- * Results class of dense and sparse solver.
- */
-template<typename T>
-struct Results
-{
-
-  ///// SOLUTION STORAGE
-
-  sparse::Vec<T> x;
-  sparse::Vec<T> y;
-  sparse::Vec<T> z;
-
-  Info<T> info;
-
-  ////// SOLUTION STATUS
-  /*!
-   * Default constructor.
-   * @param dim dimension of the primal variable.
-   * @param n_eq dimension of the number of equality constraints.
-   * @param n_in dimension of the number of inequality constraints.
-   */
-  Results(isize dim = 0, isize n_eq = 0, isize n_in = 0)
-    : x(dim)
-    , y(n_eq)
-    , z(n_in)
-  {
-
-    x.setZero();
-    y.setZero();
-    z.setZero();
-
-    info.rho = 1e-6;
-    info.mu_eq_inv = 1e3;
-    info.mu_eq = 1e-3;
-    info.mu_in_inv = 1e1;
-    info.mu_in = 1e-1;
-    info.nu = 1.;
-    info.iter = 0;
-    info.iter_ext = 0;
-    info.mu_updates = 0;
-    info.rho_updates = 0;
-    info.run_time = 0;
-    info.setup_time = 0;
-    info.solve_time = 0;
-    info.objValue = 0.;
-    info.pri_res = 0.;
-    info.dua_res = 0.;
-    info.duality_gap = 0.;
-    info.status = QPSolverOutput::PROXQP_NOT_RUN;
-    info.sparse_backend = SparseBackend::Automatic;
-  }
-  /*!
-   * cleanups the Result variables and set the info variables to their initial
-   * values.
-   */
-  void cleanup(optional<Settings<T>> settings = nullopt)
-  {
-    x.setZero();
-    y.setZero();
-    z.setZero();
-    cold_start(settings);
-  }
-  void cleanup_statistics()
-  {
-    info.run_time = 0;
-    info.setup_time = 0;
-    info.solve_time = 0;
-    info.objValue = 0.;
-    info.iter = 0;
-    info.iter_ext = 0;
-    info.mu_updates = 0;
-    info.rho_updates = 0;
-    info.pri_res = 0.;
-    info.dua_res = 0.;
-    info.duality_gap = 0.;
-    info.status = QPSolverOutput::PROXQP_MAX_ITER_REACHED;
-    info.sparse_backend = SparseBackend::Automatic;
-  }
-  void cold_start(optional<Settings<T>> settings = nullopt)
-  {
-    info.rho = 1e-6;
-    info.mu_eq_inv = 1e3;
-    info.mu_eq = 1e-3;
-    info.mu_in_inv = 1e1;
-    info.mu_in = 1e-1;
-    info.nu = 1.;
-    if (settings != nullopt) {
-      info.rho = settings.value().default_rho;
-      info.mu_eq = settings.value().default_mu_eq;
-      info.mu_eq_inv = T(1) / info.mu_eq;
-      info.mu_in = settings.value().default_mu_in;
-      info.mu_in_inv = T(1) / info.mu_in;
-    }
-    cleanup_statistics();
-  }
-  void cleanup_all_except_prox_parameters()
-  {
-    x.setZero();
-    y.setZero();
-    z.setZero();
-    cleanup_statistics();
-  }
-};
-
-template<typename T>
-bool
-operator==(const Info<T>& info1, const Info<T>& info2)
-{
-  bool value =
-    info1.mu_eq == info2.mu_eq && info1.mu_eq_inv == info2.mu_eq_inv &&
-    info1.mu_in == info2.mu_in && info1.mu_in_inv == info2.mu_in_inv &&
-    info1.rho == info2.rho && info1.nu == info2.nu &&
-    info1.iter == info2.iter && info1.iter_ext == info2.iter_ext &&
-    info1.mu_updates == info2.mu_updates &&
-    info1.rho_updates == info2.rho_updates && info1.status == info2.status &&
-    info1.setup_time == info2.setup_time &&
-    info1.solve_time == info2.solve_time && info1.run_time == info2.run_time &&
-    info1.objValue == info2.objValue && info1.pri_res == info2.pri_res &&
-    info1.dua_res == info2.dua_res && info1.duality_gap == info2.duality_gap &&
-    info1.duality_gap == info2.duality_gap;
-  return value;
-}
-
-template<typename T>
-bool
-operator!=(const Info<T>& info1, const Info<T>& info2)
-{
-  return !(info1 == info2);
-}
-
-template<typename T>
-bool
-operator==(const Results<T>& results1, const Results<T>& results2)
-{
-  bool value = results1.x == results2.x && results1.y == results2.y &&
-               //  results1.z == results2.z && results1.active_constraints ==
-               //  results2.active_constraints &&
-               results1.z == results2.z && results1.info == results2.info;
-  return value;
-}
-
-template<typename T>
-bool
-operator!=(const Results<T>& results1, const Results<T>& results2)
-{
-  return !(results1 == results2);
-}
-
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_RESULTS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file results.hpp
+ */
+#ifndef PROXSUITE_PROXQP_RESULTS_HPP
+#define PROXSUITE_PROXQP_RESULTS_HPP
+
+#include <proxsuite/helpers/optional.hpp>
+#include <Eigen/Core>
+#include <proxsuite/linalg/veg/type_traits/core.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include "proxsuite/proxqp/status.hpp"
+#include "proxsuite/proxqp/sparse/fwd.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+///
+/// @brief This class stores the results statistics of PROXQP solvers with
+/// sparse and dense backends.
+///
+/*!
+ * Info class of dense and sparse solver.
+ */
+template<typename T>
+struct Info
+{
+  ///// final proximal regularization parameters
+  T mu_eq;
+  T mu_eq_inv;
+  T mu_in;
+  T mu_in_inv;
+  T rho;
+  T nu;
+
+  ///// iteration count
+  sparse::isize iter;
+  sparse::isize iter_ext;
+  sparse::isize mu_updates;
+  sparse::isize rho_updates;
+  QPSolverOutput status;
+
+  //// timings
+  T setup_time;
+  T solve_time;
+  T run_time;
+  T objValue;
+  T pri_res;
+  T dua_res;
+  T duality_gap;
+  //// sparse backend used by solver, either CholeskySparse or MatrixFree
+  SparseBackend sparse_backend;
+};
+///
+/// @brief This class stores all the results of PROXQP solvers with sparse and
+/// dense backends.
+///
+/*!
+ * Results class of dense and sparse solver.
+ */
+template<typename T>
+struct Results
+{
+
+  ///// SOLUTION STORAGE
+
+  sparse::Vec<T> x;
+  sparse::Vec<T> y;
+  sparse::Vec<T> z;
+
+  Info<T> info;
+
+  ////// SOLUTION STATUS
+  /*!
+   * Default constructor.
+   * @param dim dimension of the primal variable.
+   * @param n_eq dimension of the number of equality constraints.
+   * @param n_in dimension of the number of inequality constraints.
+   */
+  Results(isize dim = 0, isize n_eq = 0, isize n_in = 0)
+    : x(dim)
+    , y(n_eq)
+    , z(n_in)
+  {
+
+    x.setZero();
+    y.setZero();
+    z.setZero();
+
+    info.rho = 1e-6;
+    info.mu_eq_inv = 1e3;
+    info.mu_eq = 1e-3;
+    info.mu_in_inv = 1e1;
+    info.mu_in = 1e-1;
+    info.nu = 1.;
+    info.iter = 0;
+    info.iter_ext = 0;
+    info.mu_updates = 0;
+    info.rho_updates = 0;
+    info.run_time = 0;
+    info.setup_time = 0;
+    info.solve_time = 0;
+    info.objValue = 0.;
+    info.pri_res = 0.;
+    info.dua_res = 0.;
+    info.duality_gap = 0.;
+    info.status = QPSolverOutput::PROXQP_NOT_RUN;
+    info.sparse_backend = SparseBackend::Automatic;
+  }
+  /*!
+   * cleanups the Result variables and set the info variables to their initial
+   * values.
+   */
+  void cleanup(optional<Settings<T>> settings = nullopt)
+  {
+    x.setZero();
+    y.setZero();
+    z.setZero();
+    cold_start(settings);
+  }
+  void cleanup_statistics()
+  {
+    info.run_time = 0;
+    info.setup_time = 0;
+    info.solve_time = 0;
+    info.objValue = 0.;
+    info.iter = 0;
+    info.iter_ext = 0;
+    info.mu_updates = 0;
+    info.rho_updates = 0;
+    info.pri_res = 0.;
+    info.dua_res = 0.;
+    info.duality_gap = 0.;
+    info.status = QPSolverOutput::PROXQP_MAX_ITER_REACHED;
+    info.sparse_backend = SparseBackend::Automatic;
+  }
+  void cold_start(optional<Settings<T>> settings = nullopt)
+  {
+    info.rho = 1e-6;
+    info.mu_eq_inv = 1e3;
+    info.mu_eq = 1e-3;
+    info.mu_in_inv = 1e1;
+    info.mu_in = 1e-1;
+    info.nu = 1.;
+    if (settings != nullopt) {
+      info.rho = settings.value().default_rho;
+      info.mu_eq = settings.value().default_mu_eq;
+      info.mu_eq_inv = T(1) / info.mu_eq;
+      info.mu_in = settings.value().default_mu_in;
+      info.mu_in_inv = T(1) / info.mu_in;
+    }
+    cleanup_statistics();
+  }
+  void cleanup_all_except_prox_parameters()
+  {
+    x.setZero();
+    y.setZero();
+    z.setZero();
+    cleanup_statistics();
+  }
+};
+
+template<typename T>
+bool
+operator==(const Info<T>& info1, const Info<T>& info2)
+{
+  bool value =
+    info1.mu_eq == info2.mu_eq && info1.mu_eq_inv == info2.mu_eq_inv &&
+    info1.mu_in == info2.mu_in && info1.mu_in_inv == info2.mu_in_inv &&
+    info1.rho == info2.rho && info1.nu == info2.nu &&
+    info1.iter == info2.iter && info1.iter_ext == info2.iter_ext &&
+    info1.mu_updates == info2.mu_updates &&
+    info1.rho_updates == info2.rho_updates && info1.status == info2.status &&
+    info1.setup_time == info2.setup_time &&
+    info1.solve_time == info2.solve_time && info1.run_time == info2.run_time &&
+    info1.objValue == info2.objValue && info1.pri_res == info2.pri_res &&
+    info1.dua_res == info2.dua_res && info1.duality_gap == info2.duality_gap &&
+    info1.duality_gap == info2.duality_gap;
+  return value;
+}
+
+template<typename T>
+bool
+operator!=(const Info<T>& info1, const Info<T>& info2)
+{
+  return !(info1 == info2);
+}
+
+template<typename T>
+bool
+operator==(const Results<T>& results1, const Results<T>& results2)
+{
+  bool value = results1.x == results2.x && results1.y == results2.y &&
+               //  results1.z == results2.z && results1.active_constraints ==
+               //  results2.active_constraints &&
+               results1.z == results2.z && results1.info == results2.info;
+  return value;
+}
+
+template<typename T>
+bool
+operator!=(const Results<T>& results1, const Results<T>& results2)
+{
+  return !(results1 == results2);
+}
+
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_RESULTS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/settings.hpp

 * *Ordering differences only*

```diff
@@ -1,302 +1,302 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file settings.hpp
- */
-#ifndef PROXSUITE_PROXQP_SETTINGS_HPP
-#define PROXSUITE_PROXQP_SETTINGS_HPP
-
-#include <Eigen/Core>
-#include <proxsuite/proxqp/status.hpp>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/proxqp/sparse/fwd.hpp>
-
-namespace proxsuite {
-namespace proxqp {
-
-// Sparse backend specifications
-enum struct SparseBackend
-{
-  Automatic,      // the solver will select the appropriate sparse backend.
-  SparseCholesky, // sparse cholesky backend.
-  MatrixFree,     // iterative matrix free sparse backend.
-};
-
-inline std::ostream&
-operator<<(std::ostream& os, const SparseBackend& sparse_backend)
-{
-  if (sparse_backend == SparseBackend::Automatic)
-    os << "Automatic";
-  else if (sparse_backend == SparseBackend::SparseCholesky) {
-    os << "SparseCholesky";
-  } else {
-    os << "MatrixFree";
-  }
-  return os;
-}
-
-///
-/// @brief This class defines the settings of PROXQP solvers with sparse and
-/// dense backends.
-///
-/*!
- * Settings class, which defines the parameters used by the dense and sparse
- * solver (and its preconditioner).
- */
-template<typename T>
-struct Settings
-{
-
-  T default_rho;
-  T default_mu_eq;
-  T default_mu_in;
-
-  T alpha_bcl;
-  T beta_bcl;
-
-  T refactor_dual_feasibility_threshold;
-  T refactor_rho_threshold;
-
-  T mu_min_eq;
-  T mu_min_in;
-  T mu_max_eq_inv;
-  T mu_max_in_inv;
-
-  T mu_update_factor;
-  T mu_update_inv_factor;
-
-  T cold_reset_mu_eq;
-  T cold_reset_mu_in;
-  T cold_reset_mu_eq_inv;
-  T cold_reset_mu_in_inv;
-  T eps_abs;
-  T eps_rel;
-
-  isize max_iter;
-  isize max_iter_in;
-  isize safe_guard;
-  isize nb_iterative_refinement;
-  T eps_refact;
-
-  bool verbose;
-  InitialGuessStatus initial_guess;
-  bool update_preconditioner;
-  bool compute_preconditioner;
-  bool compute_timings;
-
-  bool check_duality_gap;
-  T eps_duality_gap_abs;
-  T eps_duality_gap_rel;
-
-  isize preconditioner_max_iter;
-  T preconditioner_accuracy;
-  T eps_primal_inf;
-  T eps_dual_inf;
-  bool bcl_update;
-
-  SparseBackend sparse_backend;
-  /*!
-   * Default constructor.
-   * @param default_rho default rho parameter of result class
-   * @param default_mu_eq default mu_eq parameter of result class
-   * @param default_mu_in default mu_in parameter of result class
-   * @param alpha_bcl alpha parameter of the BCL algorithm.
-   * @param beta_bcl beta parameter of the BCL algorithm.
-   * @param refactor_dual_feasibility_threshold threshold above which
-   * refactorization is performed to change rho parameter.
-   * @param refactor_rho_threshold new rho parameter used if the
-   * refactor_dual_feasibility_threshold_ condition has been satisfied.
-   * @param mu_min_eq minimal authorized value for mu_eq.
-   * @param mu_min_in minimal authorized value for mu_in.
-   * @param mu_max_eq_inv maximal authorized value for the inverse of
-   * mu_eq_inv.
-   * @param mu_max_in_inv maximal authorized value for the inverse of
-   * mu_in_inv.
-   * @param mu_update_factor update factor used for updating mu_eq and mu_in.
-   * @param mu_update_inv_factor update factor used for updating mu_eq_inv and
-   * mu_in_inv.
-   * @param cold_reset_mu_eq value used for cold restarting mu_eq.
-   * @param cold_reset_mu_in value used for cold restarting mu_in.
-   * @param cold_reset_mu_eq_inv value used for cold restarting mu_eq_inv.
-   * @param cold_reset_mu_in_inv value used for cold restarting mu_in_inv.
-   * @param eps_abs asbolute stopping criterion of the solver.
-   * @param eps_rel relative stopping criterion of the solver.
-   * @param max_iter maximal number of authorized iteration.
-   * @param max_iter_in maximal number of authorized iterations for an inner
-   * loop.
-   * @param nb_iterative_refinement number of iterative refinements.
-   * @param eps_refact threshold value for refactorizing the ldlt factorization
-   * in the iterative refinement loop.
-   * @param safe_guard safeguard parameter ensuring global convergence of ProxQP
-   * scheme.
-   * @param VERBOSE if set to true, the solver prints information at each loop.
-   * @param initial_guess sets the initial guess option for initilizing x, y
-   * and z.
-   * @param update_preconditioner If set to true, the preconditioner will be
-   * re-derived with the update method.
-   * @param compute_preconditioner If set to true, the preconditioner will be
-   * derived with the init method.
-   * @param compute_timings If set to true, timings will be computed by the
-   * solver (setup time, solving time, and run time = setup time + solving
-   * time).
-   * @param check_duality_gap If set to true, duality gap will be calculated and
-   * included in the stopping criterion.
-   * @param eps_duality_gap_abs absolute duality-gap stopping criterion.
-   * @param eps_duality_gap_rel relative duality-gap stopping criterion.
-   * @param preconditioner_max_iter maximal number of authorized iterations for
-   * the preconditioner.
-   * @param preconditioner_accuracy accuracy level of the preconditioner.
-   * @param eps_primal_inf threshold under which primal infeasibility is
-   * detected.
-   * @param eps_dual_inf threshold under which dual infeasibility is detected.
-   * @param bcl_update if set to true, BCL strategy is used for calibrating
-   * mu_eq and mu_in. If set to false, a strategy developped by Martinez & al is
-   * used.
-   * @param sparse_backend Default automatic. User can choose between sparse
-   * cholesky or iterative matrix free sparse backend.
-   */
-
-  Settings(
-    T default_rho = 1.E-6,
-    T default_mu_eq = 1.E-3,
-    T default_mu_in = 1.E-1,
-    T alpha_bcl = 0.1,
-    T beta_bcl = 0.9,
-    T refactor_dual_feasibility_threshold = 1e-2,
-    T refactor_rho_threshold = 1e-7,
-    T mu_min_eq = 1e-9,
-    T mu_min_in = 1e-8,
-    T mu_max_eq_inv = 1e9,
-    T mu_max_in_inv = 1e8,
-    T mu_update_factor = 0.1,
-    T mu_update_inv_factor = 10,
-    T cold_reset_mu_eq = 1. / 1.1,
-    T cold_reset_mu_in = 1. / 1.1,
-    T cold_reset_mu_eq_inv = 1.1,
-    T cold_reset_mu_in_inv = 1.1,
-    T eps_abs = 1.e-5,
-    T eps_rel = 0,
-    isize max_iter = 10000,
-    isize max_iter_in = 1500,
-    isize safe_guard = 1.E4,
-    isize nb_iterative_refinement = 10,
-    T eps_refact = 1.e-6, // before eps_refact_=1.e-6
-    bool verbose = false,
-    InitialGuessStatus initial_guess = InitialGuessStatus::
-      EQUALITY_CONSTRAINED_INITIAL_GUESS, // default to
-                                          // EQUALITY_CONSTRAINED_INITIAL_GUESS,
-                                          // as most often we run only
-                                          // once a problem
-    bool update_preconditioner = true,
-    bool compute_preconditioner = true,
-    bool compute_timings = false,
-    bool check_duality_gap = false,
-    T eps_duality_gap_abs = 1.e-4,
-    T eps_duality_gap_rel = 0,
-    isize preconditioner_max_iter = 10,
-    T preconditioner_accuracy = 1.e-3,
-    T eps_primal_inf = 1.E-4,
-    T eps_dual_inf = 1.E-4,
-    bool bcl_update = true,
-    SparseBackend sparse_backend = SparseBackend::Automatic)
-    : default_rho(default_rho)
-    , default_mu_eq(default_mu_eq)
-    , default_mu_in(default_mu_in)
-    , alpha_bcl(alpha_bcl)
-    , beta_bcl(beta_bcl)
-    , refactor_dual_feasibility_threshold(refactor_dual_feasibility_threshold)
-    , refactor_rho_threshold(refactor_rho_threshold)
-    , mu_min_eq(mu_min_eq)
-    , mu_min_in(mu_min_in)
-    , mu_max_eq_inv(mu_max_eq_inv)
-    , mu_max_in_inv(mu_max_in_inv)
-    , mu_update_factor(mu_update_factor)
-    , mu_update_inv_factor(mu_update_inv_factor)
-    , cold_reset_mu_eq(cold_reset_mu_eq)
-    , cold_reset_mu_in(cold_reset_mu_in)
-    , cold_reset_mu_eq_inv(cold_reset_mu_eq_inv)
-    , cold_reset_mu_in_inv(cold_reset_mu_in_inv)
-    , eps_abs(eps_abs)
-    , eps_rel(eps_rel)
-    , max_iter(max_iter)
-    , max_iter_in(max_iter_in)
-    , safe_guard(safe_guard)
-    , nb_iterative_refinement(nb_iterative_refinement)
-    , eps_refact(eps_refact)
-    , verbose(verbose)
-    , initial_guess(initial_guess)
-    , update_preconditioner(update_preconditioner)
-    , compute_preconditioner(compute_preconditioner)
-    , compute_timings(compute_timings)
-    , check_duality_gap(check_duality_gap)
-    , eps_duality_gap_abs(eps_duality_gap_abs)
-    , eps_duality_gap_rel(eps_duality_gap_rel)
-    , preconditioner_max_iter(preconditioner_max_iter)
-    , preconditioner_accuracy(preconditioner_accuracy)
-    , eps_primal_inf(eps_primal_inf)
-    , eps_dual_inf(eps_dual_inf)
-    , bcl_update(bcl_update)
-    , sparse_backend(sparse_backend)
-  {
-  }
-};
-
-template<typename T>
-bool
-operator==(const Settings<T>& settings1, const Settings<T>& settings2)
-{
-  bool value =
-    settings1.default_rho == settings2.default_rho &&
-    settings1.default_mu_eq == settings2.default_mu_eq &&
-    settings1.default_mu_in == settings2.default_mu_in &&
-    settings1.alpha_bcl == settings2.alpha_bcl &&
-    settings1.alpha_bcl == settings2.alpha_bcl &&
-    settings1.refactor_dual_feasibility_threshold ==
-      settings2.refactor_dual_feasibility_threshold &&
-    settings1.refactor_rho_threshold == settings2.refactor_rho_threshold &&
-    settings1.mu_min_eq == settings2.mu_min_eq &&
-    settings1.mu_min_in == settings2.mu_min_in &&
-    settings1.mu_max_eq_inv == settings2.mu_max_eq_inv &&
-    settings1.mu_max_in_inv == settings2.mu_max_in_inv &&
-    settings1.mu_update_factor == settings2.mu_update_factor &&
-    settings1.mu_update_factor == settings2.mu_update_factor &&
-    settings1.cold_reset_mu_eq == settings2.cold_reset_mu_eq &&
-    settings1.cold_reset_mu_in == settings2.cold_reset_mu_in &&
-    settings1.cold_reset_mu_eq_inv == settings2.cold_reset_mu_eq_inv &&
-    settings1.cold_reset_mu_in_inv == settings2.cold_reset_mu_in_inv &&
-    settings1.eps_abs == settings2.eps_abs &&
-    settings1.eps_rel == settings2.eps_rel &&
-    settings1.max_iter == settings2.max_iter &&
-    settings1.max_iter_in == settings2.max_iter_in &&
-    settings1.safe_guard == settings2.safe_guard &&
-    settings1.nb_iterative_refinement == settings2.nb_iterative_refinement &&
-    settings1.eps_refact == settings2.eps_refact &&
-    settings1.verbose == settings2.verbose &&
-    settings1.initial_guess == settings2.initial_guess &&
-    settings1.update_preconditioner == settings2.update_preconditioner &&
-    settings1.compute_preconditioner == settings2.compute_preconditioner &&
-    settings1.compute_timings == settings2.compute_timings &&
-    settings1.check_duality_gap == settings2.check_duality_gap &&
-    settings1.eps_duality_gap_abs == settings2.eps_duality_gap_abs &&
-    settings1.eps_duality_gap_rel == settings2.eps_duality_gap_rel &&
-    settings1.preconditioner_max_iter == settings2.preconditioner_max_iter &&
-    settings1.preconditioner_accuracy == settings2.preconditioner_accuracy &&
-    settings1.eps_primal_inf == settings2.eps_primal_inf &&
-    settings1.eps_dual_inf == settings2.eps_dual_inf &&
-    settings1.bcl_update == settings2.bcl_update &&
-    settings1.sparse_backend == settings2.sparse_backend;
-  return value;
-}
-
-template<typename T>
-bool
-operator!=(const Settings<T>& settings1, const Settings<T>& settings2)
-{
-  return !(settings1 == settings2);
-}
-
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SETTINGS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file settings.hpp
+ */
+#ifndef PROXSUITE_PROXQP_SETTINGS_HPP
+#define PROXSUITE_PROXQP_SETTINGS_HPP
+
+#include <Eigen/Core>
+#include <proxsuite/proxqp/status.hpp>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/proxqp/sparse/fwd.hpp>
+
+namespace proxsuite {
+namespace proxqp {
+
+// Sparse backend specifications
+enum struct SparseBackend
+{
+  Automatic,      // the solver will select the appropriate sparse backend.
+  SparseCholesky, // sparse cholesky backend.
+  MatrixFree,     // iterative matrix free sparse backend.
+};
+
+inline std::ostream&
+operator<<(std::ostream& os, const SparseBackend& sparse_backend)
+{
+  if (sparse_backend == SparseBackend::Automatic)
+    os << "Automatic";
+  else if (sparse_backend == SparseBackend::SparseCholesky) {
+    os << "SparseCholesky";
+  } else {
+    os << "MatrixFree";
+  }
+  return os;
+}
+
+///
+/// @brief This class defines the settings of PROXQP solvers with sparse and
+/// dense backends.
+///
+/*!
+ * Settings class, which defines the parameters used by the dense and sparse
+ * solver (and its preconditioner).
+ */
+template<typename T>
+struct Settings
+{
+
+  T default_rho;
+  T default_mu_eq;
+  T default_mu_in;
+
+  T alpha_bcl;
+  T beta_bcl;
+
+  T refactor_dual_feasibility_threshold;
+  T refactor_rho_threshold;
+
+  T mu_min_eq;
+  T mu_min_in;
+  T mu_max_eq_inv;
+  T mu_max_in_inv;
+
+  T mu_update_factor;
+  T mu_update_inv_factor;
+
+  T cold_reset_mu_eq;
+  T cold_reset_mu_in;
+  T cold_reset_mu_eq_inv;
+  T cold_reset_mu_in_inv;
+  T eps_abs;
+  T eps_rel;
+
+  isize max_iter;
+  isize max_iter_in;
+  isize safe_guard;
+  isize nb_iterative_refinement;
+  T eps_refact;
+
+  bool verbose;
+  InitialGuessStatus initial_guess;
+  bool update_preconditioner;
+  bool compute_preconditioner;
+  bool compute_timings;
+
+  bool check_duality_gap;
+  T eps_duality_gap_abs;
+  T eps_duality_gap_rel;
+
+  isize preconditioner_max_iter;
+  T preconditioner_accuracy;
+  T eps_primal_inf;
+  T eps_dual_inf;
+  bool bcl_update;
+
+  SparseBackend sparse_backend;
+  /*!
+   * Default constructor.
+   * @param default_rho default rho parameter of result class
+   * @param default_mu_eq default mu_eq parameter of result class
+   * @param default_mu_in default mu_in parameter of result class
+   * @param alpha_bcl alpha parameter of the BCL algorithm.
+   * @param beta_bcl beta parameter of the BCL algorithm.
+   * @param refactor_dual_feasibility_threshold threshold above which
+   * refactorization is performed to change rho parameter.
+   * @param refactor_rho_threshold new rho parameter used if the
+   * refactor_dual_feasibility_threshold_ condition has been satisfied.
+   * @param mu_min_eq minimal authorized value for mu_eq.
+   * @param mu_min_in minimal authorized value for mu_in.
+   * @param mu_max_eq_inv maximal authorized value for the inverse of
+   * mu_eq_inv.
+   * @param mu_max_in_inv maximal authorized value for the inverse of
+   * mu_in_inv.
+   * @param mu_update_factor update factor used for updating mu_eq and mu_in.
+   * @param mu_update_inv_factor update factor used for updating mu_eq_inv and
+   * mu_in_inv.
+   * @param cold_reset_mu_eq value used for cold restarting mu_eq.
+   * @param cold_reset_mu_in value used for cold restarting mu_in.
+   * @param cold_reset_mu_eq_inv value used for cold restarting mu_eq_inv.
+   * @param cold_reset_mu_in_inv value used for cold restarting mu_in_inv.
+   * @param eps_abs asbolute stopping criterion of the solver.
+   * @param eps_rel relative stopping criterion of the solver.
+   * @param max_iter maximal number of authorized iteration.
+   * @param max_iter_in maximal number of authorized iterations for an inner
+   * loop.
+   * @param nb_iterative_refinement number of iterative refinements.
+   * @param eps_refact threshold value for refactorizing the ldlt factorization
+   * in the iterative refinement loop.
+   * @param safe_guard safeguard parameter ensuring global convergence of ProxQP
+   * scheme.
+   * @param VERBOSE if set to true, the solver prints information at each loop.
+   * @param initial_guess sets the initial guess option for initilizing x, y
+   * and z.
+   * @param update_preconditioner If set to true, the preconditioner will be
+   * re-derived with the update method.
+   * @param compute_preconditioner If set to true, the preconditioner will be
+   * derived with the init method.
+   * @param compute_timings If set to true, timings will be computed by the
+   * solver (setup time, solving time, and run time = setup time + solving
+   * time).
+   * @param check_duality_gap If set to true, duality gap will be calculated and
+   * included in the stopping criterion.
+   * @param eps_duality_gap_abs absolute duality-gap stopping criterion.
+   * @param eps_duality_gap_rel relative duality-gap stopping criterion.
+   * @param preconditioner_max_iter maximal number of authorized iterations for
+   * the preconditioner.
+   * @param preconditioner_accuracy accuracy level of the preconditioner.
+   * @param eps_primal_inf threshold under which primal infeasibility is
+   * detected.
+   * @param eps_dual_inf threshold under which dual infeasibility is detected.
+   * @param bcl_update if set to true, BCL strategy is used for calibrating
+   * mu_eq and mu_in. If set to false, a strategy developped by Martinez & al is
+   * used.
+   * @param sparse_backend Default automatic. User can choose between sparse
+   * cholesky or iterative matrix free sparse backend.
+   */
+
+  Settings(
+    T default_rho = 1.E-6,
+    T default_mu_eq = 1.E-3,
+    T default_mu_in = 1.E-1,
+    T alpha_bcl = 0.1,
+    T beta_bcl = 0.9,
+    T refactor_dual_feasibility_threshold = 1e-2,
+    T refactor_rho_threshold = 1e-7,
+    T mu_min_eq = 1e-9,
+    T mu_min_in = 1e-8,
+    T mu_max_eq_inv = 1e9,
+    T mu_max_in_inv = 1e8,
+    T mu_update_factor = 0.1,
+    T mu_update_inv_factor = 10,
+    T cold_reset_mu_eq = 1. / 1.1,
+    T cold_reset_mu_in = 1. / 1.1,
+    T cold_reset_mu_eq_inv = 1.1,
+    T cold_reset_mu_in_inv = 1.1,
+    T eps_abs = 1.e-5,
+    T eps_rel = 0,
+    isize max_iter = 10000,
+    isize max_iter_in = 1500,
+    isize safe_guard = 1.E4,
+    isize nb_iterative_refinement = 10,
+    T eps_refact = 1.e-6, // before eps_refact_=1.e-6
+    bool verbose = false,
+    InitialGuessStatus initial_guess = InitialGuessStatus::
+      EQUALITY_CONSTRAINED_INITIAL_GUESS, // default to
+                                          // EQUALITY_CONSTRAINED_INITIAL_GUESS,
+                                          // as most often we run only
+                                          // once a problem
+    bool update_preconditioner = true,
+    bool compute_preconditioner = true,
+    bool compute_timings = false,
+    bool check_duality_gap = false,
+    T eps_duality_gap_abs = 1.e-4,
+    T eps_duality_gap_rel = 0,
+    isize preconditioner_max_iter = 10,
+    T preconditioner_accuracy = 1.e-3,
+    T eps_primal_inf = 1.E-4,
+    T eps_dual_inf = 1.E-4,
+    bool bcl_update = true,
+    SparseBackend sparse_backend = SparseBackend::Automatic)
+    : default_rho(default_rho)
+    , default_mu_eq(default_mu_eq)
+    , default_mu_in(default_mu_in)
+    , alpha_bcl(alpha_bcl)
+    , beta_bcl(beta_bcl)
+    , refactor_dual_feasibility_threshold(refactor_dual_feasibility_threshold)
+    , refactor_rho_threshold(refactor_rho_threshold)
+    , mu_min_eq(mu_min_eq)
+    , mu_min_in(mu_min_in)
+    , mu_max_eq_inv(mu_max_eq_inv)
+    , mu_max_in_inv(mu_max_in_inv)
+    , mu_update_factor(mu_update_factor)
+    , mu_update_inv_factor(mu_update_inv_factor)
+    , cold_reset_mu_eq(cold_reset_mu_eq)
+    , cold_reset_mu_in(cold_reset_mu_in)
+    , cold_reset_mu_eq_inv(cold_reset_mu_eq_inv)
+    , cold_reset_mu_in_inv(cold_reset_mu_in_inv)
+    , eps_abs(eps_abs)
+    , eps_rel(eps_rel)
+    , max_iter(max_iter)
+    , max_iter_in(max_iter_in)
+    , safe_guard(safe_guard)
+    , nb_iterative_refinement(nb_iterative_refinement)
+    , eps_refact(eps_refact)
+    , verbose(verbose)
+    , initial_guess(initial_guess)
+    , update_preconditioner(update_preconditioner)
+    , compute_preconditioner(compute_preconditioner)
+    , compute_timings(compute_timings)
+    , check_duality_gap(check_duality_gap)
+    , eps_duality_gap_abs(eps_duality_gap_abs)
+    , eps_duality_gap_rel(eps_duality_gap_rel)
+    , preconditioner_max_iter(preconditioner_max_iter)
+    , preconditioner_accuracy(preconditioner_accuracy)
+    , eps_primal_inf(eps_primal_inf)
+    , eps_dual_inf(eps_dual_inf)
+    , bcl_update(bcl_update)
+    , sparse_backend(sparse_backend)
+  {
+  }
+};
+
+template<typename T>
+bool
+operator==(const Settings<T>& settings1, const Settings<T>& settings2)
+{
+  bool value =
+    settings1.default_rho == settings2.default_rho &&
+    settings1.default_mu_eq == settings2.default_mu_eq &&
+    settings1.default_mu_in == settings2.default_mu_in &&
+    settings1.alpha_bcl == settings2.alpha_bcl &&
+    settings1.alpha_bcl == settings2.alpha_bcl &&
+    settings1.refactor_dual_feasibility_threshold ==
+      settings2.refactor_dual_feasibility_threshold &&
+    settings1.refactor_rho_threshold == settings2.refactor_rho_threshold &&
+    settings1.mu_min_eq == settings2.mu_min_eq &&
+    settings1.mu_min_in == settings2.mu_min_in &&
+    settings1.mu_max_eq_inv == settings2.mu_max_eq_inv &&
+    settings1.mu_max_in_inv == settings2.mu_max_in_inv &&
+    settings1.mu_update_factor == settings2.mu_update_factor &&
+    settings1.mu_update_factor == settings2.mu_update_factor &&
+    settings1.cold_reset_mu_eq == settings2.cold_reset_mu_eq &&
+    settings1.cold_reset_mu_in == settings2.cold_reset_mu_in &&
+    settings1.cold_reset_mu_eq_inv == settings2.cold_reset_mu_eq_inv &&
+    settings1.cold_reset_mu_in_inv == settings2.cold_reset_mu_in_inv &&
+    settings1.eps_abs == settings2.eps_abs &&
+    settings1.eps_rel == settings2.eps_rel &&
+    settings1.max_iter == settings2.max_iter &&
+    settings1.max_iter_in == settings2.max_iter_in &&
+    settings1.safe_guard == settings2.safe_guard &&
+    settings1.nb_iterative_refinement == settings2.nb_iterative_refinement &&
+    settings1.eps_refact == settings2.eps_refact &&
+    settings1.verbose == settings2.verbose &&
+    settings1.initial_guess == settings2.initial_guess &&
+    settings1.update_preconditioner == settings2.update_preconditioner &&
+    settings1.compute_preconditioner == settings2.compute_preconditioner &&
+    settings1.compute_timings == settings2.compute_timings &&
+    settings1.check_duality_gap == settings2.check_duality_gap &&
+    settings1.eps_duality_gap_abs == settings2.eps_duality_gap_abs &&
+    settings1.eps_duality_gap_rel == settings2.eps_duality_gap_rel &&
+    settings1.preconditioner_max_iter == settings2.preconditioner_max_iter &&
+    settings1.preconditioner_accuracy == settings2.preconditioner_accuracy &&
+    settings1.eps_primal_inf == settings2.eps_primal_inf &&
+    settings1.eps_dual_inf == settings2.eps_dual_inf &&
+    settings1.bcl_update == settings2.bcl_update &&
+    settings1.sparse_backend == settings2.sparse_backend;
+  return value;
+}
+
+template<typename T>
+bool
+operator!=(const Settings<T>& settings1, const Settings<T>& settings2)
+{
+  return !(settings1 == settings2);
+}
+
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SETTINGS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/status.hpp

 * *Ordering differences only*

```diff
@@ -1,46 +1,46 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file constants.hpp
- */
-#ifndef PROXSUITE_PROXQP_CONSTANTS_HPP
-#define PROXSUITE_PROXQP_CONSTANTS_HPP
-
-#include <proxsuite/linalg/veg/type_traits/core.hpp>
-#include "proxsuite/proxqp/sparse/fwd.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-
-// SOLVER STATUS
-enum struct QPSolverOutput
-{
-  PROXQP_SOLVED,           // the problem is solved.
-  PROXQP_MAX_ITER_REACHED, // the maximum number of iterations has been reached.
-  PROXQP_PRIMAL_INFEASIBLE, // the problem is primal infeasible.
-  PROXQP_DUAL_INFEASIBLE,   // the problem is dual infeasible.
-  PROXQP_NOT_RUN            // the solver has not been run yet.
-};
-// INITIAL GUESS STATUS
-enum struct InitialGuessStatus
-{
-  NO_INITIAL_GUESS,
-  EQUALITY_CONSTRAINED_INITIAL_GUESS,
-  WARM_START_WITH_PREVIOUS_RESULT,
-  WARM_START,
-  COLD_START_WITH_PREVIOUS_RESULT
-};
-// PRECONDITIONER STATUS
-enum struct PreconditionerStatus
-{
-  EXECUTE, // initialize or update with qp in entry
-  KEEP,    // keep previous preconditioner (for update method)
-  IDENTITY // do not execute, hence use identity preconditioner (for init
-           // method)
-};
-
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_CONSTANTS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file constants.hpp
+ */
+#ifndef PROXSUITE_PROXQP_CONSTANTS_HPP
+#define PROXSUITE_PROXQP_CONSTANTS_HPP
+
+#include <proxsuite/linalg/veg/type_traits/core.hpp>
+#include "proxsuite/proxqp/sparse/fwd.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+
+// SOLVER STATUS
+enum struct QPSolverOutput
+{
+  PROXQP_SOLVED,           // the problem is solved.
+  PROXQP_MAX_ITER_REACHED, // the maximum number of iterations has been reached.
+  PROXQP_PRIMAL_INFEASIBLE, // the problem is primal infeasible.
+  PROXQP_DUAL_INFEASIBLE,   // the problem is dual infeasible.
+  PROXQP_NOT_RUN            // the solver has not been run yet.
+};
+// INITIAL GUESS STATUS
+enum struct InitialGuessStatus
+{
+  NO_INITIAL_GUESS,
+  EQUALITY_CONSTRAINED_INITIAL_GUESS,
+  WARM_START_WITH_PREVIOUS_RESULT,
+  WARM_START,
+  COLD_START_WITH_PREVIOUS_RESULT
+};
+// PRECONDITIONER STATUS
+enum struct PreconditionerStatus
+{
+  EXECUTE, // initialize or update with qp in entry
+  KEEP,    // keep previous preconditioner (for update method)
+  IDENTITY // do not execute, hence use identity preconditioner (for init
+           // method)
+};
+
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_CONSTANTS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/timings.hpp

 * *Ordering differences only*

```diff
@@ -1,101 +1,101 @@
-//
-// Copyright (c) 2022 INRIA
-//
-
-#ifndef PROXSUITE_PROXQP_TIMINGS_HPP
-#define PROXSUITE_PROXQP_TIMINGS_HPP
-
-#include <chrono>
-
-namespace proxsuite {
-namespace proxqp {
-
-struct CPUTimes
-{
-  double wall;
-  double user;
-  double system;
-
-  CPUTimes()
-    : wall(0)
-    , user(0)
-    , system(0)
-  {
-  }
-
-  void clear() { wall = user = system = 0; }
-};
-
-///
-/// @brief This class mimics the way "boost/timer/timer.hpp" operates while
-/// using the modern std::chrono library.
-/// Importantly, this class will only have an effect for C++11 and more.
-///
-template<typename T>
-struct Timer
-{
-  Timer()
-    : m_is_stopped(true)
-  {
-    start();
-  }
-
-  CPUTimes elapsed() const
-  {
-    if (m_is_stopped)
-      return m_times;
-
-    CPUTimes current(m_times);
-    std::chrono::time_point<std::chrono::steady_clock> current_clock =
-      std::chrono::steady_clock::now();
-    current.user +=
-      static_cast<T>(std::chrono::duration_cast<std::chrono::nanoseconds>(
-                       current_clock - m_start)
-                       .count()) *
-      1e-3;
-
-    return current;
-  }
-
-  void start()
-  {
-    if (m_is_stopped) {
-      m_is_stopped = false;
-      m_times.clear();
-      m_start = std::chrono::steady_clock::now();
-    }
-  }
-
-  void stop()
-  {
-    if (m_is_stopped)
-      return;
-    m_is_stopped = true;
-
-    m_end = std::chrono::steady_clock::now();
-    m_times.user +=
-      static_cast<double>(
-        std::chrono::duration_cast<std::chrono::nanoseconds>(m_end - m_start)
-          .count()) *
-      1e-3;
-  }
-
-  void resume()
-  {
-    if (m_is_stopped)
-      m_start = std::chrono::steady_clock::now();
-  }
-
-  bool is_stopped() const { return m_is_stopped; }
-
-protected:
-  CPUTimes m_times;
-  bool m_is_stopped;
-
-  std::chrono::time_point<std::chrono::steady_clock> m_start, m_end;
-};
-
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif // ifndef PROXSUITE_PROXQP_TIMINGS_HPP
+//
+// Copyright (c) 2022 INRIA
+//
+
+#ifndef PROXSUITE_PROXQP_TIMINGS_HPP
+#define PROXSUITE_PROXQP_TIMINGS_HPP
+
+#include <chrono>
+
+namespace proxsuite {
+namespace proxqp {
+
+struct CPUTimes
+{
+  double wall;
+  double user;
+  double system;
+
+  CPUTimes()
+    : wall(0)
+    , user(0)
+    , system(0)
+  {
+  }
+
+  void clear() { wall = user = system = 0; }
+};
+
+///
+/// @brief This class mimics the way "boost/timer/timer.hpp" operates while
+/// using the modern std::chrono library.
+/// Importantly, this class will only have an effect for C++11 and more.
+///
+template<typename T>
+struct Timer
+{
+  Timer()
+    : m_is_stopped(true)
+  {
+    start();
+  }
+
+  CPUTimes elapsed() const
+  {
+    if (m_is_stopped)
+      return m_times;
+
+    CPUTimes current(m_times);
+    std::chrono::time_point<std::chrono::steady_clock> current_clock =
+      std::chrono::steady_clock::now();
+    current.user +=
+      static_cast<T>(std::chrono::duration_cast<std::chrono::nanoseconds>(
+                       current_clock - m_start)
+                       .count()) *
+      1e-3;
+
+    return current;
+  }
+
+  void start()
+  {
+    if (m_is_stopped) {
+      m_is_stopped = false;
+      m_times.clear();
+      m_start = std::chrono::steady_clock::now();
+    }
+  }
+
+  void stop()
+  {
+    if (m_is_stopped)
+      return;
+    m_is_stopped = true;
+
+    m_end = std::chrono::steady_clock::now();
+    m_times.user +=
+      static_cast<double>(
+        std::chrono::duration_cast<std::chrono::nanoseconds>(m_end - m_start)
+          .count()) *
+      1e-3;
+  }
+
+  void resume()
+  {
+    if (m_is_stopped)
+      m_start = std::chrono::steady_clock::now();
+  }
+
+  bool is_stopped() const { return m_is_stopped; }
+
+protected:
+  CPUTimes m_times;
+  bool m_is_stopped;
+
+  std::chrono::time_point<std::chrono::steady_clock> m_start, m_end;
+};
+
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif // ifndef PROXSUITE_PROXQP_TIMINGS_HPP
```

## cmeel.prefix/include/proxsuite/proxqp/dense/dense.hpp

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_DENSE_DENSE_HPP
-#define PROXSUITE_PROXQP_DENSE_DENSE_HPP
-
-#include "proxsuite/proxqp/dense/wrapper.hpp" // includes everything
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_DENSE_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_DENSE_DENSE_HPP
+#define PROXSUITE_PROXQP_DENSE_DENSE_HPP
+
+#include "proxsuite/proxqp/dense/wrapper.hpp" // includes everything
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_DENSE_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/fwd.hpp

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_DENSE_FWD_HPP
-#define PROXSUITE_PROXQP_DENSE_FWD_HPP
-
-#include <Eigen/Sparse>
-#include "proxsuite/helpers/common.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-
-static constexpr auto DYN = Eigen::Dynamic;
-enum
-{
-  layout = Eigen::RowMajor
-};
-template<typename T>
-using SparseMat = Eigen::SparseMatrix<T, 1>;
-
-template<typename T>
-using Vec = Eigen::Matrix<T, DYN, 1>;
-template<typename T>
-using VecRef = Eigen::Ref<Vec<T> const>;
-
-template<typename T, int l = layout>
-using Mat = Eigen::Matrix<T, DYN, DYN, l>;
-template<typename T, int l = layout>
-using MatRef = Eigen::Ref<Mat<T, l> const>;
-
-using proxsuite::linalg::veg::isize;
-
-template<typename T>
-using VecMap = Eigen::Map<Vec<T> const>;
-template<typename T>
-using VecMapMut = Eigen::Map<Vec<T>>;
-
-template<typename T, int l = layout>
-using MatMap = Eigen::Map<Mat<T, l> const>;
-template<typename T, int l = layout>
-using MatMapMut = Eigen::Map<Mat<T, l>>;
-
-using VecMapISize = Eigen::Map<Eigen::Matrix<isize, DYN, 1> const>;
-using VecISize = Eigen::Matrix<isize, DYN, 1>;
-
-using VecMapBool = Eigen::Map<Eigen::Matrix<bool, DYN, 1> const>;
-using VecBool = Eigen::Matrix<bool, DYN, 1>;
-
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_FWD_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_DENSE_FWD_HPP
+#define PROXSUITE_PROXQP_DENSE_FWD_HPP
+
+#include <Eigen/Sparse>
+#include "proxsuite/helpers/common.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+
+static constexpr auto DYN = Eigen::Dynamic;
+enum
+{
+  layout = Eigen::RowMajor
+};
+template<typename T>
+using SparseMat = Eigen::SparseMatrix<T, 1>;
+
+template<typename T>
+using Vec = Eigen::Matrix<T, DYN, 1>;
+template<typename T>
+using VecRef = Eigen::Ref<Vec<T> const>;
+
+template<typename T, int l = layout>
+using Mat = Eigen::Matrix<T, DYN, DYN, l>;
+template<typename T, int l = layout>
+using MatRef = Eigen::Ref<Mat<T, l> const>;
+
+using proxsuite::linalg::veg::isize;
+
+template<typename T>
+using VecMap = Eigen::Map<Vec<T> const>;
+template<typename T>
+using VecMapMut = Eigen::Map<Vec<T>>;
+
+template<typename T, int l = layout>
+using MatMap = Eigen::Map<Mat<T, l> const>;
+template<typename T, int l = layout>
+using MatMapMut = Eigen::Map<Mat<T, l>>;
+
+using VecMapISize = Eigen::Map<Eigen::Matrix<isize, DYN, 1> const>;
+using VecISize = Eigen::Matrix<isize, DYN, 1>;
+
+using VecMapBool = Eigen::Map<Eigen::Matrix<bool, DYN, 1> const>;
+using VecBool = Eigen::Matrix<bool, DYN, 1>;
+
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_FWD_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/helpers.hpp

 * *Ordering differences only*

```diff
@@ -1,520 +1,520 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file helpers.hpp
- */
-
-#ifndef PROXSUITE_PROXQP_DENSE_HELPERS_HPP
-#define PROXSUITE_PROXQP_DENSE_HELPERS_HPP
-
-#include <proxsuite/proxqp/results.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/proxqp/status.hpp>
-#include <proxsuite/proxqp/dense/fwd.hpp>
-#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
-#include <chrono>
-#include <proxsuite/helpers/optional.hpp>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-
-/////// SETUP ////////
-/*!
- * Computes the equality constrained initial guess of a QP problem.
- *
- * @param qpwork workspace of the solver.
- * @param qpsettings settings of the solver.
- * @param qpmodel QP problem as defined by the user (without any scaling
- * performed).
- * @param qpresults solution results.
- */
-template<typename T>
-void
-compute_equality_constrained_initial_guess(Workspace<T>& qpwork,
-                                           const Settings<T>& qpsettings,
-                                           const Model<T>& qpmodel,
-                                           Results<T>& qpresults)
-{
-
-  qpwork.rhs.setZero();
-  qpwork.rhs.head(qpmodel.dim) = -qpwork.g_scaled;
-  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) = qpwork.b_scaled;
-  iterative_solve_with_permut_fact( //
-    qpsettings,
-    qpmodel,
-    qpresults,
-    qpwork,
-    T(1),
-    qpmodel.dim + qpmodel.n_eq);
-
-  qpresults.x = qpwork.dw_aug.head(qpmodel.dim);
-  qpresults.y = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
-  qpwork.dw_aug.setZero();
-  qpwork.rhs.setZero();
-}
-
-/*!
- * Setups and performs the first factorization of the regularized KKT matrix of
- * the problem.
- *
- * @param qpwork workspace of the solver.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solution results.
- */
-template<typename T>
-void
-setup_factorization(Workspace<T>& qpwork,
-                    const Model<T>& qpmodel,
-                    Results<T>& qpresults)
-{
-
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut,
-    qpwork.ldl_stack.as_mut(),
-  };
-
-  qpwork.kkt.topLeftCorner(qpmodel.dim, qpmodel.dim) = qpwork.H_scaled;
-  qpwork.kkt.topLeftCorner(qpmodel.dim, qpmodel.dim).diagonal().array() +=
-    qpresults.info.rho;
-  qpwork.kkt.block(0, qpmodel.dim, qpmodel.dim, qpmodel.n_eq) =
-    qpwork.A_scaled.transpose();
-  qpwork.kkt.block(qpmodel.dim, 0, qpmodel.n_eq, qpmodel.dim) = qpwork.A_scaled;
-  qpwork.kkt.bottomRightCorner(qpmodel.n_eq, qpmodel.n_eq).setZero();
-  qpwork.kkt.diagonal()
-    .segment(qpmodel.dim, qpmodel.n_eq)
-    .setConstant(-qpresults.info.mu_eq);
-
-  qpwork.ldl.factorize(qpwork.kkt.transpose(), stack);
-}
-/*!
- * Performs the equilibration of the QP problem for reducing its
- * ill-conditionness.
- *
- * @param qpwork workspace of the solver.
- * @param qpsettings settings of the solver.
- * @param ruiz ruiz preconditioner.
- * @param execute_preconditioner boolean variable for executing or not the ruiz
- * preconditioner. If set to False, it uses the previous preconditioning
- * variables (initialized to the identity preconditioner if it is the first
- * scaling performed).
- */
-template<typename T>
-void
-setup_equilibration(Workspace<T>& qpwork,
-                    const Settings<T>& qpsettings,
-                    preconditioner::RuizEquilibration<T>& ruiz,
-                    bool execute_preconditioner)
-{
-
-  QpViewBoxMut<T> qp_scaled{
-    { from_eigen, qpwork.H_scaled }, { from_eigen, qpwork.g_scaled },
-    { from_eigen, qpwork.A_scaled }, { from_eigen, qpwork.b_scaled },
-    { from_eigen, qpwork.C_scaled }, { from_eigen, qpwork.u_scaled },
-    { from_eigen, qpwork.l_scaled }
-  };
-
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut,
-    qpwork.ldl_stack.as_mut(),
-  };
-  ruiz.scale_qp_in_place(qp_scaled,
-                         execute_preconditioner,
-                         qpsettings.preconditioner_max_iter,
-                         qpsettings.preconditioner_accuracy,
-                         stack);
-  qpwork.correction_guess_rhs_g = infty_norm(qpwork.g_scaled);
-}
-
-/*!
- * Setups the solver initial guess.
- *
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- */
-template<typename T>
-void
-initial_guess(Workspace<T>& qpwork,
-              Settings<T>& qpsettings,
-              Model<T>& qpmodel,
-              Results<T>& qpresults)
-{
-
-  switch (qpsettings.initial_guess) {
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-      compute_equality_constrained_initial_guess(
-        qpwork, qpsettings, qpmodel, qpresults);
-      break;
-    }
-  }
-}
-/*!
- * Updates the QP solver model.
- *
- * @param H quadratic cost input defining the QP model.
- * @param g linear cost input defining the QP model.
- * @param A equality constraint matrix input defining the QP model.
- * @param b equality constraint vector input defining the QP model.
- * @param C inequality constraint matrix input defining the QP model.
- * @param l lower inequality constraint vector input defining the QP model.
- * @param u upper inequality constraint vector input defining the QP model.
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpmodel solver model.
- * @param qpresults solver result.
- */
-
-template<typename T>
-void
-update(optional<MatRef<T>> H,
-       optional<VecRef<T>> g,
-       optional<MatRef<T>> A,
-       optional<VecRef<T>> b,
-       optional<MatRef<T>> C,
-       optional<VecRef<T>> l,
-       optional<VecRef<T>> u,
-       Model<T>& model,
-       Workspace<T>& work)
-{
-  // check the model is valid
-  if (g != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(g.value().size(),
-                                  model.dim,
-                                  "the dimension wrt the primal variable x "
-                                  "variable for updating g is not valid.");
-  }
-  if (b != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(b.value().size(),
-                                  model.n_eq,
-                                  "the dimension wrt equality constrained "
-                                  "variables for updating b is not valid.");
-  }
-  if (u != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(u.value().size(),
-                                  model.n_in,
-                                  "the dimension wrt inequality constrained "
-                                  "variables for updating u is not valid.");
-  }
-  if (l != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(l.value().size(),
-                                  model.n_in,
-                                  "the dimension wrt inequality constrained "
-                                  "variables for updating l is not valid.");
-  }
-  if (H != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      H.value().rows(),
-      model.dim,
-      "the row dimension for updating H is not valid.");
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      H.value().cols(),
-      model.dim,
-      "the column dimension for updating H is not valid.");
-  }
-  if (A != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      A.value().rows(),
-      model.n_eq,
-      "the row dimension for updating A is not valid.");
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      A.value().cols(),
-      model.dim,
-      "the column dimension for updating A is not valid.");
-  }
-  if (C != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      C.value().rows(),
-      model.n_in,
-      "the row dimension for updating C is not valid.");
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      C.value().cols(),
-      model.dim,
-      "the column dimension for updating C is not valid.");
-  }
-
-  // update the model
-  if (g != nullopt) {
-    model.g = g.value().eval();
-  }
-  if (b != nullopt) {
-    model.b = b.value().eval();
-  }
-  if (u != nullopt) {
-    model.u = u.value().eval();
-  }
-  if (l != nullopt) {
-    model.l = l.value().eval();
-  }
-
-  if (H != nullopt || A != nullopt || C != nullopt) {
-    work.refactorize = true;
-  }
-
-  if (H != nullopt) {
-    model.H = H.value();
-  }
-  if (A != nullopt) {
-    model.A = A.value();
-  }
-  if (C != nullopt) {
-    model.C = C.value();
-  }
-  assert(model.is_valid());
-}
-/*!
- * Setups the QP solver model.
- *
- * @param H quadratic cost input defining the QP model.
- * @param g linear cost input defining the QP model.
- * @param A equality constraint matrix input defining the QP model.
- * @param b equality constraint vector input defining the QP model.
- * @param C inequality constraint matrix input defining the QP model.
- * @param l lower inequality constraint vector input defining the QP model.
- * @param u upper inequality constraint vector input defining the QP model.
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpmodel solver model.
- * @param qpresults solver result.
- * @param ruiz ruiz preconditioner.
- * @param preconditioner_status bool variable for deciding whether executing the
- * preconditioning algorithm, or keeping previous preconditioning variables, or
- * using the identity preconditioner (i.e., no preconditioner).
- */
-template<typename T>
-void
-setup( //
-  optional<MatRef<T>> H,
-  optional<VecRef<T>> g,
-  optional<MatRef<T>> A,
-  optional<VecRef<T>> b,
-  optional<MatRef<T>> C,
-  optional<VecRef<T>> l,
-  optional<VecRef<T>> u,
-  Settings<T>& qpsettings,
-  Model<T>& qpmodel,
-  Workspace<T>& qpwork,
-  Results<T>& qpresults,
-  preconditioner::RuizEquilibration<T>& ruiz,
-  PreconditionerStatus preconditioner_status)
-{
-
-  switch (qpsettings.initial_guess) {
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-      if (qpwork.proximal_parameter_update) {
-        qpresults.cleanup_all_except_prox_parameters();
-      } else {
-        qpresults.cleanup(qpsettings);
-      }
-      qpwork.cleanup();
-      break;
-    }
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-      // keep solutions but restart workspace and results
-      if (qpwork.proximal_parameter_update) {
-        qpresults.cleanup_statistics();
-      } else {
-        qpresults.cold_start(qpsettings);
-      }
-      qpwork.cleanup();
-      break;
-    }
-    case InitialGuessStatus::NO_INITIAL_GUESS: {
-      if (qpwork.proximal_parameter_update) {
-        qpresults.cleanup_all_except_prox_parameters();
-      } else {
-        qpresults.cleanup(qpsettings);
-      }
-      qpwork.cleanup();
-      break;
-    }
-    case InitialGuessStatus::WARM_START: {
-      if (qpwork.proximal_parameter_update) {
-        qpresults
-          .cleanup_all_except_prox_parameters(); // the warm start is given at
-                                                 // the solve function
-      } else {
-        qpresults.cleanup(qpsettings);
-      }
-      qpwork.cleanup();
-      break;
-    }
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-      if (qpwork.refactorize || qpwork.proximal_parameter_update) {
-        qpwork.cleanup(); // meaningful for when there is an upate of the model
-                          // and one wants to warm start with previous result
-        qpwork.refactorize = true;
-      }
-      qpresults.cleanup_statistics();
-      break;
-    }
-  }
-  if (H != nullopt) {
-    qpmodel.H = H.value();
-  } // else qpmodel.H remains initialzed to a matrix with zero elements
-  if (g != nullopt) {
-    qpmodel.g = g.value();
-  }
-
-  if (A != nullopt) {
-    qpmodel.A = A.value();
-  } // else qpmodel.A remains initialized to a matrix with zero elements or zero
-    // shape
-
-  if (b != nullopt) {
-    qpmodel.b = b.value();
-  } // else qpmodel.b remains initialized to a matrix with zero elements or zero
-    // shape
-
-  if (C != nullopt) {
-    qpmodel.C = C.value();
-  } // else qpmodel.C remains initialized to a matrix with zero elements or zero
-    // shape
-
-  if (u != nullopt) {
-    qpmodel.u = u.value();
-  } // else qpmodel.u remains initialized to a matrix with zero elements or zero
-    // shape
-
-  if (l != nullopt) {
-    qpmodel.l = l.value();
-  } // else qpmodel.l remains initialized to a matrix with zero elements or zero
-    // shape
-  assert(qpmodel.is_valid());
-
-  qpwork.H_scaled = qpmodel.H;
-  qpwork.g_scaled = qpmodel.g;
-  qpwork.A_scaled = qpmodel.A;
-  qpwork.b_scaled = qpmodel.b;
-  qpwork.C_scaled = qpmodel.C;
-  qpwork.u_scaled =
-    (qpmodel.u.array() <= T(1.E20))
-      .select(qpmodel.u,
-              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in).array() +
-                T(1.E20));
-  qpwork.l_scaled =
-    (qpmodel.l.array() >= T(-1.E20))
-      .select(qpmodel.l,
-              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in).array() -
-                T(1.E20));
-
-  qpwork.dual_feasibility_rhs_2 = infty_norm(qpmodel.g);
-
-  switch (preconditioner_status) {
-    case PreconditionerStatus::EXECUTE:
-      setup_equilibration(qpwork, qpsettings, ruiz, true);
-      break;
-    case PreconditionerStatus::IDENTITY:
-      setup_equilibration(qpwork, qpsettings, ruiz, false);
-      break;
-    case PreconditionerStatus::KEEP:
-      // keep previous one
-      setup_equilibration(qpwork, qpsettings, ruiz, false);
-      break;
-  }
-}
-////// UPDATES ///////
-
-/*!
- * Update the proximal parameters of the results object.
- *
- * @param rho_new primal proximal parameter.
- * @param mu_eq_new dual equality proximal parameter.
- * @param mu_in_new dual inequality proximal parameter.
- * @param results solver results.
- */
-template<typename T>
-void
-update_proximal_parameters(Settings<T>& settings,
-                           Results<T>& results,
-                           Workspace<T>& work,
-                           optional<T> rho_new,
-                           optional<T> mu_eq_new,
-                           optional<T> mu_in_new)
-{
-
-  if (rho_new != nullopt) {
-    settings.default_rho = rho_new.value();
-    results.info.rho = rho_new.value();
-    work.proximal_parameter_update = true;
-  }
-  if (mu_eq_new != nullopt) {
-    settings.default_mu_eq = mu_eq_new.value();
-    results.info.mu_eq = mu_eq_new.value();
-    results.info.mu_eq_inv = T(1) / results.info.mu_eq;
-    work.proximal_parameter_update = true;
-  }
-  if (mu_in_new != nullopt) {
-    settings.default_mu_in = mu_in_new.value();
-    results.info.mu_in = mu_in_new.value();
-    results.info.mu_in_inv = T(1) / results.info.mu_in;
-    work.proximal_parameter_update = true;
-  }
-}
-/*!
- * Warm start the primal and dual variables.
- *
- * @param x_wm primal warm start.
- * @param y_wm dual equality warm start.
- * @param z_wm dual inequality warm start.
- * @param results solver result.
- * @param settings solver settings.
- */
-template<typename T>
-void
-warm_start(optional<VecRef<T>> x_wm,
-           optional<VecRef<T>> y_wm,
-           optional<VecRef<T>> z_wm,
-           Results<T>& results,
-           Settings<T>& settings,
-           Model<T>& model)
-{
-  if (x_wm == nullopt && y_wm == nullopt && z_wm == nullopt)
-    return;
-
-  settings.initial_guess = InitialGuessStatus::WARM_START;
-
-  // first check problem dimensions
-  if (x_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      x_wm.value().rows(),
-      model.dim,
-      "the dimension wrt primal variable x for warm start is not valid.");
-  }
-
-  if (y_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(y_wm.value().rows(),
-                                  model.n_eq,
-                                  "the dimension wrt equality constrained "
-                                  "variables for warm start is not valid.");
-  }
-
-  if (z_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      z_wm.value().rows(),
-      model.n_in,
-      "the dimension wrt inequality constrained variables for warm start "
-      "is not valid.");
-  }
-
-  if (x_wm != nullopt) {
-    results.x = x_wm.value().eval();
-  }
-
-  if (y_wm != nullopt) {
-    results.y = y_wm.value().eval();
-  }
-
-  if (z_wm != nullopt) {
-    results.z = z_wm.value().eval();
-  }
-}
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_HELPERS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file helpers.hpp
+ */
+
+#ifndef PROXSUITE_PROXQP_DENSE_HELPERS_HPP
+#define PROXSUITE_PROXQP_DENSE_HELPERS_HPP
+
+#include <proxsuite/proxqp/results.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/proxqp/status.hpp>
+#include <proxsuite/proxqp/dense/fwd.hpp>
+#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
+#include <chrono>
+#include <proxsuite/helpers/optional.hpp>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+
+/////// SETUP ////////
+/*!
+ * Computes the equality constrained initial guess of a QP problem.
+ *
+ * @param qpwork workspace of the solver.
+ * @param qpsettings settings of the solver.
+ * @param qpmodel QP problem as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solution results.
+ */
+template<typename T>
+void
+compute_equality_constrained_initial_guess(Workspace<T>& qpwork,
+                                           const Settings<T>& qpsettings,
+                                           const Model<T>& qpmodel,
+                                           Results<T>& qpresults)
+{
+
+  qpwork.rhs.setZero();
+  qpwork.rhs.head(qpmodel.dim) = -qpwork.g_scaled;
+  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) = qpwork.b_scaled;
+  iterative_solve_with_permut_fact( //
+    qpsettings,
+    qpmodel,
+    qpresults,
+    qpwork,
+    T(1),
+    qpmodel.dim + qpmodel.n_eq);
+
+  qpresults.x = qpwork.dw_aug.head(qpmodel.dim);
+  qpresults.y = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
+  qpwork.dw_aug.setZero();
+  qpwork.rhs.setZero();
+}
+
+/*!
+ * Setups and performs the first factorization of the regularized KKT matrix of
+ * the problem.
+ *
+ * @param qpwork workspace of the solver.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solution results.
+ */
+template<typename T>
+void
+setup_factorization(Workspace<T>& qpwork,
+                    const Model<T>& qpmodel,
+                    Results<T>& qpresults)
+{
+
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut,
+    qpwork.ldl_stack.as_mut(),
+  };
+
+  qpwork.kkt.topLeftCorner(qpmodel.dim, qpmodel.dim) = qpwork.H_scaled;
+  qpwork.kkt.topLeftCorner(qpmodel.dim, qpmodel.dim).diagonal().array() +=
+    qpresults.info.rho;
+  qpwork.kkt.block(0, qpmodel.dim, qpmodel.dim, qpmodel.n_eq) =
+    qpwork.A_scaled.transpose();
+  qpwork.kkt.block(qpmodel.dim, 0, qpmodel.n_eq, qpmodel.dim) = qpwork.A_scaled;
+  qpwork.kkt.bottomRightCorner(qpmodel.n_eq, qpmodel.n_eq).setZero();
+  qpwork.kkt.diagonal()
+    .segment(qpmodel.dim, qpmodel.n_eq)
+    .setConstant(-qpresults.info.mu_eq);
+
+  qpwork.ldl.factorize(qpwork.kkt.transpose(), stack);
+}
+/*!
+ * Performs the equilibration of the QP problem for reducing its
+ * ill-conditionness.
+ *
+ * @param qpwork workspace of the solver.
+ * @param qpsettings settings of the solver.
+ * @param ruiz ruiz preconditioner.
+ * @param execute_preconditioner boolean variable for executing or not the ruiz
+ * preconditioner. If set to False, it uses the previous preconditioning
+ * variables (initialized to the identity preconditioner if it is the first
+ * scaling performed).
+ */
+template<typename T>
+void
+setup_equilibration(Workspace<T>& qpwork,
+                    const Settings<T>& qpsettings,
+                    preconditioner::RuizEquilibration<T>& ruiz,
+                    bool execute_preconditioner)
+{
+
+  QpViewBoxMut<T> qp_scaled{
+    { from_eigen, qpwork.H_scaled }, { from_eigen, qpwork.g_scaled },
+    { from_eigen, qpwork.A_scaled }, { from_eigen, qpwork.b_scaled },
+    { from_eigen, qpwork.C_scaled }, { from_eigen, qpwork.u_scaled },
+    { from_eigen, qpwork.l_scaled }
+  };
+
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut,
+    qpwork.ldl_stack.as_mut(),
+  };
+  ruiz.scale_qp_in_place(qp_scaled,
+                         execute_preconditioner,
+                         qpsettings.preconditioner_max_iter,
+                         qpsettings.preconditioner_accuracy,
+                         stack);
+  qpwork.correction_guess_rhs_g = infty_norm(qpwork.g_scaled);
+}
+
+/*!
+ * Setups the solver initial guess.
+ *
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ */
+template<typename T>
+void
+initial_guess(Workspace<T>& qpwork,
+              Settings<T>& qpsettings,
+              Model<T>& qpmodel,
+              Results<T>& qpresults)
+{
+
+  switch (qpsettings.initial_guess) {
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+      compute_equality_constrained_initial_guess(
+        qpwork, qpsettings, qpmodel, qpresults);
+      break;
+    }
+  }
+}
+/*!
+ * Updates the QP solver model.
+ *
+ * @param H quadratic cost input defining the QP model.
+ * @param g linear cost input defining the QP model.
+ * @param A equality constraint matrix input defining the QP model.
+ * @param b equality constraint vector input defining the QP model.
+ * @param C inequality constraint matrix input defining the QP model.
+ * @param l lower inequality constraint vector input defining the QP model.
+ * @param u upper inequality constraint vector input defining the QP model.
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpmodel solver model.
+ * @param qpresults solver result.
+ */
+
+template<typename T>
+void
+update(optional<MatRef<T>> H,
+       optional<VecRef<T>> g,
+       optional<MatRef<T>> A,
+       optional<VecRef<T>> b,
+       optional<MatRef<T>> C,
+       optional<VecRef<T>> l,
+       optional<VecRef<T>> u,
+       Model<T>& model,
+       Workspace<T>& work)
+{
+  // check the model is valid
+  if (g != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(g.value().size(),
+                                  model.dim,
+                                  "the dimension wrt the primal variable x "
+                                  "variable for updating g is not valid.");
+  }
+  if (b != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(b.value().size(),
+                                  model.n_eq,
+                                  "the dimension wrt equality constrained "
+                                  "variables for updating b is not valid.");
+  }
+  if (u != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(u.value().size(),
+                                  model.n_in,
+                                  "the dimension wrt inequality constrained "
+                                  "variables for updating u is not valid.");
+  }
+  if (l != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(l.value().size(),
+                                  model.n_in,
+                                  "the dimension wrt inequality constrained "
+                                  "variables for updating l is not valid.");
+  }
+  if (H != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      H.value().rows(),
+      model.dim,
+      "the row dimension for updating H is not valid.");
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      H.value().cols(),
+      model.dim,
+      "the column dimension for updating H is not valid.");
+  }
+  if (A != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      A.value().rows(),
+      model.n_eq,
+      "the row dimension for updating A is not valid.");
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      A.value().cols(),
+      model.dim,
+      "the column dimension for updating A is not valid.");
+  }
+  if (C != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      C.value().rows(),
+      model.n_in,
+      "the row dimension for updating C is not valid.");
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      C.value().cols(),
+      model.dim,
+      "the column dimension for updating C is not valid.");
+  }
+
+  // update the model
+  if (g != nullopt) {
+    model.g = g.value().eval();
+  }
+  if (b != nullopt) {
+    model.b = b.value().eval();
+  }
+  if (u != nullopt) {
+    model.u = u.value().eval();
+  }
+  if (l != nullopt) {
+    model.l = l.value().eval();
+  }
+
+  if (H != nullopt || A != nullopt || C != nullopt) {
+    work.refactorize = true;
+  }
+
+  if (H != nullopt) {
+    model.H = H.value();
+  }
+  if (A != nullopt) {
+    model.A = A.value();
+  }
+  if (C != nullopt) {
+    model.C = C.value();
+  }
+  assert(model.is_valid());
+}
+/*!
+ * Setups the QP solver model.
+ *
+ * @param H quadratic cost input defining the QP model.
+ * @param g linear cost input defining the QP model.
+ * @param A equality constraint matrix input defining the QP model.
+ * @param b equality constraint vector input defining the QP model.
+ * @param C inequality constraint matrix input defining the QP model.
+ * @param l lower inequality constraint vector input defining the QP model.
+ * @param u upper inequality constraint vector input defining the QP model.
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpmodel solver model.
+ * @param qpresults solver result.
+ * @param ruiz ruiz preconditioner.
+ * @param preconditioner_status bool variable for deciding whether executing the
+ * preconditioning algorithm, or keeping previous preconditioning variables, or
+ * using the identity preconditioner (i.e., no preconditioner).
+ */
+template<typename T>
+void
+setup( //
+  optional<MatRef<T>> H,
+  optional<VecRef<T>> g,
+  optional<MatRef<T>> A,
+  optional<VecRef<T>> b,
+  optional<MatRef<T>> C,
+  optional<VecRef<T>> l,
+  optional<VecRef<T>> u,
+  Settings<T>& qpsettings,
+  Model<T>& qpmodel,
+  Workspace<T>& qpwork,
+  Results<T>& qpresults,
+  preconditioner::RuizEquilibration<T>& ruiz,
+  PreconditionerStatus preconditioner_status)
+{
+
+  switch (qpsettings.initial_guess) {
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+      if (qpwork.proximal_parameter_update) {
+        qpresults.cleanup_all_except_prox_parameters();
+      } else {
+        qpresults.cleanup(qpsettings);
+      }
+      qpwork.cleanup();
+      break;
+    }
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+      // keep solutions but restart workspace and results
+      if (qpwork.proximal_parameter_update) {
+        qpresults.cleanup_statistics();
+      } else {
+        qpresults.cold_start(qpsettings);
+      }
+      qpwork.cleanup();
+      break;
+    }
+    case InitialGuessStatus::NO_INITIAL_GUESS: {
+      if (qpwork.proximal_parameter_update) {
+        qpresults.cleanup_all_except_prox_parameters();
+      } else {
+        qpresults.cleanup(qpsettings);
+      }
+      qpwork.cleanup();
+      break;
+    }
+    case InitialGuessStatus::WARM_START: {
+      if (qpwork.proximal_parameter_update) {
+        qpresults
+          .cleanup_all_except_prox_parameters(); // the warm start is given at
+                                                 // the solve function
+      } else {
+        qpresults.cleanup(qpsettings);
+      }
+      qpwork.cleanup();
+      break;
+    }
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+      if (qpwork.refactorize || qpwork.proximal_parameter_update) {
+        qpwork.cleanup(); // meaningful for when there is an upate of the model
+                          // and one wants to warm start with previous result
+        qpwork.refactorize = true;
+      }
+      qpresults.cleanup_statistics();
+      break;
+    }
+  }
+  if (H != nullopt) {
+    qpmodel.H = H.value();
+  } // else qpmodel.H remains initialzed to a matrix with zero elements
+  if (g != nullopt) {
+    qpmodel.g = g.value();
+  }
+
+  if (A != nullopt) {
+    qpmodel.A = A.value();
+  } // else qpmodel.A remains initialized to a matrix with zero elements or zero
+    // shape
+
+  if (b != nullopt) {
+    qpmodel.b = b.value();
+  } // else qpmodel.b remains initialized to a matrix with zero elements or zero
+    // shape
+
+  if (C != nullopt) {
+    qpmodel.C = C.value();
+  } // else qpmodel.C remains initialized to a matrix with zero elements or zero
+    // shape
+
+  if (u != nullopt) {
+    qpmodel.u = u.value();
+  } // else qpmodel.u remains initialized to a matrix with zero elements or zero
+    // shape
+
+  if (l != nullopt) {
+    qpmodel.l = l.value();
+  } // else qpmodel.l remains initialized to a matrix with zero elements or zero
+    // shape
+  assert(qpmodel.is_valid());
+
+  qpwork.H_scaled = qpmodel.H;
+  qpwork.g_scaled = qpmodel.g;
+  qpwork.A_scaled = qpmodel.A;
+  qpwork.b_scaled = qpmodel.b;
+  qpwork.C_scaled = qpmodel.C;
+  qpwork.u_scaled =
+    (qpmodel.u.array() <= T(1.E20))
+      .select(qpmodel.u,
+              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in).array() +
+                T(1.E20));
+  qpwork.l_scaled =
+    (qpmodel.l.array() >= T(-1.E20))
+      .select(qpmodel.l,
+              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in).array() -
+                T(1.E20));
+
+  qpwork.dual_feasibility_rhs_2 = infty_norm(qpmodel.g);
+
+  switch (preconditioner_status) {
+    case PreconditionerStatus::EXECUTE:
+      setup_equilibration(qpwork, qpsettings, ruiz, true);
+      break;
+    case PreconditionerStatus::IDENTITY:
+      setup_equilibration(qpwork, qpsettings, ruiz, false);
+      break;
+    case PreconditionerStatus::KEEP:
+      // keep previous one
+      setup_equilibration(qpwork, qpsettings, ruiz, false);
+      break;
+  }
+}
+////// UPDATES ///////
+
+/*!
+ * Update the proximal parameters of the results object.
+ *
+ * @param rho_new primal proximal parameter.
+ * @param mu_eq_new dual equality proximal parameter.
+ * @param mu_in_new dual inequality proximal parameter.
+ * @param results solver results.
+ */
+template<typename T>
+void
+update_proximal_parameters(Settings<T>& settings,
+                           Results<T>& results,
+                           Workspace<T>& work,
+                           optional<T> rho_new,
+                           optional<T> mu_eq_new,
+                           optional<T> mu_in_new)
+{
+
+  if (rho_new != nullopt) {
+    settings.default_rho = rho_new.value();
+    results.info.rho = rho_new.value();
+    work.proximal_parameter_update = true;
+  }
+  if (mu_eq_new != nullopt) {
+    settings.default_mu_eq = mu_eq_new.value();
+    results.info.mu_eq = mu_eq_new.value();
+    results.info.mu_eq_inv = T(1) / results.info.mu_eq;
+    work.proximal_parameter_update = true;
+  }
+  if (mu_in_new != nullopt) {
+    settings.default_mu_in = mu_in_new.value();
+    results.info.mu_in = mu_in_new.value();
+    results.info.mu_in_inv = T(1) / results.info.mu_in;
+    work.proximal_parameter_update = true;
+  }
+}
+/*!
+ * Warm start the primal and dual variables.
+ *
+ * @param x_wm primal warm start.
+ * @param y_wm dual equality warm start.
+ * @param z_wm dual inequality warm start.
+ * @param results solver result.
+ * @param settings solver settings.
+ */
+template<typename T>
+void
+warm_start(optional<VecRef<T>> x_wm,
+           optional<VecRef<T>> y_wm,
+           optional<VecRef<T>> z_wm,
+           Results<T>& results,
+           Settings<T>& settings,
+           Model<T>& model)
+{
+  if (x_wm == nullopt && y_wm == nullopt && z_wm == nullopt)
+    return;
+
+  settings.initial_guess = InitialGuessStatus::WARM_START;
+
+  // first check problem dimensions
+  if (x_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      x_wm.value().rows(),
+      model.dim,
+      "the dimension wrt primal variable x for warm start is not valid.");
+  }
+
+  if (y_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(y_wm.value().rows(),
+                                  model.n_eq,
+                                  "the dimension wrt equality constrained "
+                                  "variables for warm start is not valid.");
+  }
+
+  if (z_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      z_wm.value().rows(),
+      model.n_in,
+      "the dimension wrt inequality constrained variables for warm start "
+      "is not valid.");
+  }
+
+  if (x_wm != nullopt) {
+    results.x = x_wm.value().eval();
+  }
+
+  if (y_wm != nullopt) {
+    results.y = y_wm.value().eval();
+  }
+
+  if (z_wm != nullopt) {
+    results.z = z_wm.value().eval();
+  }
+}
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_HELPERS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/linesearch.hpp

 * *Ordering differences only*

```diff
@@ -1,517 +1,517 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP
-#define PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP
-
-#include "proxsuite/proxqp/dense/views.hpp"
-#include "proxsuite/proxqp/dense/model.hpp"
-#include "proxsuite/proxqp/results.hpp"
-#include "proxsuite/proxqp/dense/workspace.hpp"
-#include "proxsuite/proxqp/settings.hpp"
-#include <cmath>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-namespace linesearch {
-///
-/// @brief This class stores the results of the primal-dual line-search.
-///
-/*!
- * Stores results of the line-search.
- *
- * @param a second order polynomial coefficient of the merit function used in
- * the linesearch.
- * @param b first order polynomial coefficient of the merit function used in the
- * linesearch.
- * @param grad derivative of the merit function used in the linesearch.
- */
-template<typename T>
-struct PrimalDualDerivativeResult
-{
-  T a;
-  T b;
-  T grad;
-  VEG_REFLECT(PrimalDualDerivativeResult, a, b, grad);
-};
-
-/*!
- * Stores first derivative and coefficient of the univariate second order
- * polynomial merit function to be canceled by the exact primal-dual linesearch.
- *
- * @param a second order polynomial coefficient of the merit function used in
- * the linesearch.
- * @param b first order polynomial coefficient of the merit function used in the
- * linesearch.
- * @param grad derivative of the merit function used in the linesearch.
- */
-template<typename T>
-auto
-primal_dual_derivative_results(const Model<T>& qpmodel,
-                               Results<T>& qpresults,
-                               Workspace<T>& qpwork,
-                               T alpha) -> PrimalDualDerivativeResult<T>
-{
-
-  /*
-   * the function computes the first derivative of phi(alpha) at outer step k
-   * and inner step l
-   *
-   * phi(alpha) = f(x_l+alpha dx) + rho/2 |x_l + alpha dx - x_k|**2
-   *              + mu_eq_inv/2 (|A(x_l+alpha dx)-d+y_k * mu_eq|**2)
-   *              + mu_eq_inv * nu /2 (|A(x_l+alpha dx)-d+y_k * mu_eq -
-   * (y_l+alpha dy)
-   * |**2)
-   *              + mu_in_inv/2 ( | [C(x_l+alpha dx) - u + z_k * mu_in]_+ |**2
-   *                         +| [C(x_l+alpha dx) - l + z_k * mu_in]_- |**2
-   *                         )
-   * 				+ mu_in_inv * nu / 2 ( | [C(x_l+alpha dx) - u +
-   * z_k
-   * * mu_in]_+
-   * + [C(x_l+alpha dx) - l + z_k * mu_in]_- - (z+alpha dz) * mu_in |**2 with
-   * f(x) = 0.5 * x^THx + g^Tx phi is a second order polynomial in alpha. Below
-   * are computed its coefficients a0 and b0 in order to compute the desired
-   * gradient a0 * alpha + b0
-   */
-
-  qpwork.primal_residual_in_scaled_up_plus_alphaCdx =
-    qpwork.primal_residual_in_scaled_up + qpwork.Cdx * alpha;
-  qpwork.primal_residual_in_scaled_low_plus_alphaCdx =
-    qpwork.primal_residual_in_scaled_low + qpwork.Cdx * alpha;
-
-  T a(qpwork.dw_aug.head(qpmodel.dim).dot(qpwork.Hdx) +
-      qpresults.info.mu_eq_inv * (qpwork.Adx).squaredNorm() +
-      qpresults.info.rho *
-        qpwork.dw_aug.head(qpmodel.dim)
-          .squaredNorm()); // contains now: a = dx.dot(H.dot(dx)) + rho *
-                           // norm(dx)**2 + (mu_eq_inv) * norm(Adx)**2
-
-  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) =
-    qpwork.Adx -
-    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq) * qpresults.info.mu_eq;
-  a += qpwork.err.segment(qpmodel.dim, qpmodel.n_eq).squaredNorm() *
-       qpresults.info.mu_eq_inv *
-       qpresults.info
-         .nu; // contains now: a = dx.dot(H.dot(dx)) + rho * norm(dx)**2 +
-  // (mu_eq_inv) * norm(Adx)**2 + nu*mu_eq_inv * norm(Adx-dy*mu_eq)**2
-  qpwork.err.head(qpmodel.dim) =
-    qpresults.info.rho * (qpresults.x - qpwork.x_prev) + qpwork.g_scaled;
-  T b(qpresults.x.dot(qpwork.Hdx) +
-      (qpwork.err.head(qpmodel.dim)).dot(qpwork.dw_aug.head(qpmodel.dim)) +
-      qpresults.info.mu_eq_inv *
-        (qpwork.Adx)
-          .dot(qpwork.primal_residual_eq_scaled +
-               qpresults.y * qpresults.info.mu_eq)); // contains now: b =
-                                                     // dx.dot(H.dot(x) +
-                                                     // rho*(x-xe) +  g)  +
-  // mu_eq_inv * Adx.dot(res_eq)
-
-  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) =
-    qpwork.primal_residual_eq_scaled;
-  b += qpresults.info.nu * qpresults.info.mu_eq_inv *
-       qpwork.err.segment(qpmodel.dim, qpmodel.n_eq)
-         .dot(qpwork.rhs.segment(
-           qpmodel.dim,
-           qpmodel.n_eq)); // contains now: b = dx.dot(H.dot(x) + rho*(x-xe)
-  // +  g)  + mu_eq_inv * Adx.dot(res_eq) + nu*mu_eq_inv *
-  // (Adx-dy*mu_eq).dot(res_eq-y*mu_eq)
-
-  // derive Cdx_act
-  qpwork.err.tail(qpmodel.n_in) =
-    ((qpwork.primal_residual_in_scaled_up_plus_alphaCdx.array() > T(0.)) ||
-     (qpwork.primal_residual_in_scaled_low_plus_alphaCdx.array() < T(0.)))
-      .select(qpwork.Cdx,
-              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in));
-
-  a += qpresults.info.mu_in_inv *
-       qpwork.err.tail(qpmodel.n_in)
-         .squaredNorm(); // contains now: a = dx.dot(H.dot(dx)) + rho *
-  // norm(dx)**2 + (mu_eq_inv) * norm(Adx)**2 + nu*mu_eq_inv *
-  // norm(Adx-dy*mu_eq)**2 + mu_in *
-  // norm(Cdx_act)**2
-
-  // derive vector [Cx-u+ze/mu]_+ + [Cx-l+ze/mu]--
-  qpwork.active_part_z =
-    (qpwork.primal_residual_in_scaled_up_plus_alphaCdx.array() > T(0.))
-      .select(qpwork.primal_residual_in_scaled_up,
-              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in)) +
-    (qpwork.primal_residual_in_scaled_low_plus_alphaCdx.array() < T(0.))
-      .select(qpwork.primal_residual_in_scaled_low,
-              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in));
-
-  b += qpresults.info.mu_in_inv *
-       qpwork.active_part_z.dot(qpwork.err.tail(
-         qpmodel.n_in)); // contains now: b = dx.dot(H.dot(x) + rho*(x-xe) +
-  // g)  + mu_eq_inv * Adx.dot(res_eq) + nu*mu_eq_inv *
-  // (Adx-dy*mu_eq).dot(res_eq-y*mu_eq) + mu_in
-  // * Cdx_act.dot([Cx-u+ze/mu]_+ + [Cx-l+ze*mu_in]--)
-
-  // derive Cdx_act - dz*mu_in
-  qpwork.err.tail(qpmodel.n_in) -=
-    qpwork.dw_aug.tail(qpmodel.n_in) * qpresults.info.mu_in;
-  // derive [Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]-- -z*mu_in
-  qpwork.active_part_z -= qpresults.z * qpresults.info.mu_in;
-
-  // contains now a = dx.dot(H.dot(dx)) + rho * norm(dx)**2 + (mu_eq_inv) *
-  // norm(Adx)**2 + nu*mu_eq_inv * norm(Adx-dy*mu_eq)**2 + mu_in_inv *
-  // norm(Cdx_act)**2 + nu*mu_in_inv * norm(Cdx_act-dz*mu_in)**2
-  a += qpresults.info.nu * qpresults.info.mu_in_inv *
-       qpwork.err.tail(qpmodel.n_in).squaredNorm();
-  // contains now b =  dx.dot(H.dot(x) + rho*(x-xe) +  g)  + mu_eq_inv *
-  // Adx.dot(res_eq) + nu*mu_eq_inv * (Adx-dy*mu_eq).dot(res_eq-y*mu_eq) +
-  // mu_in_inv
-  // * Cdx_act.dot([Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]--) + nu*mu_in_inv
-  // (Cdx_act-dz*mu_in).dot([Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]-- - z*mu_in)
-  b += qpresults.info.nu * qpresults.info.mu_in_inv *
-       qpwork.err.tail(qpmodel.n_in).dot(qpwork.active_part_z);
-
-  return {
-    a,
-    b,
-    a * alpha + b,
-  };
-}
-
-/*!
- * Performs the exact primaldual linesearch algorithm.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- */
-template<typename T>
-void
-primal_dual_ls(const Model<T>& qpmodel,
-               Results<T>& qpresults,
-               Workspace<T>& qpwork)
-{
-
-  /*
-   * The algorithm performs the following step
-   *
-   * 1/
-   * 1.1/ Store solutions of equations
-   * C(x+alpha dx) - l + ze/mu_in = 0
-   * C(x+alpha dx) - u + ze/mu_in = 0
-   *
-   * 1.2/ Sort the alpha
-   * 2/
-   * 2.1
-   * For each positive alpha compute the first derivative of
-   * phi(alpha) = [proximal primal dual augmented lagrangian of the subproblem
-   * evaluated at x_k + alpha dx, y_k + alpha dy, z_k + alpha dz] using function
-   * "gradient_norm" By construction for alpha = 0, phi'(alpha) <= 0 and
-   * phi'(alpha) goes to infinity with alpha hence it cancels uniquely at one
-   * optimal alpha*
-   *
-   * while phi'(alpha)<=0 store the derivative (noted last_grad_neg) and
-   * alpha (last_alpha_neg)
-   * the first time phi'(alpha) > 0 store the derivative (noted
-   * first_grad_pos) and alpha (first_alpha_pos), and break the loo
-   *
-   * 2.2
-   * If first_alpha_pos corresponds to the first positive alpha of previous
-   * loop, then do
-   *   last_alpha_neg = 0
-   *   last_grad_neg = phi'(0)
-   *
-   * 2.3
-   * the optimal alpha is within the interval
-   * [last_alpha_neg,first_alpha_pos] and can be computed exactly as phi' is
-   * an affine function in alph
-   * alpha* = alpha_last_neg
-   *        - last_neg_grad * (alpha_first_pos - alpha_last_neg) /
-   *                          (first_pos_grad - last_neg_grad);
-   */
-
-  const T machine_eps = std::numeric_limits<T>::epsilon();
-
-  qpwork.alpha = T(1);
-  T alpha_(1.);
-
-  qpwork.alphas.clear();
-
-  ///////// STEP 1 /////////
-  // 1.1 add solutions of equations C(x+alpha dx)-l +ze/mu_in = 0 and C(x+alpha
-  // dx)-u +ze/mu_in = 0
-
-  for (isize i = 0; i < qpmodel.n_in; i++) {
-
-    if (qpwork.Cdx(i) != 0.) {
-      alpha_ =
-        -qpwork.primal_residual_in_scaled_up(i) / (qpwork.Cdx(i) + machine_eps);
-      if (alpha_ > machine_eps) {
-        qpwork.alphas.push(alpha_);
-      }
-      alpha_ = -qpwork.primal_residual_in_scaled_low(i) /
-               (qpwork.Cdx(i) + machine_eps);
-      if (alpha_ > machine_eps) {
-        qpwork.alphas.push(alpha_);
-      }
-    }
-  }
-
-  isize n_alpha = qpwork.alphas.len();
-
-  // 1.2 sort the alphas
-
-  std::sort(qpwork.alphas.ptr_mut(), qpwork.alphas.ptr_mut() + n_alpha);
-  isize new_len = std::unique( //
-                    qpwork.alphas.ptr_mut(),
-                    qpwork.alphas.ptr_mut() + n_alpha) -
-                  qpwork.alphas.ptr_mut();
-  qpwork.alphas.resize(new_len);
-
-  n_alpha = qpwork.alphas.len();
-
-  if (n_alpha == 0 || qpwork.alphas[0] > 1) {
-    qpwork.alpha = 1;
-    return;
-  }
-
-  ////////// STEP 2 ///////////
-  auto infty = std::numeric_limits<T>::infinity();
-
-  T last_neg_grad = 0;
-  T alpha_last_neg = 0;
-  T first_pos_grad = 0;
-  T alpha_first_pos = infty;
-  for (isize i = 0; i < n_alpha; ++i) {
-    alpha_ = qpwork.alphas[i];
-
-    /*
-     * 2.1
-     * For each positive alpha compute the first derivative of
-     * phi(alpha) = [proximal augmented lagrangian of the
-     *               subproblem evaluated at x_k + alpha dx]
-     *
-     * (By construction for alpha = 0,  phi'(alpha) <= 0 and
-     * phi'(alpha) goes to infinity with alpha hence it cancels
-     * uniquely at one optimal alpha*
-     *
-     * while phi'(alpha)<=0 store the derivative (noted
-     * last_grad_neg) and alpha (last_alpha_neg
-     * the first time phi'(alpha) > 0 store the derivative
-     * (noted first_grad_pos) and alpha (first_alpha_pos), and
-     * break the loop
-     */
-    T gr =
-      primal_dual_derivative_results(qpmodel, qpresults, qpwork, alpha_).grad;
-
-    if (gr < T(0)) {
-      alpha_last_neg = alpha_;
-      last_neg_grad = gr;
-    } else {
-      first_pos_grad = gr;
-      alpha_first_pos = alpha_;
-      break;
-    }
-  }
-
-  /*
-   * 2.2
-   * If first_alpha_pos corresponds to the first positive alpha of
-   * previous loop, then do
-   * last_alpha_neg = 0 and last_grad_neg = phi'(0) using function
-   * "gradient_norm"
-   */
-  if (alpha_last_neg == T(0)) {
-    last_neg_grad =
-      primal_dual_derivative_results(qpmodel, qpresults, qpwork, alpha_last_neg)
-        .grad;
-  }
-  if (alpha_first_pos == infty) {
-    /*
-     * 2.3
-     * the optimal alpha is within the interval
-     * [last_alpha_neg, +∞)
-     */
-    PrimalDualDerivativeResult<T> res = primal_dual_derivative_results(
-      qpmodel, qpresults, qpwork, 2 * alpha_last_neg + 1);
-    auto& a = res.a;
-    auto& b = res.b;
-    // grad = a * alpha + b
-    // grad = 0 => alpha = -b/a
-    qpwork.alpha = -b / a;
-  } else {
-    /*
-     * 2.3
-     * the optimal alpha is within the interval
-     * [last_alpha_neg,first_alpha_pos] and can be computed exactly as phi'
-     * is an affine function in alpha
-     */
-
-    qpwork.alpha = alpha_last_neg - last_neg_grad *
-                                      (alpha_first_pos - alpha_last_neg) /
-                                      (first_pos_grad - last_neg_grad);
-  }
-}
-
-/*!
- * Performs the active set change of the factorized KKT matrix (using rank one
- * updates or downgrades).
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- */
-template<typename T>
-void
-active_set_change(const Model<T>& qpmodel,
-                  Results<T>& qpresults,
-                  Workspace<T>& qpwork)
-{
-
-  /*
-   * arguments
-   * 1/ new_active_set : a vector which contains new active set of the
-   * problem, namely if
-   * new_active_set_u = Cx_k-u +z_k*mu_in>= 0
-   * new_active_set_l = Cx_k-l +z_k*mu_in<=
-   * then new_active_set = new_active_set_u OR new_active_set_
-   *
-   * 2/ current_bijection_map : a vector for which each entry corresponds to
-   * the current row of C of the current factorization
-   *
-   * for example, naming C_initial the initial C matrix of the problem, and
-   * C_current the one of the current factorization, the
-   * C_initial[i,:] = C_current[current_bijection_mal[i],:] for all
-   *
-   * 3/ n_c : the current number of active_inequalities
-   * This algorithm ensures that for all new version of C_current in the LDLT
-   * factorization all row index i < n_c correspond to current active indexes
-   * (all other correspond to inactive rows
-   *
-   * To do so,
-   * 1/ for initialization
-   * 1.1/ new_bijection_map = current_bijection_map
-   * 1.2/ n_c_f = n_
-   *
-   * 2/ All active indexes of the current bijection map (i.e
-   * current_bijection_map(i) < n_c by assumption) which are not active
-   * anymore in the new active set (new_active_set(i)=false are put at the
-   * end of new_bijection_map, i.
-   *
-   * 2.1/ for all j if new_bijection_map(j) > new_bijection_map(i), then
-   * new_bijection_map(j)-=1
-   * 2.2/ n_c_f -=1
-   * 2.3/ new_bijection_map(i) = n_in-1
-   *
-   * 3/ All active indexe of the new active set (new_active_set(i) == true)
-   * which are not active in the new_bijection_map (new_bijection_map(i) >=
-   * n_c_f) are put at the end of the current version of C, i.e
-   * 3.1/ if new_bijection_map(j) < new_bijection_map(i) &&
-   * new_bijection_map(j) >= n_c_f then new_bijection_map(j)+=1
-   * 3.2/ new_bijection_map(i) = n_c_f
-   * 3.3/ n_c_f +=1
-   *
-   * It returns finally the new_bijection_map, for which
-   * new_bijection_map(n_in) = n_c_f
-   */
-
-  qpwork.dw_aug.setZero();
-
-  isize n_c_f = qpwork.n_c;
-  qpwork.new_bijection_map = qpwork.current_bijection_map;
-
-  // suppression pour le nouvel active set, ajout dans le nouvel unactive set
-
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
-  };
-
-  {
-    auto _planned_to_delete = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<isize>{}, isize(qpmodel.n_in));
-    isize* planned_to_delete = _planned_to_delete.ptr_mut();
-    isize planned_to_delete_count = 0;
-
-    for (isize i = 0; i < qpmodel.n_in; i++) {
-      if (qpwork.current_bijection_map(i) < qpwork.n_c) {
-        if (!qpwork.active_inequalities(i)) {
-          // delete current_bijection_map(i)
-
-          planned_to_delete[planned_to_delete_count] =
-            qpwork.current_bijection_map(i) + qpmodel.dim + qpmodel.n_eq;
-          ++planned_to_delete_count;
-
-          for (isize j = 0; j < qpmodel.n_in; j++) {
-            if (qpwork.new_bijection_map(j) > qpwork.new_bijection_map(i)) {
-              qpwork.new_bijection_map(j) -= 1;
-            }
-          }
-          n_c_f -= 1;
-          qpwork.new_bijection_map(i) = qpmodel.n_in - 1;
-        }
-      }
-    }
-    std::sort(planned_to_delete, planned_to_delete + planned_to_delete_count);
-    qpwork.ldl.delete_at(planned_to_delete, planned_to_delete_count, stack);
-    if (planned_to_delete_count > 0) {
-      qpwork.constraints_changed = true;
-    }
-  }
-
-  // ajout au nouvel active set, suppression pour le nouvel unactive set
-
-  {
-    auto _planned_to_add = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<isize>{}, qpmodel.n_in);
-    auto planned_to_add = _planned_to_add.ptr_mut();
-
-    isize planned_to_add_count = 0;
-    T mu_in_neg = -qpresults.info.mu_in;
-    isize n_c = n_c_f;
-    for (isize i = 0; i < qpmodel.n_in; i++) {
-      if (qpwork.active_inequalities(i)) {
-        if (qpwork.new_bijection_map(i) >= n_c_f) {
-          // add at the end
-          planned_to_add[planned_to_add_count] = i;
-          ++planned_to_add_count;
-
-          for (isize j = 0; j < qpmodel.n_in; j++) {
-            if (qpwork.new_bijection_map(j) < qpwork.new_bijection_map(i) &&
-                qpwork.new_bijection_map(j) >= n_c_f) {
-              qpwork.new_bijection_map(j) += 1;
-            }
-          }
-          qpwork.new_bijection_map(i) = n_c_f;
-          n_c_f += 1;
-        }
-      }
-    }
-    {
-      isize n = qpmodel.dim;
-      isize n_eq = qpmodel.n_eq;
-      LDLT_TEMP_MAT_UNINIT(
-        T, new_cols, n + n_eq + n_c_f, planned_to_add_count, stack);
-
-      for (isize k = 0; k < planned_to_add_count; ++k) {
-        isize index = planned_to_add[k];
-        auto col = new_cols.col(k);
-        col.head(n) = (qpwork.C_scaled.row(index));
-        col.tail(n_eq + n_c_f).setZero();
-        col[n + n_eq + n_c + k] = mu_in_neg;
-      }
-      qpwork.ldl.insert_block_at(n + n_eq + n_c, new_cols, stack);
-    }
-    if (planned_to_add_count > 0) {
-      qpwork.constraints_changed = true;
-    }
-  }
-
-  qpwork.n_c = n_c_f;
-  qpwork.current_bijection_map = qpwork.new_bijection_map;
-  qpwork.dw_aug.setZero();
-}
-
-} // namespace linesearch
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP
+#define PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP
+
+#include "proxsuite/proxqp/dense/views.hpp"
+#include "proxsuite/proxqp/dense/model.hpp"
+#include "proxsuite/proxqp/results.hpp"
+#include "proxsuite/proxqp/dense/workspace.hpp"
+#include "proxsuite/proxqp/settings.hpp"
+#include <cmath>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+namespace linesearch {
+///
+/// @brief This class stores the results of the primal-dual line-search.
+///
+/*!
+ * Stores results of the line-search.
+ *
+ * @param a second order polynomial coefficient of the merit function used in
+ * the linesearch.
+ * @param b first order polynomial coefficient of the merit function used in the
+ * linesearch.
+ * @param grad derivative of the merit function used in the linesearch.
+ */
+template<typename T>
+struct PrimalDualDerivativeResult
+{
+  T a;
+  T b;
+  T grad;
+  VEG_REFLECT(PrimalDualDerivativeResult, a, b, grad);
+};
+
+/*!
+ * Stores first derivative and coefficient of the univariate second order
+ * polynomial merit function to be canceled by the exact primal-dual linesearch.
+ *
+ * @param a second order polynomial coefficient of the merit function used in
+ * the linesearch.
+ * @param b first order polynomial coefficient of the merit function used in the
+ * linesearch.
+ * @param grad derivative of the merit function used in the linesearch.
+ */
+template<typename T>
+auto
+primal_dual_derivative_results(const Model<T>& qpmodel,
+                               Results<T>& qpresults,
+                               Workspace<T>& qpwork,
+                               T alpha) -> PrimalDualDerivativeResult<T>
+{
+
+  /*
+   * the function computes the first derivative of phi(alpha) at outer step k
+   * and inner step l
+   *
+   * phi(alpha) = f(x_l+alpha dx) + rho/2 |x_l + alpha dx - x_k|**2
+   *              + mu_eq_inv/2 (|A(x_l+alpha dx)-d+y_k * mu_eq|**2)
+   *              + mu_eq_inv * nu /2 (|A(x_l+alpha dx)-d+y_k * mu_eq -
+   * (y_l+alpha dy)
+   * |**2)
+   *              + mu_in_inv/2 ( | [C(x_l+alpha dx) - u + z_k * mu_in]_+ |**2
+   *                         +| [C(x_l+alpha dx) - l + z_k * mu_in]_- |**2
+   *                         )
+   * 				+ mu_in_inv * nu / 2 ( | [C(x_l+alpha dx) - u +
+   * z_k
+   * * mu_in]_+
+   * + [C(x_l+alpha dx) - l + z_k * mu_in]_- - (z+alpha dz) * mu_in |**2 with
+   * f(x) = 0.5 * x^THx + g^Tx phi is a second order polynomial in alpha. Below
+   * are computed its coefficients a0 and b0 in order to compute the desired
+   * gradient a0 * alpha + b0
+   */
+
+  qpwork.primal_residual_in_scaled_up_plus_alphaCdx =
+    qpwork.primal_residual_in_scaled_up + qpwork.Cdx * alpha;
+  qpwork.primal_residual_in_scaled_low_plus_alphaCdx =
+    qpwork.primal_residual_in_scaled_low + qpwork.Cdx * alpha;
+
+  T a(qpwork.dw_aug.head(qpmodel.dim).dot(qpwork.Hdx) +
+      qpresults.info.mu_eq_inv * (qpwork.Adx).squaredNorm() +
+      qpresults.info.rho *
+        qpwork.dw_aug.head(qpmodel.dim)
+          .squaredNorm()); // contains now: a = dx.dot(H.dot(dx)) + rho *
+                           // norm(dx)**2 + (mu_eq_inv) * norm(Adx)**2
+
+  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) =
+    qpwork.Adx -
+    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq) * qpresults.info.mu_eq;
+  a += qpwork.err.segment(qpmodel.dim, qpmodel.n_eq).squaredNorm() *
+       qpresults.info.mu_eq_inv *
+       qpresults.info
+         .nu; // contains now: a = dx.dot(H.dot(dx)) + rho * norm(dx)**2 +
+  // (mu_eq_inv) * norm(Adx)**2 + nu*mu_eq_inv * norm(Adx-dy*mu_eq)**2
+  qpwork.err.head(qpmodel.dim) =
+    qpresults.info.rho * (qpresults.x - qpwork.x_prev) + qpwork.g_scaled;
+  T b(qpresults.x.dot(qpwork.Hdx) +
+      (qpwork.err.head(qpmodel.dim)).dot(qpwork.dw_aug.head(qpmodel.dim)) +
+      qpresults.info.mu_eq_inv *
+        (qpwork.Adx)
+          .dot(qpwork.primal_residual_eq_scaled +
+               qpresults.y * qpresults.info.mu_eq)); // contains now: b =
+                                                     // dx.dot(H.dot(x) +
+                                                     // rho*(x-xe) +  g)  +
+  // mu_eq_inv * Adx.dot(res_eq)
+
+  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) =
+    qpwork.primal_residual_eq_scaled;
+  b += qpresults.info.nu * qpresults.info.mu_eq_inv *
+       qpwork.err.segment(qpmodel.dim, qpmodel.n_eq)
+         .dot(qpwork.rhs.segment(
+           qpmodel.dim,
+           qpmodel.n_eq)); // contains now: b = dx.dot(H.dot(x) + rho*(x-xe)
+  // +  g)  + mu_eq_inv * Adx.dot(res_eq) + nu*mu_eq_inv *
+  // (Adx-dy*mu_eq).dot(res_eq-y*mu_eq)
+
+  // derive Cdx_act
+  qpwork.err.tail(qpmodel.n_in) =
+    ((qpwork.primal_residual_in_scaled_up_plus_alphaCdx.array() > T(0.)) ||
+     (qpwork.primal_residual_in_scaled_low_plus_alphaCdx.array() < T(0.)))
+      .select(qpwork.Cdx,
+              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in));
+
+  a += qpresults.info.mu_in_inv *
+       qpwork.err.tail(qpmodel.n_in)
+         .squaredNorm(); // contains now: a = dx.dot(H.dot(dx)) + rho *
+  // norm(dx)**2 + (mu_eq_inv) * norm(Adx)**2 + nu*mu_eq_inv *
+  // norm(Adx-dy*mu_eq)**2 + mu_in *
+  // norm(Cdx_act)**2
+
+  // derive vector [Cx-u+ze/mu]_+ + [Cx-l+ze/mu]--
+  qpwork.active_part_z =
+    (qpwork.primal_residual_in_scaled_up_plus_alphaCdx.array() > T(0.))
+      .select(qpwork.primal_residual_in_scaled_up,
+              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in)) +
+    (qpwork.primal_residual_in_scaled_low_plus_alphaCdx.array() < T(0.))
+      .select(qpwork.primal_residual_in_scaled_low,
+              Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(qpmodel.n_in));
+
+  b += qpresults.info.mu_in_inv *
+       qpwork.active_part_z.dot(qpwork.err.tail(
+         qpmodel.n_in)); // contains now: b = dx.dot(H.dot(x) + rho*(x-xe) +
+  // g)  + mu_eq_inv * Adx.dot(res_eq) + nu*mu_eq_inv *
+  // (Adx-dy*mu_eq).dot(res_eq-y*mu_eq) + mu_in
+  // * Cdx_act.dot([Cx-u+ze/mu]_+ + [Cx-l+ze*mu_in]--)
+
+  // derive Cdx_act - dz*mu_in
+  qpwork.err.tail(qpmodel.n_in) -=
+    qpwork.dw_aug.tail(qpmodel.n_in) * qpresults.info.mu_in;
+  // derive [Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]-- -z*mu_in
+  qpwork.active_part_z -= qpresults.z * qpresults.info.mu_in;
+
+  // contains now a = dx.dot(H.dot(dx)) + rho * norm(dx)**2 + (mu_eq_inv) *
+  // norm(Adx)**2 + nu*mu_eq_inv * norm(Adx-dy*mu_eq)**2 + mu_in_inv *
+  // norm(Cdx_act)**2 + nu*mu_in_inv * norm(Cdx_act-dz*mu_in)**2
+  a += qpresults.info.nu * qpresults.info.mu_in_inv *
+       qpwork.err.tail(qpmodel.n_in).squaredNorm();
+  // contains now b =  dx.dot(H.dot(x) + rho*(x-xe) +  g)  + mu_eq_inv *
+  // Adx.dot(res_eq) + nu*mu_eq_inv * (Adx-dy*mu_eq).dot(res_eq-y*mu_eq) +
+  // mu_in_inv
+  // * Cdx_act.dot([Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]--) + nu*mu_in_inv
+  // (Cdx_act-dz*mu_in).dot([Cx-u+ze*mu_in]_+ + [Cx-l+ze*mu_in]-- - z*mu_in)
+  b += qpresults.info.nu * qpresults.info.mu_in_inv *
+       qpwork.err.tail(qpmodel.n_in).dot(qpwork.active_part_z);
+
+  return {
+    a,
+    b,
+    a * alpha + b,
+  };
+}
+
+/*!
+ * Performs the exact primaldual linesearch algorithm.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ */
+template<typename T>
+void
+primal_dual_ls(const Model<T>& qpmodel,
+               Results<T>& qpresults,
+               Workspace<T>& qpwork)
+{
+
+  /*
+   * The algorithm performs the following step
+   *
+   * 1/
+   * 1.1/ Store solutions of equations
+   * C(x+alpha dx) - l + ze/mu_in = 0
+   * C(x+alpha dx) - u + ze/mu_in = 0
+   *
+   * 1.2/ Sort the alpha
+   * 2/
+   * 2.1
+   * For each positive alpha compute the first derivative of
+   * phi(alpha) = [proximal primal dual augmented lagrangian of the subproblem
+   * evaluated at x_k + alpha dx, y_k + alpha dy, z_k + alpha dz] using function
+   * "gradient_norm" By construction for alpha = 0, phi'(alpha) <= 0 and
+   * phi'(alpha) goes to infinity with alpha hence it cancels uniquely at one
+   * optimal alpha*
+   *
+   * while phi'(alpha)<=0 store the derivative (noted last_grad_neg) and
+   * alpha (last_alpha_neg)
+   * the first time phi'(alpha) > 0 store the derivative (noted
+   * first_grad_pos) and alpha (first_alpha_pos), and break the loo
+   *
+   * 2.2
+   * If first_alpha_pos corresponds to the first positive alpha of previous
+   * loop, then do
+   *   last_alpha_neg = 0
+   *   last_grad_neg = phi'(0)
+   *
+   * 2.3
+   * the optimal alpha is within the interval
+   * [last_alpha_neg,first_alpha_pos] and can be computed exactly as phi' is
+   * an affine function in alph
+   * alpha* = alpha_last_neg
+   *        - last_neg_grad * (alpha_first_pos - alpha_last_neg) /
+   *                          (first_pos_grad - last_neg_grad);
+   */
+
+  const T machine_eps = std::numeric_limits<T>::epsilon();
+
+  qpwork.alpha = T(1);
+  T alpha_(1.);
+
+  qpwork.alphas.clear();
+
+  ///////// STEP 1 /////////
+  // 1.1 add solutions of equations C(x+alpha dx)-l +ze/mu_in = 0 and C(x+alpha
+  // dx)-u +ze/mu_in = 0
+
+  for (isize i = 0; i < qpmodel.n_in; i++) {
+
+    if (qpwork.Cdx(i) != 0.) {
+      alpha_ =
+        -qpwork.primal_residual_in_scaled_up(i) / (qpwork.Cdx(i) + machine_eps);
+      if (alpha_ > machine_eps) {
+        qpwork.alphas.push(alpha_);
+      }
+      alpha_ = -qpwork.primal_residual_in_scaled_low(i) /
+               (qpwork.Cdx(i) + machine_eps);
+      if (alpha_ > machine_eps) {
+        qpwork.alphas.push(alpha_);
+      }
+    }
+  }
+
+  isize n_alpha = qpwork.alphas.len();
+
+  // 1.2 sort the alphas
+
+  std::sort(qpwork.alphas.ptr_mut(), qpwork.alphas.ptr_mut() + n_alpha);
+  isize new_len = std::unique( //
+                    qpwork.alphas.ptr_mut(),
+                    qpwork.alphas.ptr_mut() + n_alpha) -
+                  qpwork.alphas.ptr_mut();
+  qpwork.alphas.resize(new_len);
+
+  n_alpha = qpwork.alphas.len();
+
+  if (n_alpha == 0 || qpwork.alphas[0] > 1) {
+    qpwork.alpha = 1;
+    return;
+  }
+
+  ////////// STEP 2 ///////////
+  auto infty = std::numeric_limits<T>::infinity();
+
+  T last_neg_grad = 0;
+  T alpha_last_neg = 0;
+  T first_pos_grad = 0;
+  T alpha_first_pos = infty;
+  for (isize i = 0; i < n_alpha; ++i) {
+    alpha_ = qpwork.alphas[i];
+
+    /*
+     * 2.1
+     * For each positive alpha compute the first derivative of
+     * phi(alpha) = [proximal augmented lagrangian of the
+     *               subproblem evaluated at x_k + alpha dx]
+     *
+     * (By construction for alpha = 0,  phi'(alpha) <= 0 and
+     * phi'(alpha) goes to infinity with alpha hence it cancels
+     * uniquely at one optimal alpha*
+     *
+     * while phi'(alpha)<=0 store the derivative (noted
+     * last_grad_neg) and alpha (last_alpha_neg
+     * the first time phi'(alpha) > 0 store the derivative
+     * (noted first_grad_pos) and alpha (first_alpha_pos), and
+     * break the loop
+     */
+    T gr =
+      primal_dual_derivative_results(qpmodel, qpresults, qpwork, alpha_).grad;
+
+    if (gr < T(0)) {
+      alpha_last_neg = alpha_;
+      last_neg_grad = gr;
+    } else {
+      first_pos_grad = gr;
+      alpha_first_pos = alpha_;
+      break;
+    }
+  }
+
+  /*
+   * 2.2
+   * If first_alpha_pos corresponds to the first positive alpha of
+   * previous loop, then do
+   * last_alpha_neg = 0 and last_grad_neg = phi'(0) using function
+   * "gradient_norm"
+   */
+  if (alpha_last_neg == T(0)) {
+    last_neg_grad =
+      primal_dual_derivative_results(qpmodel, qpresults, qpwork, alpha_last_neg)
+        .grad;
+  }
+  if (alpha_first_pos == infty) {
+    /*
+     * 2.3
+     * the optimal alpha is within the interval
+     * [last_alpha_neg, +∞)
+     */
+    PrimalDualDerivativeResult<T> res = primal_dual_derivative_results(
+      qpmodel, qpresults, qpwork, 2 * alpha_last_neg + 1);
+    auto& a = res.a;
+    auto& b = res.b;
+    // grad = a * alpha + b
+    // grad = 0 => alpha = -b/a
+    qpwork.alpha = -b / a;
+  } else {
+    /*
+     * 2.3
+     * the optimal alpha is within the interval
+     * [last_alpha_neg,first_alpha_pos] and can be computed exactly as phi'
+     * is an affine function in alpha
+     */
+
+    qpwork.alpha = alpha_last_neg - last_neg_grad *
+                                      (alpha_first_pos - alpha_last_neg) /
+                                      (first_pos_grad - last_neg_grad);
+  }
+}
+
+/*!
+ * Performs the active set change of the factorized KKT matrix (using rank one
+ * updates or downgrades).
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ */
+template<typename T>
+void
+active_set_change(const Model<T>& qpmodel,
+                  Results<T>& qpresults,
+                  Workspace<T>& qpwork)
+{
+
+  /*
+   * arguments
+   * 1/ new_active_set : a vector which contains new active set of the
+   * problem, namely if
+   * new_active_set_u = Cx_k-u +z_k*mu_in>= 0
+   * new_active_set_l = Cx_k-l +z_k*mu_in<=
+   * then new_active_set = new_active_set_u OR new_active_set_
+   *
+   * 2/ current_bijection_map : a vector for which each entry corresponds to
+   * the current row of C of the current factorization
+   *
+   * for example, naming C_initial the initial C matrix of the problem, and
+   * C_current the one of the current factorization, the
+   * C_initial[i,:] = C_current[current_bijection_mal[i],:] for all
+   *
+   * 3/ n_c : the current number of active_inequalities
+   * This algorithm ensures that for all new version of C_current in the LDLT
+   * factorization all row index i < n_c correspond to current active indexes
+   * (all other correspond to inactive rows
+   *
+   * To do so,
+   * 1/ for initialization
+   * 1.1/ new_bijection_map = current_bijection_map
+   * 1.2/ n_c_f = n_
+   *
+   * 2/ All active indexes of the current bijection map (i.e
+   * current_bijection_map(i) < n_c by assumption) which are not active
+   * anymore in the new active set (new_active_set(i)=false are put at the
+   * end of new_bijection_map, i.
+   *
+   * 2.1/ for all j if new_bijection_map(j) > new_bijection_map(i), then
+   * new_bijection_map(j)-=1
+   * 2.2/ n_c_f -=1
+   * 2.3/ new_bijection_map(i) = n_in-1
+   *
+   * 3/ All active indexe of the new active set (new_active_set(i) == true)
+   * which are not active in the new_bijection_map (new_bijection_map(i) >=
+   * n_c_f) are put at the end of the current version of C, i.e
+   * 3.1/ if new_bijection_map(j) < new_bijection_map(i) &&
+   * new_bijection_map(j) >= n_c_f then new_bijection_map(j)+=1
+   * 3.2/ new_bijection_map(i) = n_c_f
+   * 3.3/ n_c_f +=1
+   *
+   * It returns finally the new_bijection_map, for which
+   * new_bijection_map(n_in) = n_c_f
+   */
+
+  qpwork.dw_aug.setZero();
+
+  isize n_c_f = qpwork.n_c;
+  qpwork.new_bijection_map = qpwork.current_bijection_map;
+
+  // suppression pour le nouvel active set, ajout dans le nouvel unactive set
+
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
+  };
+
+  {
+    auto _planned_to_delete = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<isize>{}, isize(qpmodel.n_in));
+    isize* planned_to_delete = _planned_to_delete.ptr_mut();
+    isize planned_to_delete_count = 0;
+
+    for (isize i = 0; i < qpmodel.n_in; i++) {
+      if (qpwork.current_bijection_map(i) < qpwork.n_c) {
+        if (!qpwork.active_inequalities(i)) {
+          // delete current_bijection_map(i)
+
+          planned_to_delete[planned_to_delete_count] =
+            qpwork.current_bijection_map(i) + qpmodel.dim + qpmodel.n_eq;
+          ++planned_to_delete_count;
+
+          for (isize j = 0; j < qpmodel.n_in; j++) {
+            if (qpwork.new_bijection_map(j) > qpwork.new_bijection_map(i)) {
+              qpwork.new_bijection_map(j) -= 1;
+            }
+          }
+          n_c_f -= 1;
+          qpwork.new_bijection_map(i) = qpmodel.n_in - 1;
+        }
+      }
+    }
+    std::sort(planned_to_delete, planned_to_delete + planned_to_delete_count);
+    qpwork.ldl.delete_at(planned_to_delete, planned_to_delete_count, stack);
+    if (planned_to_delete_count > 0) {
+      qpwork.constraints_changed = true;
+    }
+  }
+
+  // ajout au nouvel active set, suppression pour le nouvel unactive set
+
+  {
+    auto _planned_to_add = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<isize>{}, qpmodel.n_in);
+    auto planned_to_add = _planned_to_add.ptr_mut();
+
+    isize planned_to_add_count = 0;
+    T mu_in_neg = -qpresults.info.mu_in;
+    isize n_c = n_c_f;
+    for (isize i = 0; i < qpmodel.n_in; i++) {
+      if (qpwork.active_inequalities(i)) {
+        if (qpwork.new_bijection_map(i) >= n_c_f) {
+          // add at the end
+          planned_to_add[planned_to_add_count] = i;
+          ++planned_to_add_count;
+
+          for (isize j = 0; j < qpmodel.n_in; j++) {
+            if (qpwork.new_bijection_map(j) < qpwork.new_bijection_map(i) &&
+                qpwork.new_bijection_map(j) >= n_c_f) {
+              qpwork.new_bijection_map(j) += 1;
+            }
+          }
+          qpwork.new_bijection_map(i) = n_c_f;
+          n_c_f += 1;
+        }
+      }
+    }
+    {
+      isize n = qpmodel.dim;
+      isize n_eq = qpmodel.n_eq;
+      LDLT_TEMP_MAT_UNINIT(
+        T, new_cols, n + n_eq + n_c_f, planned_to_add_count, stack);
+
+      for (isize k = 0; k < planned_to_add_count; ++k) {
+        isize index = planned_to_add[k];
+        auto col = new_cols.col(k);
+        col.head(n) = (qpwork.C_scaled.row(index));
+        col.tail(n_eq + n_c_f).setZero();
+        col[n + n_eq + n_c + k] = mu_in_neg;
+      }
+      qpwork.ldl.insert_block_at(n + n_eq + n_c, new_cols, stack);
+    }
+    if (planned_to_add_count > 0) {
+      qpwork.constraints_changed = true;
+    }
+  }
+
+  qpwork.n_c = n_c_f;
+  qpwork.current_bijection_map = qpwork.new_bijection_map;
+  qpwork.dw_aug.setZero();
+}
+
+} // namespace linesearch
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_LINESEARCH_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/model.hpp

 * *Ordering differences only*

```diff
@@ -1,147 +1,147 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_DENSE_MODEL_HPP
-#define PROXSUITE_PROXQP_DENSE_MODEL_HPP
-
-#include <Eigen/Core>
-#include "proxsuite/linalg/veg/type_traits/core.hpp"
-#include "proxsuite/proxqp/dense/fwd.hpp"
-#include "proxsuite/proxqp/sparse/model.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-///
-/// @brief This class stores the model of the QP problem.
-///
-/*!
- * Model class of the dense solver storing the QP problem.
- */
-template<typename T>
-struct Model
-{
-
-  ///// QP STORAGE
-  Mat<T> H;
-  Vec<T> g;
-  Mat<T> A;
-  Mat<T> C;
-  Vec<T> b;
-  Vec<T> u;
-  Vec<T> l;
-
-  ///// model sizes
-  isize dim;
-  isize n_eq;
-  isize n_in;
-  isize n_total;
-
-  /*!
-   * Default constructor.
-   * @param dim primal variable dimension.
-   * @param n_eq number of equality constraints.
-   * @param n_in number of inequality constraints.
-   */
-  Model(isize dim, isize n_eq, isize n_in)
-    : H(dim, dim)
-    , g(dim)
-    , A(n_eq, dim)
-    , C(n_in, dim)
-    , b(n_eq)
-    , u(n_in)
-    , l(n_in)
-    , dim(dim)
-    , n_eq(n_eq)
-    , n_in(n_in)
-    , n_total(dim + n_eq + n_in)
-  {
-    PROXSUITE_THROW_PRETTY(dim == 0,
-                           std::invalid_argument,
-                           "wrong argument size: the dimension wrt the primal "
-                           "variable x should be strictly positive.");
-
-    const T infinite_bound_value = helpers::infinite_bound<T>::value();
-
-    H.setZero();
-    g.setZero();
-    A.setZero();
-    C.setZero();
-    b.setZero();
-    u.fill(+infinite_bound_value); // in case it appears u is nullopt (i.e., the
-                                   // problem is only lower bounded)
-    l.fill(-infinite_bound_value); // in case it appears l is nullopt (i.e., the
-                                   // problem is only upper bounded)
-  }
-
-  proxsuite::proxqp::sparse::SparseModel<T> to_sparse()
-  {
-    SparseMat<T> H_sparse = H.sparseView();
-    SparseMat<T> A_sparse = A.sparseView();
-    SparseMat<T> C_sparse = C.sparseView();
-    proxsuite::proxqp::sparse::SparseModel<T> res{ H_sparse, g, A_sparse, b,
-                                                   C_sparse, u, l };
-    return res;
-  }
-
-  bool is_valid()
-  {
-#define PROXSUITE_CHECK_SIZE(size, expected_size)                              \
-  if (size != 0) {                                                             \
-    if (!(size == expected_size))                                              \
-      return false;                                                            \
-  }
-
-    // check that all matrices and vectors of qpmodel have the correct size
-    // and that H and C have expected properties
-    PROXSUITE_CHECK_SIZE(g.size(), dim);
-    PROXSUITE_CHECK_SIZE(b.size(), n_eq);
-    PROXSUITE_CHECK_SIZE(u.size(), n_in);
-    PROXSUITE_CHECK_SIZE(l.size(), n_in);
-    if (H.size()) {
-      PROXSUITE_CHECK_SIZE(H.rows(), dim);
-      PROXSUITE_CHECK_SIZE(H.cols(), dim);
-      if (!H.isApprox(H.transpose(), 0.0))
-        return false;
-    }
-    if (A.size()) {
-      PROXSUITE_CHECK_SIZE(A.rows(), n_eq);
-      PROXSUITE_CHECK_SIZE(A.cols(), dim);
-    }
-    if (C.size()) {
-      PROXSUITE_CHECK_SIZE(C.rows(), n_in);
-      PROXSUITE_CHECK_SIZE(C.cols(), dim);
-      if (C.isZero())
-        return false;
-    }
-    return true;
-#undef PROXSUITE_CHECK_SIZE
-  }
-};
-
-template<typename T>
-bool
-operator==(const Model<T>& model1, const Model<T>& model2)
-{
-  bool value = model1.dim == model2.dim && model1.n_eq == model2.n_eq &&
-               model1.n_in == model2.n_in && model1.n_total == model2.n_total &&
-               model1.H == model2.H && model1.g == model2.g &&
-               model1.A == model2.A && model1.b == model2.b &&
-               model1.C == model2.C && model1.l == model2.l &&
-               model1.u == model2.u;
-  return value;
-}
-
-template<typename T>
-bool
-operator!=(const Model<T>& model1, const Model<T>& model2)
-{
-  return !(model1 == model2);
-}
-
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_MODEL_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_DENSE_MODEL_HPP
+#define PROXSUITE_PROXQP_DENSE_MODEL_HPP
+
+#include <Eigen/Core>
+#include "proxsuite/linalg/veg/type_traits/core.hpp"
+#include "proxsuite/proxqp/dense/fwd.hpp"
+#include "proxsuite/proxqp/sparse/model.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+///
+/// @brief This class stores the model of the QP problem.
+///
+/*!
+ * Model class of the dense solver storing the QP problem.
+ */
+template<typename T>
+struct Model
+{
+
+  ///// QP STORAGE
+  Mat<T> H;
+  Vec<T> g;
+  Mat<T> A;
+  Mat<T> C;
+  Vec<T> b;
+  Vec<T> u;
+  Vec<T> l;
+
+  ///// model sizes
+  isize dim;
+  isize n_eq;
+  isize n_in;
+  isize n_total;
+
+  /*!
+   * Default constructor.
+   * @param dim primal variable dimension.
+   * @param n_eq number of equality constraints.
+   * @param n_in number of inequality constraints.
+   */
+  Model(isize dim, isize n_eq, isize n_in)
+    : H(dim, dim)
+    , g(dim)
+    , A(n_eq, dim)
+    , C(n_in, dim)
+    , b(n_eq)
+    , u(n_in)
+    , l(n_in)
+    , dim(dim)
+    , n_eq(n_eq)
+    , n_in(n_in)
+    , n_total(dim + n_eq + n_in)
+  {
+    PROXSUITE_THROW_PRETTY(dim == 0,
+                           std::invalid_argument,
+                           "wrong argument size: the dimension wrt the primal "
+                           "variable x should be strictly positive.");
+
+    const T infinite_bound_value = helpers::infinite_bound<T>::value();
+
+    H.setZero();
+    g.setZero();
+    A.setZero();
+    C.setZero();
+    b.setZero();
+    u.fill(+infinite_bound_value); // in case it appears u is nullopt (i.e., the
+                                   // problem is only lower bounded)
+    l.fill(-infinite_bound_value); // in case it appears l is nullopt (i.e., the
+                                   // problem is only upper bounded)
+  }
+
+  proxsuite::proxqp::sparse::SparseModel<T> to_sparse()
+  {
+    SparseMat<T> H_sparse = H.sparseView();
+    SparseMat<T> A_sparse = A.sparseView();
+    SparseMat<T> C_sparse = C.sparseView();
+    proxsuite::proxqp::sparse::SparseModel<T> res{ H_sparse, g, A_sparse, b,
+                                                   C_sparse, u, l };
+    return res;
+  }
+
+  bool is_valid()
+  {
+#define PROXSUITE_CHECK_SIZE(size, expected_size)                              \
+  if (size != 0) {                                                             \
+    if (!(size == expected_size))                                              \
+      return false;                                                            \
+  }
+
+    // check that all matrices and vectors of qpmodel have the correct size
+    // and that H and C have expected properties
+    PROXSUITE_CHECK_SIZE(g.size(), dim);
+    PROXSUITE_CHECK_SIZE(b.size(), n_eq);
+    PROXSUITE_CHECK_SIZE(u.size(), n_in);
+    PROXSUITE_CHECK_SIZE(l.size(), n_in);
+    if (H.size()) {
+      PROXSUITE_CHECK_SIZE(H.rows(), dim);
+      PROXSUITE_CHECK_SIZE(H.cols(), dim);
+      if (!H.isApprox(H.transpose(), 0.0))
+        return false;
+    }
+    if (A.size()) {
+      PROXSUITE_CHECK_SIZE(A.rows(), n_eq);
+      PROXSUITE_CHECK_SIZE(A.cols(), dim);
+    }
+    if (C.size()) {
+      PROXSUITE_CHECK_SIZE(C.rows(), n_in);
+      PROXSUITE_CHECK_SIZE(C.cols(), dim);
+      if (C.isZero())
+        return false;
+    }
+    return true;
+#undef PROXSUITE_CHECK_SIZE
+  }
+};
+
+template<typename T>
+bool
+operator==(const Model<T>& model1, const Model<T>& model2)
+{
+  bool value = model1.dim == model2.dim && model1.n_eq == model2.n_eq &&
+               model1.n_in == model2.n_in && model1.n_total == model2.n_total &&
+               model1.H == model2.H && model1.g == model2.g &&
+               model1.A == model2.A && model1.b == model2.b &&
+               model1.C == model2.C && model1.l == model2.l &&
+               model1.u == model2.u;
+  return value;
+}
+
+template<typename T>
+bool
+operator!=(const Model<T>& model1, const Model<T>& model2)
+{
+  return !(model1 == model2);
+}
+
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_MODEL_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/solver.hpp

 * *Ordering differences only*

```diff
@@ -1,1330 +1,1330 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file solver.hpp
- */
-
-#ifndef PROXSUITE_PROXQP_DENSE_SOLVER_HPP
-#define PROXSUITE_PROXQP_DENSE_SOLVER_HPP
-
-#include "proxsuite/fwd.hpp"
-#include "proxsuite/proxqp/dense/views.hpp"
-#include "proxsuite/proxqp/dense/linesearch.hpp"
-#include "proxsuite/proxqp/dense/helpers.hpp"
-#include "proxsuite/proxqp/dense/utils.hpp"
-#include <cmath>
-#include <Eigen/Sparse>
-#include <iostream>
-#include <fstream>
-#include <proxsuite/linalg/veg/util/dynstack_alloc.hpp>
-#include <proxsuite/linalg/dense/ldlt.hpp>
-#include <chrono>
-#include <iomanip>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-
-/*!
- * Performs a refactorization of the KKT matrix used by the solver.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- * @param rho_new new primal proximal parameter used for the refactorization.
- */
-template<typename T>
-void
-refactorize(const Model<T>& qpmodel,
-            Results<T>& qpresults,
-            Workspace<T>& qpwork,
-            T rho_new)
-{
-
-  if (!qpwork.constraints_changed && rho_new == qpresults.info.rho) {
-    return;
-  }
-
-  qpwork.dw_aug.setZero();
-  qpwork.kkt.diagonal().head(qpmodel.dim).array() +=
-    rho_new - qpresults.info.rho;
-  qpwork.kkt.diagonal().segment(qpmodel.dim, qpmodel.n_eq).array() =
-    -qpresults.info.mu_eq;
-
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
-  };
-  qpwork.ldl.factorize(qpwork.kkt.transpose(), stack);
-
-  isize n = qpmodel.dim;
-  isize n_eq = qpmodel.n_eq;
-  isize n_in = qpmodel.n_in;
-  isize n_c = qpwork.n_c;
-
-  LDLT_TEMP_MAT(T, new_cols, n + n_eq + n_c, n_c, stack);
-  T mu_in_neg = -qpresults.info.mu_in;
-  for (isize i = 0; i < n_in; ++i) {
-    isize j = qpwork.current_bijection_map[i];
-    if (j < n_c) {
-      auto col = new_cols.col(j);
-      col.head(n) = qpwork.C_scaled.row(i);
-      col.segment(n, n_eq + n_c).setZero();
-      col(n + n_eq + j) = mu_in_neg;
-    }
-  }
-  qpwork.ldl.insert_block_at(n + n_eq, new_cols, stack);
-
-  qpwork.constraints_changed = false;
-
-  qpwork.dw_aug.setZero();
-}
-
-/*!
- * Updates the dual proximal parameters of the solver (i.e., penalization
- * parameters of the primal-dual merit function).
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- * @param mu_eq_new new dual equality constrained proximal parameter.
- * @param mu_in_new new dual inequality constrained proximal parameter.
- */
-template<typename T>
-void
-mu_update(const Model<T>& qpmodel,
-          Results<T>& qpresults,
-          Workspace<T>& qpwork,
-          T mu_eq_new,
-          T mu_in_new)
-{
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
-  };
-
-  isize n = qpmodel.dim;
-  isize n_eq = qpmodel.n_eq;
-  isize n_c = qpwork.n_c;
-
-  if ((n_eq + n_c) == 0) {
-    return;
-  }
-
-  LDLT_TEMP_VEC_UNINIT(T, rank_update_alpha, n_eq + n_c, stack);
-  rank_update_alpha.head(n_eq).setConstant(qpresults.info.mu_eq - mu_eq_new);
-  rank_update_alpha.tail(n_c).setConstant(qpresults.info.mu_in - mu_in_new);
-
-  {
-    auto _indices = stack.make_new_for_overwrite(
-      proxsuite::linalg::veg::Tag<isize>{}, n_eq + n_c);
-    isize* indices = _indices.ptr_mut();
-    for (isize k = 0; k < n_eq; ++k) {
-      indices[k] = n + k;
-    }
-    for (isize k = 0; k < n_c; ++k) {
-      indices[n_eq + k] = n + n_eq + k;
-    }
-    qpwork.ldl.diagonal_update_clobber_indices(
-      indices, n_eq + n_c, rank_update_alpha, stack);
-  }
-
-  qpwork.constraints_changed = true;
-}
-/*!
- * Derives the residual of the iterative refinement algorithm used for solving
- * associated linear systems of PROXQP algorithm.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- * @param inner_pb_dim dimension of the linear system.
- */
-template<typename T>
-void
-iterative_residual(const Model<T>& qpmodel,
-                   Results<T>& qpresults,
-                   Workspace<T>& qpwork,
-                   isize inner_pb_dim)
-{
-
-  qpwork.err.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
-
-  qpwork.err.head(qpmodel.dim).noalias() -=
-    qpwork.H_scaled.template selfadjointView<Eigen::Lower>() *
-    qpwork.dw_aug.head(qpmodel.dim);
-  qpwork.err.head(qpmodel.dim) -=
-    qpresults.info.rho * qpwork.dw_aug.head(qpmodel.dim);
-
-  // PERF: fuse {A, C}_scaled multiplication operations
-  qpwork.err.head(qpmodel.dim).noalias() -=
-    qpwork.A_scaled.transpose() *
-    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
-  for (isize i = 0; i < qpmodel.n_in; i++) {
-    isize j = qpwork.current_bijection_map(i);
-    if (j < qpwork.n_c) {
-      qpwork.err.head(qpmodel.dim).noalias() -=
-        qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + j) * qpwork.C_scaled.row(i);
-      qpwork.err(qpmodel.dim + qpmodel.n_eq + j) -=
-        (qpwork.C_scaled.row(i).dot(qpwork.dw_aug.head(qpmodel.dim)) -
-         qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + j) * qpresults.info.mu_in);
-    }
-  }
-  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq).noalias() -=
-    qpwork.A_scaled * qpwork.dw_aug.head(qpmodel.dim);
-  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) +=
-    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq) * qpresults.info.mu_eq;
-}
-/*!
- * Performs iterative refinement for solving associated linear systems of PROXQP
- * algorithm.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param eps accuracy required for pursuing or not the iterative refinement.
- * @param inner_pb_dim dimension of the linear system.
- */
-template<typename T>
-void
-iterative_solve_with_permut_fact( //
-  const Settings<T>& qpsettings,
-  const Model<T>& qpmodel,
-  Results<T>& qpresults,
-  Workspace<T>& qpwork,
-  T eps,
-  isize inner_pb_dim)
-{
-
-  qpwork.err.setZero();
-  i32 it = 0;
-  i32 it_stability = 0;
-
-  qpwork.dw_aug.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
-  proxsuite::linalg::veg::dynstack::DynStackMut stack{
-    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
-  };
-  qpwork.ldl.solve_in_place(qpwork.dw_aug.head(inner_pb_dim), stack);
-
-  iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
-
-  ++it;
-  T preverr = infty_norm(qpwork.err.head(inner_pb_dim));
-  /* to put in debuger mode
-  if (qpsettings.verbose) {
-          std::cout << "infty_norm(res) " <<
-  infty_norm(qpwork.err.head(inner_pb_dim))
-                                                  << std::endl;
-  }
-  */
-  while (infty_norm(qpwork.err.head(inner_pb_dim)) >= eps) {
-
-    if (it >= qpsettings.nb_iterative_refinement) {
-      break;
-    }
-
-    ++it;
-    qpwork.ldl.solve_in_place(qpwork.err.head(inner_pb_dim), stack);
-    qpwork.dw_aug.head(inner_pb_dim) += qpwork.err.head(inner_pb_dim);
-
-    qpwork.err.head(inner_pb_dim).setZero();
-    iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
-
-    if (infty_norm(qpwork.err.head(inner_pb_dim)) > preverr) {
-      it_stability += 1;
-
-    } else {
-      it_stability = 0;
-    }
-    if (it_stability == 2) {
-      break;
-    }
-    preverr = infty_norm(qpwork.err.head(inner_pb_dim));
-    /* to put in debug mode
-    if (qpsettings.verbose) {
-            std::cout << "infty_norm(res) "
-                                                    <<
-    infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
-    }
-    */
-  }
-
-  if (infty_norm(qpwork.err.head(inner_pb_dim)) >=
-      std::max(eps, qpsettings.eps_refact)) {
-    refactorize(qpmodel, qpresults, qpwork, qpresults.info.rho);
-    it = 0;
-    it_stability = 0;
-
-    qpwork.dw_aug.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
-    qpwork.ldl.solve_in_place(qpwork.dw_aug.head(inner_pb_dim), stack);
-
-    iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
-
-    preverr = infty_norm(qpwork.err.head(inner_pb_dim));
-    ++it;
-    /* to put in debug mode
-    if (qpsettings.verbose) {
-            std::cout << "infty_norm(res) "
-                                                    <<
-    infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
-    }
-    */
-    while (infty_norm(qpwork.err.head(inner_pb_dim)) >= eps) {
-
-      if (it >= qpsettings.nb_iterative_refinement) {
-        break;
-      }
-      ++it;
-      qpwork.ldl.solve_in_place(qpwork.err.head(inner_pb_dim), stack);
-      qpwork.dw_aug.head(inner_pb_dim) += qpwork.err.head(inner_pb_dim);
-
-      qpwork.err.head(inner_pb_dim).setZero();
-      iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
-
-      if (infty_norm(qpwork.err.head(inner_pb_dim)) > preverr) {
-        it_stability += 1;
-
-      } else {
-        it_stability = 0;
-      }
-      if (it_stability == 2) {
-        break;
-      }
-      preverr = infty_norm(qpwork.err.head(inner_pb_dim));
-      /* to put in debug mode
-      if (qpsettings.verbose) {
-              std::cout << "infty_norm(res) "
-                                                      <<
-      infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
-      }
-      */
-    }
-  }
-  qpwork.rhs.head(inner_pb_dim).setZero();
-}
-/*!
- * BCL rule for updating penalization parameters and accuracy variables.
- *
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param primal_feasibility_lhs_new primal infeasibility.
- * @param bcl_eta_ext BCL variable measuring whether the precisely infeasibility
- * is too large or not.
- * @param bcl_eta_in BCL variable setting the accuracy required for solving an
- * associated subproblem.
- * @param bcl_eta_ext_init initial BCL bcl_eta_ext variable value.
- * @param eps_in_min minimal possible value for bcl_eta_in.
- * @param new_bcl_mu_in new value of the inequality constrained penalization
- * parameter.
- * @param new_bcl_mu_eq new value of the equality constrained penalization
- * parameter.
- * @param new_bcl_mu_in_inv new value of the inequality constrained penalization
- * parameter (inverse form).
- * @param new_bcl_mu_eq_inv new value of the equality constrained penalization
- * parameter (inverse form).
- */
-template<typename T>
-void
-bcl_update(const Settings<T>& qpsettings,
-           Results<T>& qpresults,
-           Workspace<T>& qpwork,
-           T& primal_feasibility_lhs_new,
-           T& bcl_eta_ext,
-           T& bcl_eta_in,
-
-           T bcl_eta_ext_init,
-           T eps_in_min,
-
-           T& new_bcl_mu_in,
-           T& new_bcl_mu_eq,
-           T& new_bcl_mu_in_inv,
-           T& new_bcl_mu_eq_inv
-
-)
-{
-  if (primal_feasibility_lhs_new <= bcl_eta_ext ||
-      qpresults.info.iter > qpsettings.safe_guard) {
-    /* TO PUT IN DEBUG MODE
-    if (qpsettings.verbose) {
-            std::cout << "good step" << std::endl;
-    }
-    */
-    bcl_eta_ext *= pow(qpresults.info.mu_in, qpsettings.beta_bcl);
-    bcl_eta_in = std::max(bcl_eta_in * qpresults.info.mu_in, eps_in_min);
-  } else {
-    /* TO PUT IN DEBUG MODE
-    if (qpsettings.verbose) {
-            std::cout << "bad step" << std::endl;
-    }
-    */
-    qpresults.y = qpwork.y_prev;
-    qpresults.z = qpwork.z_prev;
-
-    new_bcl_mu_in = std::max(qpresults.info.mu_in * qpsettings.mu_update_factor,
-                             qpsettings.mu_min_in);
-    new_bcl_mu_eq = std::max(qpresults.info.mu_eq * qpsettings.mu_update_factor,
-                             qpsettings.mu_min_eq);
-    new_bcl_mu_in_inv =
-      std::min(qpresults.info.mu_in_inv * qpsettings.mu_update_inv_factor,
-               qpsettings.mu_max_in_inv);
-    new_bcl_mu_eq_inv =
-      std::min(qpresults.info.mu_eq_inv * qpsettings.mu_update_inv_factor,
-               qpsettings.mu_max_eq_inv);
-    bcl_eta_ext = bcl_eta_ext_init * pow(new_bcl_mu_in, qpsettings.alpha_bcl);
-    bcl_eta_in = std::max(new_bcl_mu_in, eps_in_min);
-  }
-}
-/*!
- * Martinez rule for updating penalization parameters and accuracy variables.
- *
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param primal_feasibility_lhs_new primal infeasibility.
- * @param bcl_eta_ext BCL variable measuring whether the precisely infeasibility
- * is too large or not.
- * @param bcl_eta_in BCL variable setting the accuracy required for solving an
- * associated subproblem.
- * @param bcl_eta_ext_init initial BCL bcl_eta_ext variable value.
- * @param eps_in_min minimal possible value for bcl_eta_in.
- * @param new_bcl_mu_in new value of the inequality constrained penalization
- * parameter.
- * @param new_bcl_mu_eq new value of the equality constrained penalization
- * parameter.
- * @param new_bcl_mu_in_inv new value of the inequality constrained penalization
- * parameter (inverse form).
- * @param new_bcl_mu_eq_inv new value of the equality constrained penalization
- * parameter (inverse form).
- */
-template<typename T>
-void
-Martinez_update(const Settings<T>& qpsettings,
-                Results<T>& qpresults,
-                T& primal_feasibility_lhs_new,
-                T& primal_feasibility_lhs_old,
-                T& bcl_eta_in,
-                T eps_in_min,
-
-                T& new_bcl_mu_in,
-                T& new_bcl_mu_eq,
-                T& new_bcl_mu_in_inv,
-                T& new_bcl_mu_eq_inv
-
-)
-{
-  bcl_eta_in = std::max(bcl_eta_in * 0.1, eps_in_min);
-  if (primal_feasibility_lhs_new <= 0.95 * primal_feasibility_lhs_old) {
-    /* TO PUT IN DEBUG MODE
-    if (qpsettings.verbose) {
-            std::cout << "good step" << std::endl;
-    }
-    */
-  } else {
-    /* TO PUT IN DEBUG MODE
-    if (qpsettings.verbose) {
-            std::cout << "bad step" << std::endl;
-    }
-    */
-    new_bcl_mu_in = std::max(qpresults.info.mu_in * qpsettings.mu_update_factor,
-                             qpsettings.mu_min_in);
-    new_bcl_mu_eq = std::max(qpresults.info.mu_eq * qpsettings.mu_update_factor,
-                             qpsettings.mu_min_eq);
-    new_bcl_mu_in_inv =
-      std::min(qpresults.info.mu_in_inv * qpsettings.mu_update_inv_factor,
-               qpsettings.mu_max_in_inv);
-    new_bcl_mu_eq_inv =
-      std::min(qpresults.info.mu_eq_inv * qpsettings.mu_update_inv_factor,
-               qpsettings.mu_max_eq_inv);
-  }
-}
-/*!
- * Derives the stopping criterion value used by the Newton semismooth algorithm
- * to minimize the primal-dual augmented Lagrangian function.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- */
-template<typename T>
-auto
-compute_inner_loop_saddle_point(const Model<T>& qpmodel,
-                                Results<T>& qpresults,
-                                Workspace<T>& qpwork) -> T
-{
-
-  qpwork.active_part_z =
-    helpers::positive_part(qpwork.primal_residual_in_scaled_up) +
-    helpers::negative_part(qpwork.primal_residual_in_scaled_low) -
-    qpresults.z * qpresults.info.mu_in; // contains now : [Cx-u+z_prev*mu_in]+
-                                        // + [Cx-l+z_prev*mu_in]- - z*mu_in
-
-  T err = infty_norm(qpwork.active_part_z);
-  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) =
-    qpwork.primal_residual_eq_scaled; // contains now Ax-b-(y-y_prev)/mu
-
-  T prim_eq_e = infty_norm(
-    qpwork.err.segment(qpmodel.dim, qpmodel.n_eq)); // ||Ax-b-(y-y_prev)/mu||
-  err = std::max(err, prim_eq_e);
-  T dual_e =
-    infty_norm(qpwork.dual_residual_scaled); // contains ||Hx + rho(x-xprev) +
-                                             // g + Aty + Ctz||
-  err = std::max(err, dual_e);
-
-  return err;
-}
-/*!
- * Derives the Newton semismooth step.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param eps accuracy required for solving the subproblem.
- */
-template<typename T>
-void
-primal_dual_semi_smooth_newton_step(const Settings<T>& qpsettings,
-                                    const Model<T>& qpmodel,
-                                    Results<T>& qpresults,
-                                    Workspace<T>& qpwork,
-                                    T eps)
-{
-
-  /* MUST BE
-   *  dual_residual_scaled = Hx + rho * (x-x_prev) + A.T y + C.T z
-   *  primal_residual_eq_scaled = Ax-b+mu_eq (y_prev-y)
-   *  primal_residual_in_scaled_up = Cx-u+mu_in(z_prev)
-   *  primal_residual_in_scaled_low = Cx-l+mu_in(z_prev)
-   */
-
-  qpwork.active_set_up.array() =
-    (qpwork.primal_residual_in_scaled_up.array() >= 0);
-  qpwork.active_set_low.array() =
-    (qpwork.primal_residual_in_scaled_low.array() <= 0);
-  qpwork.active_inequalities = qpwork.active_set_up || qpwork.active_set_low;
-  isize numactive_inequalities = qpwork.active_inequalities.count();
-
-  isize inner_pb_dim = qpmodel.dim + qpmodel.n_eq + numactive_inequalities;
-  qpwork.rhs.setZero();
-  qpwork.dw_aug.setZero();
-
-  linesearch::active_set_change(qpmodel, qpresults, qpwork);
-
-  qpwork.rhs.head(qpmodel.dim) = -qpwork.dual_residual_scaled;
-
-  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) =
-    -qpwork.primal_residual_eq_scaled;
-  for (isize i = 0; i < qpmodel.n_in; i++) {
-    isize j = qpwork.current_bijection_map(i);
-    if (j < qpwork.n_c) {
-      if (qpwork.active_set_up(i)) {
-        qpwork.rhs(j + qpmodel.dim + qpmodel.n_eq) =
-          -qpwork.primal_residual_in_scaled_up(i) +
-          qpresults.z(i) * qpresults.info.mu_in;
-      } else if (qpwork.active_set_low(i)) {
-        qpwork.rhs(j + qpmodel.dim + qpmodel.n_eq) =
-          -qpwork.primal_residual_in_scaled_low(i) +
-          qpresults.z(i) * qpresults.info.mu_in;
-      }
-    } else {
-      qpwork.rhs.head(qpmodel.dim) +=
-        qpresults.z(i) * qpwork.C_scaled.row(i); // unactive unrelevant columns
-    }
-  }
-
-  iterative_solve_with_permut_fact( //
-    qpsettings,
-    qpmodel,
-    qpresults,
-    qpwork,
-    eps,
-    inner_pb_dim);
-
-  // use active_part_z as a temporary variable to derive unpermutted dz step
-  for (isize j = 0; j < qpmodel.n_in; ++j) {
-    isize i = qpwork.current_bijection_map(j);
-    if (i < qpwork.n_c) {
-      qpwork.active_part_z(j) = qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + i);
-    } else {
-      qpwork.active_part_z(j) = -qpresults.z(j);
-    }
-  }
-  qpwork.dw_aug.tail(qpmodel.n_in) = qpwork.active_part_z;
-}
-/*!
- * Performs the Newton semismooth algorithm to minimize the primal-dual
- * augmented Lagrangian function used by PROXQP algorithm.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param ruiz ruiz preconditioner.
- * @param eps_int accuracy required for solving the subproblem.
- */
-template<typename T>
-void
-primal_dual_newton_semi_smooth(const Settings<T>& qpsettings,
-                               const Model<T>& qpmodel,
-                               Results<T>& qpresults,
-                               Workspace<T>& qpwork,
-                               preconditioner::RuizEquilibration<T>& ruiz,
-                               T eps_int)
-{
-
-  /* MUST CONTAIN IN ENTRY WITH x = x_prev ; y = y_prev ; z = z_prev
-   *  dual_residual_scaled = Hx + rho * (x-x_prev) + A.T y + C.T z
-   *  primal_residual_eq_scaled = Ax-b+mu_eq (y_prev-y)
-   *  primal_residual_in_scaled_up = Cx-u+mu_in(z_prev)
-   *  primal_residual_in_scaled_low = Cx-l+mu_in(z_prev)
-   */
-  /* for debug
-  if (qpsettings.verbose) {
-          std::cout << "---- inner iteration    inner error    alpha ----" <<
-  std::endl;
-  }
-  */
-  T err_in = 1.e6;
-
-  for (i64 iter = 0; iter <= qpsettings.max_iter_in; ++iter) {
-
-    if (iter == qpsettings.max_iter_in) {
-      qpresults.info.iter += qpsettings.max_iter_in + 1;
-      break;
-    }
-    primal_dual_semi_smooth_newton_step<T>(
-      qpsettings, qpmodel, qpresults, qpwork, eps_int);
-
-    proxsuite::linalg::veg::dynstack::DynStackMut stack{
-      proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
-    };
-    LDLT_TEMP_VEC(T, ATdy, qpmodel.dim, stack);
-    LDLT_TEMP_VEC(T, CTdz, qpmodel.dim, stack);
-
-    auto& Hdx = qpwork.Hdx;
-    auto& Adx = qpwork.Adx;
-    auto& Cdx = qpwork.Cdx;
-
-    auto dx = qpwork.dw_aug.head(qpmodel.dim);
-    auto dy = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
-    auto dz = qpwork.dw_aug.segment(qpmodel.dim + qpmodel.n_eq, qpmodel.n_in);
-
-    Hdx.setZero();
-    Adx.setZero();
-    Cdx.setZero();
-
-    Hdx.noalias() +=
-      qpwork.H_scaled.template selfadjointView<Eigen::Lower>() * dx;
-
-    Adx.noalias() += qpwork.A_scaled * dx;
-    ATdy.noalias() += qpwork.A_scaled.transpose() * dy;
-
-    Cdx.noalias() += qpwork.C_scaled * dx;
-    CTdz.noalias() += qpwork.C_scaled.transpose() * dz;
-
-    if (qpmodel.n_in > 0) {
-      linesearch::primal_dual_ls(qpmodel, qpresults, qpwork);
-    }
-    auto alpha = qpwork.alpha;
-
-    if (infty_norm(alpha * qpwork.dw_aug) < 1.E-11 && iter > 0) {
-      qpresults.info.iter += iter + 1;
-      /* to put in debuger mode
-      if (qpsettings.verbose) {
-              std::cout << "infty_norm(alpha_step * dx) "
-                                                      << infty_norm(alpha *
-      qpwork.dw_aug) << std::endl;
-      }
-      */
-      break;
-    }
-
-    qpresults.x += alpha * dx;
-
-    // contains now :  C(x+alpha dx)-u + z_prev * mu_in
-    qpwork.primal_residual_in_scaled_up += alpha * Cdx;
-
-    // contains now :  C(x+alpha dx)-l + z_prev * mu_in
-    qpwork.primal_residual_in_scaled_low += alpha * Cdx;
-
-    qpwork.primal_residual_eq_scaled +=
-      alpha * (Adx - qpresults.info.mu_eq * dy);
-
-    qpresults.y += alpha * dy;
-    qpresults.z += alpha * dz;
-
-    qpwork.dual_residual_scaled +=
-      alpha * (qpresults.info.rho * dx + Hdx + ATdy + CTdz);
-
-    err_in = dense::compute_inner_loop_saddle_point(qpmodel, qpresults, qpwork);
-    /* for debug
-    if (qpsettings.verbose) {
-            std::cout << "           " << iter << "              " <<
-    std::setprecision(2) << err_in
-                                                    << "         "  << alpha <<
-    std::endl;
-    }
-    */
-    if (qpsettings.verbose) {
-      std::cout << "\033[1;34m[inner iteration " << iter + 1 << "]\033[0m"
-                << std::endl;
-      std::cout << std::scientific << std::setw(2) << std::setprecision(2)
-                << "| inner residual=" << err_in << " | alpha=" << alpha
-                << std::endl;
-    }
-    if (err_in <= eps_int) {
-      qpresults.info.iter += iter + 1;
-      /* for debug
-      if (qpsettings.verbose) {
-              std::cout << "-------------------------------------------------"
-      << std::endl;
-      }
-      */
-      break;
-    }
-
-    // compute primal and dual infeasibility criteria
-    bool is_primal_infeasible =
-      global_primal_residual_infeasibility(VectorViewMut<T>{ from_eigen, ATdy },
-                                           VectorViewMut<T>{ from_eigen, CTdz },
-                                           VectorViewMut<T>{ from_eigen, dy },
-                                           VectorViewMut<T>{ from_eigen, dz },
-                                           qpwork,
-                                           qpsettings,
-                                           ruiz);
-
-    bool is_dual_infeasible =
-      global_dual_residual_infeasibility(VectorViewMut<T>{ from_eigen, Adx },
-                                         VectorViewMut<T>{ from_eigen, Cdx },
-                                         VectorViewMut<T>{ from_eigen, Hdx },
-                                         VectorViewMut<T>{ from_eigen, dx },
-                                         qpwork,
-                                         qpsettings,
-                                         qpmodel,
-                                         ruiz);
-
-    if (is_primal_infeasible) {
-      qpresults.info.status = QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE;
-      /* for debug
-      if (qpsettings.verbose) {
-              std::cout << "-------------------------------------------------"
-      << std::endl;
-      }
-      */
-      break;
-    } else if (is_dual_infeasible) {
-      qpresults.info.status = QPSolverOutput::PROXQP_DUAL_INFEASIBLE;
-      /* for debug
-      if (qpsettings.verbose) {
-              std::cout << "-------------------------------------------------"
-      << std::endl;
-      }
-      */
-      break;
-    }
-  }
-  /* to put in debuger mode
-  if (qpsettings.verbose) {
-    if (err_in > eps_int){
-          std::cout << " inner loop residual is to high! Its value is equal to "
-  << err_in << ", while it should be inferior to: "  << eps_int << std::endl;
-    }
-  }
-  */
-}
-/*!
- * Executes the PROXQP algorithm.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpsettings solver settings.
- * @param qpresults solver results.
- * @param ruiz ruiz preconditioner.
- */
-template<typename T>
-void
-qp_solve( //
-  const Settings<T>& qpsettings,
-  const Model<T>& qpmodel,
-  Results<T>& qpresults,
-  Workspace<T>& qpwork,
-  preconditioner::RuizEquilibration<T>& ruiz)
-{
-  /*** TEST WITH MATRIX FULL OF NAN FOR DEBUG
-    static constexpr Layout layout = rowmajor;
-    static constexpr auto DYN = Eigen::Dynamic;
-  using RowMat = Eigen::Matrix<T, DYN, DYN, Eigen::RowMajor>;
-  RowMat test(2,2); // test it is full of nan for debug
-  std::cout << "test " << test << std::endl;
-  */
-  PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED();
-
-  if (qpsettings.compute_timings) {
-    qpwork.timer.stop();
-    qpwork.timer.start();
-  }
-  if (qpsettings.verbose) {
-    dense::print_setup_header(qpsettings, qpresults, qpmodel);
-  }
-  if (qpwork.dirty) { // the following is used when a solve has already been
-                      // executed (and without any intermediary model update)
-    switch (qpsettings.initial_guess) {
-      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-        qpwork.cleanup();
-        qpresults.cleanup(qpsettings);
-        break;
-      }
-      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-        // keep solutions but restart workspace and results
-        qpwork.cleanup();
-        qpresults.cold_start(qpsettings);
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, qpresults.x });
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        break;
-      }
-      case InitialGuessStatus::NO_INITIAL_GUESS: {
-        qpwork.cleanup();
-        qpresults.cleanup(qpsettings);
-        break;
-      }
-      case InitialGuessStatus::WARM_START: {
-        qpwork.cleanup();
-        qpresults.cold_start(
-          qpsettings); // because there was already a solve,
-                       // precond was already computed if set so
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            qpresults
-              .x }); // it contains the value given in entry for warm start
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        break;
-      }
-      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-        // keep workspace and results solutions except statistics
-        qpresults.cleanup_statistics();
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, qpresults.x });
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        break;
-      }
-    }
-    if (qpsettings.initial_guess !=
-        InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT) {
-      qpwork.H_scaled = qpmodel.H;
-      qpwork.g_scaled = qpmodel.g;
-      qpwork.A_scaled = qpmodel.A;
-      qpwork.b_scaled = qpmodel.b;
-      qpwork.C_scaled = qpmodel.C;
-      qpwork.u_scaled = qpmodel.u;
-      qpwork.l_scaled = qpmodel.l;
-      proxsuite::proxqp::dense::setup_equilibration(
-        qpwork, qpsettings, ruiz, false); // reuse previous equilibration
-      proxsuite::proxqp::dense::setup_factorization(qpwork, qpmodel, qpresults);
-    }
-    switch (qpsettings.initial_guess) {
-      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-        compute_equality_constrained_initial_guess(
-          qpwork, qpsettings, qpmodel, qpresults);
-        break;
-      }
-      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-        //!\ TODO in a quicker way
-        qpwork.n_c = 0;
-        for (isize i = 0; i < qpmodel.n_in; i++) {
-          if (qpresults.z[i] != 0) {
-            qpwork.active_inequalities[i] = true;
-          } else {
-            qpwork.active_inequalities[i] = false;
-          }
-        }
-        linesearch::active_set_change(qpmodel, qpresults, qpwork);
-        break;
-      }
-      case InitialGuessStatus::NO_INITIAL_GUESS: {
-        break;
-      }
-      case InitialGuessStatus::WARM_START: {
-        //!\ TODO in a quicker way
-        qpwork.n_c = 0;
-        for (isize i = 0; i < qpmodel.n_in; i++) {
-          if (qpresults.z[i] != 0) {
-            qpwork.active_inequalities[i] = true;
-          } else {
-            qpwork.active_inequalities[i] = false;
-          }
-        }
-        linesearch::active_set_change(qpmodel, qpresults, qpwork);
-        break;
-      }
-      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-        // keep workspace and results solutions except statistics
-
-        // meaningful for when one wants to warm start with previous result with
-        // the same QP model
-        break;
-      }
-    }
-  } else { // the following is used for a first solve after initializing or
-           // updating the Qp object
-    switch (qpsettings.initial_guess) {
-      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-        proxsuite::proxqp::dense::setup_factorization(
-          qpwork, qpmodel, qpresults);
-        compute_equality_constrained_initial_guess(
-          qpwork, qpsettings, qpmodel, qpresults);
-        break;
-      }
-      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-        //!\ TODO in a quicker way
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            qpresults
-              .x }); // meaningful for when there is an upate of the model and
-                     // one wants to warm start with previous result
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        setup_factorization(qpwork, qpmodel, qpresults);
-        qpwork.n_c = 0;
-        for (isize i = 0; i < qpmodel.n_in; i++) {
-          if (qpresults.z[i] != 0) {
-            qpwork.active_inequalities[i] = true;
-          } else {
-            qpwork.active_inequalities[i] = false;
-          }
-        }
-        linesearch::active_set_change(qpmodel, qpresults, qpwork);
-        break;
-      }
-      case InitialGuessStatus::NO_INITIAL_GUESS: {
-        setup_factorization(qpwork, qpmodel, qpresults);
-        break;
-      }
-      case InitialGuessStatus::WARM_START: {
-        //!\ TODO in a quicker way
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, qpresults.x });
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        setup_factorization(qpwork, qpmodel, qpresults);
-        qpwork.n_c = 0;
-        for (isize i = 0; i < qpmodel.n_in; i++) {
-          if (qpresults.z[i] != 0) {
-            qpwork.active_inequalities[i] = true;
-          } else {
-            qpwork.active_inequalities[i] = false;
-          }
-        }
-        linesearch::active_set_change(qpmodel, qpresults, qpwork);
-        break;
-      }
-      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-
-        ruiz.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            qpresults
-              .x }); // meaningful for when there is an upate of the model and
-                     // one wants to warm start with previous result
-        ruiz.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, qpresults.y });
-        ruiz.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, qpresults.z });
-        if (qpwork.refactorize) { // refactorization only when one of the
-                                  // matrices has changed or one proximal
-                                  // parameter has changed
-          setup_factorization(qpwork, qpmodel, qpresults);
-          qpwork.n_c = 0;
-          for (isize i = 0; i < qpmodel.n_in; i++) {
-            if (qpresults.z[i] != 0) {
-              qpwork.active_inequalities[i] = true;
-            } else {
-              qpwork.active_inequalities[i] = false;
-            }
-          }
-          linesearch::active_set_change(qpmodel, qpresults, qpwork);
-          break;
-        }
-      }
-    }
-  }
-
-  T bcl_eta_ext_init = pow(T(0.1), qpsettings.alpha_bcl);
-  T bcl_eta_ext = bcl_eta_ext_init;
-  T bcl_eta_in(1);
-  T eps_in_min = std::min(qpsettings.eps_abs, T(1.E-9));
-
-  T primal_feasibility_eq_rhs_0(0);
-  T primal_feasibility_in_rhs_0(0);
-  T dual_feasibility_rhs_0(0);
-  T dual_feasibility_rhs_1(0);
-  T dual_feasibility_rhs_3(0);
-  T primal_feasibility_lhs(0);
-  T primal_feasibility_eq_lhs(0);
-  T primal_feasibility_in_lhs(0);
-  T dual_feasibility_lhs(0);
-
-  T duality_gap(0);
-  T rhs_duality_gap(0);
-
-  for (i64 iter = 0; iter < qpsettings.max_iter; ++iter) {
-
-    // compute primal residual
-
-    // PERF: fuse matrix product computations in global_{primal, dual}_residual
-    global_primal_residual(qpmodel,
-                           qpresults,
-                           qpwork,
-                           ruiz,
-                           primal_feasibility_lhs,
-                           primal_feasibility_eq_rhs_0,
-                           primal_feasibility_in_rhs_0,
-                           primal_feasibility_eq_lhs,
-                           primal_feasibility_in_lhs);
-
-    global_dual_residual(qpresults,
-                         qpwork,
-                         qpmodel,
-                         ruiz,
-                         dual_feasibility_lhs,
-                         dual_feasibility_rhs_0,
-                         dual_feasibility_rhs_1,
-                         dual_feasibility_rhs_3,
-                         rhs_duality_gap,
-                         duality_gap);
-    qpresults.info.pri_res = primal_feasibility_lhs;
-    qpresults.info.dua_res = dual_feasibility_lhs;
-    qpresults.info.duality_gap = duality_gap;
-
-    T new_bcl_mu_in(qpresults.info.mu_in);
-    T new_bcl_mu_eq(qpresults.info.mu_eq);
-    T new_bcl_mu_in_inv(qpresults.info.mu_in_inv);
-    T new_bcl_mu_eq_inv(qpresults.info.mu_eq_inv);
-
-    T rhs_pri(qpsettings.eps_abs);
-    if (qpsettings.eps_rel != 0) {
-      rhs_pri += qpsettings.eps_rel * std::max(primal_feasibility_eq_rhs_0,
-                                               primal_feasibility_in_rhs_0);
-    }
-    bool is_primal_feasible = primal_feasibility_lhs <= rhs_pri;
-
-    T rhs_dua(qpsettings.eps_abs);
-    if (qpsettings.eps_rel != 0) {
-      rhs_dua +=
-        qpsettings.eps_rel *
-        std::max(
-          std::max(dual_feasibility_rhs_3, dual_feasibility_rhs_0),
-          std::max(dual_feasibility_rhs_1, qpwork.dual_feasibility_rhs_2));
-    }
-
-    bool is_dual_feasible = dual_feasibility_lhs <= rhs_dua;
-
-    if (qpsettings.verbose) {
-
-      ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
-      ruiz.unscale_dual_in_place_eq(
-        VectorViewMut<T>{ from_eigen, qpresults.y });
-      ruiz.unscale_dual_in_place_in(
-        VectorViewMut<T>{ from_eigen, qpresults.z });
-
-      {
-        // EigenAllowAlloc _{};
-        qpresults.info.objValue = 0;
-        for (Eigen::Index j = 0; j < qpmodel.dim; ++j) {
-          qpresults.info.objValue +=
-            0.5 * (qpresults.x(j) * qpresults.x(j)) * qpmodel.H(j, j);
-          qpresults.info.objValue +=
-            qpresults.x(j) * T(qpmodel.H.col(j)
-                                 .tail(qpmodel.dim - j - 1)
-                                 .dot(qpresults.x.tail(qpmodel.dim - j - 1)));
-        }
-        qpresults.info.objValue += (qpmodel.g).dot(qpresults.x);
-      }
-      std::cout << "\033[1;32m[outer iteration " << iter + 1 << "]\033[0m"
-                << std::endl;
-      std::cout << std::scientific << std::setw(2) << std::setprecision(2)
-                << "| primal residual=" << qpresults.info.pri_res
-                << " | dual residual=" << qpresults.info.dua_res
-                << " | duality gap=" << qpresults.info.duality_gap
-                << " | mu_in=" << qpresults.info.mu_in
-                << " | rho=" << qpresults.info.rho << std::endl;
-      ruiz.scale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
-      ruiz.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
-      ruiz.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
-    }
-    if (is_primal_feasible && is_dual_feasible) {
-      if (qpsettings.check_duality_gap) {
-        if (std::fabs(qpresults.info.duality_gap) <=
-            qpsettings.eps_duality_gap_abs +
-              qpsettings.eps_duality_gap_rel * rhs_duality_gap) {
-          qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
-          break;
-        }
-      } else {
-        qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
-        break;
-      }
-    }
-    qpresults.info.iter_ext += 1; // We start a new external loop update
-
-    qpwork.x_prev = qpresults.x;
-    qpwork.y_prev = qpresults.y;
-    qpwork.z_prev = qpresults.z;
-
-    // primal dual version from gill and robinson
-
-    ruiz.scale_primal_residual_in_place_in(VectorViewMut<T>{
-      from_eigen,
-      qpwork.primal_residual_in_scaled_up }); // contains now scaled(Cx)
-    qpwork.primal_residual_in_scaled_up +=
-      qpwork.z_prev *
-      qpresults.info.mu_in; // contains now scaled(Cx+z_prev*mu_in)
-    qpwork.primal_residual_in_scaled_low = qpwork.primal_residual_in_scaled_up;
-    qpwork.primal_residual_in_scaled_up -=
-      qpwork.u_scaled; // contains now scaled(Cx-u+z_prev*mu_in)
-    qpwork.primal_residual_in_scaled_low -=
-      qpwork.l_scaled; // contains now scaled(Cx-l+z_prev*mu_in)
-
-    primal_dual_newton_semi_smooth(
-      qpsettings, qpmodel, qpresults, qpwork, ruiz, bcl_eta_in);
-
-    if (qpresults.info.status == QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE ||
-        qpresults.info.status == QPSolverOutput::PROXQP_DUAL_INFEASIBLE) {
-      // certificate of infeasibility
-      qpresults.x = qpwork.dw_aug.head(qpmodel.dim);
-      qpresults.y = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
-      qpresults.z = qpwork.dw_aug.tail(qpmodel.n_in);
-      break;
-    }
-
-    T primal_feasibility_lhs_new(primal_feasibility_lhs);
-
-    global_primal_residual(qpmodel,
-                           qpresults,
-                           qpwork,
-                           ruiz,
-                           primal_feasibility_lhs_new,
-                           primal_feasibility_eq_rhs_0,
-                           primal_feasibility_in_rhs_0,
-                           primal_feasibility_eq_lhs,
-                           primal_feasibility_in_lhs);
-
-    is_primal_feasible =
-      primal_feasibility_lhs_new <=
-      (qpsettings.eps_abs +
-       qpsettings.eps_rel *
-         std::max(primal_feasibility_eq_rhs_0, primal_feasibility_in_rhs_0));
-    qpresults.info.pri_res = primal_feasibility_lhs_new;
-    if (is_primal_feasible) {
-      T dual_feasibility_lhs_new(dual_feasibility_lhs);
-
-      global_dual_residual(qpresults,
-                           qpwork,
-                           qpmodel,
-                           ruiz,
-                           dual_feasibility_lhs_new,
-                           dual_feasibility_rhs_0,
-                           dual_feasibility_rhs_1,
-                           dual_feasibility_rhs_3,
-                           rhs_duality_gap,
-                           duality_gap);
-      qpresults.info.dua_res = dual_feasibility_lhs_new;
-      qpresults.info.duality_gap = duality_gap;
-
-      is_dual_feasible =
-        dual_feasibility_lhs_new <=
-        (qpsettings.eps_abs +
-         qpsettings.eps_rel *
-           std::max(
-             std::max(dual_feasibility_rhs_3, dual_feasibility_rhs_0),
-             std::max(dual_feasibility_rhs_1, qpwork.dual_feasibility_rhs_2)));
-
-      if (is_dual_feasible) {
-        if (qpsettings.check_duality_gap) {
-          if (std::fabs(qpresults.info.duality_gap) <=
-              qpsettings.eps_duality_gap_abs +
-                qpsettings.eps_duality_gap_rel * rhs_duality_gap) {
-            qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
-            break;
-          }
-        } else {
-          qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
-          break;
-        }
-      }
-    }
-    if (qpsettings.bcl_update) {
-      bcl_update(qpsettings,
-                 qpresults,
-                 qpwork,
-                 primal_feasibility_lhs_new,
-                 bcl_eta_ext,
-                 bcl_eta_in,
-                 bcl_eta_ext_init,
-                 eps_in_min,
-
-                 new_bcl_mu_in,
-                 new_bcl_mu_eq,
-                 new_bcl_mu_in_inv,
-                 new_bcl_mu_eq_inv);
-    } else {
-      Martinez_update(qpsettings,
-                      qpresults,
-                      primal_feasibility_lhs_new,
-                      primal_feasibility_lhs,
-                      bcl_eta_in,
-                      eps_in_min,
-                      new_bcl_mu_in,
-                      new_bcl_mu_eq,
-                      new_bcl_mu_in_inv,
-                      new_bcl_mu_eq_inv);
-    }
-    // COLD RESTART
-
-    T dual_feasibility_lhs_new(dual_feasibility_lhs);
-
-    global_dual_residual(qpresults,
-                         qpwork,
-                         qpmodel,
-                         ruiz,
-                         dual_feasibility_lhs_new,
-                         dual_feasibility_rhs_0,
-                         dual_feasibility_rhs_1,
-                         dual_feasibility_rhs_3,
-                         rhs_duality_gap,
-                         duality_gap);
-    qpresults.info.dua_res = dual_feasibility_lhs_new;
-    qpresults.info.duality_gap = duality_gap;
-
-    if (primal_feasibility_lhs_new >= primal_feasibility_lhs &&
-        dual_feasibility_lhs_new >= dual_feasibility_lhs &&
-        qpresults.info.mu_in <= T(1e-5)) {
-      /* to put in debuger mode
-      if (qpsettings.verbose) {
-              std::cout << "cold restart" << std::endl;
-      }
-      */
-
-      new_bcl_mu_in = qpsettings.cold_reset_mu_in;
-      new_bcl_mu_eq = qpsettings.cold_reset_mu_eq;
-      new_bcl_mu_in_inv = qpsettings.cold_reset_mu_in_inv;
-      new_bcl_mu_eq_inv = qpsettings.cold_reset_mu_eq_inv;
-    }
-
-    /// effective mu upddate
-
-    if (qpresults.info.mu_in != new_bcl_mu_in ||
-        qpresults.info.mu_eq != new_bcl_mu_eq) {
-      {
-        ++qpresults.info.mu_updates;
-      }
-      mu_update(qpmodel, qpresults, qpwork, new_bcl_mu_eq, new_bcl_mu_in);
-    }
-
-    qpresults.info.mu_eq = new_bcl_mu_eq;
-    qpresults.info.mu_in = new_bcl_mu_in;
-    qpresults.info.mu_eq_inv = new_bcl_mu_eq_inv;
-    qpresults.info.mu_in_inv = new_bcl_mu_in_inv;
-  }
-
-  ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
-  ruiz.unscale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
-  ruiz.unscale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
-
-  {
-    // EigenAllowAlloc _{};
-    qpresults.info.objValue = 0;
-    for (Eigen::Index j = 0; j < qpmodel.dim; ++j) {
-      qpresults.info.objValue +=
-        0.5 * (qpresults.x(j) * qpresults.x(j)) * qpmodel.H(j, j);
-      qpresults.info.objValue +=
-        qpresults.x(j) * T(qpmodel.H.col(j)
-                             .tail(qpmodel.dim - j - 1)
-                             .dot(qpresults.x.tail(qpmodel.dim - j - 1)));
-    }
-    qpresults.info.objValue += (qpmodel.g).dot(qpresults.x);
-  }
-
-  if (qpsettings.compute_timings) {
-    qpresults.info.solve_time = qpwork.timer.elapsed().user; // in nanoseconds
-    qpresults.info.run_time =
-      qpresults.info.solve_time + qpresults.info.setup_time;
-  }
-
-  if (qpsettings.verbose) {
-    std::cout << "-------------------SOLVER STATISTICS-------------------"
-              << std::endl;
-    std::cout << "outer iter:   " << qpresults.info.iter_ext << std::endl;
-    std::cout << "total iter:   " << qpresults.info.iter << std::endl;
-    std::cout << "mu updates:   " << qpresults.info.mu_updates << std::endl;
-    std::cout << "rho updates:  " << qpresults.info.rho_updates << std::endl;
-    std::cout << "objective:    " << qpresults.info.objValue << std::endl;
-    switch (qpresults.info.status) {
-      case QPSolverOutput::PROXQP_SOLVED: {
-        std::cout << "status:       "
-                  << "Solved" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_MAX_ITER_REACHED: {
-        std::cout << "status:       "
-                  << "Maximum number of iterations reached" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE: {
-        std::cout << "status:       "
-                  << "Primal infeasible" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_DUAL_INFEASIBLE: {
-        std::cout << "status:       "
-                  << "Dual infeasible" << std::endl;
-        break;
-      }
-      default: {
-        assert(false && "Should never happened");
-        break;
-      }
-    }
-
-    if (qpsettings.compute_timings)
-      std::cout << "run time:     " << qpresults.info.solve_time << std::endl;
-    std::cout << "--------------------------------------------------------"
-              << std::endl;
-  }
-  qpwork.dirty = true;
-  qpwork.is_initialized = true; // necessary because we call workspace cleanup
-
-  assert(!std::isnan(qpresults.info.pri_res));
-  assert(!std::isnan(qpresults.info.dua_res));
-  assert(!std::isnan(qpresults.info.duality_gap));
-
-  PROXSUITE_EIGEN_MALLOC_ALLOWED();
-}
-
-} // namespace dense
-
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_SOLVER_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file solver.hpp
+ */
+
+#ifndef PROXSUITE_PROXQP_DENSE_SOLVER_HPP
+#define PROXSUITE_PROXQP_DENSE_SOLVER_HPP
+
+#include "proxsuite/fwd.hpp"
+#include "proxsuite/proxqp/dense/views.hpp"
+#include "proxsuite/proxqp/dense/linesearch.hpp"
+#include "proxsuite/proxqp/dense/helpers.hpp"
+#include "proxsuite/proxqp/dense/utils.hpp"
+#include <cmath>
+#include <Eigen/Sparse>
+#include <iostream>
+#include <fstream>
+#include <proxsuite/linalg/veg/util/dynstack_alloc.hpp>
+#include <proxsuite/linalg/dense/ldlt.hpp>
+#include <chrono>
+#include <iomanip>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+
+/*!
+ * Performs a refactorization of the KKT matrix used by the solver.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ * @param rho_new new primal proximal parameter used for the refactorization.
+ */
+template<typename T>
+void
+refactorize(const Model<T>& qpmodel,
+            Results<T>& qpresults,
+            Workspace<T>& qpwork,
+            T rho_new)
+{
+
+  if (!qpwork.constraints_changed && rho_new == qpresults.info.rho) {
+    return;
+  }
+
+  qpwork.dw_aug.setZero();
+  qpwork.kkt.diagonal().head(qpmodel.dim).array() +=
+    rho_new - qpresults.info.rho;
+  qpwork.kkt.diagonal().segment(qpmodel.dim, qpmodel.n_eq).array() =
+    -qpresults.info.mu_eq;
+
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
+  };
+  qpwork.ldl.factorize(qpwork.kkt.transpose(), stack);
+
+  isize n = qpmodel.dim;
+  isize n_eq = qpmodel.n_eq;
+  isize n_in = qpmodel.n_in;
+  isize n_c = qpwork.n_c;
+
+  LDLT_TEMP_MAT(T, new_cols, n + n_eq + n_c, n_c, stack);
+  T mu_in_neg = -qpresults.info.mu_in;
+  for (isize i = 0; i < n_in; ++i) {
+    isize j = qpwork.current_bijection_map[i];
+    if (j < n_c) {
+      auto col = new_cols.col(j);
+      col.head(n) = qpwork.C_scaled.row(i);
+      col.segment(n, n_eq + n_c).setZero();
+      col(n + n_eq + j) = mu_in_neg;
+    }
+  }
+  qpwork.ldl.insert_block_at(n + n_eq, new_cols, stack);
+
+  qpwork.constraints_changed = false;
+
+  qpwork.dw_aug.setZero();
+}
+
+/*!
+ * Updates the dual proximal parameters of the solver (i.e., penalization
+ * parameters of the primal-dual merit function).
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ * @param mu_eq_new new dual equality constrained proximal parameter.
+ * @param mu_in_new new dual inequality constrained proximal parameter.
+ */
+template<typename T>
+void
+mu_update(const Model<T>& qpmodel,
+          Results<T>& qpresults,
+          Workspace<T>& qpwork,
+          T mu_eq_new,
+          T mu_in_new)
+{
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
+  };
+
+  isize n = qpmodel.dim;
+  isize n_eq = qpmodel.n_eq;
+  isize n_c = qpwork.n_c;
+
+  if ((n_eq + n_c) == 0) {
+    return;
+  }
+
+  LDLT_TEMP_VEC_UNINIT(T, rank_update_alpha, n_eq + n_c, stack);
+  rank_update_alpha.head(n_eq).setConstant(qpresults.info.mu_eq - mu_eq_new);
+  rank_update_alpha.tail(n_c).setConstant(qpresults.info.mu_in - mu_in_new);
+
+  {
+    auto _indices = stack.make_new_for_overwrite(
+      proxsuite::linalg::veg::Tag<isize>{}, n_eq + n_c);
+    isize* indices = _indices.ptr_mut();
+    for (isize k = 0; k < n_eq; ++k) {
+      indices[k] = n + k;
+    }
+    for (isize k = 0; k < n_c; ++k) {
+      indices[n_eq + k] = n + n_eq + k;
+    }
+    qpwork.ldl.diagonal_update_clobber_indices(
+      indices, n_eq + n_c, rank_update_alpha, stack);
+  }
+
+  qpwork.constraints_changed = true;
+}
+/*!
+ * Derives the residual of the iterative refinement algorithm used for solving
+ * associated linear systems of PROXQP algorithm.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ * @param inner_pb_dim dimension of the linear system.
+ */
+template<typename T>
+void
+iterative_residual(const Model<T>& qpmodel,
+                   Results<T>& qpresults,
+                   Workspace<T>& qpwork,
+                   isize inner_pb_dim)
+{
+
+  qpwork.err.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
+
+  qpwork.err.head(qpmodel.dim).noalias() -=
+    qpwork.H_scaled.template selfadjointView<Eigen::Lower>() *
+    qpwork.dw_aug.head(qpmodel.dim);
+  qpwork.err.head(qpmodel.dim) -=
+    qpresults.info.rho * qpwork.dw_aug.head(qpmodel.dim);
+
+  // PERF: fuse {A, C}_scaled multiplication operations
+  qpwork.err.head(qpmodel.dim).noalias() -=
+    qpwork.A_scaled.transpose() *
+    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
+  for (isize i = 0; i < qpmodel.n_in; i++) {
+    isize j = qpwork.current_bijection_map(i);
+    if (j < qpwork.n_c) {
+      qpwork.err.head(qpmodel.dim).noalias() -=
+        qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + j) * qpwork.C_scaled.row(i);
+      qpwork.err(qpmodel.dim + qpmodel.n_eq + j) -=
+        (qpwork.C_scaled.row(i).dot(qpwork.dw_aug.head(qpmodel.dim)) -
+         qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + j) * qpresults.info.mu_in);
+    }
+  }
+  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq).noalias() -=
+    qpwork.A_scaled * qpwork.dw_aug.head(qpmodel.dim);
+  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) +=
+    qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq) * qpresults.info.mu_eq;
+}
+/*!
+ * Performs iterative refinement for solving associated linear systems of PROXQP
+ * algorithm.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param eps accuracy required for pursuing or not the iterative refinement.
+ * @param inner_pb_dim dimension of the linear system.
+ */
+template<typename T>
+void
+iterative_solve_with_permut_fact( //
+  const Settings<T>& qpsettings,
+  const Model<T>& qpmodel,
+  Results<T>& qpresults,
+  Workspace<T>& qpwork,
+  T eps,
+  isize inner_pb_dim)
+{
+
+  qpwork.err.setZero();
+  i32 it = 0;
+  i32 it_stability = 0;
+
+  qpwork.dw_aug.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
+  proxsuite::linalg::veg::dynstack::DynStackMut stack{
+    proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
+  };
+  qpwork.ldl.solve_in_place(qpwork.dw_aug.head(inner_pb_dim), stack);
+
+  iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
+
+  ++it;
+  T preverr = infty_norm(qpwork.err.head(inner_pb_dim));
+  /* to put in debuger mode
+  if (qpsettings.verbose) {
+          std::cout << "infty_norm(res) " <<
+  infty_norm(qpwork.err.head(inner_pb_dim))
+                                                  << std::endl;
+  }
+  */
+  while (infty_norm(qpwork.err.head(inner_pb_dim)) >= eps) {
+
+    if (it >= qpsettings.nb_iterative_refinement) {
+      break;
+    }
+
+    ++it;
+    qpwork.ldl.solve_in_place(qpwork.err.head(inner_pb_dim), stack);
+    qpwork.dw_aug.head(inner_pb_dim) += qpwork.err.head(inner_pb_dim);
+
+    qpwork.err.head(inner_pb_dim).setZero();
+    iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
+
+    if (infty_norm(qpwork.err.head(inner_pb_dim)) > preverr) {
+      it_stability += 1;
+
+    } else {
+      it_stability = 0;
+    }
+    if (it_stability == 2) {
+      break;
+    }
+    preverr = infty_norm(qpwork.err.head(inner_pb_dim));
+    /* to put in debug mode
+    if (qpsettings.verbose) {
+            std::cout << "infty_norm(res) "
+                                                    <<
+    infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
+    }
+    */
+  }
+
+  if (infty_norm(qpwork.err.head(inner_pb_dim)) >=
+      std::max(eps, qpsettings.eps_refact)) {
+    refactorize(qpmodel, qpresults, qpwork, qpresults.info.rho);
+    it = 0;
+    it_stability = 0;
+
+    qpwork.dw_aug.head(inner_pb_dim) = qpwork.rhs.head(inner_pb_dim);
+    qpwork.ldl.solve_in_place(qpwork.dw_aug.head(inner_pb_dim), stack);
+
+    iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
+
+    preverr = infty_norm(qpwork.err.head(inner_pb_dim));
+    ++it;
+    /* to put in debug mode
+    if (qpsettings.verbose) {
+            std::cout << "infty_norm(res) "
+                                                    <<
+    infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
+    }
+    */
+    while (infty_norm(qpwork.err.head(inner_pb_dim)) >= eps) {
+
+      if (it >= qpsettings.nb_iterative_refinement) {
+        break;
+      }
+      ++it;
+      qpwork.ldl.solve_in_place(qpwork.err.head(inner_pb_dim), stack);
+      qpwork.dw_aug.head(inner_pb_dim) += qpwork.err.head(inner_pb_dim);
+
+      qpwork.err.head(inner_pb_dim).setZero();
+      iterative_residual<T>(qpmodel, qpresults, qpwork, inner_pb_dim);
+
+      if (infty_norm(qpwork.err.head(inner_pb_dim)) > preverr) {
+        it_stability += 1;
+
+      } else {
+        it_stability = 0;
+      }
+      if (it_stability == 2) {
+        break;
+      }
+      preverr = infty_norm(qpwork.err.head(inner_pb_dim));
+      /* to put in debug mode
+      if (qpsettings.verbose) {
+              std::cout << "infty_norm(res) "
+                                                      <<
+      infty_norm(qpwork.err.head(inner_pb_dim)) << std::endl;
+      }
+      */
+    }
+  }
+  qpwork.rhs.head(inner_pb_dim).setZero();
+}
+/*!
+ * BCL rule for updating penalization parameters and accuracy variables.
+ *
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param primal_feasibility_lhs_new primal infeasibility.
+ * @param bcl_eta_ext BCL variable measuring whether the precisely infeasibility
+ * is too large or not.
+ * @param bcl_eta_in BCL variable setting the accuracy required for solving an
+ * associated subproblem.
+ * @param bcl_eta_ext_init initial BCL bcl_eta_ext variable value.
+ * @param eps_in_min minimal possible value for bcl_eta_in.
+ * @param new_bcl_mu_in new value of the inequality constrained penalization
+ * parameter.
+ * @param new_bcl_mu_eq new value of the equality constrained penalization
+ * parameter.
+ * @param new_bcl_mu_in_inv new value of the inequality constrained penalization
+ * parameter (inverse form).
+ * @param new_bcl_mu_eq_inv new value of the equality constrained penalization
+ * parameter (inverse form).
+ */
+template<typename T>
+void
+bcl_update(const Settings<T>& qpsettings,
+           Results<T>& qpresults,
+           Workspace<T>& qpwork,
+           T& primal_feasibility_lhs_new,
+           T& bcl_eta_ext,
+           T& bcl_eta_in,
+
+           T bcl_eta_ext_init,
+           T eps_in_min,
+
+           T& new_bcl_mu_in,
+           T& new_bcl_mu_eq,
+           T& new_bcl_mu_in_inv,
+           T& new_bcl_mu_eq_inv
+
+)
+{
+  if (primal_feasibility_lhs_new <= bcl_eta_ext ||
+      qpresults.info.iter > qpsettings.safe_guard) {
+    /* TO PUT IN DEBUG MODE
+    if (qpsettings.verbose) {
+            std::cout << "good step" << std::endl;
+    }
+    */
+    bcl_eta_ext *= pow(qpresults.info.mu_in, qpsettings.beta_bcl);
+    bcl_eta_in = std::max(bcl_eta_in * qpresults.info.mu_in, eps_in_min);
+  } else {
+    /* TO PUT IN DEBUG MODE
+    if (qpsettings.verbose) {
+            std::cout << "bad step" << std::endl;
+    }
+    */
+    qpresults.y = qpwork.y_prev;
+    qpresults.z = qpwork.z_prev;
+
+    new_bcl_mu_in = std::max(qpresults.info.mu_in * qpsettings.mu_update_factor,
+                             qpsettings.mu_min_in);
+    new_bcl_mu_eq = std::max(qpresults.info.mu_eq * qpsettings.mu_update_factor,
+                             qpsettings.mu_min_eq);
+    new_bcl_mu_in_inv =
+      std::min(qpresults.info.mu_in_inv * qpsettings.mu_update_inv_factor,
+               qpsettings.mu_max_in_inv);
+    new_bcl_mu_eq_inv =
+      std::min(qpresults.info.mu_eq_inv * qpsettings.mu_update_inv_factor,
+               qpsettings.mu_max_eq_inv);
+    bcl_eta_ext = bcl_eta_ext_init * pow(new_bcl_mu_in, qpsettings.alpha_bcl);
+    bcl_eta_in = std::max(new_bcl_mu_in, eps_in_min);
+  }
+}
+/*!
+ * Martinez rule for updating penalization parameters and accuracy variables.
+ *
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param primal_feasibility_lhs_new primal infeasibility.
+ * @param bcl_eta_ext BCL variable measuring whether the precisely infeasibility
+ * is too large or not.
+ * @param bcl_eta_in BCL variable setting the accuracy required for solving an
+ * associated subproblem.
+ * @param bcl_eta_ext_init initial BCL bcl_eta_ext variable value.
+ * @param eps_in_min minimal possible value for bcl_eta_in.
+ * @param new_bcl_mu_in new value of the inequality constrained penalization
+ * parameter.
+ * @param new_bcl_mu_eq new value of the equality constrained penalization
+ * parameter.
+ * @param new_bcl_mu_in_inv new value of the inequality constrained penalization
+ * parameter (inverse form).
+ * @param new_bcl_mu_eq_inv new value of the equality constrained penalization
+ * parameter (inverse form).
+ */
+template<typename T>
+void
+Martinez_update(const Settings<T>& qpsettings,
+                Results<T>& qpresults,
+                T& primal_feasibility_lhs_new,
+                T& primal_feasibility_lhs_old,
+                T& bcl_eta_in,
+                T eps_in_min,
+
+                T& new_bcl_mu_in,
+                T& new_bcl_mu_eq,
+                T& new_bcl_mu_in_inv,
+                T& new_bcl_mu_eq_inv
+
+)
+{
+  bcl_eta_in = std::max(bcl_eta_in * 0.1, eps_in_min);
+  if (primal_feasibility_lhs_new <= 0.95 * primal_feasibility_lhs_old) {
+    /* TO PUT IN DEBUG MODE
+    if (qpsettings.verbose) {
+            std::cout << "good step" << std::endl;
+    }
+    */
+  } else {
+    /* TO PUT IN DEBUG MODE
+    if (qpsettings.verbose) {
+            std::cout << "bad step" << std::endl;
+    }
+    */
+    new_bcl_mu_in = std::max(qpresults.info.mu_in * qpsettings.mu_update_factor,
+                             qpsettings.mu_min_in);
+    new_bcl_mu_eq = std::max(qpresults.info.mu_eq * qpsettings.mu_update_factor,
+                             qpsettings.mu_min_eq);
+    new_bcl_mu_in_inv =
+      std::min(qpresults.info.mu_in_inv * qpsettings.mu_update_inv_factor,
+               qpsettings.mu_max_in_inv);
+    new_bcl_mu_eq_inv =
+      std::min(qpresults.info.mu_eq_inv * qpsettings.mu_update_inv_factor,
+               qpsettings.mu_max_eq_inv);
+  }
+}
+/*!
+ * Derives the stopping criterion value used by the Newton semismooth algorithm
+ * to minimize the primal-dual augmented Lagrangian function.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ */
+template<typename T>
+auto
+compute_inner_loop_saddle_point(const Model<T>& qpmodel,
+                                Results<T>& qpresults,
+                                Workspace<T>& qpwork) -> T
+{
+
+  qpwork.active_part_z =
+    helpers::positive_part(qpwork.primal_residual_in_scaled_up) +
+    helpers::negative_part(qpwork.primal_residual_in_scaled_low) -
+    qpresults.z * qpresults.info.mu_in; // contains now : [Cx-u+z_prev*mu_in]+
+                                        // + [Cx-l+z_prev*mu_in]- - z*mu_in
+
+  T err = infty_norm(qpwork.active_part_z);
+  qpwork.err.segment(qpmodel.dim, qpmodel.n_eq) =
+    qpwork.primal_residual_eq_scaled; // contains now Ax-b-(y-y_prev)/mu
+
+  T prim_eq_e = infty_norm(
+    qpwork.err.segment(qpmodel.dim, qpmodel.n_eq)); // ||Ax-b-(y-y_prev)/mu||
+  err = std::max(err, prim_eq_e);
+  T dual_e =
+    infty_norm(qpwork.dual_residual_scaled); // contains ||Hx + rho(x-xprev) +
+                                             // g + Aty + Ctz||
+  err = std::max(err, dual_e);
+
+  return err;
+}
+/*!
+ * Derives the Newton semismooth step.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param eps accuracy required for solving the subproblem.
+ */
+template<typename T>
+void
+primal_dual_semi_smooth_newton_step(const Settings<T>& qpsettings,
+                                    const Model<T>& qpmodel,
+                                    Results<T>& qpresults,
+                                    Workspace<T>& qpwork,
+                                    T eps)
+{
+
+  /* MUST BE
+   *  dual_residual_scaled = Hx + rho * (x-x_prev) + A.T y + C.T z
+   *  primal_residual_eq_scaled = Ax-b+mu_eq (y_prev-y)
+   *  primal_residual_in_scaled_up = Cx-u+mu_in(z_prev)
+   *  primal_residual_in_scaled_low = Cx-l+mu_in(z_prev)
+   */
+
+  qpwork.active_set_up.array() =
+    (qpwork.primal_residual_in_scaled_up.array() >= 0);
+  qpwork.active_set_low.array() =
+    (qpwork.primal_residual_in_scaled_low.array() <= 0);
+  qpwork.active_inequalities = qpwork.active_set_up || qpwork.active_set_low;
+  isize numactive_inequalities = qpwork.active_inequalities.count();
+
+  isize inner_pb_dim = qpmodel.dim + qpmodel.n_eq + numactive_inequalities;
+  qpwork.rhs.setZero();
+  qpwork.dw_aug.setZero();
+
+  linesearch::active_set_change(qpmodel, qpresults, qpwork);
+
+  qpwork.rhs.head(qpmodel.dim) = -qpwork.dual_residual_scaled;
+
+  qpwork.rhs.segment(qpmodel.dim, qpmodel.n_eq) =
+    -qpwork.primal_residual_eq_scaled;
+  for (isize i = 0; i < qpmodel.n_in; i++) {
+    isize j = qpwork.current_bijection_map(i);
+    if (j < qpwork.n_c) {
+      if (qpwork.active_set_up(i)) {
+        qpwork.rhs(j + qpmodel.dim + qpmodel.n_eq) =
+          -qpwork.primal_residual_in_scaled_up(i) +
+          qpresults.z(i) * qpresults.info.mu_in;
+      } else if (qpwork.active_set_low(i)) {
+        qpwork.rhs(j + qpmodel.dim + qpmodel.n_eq) =
+          -qpwork.primal_residual_in_scaled_low(i) +
+          qpresults.z(i) * qpresults.info.mu_in;
+      }
+    } else {
+      qpwork.rhs.head(qpmodel.dim) +=
+        qpresults.z(i) * qpwork.C_scaled.row(i); // unactive unrelevant columns
+    }
+  }
+
+  iterative_solve_with_permut_fact( //
+    qpsettings,
+    qpmodel,
+    qpresults,
+    qpwork,
+    eps,
+    inner_pb_dim);
+
+  // use active_part_z as a temporary variable to derive unpermutted dz step
+  for (isize j = 0; j < qpmodel.n_in; ++j) {
+    isize i = qpwork.current_bijection_map(j);
+    if (i < qpwork.n_c) {
+      qpwork.active_part_z(j) = qpwork.dw_aug(qpmodel.dim + qpmodel.n_eq + i);
+    } else {
+      qpwork.active_part_z(j) = -qpresults.z(j);
+    }
+  }
+  qpwork.dw_aug.tail(qpmodel.n_in) = qpwork.active_part_z;
+}
+/*!
+ * Performs the Newton semismooth algorithm to minimize the primal-dual
+ * augmented Lagrangian function used by PROXQP algorithm.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param ruiz ruiz preconditioner.
+ * @param eps_int accuracy required for solving the subproblem.
+ */
+template<typename T>
+void
+primal_dual_newton_semi_smooth(const Settings<T>& qpsettings,
+                               const Model<T>& qpmodel,
+                               Results<T>& qpresults,
+                               Workspace<T>& qpwork,
+                               preconditioner::RuizEquilibration<T>& ruiz,
+                               T eps_int)
+{
+
+  /* MUST CONTAIN IN ENTRY WITH x = x_prev ; y = y_prev ; z = z_prev
+   *  dual_residual_scaled = Hx + rho * (x-x_prev) + A.T y + C.T z
+   *  primal_residual_eq_scaled = Ax-b+mu_eq (y_prev-y)
+   *  primal_residual_in_scaled_up = Cx-u+mu_in(z_prev)
+   *  primal_residual_in_scaled_low = Cx-l+mu_in(z_prev)
+   */
+  /* for debug
+  if (qpsettings.verbose) {
+          std::cout << "---- inner iteration    inner error    alpha ----" <<
+  std::endl;
+  }
+  */
+  T err_in = 1.e6;
+
+  for (i64 iter = 0; iter <= qpsettings.max_iter_in; ++iter) {
+
+    if (iter == qpsettings.max_iter_in) {
+      qpresults.info.iter += qpsettings.max_iter_in + 1;
+      break;
+    }
+    primal_dual_semi_smooth_newton_step<T>(
+      qpsettings, qpmodel, qpresults, qpwork, eps_int);
+
+    proxsuite::linalg::veg::dynstack::DynStackMut stack{
+      proxsuite::linalg::veg::from_slice_mut, qpwork.ldl_stack.as_mut()
+    };
+    LDLT_TEMP_VEC(T, ATdy, qpmodel.dim, stack);
+    LDLT_TEMP_VEC(T, CTdz, qpmodel.dim, stack);
+
+    auto& Hdx = qpwork.Hdx;
+    auto& Adx = qpwork.Adx;
+    auto& Cdx = qpwork.Cdx;
+
+    auto dx = qpwork.dw_aug.head(qpmodel.dim);
+    auto dy = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
+    auto dz = qpwork.dw_aug.segment(qpmodel.dim + qpmodel.n_eq, qpmodel.n_in);
+
+    Hdx.setZero();
+    Adx.setZero();
+    Cdx.setZero();
+
+    Hdx.noalias() +=
+      qpwork.H_scaled.template selfadjointView<Eigen::Lower>() * dx;
+
+    Adx.noalias() += qpwork.A_scaled * dx;
+    ATdy.noalias() += qpwork.A_scaled.transpose() * dy;
+
+    Cdx.noalias() += qpwork.C_scaled * dx;
+    CTdz.noalias() += qpwork.C_scaled.transpose() * dz;
+
+    if (qpmodel.n_in > 0) {
+      linesearch::primal_dual_ls(qpmodel, qpresults, qpwork);
+    }
+    auto alpha = qpwork.alpha;
+
+    if (infty_norm(alpha * qpwork.dw_aug) < 1.E-11 && iter > 0) {
+      qpresults.info.iter += iter + 1;
+      /* to put in debuger mode
+      if (qpsettings.verbose) {
+              std::cout << "infty_norm(alpha_step * dx) "
+                                                      << infty_norm(alpha *
+      qpwork.dw_aug) << std::endl;
+      }
+      */
+      break;
+    }
+
+    qpresults.x += alpha * dx;
+
+    // contains now :  C(x+alpha dx)-u + z_prev * mu_in
+    qpwork.primal_residual_in_scaled_up += alpha * Cdx;
+
+    // contains now :  C(x+alpha dx)-l + z_prev * mu_in
+    qpwork.primal_residual_in_scaled_low += alpha * Cdx;
+
+    qpwork.primal_residual_eq_scaled +=
+      alpha * (Adx - qpresults.info.mu_eq * dy);
+
+    qpresults.y += alpha * dy;
+    qpresults.z += alpha * dz;
+
+    qpwork.dual_residual_scaled +=
+      alpha * (qpresults.info.rho * dx + Hdx + ATdy + CTdz);
+
+    err_in = dense::compute_inner_loop_saddle_point(qpmodel, qpresults, qpwork);
+    /* for debug
+    if (qpsettings.verbose) {
+            std::cout << "           " << iter << "              " <<
+    std::setprecision(2) << err_in
+                                                    << "         "  << alpha <<
+    std::endl;
+    }
+    */
+    if (qpsettings.verbose) {
+      std::cout << "\033[1;34m[inner iteration " << iter + 1 << "]\033[0m"
+                << std::endl;
+      std::cout << std::scientific << std::setw(2) << std::setprecision(2)
+                << "| inner residual=" << err_in << " | alpha=" << alpha
+                << std::endl;
+    }
+    if (err_in <= eps_int) {
+      qpresults.info.iter += iter + 1;
+      /* for debug
+      if (qpsettings.verbose) {
+              std::cout << "-------------------------------------------------"
+      << std::endl;
+      }
+      */
+      break;
+    }
+
+    // compute primal and dual infeasibility criteria
+    bool is_primal_infeasible =
+      global_primal_residual_infeasibility(VectorViewMut<T>{ from_eigen, ATdy },
+                                           VectorViewMut<T>{ from_eigen, CTdz },
+                                           VectorViewMut<T>{ from_eigen, dy },
+                                           VectorViewMut<T>{ from_eigen, dz },
+                                           qpwork,
+                                           qpsettings,
+                                           ruiz);
+
+    bool is_dual_infeasible =
+      global_dual_residual_infeasibility(VectorViewMut<T>{ from_eigen, Adx },
+                                         VectorViewMut<T>{ from_eigen, Cdx },
+                                         VectorViewMut<T>{ from_eigen, Hdx },
+                                         VectorViewMut<T>{ from_eigen, dx },
+                                         qpwork,
+                                         qpsettings,
+                                         qpmodel,
+                                         ruiz);
+
+    if (is_primal_infeasible) {
+      qpresults.info.status = QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE;
+      /* for debug
+      if (qpsettings.verbose) {
+              std::cout << "-------------------------------------------------"
+      << std::endl;
+      }
+      */
+      break;
+    } else if (is_dual_infeasible) {
+      qpresults.info.status = QPSolverOutput::PROXQP_DUAL_INFEASIBLE;
+      /* for debug
+      if (qpsettings.verbose) {
+              std::cout << "-------------------------------------------------"
+      << std::endl;
+      }
+      */
+      break;
+    }
+  }
+  /* to put in debuger mode
+  if (qpsettings.verbose) {
+    if (err_in > eps_int){
+          std::cout << " inner loop residual is to high! Its value is equal to "
+  << err_in << ", while it should be inferior to: "  << eps_int << std::endl;
+    }
+  }
+  */
+}
+/*!
+ * Executes the PROXQP algorithm.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpsettings solver settings.
+ * @param qpresults solver results.
+ * @param ruiz ruiz preconditioner.
+ */
+template<typename T>
+void
+qp_solve( //
+  const Settings<T>& qpsettings,
+  const Model<T>& qpmodel,
+  Results<T>& qpresults,
+  Workspace<T>& qpwork,
+  preconditioner::RuizEquilibration<T>& ruiz)
+{
+  /*** TEST WITH MATRIX FULL OF NAN FOR DEBUG
+    static constexpr Layout layout = rowmajor;
+    static constexpr auto DYN = Eigen::Dynamic;
+  using RowMat = Eigen::Matrix<T, DYN, DYN, Eigen::RowMajor>;
+  RowMat test(2,2); // test it is full of nan for debug
+  std::cout << "test " << test << std::endl;
+  */
+  PROXSUITE_EIGEN_MALLOC_NOT_ALLOWED();
+
+  if (qpsettings.compute_timings) {
+    qpwork.timer.stop();
+    qpwork.timer.start();
+  }
+  if (qpsettings.verbose) {
+    dense::print_setup_header(qpsettings, qpresults, qpmodel);
+  }
+  if (qpwork.dirty) { // the following is used when a solve has already been
+                      // executed (and without any intermediary model update)
+    switch (qpsettings.initial_guess) {
+      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+        qpwork.cleanup();
+        qpresults.cleanup(qpsettings);
+        break;
+      }
+      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+        // keep solutions but restart workspace and results
+        qpwork.cleanup();
+        qpresults.cold_start(qpsettings);
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, qpresults.x });
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        break;
+      }
+      case InitialGuessStatus::NO_INITIAL_GUESS: {
+        qpwork.cleanup();
+        qpresults.cleanup(qpsettings);
+        break;
+      }
+      case InitialGuessStatus::WARM_START: {
+        qpwork.cleanup();
+        qpresults.cold_start(
+          qpsettings); // because there was already a solve,
+                       // precond was already computed if set so
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            qpresults
+              .x }); // it contains the value given in entry for warm start
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        break;
+      }
+      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+        // keep workspace and results solutions except statistics
+        qpresults.cleanup_statistics();
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, qpresults.x });
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        break;
+      }
+    }
+    if (qpsettings.initial_guess !=
+        InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT) {
+      qpwork.H_scaled = qpmodel.H;
+      qpwork.g_scaled = qpmodel.g;
+      qpwork.A_scaled = qpmodel.A;
+      qpwork.b_scaled = qpmodel.b;
+      qpwork.C_scaled = qpmodel.C;
+      qpwork.u_scaled = qpmodel.u;
+      qpwork.l_scaled = qpmodel.l;
+      proxsuite::proxqp::dense::setup_equilibration(
+        qpwork, qpsettings, ruiz, false); // reuse previous equilibration
+      proxsuite::proxqp::dense::setup_factorization(qpwork, qpmodel, qpresults);
+    }
+    switch (qpsettings.initial_guess) {
+      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+        compute_equality_constrained_initial_guess(
+          qpwork, qpsettings, qpmodel, qpresults);
+        break;
+      }
+      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+        //!\ TODO in a quicker way
+        qpwork.n_c = 0;
+        for (isize i = 0; i < qpmodel.n_in; i++) {
+          if (qpresults.z[i] != 0) {
+            qpwork.active_inequalities[i] = true;
+          } else {
+            qpwork.active_inequalities[i] = false;
+          }
+        }
+        linesearch::active_set_change(qpmodel, qpresults, qpwork);
+        break;
+      }
+      case InitialGuessStatus::NO_INITIAL_GUESS: {
+        break;
+      }
+      case InitialGuessStatus::WARM_START: {
+        //!\ TODO in a quicker way
+        qpwork.n_c = 0;
+        for (isize i = 0; i < qpmodel.n_in; i++) {
+          if (qpresults.z[i] != 0) {
+            qpwork.active_inequalities[i] = true;
+          } else {
+            qpwork.active_inequalities[i] = false;
+          }
+        }
+        linesearch::active_set_change(qpmodel, qpresults, qpwork);
+        break;
+      }
+      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+        // keep workspace and results solutions except statistics
+
+        // meaningful for when one wants to warm start with previous result with
+        // the same QP model
+        break;
+      }
+    }
+  } else { // the following is used for a first solve after initializing or
+           // updating the Qp object
+    switch (qpsettings.initial_guess) {
+      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+        proxsuite::proxqp::dense::setup_factorization(
+          qpwork, qpmodel, qpresults);
+        compute_equality_constrained_initial_guess(
+          qpwork, qpsettings, qpmodel, qpresults);
+        break;
+      }
+      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+        //!\ TODO in a quicker way
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            qpresults
+              .x }); // meaningful for when there is an upate of the model and
+                     // one wants to warm start with previous result
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        setup_factorization(qpwork, qpmodel, qpresults);
+        qpwork.n_c = 0;
+        for (isize i = 0; i < qpmodel.n_in; i++) {
+          if (qpresults.z[i] != 0) {
+            qpwork.active_inequalities[i] = true;
+          } else {
+            qpwork.active_inequalities[i] = false;
+          }
+        }
+        linesearch::active_set_change(qpmodel, qpresults, qpwork);
+        break;
+      }
+      case InitialGuessStatus::NO_INITIAL_GUESS: {
+        setup_factorization(qpwork, qpmodel, qpresults);
+        break;
+      }
+      case InitialGuessStatus::WARM_START: {
+        //!\ TODO in a quicker way
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, qpresults.x });
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        setup_factorization(qpwork, qpmodel, qpresults);
+        qpwork.n_c = 0;
+        for (isize i = 0; i < qpmodel.n_in; i++) {
+          if (qpresults.z[i] != 0) {
+            qpwork.active_inequalities[i] = true;
+          } else {
+            qpwork.active_inequalities[i] = false;
+          }
+        }
+        linesearch::active_set_change(qpmodel, qpresults, qpwork);
+        break;
+      }
+      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+
+        ruiz.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            qpresults
+              .x }); // meaningful for when there is an upate of the model and
+                     // one wants to warm start with previous result
+        ruiz.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, qpresults.y });
+        ruiz.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, qpresults.z });
+        if (qpwork.refactorize) { // refactorization only when one of the
+                                  // matrices has changed or one proximal
+                                  // parameter has changed
+          setup_factorization(qpwork, qpmodel, qpresults);
+          qpwork.n_c = 0;
+          for (isize i = 0; i < qpmodel.n_in; i++) {
+            if (qpresults.z[i] != 0) {
+              qpwork.active_inequalities[i] = true;
+            } else {
+              qpwork.active_inequalities[i] = false;
+            }
+          }
+          linesearch::active_set_change(qpmodel, qpresults, qpwork);
+          break;
+        }
+      }
+    }
+  }
+
+  T bcl_eta_ext_init = pow(T(0.1), qpsettings.alpha_bcl);
+  T bcl_eta_ext = bcl_eta_ext_init;
+  T bcl_eta_in(1);
+  T eps_in_min = std::min(qpsettings.eps_abs, T(1.E-9));
+
+  T primal_feasibility_eq_rhs_0(0);
+  T primal_feasibility_in_rhs_0(0);
+  T dual_feasibility_rhs_0(0);
+  T dual_feasibility_rhs_1(0);
+  T dual_feasibility_rhs_3(0);
+  T primal_feasibility_lhs(0);
+  T primal_feasibility_eq_lhs(0);
+  T primal_feasibility_in_lhs(0);
+  T dual_feasibility_lhs(0);
+
+  T duality_gap(0);
+  T rhs_duality_gap(0);
+
+  for (i64 iter = 0; iter < qpsettings.max_iter; ++iter) {
+
+    // compute primal residual
+
+    // PERF: fuse matrix product computations in global_{primal, dual}_residual
+    global_primal_residual(qpmodel,
+                           qpresults,
+                           qpwork,
+                           ruiz,
+                           primal_feasibility_lhs,
+                           primal_feasibility_eq_rhs_0,
+                           primal_feasibility_in_rhs_0,
+                           primal_feasibility_eq_lhs,
+                           primal_feasibility_in_lhs);
+
+    global_dual_residual(qpresults,
+                         qpwork,
+                         qpmodel,
+                         ruiz,
+                         dual_feasibility_lhs,
+                         dual_feasibility_rhs_0,
+                         dual_feasibility_rhs_1,
+                         dual_feasibility_rhs_3,
+                         rhs_duality_gap,
+                         duality_gap);
+    qpresults.info.pri_res = primal_feasibility_lhs;
+    qpresults.info.dua_res = dual_feasibility_lhs;
+    qpresults.info.duality_gap = duality_gap;
+
+    T new_bcl_mu_in(qpresults.info.mu_in);
+    T new_bcl_mu_eq(qpresults.info.mu_eq);
+    T new_bcl_mu_in_inv(qpresults.info.mu_in_inv);
+    T new_bcl_mu_eq_inv(qpresults.info.mu_eq_inv);
+
+    T rhs_pri(qpsettings.eps_abs);
+    if (qpsettings.eps_rel != 0) {
+      rhs_pri += qpsettings.eps_rel * std::max(primal_feasibility_eq_rhs_0,
+                                               primal_feasibility_in_rhs_0);
+    }
+    bool is_primal_feasible = primal_feasibility_lhs <= rhs_pri;
+
+    T rhs_dua(qpsettings.eps_abs);
+    if (qpsettings.eps_rel != 0) {
+      rhs_dua +=
+        qpsettings.eps_rel *
+        std::max(
+          std::max(dual_feasibility_rhs_3, dual_feasibility_rhs_0),
+          std::max(dual_feasibility_rhs_1, qpwork.dual_feasibility_rhs_2));
+    }
+
+    bool is_dual_feasible = dual_feasibility_lhs <= rhs_dua;
+
+    if (qpsettings.verbose) {
+
+      ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
+      ruiz.unscale_dual_in_place_eq(
+        VectorViewMut<T>{ from_eigen, qpresults.y });
+      ruiz.unscale_dual_in_place_in(
+        VectorViewMut<T>{ from_eigen, qpresults.z });
+
+      {
+        // EigenAllowAlloc _{};
+        qpresults.info.objValue = 0;
+        for (Eigen::Index j = 0; j < qpmodel.dim; ++j) {
+          qpresults.info.objValue +=
+            0.5 * (qpresults.x(j) * qpresults.x(j)) * qpmodel.H(j, j);
+          qpresults.info.objValue +=
+            qpresults.x(j) * T(qpmodel.H.col(j)
+                                 .tail(qpmodel.dim - j - 1)
+                                 .dot(qpresults.x.tail(qpmodel.dim - j - 1)));
+        }
+        qpresults.info.objValue += (qpmodel.g).dot(qpresults.x);
+      }
+      std::cout << "\033[1;32m[outer iteration " << iter + 1 << "]\033[0m"
+                << std::endl;
+      std::cout << std::scientific << std::setw(2) << std::setprecision(2)
+                << "| primal residual=" << qpresults.info.pri_res
+                << " | dual residual=" << qpresults.info.dua_res
+                << " | duality gap=" << qpresults.info.duality_gap
+                << " | mu_in=" << qpresults.info.mu_in
+                << " | rho=" << qpresults.info.rho << std::endl;
+      ruiz.scale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
+      ruiz.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
+      ruiz.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
+    }
+    if (is_primal_feasible && is_dual_feasible) {
+      if (qpsettings.check_duality_gap) {
+        if (std::fabs(qpresults.info.duality_gap) <=
+            qpsettings.eps_duality_gap_abs +
+              qpsettings.eps_duality_gap_rel * rhs_duality_gap) {
+          qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
+          break;
+        }
+      } else {
+        qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
+        break;
+      }
+    }
+    qpresults.info.iter_ext += 1; // We start a new external loop update
+
+    qpwork.x_prev = qpresults.x;
+    qpwork.y_prev = qpresults.y;
+    qpwork.z_prev = qpresults.z;
+
+    // primal dual version from gill and robinson
+
+    ruiz.scale_primal_residual_in_place_in(VectorViewMut<T>{
+      from_eigen,
+      qpwork.primal_residual_in_scaled_up }); // contains now scaled(Cx)
+    qpwork.primal_residual_in_scaled_up +=
+      qpwork.z_prev *
+      qpresults.info.mu_in; // contains now scaled(Cx+z_prev*mu_in)
+    qpwork.primal_residual_in_scaled_low = qpwork.primal_residual_in_scaled_up;
+    qpwork.primal_residual_in_scaled_up -=
+      qpwork.u_scaled; // contains now scaled(Cx-u+z_prev*mu_in)
+    qpwork.primal_residual_in_scaled_low -=
+      qpwork.l_scaled; // contains now scaled(Cx-l+z_prev*mu_in)
+
+    primal_dual_newton_semi_smooth(
+      qpsettings, qpmodel, qpresults, qpwork, ruiz, bcl_eta_in);
+
+    if (qpresults.info.status == QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE ||
+        qpresults.info.status == QPSolverOutput::PROXQP_DUAL_INFEASIBLE) {
+      // certificate of infeasibility
+      qpresults.x = qpwork.dw_aug.head(qpmodel.dim);
+      qpresults.y = qpwork.dw_aug.segment(qpmodel.dim, qpmodel.n_eq);
+      qpresults.z = qpwork.dw_aug.tail(qpmodel.n_in);
+      break;
+    }
+
+    T primal_feasibility_lhs_new(primal_feasibility_lhs);
+
+    global_primal_residual(qpmodel,
+                           qpresults,
+                           qpwork,
+                           ruiz,
+                           primal_feasibility_lhs_new,
+                           primal_feasibility_eq_rhs_0,
+                           primal_feasibility_in_rhs_0,
+                           primal_feasibility_eq_lhs,
+                           primal_feasibility_in_lhs);
+
+    is_primal_feasible =
+      primal_feasibility_lhs_new <=
+      (qpsettings.eps_abs +
+       qpsettings.eps_rel *
+         std::max(primal_feasibility_eq_rhs_0, primal_feasibility_in_rhs_0));
+    qpresults.info.pri_res = primal_feasibility_lhs_new;
+    if (is_primal_feasible) {
+      T dual_feasibility_lhs_new(dual_feasibility_lhs);
+
+      global_dual_residual(qpresults,
+                           qpwork,
+                           qpmodel,
+                           ruiz,
+                           dual_feasibility_lhs_new,
+                           dual_feasibility_rhs_0,
+                           dual_feasibility_rhs_1,
+                           dual_feasibility_rhs_3,
+                           rhs_duality_gap,
+                           duality_gap);
+      qpresults.info.dua_res = dual_feasibility_lhs_new;
+      qpresults.info.duality_gap = duality_gap;
+
+      is_dual_feasible =
+        dual_feasibility_lhs_new <=
+        (qpsettings.eps_abs +
+         qpsettings.eps_rel *
+           std::max(
+             std::max(dual_feasibility_rhs_3, dual_feasibility_rhs_0),
+             std::max(dual_feasibility_rhs_1, qpwork.dual_feasibility_rhs_2)));
+
+      if (is_dual_feasible) {
+        if (qpsettings.check_duality_gap) {
+          if (std::fabs(qpresults.info.duality_gap) <=
+              qpsettings.eps_duality_gap_abs +
+                qpsettings.eps_duality_gap_rel * rhs_duality_gap) {
+            qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
+            break;
+          }
+        } else {
+          qpresults.info.status = QPSolverOutput::PROXQP_SOLVED;
+          break;
+        }
+      }
+    }
+    if (qpsettings.bcl_update) {
+      bcl_update(qpsettings,
+                 qpresults,
+                 qpwork,
+                 primal_feasibility_lhs_new,
+                 bcl_eta_ext,
+                 bcl_eta_in,
+                 bcl_eta_ext_init,
+                 eps_in_min,
+
+                 new_bcl_mu_in,
+                 new_bcl_mu_eq,
+                 new_bcl_mu_in_inv,
+                 new_bcl_mu_eq_inv);
+    } else {
+      Martinez_update(qpsettings,
+                      qpresults,
+                      primal_feasibility_lhs_new,
+                      primal_feasibility_lhs,
+                      bcl_eta_in,
+                      eps_in_min,
+                      new_bcl_mu_in,
+                      new_bcl_mu_eq,
+                      new_bcl_mu_in_inv,
+                      new_bcl_mu_eq_inv);
+    }
+    // COLD RESTART
+
+    T dual_feasibility_lhs_new(dual_feasibility_lhs);
+
+    global_dual_residual(qpresults,
+                         qpwork,
+                         qpmodel,
+                         ruiz,
+                         dual_feasibility_lhs_new,
+                         dual_feasibility_rhs_0,
+                         dual_feasibility_rhs_1,
+                         dual_feasibility_rhs_3,
+                         rhs_duality_gap,
+                         duality_gap);
+    qpresults.info.dua_res = dual_feasibility_lhs_new;
+    qpresults.info.duality_gap = duality_gap;
+
+    if (primal_feasibility_lhs_new >= primal_feasibility_lhs &&
+        dual_feasibility_lhs_new >= dual_feasibility_lhs &&
+        qpresults.info.mu_in <= T(1e-5)) {
+      /* to put in debuger mode
+      if (qpsettings.verbose) {
+              std::cout << "cold restart" << std::endl;
+      }
+      */
+
+      new_bcl_mu_in = qpsettings.cold_reset_mu_in;
+      new_bcl_mu_eq = qpsettings.cold_reset_mu_eq;
+      new_bcl_mu_in_inv = qpsettings.cold_reset_mu_in_inv;
+      new_bcl_mu_eq_inv = qpsettings.cold_reset_mu_eq_inv;
+    }
+
+    /// effective mu upddate
+
+    if (qpresults.info.mu_in != new_bcl_mu_in ||
+        qpresults.info.mu_eq != new_bcl_mu_eq) {
+      {
+        ++qpresults.info.mu_updates;
+      }
+      mu_update(qpmodel, qpresults, qpwork, new_bcl_mu_eq, new_bcl_mu_in);
+    }
+
+    qpresults.info.mu_eq = new_bcl_mu_eq;
+    qpresults.info.mu_in = new_bcl_mu_in;
+    qpresults.info.mu_eq_inv = new_bcl_mu_eq_inv;
+    qpresults.info.mu_in_inv = new_bcl_mu_in_inv;
+  }
+
+  ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
+  ruiz.unscale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
+  ruiz.unscale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
+
+  {
+    // EigenAllowAlloc _{};
+    qpresults.info.objValue = 0;
+    for (Eigen::Index j = 0; j < qpmodel.dim; ++j) {
+      qpresults.info.objValue +=
+        0.5 * (qpresults.x(j) * qpresults.x(j)) * qpmodel.H(j, j);
+      qpresults.info.objValue +=
+        qpresults.x(j) * T(qpmodel.H.col(j)
+                             .tail(qpmodel.dim - j - 1)
+                             .dot(qpresults.x.tail(qpmodel.dim - j - 1)));
+    }
+    qpresults.info.objValue += (qpmodel.g).dot(qpresults.x);
+  }
+
+  if (qpsettings.compute_timings) {
+    qpresults.info.solve_time = qpwork.timer.elapsed().user; // in nanoseconds
+    qpresults.info.run_time =
+      qpresults.info.solve_time + qpresults.info.setup_time;
+  }
+
+  if (qpsettings.verbose) {
+    std::cout << "-------------------SOLVER STATISTICS-------------------"
+              << std::endl;
+    std::cout << "outer iter:   " << qpresults.info.iter_ext << std::endl;
+    std::cout << "total iter:   " << qpresults.info.iter << std::endl;
+    std::cout << "mu updates:   " << qpresults.info.mu_updates << std::endl;
+    std::cout << "rho updates:  " << qpresults.info.rho_updates << std::endl;
+    std::cout << "objective:    " << qpresults.info.objValue << std::endl;
+    switch (qpresults.info.status) {
+      case QPSolverOutput::PROXQP_SOLVED: {
+        std::cout << "status:       "
+                  << "Solved" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_MAX_ITER_REACHED: {
+        std::cout << "status:       "
+                  << "Maximum number of iterations reached" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE: {
+        std::cout << "status:       "
+                  << "Primal infeasible" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_DUAL_INFEASIBLE: {
+        std::cout << "status:       "
+                  << "Dual infeasible" << std::endl;
+        break;
+      }
+      default: {
+        assert(false && "Should never happened");
+        break;
+      }
+    }
+
+    if (qpsettings.compute_timings)
+      std::cout << "run time:     " << qpresults.info.solve_time << std::endl;
+    std::cout << "--------------------------------------------------------"
+              << std::endl;
+  }
+  qpwork.dirty = true;
+  qpwork.is_initialized = true; // necessary because we call workspace cleanup
+
+  assert(!std::isnan(qpresults.info.pri_res));
+  assert(!std::isnan(qpresults.info.dua_res));
+  assert(!std::isnan(qpresults.info.duality_gap));
+
+  PROXSUITE_EIGEN_MALLOC_ALLOWED();
+}
+
+} // namespace dense
+
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_SOLVER_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/utils.hpp

 * *Ordering differences only*

```diff
@@ -1,415 +1,415 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file utils.hpp
- */
-#ifndef PROXSUITE_PROXQP_DENSE_UTILS_HPP
-#define PROXSUITE_PROXQP_DENSE_UTILS_HPP
-
-#include <iostream>
-#include <fstream>
-#include <cmath>
-#include <type_traits>
-
-#include "proxsuite/helpers/common.hpp"
-#include "proxsuite/proxqp/dense/views.hpp"
-#include "proxsuite/proxqp/dense/workspace.hpp"
-#include <proxsuite/proxqp/dense/model.hpp>
-#include <proxsuite/proxqp/results.hpp>
-#include <proxsuite/proxqp/utils/prints.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
-
-// #include <fmt/format.h>
-// #include <fmt/ostream.h>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-
-template<typename T>
-void
-print_setup_header(const Settings<T>& settings,
-                   const Results<T>& results,
-                   const Model<T>& model)
-{
-
-  proxsuite::proxqp::print_preambule();
-
-  // Print variables and constraints
-  std::cout << "problem:  " << std::noshowpos << std::endl;
-  std::cout << "          variables n = " << model.dim
-            << ", equality constraints n_eq = " << model.n_eq << ",\n"
-            << "          inequality constraints n_in = " << model.n_in
-            << std::endl;
-
-  // Print Settings
-  std::cout << "settings: " << std::endl;
-  std::cout << "          backend = dense," << std::endl;
-  std::cout << "          eps_abs = " << settings.eps_abs
-            << " eps_rel = " << settings.eps_rel << std::endl;
-  std::cout << "          eps_prim_inf = " << settings.eps_primal_inf
-            << ", eps_dual_inf = " << settings.eps_dual_inf << "," << std::endl;
-
-  std::cout << "          rho = " << results.info.rho
-            << ", mu_eq = " << results.info.mu_eq
-            << ", mu_in = " << results.info.mu_in << "," << std::endl;
-  std::cout << "          max_iter = " << settings.max_iter
-            << ", max_iter_in = " << settings.max_iter_in << "," << std::endl;
-
-  if (settings.compute_preconditioner) {
-    std::cout << "          scaling: on, " << std::endl;
-  } else {
-    std::cout << "          scaling: off, " << std::endl;
-  }
-  if (settings.compute_timings) {
-    std::cout << "          timings: on, " << std::endl;
-  } else {
-    std::cout << "          timings: off, " << std::endl;
-  }
-  switch (settings.initial_guess) {
-    case InitialGuessStatus::WARM_START:
-      std::cout << "          initial guess: warm start. \n" << std::endl;
-      break;
-    case InitialGuessStatus::NO_INITIAL_GUESS:
-      std::cout << "          initial guess: initial guess. \n" << std::endl;
-      break;
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT:
-      std::cout
-        << "          initial guess: warm start with previous result. \n"
-        << std::endl;
-      break;
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT:
-      std::cout
-        << "          initial guess: cold start with previous result. \n"
-        << std::endl;
-      break;
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS:
-      std::cout
-        << "          initial guess: equality constrained initial guess. \n"
-        << std::endl;
-  }
-}
-
-/*!
- * Save a matrix into a CSV format. Used for debug purposes.
- *
- * @param filename filename name for the CSV.
- * @param mat matrix to save into CSV format.
- */
-template<typename Derived>
-void
-save_data(const std::string& filename, const ::Eigen::MatrixBase<Derived>& mat)
-{
-  // https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html
-  const static Eigen::IOFormat CSVFormat(
-    Eigen::FullPrecision, Eigen::DontAlignCols, ", ", "\n");
-
-  std::ofstream file(filename);
-  if (file.is_open()) {
-    file << mat.format(CSVFormat);
-    file.close();
-  }
-}
-
-/*!
- * Derives the global primal residual of the QP problem.
- *
- * @param qpwork solver workspace.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param qpresults solver results.
- * @param ruiz ruiz preconditioner.
- * @param primal_feasibility_lhs primal infeasibility.
- * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param primal_feasibility_in_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param primal_feasibility_eq_lhs scalar variable used when using a relative
- * stopping criterion.
- * @param primal_feasibility_in_lhs scalar variable used when using a relative
- * stopping criterion.
- */
-template<typename T>
-void
-global_primal_residual(const Model<T>& qpmodel,
-                       const Results<T>& qpresults,
-                       Workspace<T>& qpwork,
-                       const preconditioner::RuizEquilibration<T>& ruiz,
-                       T& primal_feasibility_lhs,
-                       T& primal_feasibility_eq_rhs_0,
-                       T& primal_feasibility_in_rhs_0,
-                       T& primal_feasibility_eq_lhs,
-                       T& primal_feasibility_in_lhs)
-{
-  // COMPUTES:
-  // primal_residual_eq_scaled = scaled(Ax - b)
-  //
-  // primal_feasibility_lhs = max(norm(unscaled(Ax - b)),
-  //                              norm(unscaled([Cx - u]+ + [Cx - l]-)))
-  // primal_feasibility_eq_rhs_0 = norm(unscaled(Ax))
-  // primal_feasibility_in_rhs_0 = norm(unscaled(Cx))
-  //
-  // MAY_ALIAS[primal_residual_in_scaled_u, primal_residual_in_scaled_l]
-  //
-  // INDETERMINATE:
-  // primal_residual_in_scaled_u = unscaled(Cx)
-  // primal_residual_in_scaled_l = unscaled([Cx - u]+ + [Cx - l]-)
-  qpwork.primal_residual_eq_scaled.noalias() = qpwork.A_scaled * qpresults.x;
-  qpwork.primal_residual_in_scaled_up.noalias() = qpwork.C_scaled * qpresults.x;
-
-  ruiz.unscale_primal_residual_in_place_eq(
-    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_eq_scaled });
-  primal_feasibility_eq_rhs_0 = infty_norm(qpwork.primal_residual_eq_scaled);
-  ruiz.unscale_primal_residual_in_place_in(
-    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_in_scaled_up });
-  primal_feasibility_in_rhs_0 = infty_norm(qpwork.primal_residual_in_scaled_up);
-
-  qpwork.primal_residual_in_scaled_low =
-    helpers::positive_part(qpwork.primal_residual_in_scaled_up - qpmodel.u) +
-    helpers::negative_part(qpwork.primal_residual_in_scaled_up - qpmodel.l);
-  qpwork.primal_residual_eq_scaled -= qpmodel.b;
-
-  primal_feasibility_in_lhs = infty_norm(qpwork.primal_residual_in_scaled_low);
-  primal_feasibility_eq_lhs = infty_norm(qpwork.primal_residual_eq_scaled);
-  primal_feasibility_lhs =
-    std::max(primal_feasibility_eq_lhs, primal_feasibility_in_lhs);
-
-  ruiz.scale_primal_residual_in_place_eq(
-    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_eq_scaled });
-}
-
-/*!
- * Check whether the global primal infeasibility criterion is satisfied.
- *
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param ruiz ruiz preconditioner.
- * @param ATdy variable used for testing global primal infeasibility criterion
- * is satisfied.
- * @param CTdz variable used for testing global primal infeasibility criterion
- * is satisfied.
- * @param dy variable used for testing global primal infeasibility criterion is
- * satisfied.
- * @param dz variable used for testing global primal infeasibility criterion is
- * satisfied.
- */
-template<typename T>
-bool
-global_primal_residual_infeasibility(
-  VectorViewMut<T> ATdy,
-  VectorViewMut<T> CTdz,
-  VectorViewMut<T> dy,
-  VectorViewMut<T> dz,
-  Workspace<T>& qpwork,
-  const Settings<T>& qpsettings,
-  const preconditioner::RuizEquilibration<T>& ruiz)
-{
-
-  // The problem is primal infeasible if the following four conditions hold:
-  //
-  // ||unscaled(A^Tdy)|| <= eps_p_inf ||unscaled(dy)||
-  // b^T dy <= -eps_p_inf ||unscaled(dy)||
-  // ||unscaled(C^Tdz)|| <= eps_p_inf ||unscaled(dz)||
-  // u^T [dz]_+ - l^T[-dz]_+ <= -eps_p_inf ||unscaled(dz)||
-  //
-  // the variables in entry are changed in place
-
-  bool res = infty_norm(dy.to_eigen()) != 0 && infty_norm(dz.to_eigen()) != 0;
-  if (!res) {
-    return res;
-  }
-  ruiz.unscale_dual_residual_in_place(ATdy);
-  ruiz.unscale_dual_residual_in_place(CTdz);
-  T eq_inf = dy.to_eigen().dot(qpwork.b_scaled);
-  T in_inf = helpers::positive_part(dz.to_eigen()).dot(qpwork.u_scaled) -
-             helpers::negative_part(dz.to_eigen()).dot(qpwork.l_scaled);
-  ruiz.unscale_dual_in_place_eq(dy);
-  ruiz.unscale_dual_in_place_in(dz);
-
-  T bound_y = qpsettings.eps_primal_inf * infty_norm(dy.to_eigen());
-  T bound_z = qpsettings.eps_primal_inf * infty_norm(dz.to_eigen());
-
-  res = infty_norm(ATdy.to_eigen()) <= bound_y && eq_inf <= -bound_y &&
-        infty_norm(CTdz.to_eigen()) <= bound_z && in_inf <= -bound_z;
-  return res;
-}
-
-/*!
- * Check whether the global dual infeasibility criterion is satisfied.
- *
- * @param qpwork solver workspace.
- * @param qpsettings solver settings.
- * @param qpmodel QP problem model as defined by the user (without any scaling
- * performed).
- * @param ruiz ruiz preconditioner.
- * @param Adx variable used for testing global dual infeasibility criterion is
- * satisfied.
- * @param Cdx variable used for testing global dual infeasibility criterion is
- * satisfied.
- * @param Hdx variable used for testing global dual infeasibility criterion is
- * satisfied.
- * @param dx variable used for testing global dual infeasibility criterion is
- * satisfied.
- */
-template<typename T>
-bool
-global_dual_residual_infeasibility(
-  VectorViewMut<T> Adx,
-  VectorViewMut<T> Cdx,
-  VectorViewMut<T> Hdx,
-  VectorViewMut<T> dx,
-  Workspace<T>& qpwork,
-  const Settings<T>& qpsettings,
-  const Model<T>& qpmodel,
-  const preconditioner::RuizEquilibration<T>& ruiz)
-{
-
-  // The problem is dual infeasible the two following conditions hold:
-  //
-  // FIRST
-  // ||unscaled(Adx)|| <= eps_d_inf ||unscaled(dx)||
-  // unscaled(Cdx)_i \in [-eps_d_inf,eps_d_inf] ||unscaled(dx)|| if u_i and l_i
-  // are finite 					or >=
-  // -eps_d_inf||unscaled(dx)|| if u_i = +inf or <= eps_d_inf||unscaled(dx)|| if
-  // l_i = -inf
-  //
-  // SECOND
-  //
-  // ||unscaled(Hdx)|| <= c eps_d_inf * ||unscaled(dx)||  and  q^Tdx <= -c
-  // eps_d_inf  ||unscaled(dx)|| the variables in
-  // entry are changed in place
-  ruiz.unscale_dual_residual_in_place(Hdx);
-  ruiz.unscale_primal_residual_in_place_eq(Adx);
-  ruiz.unscale_primal_residual_in_place_in(Cdx);
-  T gdx = (dx.to_eigen()).dot(qpwork.g_scaled);
-  ruiz.unscale_primal_in_place(dx);
-
-  T bound = infty_norm(dx.to_eigen()) * qpsettings.eps_dual_inf;
-  T bound_neg = -bound;
-
-  bool first_cond = infty_norm(Adx.to_eigen()) <= bound;
-
-  for (i64 iter = 0; iter < qpmodel.n_in; ++iter) {
-    T Cdx_i = Cdx.to_eigen()[iter];
-    if (qpwork.u_scaled[iter] <= 1.E20 && qpwork.l_scaled[iter] >= -1.E20) {
-      first_cond = first_cond && Cdx_i <= bound && Cdx_i >= bound_neg;
-    } else if (qpwork.u_scaled[iter] > 1.E20) {
-      first_cond = first_cond && Cdx_i >= bound_neg;
-    } else if (qpwork.l_scaled[iter] < -1.E20) {
-      first_cond = first_cond && Cdx_i <= bound;
-    }
-  }
-
-  bound *= ruiz.c;
-  bound_neg *= ruiz.c;
-  bool second_cond_alt1 =
-    infty_norm(Hdx.to_eigen()) <= bound && gdx <= bound_neg;
-  bound_neg *= qpsettings.eps_dual_inf;
-
-  bool res = first_cond && second_cond_alt1 && infty_norm(dx.to_eigen()) != 0;
-  return res;
-}
-
-/*!
- * Derives the global dual residual of the QP problem.
- *
- * @param qpwork solver workspace.
- * @param qpresults solver results.
- * @param ruiz ruiz preconditioner.
- * @param dual_feasibility_lhs primal infeasibility.
- * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_1 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_3 scalar variable used when using a relative
- * stopping criterion.
- */
-template<typename T>
-void
-global_dual_residual(Results<T>& qpresults,
-                     Workspace<T>& qpwork,
-                     const Model<T>& qpmodel,
-                     const preconditioner::RuizEquilibration<T>& ruiz,
-                     T& dual_feasibility_lhs,
-                     T& dual_feasibility_rhs_0,
-                     T& dual_feasibility_rhs_1,
-                     T& dual_feasibility_rhs_3,
-                     T& rhs_duality_gap,
-                     T& duality_gap)
-{
-  // dual_feasibility_lhs = norm(dual_residual_scaled)
-  // dual_feasibility_rhs_0 = norm(unscaled(Hx))
-  // dual_feasibility_rhs_1 = norm(unscaled(ATy))
-  // dual_feasibility_rhs_3 = norm(unscaled(CTz))
-  //
-  // dual_residual_scaled = scaled(Hx + g + ATy + CTz)
-
-  qpwork.dual_residual_scaled = qpwork.g_scaled;
-  qpwork.CTz.noalias() =
-    qpwork.H_scaled.template selfadjointView<Eigen::Lower>() * qpresults.x;
-  qpwork.dual_residual_scaled += qpwork.CTz;
-  ruiz.unscale_dual_residual_in_place(
-    VectorViewMut<T>{ from_eigen, qpwork.CTz }); // contains unscaled Hx
-  dual_feasibility_rhs_0 = infty_norm(qpwork.CTz);
-
-  ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
-  duality_gap = (qpmodel.g).dot(qpresults.x);
-  rhs_duality_gap = std::fabs(duality_gap);
-  const T xHx = (qpwork.CTz).dot(qpresults.x);
-  duality_gap += xHx; // contains now xHx+g.Tx
-  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(xHx));
-
-  ruiz.scale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
-
-  qpwork.CTz.noalias() = qpwork.A_scaled.transpose() * qpresults.y;
-  qpwork.dual_residual_scaled += qpwork.CTz;
-  ruiz.unscale_dual_residual_in_place(
-    VectorViewMut<T>{ from_eigen, qpwork.CTz });
-  dual_feasibility_rhs_1 = infty_norm(qpwork.CTz);
-
-  qpwork.CTz.noalias() = qpwork.C_scaled.transpose() * qpresults.z;
-  qpwork.dual_residual_scaled += qpwork.CTz;
-  ruiz.unscale_dual_residual_in_place(
-    VectorViewMut<T>{ from_eigen, qpwork.CTz });
-  dual_feasibility_rhs_3 = infty_norm(qpwork.CTz);
-
-  ruiz.unscale_dual_residual_in_place(
-    VectorViewMut<T>{ from_eigen, qpwork.dual_residual_scaled });
-
-  dual_feasibility_lhs = infty_norm(qpwork.dual_residual_scaled);
-
-  ruiz.scale_dual_residual_in_place(
-    VectorViewMut<T>{ from_eigen, qpwork.dual_residual_scaled });
-
-  ruiz.unscale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
-  const T by = (qpmodel.b).dot(qpresults.y);
-  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(by));
-  duality_gap += by;
-  ruiz.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
-
-  ruiz.unscale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
-
-  const T zu =
-    helpers::select(qpwork.active_set_up, qpresults.z, 0)
-      .dot(helpers::at_most(qpmodel.u, helpers::infinite_bound<T>::value()));
-  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zu));
-  duality_gap += zu;
-
-  const T zl =
-    helpers::select(qpwork.active_set_low, qpresults.z, 0)
-      .dot(helpers::at_least(qpmodel.l, -helpers::infinite_bound<T>::value()));
-  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zl));
-  duality_gap += zl;
-
-  ruiz.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
-}
-
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_UTILS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file utils.hpp
+ */
+#ifndef PROXSUITE_PROXQP_DENSE_UTILS_HPP
+#define PROXSUITE_PROXQP_DENSE_UTILS_HPP
+
+#include <iostream>
+#include <fstream>
+#include <cmath>
+#include <type_traits>
+
+#include "proxsuite/helpers/common.hpp"
+#include "proxsuite/proxqp/dense/views.hpp"
+#include "proxsuite/proxqp/dense/workspace.hpp"
+#include <proxsuite/proxqp/dense/model.hpp>
+#include <proxsuite/proxqp/results.hpp>
+#include <proxsuite/proxqp/utils/prints.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
+
+// #include <fmt/format.h>
+// #include <fmt/ostream.h>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+
+template<typename T>
+void
+print_setup_header(const Settings<T>& settings,
+                   const Results<T>& results,
+                   const Model<T>& model)
+{
+
+  proxsuite::proxqp::print_preambule();
+
+  // Print variables and constraints
+  std::cout << "problem:  " << std::noshowpos << std::endl;
+  std::cout << "          variables n = " << model.dim
+            << ", equality constraints n_eq = " << model.n_eq << ",\n"
+            << "          inequality constraints n_in = " << model.n_in
+            << std::endl;
+
+  // Print Settings
+  std::cout << "settings: " << std::endl;
+  std::cout << "          backend = dense," << std::endl;
+  std::cout << "          eps_abs = " << settings.eps_abs
+            << " eps_rel = " << settings.eps_rel << std::endl;
+  std::cout << "          eps_prim_inf = " << settings.eps_primal_inf
+            << ", eps_dual_inf = " << settings.eps_dual_inf << "," << std::endl;
+
+  std::cout << "          rho = " << results.info.rho
+            << ", mu_eq = " << results.info.mu_eq
+            << ", mu_in = " << results.info.mu_in << "," << std::endl;
+  std::cout << "          max_iter = " << settings.max_iter
+            << ", max_iter_in = " << settings.max_iter_in << "," << std::endl;
+
+  if (settings.compute_preconditioner) {
+    std::cout << "          scaling: on, " << std::endl;
+  } else {
+    std::cout << "          scaling: off, " << std::endl;
+  }
+  if (settings.compute_timings) {
+    std::cout << "          timings: on, " << std::endl;
+  } else {
+    std::cout << "          timings: off, " << std::endl;
+  }
+  switch (settings.initial_guess) {
+    case InitialGuessStatus::WARM_START:
+      std::cout << "          initial guess: warm start. \n" << std::endl;
+      break;
+    case InitialGuessStatus::NO_INITIAL_GUESS:
+      std::cout << "          initial guess: initial guess. \n" << std::endl;
+      break;
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT:
+      std::cout
+        << "          initial guess: warm start with previous result. \n"
+        << std::endl;
+      break;
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT:
+      std::cout
+        << "          initial guess: cold start with previous result. \n"
+        << std::endl;
+      break;
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS:
+      std::cout
+        << "          initial guess: equality constrained initial guess. \n"
+        << std::endl;
+  }
+}
+
+/*!
+ * Save a matrix into a CSV format. Used for debug purposes.
+ *
+ * @param filename filename name for the CSV.
+ * @param mat matrix to save into CSV format.
+ */
+template<typename Derived>
+void
+save_data(const std::string& filename, const ::Eigen::MatrixBase<Derived>& mat)
+{
+  // https://eigen.tuxfamily.org/dox/structEigen_1_1IOFormat.html
+  const static Eigen::IOFormat CSVFormat(
+    Eigen::FullPrecision, Eigen::DontAlignCols, ", ", "\n");
+
+  std::ofstream file(filename);
+  if (file.is_open()) {
+    file << mat.format(CSVFormat);
+    file.close();
+  }
+}
+
+/*!
+ * Derives the global primal residual of the QP problem.
+ *
+ * @param qpwork solver workspace.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param qpresults solver results.
+ * @param ruiz ruiz preconditioner.
+ * @param primal_feasibility_lhs primal infeasibility.
+ * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param primal_feasibility_in_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param primal_feasibility_eq_lhs scalar variable used when using a relative
+ * stopping criterion.
+ * @param primal_feasibility_in_lhs scalar variable used when using a relative
+ * stopping criterion.
+ */
+template<typename T>
+void
+global_primal_residual(const Model<T>& qpmodel,
+                       const Results<T>& qpresults,
+                       Workspace<T>& qpwork,
+                       const preconditioner::RuizEquilibration<T>& ruiz,
+                       T& primal_feasibility_lhs,
+                       T& primal_feasibility_eq_rhs_0,
+                       T& primal_feasibility_in_rhs_0,
+                       T& primal_feasibility_eq_lhs,
+                       T& primal_feasibility_in_lhs)
+{
+  // COMPUTES:
+  // primal_residual_eq_scaled = scaled(Ax - b)
+  //
+  // primal_feasibility_lhs = max(norm(unscaled(Ax - b)),
+  //                              norm(unscaled([Cx - u]+ + [Cx - l]-)))
+  // primal_feasibility_eq_rhs_0 = norm(unscaled(Ax))
+  // primal_feasibility_in_rhs_0 = norm(unscaled(Cx))
+  //
+  // MAY_ALIAS[primal_residual_in_scaled_u, primal_residual_in_scaled_l]
+  //
+  // INDETERMINATE:
+  // primal_residual_in_scaled_u = unscaled(Cx)
+  // primal_residual_in_scaled_l = unscaled([Cx - u]+ + [Cx - l]-)
+  qpwork.primal_residual_eq_scaled.noalias() = qpwork.A_scaled * qpresults.x;
+  qpwork.primal_residual_in_scaled_up.noalias() = qpwork.C_scaled * qpresults.x;
+
+  ruiz.unscale_primal_residual_in_place_eq(
+    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_eq_scaled });
+  primal_feasibility_eq_rhs_0 = infty_norm(qpwork.primal_residual_eq_scaled);
+  ruiz.unscale_primal_residual_in_place_in(
+    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_in_scaled_up });
+  primal_feasibility_in_rhs_0 = infty_norm(qpwork.primal_residual_in_scaled_up);
+
+  qpwork.primal_residual_in_scaled_low =
+    helpers::positive_part(qpwork.primal_residual_in_scaled_up - qpmodel.u) +
+    helpers::negative_part(qpwork.primal_residual_in_scaled_up - qpmodel.l);
+  qpwork.primal_residual_eq_scaled -= qpmodel.b;
+
+  primal_feasibility_in_lhs = infty_norm(qpwork.primal_residual_in_scaled_low);
+  primal_feasibility_eq_lhs = infty_norm(qpwork.primal_residual_eq_scaled);
+  primal_feasibility_lhs =
+    std::max(primal_feasibility_eq_lhs, primal_feasibility_in_lhs);
+
+  ruiz.scale_primal_residual_in_place_eq(
+    VectorViewMut<T>{ from_eigen, qpwork.primal_residual_eq_scaled });
+}
+
+/*!
+ * Check whether the global primal infeasibility criterion is satisfied.
+ *
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param ruiz ruiz preconditioner.
+ * @param ATdy variable used for testing global primal infeasibility criterion
+ * is satisfied.
+ * @param CTdz variable used for testing global primal infeasibility criterion
+ * is satisfied.
+ * @param dy variable used for testing global primal infeasibility criterion is
+ * satisfied.
+ * @param dz variable used for testing global primal infeasibility criterion is
+ * satisfied.
+ */
+template<typename T>
+bool
+global_primal_residual_infeasibility(
+  VectorViewMut<T> ATdy,
+  VectorViewMut<T> CTdz,
+  VectorViewMut<T> dy,
+  VectorViewMut<T> dz,
+  Workspace<T>& qpwork,
+  const Settings<T>& qpsettings,
+  const preconditioner::RuizEquilibration<T>& ruiz)
+{
+
+  // The problem is primal infeasible if the following four conditions hold:
+  //
+  // ||unscaled(A^Tdy)|| <= eps_p_inf ||unscaled(dy)||
+  // b^T dy <= -eps_p_inf ||unscaled(dy)||
+  // ||unscaled(C^Tdz)|| <= eps_p_inf ||unscaled(dz)||
+  // u^T [dz]_+ - l^T[-dz]_+ <= -eps_p_inf ||unscaled(dz)||
+  //
+  // the variables in entry are changed in place
+
+  bool res = infty_norm(dy.to_eigen()) != 0 && infty_norm(dz.to_eigen()) != 0;
+  if (!res) {
+    return res;
+  }
+  ruiz.unscale_dual_residual_in_place(ATdy);
+  ruiz.unscale_dual_residual_in_place(CTdz);
+  T eq_inf = dy.to_eigen().dot(qpwork.b_scaled);
+  T in_inf = helpers::positive_part(dz.to_eigen()).dot(qpwork.u_scaled) -
+             helpers::negative_part(dz.to_eigen()).dot(qpwork.l_scaled);
+  ruiz.unscale_dual_in_place_eq(dy);
+  ruiz.unscale_dual_in_place_in(dz);
+
+  T bound_y = qpsettings.eps_primal_inf * infty_norm(dy.to_eigen());
+  T bound_z = qpsettings.eps_primal_inf * infty_norm(dz.to_eigen());
+
+  res = infty_norm(ATdy.to_eigen()) <= bound_y && eq_inf <= -bound_y &&
+        infty_norm(CTdz.to_eigen()) <= bound_z && in_inf <= -bound_z;
+  return res;
+}
+
+/*!
+ * Check whether the global dual infeasibility criterion is satisfied.
+ *
+ * @param qpwork solver workspace.
+ * @param qpsettings solver settings.
+ * @param qpmodel QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param ruiz ruiz preconditioner.
+ * @param Adx variable used for testing global dual infeasibility criterion is
+ * satisfied.
+ * @param Cdx variable used for testing global dual infeasibility criterion is
+ * satisfied.
+ * @param Hdx variable used for testing global dual infeasibility criterion is
+ * satisfied.
+ * @param dx variable used for testing global dual infeasibility criterion is
+ * satisfied.
+ */
+template<typename T>
+bool
+global_dual_residual_infeasibility(
+  VectorViewMut<T> Adx,
+  VectorViewMut<T> Cdx,
+  VectorViewMut<T> Hdx,
+  VectorViewMut<T> dx,
+  Workspace<T>& qpwork,
+  const Settings<T>& qpsettings,
+  const Model<T>& qpmodel,
+  const preconditioner::RuizEquilibration<T>& ruiz)
+{
+
+  // The problem is dual infeasible the two following conditions hold:
+  //
+  // FIRST
+  // ||unscaled(Adx)|| <= eps_d_inf ||unscaled(dx)||
+  // unscaled(Cdx)_i \in [-eps_d_inf,eps_d_inf] ||unscaled(dx)|| if u_i and l_i
+  // are finite 					or >=
+  // -eps_d_inf||unscaled(dx)|| if u_i = +inf or <= eps_d_inf||unscaled(dx)|| if
+  // l_i = -inf
+  //
+  // SECOND
+  //
+  // ||unscaled(Hdx)|| <= c eps_d_inf * ||unscaled(dx)||  and  q^Tdx <= -c
+  // eps_d_inf  ||unscaled(dx)|| the variables in
+  // entry are changed in place
+  ruiz.unscale_dual_residual_in_place(Hdx);
+  ruiz.unscale_primal_residual_in_place_eq(Adx);
+  ruiz.unscale_primal_residual_in_place_in(Cdx);
+  T gdx = (dx.to_eigen()).dot(qpwork.g_scaled);
+  ruiz.unscale_primal_in_place(dx);
+
+  T bound = infty_norm(dx.to_eigen()) * qpsettings.eps_dual_inf;
+  T bound_neg = -bound;
+
+  bool first_cond = infty_norm(Adx.to_eigen()) <= bound;
+
+  for (i64 iter = 0; iter < qpmodel.n_in; ++iter) {
+    T Cdx_i = Cdx.to_eigen()[iter];
+    if (qpwork.u_scaled[iter] <= 1.E20 && qpwork.l_scaled[iter] >= -1.E20) {
+      first_cond = first_cond && Cdx_i <= bound && Cdx_i >= bound_neg;
+    } else if (qpwork.u_scaled[iter] > 1.E20) {
+      first_cond = first_cond && Cdx_i >= bound_neg;
+    } else if (qpwork.l_scaled[iter] < -1.E20) {
+      first_cond = first_cond && Cdx_i <= bound;
+    }
+  }
+
+  bound *= ruiz.c;
+  bound_neg *= ruiz.c;
+  bool second_cond_alt1 =
+    infty_norm(Hdx.to_eigen()) <= bound && gdx <= bound_neg;
+  bound_neg *= qpsettings.eps_dual_inf;
+
+  bool res = first_cond && second_cond_alt1 && infty_norm(dx.to_eigen()) != 0;
+  return res;
+}
+
+/*!
+ * Derives the global dual residual of the QP problem.
+ *
+ * @param qpwork solver workspace.
+ * @param qpresults solver results.
+ * @param ruiz ruiz preconditioner.
+ * @param dual_feasibility_lhs primal infeasibility.
+ * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_1 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_3 scalar variable used when using a relative
+ * stopping criterion.
+ */
+template<typename T>
+void
+global_dual_residual(Results<T>& qpresults,
+                     Workspace<T>& qpwork,
+                     const Model<T>& qpmodel,
+                     const preconditioner::RuizEquilibration<T>& ruiz,
+                     T& dual_feasibility_lhs,
+                     T& dual_feasibility_rhs_0,
+                     T& dual_feasibility_rhs_1,
+                     T& dual_feasibility_rhs_3,
+                     T& rhs_duality_gap,
+                     T& duality_gap)
+{
+  // dual_feasibility_lhs = norm(dual_residual_scaled)
+  // dual_feasibility_rhs_0 = norm(unscaled(Hx))
+  // dual_feasibility_rhs_1 = norm(unscaled(ATy))
+  // dual_feasibility_rhs_3 = norm(unscaled(CTz))
+  //
+  // dual_residual_scaled = scaled(Hx + g + ATy + CTz)
+
+  qpwork.dual_residual_scaled = qpwork.g_scaled;
+  qpwork.CTz.noalias() =
+    qpwork.H_scaled.template selfadjointView<Eigen::Lower>() * qpresults.x;
+  qpwork.dual_residual_scaled += qpwork.CTz;
+  ruiz.unscale_dual_residual_in_place(
+    VectorViewMut<T>{ from_eigen, qpwork.CTz }); // contains unscaled Hx
+  dual_feasibility_rhs_0 = infty_norm(qpwork.CTz);
+
+  ruiz.unscale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
+  duality_gap = (qpmodel.g).dot(qpresults.x);
+  rhs_duality_gap = std::fabs(duality_gap);
+  const T xHx = (qpwork.CTz).dot(qpresults.x);
+  duality_gap += xHx; // contains now xHx+g.Tx
+  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(xHx));
+
+  ruiz.scale_primal_in_place(VectorViewMut<T>{ from_eigen, qpresults.x });
+
+  qpwork.CTz.noalias() = qpwork.A_scaled.transpose() * qpresults.y;
+  qpwork.dual_residual_scaled += qpwork.CTz;
+  ruiz.unscale_dual_residual_in_place(
+    VectorViewMut<T>{ from_eigen, qpwork.CTz });
+  dual_feasibility_rhs_1 = infty_norm(qpwork.CTz);
+
+  qpwork.CTz.noalias() = qpwork.C_scaled.transpose() * qpresults.z;
+  qpwork.dual_residual_scaled += qpwork.CTz;
+  ruiz.unscale_dual_residual_in_place(
+    VectorViewMut<T>{ from_eigen, qpwork.CTz });
+  dual_feasibility_rhs_3 = infty_norm(qpwork.CTz);
+
+  ruiz.unscale_dual_residual_in_place(
+    VectorViewMut<T>{ from_eigen, qpwork.dual_residual_scaled });
+
+  dual_feasibility_lhs = infty_norm(qpwork.dual_residual_scaled);
+
+  ruiz.scale_dual_residual_in_place(
+    VectorViewMut<T>{ from_eigen, qpwork.dual_residual_scaled });
+
+  ruiz.unscale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
+  const T by = (qpmodel.b).dot(qpresults.y);
+  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(by));
+  duality_gap += by;
+  ruiz.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, qpresults.y });
+
+  ruiz.unscale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
+
+  const T zu =
+    helpers::select(qpwork.active_set_up, qpresults.z, 0)
+      .dot(helpers::at_most(qpmodel.u, helpers::infinite_bound<T>::value()));
+  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zu));
+  duality_gap += zu;
+
+  const T zl =
+    helpers::select(qpwork.active_set_low, qpresults.z, 0)
+      .dot(helpers::at_least(qpmodel.l, -helpers::infinite_bound<T>::value()));
+  rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zl));
+  duality_gap += zl;
+
+  ruiz.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, qpresults.z });
+}
+
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_UTILS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/views.hpp

```diff
@@ -1,1466 +1,1460 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file views.hpp
- */
-#ifndef PROXSUITE_PROXQP_DENSE_VIEWS_HPP
-#define PROXSUITE_PROXQP_DENSE_VIEWS_HPP
-
-#include <proxsuite/linalg/veg/type_traits/core.hpp>
-#include <proxsuite/linalg/veg/util/dbg.hpp>
-#include <cstring>
-#include <type_traits>
-#include <Eigen/Core>
-
-#define LDLT_CONCEPT(...)                                                      \
-  VEG_CONCEPT_MACRO(::proxsuite::proxqp::concepts, __VA_ARGS__)
-#define LDLT_CHECK_CONCEPT(...)                                                \
-  VEG_CHECK_CONCEPT_MACRO(::proxqp::concepts, __VA_ARGS__)
-
-namespace proxsuite {
-namespace proxqp {
-
-using usize = decltype(sizeof(0));
-namespace detail {
-template<typename Fn>
-struct FnInfo;
-template<typename Ret_, typename... Args>
-struct FnInfo<auto(Args...)->Ret_>
-{
-  template<usize I>
-  using Arg = proxsuite::linalg::veg::ith<I, Args...>;
-  using Ret = Ret_;
-};
-} // namespace detail
-
-#define LDLT_IMPL_GET_PARAM(Fn, Idx)                                           \
-  typename ::proxsuite::proxqp::detail::FnInfo<                                \
-    decltype Fn /* NOLINT */>::template Arg<(Idx)>,
-
-#define LDLT_IMPL_GET_PARAMS_0(NParams, ...)                                   \
-  __VEG_PP_TUPLE_FOR_EACH(LDLT_IMPL_GET_PARAM,                                 \
-                          (__VA_ARGS__),                                       \
-                          __VEG_PP_MAKE_TUPLE(__VEG_IMPL_PP_DEC(NParams)))
-
-#define LDLT_IMPL_GET_PARAMS_1(NParams, ...)
-
-#define LDLT_IMPL_GET_PARAMS(NParams, ...)                                     \
-  __VEG_PP_CAT2(LDLT_IMPL_GET_PARAMS_, __VEG_IMPL_PP_IS_1(NParams))            \
-  (NParams, __VA_ARGS__)
-
-#define LDLT_EXPLICIT_TPL_DEF(NParams, ...)                                    \
-  template auto __VA_ARGS__(                                                   \
-    LDLT_IMPL_GET_PARAMS(NParams, __VA_ARGS__)                                 \
-      typename ::proxsuite::proxqp::detail::FnInfo<                            \
-        decltype(__VA_ARGS__)>::template Arg<(NParams)-1>)                     \
-    ->typename ::proxsuite::proxqp::detail::FnInfo<decltype(__VA_ARGS__)>::Ret
-#define LDLT_EXPLICIT_TPL_DECL(NParams, ...)                                   \
-  extern LDLT_EXPLICIT_TPL_DEF(NParams, __VA_ARGS__)
-
-using proxsuite::linalg::veg::i32;
-using proxsuite::linalg::veg::i64;
-using proxsuite::linalg::veg::isize;
-using proxsuite::linalg::veg::u32;
-using proxsuite::linalg::veg::u64;
-using proxsuite::linalg::veg::usize;
-using f32 = float;
-using f64 = double;
-namespace detail {
-
-struct NoCopy
-{
-  NoCopy() = default;
-  ~NoCopy() = default;
-
-  NoCopy(NoCopy const&) = delete;
-  NoCopy(NoCopy&&) = delete;
-  auto operator=(NoCopy const&) -> NoCopy& = delete;
-  auto operator=(NoCopy&&) -> NoCopy& = delete;
-};
-
-template<typename Fn>
-struct Defer /* NOLINT */
-{
-  Fn fn;
-  NoCopy _;
-
-  VEG_INLINE ~Defer() noexcept(noexcept(VEG_FWD(fn)())) { VEG_FWD(fn)(); }
-};
-
-namespace nb {
-struct defer
-{
-  template<typename Fn>
-  VEG_INLINE constexpr auto operator()(Fn fn) const -> Defer<Fn>
-  {
-    return { VEG_FWD(fn), {} };
-  }
-};
-struct max2
-{
-  template<typename T>
-  VEG_INLINE constexpr auto operator()(T const& a, T const& b) const -> T const&
-  {
-    return a > b ? a : b;
-  }
-};
-struct min2
-{
-  template<typename T>
-  VEG_INLINE constexpr auto operator()(T a, T b) const -> T
-  {
-    return (a < b) ? a : b;
-  }
-};
-
-} // namespace nb
-
-template<typename T>
-constexpr auto
-min_list_impl(T init, T const* arr, usize n) noexcept -> T
-{
-  return (n == 0)
-           ? init
-           : nb::min2{}(init, detail::min_list_impl(*arr, arr + 1, n - 1));
-}
-template<typename T, usize N>
-constexpr auto
-cx_min_list(T const (&arr)[N]) noexcept -> T
-{
-  return detail::min_list_impl( //
-    arr[0],
-    arr + 1,
-    N - 1);
-}
-
-namespace nb {
-struct max_list
-{
-  template<typename T>
-  VEG_INLINE auto operator()(std::initializer_list<T> list) const -> T
-  {
-    T const* data = list.begin();
-    isize len = isize(list.size());
-
-    T current_max = data[0];
-    for (isize i = 1; i < len; ++i) {
-      if (data[i] > current_max) {
-        current_max = data[i];
-      }
-    }
-    return current_max;
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(defer);
-VEG_NIEBLOID(max2);
-VEG_NIEBLOID(min2);
-VEG_NIEBLOID(max_list);
-
-template<typename T, bool = std::is_floating_point<T>::value>
-struct SetZeroImpl
-{
-  static void fn(T* dest, usize n)
-  {
-    for (usize i = 0; i < n; ++i) {
-      *dest = 0;
-    }
-  }
-};
-
-template<typename T>
-struct SetZeroImpl<T, true>
-{
-  static void fn(T* dest, usize n)
-  {
-    // TODO: assert bit representation is zero
-    std::memset(dest, 0, n * sizeof(T));
-  }
-};
-
-template<typename T>
-void
-set_zero(T* dest, usize n)
-{
-  SetZeroImpl<T>::fn(dest, n);
-}
-
-constexpr auto
-round_up(isize n, isize k) noexcept -> isize
-{
-  return (n + k - 1) / k * k;
-}
-constexpr auto
-uround_up(usize n, usize k) noexcept -> usize
-{
-  return (n + k - 1) / k * k;
-}
-
-inline auto
-bytes_to_prev_aligned(void* ptr, usize align) noexcept -> isize
-{
-  using UPtr = std::uintptr_t;
-
-  UPtr mask = align - 1;
-  UPtr iptr = UPtr(ptr);
-  UPtr aligned_ptr = iptr & ~mask;
-  return isize(aligned_ptr - iptr);
-}
-inline auto
-bytes_to_next_aligned(void* ptr, usize align) noexcept -> isize
-{
-  using UPtr = std::uintptr_t;
-
-  UPtr mask = align - 1;
-  UPtr iptr = UPtr(ptr);
-  UPtr aligned_ptr = (iptr + mask) & ~mask;
-  return isize(aligned_ptr - iptr);
-}
-
-inline auto
-next_aligned(void* ptr, usize align) noexcept -> void*
-{
-  using BytePtr = unsigned char*;
-  using VoidPtr = void*;
-  return VoidPtr(BytePtr(ptr) + detail::bytes_to_next_aligned(ptr, align));
-}
-inline auto
-prev_aligned(void* ptr, usize align) noexcept -> void*
-{
-  using BytePtr = unsigned char*;
-  using VoidPtr = void*;
-  return VoidPtr(BytePtr(ptr) + detail::bytes_to_prev_aligned(ptr, align));
-}
-
-} // namespace detail
-
-enum struct Layout : unsigned char
-{
-  colmajor = 0,
-  rowmajor = 1,
-};
-
-constexpr Layout colmajor = Layout::colmajor;
-constexpr Layout rowmajor = Layout::rowmajor;
-
-constexpr auto
-flip_layout(Layout l) noexcept -> Layout
-{
-  return Layout(1 - u32(l));
-}
-constexpr auto
-to_eigen_layout(Layout l) -> int
-{
-  return l == colmajor ? Eigen::ColMajor : Eigen::RowMajor;
-}
-constexpr auto
-from_eigen_layout(int l) -> Layout
-{
-  return (unsigned(l) & Eigen::RowMajorBit) == Eigen::RowMajor ? rowmajor
-                                                               : colmajor;
-}
-
-static_assert(to_eigen_layout(from_eigen_layout(Eigen::ColMajor)) ==
-                Eigen::ColMajor,
-              ".");
-static_assert(to_eigen_layout(from_eigen_layout(Eigen::RowMajor)) ==
-                Eigen::RowMajor,
-              ".");
-
-namespace detail {
-template<Layout L>
-struct ElementAccess;
-
-template<>
-struct ElementAccess<Layout::colmajor>
-{
-  template<typename T>
-  VEG_INLINE static constexpr auto offset(T* ptr,
-                                          isize row,
-                                          isize col,
-                                          isize outer_stride) noexcept -> T*
-  {
-    return ptr + (usize(row) + usize(col) * usize(outer_stride));
-  }
-
-  using NextRowStride = Eigen::Stride<0, 0>;
-  using NextColStride = Eigen::InnerStride<Eigen::Dynamic>;
-  VEG_INLINE static auto next_row_stride(isize outer_stride) noexcept
-    -> NextRowStride
-  {
-    (void)outer_stride;
-    return NextRowStride{};
-  }
-  VEG_INLINE static auto next_col_stride(isize outer_stride) noexcept
-    -> NextColStride
-  {
-    return NextColStride /* NOLINT(modernize-return-braced-init-list) */ (
-      outer_stride);
-  }
-
-  template<typename T>
-  VEG_INLINE static void transpose_if_rowmajor(T* ptr,
-                                               isize dim,
-                                               isize outer_stride)
-  {
-    (void)ptr, (void)dim, (void)outer_stride;
-  }
-};
-
-template<>
-struct ElementAccess<Layout::rowmajor>
-{
-  template<typename T>
-  VEG_INLINE static constexpr auto offset(T* ptr,
-                                          isize row,
-                                          isize col,
-                                          isize outer_stride) noexcept -> T*
-  {
-    return ptr + (usize(col) + usize(row) * usize(outer_stride));
-  }
-
-  using NextColStride = Eigen::Stride<0, 0>;
-  using NextRowStride = Eigen::InnerStride<Eigen::Dynamic>;
-  VEG_INLINE static auto next_col_stride(isize outer_stride) noexcept
-    -> NextColStride
-  {
-    (void)outer_stride;
-    return NextColStride{};
-  }
-  VEG_INLINE static auto next_row_stride(isize outer_stride) noexcept
-    -> NextRowStride
-  {
-    return NextRowStride /* NOLINT(modernize-return-braced-init-list) */ (
-      outer_stride);
-  }
-
-  template<typename T>
-  VEG_INLINE static void transpose_if_rowmajor(T* ptr,
-                                               isize dim,
-                                               isize outer_stride)
-  {
-    Eigen::Map<                          //
-      Eigen::Matrix<                     //
-        T,                               //
-        Eigen::Dynamic,                  //
-        Eigen::Dynamic                   //
-        >,                               //
-      Eigen::Unaligned,                  //
-      Eigen::OuterStride<Eigen::Dynamic> //
-      >{
-      ptr,
-      dim,
-      dim,
-      Eigen::OuterStride<Eigen::Dynamic>(outer_stride),
-    }
-      .transposeInPlace();
-  }
-};
-} // namespace detail
-
-namespace detail {
-template<typename T>
-struct unlref
-{
-  using Type = T;
-};
-template<typename T>
-struct unlref<T&>
-{
-  using Type = T;
-};
-
-template<typename T>
-auto
-is_eigen_matrix_base_impl(Eigen::MatrixBase<T> const volatile*)
-  -> proxsuite::linalg::veg::meta::true_type;
-auto
-is_eigen_matrix_base_impl(void const volatile*)
-  -> proxsuite::linalg::veg::meta::false_type;
-
-template<typename T>
-auto
-is_eigen_owning_matrix_base_impl(Eigen::PlainObjectBase<T> const volatile*)
-  -> proxsuite::linalg::veg::meta::true_type;
-auto
-is_eigen_owning_matrix_base_impl(void const volatile*)
-  -> proxsuite::linalg::veg::meta::false_type;
-
-template<typename... Ts>
-using Void = void;
-
-template<typename Mat, typename T>
-using DataExpr = decltype(static_cast<T*>(VEG_DECLVAL(Mat&).data()));
-
-template<typename Dummy,
-         typename Fallback,
-         template<typename...>
-         class F,
-         typename... Ts>
-struct DetectedImpl : proxsuite::linalg::veg::meta::false_type
-{
-  using Type = Fallback;
-};
-
-template<typename Fallback, template<typename...> class F, typename... Ts>
-struct DetectedImpl<Void<F<Ts...>>, Fallback, F, Ts...>
-  : proxsuite::linalg::veg::meta::true_type
-{
-  using Type = F<Ts...>;
-};
-
-template<typename Fallback, template<typename...> class F, typename... Ts>
-using Detected = typename DetectedImpl<void, Fallback, F, Ts...>::Type;
-
-template<typename T>
-using CompTimeColsImpl =
-  proxsuite::linalg::veg::meta::constant<isize, isize(T::ColsAtCompileTime)>;
-template<typename T>
-using CompTimeRowsImpl =
-  proxsuite::linalg::veg::meta::constant<isize, isize(T::RowsAtCompileTime)>;
-template<typename T>
-using CompTimeInnerStrideImpl =
-  proxsuite::linalg::veg::meta::constant<isize,
-                                         isize(T::InnerStrideAtCompileTime)>;
-template<typename T>
-using LayoutImpl = proxsuite::linalg::veg::meta::
-  constant<Layout, (bool(T::IsRowMajor) ? rowmajor : colmajor)>;
-
-template<typename T, Layout L>
-using EigenMatMap = Eigen::Map<      //
-  Eigen::Matrix<                     //
-    T,                               //
-    Eigen::Dynamic,                  //
-    Eigen::Dynamic,                  //
-    (L == colmajor)                  //
-      ? Eigen::ColMajor              //
-      : Eigen::RowMajor              //
-    > const,                         //
-  Eigen::Unaligned,                  //
-  Eigen::OuterStride<Eigen::Dynamic> //
-  >;
-template<typename T, Layout L>
-using EigenMatMapMut = Eigen::Map<   //
-  Eigen::Matrix<                     //
-    T,                               //
-    Eigen::Dynamic,                  //
-    Eigen::Dynamic,                  //
-    (L == colmajor)                  //
-      ? Eigen::ColMajor              //
-      : Eigen::RowMajor              //
-    >,                               //
-  Eigen::Unaligned,                  //
-  Eigen::OuterStride<Eigen::Dynamic> //
-  >;
-
-template<typename T, typename Stride>
-using EigenVecMap = Eigen::Map< //
-  Eigen::Matrix<                //
-    T,                          //
-    Eigen::Dynamic,             //
-    1                           //
-    > const,                    //
-  Eigen::Unaligned,             //
-  Stride                        //
-  >;
-template<typename T, typename Stride>
-using EigenVecMapMut = Eigen::Map< //
-  Eigen::Matrix<                   //
-    T,                             //
-    Eigen::Dynamic,                //
-    1                              //
-    >,                             //
-  Eigen::Unaligned,                //
-  Stride                           //
-  >;
-
-template<typename T, Layout L>
-using ColToVec = EigenVecMap<T, typename ElementAccess<L>::NextRowStride>;
-template<typename T, Layout L>
-using RowToVec = EigenVecMap<T, typename ElementAccess<L>::NextColStride>;
-template<typename T, Layout L>
-using ColToVecMut = EigenVecMapMut<T, typename ElementAccess<L>::NextRowStride>;
-template<typename T, Layout L>
-using RowToVecMut = EigenVecMapMut<T, typename ElementAccess<L>::NextColStride>;
-
-template<typename T>
-using VecMap = EigenVecMap<T, Eigen::Stride<0, 0>>;
-template<typename T>
-using VecMapMut = EigenVecMapMut<T, Eigen::Stride<0, 0>>;
-
-} // namespace detail
-
-template<typename T>
-using unref = typename detail::unlref<T&>::Type;
-
-namespace eigen {
-template<typename T>
-using CompTimeCols =
-  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
-                   detail::CompTimeColsImpl,
-                   T>;
-template<typename T>
-using CompTimeRows =
-  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
-                   detail::CompTimeRowsImpl,
-                   T>;
-template<typename T>
-using CompTimeInnerStride =
-  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
-                   detail::CompTimeInnerStrideImpl,
-                   T>;
-template<typename T>
-using GetLayout =
-  detail::Detected<proxsuite::linalg::veg::meta::
-                     constant<Layout, Layout(static_cast<unsigned char>(-1))>,
-                   detail::LayoutImpl,
-                   T>;
-} // namespace eigen
-
-namespace concepts {
-VEG_DEF_CONCEPT(typename T, rvalue_ref, std::is_rvalue_reference<T>::value);
-VEG_DEF_CONCEPT(typename T, lvalue_ref, std::is_lvalue_reference<T>::value);
-VEG_DEF_CONCEPT((template<typename...> class F, typename... Ts),
-                detected,
-                detail::DetectedImpl<void, void, F, Ts...>::value);
-
-namespace aux {
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                has_data_expr,
-                LDLT_CONCEPT(detected<detail::DataExpr, Mat, T>));
-
-VEG_DEF_CONCEPT((typename Mat),
-                matrix_base,
-                decltype(detail::is_eigen_matrix_base_impl(
-                  static_cast<Mat*>(nullptr)))::value);
-
-VEG_DEF_CONCEPT((typename Mat),
-                is_plain_object_base,
-                decltype(detail::is_eigen_owning_matrix_base_impl(
-                  static_cast<Mat*>(nullptr)))::value);
-
-VEG_DEF_CONCEPT((typename Mat),
-                tmp_matrix,
-                (LDLT_CONCEPT(aux::is_plain_object_base<unref<Mat>>) &&
-                 !LDLT_CONCEPT(lvalue_ref<Mat>)));
-} // namespace aux
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_view,
-                (LDLT_CONCEPT(aux::matrix_base<unref<Mat>>) &&
-                 LDLT_CONCEPT(aux::has_data_expr<Mat, T const>)));
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_view_mut,
-                (LDLT_CONCEPT(aux::matrix_base<unref<Mat>>) &&
-                 LDLT_CONCEPT(aux::has_data_expr<Mat, T>) &&
-                 !LDLT_CONCEPT(aux::tmp_matrix<Mat>)));
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_strided_vector_view,
-                (LDLT_CONCEPT(eigen_view<Mat, T>) &&
-                 (eigen::CompTimeCols<unref<Mat>>::value == 1)));
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_strided_vector_view_mut,
-                (LDLT_CONCEPT(eigen_view_mut<Mat, T>) &&
-                 (eigen::CompTimeCols<unref<Mat>>::value == 1)));
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_vector_view,
-                (LDLT_CONCEPT(eigen_strided_vector_view<Mat, T>) &&
-                 (eigen::CompTimeInnerStride<unref<Mat>>::value == 1)));
-
-VEG_DEF_CONCEPT((typename Mat, typename T),
-                eigen_vector_view_mut,
-                (LDLT_CONCEPT(eigen_strided_vector_view_mut<Mat, T>) &&
-                 (eigen::CompTimeInnerStride<unref<Mat>>::value == 1)));
-} // namespace concepts
-
-inline namespace tags {
-VEG_TAG(from_ptr_size, FromPtrSize);
-VEG_TAG(from_ptr_size_stride, FromPtrSizeStride);
-VEG_TAG(from_ptr_rows_cols_stride, FromPtrRowsColsStride);
-VEG_TAG(from_eigen, FromEigen);
-} // namespace tags
-
-template<typename T>
-struct VectorView
-{
-  T const* data;
-  isize dim;
-
-  VEG_INLINE
-  VectorView(FromPtrSize /*tag*/, T const* _data, isize _dim) noexcept
-    : data(_data)
-    , dim(_dim)
-  {
-  }
-
-  VEG_TEMPLATE(typename Vec,
-               requires(LDLT_CONCEPT(eigen_vector_view<Vec, T>)),
-               VEG_INLINE VectorView,
-               (/*tag*/, FromEigen),
-               (vec, Vec const&))
-  noexcept
-    : data(vec.data())
-    , dim(vec.rows())
-  {
-  }
-
-  VEG_INLINE auto ptr(isize index) const noexcept -> T const*
-  {
-    return data + index;
-  }
-  VEG_INLINE auto operator()(isize index) const noexcept -> T const&
-  {
-    return *ptr(index);
-  }
-  VEG_INLINE auto segment(isize i, isize size) const noexcept -> VectorView
-  {
-    return {
-      from_ptr_size,
-      data + i,
-      size,
-    };
-  }
-  VEG_INLINE auto to_eigen() const -> detail::VecMap<T>
-  {
-    return detail::VecMap<T>(data, Eigen::Index(dim));
-  }
-};
-
-template<typename T>
-struct VectorViewMut
-{
-  T* data;
-  isize dim;
-
-  VEG_INLINE
-  VectorViewMut(FromPtrSize /*tag*/, T* _data, isize _dim) noexcept
-    : data(_data)
-    , dim(_dim)
-  {
-  }
-
-  VEG_TEMPLATE(typename Vec,
-               requires(LDLT_CONCEPT(eigen_vector_view_mut<Vec, T>)),
-               VEG_INLINE VectorViewMut,
-               (/*tag*/, FromEigen),
-               (vec, Vec&&))
-  noexcept
-    : data(vec.data())
-    , dim(vec.rows())
-  {
-  }
-
-  VEG_INLINE auto as_const() const noexcept -> VectorView<T>
-  {
-    return {
-      from_ptr_size,
-      data,
-      dim,
-    };
-  }
-  VEG_INLINE auto ptr(isize index) const noexcept -> T* { return data + index; }
-  VEG_INLINE auto operator()(isize index) const noexcept -> T&
-  {
-    return *ptr(index);
-  }
-  VEG_INLINE auto segment(isize i, isize size) const noexcept -> VectorViewMut
-  {
-    return {
-      from_ptr_size,
-      data + i,
-      size,
-    };
-  }
-  VEG_INLINE auto to_eigen() const -> detail::VecMapMut<T>
-  {
-    return detail::VecMapMut<T>(data, Eigen::Index(dim));
-  }
-};
-
-template<typename T>
-struct StridedVectorView
-{
-  T const* data;
-  isize dim;
-  isize stride;
-
-  VEG_INLINE
-  StridedVectorView(FromPtrSizeStride /*tag*/,
-                    T const* _data,
-                    isize _dim,
-                    isize _stride) noexcept
-    : data(_data)
-    , dim(_dim)
-    , stride(_stride)
-  {
-  }
-
-  VEG_TEMPLATE(typename Vec,
-               requires(LDLT_CONCEPT(eigen_strided_vector_view<Vec, T>)),
-               VEG_INLINE StridedVectorView,
-               (/*tag*/, FromEigen),
-               (vec, Vec const&))
-  noexcept
-    : data(vec.data())
-    , dim(vec.rows())
-    , stride(vec.innerStride())
-  {
-  }
-
-  VEG_INLINE auto ptr(isize index) const noexcept -> T const*
-  {
-    return data + stride * index;
-  }
-  VEG_INLINE auto operator()(isize index) const noexcept -> T const&
-  {
-    return *ptr(index);
-  }
-  VEG_INLINE auto segment(isize i, isize size) const noexcept
-    -> StridedVectorView
-  {
-    return {
-      from_ptr_size_stride,
-      data + stride * i,
-      size,
-      stride,
-    };
-  }
-  VEG_INLINE auto to_eigen() const
-    -> detail::EigenVecMap<T, Eigen::InnerStride<Eigen::Dynamic>>
-  {
-    return detail::EigenVecMap<T, Eigen::InnerStride<Eigen::Dynamic>>(
-      data,
-      Eigen::Index(dim),
-      Eigen::Index(1),
-      Eigen::InnerStride<Eigen::Dynamic>(Eigen::Index(stride)));
-  }
-};
-
-template<typename T>
-struct StridedVectorViewMut
-{
-  T* data;
-  isize dim;
-  isize stride;
-
-  VEG_INLINE
-  StridedVectorViewMut(FromPtrSizeStride /*tag*/,
-                       T* _data,
-                       isize _dim,
-                       isize _stride) noexcept
-    : data(_data)
-    , dim(_dim)
-    , stride(_stride)
-  {
-  }
-
-  VEG_TEMPLATE(typename Vec,
-               requires(LDLT_CONCEPT(eigen_strided_vector_view_mut<Vec, T>)),
-               VEG_INLINE StridedVectorViewMut,
-               (/*tag*/, FromEigen),
-               (vec, Vec&&))
-  noexcept
-    : data(vec.data())
-    , dim(vec.rows())
-    , stride(vec.innerStride())
-  {
-  }
-
-  VEG_INLINE auto as_const() const noexcept -> StridedVectorView<T>
-  {
-    return {
-      from_ptr_size_stride,
-      data,
-      dim,
-      stride,
-    };
-  }
-  VEG_INLINE auto ptr(isize index) const noexcept -> T*
-  {
-    return data + stride * index;
-  }
-  VEG_INLINE auto operator()(isize index) const noexcept -> T&
-  {
-    return *ptr(index);
-  }
-  VEG_INLINE auto segment(isize i, isize size) const noexcept
-    -> StridedVectorViewMut
-  {
-    return {
-      from_ptr_size_stride,
-      data + stride * i,
-      size,
-      stride,
-    };
-  }
-  VEG_INLINE auto to_eigen() const
-    -> detail::EigenVecMapMut<T, Eigen::InnerStride<Eigen::Dynamic>>
-  {
-    return detail::EigenVecMapMut<T, Eigen::InnerStride<Eigen::Dynamic>>(
-      data,
-      Eigen::Index(dim),
-      Eigen::Index(1),
-      Eigen::InnerStride<Eigen::Dynamic>(Eigen::Index(stride)));
-  }
-};
-
-template<typename T, Layout L>
-struct MatrixView
-{
-  T const* data;
-  isize rows;
-  isize cols;
-  isize outer_stride;
-
-  VEG_INLINE MatrixView(FromPtrRowsColsStride /*tag*/,
-                        T const* _data,
-                        isize _rows,
-                        isize _cols,
-                        isize _outer_stride) noexcept
-    : data(_data)
-    , rows(_rows)
-    , cols(_cols)
-    , outer_stride(_outer_stride)
-  {
-  }
-
-  VEG_TEMPLATE(typename Mat,
-               requires(LDLT_CONCEPT(eigen_view<Mat, T>) &&
-                        eigen::GetLayout<unref<Mat>>::value == L),
-               VEG_INLINE MatrixView,
-               (/*tag*/, FromEigen),
-               (mat, Mat const&))
-  noexcept
-    : data(mat.data())
-    , rows(mat.rows())
-    , cols(mat.cols())
-    , outer_stride(mat.outerStride())
-  {
-  }
-
-  VEG_INLINE auto ptr(isize row, isize col) const noexcept -> T const*
-  {
-    return detail::ElementAccess<L>::offset(data, row, col, outer_stride);
-  }
-  VEG_INLINE auto operator()(isize row, isize col) const noexcept -> T const&
-  {
-    return *ptr(row, col);
-  }
-  VEG_INLINE auto block(isize row,
-                        isize col,
-                        isize nrows,
-                        isize ncols) const noexcept -> MatrixView
-  {
-    return {
-      from_ptr_rows_cols_stride,
-      detail::ElementAccess<L>::offset(data, row, col, outer_stride),
-      nrows,
-      ncols,
-      outer_stride,
-    };
-  }
-
-private:
-  VEG_INLINE auto col_impl(
-    proxsuite::linalg::veg::meta::constant<Layout, colmajor> /*tag*/,
-    isize c) const noexcept -> VectorView<T>
-  {
-    return {
-      from_ptr_size,
-      data + c * outer_stride,
-      rows,
-    };
-  }
-  VEG_INLINE auto col_impl(
-    proxsuite::linalg::veg::meta::constant<Layout, rowmajor> /*tag*/,
-    isize c) const noexcept -> StridedVectorView<T>
-  {
-    return {
-      from_ptr_size_stride,
-      data + c,
-      rows,
-      outer_stride,
-    };
-  }
-
-public:
-  VEG_INLINE auto col(isize c) const noexcept -> proxsuite::linalg::veg::meta::
-    if_t<(L == colmajor), VectorView<T>, StridedVectorView<T>>
-  {
-    return col_impl(proxsuite::linalg::veg::meta::constant<Layout, L>{}, c);
-  }
-  VEG_INLINE auto row(isize r) const noexcept -> proxsuite::linalg::veg::meta::
-    if_t<(L == rowmajor), VectorView<T>, StridedVectorView<T>>
-  {
-    return trans().col(r);
-  }
-  VEG_INLINE auto trans() const noexcept
-    -> MatrixView<T, proxqp::flip_layout(L)>
-  {
-    return {
-      from_ptr_rows_cols_stride, data, cols, rows, outer_stride,
-    };
-  }
-  VEG_INLINE auto to_eigen() const noexcept -> detail::EigenMatMap<T, L>
-  {
-    return detail::EigenMatMap<T, L>(
-      data,
-      Eigen::Index(rows),
-      Eigen::Index(cols),
-      Eigen::OuterStride<Eigen::Dynamic>(Eigen::Index(outer_stride)));
-  }
-};
-
-template<typename T, Layout L>
-struct MatrixViewMut
-{
-  T* data;
-  isize rows;
-  isize cols;
-  isize outer_stride;
-
-  VEG_INLINE MatrixViewMut(FromPtrRowsColsStride /*tag*/,
-                           T* _data,
-                           isize _rows,
-                           isize _cols,
-                           isize _outer_stride) noexcept
-    : data(_data)
-    , rows(_rows)
-    , cols(_cols)
-    , outer_stride(_outer_stride)
-  {
-  }
-
-  VEG_TEMPLATE(typename Mat,
-               requires(LDLT_CONCEPT(eigen_view<Mat, T>) &&
-                        eigen::GetLayout<unref<Mat>>::value == L),
-               VEG_INLINE MatrixViewMut,
-               (/*tag*/, FromEigen),
-               (mat, Mat&&))
-  noexcept
-    : data(mat.data())
-    , rows(mat.rows())
-    , cols(mat.cols())
-    , outer_stride(mat.outerStride())
-  {
-  }
-
-  VEG_INLINE auto ptr(isize row, isize col) const noexcept -> T*
-  {
-    return detail::ElementAccess<L>::offset(data, row, col, outer_stride);
-  }
-  VEG_INLINE auto operator()(isize row, isize col) const noexcept -> T&
-  {
-    return *ptr(row, col);
-  }
-  VEG_INLINE auto block(isize row,
-                        isize col,
-                        isize nrows,
-                        isize ncols) const noexcept -> MatrixViewMut
-  {
-    return {
-      from_ptr_rows_cols_stride,
-      detail::ElementAccess<L>::offset(data, row, col, outer_stride),
-      nrows,
-      ncols,
-      outer_stride,
-    };
-  }
-
-private:
-  VEG_INLINE auto col_impl(
-    proxsuite::linalg::veg::meta::constant<Layout, colmajor> /*tag*/,
-    isize c) const noexcept -> VectorViewMut<T>
-  {
-    return {
-      from_ptr_size,
-      data + c * outer_stride,
-      rows,
-    };
-  }
-  VEG_INLINE auto col_impl(
-    proxsuite::linalg::veg::meta::constant<Layout, rowmajor> /*tag*/,
-    isize c) const noexcept -> StridedVectorViewMut<T>
-  {
-    return {
-      from_ptr_size_stride,
-      data + c,
-      rows,
-      outer_stride,
-    };
-  }
-
-public:
-  VEG_INLINE auto col(isize c) const noexcept -> proxsuite::linalg::veg::meta::
-    if_t<(L == colmajor), VectorViewMut<T>, StridedVectorViewMut<T>>
-  {
-    return col_impl(proxsuite::linalg::veg::meta::constant<Layout, L>{}, c);
-  }
-  VEG_INLINE auto row(isize r) const noexcept -> proxsuite::linalg::veg::meta::
-    if_t<(L == rowmajor), VectorViewMut<T>, StridedVectorViewMut<T>>
-  {
-    return trans().col(r);
-  }
-  VEG_INLINE auto trans() const noexcept
-    -> MatrixViewMut<T, proxqp::flip_layout(L)>
-  {
-    return {
-      from_ptr_rows_cols_stride, data, cols, rows, outer_stride,
-    };
-  }
-  VEG_INLINE auto to_eigen() const noexcept -> detail::EigenMatMapMut<T, L>
-  {
-    return detail::EigenMatMapMut<T, L>(
-      data,
-      Eigen::Index(rows),
-      Eigen::Index(cols),
-      Eigen::OuterStride<Eigen::Dynamic>(Eigen::Index(outer_stride)));
-  }
-  VEG_INLINE auto as_const() const noexcept -> MatrixView<T, L>
-  {
-    return {
-      from_ptr_rows_cols_stride, data, rows, cols, outer_stride,
-    };
-  }
-};
-
-template<typename T>
-struct LdltView
-{
-private:
-  MatrixView<T, colmajor> ld;
-
-public:
-  explicit LdltView(MatrixView<T, colmajor> ld) noexcept
-    : ld(ld)
-  {
-    VEG_DEBUG_ASSERT(ld.rows == ld.cols);
-  }
-
-  VEG_INLINE auto l() const noexcept -> MatrixView<T, colmajor> { return ld; }
-  VEG_INLINE auto d() const noexcept -> StridedVectorView<T>
-  {
-    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
-  }
-
-  VEG_INLINE auto head(isize k) const -> LdltView
-  {
-    return LdltView{ ld.block(0, 0, k, k) };
-  }
-  VEG_INLINE auto tail(isize k) const -> LdltView
-  {
-    isize n = ld.rows;
-    return LdltView{ ld.block(n - k, n - k, k, k) };
-  }
-};
-template<typename T>
-struct LdltViewMut
-{
-private:
-  MatrixViewMut<T, colmajor> ld;
-
-public:
-  explicit LdltViewMut(MatrixViewMut<T, colmajor> ld) noexcept
-    : ld(ld)
-  {
-    VEG_DEBUG_ASSERT(ld.rows == ld.cols);
-  }
-
-  VEG_INLINE auto l() const noexcept -> MatrixView<T, colmajor>
-  {
-    return ld.as_const();
-  }
-  VEG_INLINE auto l_mut() const noexcept -> MatrixViewMut<T, colmajor>
-  {
-    return ld;
-  }
-  VEG_INLINE auto d() const noexcept -> StridedVectorView<T>
-  {
-    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
-  }
-  VEG_INLINE auto d_mut() const noexcept -> StridedVectorViewMut<T>
-  {
-    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
-  }
-
-  VEG_INLINE auto as_const() const noexcept -> LdltView<T>
-  {
-    return LdltView<T>{ ld.as_const() };
-  }
-
-  VEG_INLINE auto head(isize k) const -> LdltViewMut
-  {
-    return LdltViewMut{ ld.block(0, 0, k, k) };
-  }
-  VEG_INLINE auto tail(isize k) const -> LdltViewMut
-  {
-    isize n = ld.rows;
-    return LdltViewMut{ ld.block(n - k, n - k, k, k) };
-  }
-};
-
-namespace detail {
-template<typename T>
-void
-noalias_mul_add(MatrixViewMut<T, colmajor> dst,
-                MatrixView<T, colmajor> lhs,
-                MatrixView<T, colmajor> rhs,
-                T factor)
-{
-
-  if ((dst.cols == 0) || (dst.rows == 0) || (lhs.cols == 0)) {
-    return;
-  }
-
-#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
-#define LAZY_PRODUCT(a, b) a.lazyProduct(b)
-#else
-#define LAZY_PRODUCT(a, b) a.operator*(b)
-#endif
-
-  if (dst.cols == 1 && dst.rows == 1) {
-    // dot
-    auto rhs_col = rhs.col(0);
-    auto lhs_row = lhs.row(0);
-    auto lhs_as_col = lhs.col(0);
-    lhs_as_col.dim = lhs_row.dim;
-    if (lhs_row.stride == 1) {
-      dst(0, 0) += factor * lhs_as_col.to_eigen().dot(rhs_col.to_eigen());
-    } else {
-      dst(0, 0) += factor * lhs_row.to_eigen().dot(rhs_col.to_eigen());
-    }
-  } else if (dst.cols == 1) {
-    // gemv
-    auto rhs_col = rhs.col(0);
-    auto dst_col = dst.col(0);
-    dst_col.to_eigen().noalias().operator+=(
-      factor * LAZY_PRODUCT(lhs.to_eigen(), rhs_col.to_eigen()));
-  }
-
-#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
-  else if ((dst.rows < 20) && (dst.cols < 20) && (rhs.rows < 20)) {
-    // gemm
-    // workaround for eigen 3.3.7 bug:
-    // https://gitlab.com/libeigen/eigen/-/issues/1562
-    using Stride = Eigen::OuterStride<Eigen::Dynamic>;
-    using Mat =
-      Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor, 20, 20>;
-    using MapMut = Eigen::Map<Mat, Eigen::Unaligned, Stride>;
-    using Map = Eigen::Map<Mat const, Eigen::Unaligned, Stride>;
-
-    MapMut(dst.data, dst.rows, dst.cols, Stride(dst.outer_stride))
-      .noalias()
-      .
-      operator+=(
-        factor *
-        LAZY_PRODUCT(
-          Map(lhs.data, lhs.rows, lhs.cols, Stride(lhs.outer_stride)),
-          Map(rhs.data, rhs.rows, rhs.cols, Stride(rhs.outer_stride))));
-  }
-#endif
-
-  else {
-    // gemm
-    dst.to_eigen().noalias().operator+=(
-      factor * LAZY_PRODUCT(lhs.to_eigen(), rhs.to_eigen()));
-  }
-
-#undef LAZY_PRODUCT
-}
-
-template<typename T>
-void
-noalias_mul_add_vec(VectorViewMut<T> dst,
-                    MatrixView<T, colmajor> lhs,
-                    VectorView<T> rhs,
-                    T factor)
-{
-  detail::noalias_mul_add<T>(
-    {
-      from_ptr_rows_cols_stride,
-      dst.data,
-      dst.dim,
-      1,
-      0,
-    },
-    lhs,
-    {
-      from_ptr_rows_cols_stride,
-      rhs.data,
-      rhs.dim,
-      1,
-      0,
-    },
-    VEG_FWD(factor));
-}
-
-template<typename T>
-auto
-dot(StridedVectorView<T> lhs, VectorView<T> rhs) -> T
-{
-  auto out = T(0);
-  detail::noalias_mul_add<T>(
-    {
-      from_ptr_rows_cols_stride,
-      std::addressof(out),
-      1,
-      1,
-      0,
-    },
-    {
-      from_ptr_rows_cols_stride,
-      lhs.data,
-      1,
-      lhs.dim,
-      lhs.stride,
-    },
-    {
-      from_ptr_rows_cols_stride,
-      rhs.data,
-      rhs.dim,
-      1,
-      0,
-    },
-    1);
-  return out;
-}
-template<typename T>
-void
-assign_cwise_prod(VectorViewMut<T> out,
-                  StridedVectorView<T> lhs,
-                  StridedVectorView<T> rhs)
-{
-  out.to_eigen() = lhs.to_eigen().cwiseProduct(rhs.to_eigen());
-}
-template<typename T>
-void
-assign_scalar_prod(VectorViewMut<T> out, T factor, VectorView<T> in)
-{
-  out.to_eigen() = in.to_eigen().operator*(factor);
-}
-
-template<typename T>
-void
-trans_tr_unit_up_solve_in_place_on_right(MatrixView<T, colmajor> tr,
-                                         MatrixViewMut<T, colmajor> rhs)
-{
-  if (rhs.cols == 1) {
-    tr.to_eigen()
-      .transpose()
-      .template triangularView<Eigen::UnitUpper>()
-      .template solveInPlace<Eigen::OnTheRight>(rhs.col(0).to_eigen());
-  } else {
-    tr.to_eigen()
-      .transpose()
-      .template triangularView<Eigen::UnitUpper>()
-      .template solveInPlace<Eigen::OnTheRight>(rhs.to_eigen());
-  }
-}
-
-template<typename T>
-void
-apply_diag_inv_on_right(MatrixViewMut<T, colmajor> out,
-                        StridedVectorView<T> d,
-                        MatrixView<T, colmajor> in)
-{
-  if (out.cols == 1) {
-    out.col(0).to_eigen() =
-      in.col(0).to_eigen().operator*(d.to_eigen().asDiagonal().inverse());
-  } else {
-    out.to_eigen() =
-      in.to_eigen().operator*(d.to_eigen().asDiagonal().inverse());
-  }
-}
-template<typename T>
-void
-apply_diag_on_right(MatrixViewMut<T, colmajor> out,
-                    StridedVectorView<T> d,
-                    MatrixView<T, colmajor> in)
-{
-  if (out.cols == 1) {
-    out.col(0).to_eigen() =
-      in.col(0).to_eigen().operator*(d.to_eigen().asDiagonal());
-  } else {
-    out.to_eigen() = in.to_eigen().operator*(d.to_eigen().asDiagonal());
-  }
-}
-
-template<typename T>
-void
-noalias_mul_sub_tr_lo(MatrixViewMut<T, colmajor> out,
-                      MatrixView<T, colmajor> lhs,
-                      MatrixView<T, rowmajor> rhs)
-{
-  if (lhs.cols == 1) {
-    out.to_eigen().template triangularView<Eigen::Lower>().operator-=(
-      lhs.col(0).to_eigen().operator*(
-        Eigen::Map<Eigen::Matrix<T, 1, Eigen::Dynamic> const>(
-          rhs.data, 1, rhs.cols)));
-  } else {
-    out.to_eigen().template triangularView<Eigen::Lower>().operator-=(
-      lhs.to_eigen().operator*(rhs.to_eigen()));
-  }
-}
-
-} // namespace detail
-} // namespace proxqp
-} // namespace proxsuite
-
-namespace proxsuite {
-namespace proxqp {
-
-namespace dense {
-
-struct EigenAllowAlloc
-{
-  bool alloc_was_allowed;
-  EigenAllowAlloc(EigenAllowAlloc&&) = delete;
-  EigenAllowAlloc(EigenAllowAlloc const&) = delete;
-  auto operator=(EigenAllowAlloc&&) -> EigenAllowAlloc& = delete;
-  auto operator=(EigenAllowAlloc const&) -> EigenAllowAlloc& = delete;
-
-#if defined(EIGEN_RUNTIME_NO_MALLOC)
-  EigenAllowAlloc() noexcept
-    : alloc_was_allowed(Eigen::internal::is_malloc_allowed())
-  {
-    Eigen::internal::set_is_malloc_allowed(true);
-  }
-  ~EigenAllowAlloc() noexcept
-  {
-    Eigen::internal::set_is_malloc_allowed(alloc_was_allowed);
-  }
-#else
-  EigenAllowAlloc() = default;
-#endif
-};
-
-template<typename T>
-struct QpView
-{
-
-  static constexpr Layout layout = rowmajor;
-
-  MatrixView<T, layout> H;
-  VectorView<T> g;
-
-  MatrixView<T, layout> A;
-  VectorView<T> b;
-  MatrixView<T, layout> C;
-  VectorView<T> d;
-};
-
-template<typename Scalar>
-struct QpViewBox
-{
-  static constexpr Layout layout = rowmajor;
-
-  MatrixView<Scalar, layout> H;
-  VectorView<Scalar> g;
-
-  MatrixView<Scalar, layout> A;
-  VectorView<Scalar> b;
-  MatrixView<Scalar, layout> C;
-  VectorView<Scalar> u;
-  VectorView<Scalar> l;
-};
-
-template<typename T>
-struct QpViewMut
-{
-  static constexpr Layout layout = rowmajor;
-
-  MatrixViewMut<T, layout> H;
-  VectorViewMut<T> g;
-
-  MatrixViewMut<T, layout> A;
-  VectorViewMut<T> b;
-  MatrixViewMut<T, layout> C;
-  VectorViewMut<T> d;
-
-  VEG_INLINE constexpr auto as_const() const noexcept -> QpView<T>
-  {
-    return {
-      H.as_const(), g.as_const(), A.as_const(),
-      b.as_const(), C.as_const(), d.as_const(),
-    };
-  }
-};
-
-template<typename Scalar>
-struct QpViewBoxMut
-{
-  static constexpr Layout layout = rowmajor;
-
-  MatrixViewMut<Scalar, layout> H;
-  VectorViewMut<Scalar> g;
-
-  MatrixViewMut<Scalar, layout> A;
-  VectorViewMut<Scalar> b;
-  MatrixViewMut<Scalar, layout> C;
-  VectorViewMut<Scalar> u;
-  VectorViewMut<Scalar> l;
-
-  VEG_INLINE constexpr auto as_const() const noexcept -> QpViewBox<Scalar>
-  {
-    return {
-      H.as_const(), g.as_const(), A.as_const(), b.as_const(),
-      C.as_const(), u.as_const(), l.as_const(),
-    };
-  }
-};
-
-namespace nb {
-struct pow
-{
-  template<typename T>
-  auto operator()(T x, T y) const -> T
-  {
-    using std::pow;
-    return pow(x, y);
-  }
-};
-struct infty_norm
-{
-  template<typename D>
-  auto operator()(Eigen::MatrixBase<D> const& mat) const -> typename D::Scalar
-  {
-    if (mat.rows() == 0 || mat.cols() == 0) {
-      return typename D::Scalar(0);
-    } else {
-      return mat.template lpNorm<Eigen::Infinity>();
-    }
-  }
-};
-struct sqrt
-{
-  template<typename T>
-  auto operator()(T x) const -> T
-  {
-    using std::sqrt;
-    return sqrt(x);
-  }
-};
-struct fabs
-{
-  template<typename T>
-  auto operator()(T x) const -> T
-  {
-    using std::fabs;
-    return fabs(x);
-  }
-};
-} // namespace nb
-VEG_NIEBLOID(fabs);
-VEG_NIEBLOID(sqrt);
-VEG_NIEBLOID(pow);
-VEG_NIEBLOID(infty_norm);
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_VIEWS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file views.hpp
+ */
+#ifndef PROXSUITE_PROXQP_DENSE_VIEWS_HPP
+#define PROXSUITE_PROXQP_DENSE_VIEWS_HPP
+
+#include <proxsuite/linalg/veg/type_traits/core.hpp>
+#include <proxsuite/linalg/veg/util/dbg.hpp>
+#include <cstring>
+#include <type_traits>
+#include <Eigen/Core>
+
+#define LDLT_CONCEPT(...)                                                      \
+  VEG_CONCEPT_MACRO(::proxsuite::proxqp::concepts, __VA_ARGS__)
+#define LDLT_CHECK_CONCEPT(...)                                                \
+  VEG_CHECK_CONCEPT_MACRO(::proxqp::concepts, __VA_ARGS__)
+
+namespace proxsuite {
+namespace proxqp {
+
+using usize = decltype(sizeof(0));
+namespace detail {
+template<typename Fn>
+struct FnInfo;
+template<typename Ret_, typename... Args>
+struct FnInfo<auto(Args...)->Ret_>
+{
+  template<usize I>
+  using Arg = proxsuite::linalg::veg::ith<I, Args...>;
+  using Ret = Ret_;
+};
+} // namespace detail
+
+#define LDLT_IMPL_GET_PARAM(Fn, Idx)                                           \
+  typename ::proxsuite::proxqp::detail::FnInfo<                                \
+    decltype Fn /* NOLINT */>::template Arg<(Idx)>,
+
+#define LDLT_IMPL_GET_PARAMS_0(NParams, ...)                                   \
+  __VEG_PP_TUPLE_FOR_EACH(LDLT_IMPL_GET_PARAM,                                 \
+                          (__VA_ARGS__),                                       \
+                          __VEG_PP_MAKE_TUPLE(__VEG_IMPL_PP_DEC(NParams)))
+
+#define LDLT_IMPL_GET_PARAMS_1(NParams, ...)
+
+#define LDLT_IMPL_GET_PARAMS(NParams, ...)                                     \
+  __VEG_PP_CAT2(LDLT_IMPL_GET_PARAMS_, __VEG_IMPL_PP_IS_1(NParams))            \
+  (NParams, __VA_ARGS__)
+
+#define LDLT_EXPLICIT_TPL_DEF(NParams, ...)                                    \
+  template auto __VA_ARGS__(                                                   \
+    LDLT_IMPL_GET_PARAMS(NParams, __VA_ARGS__)                                 \
+      typename ::proxsuite::proxqp::detail::FnInfo<                            \
+        decltype(__VA_ARGS__)>::template Arg<(NParams)-1>)                     \
+    ->typename ::proxsuite::proxqp::detail::FnInfo<decltype(__VA_ARGS__)>::Ret
+#define LDLT_EXPLICIT_TPL_DECL(NParams, ...)                                   \
+  extern LDLT_EXPLICIT_TPL_DEF(NParams, __VA_ARGS__)
+
+using proxsuite::linalg::veg::i32;
+using proxsuite::linalg::veg::i64;
+using proxsuite::linalg::veg::isize;
+using proxsuite::linalg::veg::u32;
+using proxsuite::linalg::veg::u64;
+using proxsuite::linalg::veg::usize;
+using f32 = float;
+using f64 = double;
+namespace detail {
+
+struct NoCopy
+{
+  NoCopy() = default;
+  ~NoCopy() = default;
+
+  NoCopy(NoCopy const&) = delete;
+  NoCopy(NoCopy&&) = delete;
+  auto operator=(NoCopy const&) -> NoCopy& = delete;
+  auto operator=(NoCopy&&) -> NoCopy& = delete;
+};
+
+template<typename Fn>
+struct Defer /* NOLINT */
+{
+  Fn fn;
+  NoCopy _;
+
+  VEG_INLINE ~Defer() noexcept(noexcept(VEG_FWD(fn)())) { VEG_FWD(fn)(); }
+};
+
+namespace nb {
+struct defer
+{
+  template<typename Fn>
+  VEG_INLINE constexpr auto operator()(Fn fn) const -> Defer<Fn>
+  {
+    return { VEG_FWD(fn), {} };
+  }
+};
+struct max2
+{
+  template<typename T>
+  VEG_INLINE constexpr auto operator()(T const& a, T const& b) const -> T const&
+  {
+    return a > b ? a : b;
+  }
+};
+struct min2
+{
+  template<typename T>
+  VEG_INLINE constexpr auto operator()(T a, T b) const -> T
+  {
+    return (a < b) ? a : b;
+  }
+};
+
+} // namespace nb
+
+template<typename T>
+constexpr auto
+min_list_impl(T init, T const* arr, usize n) noexcept -> T
+{
+  return (n == 0)
+           ? init
+           : nb::min2{}(init, detail::min_list_impl(*arr, arr + 1, n - 1));
+}
+template<typename T, usize N>
+constexpr auto
+cx_min_list(T const (&arr)[N]) noexcept -> T
+{
+  return detail::min_list_impl( //
+    arr[0],
+    arr + 1,
+    N - 1);
+}
+
+namespace nb {
+struct max_list
+{
+  template<typename T>
+  VEG_INLINE auto operator()(std::initializer_list<T> list) const -> T
+  {
+    T const* data = list.begin();
+    isize len = isize(list.size());
+
+    T current_max = data[0];
+    for (isize i = 1; i < len; ++i) {
+      if (data[i] > current_max) {
+        current_max = data[i];
+      }
+    }
+    return current_max;
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(defer);
+VEG_NIEBLOID(max2);
+VEG_NIEBLOID(min2);
+VEG_NIEBLOID(max_list);
+
+template<typename T, bool = std::is_floating_point<T>::value>
+struct SetZeroImpl
+{
+  static void fn(T* dest, usize n)
+  {
+    for (usize i = 0; i < n; ++i) {
+      *dest = 0;
+    }
+  }
+};
+
+template<typename T>
+struct SetZeroImpl<T, true>
+{
+  static void fn(T* dest, usize n)
+  {
+    // TODO: assert bit representation is zero
+    std::memset(dest, 0, n * sizeof(T));
+  }
+};
+
+template<typename T>
+void
+set_zero(T* dest, usize n)
+{
+  SetZeroImpl<T>::fn(dest, n);
+}
+
+constexpr auto
+round_up(isize n, isize k) noexcept -> isize
+{
+  return (n + k - 1) / k * k;
+}
+constexpr auto
+uround_up(usize n, usize k) noexcept -> usize
+{
+  return (n + k - 1) / k * k;
+}
+
+inline auto
+bytes_to_prev_aligned(void* ptr, usize align) noexcept -> isize
+{
+  using UPtr = std::uintptr_t;
+
+  UPtr mask = align - 1;
+  UPtr iptr = UPtr(ptr);
+  UPtr aligned_ptr = iptr & ~mask;
+  return isize(aligned_ptr - iptr);
+}
+inline auto
+bytes_to_next_aligned(void* ptr, usize align) noexcept -> isize
+{
+  using UPtr = std::uintptr_t;
+
+  UPtr mask = align - 1;
+  UPtr iptr = UPtr(ptr);
+  UPtr aligned_ptr = (iptr + mask) & ~mask;
+  return isize(aligned_ptr - iptr);
+}
+
+inline auto
+next_aligned(void* ptr, usize align) noexcept -> void*
+{
+  using BytePtr = unsigned char*;
+  using VoidPtr = void*;
+  return VoidPtr(BytePtr(ptr) + detail::bytes_to_next_aligned(ptr, align));
+}
+inline auto
+prev_aligned(void* ptr, usize align) noexcept -> void*
+{
+  using BytePtr = unsigned char*;
+  using VoidPtr = void*;
+  return VoidPtr(BytePtr(ptr) + detail::bytes_to_prev_aligned(ptr, align));
+}
+
+} // namespace detail
+
+enum struct Layout : unsigned char
+{
+  colmajor = 0,
+  rowmajor = 1,
+};
+
+constexpr Layout colmajor = Layout::colmajor;
+constexpr Layout rowmajor = Layout::rowmajor;
+
+constexpr auto
+flip_layout(Layout l) noexcept -> Layout
+{
+  return Layout(1 - u32(l));
+}
+constexpr auto
+to_eigen_layout(Layout l) -> int
+{
+  return l == colmajor ? Eigen::ColMajor : Eigen::RowMajor;
+}
+constexpr auto
+from_eigen_layout(int l) -> Layout
+{
+  return (unsigned(l) & Eigen::RowMajorBit) == Eigen::RowMajor ? rowmajor
+                                                               : colmajor;
+}
+
+static_assert(to_eigen_layout(from_eigen_layout(Eigen::ColMajor)) ==
+                Eigen::ColMajor,
+              ".");
+static_assert(to_eigen_layout(from_eigen_layout(Eigen::RowMajor)) ==
+                Eigen::RowMajor,
+              ".");
+
+namespace detail {
+template<Layout L>
+struct ElementAccess;
+
+template<>
+struct ElementAccess<Layout::colmajor>
+{
+  template<typename T>
+  VEG_INLINE static constexpr auto offset(T* ptr,
+                                          isize row,
+                                          isize col,
+                                          isize outer_stride) noexcept -> T*
+  {
+    return ptr + (usize(row) + usize(col) * usize(outer_stride));
+  }
+
+  using NextRowStride = Eigen::Stride<0, 0>;
+  using NextColStride = Eigen::InnerStride<Eigen::Dynamic>;
+  VEG_INLINE static auto next_row_stride(isize outer_stride) noexcept
+    -> NextRowStride
+  {
+    (void)outer_stride;
+    return NextRowStride{};
+  }
+  VEG_INLINE static auto next_col_stride(isize outer_stride) noexcept
+    -> NextColStride
+  {
+    return NextColStride /* NOLINT(modernize-return-braced-init-list) */ (
+      outer_stride);
+  }
+
+  template<typename T>
+  VEG_INLINE static void transpose_if_rowmajor(T* ptr,
+                                               isize dim,
+                                               isize outer_stride)
+  {
+    (void)ptr, (void)dim, (void)outer_stride;
+  }
+};
+
+template<>
+struct ElementAccess<Layout::rowmajor>
+{
+  template<typename T>
+  VEG_INLINE static constexpr auto offset(T* ptr,
+                                          isize row,
+                                          isize col,
+                                          isize outer_stride) noexcept -> T*
+  {
+    return ptr + (usize(col) + usize(row) * usize(outer_stride));
+  }
+
+  using NextColStride = Eigen::Stride<0, 0>;
+  using NextRowStride = Eigen::InnerStride<Eigen::Dynamic>;
+  VEG_INLINE static auto next_col_stride(isize outer_stride) noexcept
+    -> NextColStride
+  {
+    (void)outer_stride;
+    return NextColStride{};
+  }
+  VEG_INLINE static auto next_row_stride(isize outer_stride) noexcept
+    -> NextRowStride
+  {
+    return NextRowStride /* NOLINT(modernize-return-braced-init-list) */ (
+      outer_stride);
+  }
+
+  template<typename T>
+  VEG_INLINE static void transpose_if_rowmajor(T* ptr,
+                                               isize dim,
+                                               isize outer_stride)
+  {
+    Eigen::Map<                          //
+      Eigen::Matrix<                     //
+        T,                               //
+        Eigen::Dynamic,                  //
+        Eigen::Dynamic                   //
+        >,                               //
+      Eigen::Unaligned,                  //
+      Eigen::OuterStride<Eigen::Dynamic> //
+      >{
+      ptr,
+      dim,
+      dim,
+      Eigen::OuterStride<Eigen::Dynamic>(outer_stride),
+    }
+      .transposeInPlace();
+  }
+};
+} // namespace detail
+
+namespace detail {
+template<typename T>
+struct unlref
+{
+  using Type = T;
+};
+template<typename T>
+struct unlref<T&>
+{
+  using Type = T;
+};
+
+template<typename T>
+auto
+is_eigen_matrix_base_impl(Eigen::MatrixBase<T> const volatile*)
+  -> proxsuite::linalg::veg::meta::true_type;
+auto
+is_eigen_matrix_base_impl(void const volatile*)
+  -> proxsuite::linalg::veg::meta::false_type;
+
+template<typename T>
+auto
+is_eigen_owning_matrix_base_impl(Eigen::PlainObjectBase<T> const volatile*)
+  -> proxsuite::linalg::veg::meta::true_type;
+auto
+is_eigen_owning_matrix_base_impl(void const volatile*)
+  -> proxsuite::linalg::veg::meta::false_type;
+
+template<typename... Ts>
+using Void = void;
+
+template<typename Mat, typename T>
+using DataExpr = decltype(static_cast<T*>(VEG_DECLVAL(Mat&).data()));
+
+template<typename Dummy,
+         typename Fallback,
+         template<typename...>
+         class F,
+         typename... Ts>
+struct DetectedImpl : proxsuite::linalg::veg::meta::false_type
+{
+  using Type = Fallback;
+};
+
+template<typename Fallback, template<typename...> class F, typename... Ts>
+struct DetectedImpl<Void<F<Ts...>>, Fallback, F, Ts...>
+  : proxsuite::linalg::veg::meta::true_type
+{
+  using Type = F<Ts...>;
+};
+
+template<typename Fallback, template<typename...> class F, typename... Ts>
+using Detected = typename DetectedImpl<void, Fallback, F, Ts...>::Type;
+
+template<typename T>
+using CompTimeColsImpl =
+  proxsuite::linalg::veg::meta::constant<isize, isize(T::ColsAtCompileTime)>;
+template<typename T>
+using CompTimeRowsImpl =
+  proxsuite::linalg::veg::meta::constant<isize, isize(T::RowsAtCompileTime)>;
+template<typename T>
+using CompTimeInnerStrideImpl =
+  proxsuite::linalg::veg::meta::constant<isize,
+                                         isize(T::InnerStrideAtCompileTime)>;
+template<typename T>
+using LayoutImpl = proxsuite::linalg::veg::meta::
+  constant<Layout, (bool(T::IsRowMajor) ? rowmajor : colmajor)>;
+
+template<typename T, Layout L>
+using EigenMatMap = Eigen::Map<      //
+  Eigen::Matrix<                     //
+    T,                               //
+    Eigen::Dynamic,                  //
+    Eigen::Dynamic,                  //
+    (L == colmajor)                  //
+      ? Eigen::ColMajor              //
+      : Eigen::RowMajor              //
+    > const,                         //
+  Eigen::Unaligned,                  //
+  Eigen::OuterStride<Eigen::Dynamic> //
+  >;
+template<typename T, Layout L>
+using EigenMatMapMut = Eigen::Map<   //
+  Eigen::Matrix<                     //
+    T,                               //
+    Eigen::Dynamic,                  //
+    Eigen::Dynamic,                  //
+    (L == colmajor)                  //
+      ? Eigen::ColMajor              //
+      : Eigen::RowMajor              //
+    >,                               //
+  Eigen::Unaligned,                  //
+  Eigen::OuterStride<Eigen::Dynamic> //
+  >;
+
+template<typename T, typename Stride>
+using EigenVecMap = Eigen::Map< //
+  Eigen::Matrix<                //
+    T,                          //
+    Eigen::Dynamic,             //
+    1                           //
+    > const,                    //
+  Eigen::Unaligned,             //
+  Stride                        //
+  >;
+template<typename T, typename Stride>
+using EigenVecMapMut = Eigen::Map< //
+  Eigen::Matrix<                   //
+    T,                             //
+    Eigen::Dynamic,                //
+    1                              //
+    >,                             //
+  Eigen::Unaligned,                //
+  Stride                           //
+  >;
+
+template<typename T, Layout L>
+using ColToVec = EigenVecMap<T, typename ElementAccess<L>::NextRowStride>;
+template<typename T, Layout L>
+using RowToVec = EigenVecMap<T, typename ElementAccess<L>::NextColStride>;
+template<typename T, Layout L>
+using ColToVecMut = EigenVecMapMut<T, typename ElementAccess<L>::NextRowStride>;
+template<typename T, Layout L>
+using RowToVecMut = EigenVecMapMut<T, typename ElementAccess<L>::NextColStride>;
+
+template<typename T>
+using VecMap = EigenVecMap<T, Eigen::Stride<0, 0>>;
+template<typename T>
+using VecMapMut = EigenVecMapMut<T, Eigen::Stride<0, 0>>;
+
+} // namespace detail
+
+template<typename T>
+using unref = typename detail::unlref<T&>::Type;
+
+namespace eigen {
+template<typename T>
+using CompTimeCols =
+  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
+                   detail::CompTimeColsImpl,
+                   T>;
+template<typename T>
+using CompTimeRows =
+  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
+                   detail::CompTimeRowsImpl,
+                   T>;
+template<typename T>
+using CompTimeInnerStride =
+  detail::Detected<proxsuite::linalg::veg::meta::constant<isize, 0>,
+                   detail::CompTimeInnerStrideImpl,
+                   T>;
+template<typename T>
+using GetLayout =
+  detail::Detected<proxsuite::linalg::veg::meta::
+                     constant<Layout, Layout(static_cast<unsigned char>(-1))>,
+                   detail::LayoutImpl,
+                   T>;
+} // namespace eigen
+
+namespace concepts {
+VEG_DEF_CONCEPT(typename T, rvalue_ref, std::is_rvalue_reference<T>::value);
+VEG_DEF_CONCEPT(typename T, lvalue_ref, std::is_lvalue_reference<T>::value);
+VEG_DEF_CONCEPT((template<typename...> class F, typename... Ts),
+                detected,
+                detail::DetectedImpl<void, void, F, Ts...>::value);
+
+namespace aux {
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                has_data_expr,
+                LDLT_CONCEPT(detected<detail::DataExpr, Mat, T>));
+
+VEG_DEF_CONCEPT((typename Mat),
+                matrix_base,
+                decltype(detail::is_eigen_matrix_base_impl(
+                  static_cast<Mat*>(nullptr)))::value);
+
+VEG_DEF_CONCEPT((typename Mat),
+                is_plain_object_base,
+                decltype(detail::is_eigen_owning_matrix_base_impl(
+                  static_cast<Mat*>(nullptr)))::value);
+
+VEG_DEF_CONCEPT((typename Mat),
+                tmp_matrix,
+                (LDLT_CONCEPT(aux::is_plain_object_base<unref<Mat>>) &&
+                 !LDLT_CONCEPT(lvalue_ref<Mat>)));
+} // namespace aux
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_view,
+                (LDLT_CONCEPT(aux::matrix_base<unref<Mat>>) &&
+                 LDLT_CONCEPT(aux::has_data_expr<Mat, T const>)));
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_view_mut,
+                (LDLT_CONCEPT(aux::matrix_base<unref<Mat>>) &&
+                 LDLT_CONCEPT(aux::has_data_expr<Mat, T>) &&
+                 !LDLT_CONCEPT(aux::tmp_matrix<Mat>)));
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_strided_vector_view,
+                (LDLT_CONCEPT(eigen_view<Mat, T>) &&
+                 (eigen::CompTimeCols<unref<Mat>>::value == 1)));
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_strided_vector_view_mut,
+                (LDLT_CONCEPT(eigen_view_mut<Mat, T>) &&
+                 (eigen::CompTimeCols<unref<Mat>>::value == 1)));
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_vector_view,
+                (LDLT_CONCEPT(eigen_strided_vector_view<Mat, T>) &&
+                 (eigen::CompTimeInnerStride<unref<Mat>>::value == 1)));
+
+VEG_DEF_CONCEPT((typename Mat, typename T),
+                eigen_vector_view_mut,
+                (LDLT_CONCEPT(eigen_strided_vector_view_mut<Mat, T>) &&
+                 (eigen::CompTimeInnerStride<unref<Mat>>::value == 1)));
+} // namespace concepts
+
+inline namespace tags {
+VEG_TAG(from_ptr_size, FromPtrSize);
+VEG_TAG(from_ptr_size_stride, FromPtrSizeStride);
+VEG_TAG(from_ptr_rows_cols_stride, FromPtrRowsColsStride);
+VEG_TAG(from_eigen, FromEigen);
+} // namespace tags
+
+template<typename T>
+struct VectorView
+{
+  T const* data;
+  isize dim;
+
+  VEG_INLINE
+  VectorView(FromPtrSize /*tag*/, T const* _data, isize _dim) noexcept
+    : data(_data)
+    , dim(_dim)
+  {
+  }
+
+  VEG_TEMPLATE(typename Vec,
+               requires(LDLT_CONCEPT(eigen_vector_view<Vec, T>)),
+               VEG_INLINE VectorView,
+               (/*tag*/, FromEigen),
+               (vec, Vec const&)) noexcept
+    : data(vec.data())
+    , dim(vec.rows())
+  {
+  }
+
+  VEG_INLINE auto ptr(isize index) const noexcept -> T const*
+  {
+    return data + index;
+  }
+  VEG_INLINE auto operator()(isize index) const noexcept -> T const&
+  {
+    return *ptr(index);
+  }
+  VEG_INLINE auto segment(isize i, isize size) const noexcept -> VectorView
+  {
+    return {
+      from_ptr_size,
+      data + i,
+      size,
+    };
+  }
+  VEG_INLINE auto to_eigen() const -> detail::VecMap<T>
+  {
+    return detail::VecMap<T>(data, Eigen::Index(dim));
+  }
+};
+
+template<typename T>
+struct VectorViewMut
+{
+  T* data;
+  isize dim;
+
+  VEG_INLINE
+  VectorViewMut(FromPtrSize /*tag*/, T* _data, isize _dim) noexcept
+    : data(_data)
+    , dim(_dim)
+  {
+  }
+
+  VEG_TEMPLATE(typename Vec,
+               requires(LDLT_CONCEPT(eigen_vector_view_mut<Vec, T>)),
+               VEG_INLINE VectorViewMut,
+               (/*tag*/, FromEigen),
+               (vec, Vec&&)) noexcept
+    : data(vec.data())
+    , dim(vec.rows())
+  {
+  }
+
+  VEG_INLINE auto as_const() const noexcept -> VectorView<T>
+  {
+    return {
+      from_ptr_size,
+      data,
+      dim,
+    };
+  }
+  VEG_INLINE auto ptr(isize index) const noexcept -> T* { return data + index; }
+  VEG_INLINE auto operator()(isize index) const noexcept -> T&
+  {
+    return *ptr(index);
+  }
+  VEG_INLINE auto segment(isize i, isize size) const noexcept -> VectorViewMut
+  {
+    return {
+      from_ptr_size,
+      data + i,
+      size,
+    };
+  }
+  VEG_INLINE auto to_eigen() const -> detail::VecMapMut<T>
+  {
+    return detail::VecMapMut<T>(data, Eigen::Index(dim));
+  }
+};
+
+template<typename T>
+struct StridedVectorView
+{
+  T const* data;
+  isize dim;
+  isize stride;
+
+  VEG_INLINE
+  StridedVectorView(FromPtrSizeStride /*tag*/,
+                    T const* _data,
+                    isize _dim,
+                    isize _stride) noexcept
+    : data(_data)
+    , dim(_dim)
+    , stride(_stride)
+  {
+  }
+
+  VEG_TEMPLATE(typename Vec,
+               requires(LDLT_CONCEPT(eigen_strided_vector_view<Vec, T>)),
+               VEG_INLINE StridedVectorView,
+               (/*tag*/, FromEigen),
+               (vec, Vec const&)) noexcept
+    : data(vec.data())
+    , dim(vec.rows())
+    , stride(vec.innerStride())
+  {
+  }
+
+  VEG_INLINE auto ptr(isize index) const noexcept -> T const*
+  {
+    return data + stride * index;
+  }
+  VEG_INLINE auto operator()(isize index) const noexcept -> T const&
+  {
+    return *ptr(index);
+  }
+  VEG_INLINE auto segment(isize i, isize size) const noexcept
+    -> StridedVectorView
+  {
+    return {
+      from_ptr_size_stride,
+      data + stride * i,
+      size,
+      stride,
+    };
+  }
+  VEG_INLINE auto to_eigen() const
+    -> detail::EigenVecMap<T, Eigen::InnerStride<Eigen::Dynamic>>
+  {
+    return detail::EigenVecMap<T, Eigen::InnerStride<Eigen::Dynamic>>(
+      data,
+      Eigen::Index(dim),
+      Eigen::Index(1),
+      Eigen::InnerStride<Eigen::Dynamic>(Eigen::Index(stride)));
+  }
+};
+
+template<typename T>
+struct StridedVectorViewMut
+{
+  T* data;
+  isize dim;
+  isize stride;
+
+  VEG_INLINE
+  StridedVectorViewMut(FromPtrSizeStride /*tag*/,
+                       T* _data,
+                       isize _dim,
+                       isize _stride) noexcept
+    : data(_data)
+    , dim(_dim)
+    , stride(_stride)
+  {
+  }
+
+  VEG_TEMPLATE(typename Vec,
+               requires(LDLT_CONCEPT(eigen_strided_vector_view_mut<Vec, T>)),
+               VEG_INLINE StridedVectorViewMut,
+               (/*tag*/, FromEigen),
+               (vec, Vec&&)) noexcept
+    : data(vec.data())
+    , dim(vec.rows())
+    , stride(vec.innerStride())
+  {
+  }
+
+  VEG_INLINE auto as_const() const noexcept -> StridedVectorView<T>
+  {
+    return {
+      from_ptr_size_stride,
+      data,
+      dim,
+      stride,
+    };
+  }
+  VEG_INLINE auto ptr(isize index) const noexcept -> T*
+  {
+    return data + stride * index;
+  }
+  VEG_INLINE auto operator()(isize index) const noexcept -> T&
+  {
+    return *ptr(index);
+  }
+  VEG_INLINE auto segment(isize i, isize size) const noexcept
+    -> StridedVectorViewMut
+  {
+    return {
+      from_ptr_size_stride,
+      data + stride * i,
+      size,
+      stride,
+    };
+  }
+  VEG_INLINE auto to_eigen() const
+    -> detail::EigenVecMapMut<T, Eigen::InnerStride<Eigen::Dynamic>>
+  {
+    return detail::EigenVecMapMut<T, Eigen::InnerStride<Eigen::Dynamic>>(
+      data,
+      Eigen::Index(dim),
+      Eigen::Index(1),
+      Eigen::InnerStride<Eigen::Dynamic>(Eigen::Index(stride)));
+  }
+};
+
+template<typename T, Layout L>
+struct MatrixView
+{
+  T const* data;
+  isize rows;
+  isize cols;
+  isize outer_stride;
+
+  VEG_INLINE MatrixView(FromPtrRowsColsStride /*tag*/,
+                        T const* _data,
+                        isize _rows,
+                        isize _cols,
+                        isize _outer_stride) noexcept
+    : data(_data)
+    , rows(_rows)
+    , cols(_cols)
+    , outer_stride(_outer_stride)
+  {
+  }
+
+  VEG_TEMPLATE(typename Mat,
+               requires(LDLT_CONCEPT(eigen_view<Mat, T>) &&
+                        eigen::GetLayout<unref<Mat>>::value == L),
+               VEG_INLINE MatrixView,
+               (/*tag*/, FromEigen),
+               (mat, Mat const&)) noexcept
+    : data(mat.data())
+    , rows(mat.rows())
+    , cols(mat.cols())
+    , outer_stride(mat.outerStride())
+  {
+  }
+
+  VEG_INLINE auto ptr(isize row, isize col) const noexcept -> T const*
+  {
+    return detail::ElementAccess<L>::offset(data, row, col, outer_stride);
+  }
+  VEG_INLINE auto operator()(isize row, isize col) const noexcept -> T const&
+  {
+    return *ptr(row, col);
+  }
+  VEG_INLINE auto block(isize row,
+                        isize col,
+                        isize nrows,
+                        isize ncols) const noexcept -> MatrixView
+  {
+    return {
+      from_ptr_rows_cols_stride,
+      detail::ElementAccess<L>::offset(data, row, col, outer_stride),
+      nrows,
+      ncols,
+      outer_stride,
+    };
+  }
+
+private:
+  VEG_INLINE auto col_impl(
+    proxsuite::linalg::veg::meta::constant<Layout, colmajor> /*tag*/,
+    isize c) const noexcept -> VectorView<T>
+  {
+    return {
+      from_ptr_size,
+      data + c * outer_stride,
+      rows,
+    };
+  }
+  VEG_INLINE auto col_impl(
+    proxsuite::linalg::veg::meta::constant<Layout, rowmajor> /*tag*/,
+    isize c) const noexcept -> StridedVectorView<T>
+  {
+    return {
+      from_ptr_size_stride,
+      data + c,
+      rows,
+      outer_stride,
+    };
+  }
+
+public:
+  VEG_INLINE auto col(isize c) const noexcept -> proxsuite::linalg::veg::meta::
+    if_t<(L == colmajor), VectorView<T>, StridedVectorView<T>>
+  {
+    return col_impl(proxsuite::linalg::veg::meta::constant<Layout, L>{}, c);
+  }
+  VEG_INLINE auto row(isize r) const noexcept -> proxsuite::linalg::veg::meta::
+    if_t<(L == rowmajor), VectorView<T>, StridedVectorView<T>>
+  {
+    return trans().col(r);
+  }
+  VEG_INLINE auto trans() const noexcept
+    -> MatrixView<T, proxqp::flip_layout(L)>
+  {
+    return {
+      from_ptr_rows_cols_stride, data, cols, rows, outer_stride,
+    };
+  }
+  VEG_INLINE auto to_eigen() const noexcept -> detail::EigenMatMap<T, L>
+  {
+    return detail::EigenMatMap<T, L>(
+      data,
+      Eigen::Index(rows),
+      Eigen::Index(cols),
+      Eigen::OuterStride<Eigen::Dynamic>(Eigen::Index(outer_stride)));
+  }
+};
+
+template<typename T, Layout L>
+struct MatrixViewMut
+{
+  T* data;
+  isize rows;
+  isize cols;
+  isize outer_stride;
+
+  VEG_INLINE MatrixViewMut(FromPtrRowsColsStride /*tag*/,
+                           T* _data,
+                           isize _rows,
+                           isize _cols,
+                           isize _outer_stride) noexcept
+    : data(_data)
+    , rows(_rows)
+    , cols(_cols)
+    , outer_stride(_outer_stride)
+  {
+  }
+
+  VEG_TEMPLATE(typename Mat,
+               requires(LDLT_CONCEPT(eigen_view<Mat, T>) &&
+                        eigen::GetLayout<unref<Mat>>::value == L),
+               VEG_INLINE MatrixViewMut,
+               (/*tag*/, FromEigen),
+               (mat, Mat&&)) noexcept
+    : data(mat.data())
+    , rows(mat.rows())
+    , cols(mat.cols())
+    , outer_stride(mat.outerStride())
+  {
+  }
+
+  VEG_INLINE auto ptr(isize row, isize col) const noexcept -> T*
+  {
+    return detail::ElementAccess<L>::offset(data, row, col, outer_stride);
+  }
+  VEG_INLINE auto operator()(isize row, isize col) const noexcept -> T&
+  {
+    return *ptr(row, col);
+  }
+  VEG_INLINE auto block(isize row,
+                        isize col,
+                        isize nrows,
+                        isize ncols) const noexcept -> MatrixViewMut
+  {
+    return {
+      from_ptr_rows_cols_stride,
+      detail::ElementAccess<L>::offset(data, row, col, outer_stride),
+      nrows,
+      ncols,
+      outer_stride,
+    };
+  }
+
+private:
+  VEG_INLINE auto col_impl(
+    proxsuite::linalg::veg::meta::constant<Layout, colmajor> /*tag*/,
+    isize c) const noexcept -> VectorViewMut<T>
+  {
+    return {
+      from_ptr_size,
+      data + c * outer_stride,
+      rows,
+    };
+  }
+  VEG_INLINE auto col_impl(
+    proxsuite::linalg::veg::meta::constant<Layout, rowmajor> /*tag*/,
+    isize c) const noexcept -> StridedVectorViewMut<T>
+  {
+    return {
+      from_ptr_size_stride,
+      data + c,
+      rows,
+      outer_stride,
+    };
+  }
+
+public:
+  VEG_INLINE auto col(isize c) const noexcept -> proxsuite::linalg::veg::meta::
+    if_t<(L == colmajor), VectorViewMut<T>, StridedVectorViewMut<T>>
+  {
+    return col_impl(proxsuite::linalg::veg::meta::constant<Layout, L>{}, c);
+  }
+  VEG_INLINE auto row(isize r) const noexcept -> proxsuite::linalg::veg::meta::
+    if_t<(L == rowmajor), VectorViewMut<T>, StridedVectorViewMut<T>>
+  {
+    return trans().col(r);
+  }
+  VEG_INLINE auto trans() const noexcept
+    -> MatrixViewMut<T, proxqp::flip_layout(L)>
+  {
+    return {
+      from_ptr_rows_cols_stride, data, cols, rows, outer_stride,
+    };
+  }
+  VEG_INLINE auto to_eigen() const noexcept -> detail::EigenMatMapMut<T, L>
+  {
+    return detail::EigenMatMapMut<T, L>(
+      data,
+      Eigen::Index(rows),
+      Eigen::Index(cols),
+      Eigen::OuterStride<Eigen::Dynamic>(Eigen::Index(outer_stride)));
+  }
+  VEG_INLINE auto as_const() const noexcept -> MatrixView<T, L>
+  {
+    return {
+      from_ptr_rows_cols_stride, data, rows, cols, outer_stride,
+    };
+  }
+};
+
+template<typename T>
+struct LdltView
+{
+private:
+  MatrixView<T, colmajor> ld;
+
+public:
+  explicit LdltView(MatrixView<T, colmajor> ld) noexcept
+    : ld(ld)
+  {
+    VEG_DEBUG_ASSERT(ld.rows == ld.cols);
+  }
+
+  VEG_INLINE auto l() const noexcept -> MatrixView<T, colmajor> { return ld; }
+  VEG_INLINE auto d() const noexcept -> StridedVectorView<T>
+  {
+    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
+  }
+
+  VEG_INLINE auto head(isize k) const -> LdltView
+  {
+    return LdltView{ ld.block(0, 0, k, k) };
+  }
+  VEG_INLINE auto tail(isize k) const -> LdltView
+  {
+    isize n = ld.rows;
+    return LdltView{ ld.block(n - k, n - k, k, k) };
+  }
+};
+template<typename T>
+struct LdltViewMut
+{
+private:
+  MatrixViewMut<T, colmajor> ld;
+
+public:
+  explicit LdltViewMut(MatrixViewMut<T, colmajor> ld) noexcept
+    : ld(ld)
+  {
+    VEG_DEBUG_ASSERT(ld.rows == ld.cols);
+  }
+
+  VEG_INLINE auto l() const noexcept -> MatrixView<T, colmajor>
+  {
+    return ld.as_const();
+  }
+  VEG_INLINE auto l_mut() const noexcept -> MatrixViewMut<T, colmajor>
+  {
+    return ld;
+  }
+  VEG_INLINE auto d() const noexcept -> StridedVectorView<T>
+  {
+    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
+  }
+  VEG_INLINE auto d_mut() const noexcept -> StridedVectorViewMut<T>
+  {
+    return { from_ptr_size_stride, ld.data, ld.rows, ld.outer_stride + 1 };
+  }
+
+  VEG_INLINE auto as_const() const noexcept -> LdltView<T>
+  {
+    return LdltView<T>{ ld.as_const() };
+  }
+
+  VEG_INLINE auto head(isize k) const -> LdltViewMut
+  {
+    return LdltViewMut{ ld.block(0, 0, k, k) };
+  }
+  VEG_INLINE auto tail(isize k) const -> LdltViewMut
+  {
+    isize n = ld.rows;
+    return LdltViewMut{ ld.block(n - k, n - k, k, k) };
+  }
+};
+
+namespace detail {
+template<typename T>
+void
+noalias_mul_add(MatrixViewMut<T, colmajor> dst,
+                MatrixView<T, colmajor> lhs,
+                MatrixView<T, colmajor> rhs,
+                T factor)
+{
+
+  if ((dst.cols == 0) || (dst.rows == 0) || (lhs.cols == 0)) {
+    return;
+  }
+
+#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
+#define LAZY_PRODUCT(a, b) a.lazyProduct(b)
+#else
+#define LAZY_PRODUCT(a, b) a.operator*(b)
+#endif
+
+  if (dst.cols == 1 && dst.rows == 1) {
+    // dot
+    auto rhs_col = rhs.col(0);
+    auto lhs_row = lhs.row(0);
+    auto lhs_as_col = lhs.col(0);
+    lhs_as_col.dim = lhs_row.dim;
+    if (lhs_row.stride == 1) {
+      dst(0, 0) += factor * lhs_as_col.to_eigen().dot(rhs_col.to_eigen());
+    } else {
+      dst(0, 0) += factor * lhs_row.to_eigen().dot(rhs_col.to_eigen());
+    }
+  } else if (dst.cols == 1) {
+    // gemv
+    auto rhs_col = rhs.col(0);
+    auto dst_col = dst.col(0);
+    dst_col.to_eigen().noalias().operator+=(
+      factor * LAZY_PRODUCT(lhs.to_eigen(), rhs_col.to_eigen()));
+  }
+
+#if !EIGEN_VERSION_AT_LEAST(3, 3, 8)
+  else if ((dst.rows < 20) && (dst.cols < 20) && (rhs.rows < 20)) {
+    // gemm
+    // workaround for eigen 3.3.7 bug:
+    // https://gitlab.com/libeigen/eigen/-/issues/1562
+    using Stride = Eigen::OuterStride<Eigen::Dynamic>;
+    using Mat =
+      Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic, Eigen::ColMajor, 20, 20>;
+    using MapMut = Eigen::Map<Mat, Eigen::Unaligned, Stride>;
+    using Map = Eigen::Map<Mat const, Eigen::Unaligned, Stride>;
+
+    MapMut(dst.data, dst.rows, dst.cols, Stride(dst.outer_stride))
+      .noalias()
+      .
+      operator+=(
+        factor *
+        LAZY_PRODUCT(
+          Map(lhs.data, lhs.rows, lhs.cols, Stride(lhs.outer_stride)),
+          Map(rhs.data, rhs.rows, rhs.cols, Stride(rhs.outer_stride))));
+  }
+#endif
+
+  else {
+    // gemm
+    dst.to_eigen().noalias().operator+=(
+      factor * LAZY_PRODUCT(lhs.to_eigen(), rhs.to_eigen()));
+  }
+
+#undef LAZY_PRODUCT
+}
+
+template<typename T>
+void
+noalias_mul_add_vec(VectorViewMut<T> dst,
+                    MatrixView<T, colmajor> lhs,
+                    VectorView<T> rhs,
+                    T factor)
+{
+  detail::noalias_mul_add<T>(
+    {
+      from_ptr_rows_cols_stride,
+      dst.data,
+      dst.dim,
+      1,
+      0,
+    },
+    lhs,
+    {
+      from_ptr_rows_cols_stride,
+      rhs.data,
+      rhs.dim,
+      1,
+      0,
+    },
+    VEG_FWD(factor));
+}
+
+template<typename T>
+auto
+dot(StridedVectorView<T> lhs, VectorView<T> rhs) -> T
+{
+  auto out = T(0);
+  detail::noalias_mul_add<T>(
+    {
+      from_ptr_rows_cols_stride,
+      std::addressof(out),
+      1,
+      1,
+      0,
+    },
+    {
+      from_ptr_rows_cols_stride,
+      lhs.data,
+      1,
+      lhs.dim,
+      lhs.stride,
+    },
+    {
+      from_ptr_rows_cols_stride,
+      rhs.data,
+      rhs.dim,
+      1,
+      0,
+    },
+    1);
+  return out;
+}
+template<typename T>
+void
+assign_cwise_prod(VectorViewMut<T> out,
+                  StridedVectorView<T> lhs,
+                  StridedVectorView<T> rhs)
+{
+  out.to_eigen() = lhs.to_eigen().cwiseProduct(rhs.to_eigen());
+}
+template<typename T>
+void
+assign_scalar_prod(VectorViewMut<T> out, T factor, VectorView<T> in)
+{
+  out.to_eigen() = in.to_eigen().operator*(factor);
+}
+
+template<typename T>
+void
+trans_tr_unit_up_solve_in_place_on_right(MatrixView<T, colmajor> tr,
+                                         MatrixViewMut<T, colmajor> rhs)
+{
+  if (rhs.cols == 1) {
+    tr.to_eigen()
+      .transpose()
+      .template triangularView<Eigen::UnitUpper>()
+      .template solveInPlace<Eigen::OnTheRight>(rhs.col(0).to_eigen());
+  } else {
+    tr.to_eigen()
+      .transpose()
+      .template triangularView<Eigen::UnitUpper>()
+      .template solveInPlace<Eigen::OnTheRight>(rhs.to_eigen());
+  }
+}
+
+template<typename T>
+void
+apply_diag_inv_on_right(MatrixViewMut<T, colmajor> out,
+                        StridedVectorView<T> d,
+                        MatrixView<T, colmajor> in)
+{
+  if (out.cols == 1) {
+    out.col(0).to_eigen() =
+      in.col(0).to_eigen().operator*(d.to_eigen().asDiagonal().inverse());
+  } else {
+    out.to_eigen() =
+      in.to_eigen().operator*(d.to_eigen().asDiagonal().inverse());
+  }
+}
+template<typename T>
+void
+apply_diag_on_right(MatrixViewMut<T, colmajor> out,
+                    StridedVectorView<T> d,
+                    MatrixView<T, colmajor> in)
+{
+  if (out.cols == 1) {
+    out.col(0).to_eigen() =
+      in.col(0).to_eigen().operator*(d.to_eigen().asDiagonal());
+  } else {
+    out.to_eigen() = in.to_eigen().operator*(d.to_eigen().asDiagonal());
+  }
+}
+
+template<typename T>
+void
+noalias_mul_sub_tr_lo(MatrixViewMut<T, colmajor> out,
+                      MatrixView<T, colmajor> lhs,
+                      MatrixView<T, rowmajor> rhs)
+{
+  if (lhs.cols == 1) {
+    out.to_eigen().template triangularView<Eigen::Lower>().operator-=(
+      lhs.col(0).to_eigen().operator*(
+        Eigen::Map<Eigen::Matrix<T, 1, Eigen::Dynamic> const>(
+          rhs.data, 1, rhs.cols)));
+  } else {
+    out.to_eigen().template triangularView<Eigen::Lower>().operator-=(
+      lhs.to_eigen().operator*(rhs.to_eigen()));
+  }
+}
+
+} // namespace detail
+} // namespace proxqp
+} // namespace proxsuite
+
+namespace proxsuite {
+namespace proxqp {
+
+namespace dense {
+
+struct EigenAllowAlloc
+{
+  bool alloc_was_allowed;
+  EigenAllowAlloc(EigenAllowAlloc&&) = delete;
+  EigenAllowAlloc(EigenAllowAlloc const&) = delete;
+  auto operator=(EigenAllowAlloc&&) -> EigenAllowAlloc& = delete;
+  auto operator=(EigenAllowAlloc const&) -> EigenAllowAlloc& = delete;
+
+#if defined(EIGEN_RUNTIME_NO_MALLOC)
+  EigenAllowAlloc() noexcept
+    : alloc_was_allowed(Eigen::internal::is_malloc_allowed())
+  {
+    Eigen::internal::set_is_malloc_allowed(true);
+  }
+  ~EigenAllowAlloc() noexcept
+  {
+    Eigen::internal::set_is_malloc_allowed(alloc_was_allowed);
+  }
+#else
+  EigenAllowAlloc() = default;
+#endif
+};
+
+template<typename T>
+struct QpView
+{
+
+  static constexpr Layout layout = rowmajor;
+
+  MatrixView<T, layout> H;
+  VectorView<T> g;
+
+  MatrixView<T, layout> A;
+  VectorView<T> b;
+  MatrixView<T, layout> C;
+  VectorView<T> d;
+};
+
+template<typename Scalar>
+struct QpViewBox
+{
+  static constexpr Layout layout = rowmajor;
+
+  MatrixView<Scalar, layout> H;
+  VectorView<Scalar> g;
+
+  MatrixView<Scalar, layout> A;
+  VectorView<Scalar> b;
+  MatrixView<Scalar, layout> C;
+  VectorView<Scalar> u;
+  VectorView<Scalar> l;
+};
+
+template<typename T>
+struct QpViewMut
+{
+  static constexpr Layout layout = rowmajor;
+
+  MatrixViewMut<T, layout> H;
+  VectorViewMut<T> g;
+
+  MatrixViewMut<T, layout> A;
+  VectorViewMut<T> b;
+  MatrixViewMut<T, layout> C;
+  VectorViewMut<T> d;
+
+  VEG_INLINE constexpr auto as_const() const noexcept -> QpView<T>
+  {
+    return {
+      H.as_const(), g.as_const(), A.as_const(),
+      b.as_const(), C.as_const(), d.as_const(),
+    };
+  }
+};
+
+template<typename Scalar>
+struct QpViewBoxMut
+{
+  static constexpr Layout layout = rowmajor;
+
+  MatrixViewMut<Scalar, layout> H;
+  VectorViewMut<Scalar> g;
+
+  MatrixViewMut<Scalar, layout> A;
+  VectorViewMut<Scalar> b;
+  MatrixViewMut<Scalar, layout> C;
+  VectorViewMut<Scalar> u;
+  VectorViewMut<Scalar> l;
+
+  VEG_INLINE constexpr auto as_const() const noexcept -> QpViewBox<Scalar>
+  {
+    return {
+      H.as_const(), g.as_const(), A.as_const(), b.as_const(),
+      C.as_const(), u.as_const(), l.as_const(),
+    };
+  }
+};
+
+namespace nb {
+struct pow
+{
+  template<typename T>
+  auto operator()(T x, T y) const -> T
+  {
+    using std::pow;
+    return pow(x, y);
+  }
+};
+struct infty_norm
+{
+  template<typename D>
+  auto operator()(Eigen::MatrixBase<D> const& mat) const -> typename D::Scalar
+  {
+    if (mat.rows() == 0 || mat.cols() == 0) {
+      return typename D::Scalar(0);
+    } else {
+      return mat.template lpNorm<Eigen::Infinity>();
+    }
+  }
+};
+struct sqrt
+{
+  template<typename T>
+  auto operator()(T x) const -> T
+  {
+    using std::sqrt;
+    return sqrt(x);
+  }
+};
+struct fabs
+{
+  template<typename T>
+  auto operator()(T x) const -> T
+  {
+    using std::fabs;
+    return fabs(x);
+  }
+};
+} // namespace nb
+VEG_NIEBLOID(fabs);
+VEG_NIEBLOID(sqrt);
+VEG_NIEBLOID(pow);
+VEG_NIEBLOID(infty_norm);
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_VIEWS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/workspace.hpp

 * *Ordering differences only*

```diff
@@ -1,264 +1,264 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file workspace.hpp
- */
-#ifndef PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP
-#define PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP
-
-#include <Eigen/Core>
-#include <proxsuite/linalg/dense/ldlt.hpp>
-#include <proxsuite/proxqp/timings.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-// #include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-///
-/// @brief This class defines the workspace of the dense solver.
-///
-/*!
- * Workspace class of the dense solver.
- */
-template<typename T>
-struct Workspace
-{
-
-  ///// Cholesky Factorization
-  proxsuite::linalg::dense::Ldlt<T> ldl{};
-  proxsuite::linalg::veg::Vec<unsigned char> ldl_stack;
-  Timer<T> timer;
-
-  ///// QP STORAGE
-  Mat<T> H_scaled;
-  Vec<T> g_scaled;
-  Mat<T> A_scaled;
-  Mat<T> C_scaled;
-  Vec<T> b_scaled;
-  Vec<T> u_scaled;
-  Vec<T> l_scaled;
-
-  ///// Initial variable loading
-
-  Vec<T> x_prev;
-  Vec<T> y_prev;
-  Vec<T> z_prev;
-
-  ///// KKT system storage
-  Mat<T> kkt;
-
-  //// Active set & permutation vector
-  VecISize current_bijection_map;
-  VecISize new_bijection_map;
-
-  VecBool active_set_up;
-  VecBool active_set_low;
-  VecBool active_inequalities;
-
-  //// First order residuals for line search
-
-  Vec<T> Hdx;
-  Vec<T> Cdx;
-  Vec<T> Adx;
-
-  Vec<T> active_part_z;
-  proxsuite::linalg::veg::Vec<T> alphas;
-
-  ///// Newton variables
-  Vec<T> dw_aug;
-  Vec<T> rhs;
-  Vec<T> err;
-
-  //// Relative residuals constants
-
-  T dual_feasibility_rhs_2;
-  T correction_guess_rhs_g;
-  T correction_guess_rhs_b;
-  T alpha;
-
-  Vec<T> dual_residual_scaled;
-  Vec<T> primal_residual_eq_scaled;
-  Vec<T> primal_residual_in_scaled_up;
-  Vec<T> primal_residual_in_scaled_low;
-
-  Vec<T> primal_residual_in_scaled_up_plus_alphaCdx;
-  Vec<T> primal_residual_in_scaled_low_plus_alphaCdx;
-  Vec<T> CTz;
-
-  bool constraints_changed;
-  bool dirty;
-  bool refactorize;
-  bool proximal_parameter_update;
-  bool is_initialized;
-
-  sparse::isize n_c; // final number of active inequalities
-  /*!
-   * Default constructor.
-   * @param dim primal variable dimension.
-   * @param n_eq number of equality constraints.
-   * @param n_in number of inequality constraints.
-   */
-  Workspace(isize dim = 0, isize n_eq = 0, isize n_in = 0)
-    : //
-      // ruiz(preconditioner::RuizEquilibration<T>{dim, n_eq + n_in}),
-    ldl{}
-    , // old version with alloc
-    H_scaled(dim, dim)
-    , g_scaled(dim)
-    , A_scaled(n_eq, dim)
-    , C_scaled(n_in, dim)
-    , b_scaled(n_eq)
-    , u_scaled(n_in)
-    , l_scaled(n_in)
-    , x_prev(dim)
-    , y_prev(n_eq)
-    , z_prev(n_in)
-    , kkt(dim + n_eq, dim + n_eq)
-    , current_bijection_map(n_in)
-    , new_bijection_map(n_in)
-    , active_set_up(n_in)
-    , active_set_low(n_in)
-    , active_inequalities(n_in)
-    , Hdx(dim)
-    , Cdx(n_in)
-    , Adx(n_eq)
-    , active_part_z(n_in)
-    , dw_aug(dim + n_eq + n_in)
-    , rhs(dim + n_eq + n_in)
-    , err(dim + n_eq + n_in)
-    ,
-
-    dual_residual_scaled(dim)
-    , primal_residual_eq_scaled(n_eq)
-    , primal_residual_in_scaled_up(n_in)
-    , primal_residual_in_scaled_low(n_in)
-    ,
-
-    primal_residual_in_scaled_up_plus_alphaCdx(n_in)
-    , primal_residual_in_scaled_low_plus_alphaCdx(n_in)
-    , CTz(dim)
-    , constraints_changed(false)
-    , dirty(false)
-    , refactorize(false)
-    , proximal_parameter_update(false)
-    , is_initialized(false)
-
-  {
-    ldl.reserve_uninit(dim + n_eq + n_in);
-    ldl_stack.resize_for_overwrite(
-      proxsuite::linalg::veg::dynstack::StackReq(
-
-        proxsuite::linalg::dense::Ldlt<T>::factorize_req(dim + n_eq + n_in) |
-
-        (proxsuite::linalg::dense::temp_vec_req(
-           proxsuite::linalg::veg::Tag<T>{}, n_eq + n_in) &
-         proxsuite::linalg::veg::dynstack::StackReq{
-           isize{ sizeof(isize) } * (n_eq + n_in), alignof(isize) } &
-         proxsuite::linalg::dense::Ldlt<T>::diagonal_update_req(
-           dim + n_eq + n_in, n_eq + n_in)) |
-
-        (proxsuite::linalg::dense::temp_mat_req(
-           proxsuite::linalg::veg::Tag<T>{}, dim + n_eq + n_in, n_in) &
-         proxsuite::linalg::dense::Ldlt<T>::insert_block_at_req(
-           dim + n_eq + n_in, n_in)) |
-
-        proxsuite::linalg::dense::Ldlt<T>::solve_in_place_req(dim + n_eq +
-                                                              n_in))
-
-        .alloc_req());
-
-    alphas.reserve(2 * n_in);
-    H_scaled.setZero();
-    g_scaled.setZero();
-    A_scaled.setZero();
-    C_scaled.setZero();
-    b_scaled.setZero();
-    u_scaled.setZero();
-    l_scaled.setZero();
-    x_prev.setZero();
-    y_prev.setZero();
-    z_prev.setZero();
-    kkt.setZero();
-    for (isize i = 0; i < n_in; i++) {
-      current_bijection_map(i) = i;
-      new_bijection_map(i) = i;
-    }
-    Hdx.setZero();
-    Cdx.setZero();
-    Adx.setZero();
-    active_part_z.setZero();
-    dw_aug.setZero();
-    rhs.setZero();
-    err.setZero();
-
-    dual_feasibility_rhs_2 = 0;
-    correction_guess_rhs_g = 0;
-    correction_guess_rhs_b = 0;
-    alpha = 1.;
-
-    dual_residual_scaled.setZero();
-    primal_residual_eq_scaled.setZero();
-    primal_residual_in_scaled_up.setZero();
-    primal_residual_in_scaled_low.setZero();
-
-    primal_residual_in_scaled_up_plus_alphaCdx.setZero();
-    primal_residual_in_scaled_low_plus_alphaCdx.setZero();
-    CTz.setZero();
-    n_c = 0;
-  }
-  /*!
-   * Clean-ups solver's workspace.
-   */
-  void cleanup()
-  {
-    isize n_in = C_scaled.rows();
-    H_scaled.setZero();
-    g_scaled.setZero();
-    A_scaled.setZero();
-    C_scaled.setZero();
-    b_scaled.setZero();
-    u_scaled.setZero();
-    l_scaled.setZero();
-    Hdx.setZero();
-    Cdx.setZero();
-    Adx.setZero();
-    active_part_z.setZero();
-    dw_aug.setZero();
-    rhs.setZero();
-    err.setZero();
-
-    alpha = 1.;
-
-    dual_residual_scaled.setZero();
-    primal_residual_eq_scaled.setZero();
-    primal_residual_in_scaled_up.setZero();
-    primal_residual_in_scaled_low.setZero();
-
-    primal_residual_in_scaled_up_plus_alphaCdx.setZero();
-    primal_residual_in_scaled_low_plus_alphaCdx.setZero();
-    CTz.setZero();
-
-    x_prev.setZero();
-    y_prev.setZero();
-    z_prev.setZero();
-
-    for (isize i = 0; i < n_in; i++) {
-      current_bijection_map(i) = i;
-      new_bijection_map(i) = i;
-      active_inequalities(i) = false;
-    }
-    constraints_changed = false;
-    dirty = false;
-    refactorize = false;
-    proximal_parameter_update = false;
-    is_initialized = false;
-    n_c = 0;
-  }
-};
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file workspace.hpp
+ */
+#ifndef PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP
+#define PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP
+
+#include <Eigen/Core>
+#include <proxsuite/linalg/dense/ldlt.hpp>
+#include <proxsuite/proxqp/timings.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+// #include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+///
+/// @brief This class defines the workspace of the dense solver.
+///
+/*!
+ * Workspace class of the dense solver.
+ */
+template<typename T>
+struct Workspace
+{
+
+  ///// Cholesky Factorization
+  proxsuite::linalg::dense::Ldlt<T> ldl{};
+  proxsuite::linalg::veg::Vec<unsigned char> ldl_stack;
+  Timer<T> timer;
+
+  ///// QP STORAGE
+  Mat<T> H_scaled;
+  Vec<T> g_scaled;
+  Mat<T> A_scaled;
+  Mat<T> C_scaled;
+  Vec<T> b_scaled;
+  Vec<T> u_scaled;
+  Vec<T> l_scaled;
+
+  ///// Initial variable loading
+
+  Vec<T> x_prev;
+  Vec<T> y_prev;
+  Vec<T> z_prev;
+
+  ///// KKT system storage
+  Mat<T> kkt;
+
+  //// Active set & permutation vector
+  VecISize current_bijection_map;
+  VecISize new_bijection_map;
+
+  VecBool active_set_up;
+  VecBool active_set_low;
+  VecBool active_inequalities;
+
+  //// First order residuals for line search
+
+  Vec<T> Hdx;
+  Vec<T> Cdx;
+  Vec<T> Adx;
+
+  Vec<T> active_part_z;
+  proxsuite::linalg::veg::Vec<T> alphas;
+
+  ///// Newton variables
+  Vec<T> dw_aug;
+  Vec<T> rhs;
+  Vec<T> err;
+
+  //// Relative residuals constants
+
+  T dual_feasibility_rhs_2;
+  T correction_guess_rhs_g;
+  T correction_guess_rhs_b;
+  T alpha;
+
+  Vec<T> dual_residual_scaled;
+  Vec<T> primal_residual_eq_scaled;
+  Vec<T> primal_residual_in_scaled_up;
+  Vec<T> primal_residual_in_scaled_low;
+
+  Vec<T> primal_residual_in_scaled_up_plus_alphaCdx;
+  Vec<T> primal_residual_in_scaled_low_plus_alphaCdx;
+  Vec<T> CTz;
+
+  bool constraints_changed;
+  bool dirty;
+  bool refactorize;
+  bool proximal_parameter_update;
+  bool is_initialized;
+
+  sparse::isize n_c; // final number of active inequalities
+  /*!
+   * Default constructor.
+   * @param dim primal variable dimension.
+   * @param n_eq number of equality constraints.
+   * @param n_in number of inequality constraints.
+   */
+  Workspace(isize dim = 0, isize n_eq = 0, isize n_in = 0)
+    : //
+      // ruiz(preconditioner::RuizEquilibration<T>{dim, n_eq + n_in}),
+    ldl{}
+    , // old version with alloc
+    H_scaled(dim, dim)
+    , g_scaled(dim)
+    , A_scaled(n_eq, dim)
+    , C_scaled(n_in, dim)
+    , b_scaled(n_eq)
+    , u_scaled(n_in)
+    , l_scaled(n_in)
+    , x_prev(dim)
+    , y_prev(n_eq)
+    , z_prev(n_in)
+    , kkt(dim + n_eq, dim + n_eq)
+    , current_bijection_map(n_in)
+    , new_bijection_map(n_in)
+    , active_set_up(n_in)
+    , active_set_low(n_in)
+    , active_inequalities(n_in)
+    , Hdx(dim)
+    , Cdx(n_in)
+    , Adx(n_eq)
+    , active_part_z(n_in)
+    , dw_aug(dim + n_eq + n_in)
+    , rhs(dim + n_eq + n_in)
+    , err(dim + n_eq + n_in)
+    ,
+
+    dual_residual_scaled(dim)
+    , primal_residual_eq_scaled(n_eq)
+    , primal_residual_in_scaled_up(n_in)
+    , primal_residual_in_scaled_low(n_in)
+    ,
+
+    primal_residual_in_scaled_up_plus_alphaCdx(n_in)
+    , primal_residual_in_scaled_low_plus_alphaCdx(n_in)
+    , CTz(dim)
+    , constraints_changed(false)
+    , dirty(false)
+    , refactorize(false)
+    , proximal_parameter_update(false)
+    , is_initialized(false)
+
+  {
+    ldl.reserve_uninit(dim + n_eq + n_in);
+    ldl_stack.resize_for_overwrite(
+      proxsuite::linalg::veg::dynstack::StackReq(
+
+        proxsuite::linalg::dense::Ldlt<T>::factorize_req(dim + n_eq + n_in) |
+
+        (proxsuite::linalg::dense::temp_vec_req(
+           proxsuite::linalg::veg::Tag<T>{}, n_eq + n_in) &
+         proxsuite::linalg::veg::dynstack::StackReq{
+           isize{ sizeof(isize) } * (n_eq + n_in), alignof(isize) } &
+         proxsuite::linalg::dense::Ldlt<T>::diagonal_update_req(
+           dim + n_eq + n_in, n_eq + n_in)) |
+
+        (proxsuite::linalg::dense::temp_mat_req(
+           proxsuite::linalg::veg::Tag<T>{}, dim + n_eq + n_in, n_in) &
+         proxsuite::linalg::dense::Ldlt<T>::insert_block_at_req(
+           dim + n_eq + n_in, n_in)) |
+
+        proxsuite::linalg::dense::Ldlt<T>::solve_in_place_req(dim + n_eq +
+                                                              n_in))
+
+        .alloc_req());
+
+    alphas.reserve(2 * n_in);
+    H_scaled.setZero();
+    g_scaled.setZero();
+    A_scaled.setZero();
+    C_scaled.setZero();
+    b_scaled.setZero();
+    u_scaled.setZero();
+    l_scaled.setZero();
+    x_prev.setZero();
+    y_prev.setZero();
+    z_prev.setZero();
+    kkt.setZero();
+    for (isize i = 0; i < n_in; i++) {
+      current_bijection_map(i) = i;
+      new_bijection_map(i) = i;
+    }
+    Hdx.setZero();
+    Cdx.setZero();
+    Adx.setZero();
+    active_part_z.setZero();
+    dw_aug.setZero();
+    rhs.setZero();
+    err.setZero();
+
+    dual_feasibility_rhs_2 = 0;
+    correction_guess_rhs_g = 0;
+    correction_guess_rhs_b = 0;
+    alpha = 1.;
+
+    dual_residual_scaled.setZero();
+    primal_residual_eq_scaled.setZero();
+    primal_residual_in_scaled_up.setZero();
+    primal_residual_in_scaled_low.setZero();
+
+    primal_residual_in_scaled_up_plus_alphaCdx.setZero();
+    primal_residual_in_scaled_low_plus_alphaCdx.setZero();
+    CTz.setZero();
+    n_c = 0;
+  }
+  /*!
+   * Clean-ups solver's workspace.
+   */
+  void cleanup()
+  {
+    isize n_in = C_scaled.rows();
+    H_scaled.setZero();
+    g_scaled.setZero();
+    A_scaled.setZero();
+    C_scaled.setZero();
+    b_scaled.setZero();
+    u_scaled.setZero();
+    l_scaled.setZero();
+    Hdx.setZero();
+    Cdx.setZero();
+    Adx.setZero();
+    active_part_z.setZero();
+    dw_aug.setZero();
+    rhs.setZero();
+    err.setZero();
+
+    alpha = 1.;
+
+    dual_residual_scaled.setZero();
+    primal_residual_eq_scaled.setZero();
+    primal_residual_in_scaled_up.setZero();
+    primal_residual_in_scaled_low.setZero();
+
+    primal_residual_in_scaled_up_plus_alphaCdx.setZero();
+    primal_residual_in_scaled_low_plus_alphaCdx.setZero();
+    CTz.setZero();
+
+    x_prev.setZero();
+    y_prev.setZero();
+    z_prev.setZero();
+
+    for (isize i = 0; i < n_in; i++) {
+      current_bijection_map(i) = i;
+      new_bijection_map(i) = i;
+      active_inequalities(i) = false;
+    }
+    constraints_changed = false;
+    dirty = false;
+    refactorize = false;
+    proximal_parameter_update = false;
+    is_initialized = false;
+    n_c = 0;
+  }
+};
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_WORKSPACE_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/wrapper.hpp

 * *Ordering differences only*

```diff
@@ -1,491 +1,491 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file wrapper.hpp
- */
-
-#ifndef PROXSUITE_PROXQP_DENSE_WRAPPER_HPP
-#define PROXSUITE_PROXQP_DENSE_WRAPPER_HPP
-#include <proxsuite/proxqp/dense/solver.hpp>
-#include <proxsuite/proxqp/dense/helpers.hpp>
-#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
-#include <chrono>
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-///
-/// @brief This class defines the API of PROXQP solver with dense backend.
-///
-/*!
- * Wrapper class for using proxsuite API with dense backend
- * for solving linearly constrained convex QP problem using ProxQp algorithm.
- *
- * Example usage:
- * ```cpp
-#include <Eigen/Core>
-#include <Eigen/Cholesky>
-#include <proxsuite/proxqp/dense/dense.hpp>
-#include <proxsuite/linalg/veg/util/dbg.hpp>
-#include <util.hpp>
-
-using T = double;
-auto main() -> int {
-
-        // Generate a random QP problem with primal variable dimension of size
-dim; n_eq equality constraints and n_in inequality constraints
-        ::proxsuite::proxqp::test::rand::set_seed(1);
-        proxqp::isize dim = 10;
-        proxqp::isize n_eq(dim / 4);
-        proxqp::isize n_in(dim / 4);
-        T strong_convexity_factor(1.e-2);
-        T sparsity_factor = 0.15; // controls the sparsity of each matrix of the
-problem generated T eps_abs = T(1e-9); Qp<T> qp{
-                        random_with_dim_and_neq_and_n_in,
-                        dim,
-                        n_eq,
-                        n_in,
-                        sparsity_factor,
-                        strong_convexity_factor};
-
-        // Solve the problem
-        proxqp::dense::QP<T> Qp{dim, n_eq, n_in}; // creating QP object
-        Qp.settings.eps_abs = eps_abs; // choose accuracy needed
-        Qp.init(qp.H, qp.g, qp.A, qp.b, qp.C, qp.u, qp.l); // setup the QP
-object Qp.solve(); // solve the problem
-
-        // Verify solution accuracy
-        T pri_res = std::max(
-                        (qp.A * Qp.results.x - qp.b).lpNorm<Eigen::Infinity>(),
-                        (helpers::positive_part(qp.C * Qp.results.x -
-qp.u) + helpers::negative_part(qp.C * Qp.results.x - qp.l))
-                                        .lpNorm<Eigen::Infinity>());
-        T dua_res = (qp.H * Qp.results.x + qp.g + qp.A.transpose() *
-Qp.results.y + qp.C.transpose() * Qp.results.z) .lpNorm<Eigen::Infinity>();
-        VEG_ASSERT(pri_res <= eps_abs);
-        VEG_ASSERT(dua_res <= eps_abs);
-
-        // Some solver statistics
-        std::cout << "------solving qp with dim: " << dim
-                                                << " neq: " << n_eq << " nin: "
-<< n_in << std::endl; std::cout << "primal residual: " << pri_res << std::endl;
-        std::cout << "dual residual: " << dua_res << std::endl;
-        std::cout << "total number of iteration: " << Qp.results.info.iter
-                                                << std::endl;
-}
- * ```
- */
-///// QP object
-template<typename T>
-struct QP
-{
-  Results<T> results;
-  Settings<T> settings;
-  Model<T> model;
-  Workspace<T> work;
-  preconditioner::RuizEquilibration<T> ruiz;
-  /*!
-   * Default constructor using QP model dimensions.
-   * @param _dim primal variable dimension.
-   * @param _n_eq number of equality constraints.
-   * @param _n_in number of inequality constraints.
-   */
-  QP(isize _dim, isize _n_eq, isize _n_in)
-    : results(_dim, _n_eq, _n_in)
-    , settings()
-    , model(_dim, _n_eq, _n_in)
-    , work(_dim, _n_eq, _n_in)
-    , ruiz(preconditioner::RuizEquilibration<T>{ _dim, _n_eq + _n_in })
-  {
-    work.timer.stop();
-  }
-  /*!
-   * Setups the QP model (with dense matrix format) and equilibrates it if
-   * specified by the user.
-   * @param H quadratic cost input defining the QP model.
-   * @param g linear cost input defining the QP model.
-   * @param A equality constraint matrix input defining the QP model.
-   * @param b equality constraint vector input defining the QP model.
-   * @param C inequality constraint matrix input defining the QP model.
-   * @param l lower inequality constraint vector input defining the QP model.
-   * @param u upper inequality constraint vector input defining the QP model.
-   * @param compute_preconditioner boolean parameter for executing or not the
-   * preconditioner.
-   * @param rho proximal step size wrt primal variable.
-   * @param mu_eq proximal step size wrt equality constrained multiplier.
-   * @param mu_in proximal step size wrt inequality constrained multiplier.
-   */
-  void init(optional<MatRef<T>> H,
-            optional<VecRef<T>> g,
-            optional<MatRef<T>> A,
-            optional<VecRef<T>> b,
-            optional<MatRef<T>> C,
-            optional<VecRef<T>> l,
-            optional<VecRef<T>> u,
-            bool compute_preconditioner = true,
-            optional<T> rho = nullopt,
-            optional<T> mu_eq = nullopt,
-            optional<T> mu_in = nullopt)
-  {
-    // dense case
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    // check the model is valid
-    if (g != nullopt && g.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        g.value().size(),
-        model.dim,
-        "the dimension wrt the primal variable x variable for initializing g "
-        "is not valid.");
-    } else {
-      g.reset();
-    }
-    if (b != nullopt && b.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        b.value().size(),
-        model.n_eq,
-        "the dimension wrt equality constrained variables for initializing b "
-        "is not valid.");
-    } else {
-      b.reset();
-    }
-    if (u != nullopt && u.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        u.value().size(),
-        model.n_in,
-        "the dimension wrt inequality constrained variables for initializing u "
-        "is not valid.");
-    } else {
-      u.reset();
-    }
-    if (l != nullopt && l.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        l.value().size(),
-        model.n_in,
-        "the dimension wrt inequality constrained variables for initializing l "
-        "is not valid.");
-    } else {
-      l.reset();
-    }
-    if (H != nullopt && H.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().rows(),
-        model.dim,
-        "the row dimension for initializing H is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().cols(),
-        model.dim,
-        "the column dimension for initializing H is not valid.");
-    } else {
-      H.reset();
-    }
-    if (A != nullopt && A.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().rows(),
-        model.n_eq,
-        "the row dimension for initializing A is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().cols(),
-        model.dim,
-        "the column dimension for initializing A is not valid.");
-    } else {
-      A.reset();
-    }
-    if (C != nullopt && C.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().rows(),
-        model.n_in,
-        "the row dimension for initializing C is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().cols(),
-        model.dim,
-        "the column dimension for initializing C is not valid.");
-    } else {
-      C.reset();
-    }
-    if (settings.initial_guess ==
-        InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT) {
-      work.refactorize =
-        true; // necessary for the first solve (then refactorize only if there
-              // is an update of the matrices)
-    } else {
-      work.refactorize = false;
-    }
-    work.proximal_parameter_update = false;
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    PreconditionerStatus preconditioner_status;
-    if (compute_preconditioner) {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
-    } else {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::IDENTITY;
-    }
-    proxsuite::proxqp::dense::update_proximal_parameters(
-      settings, results, work, rho, mu_eq, mu_in);
-    proxsuite::proxqp::dense::setup(H,
-                                    g,
-                                    A,
-                                    b,
-                                    C,
-                                    l,
-                                    u,
-                                    settings,
-                                    model,
-                                    work,
-                                    results,
-                                    ruiz,
-                                    preconditioner_status);
-    work.is_initialized = true;
-    if (settings.compute_timings) {
-      results.info.setup_time = work.timer.elapsed().user; // in microseconds
-    }
-  };
-  /*!
-   * Updates the QP model (with dense matrix format) and re-equilibrates it if
-   * specified by the user.
-   * @param H quadratic cost input defining the QP model.
-   * @param g linear cost input defining the QP model.
-   * @param A equality constraint matrix input defining the QP model.
-   * @param b equality constraint vector input defining the QP model.
-   * @param C inequality constraint matrix input defining the QP model.
-   * @param l lower inequality constraint vector input defining the QP model.
-   * @param u upper inequality constraint vector input defining the QP model.
-   * @param update_preconditioner bool parameter for updating or not the
-   * preconditioner and the associated scaled model.
-   * @param rho proximal step size wrt primal variable.
-   * @param mu_eq proximal step size wrt equality constrained multiplier.
-   * @param mu_in proximal step size wrt inequality constrained multiplier.
-   * @note The init method should be called before update. If it has not been
-   * done before, init is called depending on the is_initialized flag.
-   */
-  void update(optional<MatRef<T>> H,
-              optional<VecRef<T>> g,
-              optional<MatRef<T>> A,
-              optional<VecRef<T>> b,
-              optional<MatRef<T>> C,
-              optional<VecRef<T>> l,
-              optional<VecRef<T>> u,
-              bool update_preconditioner = true,
-              optional<T> rho = nullopt,
-              optional<T> mu_eq = nullopt,
-              optional<T> mu_in = nullopt)
-  {
-    if (!work.is_initialized) {
-      init(H, g, A, b, C, l, u, update_preconditioner, rho, mu_eq, mu_in);
-      return;
-    }
-    // dense case
-    work.refactorize = false;
-    work.proximal_parameter_update = false;
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    PreconditionerStatus preconditioner_status;
-    if (update_preconditioner) {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
-    } else {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::KEEP;
-    }
-    const bool matrix_update =
-      !(H == nullopt && g == nullopt && A == nullopt && b == nullopt &&
-        C == nullopt && u == nullopt && l == nullopt);
-    if (matrix_update) {
-      proxsuite::proxqp::dense::update(H, g, A, b, C, l, u, model, work);
-    }
-    proxsuite::proxqp::dense::update_proximal_parameters(
-      settings, results, work, rho, mu_eq, mu_in);
-
-    typedef optional<MatRef<T>> optional_MatRef;
-    typedef optional<VecRef<T>> optional_VecRef;
-    proxsuite::proxqp::dense::setup(/* avoid double assignation */
-                                    optional_MatRef(nullopt),
-                                    optional_VecRef(nullopt),
-                                    optional_MatRef(nullopt),
-                                    optional_VecRef(nullopt),
-                                    optional_MatRef(nullopt),
-                                    optional_VecRef(nullopt),
-                                    optional_VecRef(nullopt),
-                                    settings,
-                                    model,
-                                    work,
-                                    results,
-                                    ruiz,
-                                    preconditioner_status);
-
-    if (settings.compute_timings) {
-      results.info.setup_time = work.timer.elapsed().user; // in microseconds
-    }
-  };
-
-  /*!
-   * Solves the QP problem using PRXOQP algorithm.
-   */
-  void solve()
-  {
-    qp_solve( //
-      settings,
-      model,
-      results,
-      work,
-      ruiz);
-  };
-  /*!
-   * Solves the QP problem using PROXQP algorithm using a warm start.
-   * @param x primal warm start.
-   * @param y dual equality warm start.
-   * @param z dual inequality warm start.
-   */
-  void solve(optional<VecRef<T>> x,
-             optional<VecRef<T>> y,
-             optional<VecRef<T>> z)
-  {
-    proxsuite::proxqp::dense::warm_start(x, y, z, results, settings, model);
-    qp_solve( //
-      settings,
-      model,
-      results,
-      work,
-      ruiz);
-  };
-  /*!
-   * Clean-ups solver's results and workspace.
-   */
-  void cleanup()
-  {
-    results.cleanup(settings);
-    work.cleanup();
-  }
-};
-/*!
- * Solves the QP problem using PROXQP algorithm without the need to define a QP
- * object, with matrices defined by Dense Eigen matrices. It is possible to set
- * up some of the solver parameters (warm start, initial guess option, proximal
- * step sizes, absolute and relative accuracies, maximum number of iterations,
- * preconditioner execution).
- * @param H quadratic cost input defining the QP model.
- * @param g linear cost input defining the QP model.
- * @param A equality constraint matrix input defining the QP model.
- * @param b equality constraint vector input defining the QP model.
- * @param C inequality constraint matrix input defining the QP model.
- * @param l lower inequality constraint vector input defining the QP model.
- * @param u upper inequality constraint vector input defining the QP model.
- * @param x primal warm start.
- * @param y dual equality constraint warm start.
- * @param z dual inequality constraint warm start.
- * @param verbose if set to true, the solver prints more information about each
- * iteration.
- * @param compute_preconditioner bool parameter for executing or not the
- * preconditioner.
- * @param compute_timings boolean parameter for computing the solver timings.
- * @param rho proximal step size wrt primal variable.
- * @param mu_eq proximal step size wrt equality constrained multiplier.
- * @param mu_in proximal step size wrt inequality constrained multiplier.
- * @param eps_abs absolute accuracy threshold.
- * @param eps_rel relative accuracy threshold.
- * @param max_iter maximum number of iteration.
- * @param initial_guess initial guess option for warm starting or not the
- * initial iterate values.
- * @param check_duality_gap If set to true, include the duality gap in absolute
- * and relative stopping criteria.
- * @param eps_duality_gap_abs absolute accuracy threshold for the duality-gap
- * criterion.
- * @param eps_duality_gap_rel relative accuracy threshold for the duality-gap
- * criterion.
- */
-template<typename T>
-proxqp::Results<T>
-solve(
-  optional<MatRef<T>> H,
-  optional<VecRef<T>> g,
-  optional<MatRef<T>> A,
-  optional<VecRef<T>> b,
-  optional<MatRef<T>> C,
-  optional<VecRef<T>> l,
-  optional<VecRef<T>> u,
-  optional<VecRef<T>> x = nullopt,
-  optional<VecRef<T>> y = nullopt,
-  optional<VecRef<T>> z = nullopt,
-  optional<T> eps_abs = nullopt,
-  optional<T> eps_rel = nullopt,
-  optional<T> rho = nullopt,
-  optional<T> mu_eq = nullopt,
-  optional<T> mu_in = nullopt,
-  optional<bool> verbose = nullopt,
-  bool compute_preconditioner = true,
-  bool compute_timings = false,
-  optional<isize> max_iter = nullopt,
-  proxsuite::proxqp::InitialGuessStatus initial_guess =
-    proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS,
-  bool check_duality_gap = false,
-  optional<T> eps_duality_gap_abs = nullopt,
-  optional<T> eps_duality_gap_rel = nullopt)
-{
-  isize n(0);
-  isize n_eq(0);
-  isize n_in(0);
-  if (H != nullopt) {
-    n = H.value().rows();
-  }
-  if (A != nullopt) {
-    n_eq = A.value().rows();
-  }
-  if (C != nullopt) {
-    n_in = C.value().rows();
-  }
-
-  QP<T> Qp(n, n_eq, n_in);
-  Qp.settings.initial_guess = initial_guess;
-  Qp.settings.check_duality_gap = check_duality_gap;
-
-  if (eps_abs != nullopt) {
-    Qp.settings.eps_abs = eps_abs.value();
-  }
-  if (eps_rel != nullopt) {
-    Qp.settings.eps_rel = eps_rel.value();
-  }
-  if (verbose != nullopt) {
-    Qp.settings.verbose = verbose.value();
-  }
-  if (max_iter != nullopt) {
-    Qp.settings.max_iter = max_iter.value();
-  }
-  if (eps_duality_gap_abs != nullopt) {
-    Qp.settings.eps_duality_gap_abs = eps_duality_gap_abs.value();
-  }
-  if (eps_duality_gap_rel != nullopt) {
-    Qp.settings.eps_duality_gap_rel = eps_duality_gap_rel.value();
-  }
-  Qp.settings.compute_timings = compute_timings;
-  Qp.init(H, g, A, b, C, l, u, compute_preconditioner, rho, mu_eq, mu_in);
-  Qp.solve(x, y, z);
-
-  return Qp.results;
-}
-
-template<typename T>
-bool
-operator==(const QP<T>& qp1, const QP<T>& qp2)
-{
-  bool value = qp1.model == qp2.model && qp1.settings == qp2.settings &&
-               qp1.results == qp2.results;
-  return value;
-}
-
-template<typename T>
-bool
-operator!=(const QP<T>& qp1, const QP<T>& qp2)
-{
-  return !(qp1 == qp2);
-}
-
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_WRAPPER_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file wrapper.hpp
+ */
+
+#ifndef PROXSUITE_PROXQP_DENSE_WRAPPER_HPP
+#define PROXSUITE_PROXQP_DENSE_WRAPPER_HPP
+#include <proxsuite/proxqp/dense/solver.hpp>
+#include <proxsuite/proxqp/dense/helpers.hpp>
+#include <proxsuite/proxqp/dense/preconditioner/ruiz.hpp>
+#include <chrono>
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+///
+/// @brief This class defines the API of PROXQP solver with dense backend.
+///
+/*!
+ * Wrapper class for using proxsuite API with dense backend
+ * for solving linearly constrained convex QP problem using ProxQp algorithm.
+ *
+ * Example usage:
+ * ```cpp
+#include <Eigen/Core>
+#include <Eigen/Cholesky>
+#include <proxsuite/proxqp/dense/dense.hpp>
+#include <proxsuite/linalg/veg/util/dbg.hpp>
+#include <util.hpp>
+
+using T = double;
+auto main() -> int {
+
+        // Generate a random QP problem with primal variable dimension of size
+dim; n_eq equality constraints and n_in inequality constraints
+        ::proxsuite::proxqp::test::rand::set_seed(1);
+        proxqp::isize dim = 10;
+        proxqp::isize n_eq(dim / 4);
+        proxqp::isize n_in(dim / 4);
+        T strong_convexity_factor(1.e-2);
+        T sparsity_factor = 0.15; // controls the sparsity of each matrix of the
+problem generated T eps_abs = T(1e-9); Qp<T> qp{
+                        random_with_dim_and_neq_and_n_in,
+                        dim,
+                        n_eq,
+                        n_in,
+                        sparsity_factor,
+                        strong_convexity_factor};
+
+        // Solve the problem
+        proxqp::dense::QP<T> Qp{dim, n_eq, n_in}; // creating QP object
+        Qp.settings.eps_abs = eps_abs; // choose accuracy needed
+        Qp.init(qp.H, qp.g, qp.A, qp.b, qp.C, qp.u, qp.l); // setup the QP
+object Qp.solve(); // solve the problem
+
+        // Verify solution accuracy
+        T pri_res = std::max(
+                        (qp.A * Qp.results.x - qp.b).lpNorm<Eigen::Infinity>(),
+                        (helpers::positive_part(qp.C * Qp.results.x -
+qp.u) + helpers::negative_part(qp.C * Qp.results.x - qp.l))
+                                        .lpNorm<Eigen::Infinity>());
+        T dua_res = (qp.H * Qp.results.x + qp.g + qp.A.transpose() *
+Qp.results.y + qp.C.transpose() * Qp.results.z) .lpNorm<Eigen::Infinity>();
+        VEG_ASSERT(pri_res <= eps_abs);
+        VEG_ASSERT(dua_res <= eps_abs);
+
+        // Some solver statistics
+        std::cout << "------solving qp with dim: " << dim
+                                                << " neq: " << n_eq << " nin: "
+<< n_in << std::endl; std::cout << "primal residual: " << pri_res << std::endl;
+        std::cout << "dual residual: " << dua_res << std::endl;
+        std::cout << "total number of iteration: " << Qp.results.info.iter
+                                                << std::endl;
+}
+ * ```
+ */
+///// QP object
+template<typename T>
+struct QP
+{
+  Results<T> results;
+  Settings<T> settings;
+  Model<T> model;
+  Workspace<T> work;
+  preconditioner::RuizEquilibration<T> ruiz;
+  /*!
+   * Default constructor using QP model dimensions.
+   * @param _dim primal variable dimension.
+   * @param _n_eq number of equality constraints.
+   * @param _n_in number of inequality constraints.
+   */
+  QP(isize _dim, isize _n_eq, isize _n_in)
+    : results(_dim, _n_eq, _n_in)
+    , settings()
+    , model(_dim, _n_eq, _n_in)
+    , work(_dim, _n_eq, _n_in)
+    , ruiz(preconditioner::RuizEquilibration<T>{ _dim, _n_eq + _n_in })
+  {
+    work.timer.stop();
+  }
+  /*!
+   * Setups the QP model (with dense matrix format) and equilibrates it if
+   * specified by the user.
+   * @param H quadratic cost input defining the QP model.
+   * @param g linear cost input defining the QP model.
+   * @param A equality constraint matrix input defining the QP model.
+   * @param b equality constraint vector input defining the QP model.
+   * @param C inequality constraint matrix input defining the QP model.
+   * @param l lower inequality constraint vector input defining the QP model.
+   * @param u upper inequality constraint vector input defining the QP model.
+   * @param compute_preconditioner boolean parameter for executing or not the
+   * preconditioner.
+   * @param rho proximal step size wrt primal variable.
+   * @param mu_eq proximal step size wrt equality constrained multiplier.
+   * @param mu_in proximal step size wrt inequality constrained multiplier.
+   */
+  void init(optional<MatRef<T>> H,
+            optional<VecRef<T>> g,
+            optional<MatRef<T>> A,
+            optional<VecRef<T>> b,
+            optional<MatRef<T>> C,
+            optional<VecRef<T>> l,
+            optional<VecRef<T>> u,
+            bool compute_preconditioner = true,
+            optional<T> rho = nullopt,
+            optional<T> mu_eq = nullopt,
+            optional<T> mu_in = nullopt)
+  {
+    // dense case
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    // check the model is valid
+    if (g != nullopt && g.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        g.value().size(),
+        model.dim,
+        "the dimension wrt the primal variable x variable for initializing g "
+        "is not valid.");
+    } else {
+      g.reset();
+    }
+    if (b != nullopt && b.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        b.value().size(),
+        model.n_eq,
+        "the dimension wrt equality constrained variables for initializing b "
+        "is not valid.");
+    } else {
+      b.reset();
+    }
+    if (u != nullopt && u.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        u.value().size(),
+        model.n_in,
+        "the dimension wrt inequality constrained variables for initializing u "
+        "is not valid.");
+    } else {
+      u.reset();
+    }
+    if (l != nullopt && l.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        l.value().size(),
+        model.n_in,
+        "the dimension wrt inequality constrained variables for initializing l "
+        "is not valid.");
+    } else {
+      l.reset();
+    }
+    if (H != nullopt && H.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().rows(),
+        model.dim,
+        "the row dimension for initializing H is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().cols(),
+        model.dim,
+        "the column dimension for initializing H is not valid.");
+    } else {
+      H.reset();
+    }
+    if (A != nullopt && A.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().rows(),
+        model.n_eq,
+        "the row dimension for initializing A is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().cols(),
+        model.dim,
+        "the column dimension for initializing A is not valid.");
+    } else {
+      A.reset();
+    }
+    if (C != nullopt && C.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().rows(),
+        model.n_in,
+        "the row dimension for initializing C is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().cols(),
+        model.dim,
+        "the column dimension for initializing C is not valid.");
+    } else {
+      C.reset();
+    }
+    if (settings.initial_guess ==
+        InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT) {
+      work.refactorize =
+        true; // necessary for the first solve (then refactorize only if there
+              // is an update of the matrices)
+    } else {
+      work.refactorize = false;
+    }
+    work.proximal_parameter_update = false;
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    PreconditionerStatus preconditioner_status;
+    if (compute_preconditioner) {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
+    } else {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::IDENTITY;
+    }
+    proxsuite::proxqp::dense::update_proximal_parameters(
+      settings, results, work, rho, mu_eq, mu_in);
+    proxsuite::proxqp::dense::setup(H,
+                                    g,
+                                    A,
+                                    b,
+                                    C,
+                                    l,
+                                    u,
+                                    settings,
+                                    model,
+                                    work,
+                                    results,
+                                    ruiz,
+                                    preconditioner_status);
+    work.is_initialized = true;
+    if (settings.compute_timings) {
+      results.info.setup_time = work.timer.elapsed().user; // in microseconds
+    }
+  };
+  /*!
+   * Updates the QP model (with dense matrix format) and re-equilibrates it if
+   * specified by the user.
+   * @param H quadratic cost input defining the QP model.
+   * @param g linear cost input defining the QP model.
+   * @param A equality constraint matrix input defining the QP model.
+   * @param b equality constraint vector input defining the QP model.
+   * @param C inequality constraint matrix input defining the QP model.
+   * @param l lower inequality constraint vector input defining the QP model.
+   * @param u upper inequality constraint vector input defining the QP model.
+   * @param update_preconditioner bool parameter for updating or not the
+   * preconditioner and the associated scaled model.
+   * @param rho proximal step size wrt primal variable.
+   * @param mu_eq proximal step size wrt equality constrained multiplier.
+   * @param mu_in proximal step size wrt inequality constrained multiplier.
+   * @note The init method should be called before update. If it has not been
+   * done before, init is called depending on the is_initialized flag.
+   */
+  void update(optional<MatRef<T>> H,
+              optional<VecRef<T>> g,
+              optional<MatRef<T>> A,
+              optional<VecRef<T>> b,
+              optional<MatRef<T>> C,
+              optional<VecRef<T>> l,
+              optional<VecRef<T>> u,
+              bool update_preconditioner = true,
+              optional<T> rho = nullopt,
+              optional<T> mu_eq = nullopt,
+              optional<T> mu_in = nullopt)
+  {
+    if (!work.is_initialized) {
+      init(H, g, A, b, C, l, u, update_preconditioner, rho, mu_eq, mu_in);
+      return;
+    }
+    // dense case
+    work.refactorize = false;
+    work.proximal_parameter_update = false;
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    PreconditionerStatus preconditioner_status;
+    if (update_preconditioner) {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
+    } else {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::KEEP;
+    }
+    const bool matrix_update =
+      !(H == nullopt && g == nullopt && A == nullopt && b == nullopt &&
+        C == nullopt && u == nullopt && l == nullopt);
+    if (matrix_update) {
+      proxsuite::proxqp::dense::update(H, g, A, b, C, l, u, model, work);
+    }
+    proxsuite::proxqp::dense::update_proximal_parameters(
+      settings, results, work, rho, mu_eq, mu_in);
+
+    typedef optional<MatRef<T>> optional_MatRef;
+    typedef optional<VecRef<T>> optional_VecRef;
+    proxsuite::proxqp::dense::setup(/* avoid double assignation */
+                                    optional_MatRef(nullopt),
+                                    optional_VecRef(nullopt),
+                                    optional_MatRef(nullopt),
+                                    optional_VecRef(nullopt),
+                                    optional_MatRef(nullopt),
+                                    optional_VecRef(nullopt),
+                                    optional_VecRef(nullopt),
+                                    settings,
+                                    model,
+                                    work,
+                                    results,
+                                    ruiz,
+                                    preconditioner_status);
+
+    if (settings.compute_timings) {
+      results.info.setup_time = work.timer.elapsed().user; // in microseconds
+    }
+  };
+
+  /*!
+   * Solves the QP problem using PRXOQP algorithm.
+   */
+  void solve()
+  {
+    qp_solve( //
+      settings,
+      model,
+      results,
+      work,
+      ruiz);
+  };
+  /*!
+   * Solves the QP problem using PROXQP algorithm using a warm start.
+   * @param x primal warm start.
+   * @param y dual equality warm start.
+   * @param z dual inequality warm start.
+   */
+  void solve(optional<VecRef<T>> x,
+             optional<VecRef<T>> y,
+             optional<VecRef<T>> z)
+  {
+    proxsuite::proxqp::dense::warm_start(x, y, z, results, settings, model);
+    qp_solve( //
+      settings,
+      model,
+      results,
+      work,
+      ruiz);
+  };
+  /*!
+   * Clean-ups solver's results and workspace.
+   */
+  void cleanup()
+  {
+    results.cleanup(settings);
+    work.cleanup();
+  }
+};
+/*!
+ * Solves the QP problem using PROXQP algorithm without the need to define a QP
+ * object, with matrices defined by Dense Eigen matrices. It is possible to set
+ * up some of the solver parameters (warm start, initial guess option, proximal
+ * step sizes, absolute and relative accuracies, maximum number of iterations,
+ * preconditioner execution).
+ * @param H quadratic cost input defining the QP model.
+ * @param g linear cost input defining the QP model.
+ * @param A equality constraint matrix input defining the QP model.
+ * @param b equality constraint vector input defining the QP model.
+ * @param C inequality constraint matrix input defining the QP model.
+ * @param l lower inequality constraint vector input defining the QP model.
+ * @param u upper inequality constraint vector input defining the QP model.
+ * @param x primal warm start.
+ * @param y dual equality constraint warm start.
+ * @param z dual inequality constraint warm start.
+ * @param verbose if set to true, the solver prints more information about each
+ * iteration.
+ * @param compute_preconditioner bool parameter for executing or not the
+ * preconditioner.
+ * @param compute_timings boolean parameter for computing the solver timings.
+ * @param rho proximal step size wrt primal variable.
+ * @param mu_eq proximal step size wrt equality constrained multiplier.
+ * @param mu_in proximal step size wrt inequality constrained multiplier.
+ * @param eps_abs absolute accuracy threshold.
+ * @param eps_rel relative accuracy threshold.
+ * @param max_iter maximum number of iteration.
+ * @param initial_guess initial guess option for warm starting or not the
+ * initial iterate values.
+ * @param check_duality_gap If set to true, include the duality gap in absolute
+ * and relative stopping criteria.
+ * @param eps_duality_gap_abs absolute accuracy threshold for the duality-gap
+ * criterion.
+ * @param eps_duality_gap_rel relative accuracy threshold for the duality-gap
+ * criterion.
+ */
+template<typename T>
+proxqp::Results<T>
+solve(
+  optional<MatRef<T>> H,
+  optional<VecRef<T>> g,
+  optional<MatRef<T>> A,
+  optional<VecRef<T>> b,
+  optional<MatRef<T>> C,
+  optional<VecRef<T>> l,
+  optional<VecRef<T>> u,
+  optional<VecRef<T>> x = nullopt,
+  optional<VecRef<T>> y = nullopt,
+  optional<VecRef<T>> z = nullopt,
+  optional<T> eps_abs = nullopt,
+  optional<T> eps_rel = nullopt,
+  optional<T> rho = nullopt,
+  optional<T> mu_eq = nullopt,
+  optional<T> mu_in = nullopt,
+  optional<bool> verbose = nullopt,
+  bool compute_preconditioner = true,
+  bool compute_timings = false,
+  optional<isize> max_iter = nullopt,
+  proxsuite::proxqp::InitialGuessStatus initial_guess =
+    proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS,
+  bool check_duality_gap = false,
+  optional<T> eps_duality_gap_abs = nullopt,
+  optional<T> eps_duality_gap_rel = nullopt)
+{
+  isize n(0);
+  isize n_eq(0);
+  isize n_in(0);
+  if (H != nullopt) {
+    n = H.value().rows();
+  }
+  if (A != nullopt) {
+    n_eq = A.value().rows();
+  }
+  if (C != nullopt) {
+    n_in = C.value().rows();
+  }
+
+  QP<T> Qp(n, n_eq, n_in);
+  Qp.settings.initial_guess = initial_guess;
+  Qp.settings.check_duality_gap = check_duality_gap;
+
+  if (eps_abs != nullopt) {
+    Qp.settings.eps_abs = eps_abs.value();
+  }
+  if (eps_rel != nullopt) {
+    Qp.settings.eps_rel = eps_rel.value();
+  }
+  if (verbose != nullopt) {
+    Qp.settings.verbose = verbose.value();
+  }
+  if (max_iter != nullopt) {
+    Qp.settings.max_iter = max_iter.value();
+  }
+  if (eps_duality_gap_abs != nullopt) {
+    Qp.settings.eps_duality_gap_abs = eps_duality_gap_abs.value();
+  }
+  if (eps_duality_gap_rel != nullopt) {
+    Qp.settings.eps_duality_gap_rel = eps_duality_gap_rel.value();
+  }
+  Qp.settings.compute_timings = compute_timings;
+  Qp.init(H, g, A, b, C, l, u, compute_preconditioner, rho, mu_eq, mu_in);
+  Qp.solve(x, y, z);
+
+  return Qp.results;
+}
+
+template<typename T>
+bool
+operator==(const QP<T>& qp1, const QP<T>& qp2)
+{
+  bool value = qp1.model == qp2.model && qp1.settings == qp2.settings &&
+               qp1.results == qp2.results;
+  return value;
+}
+
+template<typename T>
+bool
+operator!=(const QP<T>& qp1, const QP<T>& qp2)
+{
+  return !(qp1 == qp2);
+}
+
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_WRAPPER_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/identity.hpp

 * *Ordering differences only*

```diff
@@ -1,113 +1,113 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file identity.hpp
- */
-#ifndef PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP
-#define PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP
-
-#include "proxsuite/proxqp/dense/views.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace dense {
-namespace preconditioner {
-struct IdentityPrecond
-{
-
-  /*!
-   * Scales the qp performing using identity equilibrator (i.e., does nothing).
-   */
-  template<typename T>
-  void scale_qp_in_place(QpViewBoxMut<T> /*qp*/) const noexcept
-  {
-  }
-  /*!
-   * Scales a primal variable in place.
-   */
-  template<typename T>
-  void scale_primal_in_place(VectorViewMut<T> /*x*/) const noexcept
-  {
-  }
-  /*!
-   * Scales a dual inequality constrained variable in place.
-   */
-  template<typename T>
-  void scale_dual_in_place_in(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-  /*!
-   * Scales a dual equality constrained variable in place.
-   */
-  template<typename T>
-  void scale_dual_in_place_eq(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-  /*!
-   * Scales a primal residual in place.
-   */
-  template<typename T>
-  void scale_primal_residual_in_place(VectorViewMut<T> /*x*/) const noexcept
-  {
-  }
-  /*!
-   * Scales a dual residual in place.
-   */
-  template<typename T>
-  void scale_dual_residual_in_place(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-  /*!
-   * Unscales a primal variable in place.
-   */
-  template<typename T>
-  void unscale_primal_in_place(VectorViewMut<T> /*x*/) const noexcept
-  {
-  }
-
-  /*!
-   * Unscales a dual variable in place.
-   */
-  template<typename T>
-  void unscale_dual_in_place_in(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-  /*!
-   * Unscales a dual equality variable in place.
-   */
-  template<typename T>
-  void unscale_dual_in_place_eq(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-  /*!
-   * Unscales a primal inequality residual in place.
-   */
-  template<typename T>
-  void unscale_primal_residual_in_place_in(
-    VectorViewMut<T> /*x*/) const noexcept
-  {
-  }
-  /*!
-   * Unscales a primal equality residual in place.
-   */
-  template<typename T>
-  void unscale_primal_residual_in_place_eq(
-    VectorViewMut<T> /*x*/) const noexcept
-  {
-  }
-  /*!
-   * Unscales a dual residual in place.
-   */
-  template<typename T>
-  void unscale_dual_residual_in_place(VectorViewMut<T> /*y*/) const noexcept
-  {
-  }
-};
-} // namespace preconditioner
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP     \
-        */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file identity.hpp
+ */
+#ifndef PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP
+#define PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP
+
+#include "proxsuite/proxqp/dense/views.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace dense {
+namespace preconditioner {
+struct IdentityPrecond
+{
+
+  /*!
+   * Scales the qp performing using identity equilibrator (i.e., does nothing).
+   */
+  template<typename T>
+  void scale_qp_in_place(QpViewBoxMut<T> /*qp*/) const noexcept
+  {
+  }
+  /*!
+   * Scales a primal variable in place.
+   */
+  template<typename T>
+  void scale_primal_in_place(VectorViewMut<T> /*x*/) const noexcept
+  {
+  }
+  /*!
+   * Scales a dual inequality constrained variable in place.
+   */
+  template<typename T>
+  void scale_dual_in_place_in(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+  /*!
+   * Scales a dual equality constrained variable in place.
+   */
+  template<typename T>
+  void scale_dual_in_place_eq(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+  /*!
+   * Scales a primal residual in place.
+   */
+  template<typename T>
+  void scale_primal_residual_in_place(VectorViewMut<T> /*x*/) const noexcept
+  {
+  }
+  /*!
+   * Scales a dual residual in place.
+   */
+  template<typename T>
+  void scale_dual_residual_in_place(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+  /*!
+   * Unscales a primal variable in place.
+   */
+  template<typename T>
+  void unscale_primal_in_place(VectorViewMut<T> /*x*/) const noexcept
+  {
+  }
+
+  /*!
+   * Unscales a dual variable in place.
+   */
+  template<typename T>
+  void unscale_dual_in_place_in(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+  /*!
+   * Unscales a dual equality variable in place.
+   */
+  template<typename T>
+  void unscale_dual_in_place_eq(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+  /*!
+   * Unscales a primal inequality residual in place.
+   */
+  template<typename T>
+  void unscale_primal_residual_in_place_in(
+    VectorViewMut<T> /*x*/) const noexcept
+  {
+  }
+  /*!
+   * Unscales a primal equality residual in place.
+   */
+  template<typename T>
+  void unscale_primal_residual_in_place_eq(
+    VectorViewMut<T> /*x*/) const noexcept
+  {
+  }
+  /*!
+   * Unscales a dual residual in place.
+   */
+  template<typename T>
+  void unscale_dual_residual_in_place(VectorViewMut<T> /*y*/) const noexcept
+  {
+  }
+};
+} // namespace preconditioner
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_PRECOND_IDENTITY_HPP     \
+        */
```

## cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/ruiz.hpp

 * *Ordering differences only*

```diff
@@ -1,571 +1,571 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file ruiz.hpp
- */
-#ifndef PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP
-#define PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP
-
-#include "proxsuite/proxqp/dense/views.hpp"
-#include "proxsuite/proxqp/dense/fwd.hpp"
-#include <proxsuite/linalg/dense/core.hpp>
-#include <ostream>
-
-#include <Eigen/Core>
-
-namespace proxsuite {
-namespace proxqp {
-enum struct Symmetry
-{
-  general,
-  lower,
-  upper,
-};
-namespace dense {
-namespace detail {
-
-template<typename T>
-auto
-ruiz_scale_qp_in_place( //
-  VectorViewMut<T> delta_,
-  std::ostream* logger_ptr,
-  QpViewBoxMut<T> qp,
-  T epsilon,
-  isize max_iter,
-  Symmetry sym,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack) -> T
-{
-
-  T c(1);
-  auto S = delta_.to_eigen();
-
-  auto H = qp.H.to_eigen();
-  auto g = qp.g.to_eigen();
-  auto A = qp.A.to_eigen();
-  auto b = qp.b.to_eigen();
-  auto C = qp.C.to_eigen();
-  auto u = qp.u.to_eigen();
-  auto l = qp.l.to_eigen();
-
-  static constexpr T machine_eps = std::numeric_limits<T>::epsilon();
-  /*
-   * compute equilibration parameters and scale in place the qp following
-   * algorithm
-   *
-   * modified: removed g in gamma computation
-   */
-
-  isize n = qp.H.rows;
-  isize n_eq = qp.A.rows;
-  isize n_in = qp.C.rows;
-
-  T gamma = T(1);
-
-  LDLT_TEMP_VEC(T, delta, n + n_eq + n_in, stack);
-
-  i64 iter = 1;
-
-  while (infty_norm((1 - delta.array()).matrix()) > epsilon) {
-    if (logger_ptr != nullptr) {
-      *logger_ptr                                   //
-        << "j : "                                   //
-        << iter                                     //
-        << " ; error : "                            //
-        << infty_norm((1 - delta.array()).matrix()) //
-        << "\n\n";
-    }
-    if (iter == max_iter) {
-      break;
-    } else {
-      ++iter;
-    }
-
-    // normalization vector
-    {
-      for (isize k = 0; k < n; ++k) {
-        switch (sym) {
-          case Symmetry::upper: { // upper triangular part
-            T aux = sqrt(std::max({
-              infty_norm(H.col(k).head(k)),
-              infty_norm(H.row(k).tail(n - k)),
-              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
-              n_in > 0 ? infty_norm(C.col(k)) : T(0),
-            }));
-            if (aux == T(0)) {
-              delta(k) = T(1);
-            } else {
-              delta(k) = T(1) / (aux + machine_eps);
-            }
-            break;
-          }
-          case Symmetry::lower: { // lower triangular part
-
-            T aux = sqrt(std::max({
-              infty_norm(H.col(k).head(k)),
-              infty_norm(H.col(k).tail(n - k)),
-              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
-              n_in > 0 ? infty_norm(C.col(k)) : T(0),
-            }));
-            if (aux == T(0)) {
-              delta(k) = T(1);
-            } else {
-              delta(k) = T(1) / (aux + machine_eps);
-            }
-            break;
-          }
-          case Symmetry::general: {
-
-            T aux = sqrt(std::max({
-              infty_norm(H.col(k)),
-              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
-              n_in > 0 ? infty_norm(C.col(k)) : T(0),
-            }));
-            if (aux == T(0)) {
-              delta(k) = T(1);
-            } else {
-              delta(k) = T(1) / (aux + machine_eps);
-            }
-            break;
-          }
-        }
-      }
-
-      for (isize k = 0; k < n_eq; ++k) {
-        T aux = sqrt(infty_norm(A.row(k)));
-        if (aux == T(0)) {
-          delta(n + k) = T(1);
-        } else {
-          delta(n + k) = T(1) / (aux + machine_eps);
-        }
-      }
-      for (isize k = 0; k < n_in; ++k) {
-        T aux = sqrt(infty_norm(C.row(k)));
-        if (aux == T(0)) {
-          delta(k + n + n_eq) = T(1);
-        } else {
-          delta(k + n + n_eq) = T(1) / (aux + machine_eps);
-        }
-      }
-    }
-    {
-
-      // normalize A and C
-      A = delta.segment(n, n_eq).asDiagonal() * A * delta.head(n).asDiagonal();
-      C = delta.tail(n_in).asDiagonal() * C * delta.head(n).asDiagonal();
-      // normalize vectors
-      g.array() *= delta.head(n).array();
-      b.array() *= delta.middleRows(n, n_eq).array();
-      u.array() *= delta.tail(n_in).array();
-      l.array() *= delta.tail(n_in).array();
-
-      // normalize H
-      switch (sym) {
-        case Symmetry::upper: {
-          // upper triangular part
-          for (isize j = 0; j < n; ++j) {
-            H.col(j).head(j + 1) *= delta(j);
-          }
-          // normalisation des lignes
-          for (isize i = 0; i < n; ++i) {
-            H.row(i).tail(n - i) *= delta(i);
-          }
-          break;
-        }
-        case Symmetry::lower: {
-          // lower triangular part
-          for (isize j = 0; j < n; ++j) {
-            H.col(j).tail(n - j) *= delta(j);
-          }
-          // normalisation des lignes
-          for (isize i = 0; i < n; ++i) {
-            H.row(i).head(i + 1) *= delta(i);
-          }
-          break;
-        }
-        case Symmetry::general: {
-          // all matrix
-          H = delta.head(n).asDiagonal() * H * delta.head(n).asDiagonal();
-          break;
-        }
-        default:
-          break;
-      }
-
-      // additional normalization for the cost function
-      switch (sym) {
-        case Symmetry::upper: {
-          // upper triangular part
-          T tmp = T(0);
-          for (isize j = 0; j < n; ++j) {
-            tmp += proxqp::dense::infty_norm(H.row(j).tail(n - j));
-          }
-          gamma = 1 / std::max(tmp / T(n), T(1));
-          break;
-        }
-        case Symmetry::lower: {
-          // lower triangular part
-          T tmp = T(0);
-          for (isize j = 0; j < n; ++j) {
-            tmp += proxqp::dense::infty_norm(H.col(j).tail(n - j));
-          }
-          gamma = 1 / std::max(tmp / T(n), T(1));
-          break;
-        }
-        case Symmetry::general: {
-          // all matrix
-          gamma =
-            1 /
-            std::max(T(1),
-                     (H.colwise().template lpNorm<Eigen::Infinity>()).mean());
-          break;
-        }
-        default:
-          break;
-      }
-
-      g *= gamma;
-      H *= gamma;
-
-      S.array() *= delta.array(); // coefficientwise product
-      c *= gamma;
-    }
-  }
-  return c;
-}
-} // namespace detail
-
-namespace preconditioner {
-
-template<typename T>
-struct RuizEquilibration
-{
-  Vec<T> delta;
-  T c;
-  isize dim;
-  T epsilon;
-  i64 max_iter;
-  Symmetry sym;
-
-  std::ostream* logger_ptr = nullptr;
-  /*!
-   * Default constructor.
-   * @param dim primal variable dimension.
-   * @param n_eq_in number of equality and inequality constraints.
-   * @param epsilon_ accuracy required for stopping the ruiz equilibration
-   * algorithm.
-   * @param max_iter_ maximum number of ruiz equilibration iterations.
-   * @param sym_ symetry option format of quadratic cost matrix.
-   * @param logger parameter for printing or not intermediary results.
-   */
-  explicit RuizEquilibration(isize dim_,
-                             isize n_eq_in,
-                             T epsilon_ = T(1e-3),
-                             i64 max_iter_ = 10,
-                             Symmetry sym_ = Symmetry::general,
-                             std::ostream* logger = nullptr)
-    : delta(Vec<T>::Ones(dim_ + n_eq_in))
-    , c(1)
-    , dim(dim_)
-    , epsilon(epsilon_)
-    , max_iter(max_iter_)
-    , sym(sym_)
-    , logger_ptr(logger)
-  {
-  }
-  /*!
-   * Prints ruiz equilibrator scaling variables.
-   */
-  void print() const
-  {
-    // CHANGE: endl to newline
-    *logger_ptr << " delta : " << delta << "\n\n";
-    *logger_ptr << " c : " << c << "\n\n";
-  }
-  /*!
-   * Determines memory requirements for executing the equilibrator.
-   * @param tag tag for specifying entry type.
-   * @param n dimension of the primal variable of the model.
-   * @param n_eq number of equality constraints.
-   * @param n_in number of inequality constraints.
-   */
-  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> tag,
-                                    isize n,
-                                    isize n_eq,
-                                    isize n_in)
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return proxsuite::linalg::dense::temp_vec_req(tag, n + n_eq + n_in);
-  }
-
-  // H_new = c * head @ H @ head
-  // A_new = tail @ A @ head
-  // g_new = c * head @ g
-  // b_new = tail @ b
-  /*!
-   * Scales the qp performing the ruiz equilibrator algorithm considering user
-   * options.
-   * @param qp qp to be scaled (in place).
-   * @param execute_preconditioner bool variable specifying whether the qp is
-   * scaled using current equilibrator scaling variables, or performing anew the
-   * algorithm.
-   * @param settings solver's settings.
-   * @param stack stack variable used by the equilibrator.
-   */
-  void scale_qp_in_place(QpViewBoxMut<T> qp,
-                         bool execute_preconditioner,
-                         const isize max_iter,
-                         const T epsilon,
-                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-    if (execute_preconditioner) {
-      delta.setOnes();
-      c = detail::ruiz_scale_qp_in_place({ proxqp::from_eigen, delta },
-                                         logger_ptr,
-                                         qp,
-                                         epsilon,
-                                         max_iter,
-                                         sym,
-                                         stack);
-    } else {
-
-      auto H = qp.H.to_eigen();
-      auto g = qp.g.to_eigen();
-      auto A = qp.A.to_eigen();
-      auto b = qp.b.to_eigen();
-      auto C = qp.C.to_eigen();
-      auto u = qp.u.to_eigen();
-      auto l = qp.l.to_eigen();
-      isize n = qp.H.rows;
-      isize n_eq = qp.A.rows;
-      isize n_in = qp.C.rows;
-
-      // normalize A and C
-      A = delta.segment(n, n_eq).asDiagonal() * A * delta.head(n).asDiagonal();
-      C = delta.tail(n_in).asDiagonal() * C * delta.head(n).asDiagonal();
-
-      // normalize H
-      switch (sym) {
-        case Symmetry::upper: {
-          // upper triangular part
-          for (isize j = 0; j < n; ++j) {
-            H.col(j).head(j + 1) *= delta(j);
-          }
-          // normalisation des lignes
-          for (isize i = 0; i < n; ++i) {
-            H.row(i).tail(n - i) *= delta(i);
-          }
-          break;
-        }
-        case Symmetry::lower: {
-          // lower triangular part
-          for (isize j = 0; j < n; ++j) {
-            H.col(j).tail(n - j) *= delta(j);
-          }
-          // normalisation des lignes
-          for (isize i = 0; i < n; ++i) {
-            H.row(i).head(i + 1) *= delta(i);
-          }
-          break;
-        }
-        case Symmetry::general: {
-          // all matrix
-          H = delta.head(n).asDiagonal() * H * delta.head(n).asDiagonal();
-          break;
-        }
-        default:
-          break;
-      }
-
-      // normalize vectors
-      g.array() *= delta.head(n).array();
-      b.array() *= delta.segment(n, n_eq).array();
-      l.array() *= delta.tail(n_in).array();
-      u.array() *= delta.tail(n_in).array();
-
-      g *= c;
-      H *= c;
-    }
-  }
-  /*!
-   * Scales the qp performing the ruiz equilibrator algorithm considering user
-   * options.
-   * @param qp qp model.
-   * @param scaled_qp qp to be scaled.
-   * @param tmp_delta_preallocated temporary variable used for performing the
-   * equilibration.
-   */
-  void scale_qp(const QpViewBox<T> qp,
-                QpViewBoxMut<T> scaled_qp,
-                VectorViewMut<T> tmp_delta_preallocated) const
-  {
-
-    /*
-     * scaled_qp is scaled, whereas first qp is not
-     * the procedure computes as well equilibration parameters using default
-     * parameters
-     */
-
-    scaled_qp.H.to_eigen() = qp.H.to_eigen();
-    scaled_qp.A.to_eigen() = qp.A.to_eigen();
-    scaled_qp.C.to_eigen() = qp.C.to_eigen();
-    scaled_qp.g.to_eigen() = qp.g.to_eigen();
-    scaled_qp.b.to_eigen() = qp.b.to_eigen();
-    scaled_qp.d.to_eigen() = qp.d.to_eigen();
-
-    scale_qp_in_place(scaled_qp, tmp_delta_preallocated, epsilon, max_iter);
-  }
-  // modifies variables in place
-  /*!
-   * Scales a primal variable in place.
-   * @param primal primal variable.
-   */
-  void scale_primal_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() /= delta.array().head(dim);
-  }
-  /*!
-   * Scales a dual variable in place.
-   * @param dual dual variable (includes all equalities and inequalities
-   * constraints).
-   */
-  void scale_dual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
-                              delta.tail(delta.size() - dim).array() * c;
-  }
-  /*!
-   * Scales a dual equality constrained variable in place.
-   * @param dual dual variable (includes equalities constraints only).
-   */
-  void scale_dual_in_place_eq(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() =
-      dual.as_const().to_eigen().array() /
-      delta.middleRows(dim, dual.to_eigen().size()).array() * c;
-  }
-  /*!
-   * Scales a dual inequality constrained variable in place.
-   * @param dual dual variable (includes inequalities constraints only).
-   */
-  void scale_dual_in_place_in(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
-                              delta.tail(dual.to_eigen().size()).array() * c;
-  }
-  /*!
-   * Unscales a primal variable in place.
-   * @param primal primal variable.
-   */
-  void unscale_primal_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() *= delta.array().head(dim);
-  }
-  /*!
-   * Unscales a dual variable in place.
-   * @param dual dual variable (includes equalities constraints only).
-   */
-  void unscale_dual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
-                              delta.tail(delta.size() - dim).array() / c;
-  }
-  /*!
-   * Unscales a dual equality constrained variable in place.
-   * @param dual dual variable (includes equalities constraints only).
-   */
-  void unscale_dual_in_place_eq(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() =
-      dual.as_const().to_eigen().array() *
-      delta.middleRows(dim, dual.to_eigen().size()).array() / c;
-  }
-  /*!
-   * Unscales a dual inequality constrained variable in place.
-   * @param dual dual variable (includes inequalities constraints only).
-   */
-  void unscale_dual_in_place_in(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
-                              delta.tail(dual.to_eigen().size()).array() / c;
-  }
-  // modifies residuals in place
-  /*!
-   * Scales a primal residual in place.
-   * @param primal primal residual (includes equality and inequality
-   * constraints)
-   */
-  void scale_primal_residual_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() *= delta.tail(delta.size() - dim).array();
-  }
-
-  /*!
-   * Scales a primal equality constraint residual in place.
-   * @param primal primal equality constraint residual.
-   */
-  void scale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
-  {
-    primal_eq.to_eigen().array() *=
-      delta.middleRows(dim, primal_eq.to_eigen().size()).array();
-  }
-  /*!
-   * Scales a primal inequality constraint residual in place.
-   * @param primal primal inequality constraint residual.
-   */
-  void scale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
-  {
-    primal_in.to_eigen().array() *=
-      delta.tail(primal_in.to_eigen().size()).array();
-  }
-  /*!
-   * Scales a dual residual in place.
-   * @param dual dual residual.
-   */
-  void scale_dual_residual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() *= delta.head(dim).array() * c;
-  }
-  /*!
-   * Unscales a primal residual in place.
-   * @param primal primal residual (includes equality and inequality
-   * constraints).
-   */
-  void unscale_primal_residual_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() /= delta.tail(delta.size() - dim).array();
-  }
-  /*!
-   * Unscales a primal equality constraint residual in place.
-   * @param primal primal equality constraint residual.
-   */
-  void unscale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
-  {
-    primal_eq.to_eigen().array() /=
-      delta.middleRows(dim, primal_eq.to_eigen().size()).array();
-  }
-  /*!
-   * Unscales a primal inequality constraint residual in place.
-   * @param primal primal inequality constraint residual.
-   */
-  void unscale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
-  {
-    primal_in.to_eigen().array() /=
-      delta.tail(primal_in.to_eigen().size()).array();
-  }
-  /*!
-   * Unscales a dual residual in place.
-   * @param dual dual residual.
-   */
-  void unscale_dual_residual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() /= delta.head(dim).array() * c;
-  }
-};
-
-} // namespace preconditioner
-} // namespace dense
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file ruiz.hpp
+ */
+#ifndef PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP
+#define PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP
+
+#include "proxsuite/proxqp/dense/views.hpp"
+#include "proxsuite/proxqp/dense/fwd.hpp"
+#include <proxsuite/linalg/dense/core.hpp>
+#include <ostream>
+
+#include <Eigen/Core>
+
+namespace proxsuite {
+namespace proxqp {
+enum struct Symmetry
+{
+  general,
+  lower,
+  upper,
+};
+namespace dense {
+namespace detail {
+
+template<typename T>
+auto
+ruiz_scale_qp_in_place( //
+  VectorViewMut<T> delta_,
+  std::ostream* logger_ptr,
+  QpViewBoxMut<T> qp,
+  T epsilon,
+  isize max_iter,
+  Symmetry sym,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack) -> T
+{
+
+  T c(1);
+  auto S = delta_.to_eigen();
+
+  auto H = qp.H.to_eigen();
+  auto g = qp.g.to_eigen();
+  auto A = qp.A.to_eigen();
+  auto b = qp.b.to_eigen();
+  auto C = qp.C.to_eigen();
+  auto u = qp.u.to_eigen();
+  auto l = qp.l.to_eigen();
+
+  static constexpr T machine_eps = std::numeric_limits<T>::epsilon();
+  /*
+   * compute equilibration parameters and scale in place the qp following
+   * algorithm
+   *
+   * modified: removed g in gamma computation
+   */
+
+  isize n = qp.H.rows;
+  isize n_eq = qp.A.rows;
+  isize n_in = qp.C.rows;
+
+  T gamma = T(1);
+
+  LDLT_TEMP_VEC(T, delta, n + n_eq + n_in, stack);
+
+  i64 iter = 1;
+
+  while (infty_norm((1 - delta.array()).matrix()) > epsilon) {
+    if (logger_ptr != nullptr) {
+      *logger_ptr                                   //
+        << "j : "                                   //
+        << iter                                     //
+        << " ; error : "                            //
+        << infty_norm((1 - delta.array()).matrix()) //
+        << "\n\n";
+    }
+    if (iter == max_iter) {
+      break;
+    } else {
+      ++iter;
+    }
+
+    // normalization vector
+    {
+      for (isize k = 0; k < n; ++k) {
+        switch (sym) {
+          case Symmetry::upper: { // upper triangular part
+            T aux = sqrt(std::max({
+              infty_norm(H.col(k).head(k)),
+              infty_norm(H.row(k).tail(n - k)),
+              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
+              n_in > 0 ? infty_norm(C.col(k)) : T(0),
+            }));
+            if (aux == T(0)) {
+              delta(k) = T(1);
+            } else {
+              delta(k) = T(1) / (aux + machine_eps);
+            }
+            break;
+          }
+          case Symmetry::lower: { // lower triangular part
+
+            T aux = sqrt(std::max({
+              infty_norm(H.col(k).head(k)),
+              infty_norm(H.col(k).tail(n - k)),
+              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
+              n_in > 0 ? infty_norm(C.col(k)) : T(0),
+            }));
+            if (aux == T(0)) {
+              delta(k) = T(1);
+            } else {
+              delta(k) = T(1) / (aux + machine_eps);
+            }
+            break;
+          }
+          case Symmetry::general: {
+
+            T aux = sqrt(std::max({
+              infty_norm(H.col(k)),
+              n_eq > 0 ? infty_norm(A.col(k)) : T(0),
+              n_in > 0 ? infty_norm(C.col(k)) : T(0),
+            }));
+            if (aux == T(0)) {
+              delta(k) = T(1);
+            } else {
+              delta(k) = T(1) / (aux + machine_eps);
+            }
+            break;
+          }
+        }
+      }
+
+      for (isize k = 0; k < n_eq; ++k) {
+        T aux = sqrt(infty_norm(A.row(k)));
+        if (aux == T(0)) {
+          delta(n + k) = T(1);
+        } else {
+          delta(n + k) = T(1) / (aux + machine_eps);
+        }
+      }
+      for (isize k = 0; k < n_in; ++k) {
+        T aux = sqrt(infty_norm(C.row(k)));
+        if (aux == T(0)) {
+          delta(k + n + n_eq) = T(1);
+        } else {
+          delta(k + n + n_eq) = T(1) / (aux + machine_eps);
+        }
+      }
+    }
+    {
+
+      // normalize A and C
+      A = delta.segment(n, n_eq).asDiagonal() * A * delta.head(n).asDiagonal();
+      C = delta.tail(n_in).asDiagonal() * C * delta.head(n).asDiagonal();
+      // normalize vectors
+      g.array() *= delta.head(n).array();
+      b.array() *= delta.middleRows(n, n_eq).array();
+      u.array() *= delta.tail(n_in).array();
+      l.array() *= delta.tail(n_in).array();
+
+      // normalize H
+      switch (sym) {
+        case Symmetry::upper: {
+          // upper triangular part
+          for (isize j = 0; j < n; ++j) {
+            H.col(j).head(j + 1) *= delta(j);
+          }
+          // normalisation des lignes
+          for (isize i = 0; i < n; ++i) {
+            H.row(i).tail(n - i) *= delta(i);
+          }
+          break;
+        }
+        case Symmetry::lower: {
+          // lower triangular part
+          for (isize j = 0; j < n; ++j) {
+            H.col(j).tail(n - j) *= delta(j);
+          }
+          // normalisation des lignes
+          for (isize i = 0; i < n; ++i) {
+            H.row(i).head(i + 1) *= delta(i);
+          }
+          break;
+        }
+        case Symmetry::general: {
+          // all matrix
+          H = delta.head(n).asDiagonal() * H * delta.head(n).asDiagonal();
+          break;
+        }
+        default:
+          break;
+      }
+
+      // additional normalization for the cost function
+      switch (sym) {
+        case Symmetry::upper: {
+          // upper triangular part
+          T tmp = T(0);
+          for (isize j = 0; j < n; ++j) {
+            tmp += proxqp::dense::infty_norm(H.row(j).tail(n - j));
+          }
+          gamma = 1 / std::max(tmp / T(n), T(1));
+          break;
+        }
+        case Symmetry::lower: {
+          // lower triangular part
+          T tmp = T(0);
+          for (isize j = 0; j < n; ++j) {
+            tmp += proxqp::dense::infty_norm(H.col(j).tail(n - j));
+          }
+          gamma = 1 / std::max(tmp / T(n), T(1));
+          break;
+        }
+        case Symmetry::general: {
+          // all matrix
+          gamma =
+            1 /
+            std::max(T(1),
+                     (H.colwise().template lpNorm<Eigen::Infinity>()).mean());
+          break;
+        }
+        default:
+          break;
+      }
+
+      g *= gamma;
+      H *= gamma;
+
+      S.array() *= delta.array(); // coefficientwise product
+      c *= gamma;
+    }
+  }
+  return c;
+}
+} // namespace detail
+
+namespace preconditioner {
+
+template<typename T>
+struct RuizEquilibration
+{
+  Vec<T> delta;
+  T c;
+  isize dim;
+  T epsilon;
+  i64 max_iter;
+  Symmetry sym;
+
+  std::ostream* logger_ptr = nullptr;
+  /*!
+   * Default constructor.
+   * @param dim primal variable dimension.
+   * @param n_eq_in number of equality and inequality constraints.
+   * @param epsilon_ accuracy required for stopping the ruiz equilibration
+   * algorithm.
+   * @param max_iter_ maximum number of ruiz equilibration iterations.
+   * @param sym_ symetry option format of quadratic cost matrix.
+   * @param logger parameter for printing or not intermediary results.
+   */
+  explicit RuizEquilibration(isize dim_,
+                             isize n_eq_in,
+                             T epsilon_ = T(1e-3),
+                             i64 max_iter_ = 10,
+                             Symmetry sym_ = Symmetry::general,
+                             std::ostream* logger = nullptr)
+    : delta(Vec<T>::Ones(dim_ + n_eq_in))
+    , c(1)
+    , dim(dim_)
+    , epsilon(epsilon_)
+    , max_iter(max_iter_)
+    , sym(sym_)
+    , logger_ptr(logger)
+  {
+  }
+  /*!
+   * Prints ruiz equilibrator scaling variables.
+   */
+  void print() const
+  {
+    // CHANGE: endl to newline
+    *logger_ptr << " delta : " << delta << "\n\n";
+    *logger_ptr << " c : " << c << "\n\n";
+  }
+  /*!
+   * Determines memory requirements for executing the equilibrator.
+   * @param tag tag for specifying entry type.
+   * @param n dimension of the primal variable of the model.
+   * @param n_eq number of equality constraints.
+   * @param n_in number of inequality constraints.
+   */
+  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> tag,
+                                    isize n,
+                                    isize n_eq,
+                                    isize n_in)
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return proxsuite::linalg::dense::temp_vec_req(tag, n + n_eq + n_in);
+  }
+
+  // H_new = c * head @ H @ head
+  // A_new = tail @ A @ head
+  // g_new = c * head @ g
+  // b_new = tail @ b
+  /*!
+   * Scales the qp performing the ruiz equilibrator algorithm considering user
+   * options.
+   * @param qp qp to be scaled (in place).
+   * @param execute_preconditioner bool variable specifying whether the qp is
+   * scaled using current equilibrator scaling variables, or performing anew the
+   * algorithm.
+   * @param settings solver's settings.
+   * @param stack stack variable used by the equilibrator.
+   */
+  void scale_qp_in_place(QpViewBoxMut<T> qp,
+                         bool execute_preconditioner,
+                         const isize max_iter,
+                         const T epsilon,
+                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+    if (execute_preconditioner) {
+      delta.setOnes();
+      c = detail::ruiz_scale_qp_in_place({ proxqp::from_eigen, delta },
+                                         logger_ptr,
+                                         qp,
+                                         epsilon,
+                                         max_iter,
+                                         sym,
+                                         stack);
+    } else {
+
+      auto H = qp.H.to_eigen();
+      auto g = qp.g.to_eigen();
+      auto A = qp.A.to_eigen();
+      auto b = qp.b.to_eigen();
+      auto C = qp.C.to_eigen();
+      auto u = qp.u.to_eigen();
+      auto l = qp.l.to_eigen();
+      isize n = qp.H.rows;
+      isize n_eq = qp.A.rows;
+      isize n_in = qp.C.rows;
+
+      // normalize A and C
+      A = delta.segment(n, n_eq).asDiagonal() * A * delta.head(n).asDiagonal();
+      C = delta.tail(n_in).asDiagonal() * C * delta.head(n).asDiagonal();
+
+      // normalize H
+      switch (sym) {
+        case Symmetry::upper: {
+          // upper triangular part
+          for (isize j = 0; j < n; ++j) {
+            H.col(j).head(j + 1) *= delta(j);
+          }
+          // normalisation des lignes
+          for (isize i = 0; i < n; ++i) {
+            H.row(i).tail(n - i) *= delta(i);
+          }
+          break;
+        }
+        case Symmetry::lower: {
+          // lower triangular part
+          for (isize j = 0; j < n; ++j) {
+            H.col(j).tail(n - j) *= delta(j);
+          }
+          // normalisation des lignes
+          for (isize i = 0; i < n; ++i) {
+            H.row(i).head(i + 1) *= delta(i);
+          }
+          break;
+        }
+        case Symmetry::general: {
+          // all matrix
+          H = delta.head(n).asDiagonal() * H * delta.head(n).asDiagonal();
+          break;
+        }
+        default:
+          break;
+      }
+
+      // normalize vectors
+      g.array() *= delta.head(n).array();
+      b.array() *= delta.segment(n, n_eq).array();
+      l.array() *= delta.tail(n_in).array();
+      u.array() *= delta.tail(n_in).array();
+
+      g *= c;
+      H *= c;
+    }
+  }
+  /*!
+   * Scales the qp performing the ruiz equilibrator algorithm considering user
+   * options.
+   * @param qp qp model.
+   * @param scaled_qp qp to be scaled.
+   * @param tmp_delta_preallocated temporary variable used for performing the
+   * equilibration.
+   */
+  void scale_qp(const QpViewBox<T> qp,
+                QpViewBoxMut<T> scaled_qp,
+                VectorViewMut<T> tmp_delta_preallocated) const
+  {
+
+    /*
+     * scaled_qp is scaled, whereas first qp is not
+     * the procedure computes as well equilibration parameters using default
+     * parameters
+     */
+
+    scaled_qp.H.to_eigen() = qp.H.to_eigen();
+    scaled_qp.A.to_eigen() = qp.A.to_eigen();
+    scaled_qp.C.to_eigen() = qp.C.to_eigen();
+    scaled_qp.g.to_eigen() = qp.g.to_eigen();
+    scaled_qp.b.to_eigen() = qp.b.to_eigen();
+    scaled_qp.d.to_eigen() = qp.d.to_eigen();
+
+    scale_qp_in_place(scaled_qp, tmp_delta_preallocated, epsilon, max_iter);
+  }
+  // modifies variables in place
+  /*!
+   * Scales a primal variable in place.
+   * @param primal primal variable.
+   */
+  void scale_primal_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() /= delta.array().head(dim);
+  }
+  /*!
+   * Scales a dual variable in place.
+   * @param dual dual variable (includes all equalities and inequalities
+   * constraints).
+   */
+  void scale_dual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
+                              delta.tail(delta.size() - dim).array() * c;
+  }
+  /*!
+   * Scales a dual equality constrained variable in place.
+   * @param dual dual variable (includes equalities constraints only).
+   */
+  void scale_dual_in_place_eq(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() =
+      dual.as_const().to_eigen().array() /
+      delta.middleRows(dim, dual.to_eigen().size()).array() * c;
+  }
+  /*!
+   * Scales a dual inequality constrained variable in place.
+   * @param dual dual variable (includes inequalities constraints only).
+   */
+  void scale_dual_in_place_in(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
+                              delta.tail(dual.to_eigen().size()).array() * c;
+  }
+  /*!
+   * Unscales a primal variable in place.
+   * @param primal primal variable.
+   */
+  void unscale_primal_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() *= delta.array().head(dim);
+  }
+  /*!
+   * Unscales a dual variable in place.
+   * @param dual dual variable (includes equalities constraints only).
+   */
+  void unscale_dual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
+                              delta.tail(delta.size() - dim).array() / c;
+  }
+  /*!
+   * Unscales a dual equality constrained variable in place.
+   * @param dual dual variable (includes equalities constraints only).
+   */
+  void unscale_dual_in_place_eq(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() =
+      dual.as_const().to_eigen().array() *
+      delta.middleRows(dim, dual.to_eigen().size()).array() / c;
+  }
+  /*!
+   * Unscales a dual inequality constrained variable in place.
+   * @param dual dual variable (includes inequalities constraints only).
+   */
+  void unscale_dual_in_place_in(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
+                              delta.tail(dual.to_eigen().size()).array() / c;
+  }
+  // modifies residuals in place
+  /*!
+   * Scales a primal residual in place.
+   * @param primal primal residual (includes equality and inequality
+   * constraints)
+   */
+  void scale_primal_residual_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() *= delta.tail(delta.size() - dim).array();
+  }
+
+  /*!
+   * Scales a primal equality constraint residual in place.
+   * @param primal primal equality constraint residual.
+   */
+  void scale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
+  {
+    primal_eq.to_eigen().array() *=
+      delta.middleRows(dim, primal_eq.to_eigen().size()).array();
+  }
+  /*!
+   * Scales a primal inequality constraint residual in place.
+   * @param primal primal inequality constraint residual.
+   */
+  void scale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
+  {
+    primal_in.to_eigen().array() *=
+      delta.tail(primal_in.to_eigen().size()).array();
+  }
+  /*!
+   * Scales a dual residual in place.
+   * @param dual dual residual.
+   */
+  void scale_dual_residual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() *= delta.head(dim).array() * c;
+  }
+  /*!
+   * Unscales a primal residual in place.
+   * @param primal primal residual (includes equality and inequality
+   * constraints).
+   */
+  void unscale_primal_residual_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() /= delta.tail(delta.size() - dim).array();
+  }
+  /*!
+   * Unscales a primal equality constraint residual in place.
+   * @param primal primal equality constraint residual.
+   */
+  void unscale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
+  {
+    primal_eq.to_eigen().array() /=
+      delta.middleRows(dim, primal_eq.to_eigen().size()).array();
+  }
+  /*!
+   * Unscales a primal inequality constraint residual in place.
+   * @param primal primal inequality constraint residual.
+   */
+  void unscale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
+  {
+    primal_in.to_eigen().array() /=
+      delta.tail(primal_in.to_eigen().size()).array();
+  }
+  /*!
+   * Unscales a dual residual in place.
+   * @param dual dual residual.
+   */
+  void unscale_dual_residual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() /= delta.head(dim).array() * c;
+  }
+};
+
+} // namespace preconditioner
+} // namespace dense
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_DENSE_PRECOND_RUIZ_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/fwd.hpp

 * *Ordering differences only*

```diff
@@ -1,58 +1,58 @@
-//
-// Copyright (c) 2022-2023 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_SPARSE_FWD_HPP
-#define PROXSUITE_PROXQP_SPARSE_FWD_HPP
-
-#include <Eigen/Sparse>
-#include "proxsuite/linalg/veg/vec.hpp"
-#include "proxsuite/proxqp/dense/views.hpp"
-#include "proxsuite/helpers/common.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-using dense::infty_norm;
-using proxsuite::linalg::veg::i64;
-using proxsuite::linalg::veg::isize;
-using proxsuite::linalg::veg::usize;
-
-template<typename T>
-using DMat = Eigen::Matrix<T, -1, -1>;
-
-static constexpr auto DYN = Eigen::Dynamic;
-enum
-{
-  layout = Eigen::RowMajor
-};
-template<typename T, typename I>
-using SparseMat = Eigen::SparseMatrix<T, Eigen::ColMajor, I>;
-// using SparseMat = Eigen::SparseMatrix<T, Eigen::RowMajor, I>;
-template<typename T>
-using VecRef = Eigen::Ref<Eigen::Matrix<T, DYN, 1> const>;
-template<typename T>
-using MatRef = Eigen::Ref<Eigen::Matrix<T, DYN, DYN> const>;
-template<typename T>
-using Vec = Eigen::Matrix<T, DYN, 1>;
-
-template<typename T, typename I>
-using Mat = Eigen::SparseMatrix<T, Eigen::ColMajor, I>;
-// using Mat = Eigen::SparseMatrix<T, Eigen::RowMajor, I>;
-using VecBool = Eigen::Matrix<bool, DYN, 1>;
-
-///
-/// @brief This class defines the workspace of the sparse solver.
-///
-/*!
- * Workspace class of the sparse solver.
- */
-template<typename T, typename I>
-struct Workspace;
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_FWD_HPP */
+//
+// Copyright (c) 2022-2023 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_SPARSE_FWD_HPP
+#define PROXSUITE_PROXQP_SPARSE_FWD_HPP
+
+#include <Eigen/Sparse>
+#include "proxsuite/linalg/veg/vec.hpp"
+#include "proxsuite/proxqp/dense/views.hpp"
+#include "proxsuite/helpers/common.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+using dense::infty_norm;
+using proxsuite::linalg::veg::i64;
+using proxsuite::linalg::veg::isize;
+using proxsuite::linalg::veg::usize;
+
+template<typename T>
+using DMat = Eigen::Matrix<T, -1, -1>;
+
+static constexpr auto DYN = Eigen::Dynamic;
+enum
+{
+  layout = Eigen::RowMajor
+};
+template<typename T, typename I>
+using SparseMat = Eigen::SparseMatrix<T, Eigen::ColMajor, I>;
+// using SparseMat = Eigen::SparseMatrix<T, Eigen::RowMajor, I>;
+template<typename T>
+using VecRef = Eigen::Ref<Eigen::Matrix<T, DYN, 1> const>;
+template<typename T>
+using MatRef = Eigen::Ref<Eigen::Matrix<T, DYN, DYN> const>;
+template<typename T>
+using Vec = Eigen::Matrix<T, DYN, 1>;
+
+template<typename T, typename I>
+using Mat = Eigen::SparseMatrix<T, Eigen::ColMajor, I>;
+// using Mat = Eigen::SparseMatrix<T, Eigen::RowMajor, I>;
+using VecBool = Eigen::Matrix<bool, DYN, 1>;
+
+///
+/// @brief This class defines the workspace of the sparse solver.
+///
+/*!
+ * Workspace class of the sparse solver.
+ */
+template<typename T, typename I>
+struct Workspace;
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_FWD_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/helpers.hpp

 * *Ordering differences only*

```diff
@@ -1,309 +1,309 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_SPARSE_HELPERS_HPP
-#define PROXSUITE_PROXQP_SPARSE_HELPERS_HPP
-
-#include <Eigen/Sparse>
-#include <proxsuite/helpers/optional.hpp>
-
-#include <proxsuite/linalg/veg/vec.hpp>
-#include <proxsuite/proxqp/sparse/fwd.hpp>
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-/*!
- * Update the proximal parameters of the results object.
- *
- * @param rho_new primal proximal parameter
- * @param mu_eq_new dual equality proximal parameter
- * @param mu_in_new dual inequality proximal parameter
- * @param results solver result
- */
-template<typename T, typename I>
-void
-update_proximal_parameters(Settings<T>& settings,
-                           Results<T>& results,
-                           Workspace<T, I>& work,
-                           optional<T> rho_new,
-                           optional<T> mu_eq_new,
-                           optional<T> mu_in_new)
-{
-  if (rho_new != nullopt) {
-    settings.default_rho = rho_new.value();
-    results.info.rho = rho_new.value();
-    work.internal.proximal_parameter_update = true;
-  }
-  if (mu_eq_new != nullopt) {
-    settings.default_mu_eq = mu_eq_new.value();
-    results.info.mu_eq = mu_eq_new.value();
-    results.info.mu_eq_inv = T(1) / results.info.mu_eq;
-    work.internal.proximal_parameter_update = true;
-  }
-  if (mu_in_new != nullopt) {
-    settings.default_mu_in = mu_in_new.value();
-    results.info.mu_in = mu_in_new.value();
-    results.info.mu_in_inv = T(1) / results.info.mu_in;
-    work.internal.proximal_parameter_update = true;
-  }
-}
-/*!
- * Warm start the results primal and dual variables.
- *
- * @param x_wm primal proximal parameter
- * @param y_wm dual equality proximal parameter
- * @param z_wm dual inequality proximal parameter
- * @param results solver result
- * @param settings solver settings
- */
-template<typename T, typename I>
-void
-warm_start(optional<VecRef<T>> x_wm,
-           optional<VecRef<T>> y_wm,
-           optional<VecRef<T>> z_wm,
-           Results<T>& results,
-           Settings<T>& settings,
-           Model<T, I>& model)
-{
-  if (x_wm == nullopt && y_wm == nullopt && z_wm == nullopt)
-    return;
-
-  settings.initial_guess = InitialGuessStatus::WARM_START;
-
-  // first check problem dimensions
-  if (x_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      x_wm.value().rows(),
-      model.dim,
-      "the dimension wrt primal variable x for warm start is not valid.");
-  }
-
-  if (y_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(y_wm.value().rows(),
-                                  model.n_eq,
-                                  "the dimension wrt equality constrained "
-                                  "variables for warm start is not valid.");
-  }
-
-  if (z_wm != nullopt) {
-    PROXSUITE_CHECK_ARGUMENT_SIZE(
-      z_wm.value().rows(),
-      model.n_in,
-      "the dimension wrt inequality constrained variables for warm start "
-      "is not valid.");
-  }
-
-  if (x_wm != nullopt) {
-    results.x = x_wm.value().eval();
-  }
-
-  if (y_wm != nullopt) {
-    results.y = y_wm.value().eval();
-  }
-
-  if (z_wm != nullopt) {
-    results.z = z_wm.value().eval();
-  }
-}
-
-/*!
- * Setups the QP solver model.
- *
- * @param qp view of the QP model.
- * @param work solver workspace.
- * @param settings solver settings.
- * @param data solver model.
- * @param results solver result.
- * @param precond preconditioner.
- * @param preconditioner_status bool variable for deciding whether executing the
- * preconditioning algorithm, or keeping previous preconditioning variables, or
- * using the identity preconditioner (i.e., no preconditioner).
- */
-template<typename T, typename I, typename P>
-void
-qp_setup(QpView<T, I> qp,
-         Results<T>& results,
-         Model<T, I>& data,
-         Workspace<T, I>& work,
-         Settings<T>& settings,
-         P& precond,
-         PreconditionerStatus& preconditioner_status)
-{
-  isize n = qp.H.nrows();
-  isize n_eq = qp.AT.ncols();
-  isize n_in = qp.CT.ncols();
-
-  if (results.x.rows() != n) {
-    results.x.resize(n);
-    results.x.setZero();
-  }
-  if (results.y.rows() != n_eq) {
-    results.y.resize(n_eq);
-    results.y.setZero();
-  }
-  if (results.z.rows() != n_in) {
-    results.z.resize(n_in);
-    results.z.setZero();
-  }
-  if (work.active_inequalities.len() != n_in) {
-    work.active_inequalities.resize(n_in);
-    for (isize i = 0; i < n_in; ++i) {
-      work.active_inequalities[i] = false;
-    }
-  }
-  if (work.active_set_up.rows() != n_in) {
-    work.active_set_up.resize(n_in);
-    for (isize i = 0; i < n_in; ++i) {
-      work.active_set_up[i] = false;
-    }
-  }
-  if (work.active_set_low.rows() != n_in) {
-    work.active_set_low.resize(n_in);
-    for (isize i = 0; i < n_in; ++i) {
-      work.active_set_low[i] = false;
-    }
-  }
-  bool execute_preconditioner_or_not = false;
-  switch (preconditioner_status) {
-    case PreconditionerStatus::EXECUTE:
-      execute_preconditioner_or_not = true;
-      break;
-    case PreconditionerStatus::IDENTITY:
-      execute_preconditioner_or_not = false;
-      break;
-    case PreconditionerStatus::KEEP:
-      // keep previous one
-      execute_preconditioner_or_not = false;
-      break;
-  }
-  // performs scaling according to options chosen + stored model value
-  work.setup_impl(
-    qp,
-    data,
-    settings,
-    execute_preconditioner_or_not,
-    precond,
-    P::scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T>{}, n, n_eq, n_in));
-  switch (settings.initial_guess) { // the following is used when initiliazing
-                                    // the Qp object or updating it
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-
-      if (work.internal.proximal_parameter_update) {
-        results.cleanup_all_except_prox_parameters();
-      } else {
-        results.cleanup(settings);
-      }
-      break;
-    }
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-      // keep solutions but restart workspace and results
-
-      if (work.internal.proximal_parameter_update) {
-        results.cleanup_statistics();
-      } else {
-        results.cold_start(settings);
-      }
-      break;
-    }
-    case InitialGuessStatus::NO_INITIAL_GUESS: {
-
-      if (work.internal.proximal_parameter_update) {
-        results.cleanup_all_except_prox_parameters();
-      } else {
-        results.cleanup(settings);
-      }
-      break;
-    }
-    case InitialGuessStatus::WARM_START: {
-
-      if (work.internal.proximal_parameter_update) {
-        results.cleanup_all_except_prox_parameters();
-      } else {
-        results.cleanup(settings);
-      }
-      break;
-    }
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-      // keep workspace and results solutions except statistics
-
-      results.cleanup_statistics(); // always keep prox parameters (changed or
-                                    // previous ones)
-      break;
-    }
-  }
-  // if user chose Automatic as sparse backend, store in results which backend
-  // of SparseCholesky or MatrixFree had been used
-  if (settings.sparse_backend == SparseBackend::Automatic) {
-    if (work.internal.do_ldlt) {
-      results.info.sparse_backend = SparseBackend::SparseCholesky;
-    } else {
-      results.info.sparse_backend = SparseBackend::MatrixFree;
-    }
-  }
-  // if user selected a specfic sparse backend, store it in results
-  else {
-    results.info.sparse_backend = settings.sparse_backend;
-  }
-}
-/*!
- * Checks whether matrix b has the same sparsity structure as matrix a.
- *
- * @param a matrix.
- * @param b matrix.
- */
-template<typename T, typename I>
-auto
-have_same_structure(proxsuite::linalg::sparse::MatRef<T, I> a,
-                    proxsuite::linalg::sparse::MatRef<T, I> b) -> bool
-{
-  if (a.nrows() != b.nrows())
-    return false;
-  if (a.ncols() != b.ncols())
-    return false;
-  for (usize j = 0; j < static_cast<usize>(a.ncols()); ++j) {
-    usize n_elems(a.col_end(j) - a.col_start(j));
-    usize n_elems_to_compare(b.col_end(j) - b.col_start(j));
-    if (n_elems != n_elems_to_compare)
-      return false;
-    for (usize p = 0; p < n_elems; ++p) {
-      isize i_a = a.row_indices()[a.col_start(j) + p];
-      isize i_b = b.row_indices()[b.col_start(j) + p];
-      if (i_a != i_b)
-        return false;
-    }
-  }
-  return true;
-}
-/*!
- * Copies matrix b elements into matrix a.
- *
- * @param a matrix.
- * @param b matrix.
- */
-template<typename T, typename I>
-void
-copy(proxsuite::linalg::sparse::MatMut<T, I> a,
-     proxsuite::linalg::sparse::MatRef<T, I> b)
-{
-  // assume same sparsity structure for a and b
-  // copy b into a
-  for (usize j = 0; j < static_cast<usize>(a.ncols()); ++j) {
-    auto a_start = a.values_mut() + a.col_start(j);
-    auto b_start = b.values() + b.col_start(j);
-
-    usize n_elems = static_cast<usize>(a.col_end(j) - a.col_start(j));
-
-    for (usize p = 0; p < n_elems; ++p) {
-      a_start[p] = b_start[p];
-    }
-  }
-}
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_HELPERS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_SPARSE_HELPERS_HPP
+#define PROXSUITE_PROXQP_SPARSE_HELPERS_HPP
+
+#include <Eigen/Sparse>
+#include <proxsuite/helpers/optional.hpp>
+
+#include <proxsuite/linalg/veg/vec.hpp>
+#include <proxsuite/proxqp/sparse/fwd.hpp>
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+/*!
+ * Update the proximal parameters of the results object.
+ *
+ * @param rho_new primal proximal parameter
+ * @param mu_eq_new dual equality proximal parameter
+ * @param mu_in_new dual inequality proximal parameter
+ * @param results solver result
+ */
+template<typename T, typename I>
+void
+update_proximal_parameters(Settings<T>& settings,
+                           Results<T>& results,
+                           Workspace<T, I>& work,
+                           optional<T> rho_new,
+                           optional<T> mu_eq_new,
+                           optional<T> mu_in_new)
+{
+  if (rho_new != nullopt) {
+    settings.default_rho = rho_new.value();
+    results.info.rho = rho_new.value();
+    work.internal.proximal_parameter_update = true;
+  }
+  if (mu_eq_new != nullopt) {
+    settings.default_mu_eq = mu_eq_new.value();
+    results.info.mu_eq = mu_eq_new.value();
+    results.info.mu_eq_inv = T(1) / results.info.mu_eq;
+    work.internal.proximal_parameter_update = true;
+  }
+  if (mu_in_new != nullopt) {
+    settings.default_mu_in = mu_in_new.value();
+    results.info.mu_in = mu_in_new.value();
+    results.info.mu_in_inv = T(1) / results.info.mu_in;
+    work.internal.proximal_parameter_update = true;
+  }
+}
+/*!
+ * Warm start the results primal and dual variables.
+ *
+ * @param x_wm primal proximal parameter
+ * @param y_wm dual equality proximal parameter
+ * @param z_wm dual inequality proximal parameter
+ * @param results solver result
+ * @param settings solver settings
+ */
+template<typename T, typename I>
+void
+warm_start(optional<VecRef<T>> x_wm,
+           optional<VecRef<T>> y_wm,
+           optional<VecRef<T>> z_wm,
+           Results<T>& results,
+           Settings<T>& settings,
+           Model<T, I>& model)
+{
+  if (x_wm == nullopt && y_wm == nullopt && z_wm == nullopt)
+    return;
+
+  settings.initial_guess = InitialGuessStatus::WARM_START;
+
+  // first check problem dimensions
+  if (x_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      x_wm.value().rows(),
+      model.dim,
+      "the dimension wrt primal variable x for warm start is not valid.");
+  }
+
+  if (y_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(y_wm.value().rows(),
+                                  model.n_eq,
+                                  "the dimension wrt equality constrained "
+                                  "variables for warm start is not valid.");
+  }
+
+  if (z_wm != nullopt) {
+    PROXSUITE_CHECK_ARGUMENT_SIZE(
+      z_wm.value().rows(),
+      model.n_in,
+      "the dimension wrt inequality constrained variables for warm start "
+      "is not valid.");
+  }
+
+  if (x_wm != nullopt) {
+    results.x = x_wm.value().eval();
+  }
+
+  if (y_wm != nullopt) {
+    results.y = y_wm.value().eval();
+  }
+
+  if (z_wm != nullopt) {
+    results.z = z_wm.value().eval();
+  }
+}
+
+/*!
+ * Setups the QP solver model.
+ *
+ * @param qp view of the QP model.
+ * @param work solver workspace.
+ * @param settings solver settings.
+ * @param data solver model.
+ * @param results solver result.
+ * @param precond preconditioner.
+ * @param preconditioner_status bool variable for deciding whether executing the
+ * preconditioning algorithm, or keeping previous preconditioning variables, or
+ * using the identity preconditioner (i.e., no preconditioner).
+ */
+template<typename T, typename I, typename P>
+void
+qp_setup(QpView<T, I> qp,
+         Results<T>& results,
+         Model<T, I>& data,
+         Workspace<T, I>& work,
+         Settings<T>& settings,
+         P& precond,
+         PreconditionerStatus& preconditioner_status)
+{
+  isize n = qp.H.nrows();
+  isize n_eq = qp.AT.ncols();
+  isize n_in = qp.CT.ncols();
+
+  if (results.x.rows() != n) {
+    results.x.resize(n);
+    results.x.setZero();
+  }
+  if (results.y.rows() != n_eq) {
+    results.y.resize(n_eq);
+    results.y.setZero();
+  }
+  if (results.z.rows() != n_in) {
+    results.z.resize(n_in);
+    results.z.setZero();
+  }
+  if (work.active_inequalities.len() != n_in) {
+    work.active_inequalities.resize(n_in);
+    for (isize i = 0; i < n_in; ++i) {
+      work.active_inequalities[i] = false;
+    }
+  }
+  if (work.active_set_up.rows() != n_in) {
+    work.active_set_up.resize(n_in);
+    for (isize i = 0; i < n_in; ++i) {
+      work.active_set_up[i] = false;
+    }
+  }
+  if (work.active_set_low.rows() != n_in) {
+    work.active_set_low.resize(n_in);
+    for (isize i = 0; i < n_in; ++i) {
+      work.active_set_low[i] = false;
+    }
+  }
+  bool execute_preconditioner_or_not = false;
+  switch (preconditioner_status) {
+    case PreconditionerStatus::EXECUTE:
+      execute_preconditioner_or_not = true;
+      break;
+    case PreconditionerStatus::IDENTITY:
+      execute_preconditioner_or_not = false;
+      break;
+    case PreconditionerStatus::KEEP:
+      // keep previous one
+      execute_preconditioner_or_not = false;
+      break;
+  }
+  // performs scaling according to options chosen + stored model value
+  work.setup_impl(
+    qp,
+    data,
+    settings,
+    execute_preconditioner_or_not,
+    precond,
+    P::scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T>{}, n, n_eq, n_in));
+  switch (settings.initial_guess) { // the following is used when initiliazing
+                                    // the Qp object or updating it
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+
+      if (work.internal.proximal_parameter_update) {
+        results.cleanup_all_except_prox_parameters();
+      } else {
+        results.cleanup(settings);
+      }
+      break;
+    }
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+      // keep solutions but restart workspace and results
+
+      if (work.internal.proximal_parameter_update) {
+        results.cleanup_statistics();
+      } else {
+        results.cold_start(settings);
+      }
+      break;
+    }
+    case InitialGuessStatus::NO_INITIAL_GUESS: {
+
+      if (work.internal.proximal_parameter_update) {
+        results.cleanup_all_except_prox_parameters();
+      } else {
+        results.cleanup(settings);
+      }
+      break;
+    }
+    case InitialGuessStatus::WARM_START: {
+
+      if (work.internal.proximal_parameter_update) {
+        results.cleanup_all_except_prox_parameters();
+      } else {
+        results.cleanup(settings);
+      }
+      break;
+    }
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+      // keep workspace and results solutions except statistics
+
+      results.cleanup_statistics(); // always keep prox parameters (changed or
+                                    // previous ones)
+      break;
+    }
+  }
+  // if user chose Automatic as sparse backend, store in results which backend
+  // of SparseCholesky or MatrixFree had been used
+  if (settings.sparse_backend == SparseBackend::Automatic) {
+    if (work.internal.do_ldlt) {
+      results.info.sparse_backend = SparseBackend::SparseCholesky;
+    } else {
+      results.info.sparse_backend = SparseBackend::MatrixFree;
+    }
+  }
+  // if user selected a specfic sparse backend, store it in results
+  else {
+    results.info.sparse_backend = settings.sparse_backend;
+  }
+}
+/*!
+ * Checks whether matrix b has the same sparsity structure as matrix a.
+ *
+ * @param a matrix.
+ * @param b matrix.
+ */
+template<typename T, typename I>
+auto
+have_same_structure(proxsuite::linalg::sparse::MatRef<T, I> a,
+                    proxsuite::linalg::sparse::MatRef<T, I> b) -> bool
+{
+  if (a.nrows() != b.nrows())
+    return false;
+  if (a.ncols() != b.ncols())
+    return false;
+  for (usize j = 0; j < static_cast<usize>(a.ncols()); ++j) {
+    usize n_elems(a.col_end(j) - a.col_start(j));
+    usize n_elems_to_compare(b.col_end(j) - b.col_start(j));
+    if (n_elems != n_elems_to_compare)
+      return false;
+    for (usize p = 0; p < n_elems; ++p) {
+      isize i_a = a.row_indices()[a.col_start(j) + p];
+      isize i_b = b.row_indices()[b.col_start(j) + p];
+      if (i_a != i_b)
+        return false;
+    }
+  }
+  return true;
+}
+/*!
+ * Copies matrix b elements into matrix a.
+ *
+ * @param a matrix.
+ * @param b matrix.
+ */
+template<typename T, typename I>
+void
+copy(proxsuite::linalg::sparse::MatMut<T, I> a,
+     proxsuite::linalg::sparse::MatRef<T, I> b)
+{
+  // assume same sparsity structure for a and b
+  // copy b into a
+  for (usize j = 0; j < static_cast<usize>(a.ncols()); ++j) {
+    auto a_start = a.values_mut() + a.col_start(j);
+    auto b_start = b.values() + b.col_start(j);
+
+    usize n_elems = static_cast<usize>(a.col_end(j) - a.col_start(j));
+
+    for (usize p = 0; p < n_elems; ++p) {
+      a_start[p] = b_start[p];
+    }
+  }
+}
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_HELPERS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/model.hpp

 * *Ordering differences only*

```diff
@@ -1,228 +1,228 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_SPARSE_MODEL_HPP
-#define PROXSUITE_PROXQP_SPARSE_MODEL_HPP
-
-#include <Eigen/Sparse>
-#include "proxsuite/linalg/sparse/core.hpp"
-#include "proxsuite/proxqp/sparse/fwd.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-///
-/// @brief This class stores the model of the QP problem.
-///
-/*!
- * Model class of the sparse solver storing the QP problem structure.
- */
-template<typename T, typename I>
-struct Model
-{
-  typedef T Scalar;
-  using VectorType = Eigen::Matrix<T, Eigen::Dynamic, 1>;
-
-  isize dim;
-  isize n_eq;
-  isize n_in;
-
-  isize H_nnz;
-  isize A_nnz;
-  isize C_nnz;
-
-  proxsuite::linalg::veg::Vec<I> kkt_col_ptrs;
-  proxsuite::linalg::veg::Vec<I> kkt_row_indices;
-  proxsuite::linalg::veg::Vec<T> kkt_values;
-
-  proxsuite::linalg::veg::Vec<I> kkt_col_ptrs_unscaled;
-  proxsuite::linalg::veg::Vec<I> kkt_row_indices_unscaled;
-  proxsuite::linalg::veg::Vec<T> kkt_values_unscaled;
-
-  VectorType g;
-  VectorType b;
-  VectorType l;
-  VectorType u;
-
-  /*!
-   * Default constructor.
-   * @param dim primal variable dimension.
-   * @param n_eq number of equality constraints.
-   * @param n_in number of inequality constraints.
-   */
-  Model(isize dim, isize n_eq, isize n_in)
-    : dim(dim)
-    , n_eq(n_eq)
-    , n_in(n_in)
-  {
-    PROXSUITE_THROW_PRETTY(dim == 0,
-                           std::invalid_argument,
-                           "wrong argument size: the dimension wrt primal "
-                           "variable x should be strictly positive.");
-
-    const T infinite_bound_value = helpers::infinite_bound<T>::value();
-
-    g.setZero();
-    b.setZero();
-    u.setZero();
-    u.fill(+infinite_bound_value); // in case it appears u is nullopt (i.e., the
-                                   // problem is only lower bounded)
-    l.fill(-infinite_bound_value); // in case it appears l is nullopt (i.e., the
-                                   // problem is only upper bounded)
-  }
-  /*!
-   * Returns the current (scaled) KKT matrix of the problem.
-   */
-  auto kkt() const -> proxsuite::linalg::sparse::MatRef<T, I>
-  {
-    auto n_tot = kkt_col_ptrs.len() - 1;
-    auto nnz =
-      isize(proxsuite::linalg::sparse::util::zero_extend(kkt_col_ptrs[n_tot]));
-    return {
-      proxsuite::linalg::sparse::from_raw_parts,
-      n_tot,
-      n_tot,
-      nnz,
-      kkt_col_ptrs.ptr(),
-      nullptr,
-      kkt_row_indices.ptr(),
-      kkt_values.ptr(),
-    };
-  }
-  /*!
-   * Returns the current (scaled) KKT matrix of the problem (mutable form).
-   */
-  auto kkt_mut() -> proxsuite::linalg::sparse::MatMut<T, I>
-  {
-    auto n_tot = kkt_col_ptrs.len() - 1;
-    auto nnz =
-      isize(proxsuite::linalg::sparse::util::zero_extend(kkt_col_ptrs[n_tot]));
-    return {
-      proxsuite::linalg::sparse::from_raw_parts,
-      n_tot,
-      n_tot,
-      nnz,
-      kkt_col_ptrs.ptr_mut(),
-      nullptr,
-      kkt_row_indices.ptr_mut(),
-      kkt_values.ptr_mut(),
-    };
-  }
-  /*!
-   * Returns the original (unscaled) KKT matrix of the problem.
-   */
-  auto kkt_unscaled() const -> proxsuite::linalg::sparse::MatRef<T, I>
-  {
-    auto n_tot = kkt_col_ptrs_unscaled.len() - 1;
-    auto nnz = isize(proxsuite::linalg::sparse::util::zero_extend(
-      kkt_col_ptrs_unscaled[n_tot]));
-    return {
-      proxsuite::linalg::sparse::from_raw_parts,
-      n_tot,
-      n_tot,
-      nnz,
-      kkt_col_ptrs_unscaled.ptr(),
-      nullptr,
-      kkt_row_indices_unscaled.ptr(),
-      kkt_values_unscaled.ptr(),
-    };
-  }
-  /*!
-   * Returns the original (unscaled) KKT matrix of the problem (mutable form).
-   */
-  auto kkt_mut_unscaled() -> proxsuite::linalg::sparse::MatMut<T, I>
-  {
-    auto n_tot = kkt_col_ptrs_unscaled.len() - 1;
-    auto nnz = isize(proxsuite::linalg::sparse::util::zero_extend(
-      kkt_col_ptrs_unscaled[n_tot]));
-    return {
-      proxsuite::linalg::sparse::from_raw_parts,
-      n_tot,
-      n_tot,
-      nnz,
-      kkt_col_ptrs_unscaled.ptr_mut(),
-      nullptr,
-      kkt_row_indices_unscaled.ptr_mut(),
-      kkt_values_unscaled.ptr_mut(),
-    };
-  }
-};
-
-template<typename _Scalar>
-struct SparseModel
-{
-  typedef _Scalar Scalar;
-  enum
-  {
-    layout = Eigen::RowMajor
-  };
-
-  using VectorType = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;
-
-  Eigen::SparseMatrix<Scalar, 1> H;
-  VectorType g;
-  Eigen::SparseMatrix<Scalar, 1> A;
-  VectorType b;
-  Eigen::SparseMatrix<Scalar, 1> C;
-  VectorType u;
-  VectorType l;
-
-  template<typename Vector_g,
-           typename Vector_b,
-           typename Vector_u,
-           typename Vector_l>
-  SparseModel(const Eigen::SparseMatrix<Scalar, 1>& H,
-              const Eigen::MatrixBase<Vector_g>& g,
-              const Eigen::SparseMatrix<Scalar, 1>& A,
-              const Eigen::MatrixBase<Vector_b>& b,
-              const Eigen::SparseMatrix<Scalar, 1>& C,
-              const Eigen::MatrixBase<Vector_u>& u,
-              const Eigen::MatrixBase<Vector_l>& l) noexcept
-    : H(H)
-    , g(g)
-    , A(A)
-    , b(b)
-    , C(C)
-    , u(u)
-    , l(l)
-  {
-  }
-
-  auto as_view() -> proxqp::dense::QpView<Scalar>
-  {
-    return {
-      { proxqp::from_eigen, H },
-      { proxqp::from_eigen, g },
-      { proxqp::from_eigen, A },
-      { proxqp::from_eigen, b },
-      { proxqp::from_ptr_rows_cols_stride,
-        nullptr,
-        0,
-        proxqp::isize(H.rows()),
-        0 },
-      { proxqp::from_ptr_size, nullptr, 0 },
-    };
-  }
-  auto as_mut() -> proxqp::dense::QpViewMut<Scalar>
-  {
-    return {
-      { proxqp::from_eigen, H },
-      { proxqp::from_eigen, g },
-      { proxqp::from_eigen, A },
-      { proxqp::from_eigen, b },
-      { proxqp::from_ptr_rows_cols_stride,
-        nullptr,
-        0,
-        proxqp::isize(H.rows()),
-        0 },
-      { proxqp::from_ptr_size, nullptr, 0 },
-    };
-  }
-};
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_MODEL_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_SPARSE_MODEL_HPP
+#define PROXSUITE_PROXQP_SPARSE_MODEL_HPP
+
+#include <Eigen/Sparse>
+#include "proxsuite/linalg/sparse/core.hpp"
+#include "proxsuite/proxqp/sparse/fwd.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+///
+/// @brief This class stores the model of the QP problem.
+///
+/*!
+ * Model class of the sparse solver storing the QP problem structure.
+ */
+template<typename T, typename I>
+struct Model
+{
+  typedef T Scalar;
+  using VectorType = Eigen::Matrix<T, Eigen::Dynamic, 1>;
+
+  isize dim;
+  isize n_eq;
+  isize n_in;
+
+  isize H_nnz;
+  isize A_nnz;
+  isize C_nnz;
+
+  proxsuite::linalg::veg::Vec<I> kkt_col_ptrs;
+  proxsuite::linalg::veg::Vec<I> kkt_row_indices;
+  proxsuite::linalg::veg::Vec<T> kkt_values;
+
+  proxsuite::linalg::veg::Vec<I> kkt_col_ptrs_unscaled;
+  proxsuite::linalg::veg::Vec<I> kkt_row_indices_unscaled;
+  proxsuite::linalg::veg::Vec<T> kkt_values_unscaled;
+
+  VectorType g;
+  VectorType b;
+  VectorType l;
+  VectorType u;
+
+  /*!
+   * Default constructor.
+   * @param dim primal variable dimension.
+   * @param n_eq number of equality constraints.
+   * @param n_in number of inequality constraints.
+   */
+  Model(isize dim, isize n_eq, isize n_in)
+    : dim(dim)
+    , n_eq(n_eq)
+    , n_in(n_in)
+  {
+    PROXSUITE_THROW_PRETTY(dim == 0,
+                           std::invalid_argument,
+                           "wrong argument size: the dimension wrt primal "
+                           "variable x should be strictly positive.");
+
+    const T infinite_bound_value = helpers::infinite_bound<T>::value();
+
+    g.setZero();
+    b.setZero();
+    u.setZero();
+    u.fill(+infinite_bound_value); // in case it appears u is nullopt (i.e., the
+                                   // problem is only lower bounded)
+    l.fill(-infinite_bound_value); // in case it appears l is nullopt (i.e., the
+                                   // problem is only upper bounded)
+  }
+  /*!
+   * Returns the current (scaled) KKT matrix of the problem.
+   */
+  auto kkt() const -> proxsuite::linalg::sparse::MatRef<T, I>
+  {
+    auto n_tot = kkt_col_ptrs.len() - 1;
+    auto nnz =
+      isize(proxsuite::linalg::sparse::util::zero_extend(kkt_col_ptrs[n_tot]));
+    return {
+      proxsuite::linalg::sparse::from_raw_parts,
+      n_tot,
+      n_tot,
+      nnz,
+      kkt_col_ptrs.ptr(),
+      nullptr,
+      kkt_row_indices.ptr(),
+      kkt_values.ptr(),
+    };
+  }
+  /*!
+   * Returns the current (scaled) KKT matrix of the problem (mutable form).
+   */
+  auto kkt_mut() -> proxsuite::linalg::sparse::MatMut<T, I>
+  {
+    auto n_tot = kkt_col_ptrs.len() - 1;
+    auto nnz =
+      isize(proxsuite::linalg::sparse::util::zero_extend(kkt_col_ptrs[n_tot]));
+    return {
+      proxsuite::linalg::sparse::from_raw_parts,
+      n_tot,
+      n_tot,
+      nnz,
+      kkt_col_ptrs.ptr_mut(),
+      nullptr,
+      kkt_row_indices.ptr_mut(),
+      kkt_values.ptr_mut(),
+    };
+  }
+  /*!
+   * Returns the original (unscaled) KKT matrix of the problem.
+   */
+  auto kkt_unscaled() const -> proxsuite::linalg::sparse::MatRef<T, I>
+  {
+    auto n_tot = kkt_col_ptrs_unscaled.len() - 1;
+    auto nnz = isize(proxsuite::linalg::sparse::util::zero_extend(
+      kkt_col_ptrs_unscaled[n_tot]));
+    return {
+      proxsuite::linalg::sparse::from_raw_parts,
+      n_tot,
+      n_tot,
+      nnz,
+      kkt_col_ptrs_unscaled.ptr(),
+      nullptr,
+      kkt_row_indices_unscaled.ptr(),
+      kkt_values_unscaled.ptr(),
+    };
+  }
+  /*!
+   * Returns the original (unscaled) KKT matrix of the problem (mutable form).
+   */
+  auto kkt_mut_unscaled() -> proxsuite::linalg::sparse::MatMut<T, I>
+  {
+    auto n_tot = kkt_col_ptrs_unscaled.len() - 1;
+    auto nnz = isize(proxsuite::linalg::sparse::util::zero_extend(
+      kkt_col_ptrs_unscaled[n_tot]));
+    return {
+      proxsuite::linalg::sparse::from_raw_parts,
+      n_tot,
+      n_tot,
+      nnz,
+      kkt_col_ptrs_unscaled.ptr_mut(),
+      nullptr,
+      kkt_row_indices_unscaled.ptr_mut(),
+      kkt_values_unscaled.ptr_mut(),
+    };
+  }
+};
+
+template<typename _Scalar>
+struct SparseModel
+{
+  typedef _Scalar Scalar;
+  enum
+  {
+    layout = Eigen::RowMajor
+  };
+
+  using VectorType = Eigen::Matrix<Scalar, Eigen::Dynamic, 1>;
+
+  Eigen::SparseMatrix<Scalar, 1> H;
+  VectorType g;
+  Eigen::SparseMatrix<Scalar, 1> A;
+  VectorType b;
+  Eigen::SparseMatrix<Scalar, 1> C;
+  VectorType u;
+  VectorType l;
+
+  template<typename Vector_g,
+           typename Vector_b,
+           typename Vector_u,
+           typename Vector_l>
+  SparseModel(const Eigen::SparseMatrix<Scalar, 1>& H,
+              const Eigen::MatrixBase<Vector_g>& g,
+              const Eigen::SparseMatrix<Scalar, 1>& A,
+              const Eigen::MatrixBase<Vector_b>& b,
+              const Eigen::SparseMatrix<Scalar, 1>& C,
+              const Eigen::MatrixBase<Vector_u>& u,
+              const Eigen::MatrixBase<Vector_l>& l) noexcept
+    : H(H)
+    , g(g)
+    , A(A)
+    , b(b)
+    , C(C)
+    , u(u)
+    , l(l)
+  {
+  }
+
+  auto as_view() -> proxqp::dense::QpView<Scalar>
+  {
+    return {
+      { proxqp::from_eigen, H },
+      { proxqp::from_eigen, g },
+      { proxqp::from_eigen, A },
+      { proxqp::from_eigen, b },
+      { proxqp::from_ptr_rows_cols_stride,
+        nullptr,
+        0,
+        proxqp::isize(H.rows()),
+        0 },
+      { proxqp::from_ptr_size, nullptr, 0 },
+    };
+  }
+  auto as_mut() -> proxqp::dense::QpViewMut<Scalar>
+  {
+    return {
+      { proxqp::from_eigen, H },
+      { proxqp::from_eigen, g },
+      { proxqp::from_eigen, A },
+      { proxqp::from_eigen, b },
+      { proxqp::from_ptr_rows_cols_stride,
+        nullptr,
+        0,
+        proxqp::isize(H.rows()),
+        0 },
+      { proxqp::from_ptr_size, nullptr, 0 },
+    };
+  }
+};
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_MODEL_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/solver.hpp

 * *Ordering differences only*

```diff
@@ -1,1441 +1,1441 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_SOLVER_HPP
-#define PROXSUITE_PROXQP_SPARSE_SOLVER_HPP
-
-#include <chrono>
-#include <cmath>
-
-#include <proxsuite/linalg/dense/core.hpp>
-#include <proxsuite/linalg/sparse/core.hpp>
-#include <proxsuite/linalg/sparse/factorize.hpp>
-#include <proxsuite/linalg/sparse/update.hpp>
-#include <proxsuite/linalg/sparse/rowmod.hpp>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-#include "proxsuite/proxqp/results.hpp"
-#include "proxsuite/proxqp/sparse/fwd.hpp"
-#include "proxsuite/proxqp/sparse/views.hpp"
-#include "proxsuite/proxqp/sparse/model.hpp"
-#include "proxsuite/proxqp/sparse/workspace.hpp"
-#include "proxsuite/proxqp/sparse/utils.hpp"
-#include "proxsuite/proxqp/sparse/preconditioner/ruiz.hpp"
-#include "proxsuite/proxqp/sparse/preconditioner/identity.hpp"
-
-#include <iostream>
-#include <iomanip>
-#include <Eigen/IterativeLinearSolvers>
-#include <unsupported/Eigen/IterativeSolvers>
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-template<typename T, typename I>
-void
-ldl_solve(VectorViewMut<T> sol,
-          VectorView<T> rhs,
-          isize n_tot,
-          proxsuite::linalg::sparse::MatMut<T, I> ldl,
-          Eigen::MINRES<detail::AugmentedKkt<T, I>,
-                        Eigen::Upper | Eigen::Lower,
-                        Eigen::IdentityPreconditioner>& iterative_solver,
-          bool do_ldlt,
-          proxsuite::linalg::veg::dynstack::DynStackMut stack,
-          T* ldl_values,
-          I* perm,
-          I* ldl_col_ptrs,
-          I const* perm_inv)
-{
-  LDLT_TEMP_VEC_UNINIT(T, work_, n_tot, stack);
-  auto rhs_e = rhs.to_eigen();
-  auto sol_e = sol.to_eigen();
-  auto zx = proxsuite::linalg::sparse::util::zero_extend;
-
-  if (do_ldlt) {
-
-    for (isize i = 0; i < n_tot; ++i) {
-      work_[i] = rhs_e[isize(zx(perm[i]))];
-    }
-
-    proxsuite::linalg::sparse::dense_lsolve<T, I>( //
-      { proxsuite::linalg::sparse::from_eigen, work_ },
-      ldl.as_const());
-
-    for (isize i = 0; i < n_tot; ++i) {
-      work_[i] /= ldl_values[isize(zx(ldl_col_ptrs[i]))];
-    }
-
-    proxsuite::linalg::sparse::dense_ltsolve<T, I>( //
-      { proxsuite::linalg::sparse::from_eigen, work_ },
-      ldl.as_const());
-
-    for (isize i = 0; i < n_tot; ++i) {
-      sol_e[i] = work_[isize(zx(perm_inv[i]))];
-    }
-  } else {
-    work_ = iterative_solver.solve(rhs_e);
-    sol_e = work_;
-  }
-}
-
-template<typename T, typename I>
-void
-ldl_iter_solve_noalias(
-  VectorViewMut<T> sol,
-  VectorView<T> rhs,
-  VectorView<T> init_guess,
-  Results<T> const& results,
-  Model<T, I> const& data,
-  isize n_tot,
-  proxsuite::linalg::sparse::MatMut<T, I> ldl,
-  Eigen::MINRES<detail::AugmentedKkt<T, I>,
-                Eigen::Upper | Eigen::Lower,
-                Eigen::IdentityPreconditioner>& iterative_solver,
-  bool do_ldlt,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack,
-  T* ldl_values,
-  I* perm,
-  I* ldl_col_ptrs,
-  I const* perm_inv,
-  Settings<T> const& settings,
-  proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
-  proxsuite::linalg::veg::SliceMut<bool> active_constraints)
-{
-  auto rhs_e = rhs.to_eigen();
-  auto sol_e = sol.to_eigen();
-
-  if (init_guess.dim == sol.dim) {
-    sol_e = init_guess.to_eigen();
-  } else {
-    sol_e.setZero();
-  }
-
-  LDLT_TEMP_VEC_UNINIT(T, err, n_tot, stack);
-
-  T prev_err_norm = std::numeric_limits<T>::infinity();
-
-  for (isize solve_iter = 0; solve_iter < settings.nb_iterative_refinement;
-       ++solve_iter) {
-
-    auto err_x = err.head(data.dim);
-    auto err_y = err.segment(data.dim, data.n_eq);
-    auto err_z = err.tail(data.n_in);
-
-    auto sol_x = sol_e.head(data.dim);
-    auto sol_y = sol_e.segment(data.dim, data.n_eq);
-    auto sol_z = sol_e.tail(data.n_in); // removed active set condition
-
-    err = -rhs_e;
-
-    if (solve_iter > 0) {
-      T mu_eq_neg = -results.info.mu_eq;
-      T mu_in_neg = -results.info.mu_in;
-      detail::noalias_symhiv_add(err, kkt_active.to_eigen(), sol_e);
-      err_x += results.info.rho * sol_x;
-      err_y += mu_eq_neg * sol_y;
-      for (isize i = 0; i < data.n_in; ++i) {
-        err_z[i] += (active_constraints[i] ? mu_in_neg : T(1)) * sol_z[i];
-      }
-    }
-
-    T err_norm = infty_norm(err);
-    if (err_norm > prev_err_norm / T(2)) {
-      break;
-    }
-    prev_err_norm = err_norm;
-
-    ldl_solve({ proxqp::from_eigen, err },
-              { proxqp::from_eigen, err },
-              n_tot,
-              ldl,
-              iterative_solver,
-              do_ldlt,
-              stack,
-              ldl_values,
-              perm,
-              ldl_col_ptrs,
-              perm_inv);
-
-    sol_e -= err;
-  }
-}
-/*!
- * Solves in place a linear system.
- *
- * @param rhs right hand side vector of the linear system to solver.
- * @param init_guess initial guess for solving the linear system
- * @param ldl current ldlt.
- * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
- * algorithm).
- * @param perm_inv pointer to the inverse of the permutation.
- * @param results solver results.
- * @param data model of the QP.
- * @param n_tot dimension of the KKT matrix
- * @param kkt_active active part of the KKT matrix.
- * @param active_constraints vector boolean precising whether the constraints
- * are active or not.
- * @param iterative_solver iterative solver matrix free.
- * @param stack memory stack.
- * @param ldl_values pointor to ldl values.
- * @param perm pointor to the ldl permutation.
- * @param ldl_col_ptrs pointor to the column of the ldl.
- * @param perm_inv pointor the inverse permutation.
- * @param settings solver's settings.
- * @param kkt_active active part of the kkt.
- */
-template<typename T, typename I>
-void
-ldl_solve_in_place(
-  VectorViewMut<T> rhs,
-  VectorView<T> init_guess,
-  Results<T> const& results,
-  Model<T, I> const& data,
-  isize n_tot,
-  proxsuite::linalg::sparse::MatMut<T, I> ldl,
-  Eigen::MINRES<detail::AugmentedKkt<T, I>,
-                Eigen::Upper | Eigen::Lower,
-                Eigen::IdentityPreconditioner>& iterative_solver,
-  bool do_ldlt,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack,
-  T* ldl_values,
-  I* perm,
-  I* ldl_col_ptrs,
-  I const* perm_inv,
-  Settings<T> const& settings,
-  proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
-  proxsuite::linalg::veg::SliceMut<bool> active_constraints)
-{
-  LDLT_TEMP_VEC_UNINIT(T, tmp, n_tot, stack);
-  ldl_iter_solve_noalias({ proxqp::from_eigen, tmp },
-                         rhs.as_const(),
-                         init_guess,
-                         results,
-                         data,
-                         n_tot,
-                         ldl,
-                         iterative_solver,
-                         do_ldlt,
-                         stack,
-                         ldl_values,
-                         perm,
-                         ldl_col_ptrs,
-                         perm_inv,
-                         settings,
-                         kkt_active,
-                         active_constraints);
-  rhs.to_eigen() = tmp;
-}
-/*!
- * Reconstructs manually the permutted matrix.
- *
- * @param ldl current ldlt.
- * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
- * algorithm).
- */
-template<typename T, typename I>
-auto
-inner_reconstructed_matrix(proxsuite::linalg::sparse::MatMut<T, I> ldl)
-  -> DMat<T>
-{
-  auto ldl_dense = ldl.to_eigen().toDense();
-  auto l = DMat<T>(ldl_dense.template triangularView<Eigen::UnitLower>());
-  auto lt = l.transpose();
-  auto d = ldl_dense.diagonal().asDiagonal();
-  auto mat = DMat<T>(l * d * lt);
-  return mat;
-}
-/*!
- * Reconstructs manually the value of the KKT matrix.
- *
- * @param ldl current ldlt.
- * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
- * algorithm).
- * @param perm_inv pointer to the inverse of the permutation.
- * @param n_tot dimension of the KKT matrix
- */
-template<typename T, typename I>
-auto
-reconstructed_matrix(proxsuite::linalg::sparse::MatMut<T, I> ldl,
-                     I const* perm_inv,
-                     isize n_tot) -> DMat<T>
-{
-  auto mat = inner_reconstructed_matrix(ldl);
-  auto mat_backup = mat;
-  for (isize i = 0; i < n_tot; ++i) {
-    for (isize j = 0; j < n_tot; ++j) {
-      mat(i, j) = mat_backup(perm_inv[i], perm_inv[j]);
-    }
-  }
-  return mat;
-}
-/*!
- * Derives the norm of the difference between current KKT and the one it should
- * be (derived manually).
- *
- * @param ldl current ldlt.
- * @param perm_inv pointer to the inverse of the permutation.
- * @param results solver results.
- * @param data model of the QP.
- * @param n_tot dimension of the KKT matrix
- * @param kkt_active active part of the KKT matrix.
- * @param active_constraints vector boolean precising whether the constraints
- * are active or not.
- */
-template<typename T, typename I>
-auto
-reconstruction_error(proxsuite::linalg::sparse::MatMut<T, I> ldl,
-                     I const* perm_inv,
-                     Results<T> const& results,
-                     Model<T, I> const& data,
-                     isize n_tot,
-                     proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
-                     proxsuite::linalg::veg::SliceMut<bool> active_constraints)
-  -> DMat<T>
-{
-  T mu_eq_neg = -results.info.mu_eq;
-  T mu_in_neg = -results.info.mu_in;
-  auto diff = DMat<T>(
-    reconstructed_matrix(ldl, perm_inv, n_tot) -
-    DMat<T>(
-      DMat<T>(kkt_active.to_eigen()).template selfadjointView<Eigen::Upper>()));
-  diff.diagonal().head(data.dim).array() -= results.info.rho;
-  diff.diagonal().segment(data.dim, data.n_eq).array() -= mu_eq_neg;
-  for (isize i = 0; i < data.n_in; ++i) {
-    diff.diagonal()[data.dim + data.n_eq + i] -=
-      active_constraints[i] ? mu_in_neg : T(1);
-  }
-  return diff;
-}
-
-template<typename T>
-struct PrimalDualGradResult
-{
-  T a;
-  T b;
-  T grad;
-  VEG_REFLECT(PrimalDualGradResult, a, b, grad);
-};
-
-/*!
- * Executes the PROXQP algorithm.
- *
- * @param results solver results.
- * @param data QP problem model as defined by the user (without any scaling
- * performed).
- * @param settings solver settings.
- * @param work solver workspace.
- * @param precond preconditioner.
- */
-template<typename T, typename I, typename P>
-void
-qp_solve(Results<T>& results,
-         Model<T, I>& data,
-         const Settings<T>& settings,
-         Workspace<T, I>& work,
-         P& precond)
-{
-  if (settings.compute_timings) {
-    work.timer.stop();
-    work.timer.start();
-  }
-
-  if (work.internal
-        .dirty) // the following is used when a solve has already been executed
-                // (and without any intermediary model update)
-  {
-    proxsuite::linalg::sparse::MatMut<T, I> kkt_unscaled =
-      data.kkt_mut_unscaled();
-
-    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
-      proxsuite::linalg::veg::unsafe, kkt_unscaled, data.dim);
-
-    proxsuite::linalg::sparse::MatMut<T, I> H_unscaled =
-      detail::middle_cols_mut(kkt_top_n_rows, 0, data.dim, data.H_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> AT_unscaled =
-      detail::middle_cols_mut(kkt_top_n_rows, data.dim, data.n_eq, data.A_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> CT_unscaled =
-      detail::middle_cols_mut(
-        kkt_top_n_rows, data.dim + data.n_eq, data.n_in, data.C_nnz);
-
-    SparseMat<T, I> H_triu =
-      H_unscaled.to_eigen().template triangularView<Eigen::Upper>();
-    sparse::QpView<T, I> qp = {
-      { proxsuite::linalg::sparse::from_eigen, H_triu },
-      { proxsuite::linalg::sparse::from_eigen, data.g },
-      { proxsuite::linalg::sparse::from_eigen, AT_unscaled.to_eigen() },
-      { proxsuite::linalg::sparse::from_eigen, data.b },
-      { proxsuite::linalg::sparse::from_eigen, CT_unscaled.to_eigen() },
-      { proxsuite::linalg::sparse::from_eigen, data.l },
-      { proxsuite::linalg::sparse::from_eigen, data.u }
-    };
-
-    switch (settings.initial_guess) { // the following is used when one solve
-                                      // has already been executed
-      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-        results.cleanup(settings);
-        break;
-      }
-      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-        // keep solutions but restart workspace and results
-        results.cold_start(settings);
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, results.x });
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-      case InitialGuessStatus::NO_INITIAL_GUESS: {
-        results.cleanup(settings);
-        break;
-      }
-      case InitialGuessStatus::WARM_START: {
-        results.cold_start(settings); // because there was already a solve,
-                                      // precond was already computed if set so
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            results.x }); // it contains the value given in entry for warm start
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-        // keep workspace and results solutions except statistics
-        results.cleanup_statistics();
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, results.x });
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-    }
-    work.setup_impl(
-      qp,
-      data,
-      settings,
-      false,
-      precond,
-      P::scale_qp_in_place_req(
-        proxsuite::linalg::veg::Tag<T>{}, data.dim, data.n_eq, data.n_in));
-
-  } else {
-    // the following is used for a first solve after initializing or updating
-    // the Qp object
-    switch (settings.initial_guess) {
-      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-        break;
-      }
-      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            results.x }); // meaningful for when there is an upate of the model
-                          // and one wants to warm start with previous result
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-      case InitialGuessStatus::NO_INITIAL_GUESS: {
-        break;
-      }
-      case InitialGuessStatus::WARM_START: {
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen, results.x });
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-        precond.scale_primal_in_place(
-          { proxsuite::proxqp::from_eigen,
-            results.x }); // meaningful for when there is an upate of the model
-                          // and one wants to warm start with previous result
-        precond.scale_dual_in_place_eq(
-          { proxsuite::proxqp::from_eigen, results.y });
-        precond.scale_dual_in_place_in(
-          { proxsuite::proxqp::from_eigen, results.z });
-        break;
-      }
-    }
-  }
-
-  if (settings.verbose) {
-    sparse::print_setup_header(settings, results, data);
-  }
-  using namespace proxsuite::linalg::veg::literals;
-  namespace util = proxsuite::linalg::sparse::util;
-  auto zx = util::zero_extend;
-
-  proxsuite::linalg::veg::dynstack::DynStackMut stack = work.stack_mut();
-
-  isize n = data.dim;
-  isize n_eq = data.n_eq;
-  isize n_in = data.n_in;
-  isize n_tot = n + n_eq + n_in;
-
-  VectorViewMut<T> x{ proxqp::from_eigen, results.x };
-  VectorViewMut<T> y{ proxqp::from_eigen, results.y };
-  VectorViewMut<T> z{ proxqp::from_eigen, results.z };
-
-  proxsuite::linalg::sparse::MatMut<T, I> kkt = data.kkt_mut();
-
-  auto kkt_top_n_rows =
-    detail::top_rows_mut_unchecked(proxsuite::linalg::veg::unsafe, kkt, n);
-
-  proxsuite::linalg::sparse::MatMut<T, I> H_scaled =
-    detail::middle_cols_mut(kkt_top_n_rows, 0, n, data.H_nnz);
-
-  proxsuite::linalg::sparse::MatMut<T, I> AT_scaled =
-    detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, data.A_nnz);
-
-  proxsuite::linalg::sparse::MatMut<T, I> CT_scaled =
-    detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, data.C_nnz);
-
-  auto& g_scaled_e = work.internal.g_scaled;
-  auto& b_scaled_e = work.internal.b_scaled;
-  auto& l_scaled_e = work.internal.l_scaled;
-  auto& u_scaled_e = work.internal.u_scaled;
-
-  QpViewMut<T, I> qp_scaled = {
-    H_scaled,
-    { proxsuite::linalg::sparse::from_eigen, g_scaled_e },
-    AT_scaled,
-    { proxsuite::linalg::sparse::from_eigen, b_scaled_e },
-    CT_scaled,
-    { proxsuite::linalg::sparse::from_eigen, l_scaled_e },
-    { proxsuite::linalg::sparse::from_eigen, u_scaled_e },
-  };
-
-  T const dual_feasibility_rhs_2 = infty_norm(data.g);
-
-  // auto ldl_col_ptrs = work.ldl_col_ptrs_mut();
-  auto ldl_col_ptrs = work.internal.ldl.col_ptrs.ptr_mut();
-  proxsuite::linalg::veg::Tag<I> itag;
-  proxsuite::linalg::veg::Tag<T> xtag;
-
-  bool do_ldlt = work.internal.do_ldlt;
-
-  isize ldlt_ntot = do_ldlt ? n_tot : 0;
-
-  auto _perm = stack.make_new_for_overwrite(itag, ldlt_ntot);
-
-  I* perm_inv = work.internal.ldl.perm_inv.ptr_mut();
-  I* perm = _perm.ptr_mut();
-
-  if (do_ldlt) {
-    // compute perm from perm_inv
-    for (isize i = 0; i < n_tot; ++i) {
-      perm[isize(zx(perm_inv[i]))] = I(i);
-    }
-  }
-
-  I* kkt_nnz_counts = work.internal.kkt_nnz_counts.ptr_mut();
-
-  auto& iterative_solver = *work.internal.matrix_free_solver.get();
-  isize C_active_nnz = 0;
-  switch (settings.initial_guess) {
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-      // H and A are always active
-      for (usize j = 0; j < usize(n + n_eq); ++j) {
-        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
-      }
-      // ineq constraints initially inactive
-      for (isize j = 0; j < n_in; ++j) {
-        kkt_nnz_counts[n + n_eq + j] = 0;
-        work.active_inequalities[j] = false;
-      }
-      break;
-    }
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-      // keep solutions + restart workspace and results except rho and mu : done
-      // in setup
-
-      // H and A are always active
-      for (usize j = 0; j < usize(n + n_eq); ++j) {
-        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
-      }
-      // keep constraints inactive from previous solution
-      for (isize j = 0; j < n_in; ++j) {
-        if (results.z(j) != 0) {
-          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
-                                           kkt.col_start(usize(n + n_eq + j)));
-          work.active_inequalities[j] = true;
-          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
-        } else {
-          kkt_nnz_counts[n + n_eq + j] = 0;
-          work.active_inequalities[j] = false;
-        }
-      }
-      break;
-    }
-    case InitialGuessStatus::NO_INITIAL_GUESS: {
-      // already set to zero in the setup
-      // H and A are always active
-      for (usize j = 0; j < usize(n + n_eq); ++j) {
-        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
-      }
-      // ineq constraints initially inactive
-      for (isize j = 0; j < n_in; ++j) {
-        kkt_nnz_counts[n + n_eq + j] = 0;
-        work.active_inequalities[j] = false;
-      }
-      break;
-    }
-    case InitialGuessStatus::WARM_START: {
-      // keep previous solution
-
-      // H and A are always active
-      for (usize j = 0; j < usize(n + n_eq); ++j) {
-        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
-      }
-      // keep constraints inactive from previous solution
-      for (isize j = 0; j < n_in; ++j) {
-        if (results.z(j) != 0) {
-          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
-                                           kkt.col_start(usize(n + n_eq + j)));
-          work.active_inequalities[j] = true;
-          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
-
-        } else {
-          kkt_nnz_counts[n + n_eq + j] = 0;
-          work.active_inequalities[j] = false;
-        }
-      }
-      break;
-    }
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-      // keep workspace and results solutions except statistics
-      // H and A are always active
-      for (usize j = 0; j < usize(n + n_eq); ++j) {
-        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
-      }
-      // keep constraints inactive from previous solution
-      for (isize j = 0; j < n_in; ++j) {
-        if (results.z(j) != 0) {
-          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
-                                           kkt.col_start(usize(n + n_eq + j)));
-          work.active_inequalities[j] = true;
-          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
-        } else {
-          kkt_nnz_counts[n + n_eq + j] = 0;
-          work.active_inequalities[j] = false;
-        }
-      }
-      break;
-    }
-  }
-
-  proxsuite::linalg::sparse::MatMut<T, I> kkt_active = {
-    proxsuite::linalg::sparse::from_raw_parts,
-    n_tot,
-    n_tot,
-    data.H_nnz + data.A_nnz + C_active_nnz,
-    kkt.col_ptrs_mut(),
-    kkt_nnz_counts,
-    kkt.row_indices_mut(),
-    kkt.values_mut(),
-  };
-
-  I* etree = work.internal.ldl.etree.ptr_mut();
-  I* ldl_nnz_counts = work.internal.ldl.nnz_counts.ptr_mut();
-  I* ldl_row_indices = work.internal.ldl.row_indices.ptr_mut();
-  T* ldl_values = work.internal.ldl.values.ptr_mut();
-  proxsuite::linalg::veg::SliceMut<bool> active_constraints =
-    work.active_inequalities.as_mut();
-
-  proxsuite::linalg::sparse::MatMut<T, I> ldl = {
-    proxsuite::linalg::sparse::from_raw_parts,
-    n_tot,
-    n_tot,
-    0,
-    ldl_col_ptrs,
-    do_ldlt ? ldl_nnz_counts : nullptr, // si do_ldlt est vrai do ldl_nnz_counts
-    ldl_row_indices,
-    ldl_values,
-  };
-
-  T bcl_eta_ext_init = pow(T(0.1), settings.alpha_bcl);
-  T bcl_eta_ext = bcl_eta_ext_init;
-  T bcl_eta_in(1);
-  T eps_in_min = std::min(settings.eps_abs, T(1e-9));
-
-  auto x_e = x.to_eigen();
-  auto y_e = y.to_eigen();
-  auto z_e = z.to_eigen();
-  sparse::refactorize<T, I>(
-    work, results, kkt_active, active_constraints, data, stack, xtag);
-  switch (settings.initial_guess) {
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
-      LDLT_TEMP_VEC_UNINIT(T, rhs, n_tot, stack);
-      LDLT_TEMP_VEC_UNINIT(T, no_guess, 0, stack);
-
-      rhs.head(n) = -g_scaled_e;
-      rhs.segment(n, n_eq) = b_scaled_e;
-      rhs.segment(n + n_eq, n_in).setZero();
-
-      ldl_solve_in_place({ proxqp::from_eigen, rhs },
-                         { proxqp::from_eigen, no_guess },
-                         results,
-                         data,
-                         n_tot,
-                         ldl,
-                         iterative_solver,
-                         do_ldlt,
-                         stack,
-                         ldl_values,
-                         perm,
-                         ldl_col_ptrs,
-                         perm_inv,
-                         settings,
-                         kkt_active,
-                         active_constraints);
-      x_e = rhs.head(n);
-      y_e = rhs.segment(n, n_eq);
-      z_e = rhs.segment(n + n_eq, n_in);
-      break;
-    }
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
-      // keep solutions but restart workspace and results
-      break;
-    }
-    case InitialGuessStatus::NO_INITIAL_GUESS: {
-      // already set to zero in the setup
-      break;
-    }
-    case InitialGuessStatus::WARM_START: {
-      // keep previous solution
-      break;
-    }
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
-      // keep workspace and results solutions except statistics
-      break;
-    }
-  }
-  T rhs_duality_gap(0);
-
-  for (isize iter = 0; iter < settings.max_iter; ++iter) {
-
-    results.info.iter_ext += 1;
-    if (iter == settings.max_iter) {
-      break;
-    }
-    T new_bcl_mu_eq = results.info.mu_eq;
-    T new_bcl_mu_in = results.info.mu_in;
-    T new_bcl_mu_eq_inv = results.info.mu_eq_inv;
-    T new_bcl_mu_in_inv = results.info.mu_in_inv;
-
-    {
-      T primal_feasibility_eq_rhs_0;
-      T primal_feasibility_in_rhs_0;
-
-      T dual_feasibility_rhs_0(0);
-      T dual_feasibility_rhs_1(0);
-      T dual_feasibility_rhs_3(0);
-
-      LDLT_TEMP_VEC_UNINIT(T, primal_residual_eq_scaled, n_eq, stack);
-      LDLT_TEMP_VEC_UNINIT(T, primal_residual_in_scaled_lo, n_in, stack);
-      LDLT_TEMP_VEC_UNINIT(T, primal_residual_in_scaled_up, n_in, stack);
-
-      LDLT_TEMP_VEC_UNINIT(T, dual_residual_scaled, n, stack);
-
-      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-      auto is_primal_feasible = [&](T primal_feasibility_lhs) -> bool {
-        T rhs_pri = settings.eps_abs;
-        if (settings.eps_rel != 0) {
-          rhs_pri +=
-            settings.eps_rel * std::max({ primal_feasibility_eq_rhs_0,
-                                          primal_feasibility_in_rhs_0 });
-        }
-        return primal_feasibility_lhs <= rhs_pri;
-      };
-      auto is_dual_feasible = [&](T dual_feasibility_lhs) -> bool {
-        T rhs_dua = settings.eps_abs;
-        if (settings.eps_rel != 0) {
-          rhs_dua += settings.eps_rel * std::max({
-                                          dual_feasibility_rhs_0,
-                                          dual_feasibility_rhs_1,
-                                          dual_feasibility_rhs_2,
-                                          dual_feasibility_rhs_3,
-                                        });
-        }
-
-        return dual_feasibility_lhs <= rhs_dua;
-      };
-      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-      VEG_BIND( // ?
-        auto,
-        (primal_feasibility_lhs, dual_feasibility_lhs),
-        detail::unscaled_primal_dual_residual(work,
-                                              results,
-                                              primal_residual_eq_scaled,
-                                              primal_residual_in_scaled_lo,
-                                              primal_residual_in_scaled_up,
-                                              dual_residual_scaled,
-                                              primal_feasibility_eq_rhs_0,
-                                              primal_feasibility_in_rhs_0,
-                                              dual_feasibility_rhs_0,
-                                              dual_feasibility_rhs_1,
-                                              dual_feasibility_rhs_3,
-                                              rhs_duality_gap,
-                                              precond,
-                                              data,
-                                              qp_scaled.as_const(),
-                                              detail::vec_mut(x_e),
-                                              detail::vec_mut(y_e),
-                                              detail::vec_mut(z_e),
-                                              stack));
-      /*put in debug mode
-      if (settings.verbose) {
-              std::cout << "-------- outer iteration: " << iter << " primal
-      residual "
-                                                      << primal_feasibility_lhs
-      << " dual residual "
-                                                      << dual_feasibility_lhs <<
-      " mu_in " << results.info.mu_in
-                                                      << " bcl_eta_ext " <<
-      bcl_eta_ext << " bcl_eta_in "
-                                                      << bcl_eta_in <<
-      std::endl;
-      }
-      */
-      if (settings.verbose) {
-        LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
-        tmp.setZero();
-        detail::noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
-        precond.unscale_dual_residual_in_place({ proxqp::from_eigen, tmp });
-
-        precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
-        precond.unscale_dual_in_place_eq({ proxqp::from_eigen, y_e });
-        precond.unscale_dual_in_place_in({ proxqp::from_eigen, z_e });
-        tmp *= 0.5;
-        tmp += data.g;
-        results.info.objValue = (tmp).dot(x_e);
-        std::cout << "\033[1;32m[outer iteration " << iter + 1 << "]\033[0m"
-                  << std::endl;
-        std::cout << std::scientific << std::setw(2) << std::setprecision(2)
-                  << "| primal residual=" << primal_feasibility_lhs
-                  << " | dual residual=" << dual_feasibility_lhs
-                  << " | duality gap=" << results.info.duality_gap
-                  << " | mu_in=" << results.info.mu_in
-                  << " | rho=" << results.info.rho << std::endl;
-        results.info.pri_res = primal_feasibility_lhs;
-        results.info.dua_res = dual_feasibility_lhs;
-        precond.scale_primal_in_place(VectorViewMut<T>{ from_eigen, x_e });
-        precond.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, y_e });
-        precond.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, z_e });
-      }
-      if (is_primal_feasible(primal_feasibility_lhs) &&
-          is_dual_feasible(dual_feasibility_lhs)) {
-        if (settings.check_duality_gap) {
-          if (std::fabs(results.info.duality_gap) <=
-              settings.eps_duality_gap_abs +
-                settings.eps_duality_gap_rel * rhs_duality_gap) {
-            results.info.pri_res = primal_feasibility_lhs;
-            results.info.dua_res = dual_feasibility_lhs;
-            results.info.status = QPSolverOutput::PROXQP_SOLVED;
-            break;
-          }
-        } else {
-          results.info.pri_res = primal_feasibility_lhs;
-          results.info.dua_res = dual_feasibility_lhs;
-          results.info.status = QPSolverOutput::PROXQP_SOLVED;
-          break;
-        }
-      }
-
-      LDLT_TEMP_VEC_UNINIT(T, x_prev_e, n, stack);
-      LDLT_TEMP_VEC_UNINIT(T, y_prev_e, n_eq, stack);
-      LDLT_TEMP_VEC_UNINIT(T, z_prev_e, n_in, stack);
-      LDLT_TEMP_VEC(T, dw_prev, n_tot, stack);
-
-      x_prev_e = x_e;
-      y_prev_e = y_e;
-      z_prev_e = z_e;
-
-      // Cx + 1/mu_in * z_prev
-      primal_residual_in_scaled_up += results.info.mu_in * z_prev_e;
-      primal_residual_in_scaled_lo = primal_residual_in_scaled_up;
-
-      // Cx - l + 1/mu_in * z_prev
-      primal_residual_in_scaled_lo -= l_scaled_e;
-
-      // Cx - u + 1/mu_in * z_prev
-      primal_residual_in_scaled_up -= u_scaled_e;
-
-      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-      auto primal_dual_newton_semi_smooth = [&]() -> void {
-        for (isize iter_inner = 0; iter_inner < settings.max_iter_in;
-             ++iter_inner) {
-          LDLT_TEMP_VEC_UNINIT(T, dw, n_tot, stack);
-
-          if (iter_inner == settings.max_iter_in - 1) {
-            results.info.iter += settings.max_iter_in;
-            break;
-          }
-
-          // primal_dual_semi_smooth_newton_step
-          {
-            LDLT_TEMP_VEC_UNINIT(bool, new_active_constraints, n_in, stack);
-            auto rhs = dw;
-
-            work.active_set_low.array() =
-              primal_residual_in_scaled_lo.array() <= 0;
-            work.active_set_up.array() =
-              primal_residual_in_scaled_up.array() >= 0;
-            new_active_constraints = work.active_set_low || work.active_set_up;
-
-            // active set change
-            if (n_in > 0) {
-              bool removed = false;
-              bool added = false;
-
-              for (isize i = 0; i < n_in; ++i) {
-                bool was_active = active_constraints[i];
-                bool is_active = new_active_constraints[i];
-
-                isize idx = n + n_eq + i;
-
-                usize col_nnz =
-                  zx(kkt.col_end(usize(idx))) - zx(kkt.col_start(usize(idx)));
-
-                if (is_active && !was_active) {
-                  added = true;
-
-                  kkt_active.nnz_per_col_mut()[idx] = I(col_nnz);
-                  kkt_active._set_nnz(kkt_active.nnz() + isize(col_nnz));
-
-                  if (do_ldlt) {
-                    proxsuite::linalg::sparse::VecRef<T, I> new_col{
-                      proxsuite::linalg::sparse::from_raw_parts,
-                      n_tot,
-                      isize(col_nnz),
-                      kkt.row_indices() + zx(kkt.col_start(usize(idx))),
-                      kkt.values() + zx(kkt.col_start(usize(idx))),
-                    };
-
-                    ldl =
-                      proxsuite::linalg::sparse::add_row(ldl,
-                                                         etree,
-                                                         perm_inv,
-                                                         idx,
-                                                         new_col,
-                                                         -results.info.mu_in,
-                                                         stack);
-                  }
-                  active_constraints[i] = new_active_constraints[i];
-
-                } else if (!is_active && was_active) {
-                  removed = true;
-                  kkt_active.nnz_per_col_mut()[idx] = 0;
-                  kkt_active._set_nnz(kkt_active.nnz() - isize(col_nnz));
-                  if (do_ldlt) {
-                    ldl = proxsuite::linalg::sparse::delete_row(
-                      ldl, etree, perm_inv, idx, stack);
-                  }
-                  active_constraints[i] = new_active_constraints[i];
-                }
-              }
-
-              if (!do_ldlt) {
-                if (removed || added) {
-                  refactorize(work,
-                              results,
-                              kkt_active,
-                              active_constraints,
-                              data,
-                              stack,
-                              xtag);
-                }
-              }
-            }
-
-            rhs.head(n) = -dual_residual_scaled;
-            rhs.segment(n, n_eq) = -primal_residual_eq_scaled;
-
-            for (isize i = 0; i < n_in; ++i) {
-              if (work.active_set_up(i)) {
-                rhs(n + n_eq + i) =
-                  results.info.mu_in * z_e(i) - primal_residual_in_scaled_up(i);
-              } else if (work.active_set_low(i)) {
-                rhs(n + n_eq + i) =
-                  results.info.mu_in * z_e(i) - primal_residual_in_scaled_lo(i);
-              } else {
-                rhs(n + n_eq + i) = -z_e(i);
-                rhs.head(n) += z_e(i) * CT_scaled.to_eigen().col(i);
-              }
-            }
-
-            ldl_solve_in_place(
-              { proxqp::from_eigen, rhs },
-              { proxqp::from_eigen,
-                dw_prev }, // todo: MAJ dw_prev avec dw pour avoir meilleur
-                           // guess sur les solve in place
-              results,
-              data,
-              n_tot,
-              ldl,
-              iterative_solver,
-              do_ldlt,
-              stack,
-              ldl_values,
-              perm,
-              ldl_col_ptrs,
-              perm_inv,
-              settings,
-              kkt_active,
-              active_constraints);
-          }
-          auto dx = dw.head(n);
-          auto dy = dw.segment(n, n_eq);
-          auto dz = dw.segment(n + n_eq, n_in);
-
-          LDLT_TEMP_VEC(T, Hdx, n, stack);
-          LDLT_TEMP_VEC(T, Adx, n_eq, stack);
-          LDLT_TEMP_VEC(T, Cdx, n_in, stack);
-
-          LDLT_TEMP_VEC(T, ATdy, n, stack);
-          LDLT_TEMP_VEC(T, CTdz, n, stack);
-
-          detail::noalias_symhiv_add(Hdx, H_scaled.to_eigen(), dx);
-          detail::noalias_gevmmv_add(Adx, ATdy, AT_scaled.to_eigen(), dx, dy);
-          detail::noalias_gevmmv_add(Cdx, CTdz, CT_scaled.to_eigen(), dx, dz);
-
-          T alpha = 1;
-          // primal dual line search
-          if (n_in > 0) {
-            auto primal_dual_gradient_norm =
-              [&](T alpha_cur) -> PrimalDualGradResult<T> {
-              LDLT_TEMP_VEC_UNINIT(T, Cdx_active, n_in, stack);
-              LDLT_TEMP_VEC_UNINIT(T, active_part_z, n_in, stack);
-              {
-                LDLT_TEMP_VEC_UNINIT(T, tmp_lo, n_in, stack);
-                LDLT_TEMP_VEC_UNINIT(T, tmp_up, n_in, stack);
-
-                auto zero = Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(n_in);
-
-                tmp_lo = primal_residual_in_scaled_lo + alpha_cur * Cdx;
-                tmp_up = primal_residual_in_scaled_up + alpha_cur * Cdx;
-                Cdx_active =
-                  (tmp_lo.array() < 0 || tmp_up.array() > 0).select(Cdx, zero);
-                active_part_z = (tmp_lo.array() < 0)
-                                  .select(primal_residual_in_scaled_lo, zero) +
-                                (tmp_up.array() > 0)
-                                  .select(primal_residual_in_scaled_up, zero);
-              }
-
-              T a = dx.dot(Hdx) +                         //
-                    results.info.rho * dx.squaredNorm() + //
-                    results.info.mu_eq_inv * Adx.squaredNorm() +
-                    +results.info.mu_in_inv * Cdx_active.squaredNorm() +
-                    results.info.nu * results.info.mu_eq *
-                      (results.info.mu_eq_inv * Adx - dy).squaredNorm() +
-                    results.info.nu * results.info.mu_in *
-                      (results.info.mu_in_inv * Cdx_active - dz).squaredNorm();
-
-              T b =
-                x_e.dot(Hdx) +                                               //
-                (results.info.rho * (x_e - x_prev_e) + g_scaled_e).dot(dx) + //
-                Adx.dot(results.info.mu_eq_inv * primal_residual_eq_scaled +
-                        y_e) +                                           //
-                results.info.mu_in_inv * Cdx_active.dot(active_part_z) + //
-                results.info.nu * primal_residual_eq_scaled.dot(
-                                    results.info.mu_eq_inv * Adx - dy) + //
-                results.info.nu *
-                  (active_part_z - results.info.mu_in * z_e)
-                    .dot(results.info.mu_in_inv * Cdx_active - dz);
-
-              return {
-                a,
-                b,
-                a * alpha_cur + b,
-              };
-            };
-
-            LDLT_TEMP_VEC_UNINIT(T, alphas, 2 * n_in, stack);
-            isize alphas_count = 0;
-
-            for (isize i = 0; i < n_in; ++i) {
-              T alpha_candidates[2] = {
-                -primal_residual_in_scaled_lo(i) / (Cdx(i)),
-                -primal_residual_in_scaled_up(i) / (Cdx(i)),
-              };
-
-              for (auto alpha_candidate : alpha_candidates) {
-                if (alpha_candidate > 0) {
-                  alphas[alphas_count] = alpha_candidate;
-                  ++alphas_count;
-                }
-              }
-            }
-            std::sort(alphas.data(), alphas.data() + alphas_count);
-            alphas_count =
-              std::unique(alphas.data(), alphas.data() + alphas_count) -
-              alphas.data();
-
-            if (alphas_count > 0 && alphas[0] <= 1) {
-              auto infty = std::numeric_limits<T>::infinity();
-
-              T last_neg_grad = 0;
-              T alpha_last_neg = 0;
-              T first_pos_grad = 0;
-              T alpha_first_pos = infty;
-
-              {
-                for (isize i = 0; i < alphas_count; ++i) {
-                  T alpha_cur = alphas[i];
-                  T gr = primal_dual_gradient_norm(alpha_cur).grad;
-
-                  if (gr < 0) {
-                    alpha_last_neg = alpha_cur;
-                    last_neg_grad = gr;
-                  } else {
-                    first_pos_grad = gr;
-                    alpha_first_pos = alpha_cur;
-                    break;
-                  }
-                }
-
-                if (alpha_last_neg == 0) {
-                  last_neg_grad =
-                    primal_dual_gradient_norm(alpha_last_neg).grad;
-                }
-
-                if (alpha_first_pos == infty) {
-                  auto res = primal_dual_gradient_norm(2 * alpha_last_neg + 1);
-                  alpha = -res.b / res.a;
-                } else {
-                  alpha = alpha_last_neg -
-                          last_neg_grad * (alpha_first_pos - alpha_last_neg) /
-                            (first_pos_grad - last_neg_grad);
-                }
-              }
-            } else {
-              auto res = primal_dual_gradient_norm(T(0));
-              alpha = -res.b / res.a;
-            }
-          }
-          if (alpha * infty_norm(dw) < T(1e-11) && iter_inner > 0) {
-            results.info.iter += iter_inner + 1;
-            return;
-          }
-
-          x_e += alpha * dx;
-          y_e += alpha * dy;
-          z_e += alpha * dz;
-
-          dual_residual_scaled +=
-            alpha * (Hdx + ATdy + CTdz + results.info.rho * dx);
-          primal_residual_eq_scaled += alpha * (Adx - results.info.mu_eq * dy);
-          primal_residual_in_scaled_lo += alpha * Cdx;
-          primal_residual_in_scaled_up += alpha * Cdx;
-
-          T err_in = std::max({
-            (infty_norm(helpers::negative_part(primal_residual_in_scaled_lo) +
-                        helpers::positive_part(primal_residual_in_scaled_up) -
-                        results.info.mu_in * z_e)),
-            (infty_norm(primal_residual_eq_scaled)),
-            (infty_norm(dual_residual_scaled)),
-          });
-          /* put in debug mode
-          if (settings.verbose) {
-                  std::cout << "--inner iter " << iter_inner << " iner error "
-                                                          << err_in << " alpha "
-          << alpha << " infty_norm(dw) "
-                                                          << infty_norm(dw) <<
-          std::endl;
-          }
-          */
-          if (settings.verbose) {
-            std::cout << "\033[1;34m[inner iteration " << iter_inner + 1
-                      << "]\033[0m" << std::endl;
-            std::cout << std::scientific << std::setw(2) << std::setprecision(2)
-                      << "| inner residual=" << err_in << " | alpha=" << alpha
-                      << std::endl;
-          }
-          if (err_in <= bcl_eta_in) {
-            results.info.iter += iter_inner + 1;
-            return;
-          }
-
-          // compute primal and dual infeasibility criteria
-          bool is_primal_infeasible = proxsuite::proxqp::sparse::detail::
-            global_primal_residual_infeasibility(
-              VectorViewMut<T>{ from_eigen, ATdy },
-              VectorViewMut<T>{ from_eigen, CTdz },
-              VectorViewMut<T>{ from_eigen, dy },
-              VectorViewMut<T>{ from_eigen, dz },
-              qp_scaled.as_const(),
-              settings,
-              precond);
-          bool is_dual_infeasible = proxsuite::proxqp::sparse::detail::
-            global_dual_residual_infeasibility(
-              VectorViewMut<T>{ from_eigen, Adx },
-              VectorViewMut<T>{ from_eigen, Cdx },
-              VectorViewMut<T>{ from_eigen, Hdx },
-              VectorViewMut<T>{ from_eigen, dx },
-              qp_scaled.as_const(),
-              settings,
-              data,
-              precond);
-          if (is_primal_infeasible) {
-            results.info.status = QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE;
-            dw_prev = dw;
-            break;
-          } else if (is_dual_infeasible) {
-            results.info.status = QPSolverOutput::PROXQP_DUAL_INFEASIBLE;
-            dw_prev = dw;
-            break;
-          }
-        }
-      };
-      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-      primal_dual_newton_semi_smooth();
-      if (results.info.status == QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE ||
-          results.info.status == QPSolverOutput::PROXQP_DUAL_INFEASIBLE) {
-        // certificate of infeasibility
-        results.x = dw_prev.head(data.dim);
-        results.y = dw_prev.segment(data.dim, data.n_eq);
-        results.z = dw_prev.tail(data.n_in);
-        break;
-      }
-      // VEG bind : met le résultat tuple de unscaled_primal_dual_residual dans
-      // (primal_feasibility_lhs_new, dual_feasibility_lhs_new) en guessant leur
-      // type via auto
-      VEG_BIND(
-        auto,
-        (primal_feasibility_lhs_new, dual_feasibility_lhs_new),
-        detail::unscaled_primal_dual_residual(work,
-                                              results,
-                                              primal_residual_eq_scaled,
-                                              primal_residual_in_scaled_lo,
-                                              primal_residual_in_scaled_up,
-                                              dual_residual_scaled,
-                                              primal_feasibility_eq_rhs_0,
-                                              primal_feasibility_in_rhs_0,
-                                              dual_feasibility_rhs_0,
-                                              dual_feasibility_rhs_1,
-                                              dual_feasibility_rhs_3,
-                                              rhs_duality_gap,
-                                              precond,
-                                              data,
-                                              qp_scaled.as_const(),
-                                              detail::vec_mut(x_e),
-                                              detail::vec_mut(y_e),
-                                              detail::vec_mut(z_e),
-                                              stack));
-
-      if (is_primal_feasible(primal_feasibility_lhs_new) &&
-          is_dual_feasible(dual_feasibility_lhs_new)) {
-        if (settings.check_duality_gap) {
-          if (std::fabs(results.info.duality_gap) <=
-              settings.eps_duality_gap_abs +
-                settings.eps_duality_gap_rel * rhs_duality_gap) {
-            results.info.pri_res = primal_feasibility_lhs_new;
-            results.info.dua_res = dual_feasibility_lhs_new;
-            results.info.status = QPSolverOutput::PROXQP_SOLVED;
-            break;
-          }
-        } else {
-          results.info.pri_res = primal_feasibility_lhs_new;
-          results.info.dua_res = dual_feasibility_lhs_new;
-          results.info.status = QPSolverOutput::PROXQP_SOLVED;
-          break;
-        }
-      }
-
-      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
-      auto bcl_update = [&]() -> void {
-        if (primal_feasibility_lhs_new <= bcl_eta_ext ||
-            iter > settings.safe_guard) {
-          bcl_eta_ext *= pow(results.info.mu_in, settings.beta_bcl);
-          bcl_eta_in = std::max(bcl_eta_in * results.info.mu_in, eps_in_min);
-
-        } else {
-          y_e = y_prev_e;
-          z_e = z_prev_e;
-          new_bcl_mu_in = std::max(
-            results.info.mu_in * settings.mu_update_factor, settings.mu_min_in);
-          new_bcl_mu_eq = std::max(
-            results.info.mu_eq * settings.mu_update_factor, settings.mu_min_eq);
-
-          new_bcl_mu_in_inv =
-            std::min(results.info.mu_in_inv * settings.mu_update_inv_factor,
-                     settings.mu_max_in_inv);
-          new_bcl_mu_eq_inv =
-            std::min(results.info.mu_eq_inv * settings.mu_update_inv_factor,
-                     settings.mu_max_eq_inv);
-          bcl_eta_ext =
-            bcl_eta_ext_init * pow(new_bcl_mu_in, settings.alpha_bcl);
-          bcl_eta_in = std::max(new_bcl_mu_in, eps_in_min);
-        }
-      };
-      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-      bcl_update();
-
-      VEG_BIND(
-        auto,
-        (_, dual_feasibility_lhs_new_2),
-        detail::unscaled_primal_dual_residual(work,
-                                              results,
-                                              primal_residual_eq_scaled,
-                                              primal_residual_in_scaled_lo,
-                                              primal_residual_in_scaled_up,
-                                              dual_residual_scaled,
-                                              primal_feasibility_eq_rhs_0,
-                                              primal_feasibility_in_rhs_0,
-                                              dual_feasibility_rhs_0,
-                                              dual_feasibility_rhs_1,
-                                              dual_feasibility_rhs_3,
-                                              rhs_duality_gap,
-                                              precond,
-                                              data,
-                                              qp_scaled.as_const(),
-                                              detail::vec_mut(x_e),
-                                              detail::vec_mut(y_e),
-                                              detail::vec_mut(z_e),
-                                              stack));
-      proxsuite::linalg::veg::unused(_);
-
-      if (primal_feasibility_lhs_new >= primal_feasibility_lhs && //
-          dual_feasibility_lhs_new_2 >= primal_feasibility_lhs && //
-          results.info.mu_in <= T(1.E-5)) {
-        new_bcl_mu_in = settings.cold_reset_mu_in;
-        new_bcl_mu_eq = settings.cold_reset_mu_eq;
-        new_bcl_mu_in_inv = settings.cold_reset_mu_in_inv;
-        new_bcl_mu_eq_inv = settings.cold_reset_mu_eq_inv;
-      }
-    }
-    if (results.info.mu_in != new_bcl_mu_in ||
-        results.info.mu_eq != new_bcl_mu_eq) {
-      {
-        ++results.info.mu_updates;
-      }
-      /*
-      refactorize(
-                      work,
-                      results,
-                      kkt_active,
-                      active_constraints,
-                      data,
-                      stack,
-                      xtag);
-      */
-      if (work.internal.do_ldlt) {
-        isize w_values = 1; // un seul elt non nul
-        T alpha = 0;
-        for (isize j = 0; j < n_eq + n_in; ++j) {
-          I row_index = I(j + n);
-          if (j < n_eq) {
-            alpha = results.info.mu_eq - new_bcl_mu_eq;
-
-          } else {
-            if (!work.active_inequalities[j - n_eq]) {
-              continue;
-            }
-            alpha = results.info.mu_in - new_bcl_mu_in;
-          }
-          T value = 1;
-          proxsuite::linalg::sparse::VecRef<T, I> w{
-            proxsuite::linalg::veg::from_raw_parts,
-            n + n_eq + n_in,
-            w_values,
-            &row_index, // &: adresse de row index
-            &value,
-          };
-          ldl = rank1_update(ldl, etree, perm_inv, w, alpha, stack);
-        }
-      } else {
-        refactorize(
-          work, results, kkt_active, active_constraints, data, stack, xtag);
-      }
-    }
-
-    results.info.mu_eq = new_bcl_mu_eq;
-    results.info.mu_in = new_bcl_mu_in;
-    results.info.mu_eq_inv = new_bcl_mu_eq_inv;
-    results.info.mu_in_inv = new_bcl_mu_in_inv;
-  }
-  LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
-  tmp.setZero();
-  detail::noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
-  precond.unscale_dual_residual_in_place({ proxqp::from_eigen, tmp });
-
-  precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
-  precond.unscale_dual_in_place_eq({ proxqp::from_eigen, y_e });
-  precond.unscale_dual_in_place_in({ proxqp::from_eigen, z_e });
-  tmp *= 0.5;
-  tmp += data.g;
-  results.info.objValue = (tmp).dot(x_e);
-
-  if (settings.compute_timings) {
-    results.info.solve_time = work.timer.elapsed().user; // in nanoseconds
-    results.info.run_time = results.info.solve_time + results.info.setup_time;
-  }
-  if (settings.verbose) {
-    std::cout << "-------------------SOLVER STATISTICS-------------------"
-              << std::endl;
-    std::cout << "outer iter:   " << results.info.iter_ext << std::endl;
-    std::cout << "total iter:   " << results.info.iter << std::endl;
-    std::cout << "mu updates:   " << results.info.mu_updates << std::endl;
-    std::cout << "rho updates:  " << results.info.rho_updates << std::endl;
-    std::cout << "objective:    " << results.info.objValue << std::endl;
-    switch (results.info.status) {
-      case QPSolverOutput::PROXQP_SOLVED: {
-        std::cout << "status:       "
-                  << "Solved" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_MAX_ITER_REACHED: {
-        std::cout << "status:       "
-                  << "Maximum number of iterations reached" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE: {
-        std::cout << "status:       "
-                  << "Primal infeasible" << std::endl;
-        break;
-      }
-      case QPSolverOutput::PROXQP_DUAL_INFEASIBLE: {
-        std::cout << "status:       "
-                  << "Dual infeasible" << std::endl;
-        break;
-      }
-      default: {
-        assert(false && "Should never happened");
-        break;
-      }
-    }
-    if (settings.compute_timings)
-      std::cout << "run time:     " << results.info.solve_time << std::endl;
-    std::cout << "--------------------------------------------------------"
-              << std::endl;
-  }
-
-  assert(!std::isnan(results.info.pri_res));
-  assert(!std::isnan(results.info.dua_res));
-  assert(!std::isnan(results.info.duality_gap));
-
-  work.set_dirty();
-}
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_SOLVER_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_SOLVER_HPP
+#define PROXSUITE_PROXQP_SPARSE_SOLVER_HPP
+
+#include <chrono>
+#include <cmath>
+
+#include <proxsuite/linalg/dense/core.hpp>
+#include <proxsuite/linalg/sparse/core.hpp>
+#include <proxsuite/linalg/sparse/factorize.hpp>
+#include <proxsuite/linalg/sparse/update.hpp>
+#include <proxsuite/linalg/sparse/rowmod.hpp>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+#include "proxsuite/proxqp/results.hpp"
+#include "proxsuite/proxqp/sparse/fwd.hpp"
+#include "proxsuite/proxqp/sparse/views.hpp"
+#include "proxsuite/proxqp/sparse/model.hpp"
+#include "proxsuite/proxqp/sparse/workspace.hpp"
+#include "proxsuite/proxqp/sparse/utils.hpp"
+#include "proxsuite/proxqp/sparse/preconditioner/ruiz.hpp"
+#include "proxsuite/proxqp/sparse/preconditioner/identity.hpp"
+
+#include <iostream>
+#include <iomanip>
+#include <Eigen/IterativeLinearSolvers>
+#include <unsupported/Eigen/IterativeSolvers>
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+template<typename T, typename I>
+void
+ldl_solve(VectorViewMut<T> sol,
+          VectorView<T> rhs,
+          isize n_tot,
+          proxsuite::linalg::sparse::MatMut<T, I> ldl,
+          Eigen::MINRES<detail::AugmentedKkt<T, I>,
+                        Eigen::Upper | Eigen::Lower,
+                        Eigen::IdentityPreconditioner>& iterative_solver,
+          bool do_ldlt,
+          proxsuite::linalg::veg::dynstack::DynStackMut stack,
+          T* ldl_values,
+          I* perm,
+          I* ldl_col_ptrs,
+          I const* perm_inv)
+{
+  LDLT_TEMP_VEC_UNINIT(T, work_, n_tot, stack);
+  auto rhs_e = rhs.to_eigen();
+  auto sol_e = sol.to_eigen();
+  auto zx = proxsuite::linalg::sparse::util::zero_extend;
+
+  if (do_ldlt) {
+
+    for (isize i = 0; i < n_tot; ++i) {
+      work_[i] = rhs_e[isize(zx(perm[i]))];
+    }
+
+    proxsuite::linalg::sparse::dense_lsolve<T, I>( //
+      { proxsuite::linalg::sparse::from_eigen, work_ },
+      ldl.as_const());
+
+    for (isize i = 0; i < n_tot; ++i) {
+      work_[i] /= ldl_values[isize(zx(ldl_col_ptrs[i]))];
+    }
+
+    proxsuite::linalg::sparse::dense_ltsolve<T, I>( //
+      { proxsuite::linalg::sparse::from_eigen, work_ },
+      ldl.as_const());
+
+    for (isize i = 0; i < n_tot; ++i) {
+      sol_e[i] = work_[isize(zx(perm_inv[i]))];
+    }
+  } else {
+    work_ = iterative_solver.solve(rhs_e);
+    sol_e = work_;
+  }
+}
+
+template<typename T, typename I>
+void
+ldl_iter_solve_noalias(
+  VectorViewMut<T> sol,
+  VectorView<T> rhs,
+  VectorView<T> init_guess,
+  Results<T> const& results,
+  Model<T, I> const& data,
+  isize n_tot,
+  proxsuite::linalg::sparse::MatMut<T, I> ldl,
+  Eigen::MINRES<detail::AugmentedKkt<T, I>,
+                Eigen::Upper | Eigen::Lower,
+                Eigen::IdentityPreconditioner>& iterative_solver,
+  bool do_ldlt,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack,
+  T* ldl_values,
+  I* perm,
+  I* ldl_col_ptrs,
+  I const* perm_inv,
+  Settings<T> const& settings,
+  proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
+  proxsuite::linalg::veg::SliceMut<bool> active_constraints)
+{
+  auto rhs_e = rhs.to_eigen();
+  auto sol_e = sol.to_eigen();
+
+  if (init_guess.dim == sol.dim) {
+    sol_e = init_guess.to_eigen();
+  } else {
+    sol_e.setZero();
+  }
+
+  LDLT_TEMP_VEC_UNINIT(T, err, n_tot, stack);
+
+  T prev_err_norm = std::numeric_limits<T>::infinity();
+
+  for (isize solve_iter = 0; solve_iter < settings.nb_iterative_refinement;
+       ++solve_iter) {
+
+    auto err_x = err.head(data.dim);
+    auto err_y = err.segment(data.dim, data.n_eq);
+    auto err_z = err.tail(data.n_in);
+
+    auto sol_x = sol_e.head(data.dim);
+    auto sol_y = sol_e.segment(data.dim, data.n_eq);
+    auto sol_z = sol_e.tail(data.n_in); // removed active set condition
+
+    err = -rhs_e;
+
+    if (solve_iter > 0) {
+      T mu_eq_neg = -results.info.mu_eq;
+      T mu_in_neg = -results.info.mu_in;
+      detail::noalias_symhiv_add(err, kkt_active.to_eigen(), sol_e);
+      err_x += results.info.rho * sol_x;
+      err_y += mu_eq_neg * sol_y;
+      for (isize i = 0; i < data.n_in; ++i) {
+        err_z[i] += (active_constraints[i] ? mu_in_neg : T(1)) * sol_z[i];
+      }
+    }
+
+    T err_norm = infty_norm(err);
+    if (err_norm > prev_err_norm / T(2)) {
+      break;
+    }
+    prev_err_norm = err_norm;
+
+    ldl_solve({ proxqp::from_eigen, err },
+              { proxqp::from_eigen, err },
+              n_tot,
+              ldl,
+              iterative_solver,
+              do_ldlt,
+              stack,
+              ldl_values,
+              perm,
+              ldl_col_ptrs,
+              perm_inv);
+
+    sol_e -= err;
+  }
+}
+/*!
+ * Solves in place a linear system.
+ *
+ * @param rhs right hand side vector of the linear system to solver.
+ * @param init_guess initial guess for solving the linear system
+ * @param ldl current ldlt.
+ * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
+ * algorithm).
+ * @param perm_inv pointer to the inverse of the permutation.
+ * @param results solver results.
+ * @param data model of the QP.
+ * @param n_tot dimension of the KKT matrix
+ * @param kkt_active active part of the KKT matrix.
+ * @param active_constraints vector boolean precising whether the constraints
+ * are active or not.
+ * @param iterative_solver iterative solver matrix free.
+ * @param stack memory stack.
+ * @param ldl_values pointor to ldl values.
+ * @param perm pointor to the ldl permutation.
+ * @param ldl_col_ptrs pointor to the column of the ldl.
+ * @param perm_inv pointor the inverse permutation.
+ * @param settings solver's settings.
+ * @param kkt_active active part of the kkt.
+ */
+template<typename T, typename I>
+void
+ldl_solve_in_place(
+  VectorViewMut<T> rhs,
+  VectorView<T> init_guess,
+  Results<T> const& results,
+  Model<T, I> const& data,
+  isize n_tot,
+  proxsuite::linalg::sparse::MatMut<T, I> ldl,
+  Eigen::MINRES<detail::AugmentedKkt<T, I>,
+                Eigen::Upper | Eigen::Lower,
+                Eigen::IdentityPreconditioner>& iterative_solver,
+  bool do_ldlt,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack,
+  T* ldl_values,
+  I* perm,
+  I* ldl_col_ptrs,
+  I const* perm_inv,
+  Settings<T> const& settings,
+  proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
+  proxsuite::linalg::veg::SliceMut<bool> active_constraints)
+{
+  LDLT_TEMP_VEC_UNINIT(T, tmp, n_tot, stack);
+  ldl_iter_solve_noalias({ proxqp::from_eigen, tmp },
+                         rhs.as_const(),
+                         init_guess,
+                         results,
+                         data,
+                         n_tot,
+                         ldl,
+                         iterative_solver,
+                         do_ldlt,
+                         stack,
+                         ldl_values,
+                         perm,
+                         ldl_col_ptrs,
+                         perm_inv,
+                         settings,
+                         kkt_active,
+                         active_constraints);
+  rhs.to_eigen() = tmp;
+}
+/*!
+ * Reconstructs manually the permutted matrix.
+ *
+ * @param ldl current ldlt.
+ * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
+ * algorithm).
+ */
+template<typename T, typename I>
+auto
+inner_reconstructed_matrix(proxsuite::linalg::sparse::MatMut<T, I> ldl)
+  -> DMat<T>
+{
+  auto ldl_dense = ldl.to_eigen().toDense();
+  auto l = DMat<T>(ldl_dense.template triangularView<Eigen::UnitLower>());
+  auto lt = l.transpose();
+  auto d = ldl_dense.diagonal().asDiagonal();
+  auto mat = DMat<T>(l * d * lt);
+  return mat;
+}
+/*!
+ * Reconstructs manually the value of the KKT matrix.
+ *
+ * @param ldl current ldlt.
+ * @param do_ldlt boolean variable for doing the ldlt (rather than MinRes
+ * algorithm).
+ * @param perm_inv pointer to the inverse of the permutation.
+ * @param n_tot dimension of the KKT matrix
+ */
+template<typename T, typename I>
+auto
+reconstructed_matrix(proxsuite::linalg::sparse::MatMut<T, I> ldl,
+                     I const* perm_inv,
+                     isize n_tot) -> DMat<T>
+{
+  auto mat = inner_reconstructed_matrix(ldl);
+  auto mat_backup = mat;
+  for (isize i = 0; i < n_tot; ++i) {
+    for (isize j = 0; j < n_tot; ++j) {
+      mat(i, j) = mat_backup(perm_inv[i], perm_inv[j]);
+    }
+  }
+  return mat;
+}
+/*!
+ * Derives the norm of the difference between current KKT and the one it should
+ * be (derived manually).
+ *
+ * @param ldl current ldlt.
+ * @param perm_inv pointer to the inverse of the permutation.
+ * @param results solver results.
+ * @param data model of the QP.
+ * @param n_tot dimension of the KKT matrix
+ * @param kkt_active active part of the KKT matrix.
+ * @param active_constraints vector boolean precising whether the constraints
+ * are active or not.
+ */
+template<typename T, typename I>
+auto
+reconstruction_error(proxsuite::linalg::sparse::MatMut<T, I> ldl,
+                     I const* perm_inv,
+                     Results<T> const& results,
+                     Model<T, I> const& data,
+                     isize n_tot,
+                     proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
+                     proxsuite::linalg::veg::SliceMut<bool> active_constraints)
+  -> DMat<T>
+{
+  T mu_eq_neg = -results.info.mu_eq;
+  T mu_in_neg = -results.info.mu_in;
+  auto diff = DMat<T>(
+    reconstructed_matrix(ldl, perm_inv, n_tot) -
+    DMat<T>(
+      DMat<T>(kkt_active.to_eigen()).template selfadjointView<Eigen::Upper>()));
+  diff.diagonal().head(data.dim).array() -= results.info.rho;
+  diff.diagonal().segment(data.dim, data.n_eq).array() -= mu_eq_neg;
+  for (isize i = 0; i < data.n_in; ++i) {
+    diff.diagonal()[data.dim + data.n_eq + i] -=
+      active_constraints[i] ? mu_in_neg : T(1);
+  }
+  return diff;
+}
+
+template<typename T>
+struct PrimalDualGradResult
+{
+  T a;
+  T b;
+  T grad;
+  VEG_REFLECT(PrimalDualGradResult, a, b, grad);
+};
+
+/*!
+ * Executes the PROXQP algorithm.
+ *
+ * @param results solver results.
+ * @param data QP problem model as defined by the user (without any scaling
+ * performed).
+ * @param settings solver settings.
+ * @param work solver workspace.
+ * @param precond preconditioner.
+ */
+template<typename T, typename I, typename P>
+void
+qp_solve(Results<T>& results,
+         Model<T, I>& data,
+         const Settings<T>& settings,
+         Workspace<T, I>& work,
+         P& precond)
+{
+  if (settings.compute_timings) {
+    work.timer.stop();
+    work.timer.start();
+  }
+
+  if (work.internal
+        .dirty) // the following is used when a solve has already been executed
+                // (and without any intermediary model update)
+  {
+    proxsuite::linalg::sparse::MatMut<T, I> kkt_unscaled =
+      data.kkt_mut_unscaled();
+
+    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
+      proxsuite::linalg::veg::unsafe, kkt_unscaled, data.dim);
+
+    proxsuite::linalg::sparse::MatMut<T, I> H_unscaled =
+      detail::middle_cols_mut(kkt_top_n_rows, 0, data.dim, data.H_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> AT_unscaled =
+      detail::middle_cols_mut(kkt_top_n_rows, data.dim, data.n_eq, data.A_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> CT_unscaled =
+      detail::middle_cols_mut(
+        kkt_top_n_rows, data.dim + data.n_eq, data.n_in, data.C_nnz);
+
+    SparseMat<T, I> H_triu =
+      H_unscaled.to_eigen().template triangularView<Eigen::Upper>();
+    sparse::QpView<T, I> qp = {
+      { proxsuite::linalg::sparse::from_eigen, H_triu },
+      { proxsuite::linalg::sparse::from_eigen, data.g },
+      { proxsuite::linalg::sparse::from_eigen, AT_unscaled.to_eigen() },
+      { proxsuite::linalg::sparse::from_eigen, data.b },
+      { proxsuite::linalg::sparse::from_eigen, CT_unscaled.to_eigen() },
+      { proxsuite::linalg::sparse::from_eigen, data.l },
+      { proxsuite::linalg::sparse::from_eigen, data.u }
+    };
+
+    switch (settings.initial_guess) { // the following is used when one solve
+                                      // has already been executed
+      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+        results.cleanup(settings);
+        break;
+      }
+      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+        // keep solutions but restart workspace and results
+        results.cold_start(settings);
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, results.x });
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+      case InitialGuessStatus::NO_INITIAL_GUESS: {
+        results.cleanup(settings);
+        break;
+      }
+      case InitialGuessStatus::WARM_START: {
+        results.cold_start(settings); // because there was already a solve,
+                                      // precond was already computed if set so
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            results.x }); // it contains the value given in entry for warm start
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+        // keep workspace and results solutions except statistics
+        results.cleanup_statistics();
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, results.x });
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+    }
+    work.setup_impl(
+      qp,
+      data,
+      settings,
+      false,
+      precond,
+      P::scale_qp_in_place_req(
+        proxsuite::linalg::veg::Tag<T>{}, data.dim, data.n_eq, data.n_in));
+
+  } else {
+    // the following is used for a first solve after initializing or updating
+    // the Qp object
+    switch (settings.initial_guess) {
+      case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+        break;
+      }
+      case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            results.x }); // meaningful for when there is an upate of the model
+                          // and one wants to warm start with previous result
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+      case InitialGuessStatus::NO_INITIAL_GUESS: {
+        break;
+      }
+      case InitialGuessStatus::WARM_START: {
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen, results.x });
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+      case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+        precond.scale_primal_in_place(
+          { proxsuite::proxqp::from_eigen,
+            results.x }); // meaningful for when there is an upate of the model
+                          // and one wants to warm start with previous result
+        precond.scale_dual_in_place_eq(
+          { proxsuite::proxqp::from_eigen, results.y });
+        precond.scale_dual_in_place_in(
+          { proxsuite::proxqp::from_eigen, results.z });
+        break;
+      }
+    }
+  }
+
+  if (settings.verbose) {
+    sparse::print_setup_header(settings, results, data);
+  }
+  using namespace proxsuite::linalg::veg::literals;
+  namespace util = proxsuite::linalg::sparse::util;
+  auto zx = util::zero_extend;
+
+  proxsuite::linalg::veg::dynstack::DynStackMut stack = work.stack_mut();
+
+  isize n = data.dim;
+  isize n_eq = data.n_eq;
+  isize n_in = data.n_in;
+  isize n_tot = n + n_eq + n_in;
+
+  VectorViewMut<T> x{ proxqp::from_eigen, results.x };
+  VectorViewMut<T> y{ proxqp::from_eigen, results.y };
+  VectorViewMut<T> z{ proxqp::from_eigen, results.z };
+
+  proxsuite::linalg::sparse::MatMut<T, I> kkt = data.kkt_mut();
+
+  auto kkt_top_n_rows =
+    detail::top_rows_mut_unchecked(proxsuite::linalg::veg::unsafe, kkt, n);
+
+  proxsuite::linalg::sparse::MatMut<T, I> H_scaled =
+    detail::middle_cols_mut(kkt_top_n_rows, 0, n, data.H_nnz);
+
+  proxsuite::linalg::sparse::MatMut<T, I> AT_scaled =
+    detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, data.A_nnz);
+
+  proxsuite::linalg::sparse::MatMut<T, I> CT_scaled =
+    detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, data.C_nnz);
+
+  auto& g_scaled_e = work.internal.g_scaled;
+  auto& b_scaled_e = work.internal.b_scaled;
+  auto& l_scaled_e = work.internal.l_scaled;
+  auto& u_scaled_e = work.internal.u_scaled;
+
+  QpViewMut<T, I> qp_scaled = {
+    H_scaled,
+    { proxsuite::linalg::sparse::from_eigen, g_scaled_e },
+    AT_scaled,
+    { proxsuite::linalg::sparse::from_eigen, b_scaled_e },
+    CT_scaled,
+    { proxsuite::linalg::sparse::from_eigen, l_scaled_e },
+    { proxsuite::linalg::sparse::from_eigen, u_scaled_e },
+  };
+
+  T const dual_feasibility_rhs_2 = infty_norm(data.g);
+
+  // auto ldl_col_ptrs = work.ldl_col_ptrs_mut();
+  auto ldl_col_ptrs = work.internal.ldl.col_ptrs.ptr_mut();
+  proxsuite::linalg::veg::Tag<I> itag;
+  proxsuite::linalg::veg::Tag<T> xtag;
+
+  bool do_ldlt = work.internal.do_ldlt;
+
+  isize ldlt_ntot = do_ldlt ? n_tot : 0;
+
+  auto _perm = stack.make_new_for_overwrite(itag, ldlt_ntot);
+
+  I* perm_inv = work.internal.ldl.perm_inv.ptr_mut();
+  I* perm = _perm.ptr_mut();
+
+  if (do_ldlt) {
+    // compute perm from perm_inv
+    for (isize i = 0; i < n_tot; ++i) {
+      perm[isize(zx(perm_inv[i]))] = I(i);
+    }
+  }
+
+  I* kkt_nnz_counts = work.internal.kkt_nnz_counts.ptr_mut();
+
+  auto& iterative_solver = *work.internal.matrix_free_solver.get();
+  isize C_active_nnz = 0;
+  switch (settings.initial_guess) {
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+      // H and A are always active
+      for (usize j = 0; j < usize(n + n_eq); ++j) {
+        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
+      }
+      // ineq constraints initially inactive
+      for (isize j = 0; j < n_in; ++j) {
+        kkt_nnz_counts[n + n_eq + j] = 0;
+        work.active_inequalities[j] = false;
+      }
+      break;
+    }
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+      // keep solutions + restart workspace and results except rho and mu : done
+      // in setup
+
+      // H and A are always active
+      for (usize j = 0; j < usize(n + n_eq); ++j) {
+        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
+      }
+      // keep constraints inactive from previous solution
+      for (isize j = 0; j < n_in; ++j) {
+        if (results.z(j) != 0) {
+          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
+                                           kkt.col_start(usize(n + n_eq + j)));
+          work.active_inequalities[j] = true;
+          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
+        } else {
+          kkt_nnz_counts[n + n_eq + j] = 0;
+          work.active_inequalities[j] = false;
+        }
+      }
+      break;
+    }
+    case InitialGuessStatus::NO_INITIAL_GUESS: {
+      // already set to zero in the setup
+      // H and A are always active
+      for (usize j = 0; j < usize(n + n_eq); ++j) {
+        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
+      }
+      // ineq constraints initially inactive
+      for (isize j = 0; j < n_in; ++j) {
+        kkt_nnz_counts[n + n_eq + j] = 0;
+        work.active_inequalities[j] = false;
+      }
+      break;
+    }
+    case InitialGuessStatus::WARM_START: {
+      // keep previous solution
+
+      // H and A are always active
+      for (usize j = 0; j < usize(n + n_eq); ++j) {
+        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
+      }
+      // keep constraints inactive from previous solution
+      for (isize j = 0; j < n_in; ++j) {
+        if (results.z(j) != 0) {
+          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
+                                           kkt.col_start(usize(n + n_eq + j)));
+          work.active_inequalities[j] = true;
+          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
+
+        } else {
+          kkt_nnz_counts[n + n_eq + j] = 0;
+          work.active_inequalities[j] = false;
+        }
+      }
+      break;
+    }
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+      // keep workspace and results solutions except statistics
+      // H and A are always active
+      for (usize j = 0; j < usize(n + n_eq); ++j) {
+        kkt_nnz_counts[isize(j)] = I(kkt.col_end(j) - kkt.col_start(j));
+      }
+      // keep constraints inactive from previous solution
+      for (isize j = 0; j < n_in; ++j) {
+        if (results.z(j) != 0) {
+          kkt_nnz_counts[n + n_eq + j] = I(kkt.col_end(usize(n + n_eq + j)) -
+                                           kkt.col_start(usize(n + n_eq + j)));
+          work.active_inequalities[j] = true;
+          C_active_nnz += kkt_nnz_counts[n + n_eq + j];
+        } else {
+          kkt_nnz_counts[n + n_eq + j] = 0;
+          work.active_inequalities[j] = false;
+        }
+      }
+      break;
+    }
+  }
+
+  proxsuite::linalg::sparse::MatMut<T, I> kkt_active = {
+    proxsuite::linalg::sparse::from_raw_parts,
+    n_tot,
+    n_tot,
+    data.H_nnz + data.A_nnz + C_active_nnz,
+    kkt.col_ptrs_mut(),
+    kkt_nnz_counts,
+    kkt.row_indices_mut(),
+    kkt.values_mut(),
+  };
+
+  I* etree = work.internal.ldl.etree.ptr_mut();
+  I* ldl_nnz_counts = work.internal.ldl.nnz_counts.ptr_mut();
+  I* ldl_row_indices = work.internal.ldl.row_indices.ptr_mut();
+  T* ldl_values = work.internal.ldl.values.ptr_mut();
+  proxsuite::linalg::veg::SliceMut<bool> active_constraints =
+    work.active_inequalities.as_mut();
+
+  proxsuite::linalg::sparse::MatMut<T, I> ldl = {
+    proxsuite::linalg::sparse::from_raw_parts,
+    n_tot,
+    n_tot,
+    0,
+    ldl_col_ptrs,
+    do_ldlt ? ldl_nnz_counts : nullptr, // si do_ldlt est vrai do ldl_nnz_counts
+    ldl_row_indices,
+    ldl_values,
+  };
+
+  T bcl_eta_ext_init = pow(T(0.1), settings.alpha_bcl);
+  T bcl_eta_ext = bcl_eta_ext_init;
+  T bcl_eta_in(1);
+  T eps_in_min = std::min(settings.eps_abs, T(1e-9));
+
+  auto x_e = x.to_eigen();
+  auto y_e = y.to_eigen();
+  auto z_e = z.to_eigen();
+  sparse::refactorize<T, I>(
+    work, results, kkt_active, active_constraints, data, stack, xtag);
+  switch (settings.initial_guess) {
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS: {
+      LDLT_TEMP_VEC_UNINIT(T, rhs, n_tot, stack);
+      LDLT_TEMP_VEC_UNINIT(T, no_guess, 0, stack);
+
+      rhs.head(n) = -g_scaled_e;
+      rhs.segment(n, n_eq) = b_scaled_e;
+      rhs.segment(n + n_eq, n_in).setZero();
+
+      ldl_solve_in_place({ proxqp::from_eigen, rhs },
+                         { proxqp::from_eigen, no_guess },
+                         results,
+                         data,
+                         n_tot,
+                         ldl,
+                         iterative_solver,
+                         do_ldlt,
+                         stack,
+                         ldl_values,
+                         perm,
+                         ldl_col_ptrs,
+                         perm_inv,
+                         settings,
+                         kkt_active,
+                         active_constraints);
+      x_e = rhs.head(n);
+      y_e = rhs.segment(n, n_eq);
+      z_e = rhs.segment(n + n_eq, n_in);
+      break;
+    }
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT: {
+      // keep solutions but restart workspace and results
+      break;
+    }
+    case InitialGuessStatus::NO_INITIAL_GUESS: {
+      // already set to zero in the setup
+      break;
+    }
+    case InitialGuessStatus::WARM_START: {
+      // keep previous solution
+      break;
+    }
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT: {
+      // keep workspace and results solutions except statistics
+      break;
+    }
+  }
+  T rhs_duality_gap(0);
+
+  for (isize iter = 0; iter < settings.max_iter; ++iter) {
+
+    results.info.iter_ext += 1;
+    if (iter == settings.max_iter) {
+      break;
+    }
+    T new_bcl_mu_eq = results.info.mu_eq;
+    T new_bcl_mu_in = results.info.mu_in;
+    T new_bcl_mu_eq_inv = results.info.mu_eq_inv;
+    T new_bcl_mu_in_inv = results.info.mu_in_inv;
+
+    {
+      T primal_feasibility_eq_rhs_0;
+      T primal_feasibility_in_rhs_0;
+
+      T dual_feasibility_rhs_0(0);
+      T dual_feasibility_rhs_1(0);
+      T dual_feasibility_rhs_3(0);
+
+      LDLT_TEMP_VEC_UNINIT(T, primal_residual_eq_scaled, n_eq, stack);
+      LDLT_TEMP_VEC_UNINIT(T, primal_residual_in_scaled_lo, n_in, stack);
+      LDLT_TEMP_VEC_UNINIT(T, primal_residual_in_scaled_up, n_in, stack);
+
+      LDLT_TEMP_VEC_UNINIT(T, dual_residual_scaled, n, stack);
+
+      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+      auto is_primal_feasible = [&](T primal_feasibility_lhs) -> bool {
+        T rhs_pri = settings.eps_abs;
+        if (settings.eps_rel != 0) {
+          rhs_pri +=
+            settings.eps_rel * std::max({ primal_feasibility_eq_rhs_0,
+                                          primal_feasibility_in_rhs_0 });
+        }
+        return primal_feasibility_lhs <= rhs_pri;
+      };
+      auto is_dual_feasible = [&](T dual_feasibility_lhs) -> bool {
+        T rhs_dua = settings.eps_abs;
+        if (settings.eps_rel != 0) {
+          rhs_dua += settings.eps_rel * std::max({
+                                          dual_feasibility_rhs_0,
+                                          dual_feasibility_rhs_1,
+                                          dual_feasibility_rhs_2,
+                                          dual_feasibility_rhs_3,
+                                        });
+        }
+
+        return dual_feasibility_lhs <= rhs_dua;
+      };
+      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+      VEG_BIND( // ?
+        auto,
+        (primal_feasibility_lhs, dual_feasibility_lhs),
+        detail::unscaled_primal_dual_residual(work,
+                                              results,
+                                              primal_residual_eq_scaled,
+                                              primal_residual_in_scaled_lo,
+                                              primal_residual_in_scaled_up,
+                                              dual_residual_scaled,
+                                              primal_feasibility_eq_rhs_0,
+                                              primal_feasibility_in_rhs_0,
+                                              dual_feasibility_rhs_0,
+                                              dual_feasibility_rhs_1,
+                                              dual_feasibility_rhs_3,
+                                              rhs_duality_gap,
+                                              precond,
+                                              data,
+                                              qp_scaled.as_const(),
+                                              detail::vec_mut(x_e),
+                                              detail::vec_mut(y_e),
+                                              detail::vec_mut(z_e),
+                                              stack));
+      /*put in debug mode
+      if (settings.verbose) {
+              std::cout << "-------- outer iteration: " << iter << " primal
+      residual "
+                                                      << primal_feasibility_lhs
+      << " dual residual "
+                                                      << dual_feasibility_lhs <<
+      " mu_in " << results.info.mu_in
+                                                      << " bcl_eta_ext " <<
+      bcl_eta_ext << " bcl_eta_in "
+                                                      << bcl_eta_in <<
+      std::endl;
+      }
+      */
+      if (settings.verbose) {
+        LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
+        tmp.setZero();
+        detail::noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
+        precond.unscale_dual_residual_in_place({ proxqp::from_eigen, tmp });
+
+        precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
+        precond.unscale_dual_in_place_eq({ proxqp::from_eigen, y_e });
+        precond.unscale_dual_in_place_in({ proxqp::from_eigen, z_e });
+        tmp *= 0.5;
+        tmp += data.g;
+        results.info.objValue = (tmp).dot(x_e);
+        std::cout << "\033[1;32m[outer iteration " << iter + 1 << "]\033[0m"
+                  << std::endl;
+        std::cout << std::scientific << std::setw(2) << std::setprecision(2)
+                  << "| primal residual=" << primal_feasibility_lhs
+                  << " | dual residual=" << dual_feasibility_lhs
+                  << " | duality gap=" << results.info.duality_gap
+                  << " | mu_in=" << results.info.mu_in
+                  << " | rho=" << results.info.rho << std::endl;
+        results.info.pri_res = primal_feasibility_lhs;
+        results.info.dua_res = dual_feasibility_lhs;
+        precond.scale_primal_in_place(VectorViewMut<T>{ from_eigen, x_e });
+        precond.scale_dual_in_place_eq(VectorViewMut<T>{ from_eigen, y_e });
+        precond.scale_dual_in_place_in(VectorViewMut<T>{ from_eigen, z_e });
+      }
+      if (is_primal_feasible(primal_feasibility_lhs) &&
+          is_dual_feasible(dual_feasibility_lhs)) {
+        if (settings.check_duality_gap) {
+          if (std::fabs(results.info.duality_gap) <=
+              settings.eps_duality_gap_abs +
+                settings.eps_duality_gap_rel * rhs_duality_gap) {
+            results.info.pri_res = primal_feasibility_lhs;
+            results.info.dua_res = dual_feasibility_lhs;
+            results.info.status = QPSolverOutput::PROXQP_SOLVED;
+            break;
+          }
+        } else {
+          results.info.pri_res = primal_feasibility_lhs;
+          results.info.dua_res = dual_feasibility_lhs;
+          results.info.status = QPSolverOutput::PROXQP_SOLVED;
+          break;
+        }
+      }
+
+      LDLT_TEMP_VEC_UNINIT(T, x_prev_e, n, stack);
+      LDLT_TEMP_VEC_UNINIT(T, y_prev_e, n_eq, stack);
+      LDLT_TEMP_VEC_UNINIT(T, z_prev_e, n_in, stack);
+      LDLT_TEMP_VEC(T, dw_prev, n_tot, stack);
+
+      x_prev_e = x_e;
+      y_prev_e = y_e;
+      z_prev_e = z_e;
+
+      // Cx + 1/mu_in * z_prev
+      primal_residual_in_scaled_up += results.info.mu_in * z_prev_e;
+      primal_residual_in_scaled_lo = primal_residual_in_scaled_up;
+
+      // Cx - l + 1/mu_in * z_prev
+      primal_residual_in_scaled_lo -= l_scaled_e;
+
+      // Cx - u + 1/mu_in * z_prev
+      primal_residual_in_scaled_up -= u_scaled_e;
+
+      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+      auto primal_dual_newton_semi_smooth = [&]() -> void {
+        for (isize iter_inner = 0; iter_inner < settings.max_iter_in;
+             ++iter_inner) {
+          LDLT_TEMP_VEC_UNINIT(T, dw, n_tot, stack);
+
+          if (iter_inner == settings.max_iter_in - 1) {
+            results.info.iter += settings.max_iter_in;
+            break;
+          }
+
+          // primal_dual_semi_smooth_newton_step
+          {
+            LDLT_TEMP_VEC_UNINIT(bool, new_active_constraints, n_in, stack);
+            auto rhs = dw;
+
+            work.active_set_low.array() =
+              primal_residual_in_scaled_lo.array() <= 0;
+            work.active_set_up.array() =
+              primal_residual_in_scaled_up.array() >= 0;
+            new_active_constraints = work.active_set_low || work.active_set_up;
+
+            // active set change
+            if (n_in > 0) {
+              bool removed = false;
+              bool added = false;
+
+              for (isize i = 0; i < n_in; ++i) {
+                bool was_active = active_constraints[i];
+                bool is_active = new_active_constraints[i];
+
+                isize idx = n + n_eq + i;
+
+                usize col_nnz =
+                  zx(kkt.col_end(usize(idx))) - zx(kkt.col_start(usize(idx)));
+
+                if (is_active && !was_active) {
+                  added = true;
+
+                  kkt_active.nnz_per_col_mut()[idx] = I(col_nnz);
+                  kkt_active._set_nnz(kkt_active.nnz() + isize(col_nnz));
+
+                  if (do_ldlt) {
+                    proxsuite::linalg::sparse::VecRef<T, I> new_col{
+                      proxsuite::linalg::sparse::from_raw_parts,
+                      n_tot,
+                      isize(col_nnz),
+                      kkt.row_indices() + zx(kkt.col_start(usize(idx))),
+                      kkt.values() + zx(kkt.col_start(usize(idx))),
+                    };
+
+                    ldl =
+                      proxsuite::linalg::sparse::add_row(ldl,
+                                                         etree,
+                                                         perm_inv,
+                                                         idx,
+                                                         new_col,
+                                                         -results.info.mu_in,
+                                                         stack);
+                  }
+                  active_constraints[i] = new_active_constraints[i];
+
+                } else if (!is_active && was_active) {
+                  removed = true;
+                  kkt_active.nnz_per_col_mut()[idx] = 0;
+                  kkt_active._set_nnz(kkt_active.nnz() - isize(col_nnz));
+                  if (do_ldlt) {
+                    ldl = proxsuite::linalg::sparse::delete_row(
+                      ldl, etree, perm_inv, idx, stack);
+                  }
+                  active_constraints[i] = new_active_constraints[i];
+                }
+              }
+
+              if (!do_ldlt) {
+                if (removed || added) {
+                  refactorize(work,
+                              results,
+                              kkt_active,
+                              active_constraints,
+                              data,
+                              stack,
+                              xtag);
+                }
+              }
+            }
+
+            rhs.head(n) = -dual_residual_scaled;
+            rhs.segment(n, n_eq) = -primal_residual_eq_scaled;
+
+            for (isize i = 0; i < n_in; ++i) {
+              if (work.active_set_up(i)) {
+                rhs(n + n_eq + i) =
+                  results.info.mu_in * z_e(i) - primal_residual_in_scaled_up(i);
+              } else if (work.active_set_low(i)) {
+                rhs(n + n_eq + i) =
+                  results.info.mu_in * z_e(i) - primal_residual_in_scaled_lo(i);
+              } else {
+                rhs(n + n_eq + i) = -z_e(i);
+                rhs.head(n) += z_e(i) * CT_scaled.to_eigen().col(i);
+              }
+            }
+
+            ldl_solve_in_place(
+              { proxqp::from_eigen, rhs },
+              { proxqp::from_eigen,
+                dw_prev }, // todo: MAJ dw_prev avec dw pour avoir meilleur
+                           // guess sur les solve in place
+              results,
+              data,
+              n_tot,
+              ldl,
+              iterative_solver,
+              do_ldlt,
+              stack,
+              ldl_values,
+              perm,
+              ldl_col_ptrs,
+              perm_inv,
+              settings,
+              kkt_active,
+              active_constraints);
+          }
+          auto dx = dw.head(n);
+          auto dy = dw.segment(n, n_eq);
+          auto dz = dw.segment(n + n_eq, n_in);
+
+          LDLT_TEMP_VEC(T, Hdx, n, stack);
+          LDLT_TEMP_VEC(T, Adx, n_eq, stack);
+          LDLT_TEMP_VEC(T, Cdx, n_in, stack);
+
+          LDLT_TEMP_VEC(T, ATdy, n, stack);
+          LDLT_TEMP_VEC(T, CTdz, n, stack);
+
+          detail::noalias_symhiv_add(Hdx, H_scaled.to_eigen(), dx);
+          detail::noalias_gevmmv_add(Adx, ATdy, AT_scaled.to_eigen(), dx, dy);
+          detail::noalias_gevmmv_add(Cdx, CTdz, CT_scaled.to_eigen(), dx, dz);
+
+          T alpha = 1;
+          // primal dual line search
+          if (n_in > 0) {
+            auto primal_dual_gradient_norm =
+              [&](T alpha_cur) -> PrimalDualGradResult<T> {
+              LDLT_TEMP_VEC_UNINIT(T, Cdx_active, n_in, stack);
+              LDLT_TEMP_VEC_UNINIT(T, active_part_z, n_in, stack);
+              {
+                LDLT_TEMP_VEC_UNINIT(T, tmp_lo, n_in, stack);
+                LDLT_TEMP_VEC_UNINIT(T, tmp_up, n_in, stack);
+
+                auto zero = Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(n_in);
+
+                tmp_lo = primal_residual_in_scaled_lo + alpha_cur * Cdx;
+                tmp_up = primal_residual_in_scaled_up + alpha_cur * Cdx;
+                Cdx_active =
+                  (tmp_lo.array() < 0 || tmp_up.array() > 0).select(Cdx, zero);
+                active_part_z = (tmp_lo.array() < 0)
+                                  .select(primal_residual_in_scaled_lo, zero) +
+                                (tmp_up.array() > 0)
+                                  .select(primal_residual_in_scaled_up, zero);
+              }
+
+              T a = dx.dot(Hdx) +                         //
+                    results.info.rho * dx.squaredNorm() + //
+                    results.info.mu_eq_inv * Adx.squaredNorm() +
+                    +results.info.mu_in_inv * Cdx_active.squaredNorm() +
+                    results.info.nu * results.info.mu_eq *
+                      (results.info.mu_eq_inv * Adx - dy).squaredNorm() +
+                    results.info.nu * results.info.mu_in *
+                      (results.info.mu_in_inv * Cdx_active - dz).squaredNorm();
+
+              T b =
+                x_e.dot(Hdx) +                                               //
+                (results.info.rho * (x_e - x_prev_e) + g_scaled_e).dot(dx) + //
+                Adx.dot(results.info.mu_eq_inv * primal_residual_eq_scaled +
+                        y_e) +                                           //
+                results.info.mu_in_inv * Cdx_active.dot(active_part_z) + //
+                results.info.nu * primal_residual_eq_scaled.dot(
+                                    results.info.mu_eq_inv * Adx - dy) + //
+                results.info.nu *
+                  (active_part_z - results.info.mu_in * z_e)
+                    .dot(results.info.mu_in_inv * Cdx_active - dz);
+
+              return {
+                a,
+                b,
+                a * alpha_cur + b,
+              };
+            };
+
+            LDLT_TEMP_VEC_UNINIT(T, alphas, 2 * n_in, stack);
+            isize alphas_count = 0;
+
+            for (isize i = 0; i < n_in; ++i) {
+              T alpha_candidates[2] = {
+                -primal_residual_in_scaled_lo(i) / (Cdx(i)),
+                -primal_residual_in_scaled_up(i) / (Cdx(i)),
+              };
+
+              for (auto alpha_candidate : alpha_candidates) {
+                if (alpha_candidate > 0) {
+                  alphas[alphas_count] = alpha_candidate;
+                  ++alphas_count;
+                }
+              }
+            }
+            std::sort(alphas.data(), alphas.data() + alphas_count);
+            alphas_count =
+              std::unique(alphas.data(), alphas.data() + alphas_count) -
+              alphas.data();
+
+            if (alphas_count > 0 && alphas[0] <= 1) {
+              auto infty = std::numeric_limits<T>::infinity();
+
+              T last_neg_grad = 0;
+              T alpha_last_neg = 0;
+              T first_pos_grad = 0;
+              T alpha_first_pos = infty;
+
+              {
+                for (isize i = 0; i < alphas_count; ++i) {
+                  T alpha_cur = alphas[i];
+                  T gr = primal_dual_gradient_norm(alpha_cur).grad;
+
+                  if (gr < 0) {
+                    alpha_last_neg = alpha_cur;
+                    last_neg_grad = gr;
+                  } else {
+                    first_pos_grad = gr;
+                    alpha_first_pos = alpha_cur;
+                    break;
+                  }
+                }
+
+                if (alpha_last_neg == 0) {
+                  last_neg_grad =
+                    primal_dual_gradient_norm(alpha_last_neg).grad;
+                }
+
+                if (alpha_first_pos == infty) {
+                  auto res = primal_dual_gradient_norm(2 * alpha_last_neg + 1);
+                  alpha = -res.b / res.a;
+                } else {
+                  alpha = alpha_last_neg -
+                          last_neg_grad * (alpha_first_pos - alpha_last_neg) /
+                            (first_pos_grad - last_neg_grad);
+                }
+              }
+            } else {
+              auto res = primal_dual_gradient_norm(T(0));
+              alpha = -res.b / res.a;
+            }
+          }
+          if (alpha * infty_norm(dw) < T(1e-11) && iter_inner > 0) {
+            results.info.iter += iter_inner + 1;
+            return;
+          }
+
+          x_e += alpha * dx;
+          y_e += alpha * dy;
+          z_e += alpha * dz;
+
+          dual_residual_scaled +=
+            alpha * (Hdx + ATdy + CTdz + results.info.rho * dx);
+          primal_residual_eq_scaled += alpha * (Adx - results.info.mu_eq * dy);
+          primal_residual_in_scaled_lo += alpha * Cdx;
+          primal_residual_in_scaled_up += alpha * Cdx;
+
+          T err_in = std::max({
+            (infty_norm(helpers::negative_part(primal_residual_in_scaled_lo) +
+                        helpers::positive_part(primal_residual_in_scaled_up) -
+                        results.info.mu_in * z_e)),
+            (infty_norm(primal_residual_eq_scaled)),
+            (infty_norm(dual_residual_scaled)),
+          });
+          /* put in debug mode
+          if (settings.verbose) {
+                  std::cout << "--inner iter " << iter_inner << " iner error "
+                                                          << err_in << " alpha "
+          << alpha << " infty_norm(dw) "
+                                                          << infty_norm(dw) <<
+          std::endl;
+          }
+          */
+          if (settings.verbose) {
+            std::cout << "\033[1;34m[inner iteration " << iter_inner + 1
+                      << "]\033[0m" << std::endl;
+            std::cout << std::scientific << std::setw(2) << std::setprecision(2)
+                      << "| inner residual=" << err_in << " | alpha=" << alpha
+                      << std::endl;
+          }
+          if (err_in <= bcl_eta_in) {
+            results.info.iter += iter_inner + 1;
+            return;
+          }
+
+          // compute primal and dual infeasibility criteria
+          bool is_primal_infeasible = proxsuite::proxqp::sparse::detail::
+            global_primal_residual_infeasibility(
+              VectorViewMut<T>{ from_eigen, ATdy },
+              VectorViewMut<T>{ from_eigen, CTdz },
+              VectorViewMut<T>{ from_eigen, dy },
+              VectorViewMut<T>{ from_eigen, dz },
+              qp_scaled.as_const(),
+              settings,
+              precond);
+          bool is_dual_infeasible = proxsuite::proxqp::sparse::detail::
+            global_dual_residual_infeasibility(
+              VectorViewMut<T>{ from_eigen, Adx },
+              VectorViewMut<T>{ from_eigen, Cdx },
+              VectorViewMut<T>{ from_eigen, Hdx },
+              VectorViewMut<T>{ from_eigen, dx },
+              qp_scaled.as_const(),
+              settings,
+              data,
+              precond);
+          if (is_primal_infeasible) {
+            results.info.status = QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE;
+            dw_prev = dw;
+            break;
+          } else if (is_dual_infeasible) {
+            results.info.status = QPSolverOutput::PROXQP_DUAL_INFEASIBLE;
+            dw_prev = dw;
+            break;
+          }
+        }
+      };
+      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+      primal_dual_newton_semi_smooth();
+      if (results.info.status == QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE ||
+          results.info.status == QPSolverOutput::PROXQP_DUAL_INFEASIBLE) {
+        // certificate of infeasibility
+        results.x = dw_prev.head(data.dim);
+        results.y = dw_prev.segment(data.dim, data.n_eq);
+        results.z = dw_prev.tail(data.n_in);
+        break;
+      }
+      // VEG bind : met le résultat tuple de unscaled_primal_dual_residual dans
+      // (primal_feasibility_lhs_new, dual_feasibility_lhs_new) en guessant leur
+      // type via auto
+      VEG_BIND(
+        auto,
+        (primal_feasibility_lhs_new, dual_feasibility_lhs_new),
+        detail::unscaled_primal_dual_residual(work,
+                                              results,
+                                              primal_residual_eq_scaled,
+                                              primal_residual_in_scaled_lo,
+                                              primal_residual_in_scaled_up,
+                                              dual_residual_scaled,
+                                              primal_feasibility_eq_rhs_0,
+                                              primal_feasibility_in_rhs_0,
+                                              dual_feasibility_rhs_0,
+                                              dual_feasibility_rhs_1,
+                                              dual_feasibility_rhs_3,
+                                              rhs_duality_gap,
+                                              precond,
+                                              data,
+                                              qp_scaled.as_const(),
+                                              detail::vec_mut(x_e),
+                                              detail::vec_mut(y_e),
+                                              detail::vec_mut(z_e),
+                                              stack));
+
+      if (is_primal_feasible(primal_feasibility_lhs_new) &&
+          is_dual_feasible(dual_feasibility_lhs_new)) {
+        if (settings.check_duality_gap) {
+          if (std::fabs(results.info.duality_gap) <=
+              settings.eps_duality_gap_abs +
+                settings.eps_duality_gap_rel * rhs_duality_gap) {
+            results.info.pri_res = primal_feasibility_lhs_new;
+            results.info.dua_res = dual_feasibility_lhs_new;
+            results.info.status = QPSolverOutput::PROXQP_SOLVED;
+            break;
+          }
+        } else {
+          results.info.pri_res = primal_feasibility_lhs_new;
+          results.info.dua_res = dual_feasibility_lhs_new;
+          results.info.status = QPSolverOutput::PROXQP_SOLVED;
+          break;
+        }
+      }
+
+      // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
+      auto bcl_update = [&]() -> void {
+        if (primal_feasibility_lhs_new <= bcl_eta_ext ||
+            iter > settings.safe_guard) {
+          bcl_eta_ext *= pow(results.info.mu_in, settings.beta_bcl);
+          bcl_eta_in = std::max(bcl_eta_in * results.info.mu_in, eps_in_min);
+
+        } else {
+          y_e = y_prev_e;
+          z_e = z_prev_e;
+          new_bcl_mu_in = std::max(
+            results.info.mu_in * settings.mu_update_factor, settings.mu_min_in);
+          new_bcl_mu_eq = std::max(
+            results.info.mu_eq * settings.mu_update_factor, settings.mu_min_eq);
+
+          new_bcl_mu_in_inv =
+            std::min(results.info.mu_in_inv * settings.mu_update_inv_factor,
+                     settings.mu_max_in_inv);
+          new_bcl_mu_eq_inv =
+            std::min(results.info.mu_eq_inv * settings.mu_update_inv_factor,
+                     settings.mu_max_eq_inv);
+          bcl_eta_ext =
+            bcl_eta_ext_init * pow(new_bcl_mu_in, settings.alpha_bcl);
+          bcl_eta_in = std::max(new_bcl_mu_in, eps_in_min);
+        }
+      };
+      // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+      bcl_update();
+
+      VEG_BIND(
+        auto,
+        (_, dual_feasibility_lhs_new_2),
+        detail::unscaled_primal_dual_residual(work,
+                                              results,
+                                              primal_residual_eq_scaled,
+                                              primal_residual_in_scaled_lo,
+                                              primal_residual_in_scaled_up,
+                                              dual_residual_scaled,
+                                              primal_feasibility_eq_rhs_0,
+                                              primal_feasibility_in_rhs_0,
+                                              dual_feasibility_rhs_0,
+                                              dual_feasibility_rhs_1,
+                                              dual_feasibility_rhs_3,
+                                              rhs_duality_gap,
+                                              precond,
+                                              data,
+                                              qp_scaled.as_const(),
+                                              detail::vec_mut(x_e),
+                                              detail::vec_mut(y_e),
+                                              detail::vec_mut(z_e),
+                                              stack));
+      proxsuite::linalg::veg::unused(_);
+
+      if (primal_feasibility_lhs_new >= primal_feasibility_lhs && //
+          dual_feasibility_lhs_new_2 >= primal_feasibility_lhs && //
+          results.info.mu_in <= T(1.E-5)) {
+        new_bcl_mu_in = settings.cold_reset_mu_in;
+        new_bcl_mu_eq = settings.cold_reset_mu_eq;
+        new_bcl_mu_in_inv = settings.cold_reset_mu_in_inv;
+        new_bcl_mu_eq_inv = settings.cold_reset_mu_eq_inv;
+      }
+    }
+    if (results.info.mu_in != new_bcl_mu_in ||
+        results.info.mu_eq != new_bcl_mu_eq) {
+      {
+        ++results.info.mu_updates;
+      }
+      /*
+      refactorize(
+                      work,
+                      results,
+                      kkt_active,
+                      active_constraints,
+                      data,
+                      stack,
+                      xtag);
+      */
+      if (work.internal.do_ldlt) {
+        isize w_values = 1; // un seul elt non nul
+        T alpha = 0;
+        for (isize j = 0; j < n_eq + n_in; ++j) {
+          I row_index = I(j + n);
+          if (j < n_eq) {
+            alpha = results.info.mu_eq - new_bcl_mu_eq;
+
+          } else {
+            if (!work.active_inequalities[j - n_eq]) {
+              continue;
+            }
+            alpha = results.info.mu_in - new_bcl_mu_in;
+          }
+          T value = 1;
+          proxsuite::linalg::sparse::VecRef<T, I> w{
+            proxsuite::linalg::veg::from_raw_parts,
+            n + n_eq + n_in,
+            w_values,
+            &row_index, // &: adresse de row index
+            &value,
+          };
+          ldl = rank1_update(ldl, etree, perm_inv, w, alpha, stack);
+        }
+      } else {
+        refactorize(
+          work, results, kkt_active, active_constraints, data, stack, xtag);
+      }
+    }
+
+    results.info.mu_eq = new_bcl_mu_eq;
+    results.info.mu_in = new_bcl_mu_in;
+    results.info.mu_eq_inv = new_bcl_mu_eq_inv;
+    results.info.mu_in_inv = new_bcl_mu_in_inv;
+  }
+  LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
+  tmp.setZero();
+  detail::noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
+  precond.unscale_dual_residual_in_place({ proxqp::from_eigen, tmp });
+
+  precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
+  precond.unscale_dual_in_place_eq({ proxqp::from_eigen, y_e });
+  precond.unscale_dual_in_place_in({ proxqp::from_eigen, z_e });
+  tmp *= 0.5;
+  tmp += data.g;
+  results.info.objValue = (tmp).dot(x_e);
+
+  if (settings.compute_timings) {
+    results.info.solve_time = work.timer.elapsed().user; // in nanoseconds
+    results.info.run_time = results.info.solve_time + results.info.setup_time;
+  }
+  if (settings.verbose) {
+    std::cout << "-------------------SOLVER STATISTICS-------------------"
+              << std::endl;
+    std::cout << "outer iter:   " << results.info.iter_ext << std::endl;
+    std::cout << "total iter:   " << results.info.iter << std::endl;
+    std::cout << "mu updates:   " << results.info.mu_updates << std::endl;
+    std::cout << "rho updates:  " << results.info.rho_updates << std::endl;
+    std::cout << "objective:    " << results.info.objValue << std::endl;
+    switch (results.info.status) {
+      case QPSolverOutput::PROXQP_SOLVED: {
+        std::cout << "status:       "
+                  << "Solved" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_MAX_ITER_REACHED: {
+        std::cout << "status:       "
+                  << "Maximum number of iterations reached" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_PRIMAL_INFEASIBLE: {
+        std::cout << "status:       "
+                  << "Primal infeasible" << std::endl;
+        break;
+      }
+      case QPSolverOutput::PROXQP_DUAL_INFEASIBLE: {
+        std::cout << "status:       "
+                  << "Dual infeasible" << std::endl;
+        break;
+      }
+      default: {
+        assert(false && "Should never happened");
+        break;
+      }
+    }
+    if (settings.compute_timings)
+      std::cout << "run time:     " << results.info.solve_time << std::endl;
+    std::cout << "--------------------------------------------------------"
+              << std::endl;
+  }
+
+  assert(!std::isnan(results.info.pri_res));
+  assert(!std::isnan(results.info.dua_res));
+  assert(!std::isnan(results.info.duality_gap));
+
+  work.set_dirty();
+}
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_SOLVER_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/sparse.hpp

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-#ifndef PROXSUITE_PROXQP_SPARSE_SPARSE_HPP
-#define PROXSUITE_PROXQP_SPARSE_SPARSE_HPP
-
-#include "proxsuite/proxqp/sparse/wrapper.hpp" // includes everything
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_SPARSE_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+#ifndef PROXSUITE_PROXQP_SPARSE_SPARSE_HPP
+#define PROXSUITE_PROXQP_SPARSE_SPARSE_HPP
+
+#include "proxsuite/proxqp/sparse/wrapper.hpp" // includes everything
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_SPARSE_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/utils.hpp

 * *Ordering differences only*

```diff
@@ -1,815 +1,815 @@
-//
-// Copyright (c) 2022-2023 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_UTILS_HPP
-#define PROXSUITE_PROXQP_SPARSE_UTILS_HPP
-
-#include <iostream>
-#include <Eigen/IterativeLinearSolvers>
-#include <unsupported/Eigen/IterativeSolvers>
-
-#include "proxsuite/helpers/common.hpp"
-#include <proxsuite/linalg/dense/core.hpp>
-#include <proxsuite/linalg/sparse/core.hpp>
-#include "proxsuite/proxqp/sparse/workspace.hpp"
-#include <proxsuite/linalg/sparse/factorize.hpp>
-#include <proxsuite/linalg/sparse/update.hpp>
-#include <proxsuite/linalg/sparse/rowmod.hpp>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-#include "proxsuite/proxqp/results.hpp"
-#include "proxsuite/proxqp/utils/prints.hpp"
-#include "proxsuite/proxqp/sparse/views.hpp"
-#include "proxsuite/proxqp/sparse/model.hpp"
-#include "proxsuite/proxqp/sparse/preconditioner/ruiz.hpp"
-#include "proxsuite/proxqp/sparse/preconditioner/identity.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-template<typename T, typename I>
-void
-print_setup_header(const Settings<T>& settings,
-                   Results<T>& results,
-                   const Model<T, I>& model)
-{
-
-  proxsuite::proxqp::print_preambule();
-
-  // Print variables and constraints
-  std::cout << "problem:  " << std::noshowpos << std::endl;
-  std::cout << "          variables n = " << model.dim
-            << ", equality constraints n_eq = " << model.n_eq << ",\n"
-            << "          inequality constraints n_in = " << model.n_in
-            << ", nnz = " << model.H_nnz + model.A_nnz + model.C_nnz << ",\n"
-            << std::endl;
-
-  // Print Settings
-  std::cout << "settings: " << std::endl;
-  std::cout << "          backend = sparse," << std::endl;
-  std::cout << "          sparse_backend = " << settings.sparse_backend;
-  if (settings.sparse_backend == SparseBackend::Automatic) {
-    std::cout << " -> " << results.info.sparse_backend;
-  }
-  std::cout << "," << std::endl;
-  std::cout << "          eps_abs = " << settings.eps_abs
-            << ", eps_rel = " << settings.eps_rel << std::endl;
-  std::cout << "          eps_prim_inf = " << settings.eps_primal_inf
-            << ", eps_dual_inf = " << settings.eps_dual_inf << "," << std::endl;
-
-  std::cout << "          rho = " << results.info.rho
-            << ", mu_eq = " << results.info.mu_eq
-            << ", mu_in = " << results.info.mu_in << "," << std::endl;
-  std::cout << "          max_iter = " << settings.max_iter
-            << ", max_iter_in = " << settings.max_iter_in << "," << std::endl;
-
-  if (settings.compute_preconditioner) {
-    std::cout << "          scaling: on, " << std::endl;
-  } else {
-    std::cout << "          scaling: off, " << std::endl;
-  }
-  if (settings.compute_timings) {
-    std::cout << "          timings: on, " << std::endl;
-  } else {
-    std::cout << "          timings: off, " << std::endl;
-  }
-  switch (settings.initial_guess) {
-    case InitialGuessStatus::WARM_START:
-      std::cout << "          initial guess: warm start. \n" << std::endl;
-      break;
-    case InitialGuessStatus::NO_INITIAL_GUESS:
-      std::cout << "          initial guess: initial guess. \n" << std::endl;
-      break;
-    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT:
-      std::cout
-        << "          initial guess: warm start with previous result. \n"
-        << std::endl;
-      break;
-    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT:
-      std::cout
-        << "          initial guess: cold start with previous result. \n"
-        << std::endl;
-      break;
-    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS:
-      std::cout
-        << "          initial guess: equality constrained initial guess. \n"
-        << std::endl;
-  }
-}
-
-namespace detail {
-
-template<typename T, typename I>
-VEG_NO_INLINE void
-noalias_gevmmv_add_impl( //
-  VectorViewMut<T> out_l,
-  VectorViewMut<T> out_r,
-  proxsuite::linalg::sparse::MatRef<T, I> a,
-  VectorView<T> in_l,
-  VectorView<T> in_r)
-{
-  VEG_ASSERT_ALL_OF /* NOLINT */ (a.nrows() == out_r.dim,
-                                  a.ncols() == in_r.dim,
-                                  a.ncols() == out_l.dim,
-                                  a.nrows() == in_l.dim);
-  // equivalent to
-  // out_r.to_eigen().noalias() += a.to_eigen() * in_r.to_eigen();
-  // out_l.to_eigen().noalias() += a.to_eigen().transpose() * in_l.to_eigen();
-
-  auto* ai = a.row_indices();
-  auto* ax = a.values();
-  auto n = a.ncols();
-
-  for (usize j = 0; j < usize(n); ++j) {
-    usize col_start = a.col_start(j);
-    usize col_end = a.col_end(j);
-
-    T acc0 = 0;
-    T acc1 = 0;
-    T acc2 = 0;
-    T acc3 = 0;
-
-    T in_rj = in_r(isize(j));
-
-    usize pcount = col_end - col_start;
-
-    usize p = col_start;
-
-    auto zx = proxsuite::linalg::sparse::util::zero_extend;
-
-    for (; p < col_start + pcount / 4 * 4; p += 4) {
-      auto i0 = isize(zx(ai[p + 0]));
-      auto i1 = isize(zx(ai[p + 1]));
-      auto i2 = isize(zx(ai[p + 2]));
-      auto i3 = isize(zx(ai[p + 3]));
-
-      T ai0j = ax[p + 0];
-      T ai1j = ax[p + 1];
-      T ai2j = ax[p + 2];
-      T ai3j = ax[p + 3];
-
-      out_r(i0) += ai0j * in_rj;
-      out_r(i1) += ai1j * in_rj;
-      out_r(i2) += ai2j * in_rj;
-      out_r(i3) += ai3j * in_rj;
-
-      acc0 += ai0j * in_l(i0);
-      acc1 += ai1j * in_l(i1);
-      acc2 += ai2j * in_l(i2);
-      acc3 += ai3j * in_l(i3);
-    }
-
-    for (; p < col_end; ++p) {
-      auto i = isize(zx(ai[p]));
-
-      T aij = ax[p];
-      out_r(i) += aij * in_rj;
-      acc0 += aij * in_l(i);
-    }
-
-    acc0 = ((acc0 + acc1) + (acc2 + acc3));
-    out_l(isize(j)) += acc0;
-  }
-}
-
-template<typename T, typename I>
-VEG_NO_INLINE void
-noalias_symhiv_add_impl( //
-  VectorViewMut<T> out,
-  proxsuite::linalg::sparse::MatRef<T, I> a,
-  VectorView<T> in)
-{
-  VEG_ASSERT_ALL_OF /* NOLINT */ ( //
-    a.nrows() == a.ncols(),
-    a.nrows() == out.dim,
-    a.ncols() == in.dim);
-  // equivalent to
-  // out.to_eigen().noalias() +=
-  // 		a.to_eigen().template selfadjointView<Eigen::Upper>() *
-  // in.to_eigen();
-
-  auto* ai = a.row_indices();
-  auto* ax = a.values();
-  auto n = a.ncols();
-
-  for (usize j = 0; j < usize(n); ++j) {
-    usize col_start = a.col_start(j);
-    usize col_end = a.col_end(j);
-
-    if (col_start == col_end) {
-      continue;
-    }
-
-    T acc0 = 0;
-    T acc1 = 0;
-    T acc2 = 0;
-    T acc3 = 0;
-
-    T in_j = in(isize(j));
-
-    usize pcount = col_end - col_start;
-
-    auto zx = proxsuite::linalg::sparse::util::zero_extend;
-
-    if (zx(ai[col_end - 1]) == j) {
-      T ajj = ax[col_end - 1];
-      out(isize(j)) += ajj * in_j;
-      pcount -= 1;
-    }
-
-    usize p = col_start;
-
-    for (; p < col_start + pcount / 4 * 4; p += 4) {
-      auto i0 = isize(zx(ai[p + 0]));
-      auto i1 = isize(zx(ai[p + 1]));
-      auto i2 = isize(zx(ai[p + 2]));
-      auto i3 = isize(zx(ai[p + 3]));
-
-      T ai0j = ax[p + 0];
-      T ai1j = ax[p + 1];
-      T ai2j = ax[p + 2];
-      T ai3j = ax[p + 3];
-
-      out(i0) += ai0j * in_j;
-      out(i1) += ai1j * in_j;
-      out(i2) += ai2j * in_j;
-      out(i3) += ai3j * in_j;
-
-      acc0 += ai0j * in(i0);
-      acc1 += ai1j * in(i1);
-      acc2 += ai2j * in(i2);
-      acc3 += ai3j * in(i3);
-    }
-    for (; p < col_start + pcount; ++p) {
-      auto i = isize(zx(ai[p]));
-
-      T aij = ax[p];
-      out(i) += aij * in_j;
-      acc0 += aij * in(i);
-    }
-    acc0 = ((acc0 + acc1) + (acc2 + acc3));
-    out(isize(j)) += acc0;
-  }
-}
-
-template<typename OutL, typename OutR, typename A, typename InL, typename InR>
-void
-noalias_gevmmv_add(OutL&& out_l,
-                   OutR&& out_r,
-                   A const& a,
-                   InL const& in_l,
-                   InR const& in_r)
-{
-  // noalias general vector matrix matrix vector add
-  noalias_gevmmv_add_impl<typename A::Scalar, typename A::StorageIndex>(
-    { proxqp::from_eigen, out_l },
-    { proxqp::from_eigen, out_r },
-    { proxsuite::linalg::sparse::from_eigen, a },
-    { proxqp::from_eigen, in_l },
-    { proxqp::from_eigen, in_r });
-}
-
-template<typename Out, typename A, typename In>
-void
-noalias_symhiv_add(Out&& out, A const& a, In const& in)
-{
-  // noalias symmetric (hi) matrix vector add
-  noalias_symhiv_add_impl<typename A::Scalar, typename A::StorageIndex>(
-    { proxqp::from_eigen, out },
-    { proxsuite::linalg::sparse::from_eigen, a },
-    { proxqp::from_eigen, in });
-}
-
-template<typename T, typename I>
-struct AugmentedKkt : Eigen::EigenBase<AugmentedKkt<T, I>>
-{
-  struct Raw /* NOLINT */
-  {
-    proxsuite::linalg::sparse::MatRef<T, I> kkt_active;
-    proxsuite::linalg::veg::Slice<bool> active_constraints;
-    isize n;
-    isize n_eq;
-    isize n_in;
-    T rho;
-    T mu_eq;
-    T mu_in;
-  } _;
-
-  AugmentedKkt /* NOLINT */ (Raw raw) noexcept
-    : _{ raw }
-  {
-  }
-
-  using Scalar = T;
-  using RealScalar = T;
-  using StorageIndex = I;
-  enum
-  {
-    ColsAtCompileTime = Eigen::Dynamic,
-    MaxColsAtCompileTime = Eigen::Dynamic,
-    IsRowMajor = false,
-  };
-
-  auto rows() const noexcept -> isize { return _.n + _.n_eq + _.n_in; }
-  auto cols() const noexcept -> isize { return rows(); }
-  template<typename Rhs>
-  auto operator*(Eigen::MatrixBase<Rhs> const& x) const
-    -> Eigen::Product<AugmentedKkt, Rhs, Eigen::AliasFreeProduct>
-  {
-    return Eigen::Product< //
-      AugmentedKkt,
-      Rhs,
-      Eigen::AliasFreeProduct>{
-      *this,
-      x.derived(),
-    };
-  }
-};
-
-template<typename T>
-using VecMapMut = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1>,
-                             Eigen::Unaligned,
-                             Eigen::Stride<Eigen::Dynamic, 1>>;
-template<typename T>
-using VecMap = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1> const,
-                          Eigen::Unaligned,
-                          Eigen::Stride<Eigen::Dynamic, 1>>;
-
-template<typename V>
-auto
-vec(V const& v) -> VecMap<typename V::Scalar>
-{
-  static_assert(V::InnerStrideAtCompileTime == 1, ".");
-  return {
-    v.data(),
-    v.rows(),
-    v.cols(),
-    Eigen::Stride<Eigen::Dynamic, 1>{
-      v.outerStride(),
-      v.innerStride(),
-    },
-  };
-}
-
-template<typename V>
-auto
-vec_mut(V&& v)
-  -> VecMapMut<typename proxsuite::linalg::veg::uncvref_t<V>::Scalar>
-{
-  static_assert(
-    proxsuite::linalg::veg::uncvref_t<V>::InnerStrideAtCompileTime == 1, ".");
-  return {
-    v.data(),
-    v.rows(),
-    v.cols(),
-    Eigen::Stride<Eigen::Dynamic, 1>{
-      v.outerStride(),
-      v.innerStride(),
-    },
-  };
-}
-
-template<typename T, typename I>
-auto
-middle_cols(proxsuite::linalg::sparse::MatRef<T, I> mat,
-            isize start,
-            isize ncols,
-            isize nnz) -> proxsuite::linalg::sparse::MatRef<T, I>
-{
-  VEG_ASSERT(start <= mat.ncols());
-  VEG_ASSERT(ncols <= mat.ncols() - start);
-
-  return {
-    proxsuite::linalg::sparse::from_raw_parts,
-    mat.nrows(),
-    ncols,
-    nnz,
-    mat.col_ptrs() + start,
-    mat.is_compressed() ? nullptr : (mat.nnz_per_col() + start),
-    mat.row_indices(),
-    mat.values(),
-  };
-}
-
-template<typename T, typename I>
-auto
-middle_cols_mut(proxsuite::linalg::sparse::MatMut<T, I> mat,
-                isize start,
-                isize ncols,
-                isize nnz) -> proxsuite::linalg::sparse::MatMut<T, I>
-{
-  VEG_ASSERT(start <= mat.ncols());
-  VEG_ASSERT(ncols <= mat.ncols() - start);
-  return {
-    proxsuite::linalg::sparse::from_raw_parts,
-    mat.nrows(),
-    ncols,
-    nnz,
-    mat.col_ptrs_mut() + start,
-    mat.is_compressed() ? nullptr : (mat.nnz_per_col_mut() + start),
-    mat.row_indices_mut(),
-    mat.values_mut(),
-  };
-}
-
-template<typename T, typename I>
-auto
-top_rows_unchecked(proxsuite::linalg::veg::Unsafe /*unsafe*/,
-                   proxsuite::linalg::sparse::MatRef<T, I> mat,
-                   isize nrows) -> proxsuite::linalg::sparse::MatRef<T, I>
-{
-  VEG_ASSERT(nrows <= mat.nrows());
-  return {
-    proxsuite::linalg::sparse::from_raw_parts,
-    nrows,
-    mat.ncols(),
-    mat.nnz(),
-    mat.col_ptrs(),
-    mat.nnz_per_col(),
-    mat.row_indices(),
-    mat.values(),
-  };
-}
-
-template<typename T, typename I>
-auto
-top_rows_mut_unchecked(proxsuite::linalg::veg::Unsafe /*unsafe*/,
-                       proxsuite::linalg::sparse::MatMut<T, I> mat,
-                       isize nrows) -> proxsuite::linalg::sparse::MatMut<T, I>
-{
-  VEG_ASSERT(nrows <= mat.nrows());
-  return {
-    proxsuite::linalg::sparse::from_raw_parts,
-    nrows,
-    mat.ncols(),
-    mat.nnz(),
-    mat.col_ptrs_mut(),
-    mat.nnz_per_col_mut(),
-    mat.row_indices_mut(),
-    mat.values_mut(),
-  };
-}
-/*!
- * Check whether the global primal infeasibility criterion is satisfied.
- *
- * @param qp_scaled view on the scaled version of the qp problem.
- * @param qpsettings solver settings.
- * @param ruiz ruiz preconditioner.
- * @param ATdy variable used for testing global primal infeasibility criterion
- * is satisfied.
- * @param CTdz variable used for testing global primal infeasibility criterion
- * is satisfied.
- * @param dy variable used for testing global primal infeasibility criterion is
- * satisfied.
- * @param dz variable used for testing global primal infeasibility criterion is
- * satisfied.
- */
-template<typename T, typename I, typename P>
-bool
-global_primal_residual_infeasibility(VectorViewMut<T> ATdy,
-                                     VectorViewMut<T> CTdz,
-                                     VectorViewMut<T> dy,
-                                     VectorViewMut<T> dz,
-                                     const QpView<T, I> qp_scaled,
-                                     const Settings<T>& qpsettings,
-                                     const P& ruiz)
-{
-
-  // The problem is primal infeasible if the following four conditions hold:
-  //
-  // ||unscaled(A^Tdy)|| <= eps_p_inf ||unscaled(dy)||
-  // b^T dy <= -eps_p_inf ||unscaled(dy)||
-  // ||unscaled(C^Tdz)|| <= eps_p_inf ||unscaled(dz)||
-  // u^T [dz]_+ - l^T[-dz]_+ <= -eps_p_inf ||unscaled(dz)||
-  //
-  // the variables in entry are changed in place
-
-  bool res = infty_norm(dy.to_eigen()) != 0 && infty_norm(dz.to_eigen()) != 0;
-  if (!res) {
-    return res;
-  }
-  ruiz.unscale_dual_residual_in_place(ATdy);
-  ruiz.unscale_dual_residual_in_place(CTdz);
-  T eq_inf = dy.to_eigen().dot(qp_scaled.b.to_eigen());
-  T in_inf = helpers::positive_part(dz.to_eigen()).dot(qp_scaled.u.to_eigen()) -
-             helpers::negative_part(dz.to_eigen()).dot(qp_scaled.l.to_eigen());
-  ruiz.unscale_dual_in_place_eq(dy);
-  ruiz.unscale_dual_in_place_in(dz);
-
-  T bound_y = qpsettings.eps_primal_inf * infty_norm(dy.to_eigen());
-  T bound_z = qpsettings.eps_primal_inf * infty_norm(dz.to_eigen());
-
-  res = infty_norm(ATdy.to_eigen()) <= bound_y && eq_inf <= -bound_y &&
-        infty_norm(CTdz.to_eigen()) <= bound_z && in_inf <= -bound_z;
-  return res;
-}
-/*!
-* Check whether the global dual infeasibility criterion is satisfied.
-
-* @param qp_scaled view on the scaled version of the qp problem.
-* @param qpsettings solver settings.
-* @param qpmodel QP problem model as defined by the user (without any scaling
-performed).
-* @param ruiz ruiz preconditioner.
-* @param Adx variable used for testing global dual infeasibility criterion is
-satisfied.
-* @param Cdx variable used for testing global dual infeasibility criterion is
-satisfied.
-* @param Hdx variable used for testing global dual infeasibility criterion is
-satisfied.
-* @param dx variable used for testing global dual infeasibility criterion is
-satisfied.
-*/
-template<typename T, typename I, typename P>
-bool
-global_dual_residual_infeasibility(VectorViewMut<T> Adx,
-                                   VectorViewMut<T> Cdx,
-                                   VectorViewMut<T> Hdx,
-                                   VectorViewMut<T> dx,
-                                   const QpView<T, I> qp_scaled,
-                                   const Settings<T>& qpsettings,
-                                   const Model<T, I>& qpmodel,
-                                   const P& ruiz)
-{
-
-  // The problem is dual infeasible if one of the conditions hold:
-  //
-  // FIRST
-  // ||unscaled(Adx)|| <= eps_d_inf ||unscaled(dx)||
-  // unscaled(Cdx)_i \in [-eps_d_inf,eps_d_inf] ||unscaled(dx)|| if u_i and l_i
-  // are finite 					or >=
-  // -eps_d_inf||unscaled(dx)|| if u_i = +inf or <= eps_d_inf||unscaled(dx)|| if
-  // l_i = -inf
-  //
-  // SECOND
-  //
-  // ||unscaled(Hdx)|| <= c eps_d_inf * ||unscaled(dx)||  and  q^Tdx <= -c
-  // eps_d_inf  ||unscaled(dx)||
-  // the variables in entry are changed in place
-  ruiz.unscale_dual_residual_in_place(Hdx);
-  ruiz.unscale_primal_residual_in_place_eq(Adx);
-  ruiz.unscale_primal_residual_in_place_in(Cdx);
-  T gdx = (dx.to_eigen()).dot(qp_scaled.g.to_eigen());
-  ruiz.unscale_primal_in_place(dx);
-
-  T bound = infty_norm(dx.to_eigen()) * qpsettings.eps_dual_inf;
-  T bound_neg = -bound;
-
-  bool first_cond = infty_norm(Adx.to_eigen()) <= bound;
-
-  for (i64 iter = 0; iter < qpmodel.n_in; ++iter) {
-    T Cdx_i = Cdx.to_eigen()[iter];
-    if (qp_scaled.u.to_eigen()[iter] <= 1.E20 &&
-        qp_scaled.l.to_eigen()[iter] >= -1.E20) {
-      first_cond = first_cond && Cdx_i <= bound && Cdx_i >= bound_neg;
-    } else if (qp_scaled.u.to_eigen()[iter] > 1.E20) {
-      first_cond = first_cond && Cdx_i >= bound_neg;
-    } else if (qp_scaled.l.to_eigen()[iter] < -1.E20) {
-      first_cond = first_cond && Cdx_i <= bound;
-    }
-  }
-
-  bound *= ruiz.c;
-  bound_neg *= ruiz.c;
-  bool second_cond_alt1 =
-    infty_norm(Hdx.to_eigen()) <= bound && gdx <= bound_neg;
-  bound_neg *= qpsettings.eps_dual_inf;
-
-  bool res = first_cond && second_cond_alt1 && infty_norm(dx.to_eigen()) != 0;
-  return res;
-}
-
-/*!
- * Derives the global primal and dual residual of the QP problem for determining
- * whether the solution is reached (at the desired accuracy).
- *
- * @param primal_residual_eq_scaled vector storing the primal equality residual.
- * @param primal_residual_in_scaled_lo vector storing the primal lower bound
- * inequality residual.
- * @param primal_residual_in_scaled_up vector storing the primal uppder bound
- * inequality residual.
- * @param dual_residual_scaled vector storing the dual residual.
- * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param primal_feasibility_in_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_0 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_1 scalar variable used when using a relative
- * stopping criterion.
- * @param dual_feasibility_rhs_3 scalar variable used when using a relative
- * stopping criterion.
- * @param precond preconditioner.
- * @param data model of the problem.
- * @param qp_scaled view on the scaled version of the qp problem.
- * @param x_e current estimate of primal variable x.
- * @param y_e current estimate of equality constrained lagrange multiplier.
- * @param z_e current estimate of inequality constrained lagrange multiplier.
- * @param stak stack.
- */
-template<typename T, typename I, typename P>
-auto
-unscaled_primal_dual_residual(
-  const Workspace<T, I>& work,
-  Results<T>& results,
-  VecMapMut<T> primal_residual_eq_scaled,
-  VecMapMut<T> primal_residual_in_scaled_lo,
-  VecMapMut<T> primal_residual_in_scaled_up,
-  VecMapMut<T> dual_residual_scaled,
-  T& primal_feasibility_eq_rhs_0,
-  T& primal_feasibility_in_rhs_0,
-  T& dual_feasibility_rhs_0,
-  T& dual_feasibility_rhs_1,
-  T& dual_feasibility_rhs_3,
-  T& rhs_duality_gap,
-  const P& precond,
-  Model<T, I> const& data,
-  const QpView<T, I> qp_scaled,
-  VecMapMut<T> x_e,
-  VecMapMut<T> y_e,
-  VecMapMut<T> z_e,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  -> proxsuite::linalg::veg::Tuple<T, T>
-{
-  isize n = x_e.rows();
-
-  LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
-  dual_residual_scaled = qp_scaled.g.to_eigen();
-  {
-    tmp.setZero();
-    noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
-    dual_residual_scaled += tmp;
-
-    precond.unscale_dual_residual_in_place(
-      { proxqp::from_eigen, tmp }); // contains unscaled Hx
-    dual_feasibility_rhs_0 = infty_norm(tmp);
-    precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
-    results.info.duality_gap = x_e.dot(data.g); // contains gTx
-    rhs_duality_gap = std::fabs(results.info.duality_gap);
-
-    const T xHx = (tmp).dot(x_e);
-    results.info.duality_gap += xHx;
-    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(xHx));
-    tmp += data.g; // contains now Hx+g
-    precond.scale_primal_in_place({ proxqp::from_eigen, x_e });
-
-    precond.unscale_dual_in_place_eq({ proxsuite::proxqp::from_eigen, y_e });
-    const T by = (data.b).dot(y_e);
-    results.info.duality_gap += by;
-    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(by));
-    precond.scale_dual_in_place_eq({ proxsuite::proxqp::from_eigen, y_e });
-
-    precond.unscale_dual_in_place_in({ proxsuite::proxqp::from_eigen, z_e });
-
-    const T zl =
-      helpers::select(work.active_set_low, results.z, 0)
-        .dot(helpers::at_least(data.l, -helpers::infinite_bound<T>::value()));
-    results.info.duality_gap += zl;
-    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zl));
-
-    const T zu =
-      helpers::select(work.active_set_up, results.z, 0)
-        .dot(helpers::at_most(data.u, helpers::infinite_bound<T>::value()));
-    results.info.duality_gap += zu;
-    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zu));
-
-    precond.scale_dual_in_place_in({ proxsuite::proxqp::from_eigen, z_e });
-  }
-
-  {
-    auto ATy = tmp;
-    ATy.setZero();
-    primal_residual_eq_scaled.setZero();
-
-    detail::noalias_gevmmv_add(
-      primal_residual_eq_scaled, ATy, qp_scaled.AT.to_eigen(), x_e, y_e);
-
-    dual_residual_scaled += ATy;
-
-    precond.unscale_dual_residual_in_place({ proxqp::from_eigen, ATy });
-    dual_feasibility_rhs_1 = infty_norm(ATy);
-  }
-
-  {
-    auto CTz = tmp;
-    CTz.setZero();
-    primal_residual_in_scaled_up.setZero();
-
-    detail::noalias_gevmmv_add(
-      primal_residual_in_scaled_up, CTz, qp_scaled.CT.to_eigen(), x_e, z_e);
-
-    dual_residual_scaled += CTz;
-
-    precond.unscale_dual_residual_in_place({ proxqp::from_eigen, CTz });
-    dual_feasibility_rhs_3 = infty_norm(CTz);
-  }
-  precond.unscale_primal_residual_in_place_eq(
-    { proxqp::from_eigen, primal_residual_eq_scaled });
-  primal_feasibility_eq_rhs_0 = infty_norm(primal_residual_eq_scaled);
-
-  precond.unscale_primal_residual_in_place_in(
-    { proxqp::from_eigen, primal_residual_in_scaled_up });
-  primal_feasibility_in_rhs_0 = infty_norm(primal_residual_in_scaled_up);
-
-  auto b = data.b;
-  auto l = data.l;
-  auto u = data.u;
-  primal_residual_in_scaled_lo =
-    helpers::positive_part(primal_residual_in_scaled_up - u) +
-    helpers::negative_part(primal_residual_in_scaled_up - l);
-
-  primal_residual_eq_scaled -= b;
-  T primal_feasibility_eq_lhs = infty_norm(primal_residual_eq_scaled);
-  T primal_feasibility_in_lhs = infty_norm(primal_residual_in_scaled_lo);
-  T primal_feasibility_lhs =
-    std::max(primal_feasibility_eq_lhs, primal_feasibility_in_lhs);
-
-  // scaled Ax - b
-  precond.scale_primal_residual_in_place_eq(
-    { proxqp::from_eigen, primal_residual_eq_scaled });
-  // scaled Cx
-  precond.scale_primal_residual_in_place_in(
-    { proxqp::from_eigen, primal_residual_in_scaled_up });
-
-  precond.unscale_dual_residual_in_place(
-    { proxqp::from_eigen, dual_residual_scaled });
-  T dual_feasibility_lhs = infty_norm(dual_residual_scaled);
-  precond.scale_dual_residual_in_place(
-    { proxqp::from_eigen, dual_residual_scaled });
-
-  return proxsuite::linalg::veg::tuplify(primal_feasibility_lhs,
-                                         dual_feasibility_lhs);
-}
-
-} // namespace detail
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-namespace Eigen {
-namespace internal {
-template<typename T, typename I>
-struct traits<proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>>
-  : Eigen::internal::traits<Eigen::SparseMatrix<T, Eigen::ColMajor, I>>
-{};
-
-template<typename Rhs, typename T, typename I>
-struct generic_product_impl<
-  proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
-  Rhs,
-  SparseShape,
-  DenseShape,
-  GemvProduct>
-  : generic_product_impl_base<
-      proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
-      Rhs,
-      generic_product_impl<
-        proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
-        Rhs>>
-{
-  using Mat_ = proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>;
-
-  using Scalar = typename Product<Mat_, Rhs>::Scalar;
-
-  template<typename Dst>
-  static void scaleAndAddTo(Dst& dst,
-                            Mat_ const& lhs,
-                            Rhs const& rhs,
-                            PROXSUITE_MAYBE_UNUSED Scalar const& alpha)
-  {
-    using proxsuite::linalg::veg::isize;
-
-    VEG_ASSERT(alpha == Scalar(1));
-    proxsuite::proxqp::sparse::detail::noalias_symhiv_add(
-      dst, lhs._.kkt_active.to_eigen(), rhs);
-
-    {
-      isize n = lhs._.n;
-      isize n_eq = lhs._.n_eq;
-      isize n_in = lhs._.n_in;
-
-      auto dst_x = dst.head(n);
-      auto dst_y = dst.segment(n, n_eq);
-      auto dst_z = dst.tail(n_in);
-
-      auto rhs_x = rhs.head(n);
-      auto rhs_y = rhs.segment(n, n_eq);
-      auto rhs_z = rhs.tail(n_in);
-
-      dst_x += lhs._.rho * rhs_x;
-      dst_y += (-1 / lhs._.mu_eq) * rhs_y;
-      for (isize i = 0; i < n_in; ++i) {
-        dst_z[i] +=
-          (lhs._.active_constraints[i] ? -1 / lhs._.mu_in : T(1)) * rhs_z[i];
-      }
-    }
-  }
-};
-} // namespace internal
-} // namespace Eigen
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_UTILS_HPP */
+//
+// Copyright (c) 2022-2023 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_UTILS_HPP
+#define PROXSUITE_PROXQP_SPARSE_UTILS_HPP
+
+#include <iostream>
+#include <Eigen/IterativeLinearSolvers>
+#include <unsupported/Eigen/IterativeSolvers>
+
+#include "proxsuite/helpers/common.hpp"
+#include <proxsuite/linalg/dense/core.hpp>
+#include <proxsuite/linalg/sparse/core.hpp>
+#include "proxsuite/proxqp/sparse/workspace.hpp"
+#include <proxsuite/linalg/sparse/factorize.hpp>
+#include <proxsuite/linalg/sparse/update.hpp>
+#include <proxsuite/linalg/sparse/rowmod.hpp>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+#include "proxsuite/proxqp/results.hpp"
+#include "proxsuite/proxqp/utils/prints.hpp"
+#include "proxsuite/proxqp/sparse/views.hpp"
+#include "proxsuite/proxqp/sparse/model.hpp"
+#include "proxsuite/proxqp/sparse/preconditioner/ruiz.hpp"
+#include "proxsuite/proxqp/sparse/preconditioner/identity.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+template<typename T, typename I>
+void
+print_setup_header(const Settings<T>& settings,
+                   Results<T>& results,
+                   const Model<T, I>& model)
+{
+
+  proxsuite::proxqp::print_preambule();
+
+  // Print variables and constraints
+  std::cout << "problem:  " << std::noshowpos << std::endl;
+  std::cout << "          variables n = " << model.dim
+            << ", equality constraints n_eq = " << model.n_eq << ",\n"
+            << "          inequality constraints n_in = " << model.n_in
+            << ", nnz = " << model.H_nnz + model.A_nnz + model.C_nnz << ",\n"
+            << std::endl;
+
+  // Print Settings
+  std::cout << "settings: " << std::endl;
+  std::cout << "          backend = sparse," << std::endl;
+  std::cout << "          sparse_backend = " << settings.sparse_backend;
+  if (settings.sparse_backend == SparseBackend::Automatic) {
+    std::cout << " -> " << results.info.sparse_backend;
+  }
+  std::cout << "," << std::endl;
+  std::cout << "          eps_abs = " << settings.eps_abs
+            << ", eps_rel = " << settings.eps_rel << std::endl;
+  std::cout << "          eps_prim_inf = " << settings.eps_primal_inf
+            << ", eps_dual_inf = " << settings.eps_dual_inf << "," << std::endl;
+
+  std::cout << "          rho = " << results.info.rho
+            << ", mu_eq = " << results.info.mu_eq
+            << ", mu_in = " << results.info.mu_in << "," << std::endl;
+  std::cout << "          max_iter = " << settings.max_iter
+            << ", max_iter_in = " << settings.max_iter_in << "," << std::endl;
+
+  if (settings.compute_preconditioner) {
+    std::cout << "          scaling: on, " << std::endl;
+  } else {
+    std::cout << "          scaling: off, " << std::endl;
+  }
+  if (settings.compute_timings) {
+    std::cout << "          timings: on, " << std::endl;
+  } else {
+    std::cout << "          timings: off, " << std::endl;
+  }
+  switch (settings.initial_guess) {
+    case InitialGuessStatus::WARM_START:
+      std::cout << "          initial guess: warm start. \n" << std::endl;
+      break;
+    case InitialGuessStatus::NO_INITIAL_GUESS:
+      std::cout << "          initial guess: initial guess. \n" << std::endl;
+      break;
+    case InitialGuessStatus::WARM_START_WITH_PREVIOUS_RESULT:
+      std::cout
+        << "          initial guess: warm start with previous result. \n"
+        << std::endl;
+      break;
+    case InitialGuessStatus::COLD_START_WITH_PREVIOUS_RESULT:
+      std::cout
+        << "          initial guess: cold start with previous result. \n"
+        << std::endl;
+      break;
+    case InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS:
+      std::cout
+        << "          initial guess: equality constrained initial guess. \n"
+        << std::endl;
+  }
+}
+
+namespace detail {
+
+template<typename T, typename I>
+VEG_NO_INLINE void
+noalias_gevmmv_add_impl( //
+  VectorViewMut<T> out_l,
+  VectorViewMut<T> out_r,
+  proxsuite::linalg::sparse::MatRef<T, I> a,
+  VectorView<T> in_l,
+  VectorView<T> in_r)
+{
+  VEG_ASSERT_ALL_OF /* NOLINT */ (a.nrows() == out_r.dim,
+                                  a.ncols() == in_r.dim,
+                                  a.ncols() == out_l.dim,
+                                  a.nrows() == in_l.dim);
+  // equivalent to
+  // out_r.to_eigen().noalias() += a.to_eigen() * in_r.to_eigen();
+  // out_l.to_eigen().noalias() += a.to_eigen().transpose() * in_l.to_eigen();
+
+  auto* ai = a.row_indices();
+  auto* ax = a.values();
+  auto n = a.ncols();
+
+  for (usize j = 0; j < usize(n); ++j) {
+    usize col_start = a.col_start(j);
+    usize col_end = a.col_end(j);
+
+    T acc0 = 0;
+    T acc1 = 0;
+    T acc2 = 0;
+    T acc3 = 0;
+
+    T in_rj = in_r(isize(j));
+
+    usize pcount = col_end - col_start;
+
+    usize p = col_start;
+
+    auto zx = proxsuite::linalg::sparse::util::zero_extend;
+
+    for (; p < col_start + pcount / 4 * 4; p += 4) {
+      auto i0 = isize(zx(ai[p + 0]));
+      auto i1 = isize(zx(ai[p + 1]));
+      auto i2 = isize(zx(ai[p + 2]));
+      auto i3 = isize(zx(ai[p + 3]));
+
+      T ai0j = ax[p + 0];
+      T ai1j = ax[p + 1];
+      T ai2j = ax[p + 2];
+      T ai3j = ax[p + 3];
+
+      out_r(i0) += ai0j * in_rj;
+      out_r(i1) += ai1j * in_rj;
+      out_r(i2) += ai2j * in_rj;
+      out_r(i3) += ai3j * in_rj;
+
+      acc0 += ai0j * in_l(i0);
+      acc1 += ai1j * in_l(i1);
+      acc2 += ai2j * in_l(i2);
+      acc3 += ai3j * in_l(i3);
+    }
+
+    for (; p < col_end; ++p) {
+      auto i = isize(zx(ai[p]));
+
+      T aij = ax[p];
+      out_r(i) += aij * in_rj;
+      acc0 += aij * in_l(i);
+    }
+
+    acc0 = ((acc0 + acc1) + (acc2 + acc3));
+    out_l(isize(j)) += acc0;
+  }
+}
+
+template<typename T, typename I>
+VEG_NO_INLINE void
+noalias_symhiv_add_impl( //
+  VectorViewMut<T> out,
+  proxsuite::linalg::sparse::MatRef<T, I> a,
+  VectorView<T> in)
+{
+  VEG_ASSERT_ALL_OF /* NOLINT */ ( //
+    a.nrows() == a.ncols(),
+    a.nrows() == out.dim,
+    a.ncols() == in.dim);
+  // equivalent to
+  // out.to_eigen().noalias() +=
+  // 		a.to_eigen().template selfadjointView<Eigen::Upper>() *
+  // in.to_eigen();
+
+  auto* ai = a.row_indices();
+  auto* ax = a.values();
+  auto n = a.ncols();
+
+  for (usize j = 0; j < usize(n); ++j) {
+    usize col_start = a.col_start(j);
+    usize col_end = a.col_end(j);
+
+    if (col_start == col_end) {
+      continue;
+    }
+
+    T acc0 = 0;
+    T acc1 = 0;
+    T acc2 = 0;
+    T acc3 = 0;
+
+    T in_j = in(isize(j));
+
+    usize pcount = col_end - col_start;
+
+    auto zx = proxsuite::linalg::sparse::util::zero_extend;
+
+    if (zx(ai[col_end - 1]) == j) {
+      T ajj = ax[col_end - 1];
+      out(isize(j)) += ajj * in_j;
+      pcount -= 1;
+    }
+
+    usize p = col_start;
+
+    for (; p < col_start + pcount / 4 * 4; p += 4) {
+      auto i0 = isize(zx(ai[p + 0]));
+      auto i1 = isize(zx(ai[p + 1]));
+      auto i2 = isize(zx(ai[p + 2]));
+      auto i3 = isize(zx(ai[p + 3]));
+
+      T ai0j = ax[p + 0];
+      T ai1j = ax[p + 1];
+      T ai2j = ax[p + 2];
+      T ai3j = ax[p + 3];
+
+      out(i0) += ai0j * in_j;
+      out(i1) += ai1j * in_j;
+      out(i2) += ai2j * in_j;
+      out(i3) += ai3j * in_j;
+
+      acc0 += ai0j * in(i0);
+      acc1 += ai1j * in(i1);
+      acc2 += ai2j * in(i2);
+      acc3 += ai3j * in(i3);
+    }
+    for (; p < col_start + pcount; ++p) {
+      auto i = isize(zx(ai[p]));
+
+      T aij = ax[p];
+      out(i) += aij * in_j;
+      acc0 += aij * in(i);
+    }
+    acc0 = ((acc0 + acc1) + (acc2 + acc3));
+    out(isize(j)) += acc0;
+  }
+}
+
+template<typename OutL, typename OutR, typename A, typename InL, typename InR>
+void
+noalias_gevmmv_add(OutL&& out_l,
+                   OutR&& out_r,
+                   A const& a,
+                   InL const& in_l,
+                   InR const& in_r)
+{
+  // noalias general vector matrix matrix vector add
+  noalias_gevmmv_add_impl<typename A::Scalar, typename A::StorageIndex>(
+    { proxqp::from_eigen, out_l },
+    { proxqp::from_eigen, out_r },
+    { proxsuite::linalg::sparse::from_eigen, a },
+    { proxqp::from_eigen, in_l },
+    { proxqp::from_eigen, in_r });
+}
+
+template<typename Out, typename A, typename In>
+void
+noalias_symhiv_add(Out&& out, A const& a, In const& in)
+{
+  // noalias symmetric (hi) matrix vector add
+  noalias_symhiv_add_impl<typename A::Scalar, typename A::StorageIndex>(
+    { proxqp::from_eigen, out },
+    { proxsuite::linalg::sparse::from_eigen, a },
+    { proxqp::from_eigen, in });
+}
+
+template<typename T, typename I>
+struct AugmentedKkt : Eigen::EigenBase<AugmentedKkt<T, I>>
+{
+  struct Raw /* NOLINT */
+  {
+    proxsuite::linalg::sparse::MatRef<T, I> kkt_active;
+    proxsuite::linalg::veg::Slice<bool> active_constraints;
+    isize n;
+    isize n_eq;
+    isize n_in;
+    T rho;
+    T mu_eq;
+    T mu_in;
+  } _;
+
+  AugmentedKkt /* NOLINT */ (Raw raw) noexcept
+    : _{ raw }
+  {
+  }
+
+  using Scalar = T;
+  using RealScalar = T;
+  using StorageIndex = I;
+  enum
+  {
+    ColsAtCompileTime = Eigen::Dynamic,
+    MaxColsAtCompileTime = Eigen::Dynamic,
+    IsRowMajor = false,
+  };
+
+  auto rows() const noexcept -> isize { return _.n + _.n_eq + _.n_in; }
+  auto cols() const noexcept -> isize { return rows(); }
+  template<typename Rhs>
+  auto operator*(Eigen::MatrixBase<Rhs> const& x) const
+    -> Eigen::Product<AugmentedKkt, Rhs, Eigen::AliasFreeProduct>
+  {
+    return Eigen::Product< //
+      AugmentedKkt,
+      Rhs,
+      Eigen::AliasFreeProduct>{
+      *this,
+      x.derived(),
+    };
+  }
+};
+
+template<typename T>
+using VecMapMut = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1>,
+                             Eigen::Unaligned,
+                             Eigen::Stride<Eigen::Dynamic, 1>>;
+template<typename T>
+using VecMap = Eigen::Map<Eigen::Matrix<T, Eigen::Dynamic, 1> const,
+                          Eigen::Unaligned,
+                          Eigen::Stride<Eigen::Dynamic, 1>>;
+
+template<typename V>
+auto
+vec(V const& v) -> VecMap<typename V::Scalar>
+{
+  static_assert(V::InnerStrideAtCompileTime == 1, ".");
+  return {
+    v.data(),
+    v.rows(),
+    v.cols(),
+    Eigen::Stride<Eigen::Dynamic, 1>{
+      v.outerStride(),
+      v.innerStride(),
+    },
+  };
+}
+
+template<typename V>
+auto
+vec_mut(V&& v)
+  -> VecMapMut<typename proxsuite::linalg::veg::uncvref_t<V>::Scalar>
+{
+  static_assert(
+    proxsuite::linalg::veg::uncvref_t<V>::InnerStrideAtCompileTime == 1, ".");
+  return {
+    v.data(),
+    v.rows(),
+    v.cols(),
+    Eigen::Stride<Eigen::Dynamic, 1>{
+      v.outerStride(),
+      v.innerStride(),
+    },
+  };
+}
+
+template<typename T, typename I>
+auto
+middle_cols(proxsuite::linalg::sparse::MatRef<T, I> mat,
+            isize start,
+            isize ncols,
+            isize nnz) -> proxsuite::linalg::sparse::MatRef<T, I>
+{
+  VEG_ASSERT(start <= mat.ncols());
+  VEG_ASSERT(ncols <= mat.ncols() - start);
+
+  return {
+    proxsuite::linalg::sparse::from_raw_parts,
+    mat.nrows(),
+    ncols,
+    nnz,
+    mat.col_ptrs() + start,
+    mat.is_compressed() ? nullptr : (mat.nnz_per_col() + start),
+    mat.row_indices(),
+    mat.values(),
+  };
+}
+
+template<typename T, typename I>
+auto
+middle_cols_mut(proxsuite::linalg::sparse::MatMut<T, I> mat,
+                isize start,
+                isize ncols,
+                isize nnz) -> proxsuite::linalg::sparse::MatMut<T, I>
+{
+  VEG_ASSERT(start <= mat.ncols());
+  VEG_ASSERT(ncols <= mat.ncols() - start);
+  return {
+    proxsuite::linalg::sparse::from_raw_parts,
+    mat.nrows(),
+    ncols,
+    nnz,
+    mat.col_ptrs_mut() + start,
+    mat.is_compressed() ? nullptr : (mat.nnz_per_col_mut() + start),
+    mat.row_indices_mut(),
+    mat.values_mut(),
+  };
+}
+
+template<typename T, typename I>
+auto
+top_rows_unchecked(proxsuite::linalg::veg::Unsafe /*unsafe*/,
+                   proxsuite::linalg::sparse::MatRef<T, I> mat,
+                   isize nrows) -> proxsuite::linalg::sparse::MatRef<T, I>
+{
+  VEG_ASSERT(nrows <= mat.nrows());
+  return {
+    proxsuite::linalg::sparse::from_raw_parts,
+    nrows,
+    mat.ncols(),
+    mat.nnz(),
+    mat.col_ptrs(),
+    mat.nnz_per_col(),
+    mat.row_indices(),
+    mat.values(),
+  };
+}
+
+template<typename T, typename I>
+auto
+top_rows_mut_unchecked(proxsuite::linalg::veg::Unsafe /*unsafe*/,
+                       proxsuite::linalg::sparse::MatMut<T, I> mat,
+                       isize nrows) -> proxsuite::linalg::sparse::MatMut<T, I>
+{
+  VEG_ASSERT(nrows <= mat.nrows());
+  return {
+    proxsuite::linalg::sparse::from_raw_parts,
+    nrows,
+    mat.ncols(),
+    mat.nnz(),
+    mat.col_ptrs_mut(),
+    mat.nnz_per_col_mut(),
+    mat.row_indices_mut(),
+    mat.values_mut(),
+  };
+}
+/*!
+ * Check whether the global primal infeasibility criterion is satisfied.
+ *
+ * @param qp_scaled view on the scaled version of the qp problem.
+ * @param qpsettings solver settings.
+ * @param ruiz ruiz preconditioner.
+ * @param ATdy variable used for testing global primal infeasibility criterion
+ * is satisfied.
+ * @param CTdz variable used for testing global primal infeasibility criterion
+ * is satisfied.
+ * @param dy variable used for testing global primal infeasibility criterion is
+ * satisfied.
+ * @param dz variable used for testing global primal infeasibility criterion is
+ * satisfied.
+ */
+template<typename T, typename I, typename P>
+bool
+global_primal_residual_infeasibility(VectorViewMut<T> ATdy,
+                                     VectorViewMut<T> CTdz,
+                                     VectorViewMut<T> dy,
+                                     VectorViewMut<T> dz,
+                                     const QpView<T, I> qp_scaled,
+                                     const Settings<T>& qpsettings,
+                                     const P& ruiz)
+{
+
+  // The problem is primal infeasible if the following four conditions hold:
+  //
+  // ||unscaled(A^Tdy)|| <= eps_p_inf ||unscaled(dy)||
+  // b^T dy <= -eps_p_inf ||unscaled(dy)||
+  // ||unscaled(C^Tdz)|| <= eps_p_inf ||unscaled(dz)||
+  // u^T [dz]_+ - l^T[-dz]_+ <= -eps_p_inf ||unscaled(dz)||
+  //
+  // the variables in entry are changed in place
+
+  bool res = infty_norm(dy.to_eigen()) != 0 && infty_norm(dz.to_eigen()) != 0;
+  if (!res) {
+    return res;
+  }
+  ruiz.unscale_dual_residual_in_place(ATdy);
+  ruiz.unscale_dual_residual_in_place(CTdz);
+  T eq_inf = dy.to_eigen().dot(qp_scaled.b.to_eigen());
+  T in_inf = helpers::positive_part(dz.to_eigen()).dot(qp_scaled.u.to_eigen()) -
+             helpers::negative_part(dz.to_eigen()).dot(qp_scaled.l.to_eigen());
+  ruiz.unscale_dual_in_place_eq(dy);
+  ruiz.unscale_dual_in_place_in(dz);
+
+  T bound_y = qpsettings.eps_primal_inf * infty_norm(dy.to_eigen());
+  T bound_z = qpsettings.eps_primal_inf * infty_norm(dz.to_eigen());
+
+  res = infty_norm(ATdy.to_eigen()) <= bound_y && eq_inf <= -bound_y &&
+        infty_norm(CTdz.to_eigen()) <= bound_z && in_inf <= -bound_z;
+  return res;
+}
+/*!
+* Check whether the global dual infeasibility criterion is satisfied.
+
+* @param qp_scaled view on the scaled version of the qp problem.
+* @param qpsettings solver settings.
+* @param qpmodel QP problem model as defined by the user (without any scaling
+performed).
+* @param ruiz ruiz preconditioner.
+* @param Adx variable used for testing global dual infeasibility criterion is
+satisfied.
+* @param Cdx variable used for testing global dual infeasibility criterion is
+satisfied.
+* @param Hdx variable used for testing global dual infeasibility criterion is
+satisfied.
+* @param dx variable used for testing global dual infeasibility criterion is
+satisfied.
+*/
+template<typename T, typename I, typename P>
+bool
+global_dual_residual_infeasibility(VectorViewMut<T> Adx,
+                                   VectorViewMut<T> Cdx,
+                                   VectorViewMut<T> Hdx,
+                                   VectorViewMut<T> dx,
+                                   const QpView<T, I> qp_scaled,
+                                   const Settings<T>& qpsettings,
+                                   const Model<T, I>& qpmodel,
+                                   const P& ruiz)
+{
+
+  // The problem is dual infeasible if one of the conditions hold:
+  //
+  // FIRST
+  // ||unscaled(Adx)|| <= eps_d_inf ||unscaled(dx)||
+  // unscaled(Cdx)_i \in [-eps_d_inf,eps_d_inf] ||unscaled(dx)|| if u_i and l_i
+  // are finite 					or >=
+  // -eps_d_inf||unscaled(dx)|| if u_i = +inf or <= eps_d_inf||unscaled(dx)|| if
+  // l_i = -inf
+  //
+  // SECOND
+  //
+  // ||unscaled(Hdx)|| <= c eps_d_inf * ||unscaled(dx)||  and  q^Tdx <= -c
+  // eps_d_inf  ||unscaled(dx)||
+  // the variables in entry are changed in place
+  ruiz.unscale_dual_residual_in_place(Hdx);
+  ruiz.unscale_primal_residual_in_place_eq(Adx);
+  ruiz.unscale_primal_residual_in_place_in(Cdx);
+  T gdx = (dx.to_eigen()).dot(qp_scaled.g.to_eigen());
+  ruiz.unscale_primal_in_place(dx);
+
+  T bound = infty_norm(dx.to_eigen()) * qpsettings.eps_dual_inf;
+  T bound_neg = -bound;
+
+  bool first_cond = infty_norm(Adx.to_eigen()) <= bound;
+
+  for (i64 iter = 0; iter < qpmodel.n_in; ++iter) {
+    T Cdx_i = Cdx.to_eigen()[iter];
+    if (qp_scaled.u.to_eigen()[iter] <= 1.E20 &&
+        qp_scaled.l.to_eigen()[iter] >= -1.E20) {
+      first_cond = first_cond && Cdx_i <= bound && Cdx_i >= bound_neg;
+    } else if (qp_scaled.u.to_eigen()[iter] > 1.E20) {
+      first_cond = first_cond && Cdx_i >= bound_neg;
+    } else if (qp_scaled.l.to_eigen()[iter] < -1.E20) {
+      first_cond = first_cond && Cdx_i <= bound;
+    }
+  }
+
+  bound *= ruiz.c;
+  bound_neg *= ruiz.c;
+  bool second_cond_alt1 =
+    infty_norm(Hdx.to_eigen()) <= bound && gdx <= bound_neg;
+  bound_neg *= qpsettings.eps_dual_inf;
+
+  bool res = first_cond && second_cond_alt1 && infty_norm(dx.to_eigen()) != 0;
+  return res;
+}
+
+/*!
+ * Derives the global primal and dual residual of the QP problem for determining
+ * whether the solution is reached (at the desired accuracy).
+ *
+ * @param primal_residual_eq_scaled vector storing the primal equality residual.
+ * @param primal_residual_in_scaled_lo vector storing the primal lower bound
+ * inequality residual.
+ * @param primal_residual_in_scaled_up vector storing the primal uppder bound
+ * inequality residual.
+ * @param dual_residual_scaled vector storing the dual residual.
+ * @param primal_feasibility_eq_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param primal_feasibility_in_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_0 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_1 scalar variable used when using a relative
+ * stopping criterion.
+ * @param dual_feasibility_rhs_3 scalar variable used when using a relative
+ * stopping criterion.
+ * @param precond preconditioner.
+ * @param data model of the problem.
+ * @param qp_scaled view on the scaled version of the qp problem.
+ * @param x_e current estimate of primal variable x.
+ * @param y_e current estimate of equality constrained lagrange multiplier.
+ * @param z_e current estimate of inequality constrained lagrange multiplier.
+ * @param stak stack.
+ */
+template<typename T, typename I, typename P>
+auto
+unscaled_primal_dual_residual(
+  const Workspace<T, I>& work,
+  Results<T>& results,
+  VecMapMut<T> primal_residual_eq_scaled,
+  VecMapMut<T> primal_residual_in_scaled_lo,
+  VecMapMut<T> primal_residual_in_scaled_up,
+  VecMapMut<T> dual_residual_scaled,
+  T& primal_feasibility_eq_rhs_0,
+  T& primal_feasibility_in_rhs_0,
+  T& dual_feasibility_rhs_0,
+  T& dual_feasibility_rhs_1,
+  T& dual_feasibility_rhs_3,
+  T& rhs_duality_gap,
+  const P& precond,
+  Model<T, I> const& data,
+  const QpView<T, I> qp_scaled,
+  VecMapMut<T> x_e,
+  VecMapMut<T> y_e,
+  VecMapMut<T> z_e,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  -> proxsuite::linalg::veg::Tuple<T, T>
+{
+  isize n = x_e.rows();
+
+  LDLT_TEMP_VEC_UNINIT(T, tmp, n, stack);
+  dual_residual_scaled = qp_scaled.g.to_eigen();
+  {
+    tmp.setZero();
+    noalias_symhiv_add(tmp, qp_scaled.H.to_eigen(), x_e);
+    dual_residual_scaled += tmp;
+
+    precond.unscale_dual_residual_in_place(
+      { proxqp::from_eigen, tmp }); // contains unscaled Hx
+    dual_feasibility_rhs_0 = infty_norm(tmp);
+    precond.unscale_primal_in_place({ proxqp::from_eigen, x_e });
+    results.info.duality_gap = x_e.dot(data.g); // contains gTx
+    rhs_duality_gap = std::fabs(results.info.duality_gap);
+
+    const T xHx = (tmp).dot(x_e);
+    results.info.duality_gap += xHx;
+    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(xHx));
+    tmp += data.g; // contains now Hx+g
+    precond.scale_primal_in_place({ proxqp::from_eigen, x_e });
+
+    precond.unscale_dual_in_place_eq({ proxsuite::proxqp::from_eigen, y_e });
+    const T by = (data.b).dot(y_e);
+    results.info.duality_gap += by;
+    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(by));
+    precond.scale_dual_in_place_eq({ proxsuite::proxqp::from_eigen, y_e });
+
+    precond.unscale_dual_in_place_in({ proxsuite::proxqp::from_eigen, z_e });
+
+    const T zl =
+      helpers::select(work.active_set_low, results.z, 0)
+        .dot(helpers::at_least(data.l, -helpers::infinite_bound<T>::value()));
+    results.info.duality_gap += zl;
+    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zl));
+
+    const T zu =
+      helpers::select(work.active_set_up, results.z, 0)
+        .dot(helpers::at_most(data.u, helpers::infinite_bound<T>::value()));
+    results.info.duality_gap += zu;
+    rhs_duality_gap = std::max(rhs_duality_gap, std::abs(zu));
+
+    precond.scale_dual_in_place_in({ proxsuite::proxqp::from_eigen, z_e });
+  }
+
+  {
+    auto ATy = tmp;
+    ATy.setZero();
+    primal_residual_eq_scaled.setZero();
+
+    detail::noalias_gevmmv_add(
+      primal_residual_eq_scaled, ATy, qp_scaled.AT.to_eigen(), x_e, y_e);
+
+    dual_residual_scaled += ATy;
+
+    precond.unscale_dual_residual_in_place({ proxqp::from_eigen, ATy });
+    dual_feasibility_rhs_1 = infty_norm(ATy);
+  }
+
+  {
+    auto CTz = tmp;
+    CTz.setZero();
+    primal_residual_in_scaled_up.setZero();
+
+    detail::noalias_gevmmv_add(
+      primal_residual_in_scaled_up, CTz, qp_scaled.CT.to_eigen(), x_e, z_e);
+
+    dual_residual_scaled += CTz;
+
+    precond.unscale_dual_residual_in_place({ proxqp::from_eigen, CTz });
+    dual_feasibility_rhs_3 = infty_norm(CTz);
+  }
+  precond.unscale_primal_residual_in_place_eq(
+    { proxqp::from_eigen, primal_residual_eq_scaled });
+  primal_feasibility_eq_rhs_0 = infty_norm(primal_residual_eq_scaled);
+
+  precond.unscale_primal_residual_in_place_in(
+    { proxqp::from_eigen, primal_residual_in_scaled_up });
+  primal_feasibility_in_rhs_0 = infty_norm(primal_residual_in_scaled_up);
+
+  auto b = data.b;
+  auto l = data.l;
+  auto u = data.u;
+  primal_residual_in_scaled_lo =
+    helpers::positive_part(primal_residual_in_scaled_up - u) +
+    helpers::negative_part(primal_residual_in_scaled_up - l);
+
+  primal_residual_eq_scaled -= b;
+  T primal_feasibility_eq_lhs = infty_norm(primal_residual_eq_scaled);
+  T primal_feasibility_in_lhs = infty_norm(primal_residual_in_scaled_lo);
+  T primal_feasibility_lhs =
+    std::max(primal_feasibility_eq_lhs, primal_feasibility_in_lhs);
+
+  // scaled Ax - b
+  precond.scale_primal_residual_in_place_eq(
+    { proxqp::from_eigen, primal_residual_eq_scaled });
+  // scaled Cx
+  precond.scale_primal_residual_in_place_in(
+    { proxqp::from_eigen, primal_residual_in_scaled_up });
+
+  precond.unscale_dual_residual_in_place(
+    { proxqp::from_eigen, dual_residual_scaled });
+  T dual_feasibility_lhs = infty_norm(dual_residual_scaled);
+  precond.scale_dual_residual_in_place(
+    { proxqp::from_eigen, dual_residual_scaled });
+
+  return proxsuite::linalg::veg::tuplify(primal_feasibility_lhs,
+                                         dual_feasibility_lhs);
+}
+
+} // namespace detail
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+namespace Eigen {
+namespace internal {
+template<typename T, typename I>
+struct traits<proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>>
+  : Eigen::internal::traits<Eigen::SparseMatrix<T, Eigen::ColMajor, I>>
+{};
+
+template<typename Rhs, typename T, typename I>
+struct generic_product_impl<
+  proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
+  Rhs,
+  SparseShape,
+  DenseShape,
+  GemvProduct>
+  : generic_product_impl_base<
+      proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
+      Rhs,
+      generic_product_impl<
+        proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>,
+        Rhs>>
+{
+  using Mat_ = proxsuite::proxqp::sparse::detail::AugmentedKkt<T, I>;
+
+  using Scalar = typename Product<Mat_, Rhs>::Scalar;
+
+  template<typename Dst>
+  static void scaleAndAddTo(Dst& dst,
+                            Mat_ const& lhs,
+                            Rhs const& rhs,
+                            PROXSUITE_MAYBE_UNUSED Scalar const& alpha)
+  {
+    using proxsuite::linalg::veg::isize;
+
+    VEG_ASSERT(alpha == Scalar(1));
+    proxsuite::proxqp::sparse::detail::noalias_symhiv_add(
+      dst, lhs._.kkt_active.to_eigen(), rhs);
+
+    {
+      isize n = lhs._.n;
+      isize n_eq = lhs._.n_eq;
+      isize n_in = lhs._.n_in;
+
+      auto dst_x = dst.head(n);
+      auto dst_y = dst.segment(n, n_eq);
+      auto dst_z = dst.tail(n_in);
+
+      auto rhs_x = rhs.head(n);
+      auto rhs_y = rhs.segment(n, n_eq);
+      auto rhs_z = rhs.tail(n_in);
+
+      dst_x += lhs._.rho * rhs_x;
+      dst_y += (-1 / lhs._.mu_eq) * rhs_y;
+      for (isize i = 0; i < n_in; ++i) {
+        dst_z[i] +=
+          (lhs._.active_constraints[i] ? -1 / lhs._.mu_in : T(1)) * rhs_z[i];
+      }
+    }
+  }
+};
+} // namespace internal
+} // namespace Eigen
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_UTILS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/views.hpp

 * *Ordering differences only*

```diff
@@ -1,63 +1,63 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_VIEWS_HPP
-#define PROXSUITE_PROXQP_SPARSE_VIEWS_HPP
-
-#include <proxsuite/linalg/dense/core.hpp>
-#include <proxsuite/linalg/sparse/core.hpp>
-#include <proxsuite/linalg/sparse/factorize.hpp>
-#include <proxsuite/linalg/sparse/update.hpp>
-#include <proxsuite/linalg/sparse/rowmod.hpp>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-#include "proxsuite/proxqp/sparse/model.hpp"
-#include "proxsuite/proxqp/results.hpp"
-
-#include <Eigen/IterativeLinearSolvers>
-#include <unsupported/Eigen/IterativeSolvers>
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-template<typename T, typename I>
-struct QpView
-{
-  proxsuite::linalg::sparse::MatRef<T, I> H;
-  proxsuite::linalg::sparse::DenseVecRef<T> g;
-  proxsuite::linalg::sparse::MatRef<T, I> AT;
-  proxsuite::linalg::sparse::DenseVecRef<T> b;
-  proxsuite::linalg::sparse::MatRef<T, I> CT;
-  proxsuite::linalg::sparse::DenseVecRef<T> l;
-  proxsuite::linalg::sparse::DenseVecRef<T> u;
-};
-
-template<typename T, typename I>
-struct QpViewMut
-{
-  proxsuite::linalg::sparse::MatMut<T, I> H;
-  proxsuite::linalg::sparse::DenseVecMut<T> g;
-  proxsuite::linalg::sparse::MatMut<T, I> AT;
-  proxsuite::linalg::sparse::DenseVecMut<T> b;
-  proxsuite::linalg::sparse::MatMut<T, I> CT;
-  proxsuite::linalg::sparse::DenseVecMut<T> l;
-  proxsuite::linalg::sparse::DenseVecMut<T> u;
-
-  auto as_const() noexcept -> QpView<T, I>
-  {
-    return {
-      H.as_const(),  g.as_const(), AT.as_const(), b.as_const(),
-      CT.as_const(), l.as_const(), u.as_const(),
-    };
-  }
-};
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_VIEWS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_VIEWS_HPP
+#define PROXSUITE_PROXQP_SPARSE_VIEWS_HPP
+
+#include <proxsuite/linalg/dense/core.hpp>
+#include <proxsuite/linalg/sparse/core.hpp>
+#include <proxsuite/linalg/sparse/factorize.hpp>
+#include <proxsuite/linalg/sparse/update.hpp>
+#include <proxsuite/linalg/sparse/rowmod.hpp>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+#include "proxsuite/proxqp/sparse/model.hpp"
+#include "proxsuite/proxqp/results.hpp"
+
+#include <Eigen/IterativeLinearSolvers>
+#include <unsupported/Eigen/IterativeSolvers>
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+template<typename T, typename I>
+struct QpView
+{
+  proxsuite::linalg::sparse::MatRef<T, I> H;
+  proxsuite::linalg::sparse::DenseVecRef<T> g;
+  proxsuite::linalg::sparse::MatRef<T, I> AT;
+  proxsuite::linalg::sparse::DenseVecRef<T> b;
+  proxsuite::linalg::sparse::MatRef<T, I> CT;
+  proxsuite::linalg::sparse::DenseVecRef<T> l;
+  proxsuite::linalg::sparse::DenseVecRef<T> u;
+};
+
+template<typename T, typename I>
+struct QpViewMut
+{
+  proxsuite::linalg::sparse::MatMut<T, I> H;
+  proxsuite::linalg::sparse::DenseVecMut<T> g;
+  proxsuite::linalg::sparse::MatMut<T, I> AT;
+  proxsuite::linalg::sparse::DenseVecMut<T> b;
+  proxsuite::linalg::sparse::MatMut<T, I> CT;
+  proxsuite::linalg::sparse::DenseVecMut<T> l;
+  proxsuite::linalg::sparse::DenseVecMut<T> u;
+
+  auto as_const() noexcept -> QpView<T, I>
+  {
+    return {
+      H.as_const(),  g.as_const(), AT.as_const(), b.as_const(),
+      CT.as_const(), l.as_const(), u.as_const(),
+    };
+  }
+};
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_VIEWS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/workspace.hpp

 * *Ordering differences only*

```diff
@@ -1,790 +1,790 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP
-#define PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP
-
-#include <proxsuite/linalg/dense/core.hpp>
-#include <proxsuite/linalg/sparse/core.hpp>
-#include <proxsuite/linalg/sparse/factorize.hpp>
-#include <proxsuite/linalg/sparse/update.hpp>
-#include <proxsuite/linalg/sparse/rowmod.hpp>
-#include <proxsuite/proxqp/timings.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/linalg/veg/vec.hpp>
-#include "proxsuite/proxqp/sparse/views.hpp"
-#include "proxsuite/proxqp/sparse/model.hpp"
-#include "proxsuite/proxqp/results.hpp"
-#include "proxsuite/proxqp/sparse/utils.hpp"
-
-#include <memory>
-#include <Eigen/IterativeLinearSolvers>
-#include <unsupported/Eigen/IterativeSolvers>
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-template<typename T, typename I>
-void
-refactorize(Workspace<T, I>& work,
-            Results<T> const& results,
-            proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
-            proxsuite::linalg::veg::SliceMut<bool> active_constraints,
-            Model<T, I> const& data,
-            proxsuite::linalg::veg::dynstack::DynStackMut stack,
-            proxsuite::linalg::veg::Tag<T>& xtag)
-{
-  isize n_tot = kkt_active.nrows();
-  T mu_eq_neg = -results.info.mu_eq;
-  T mu_in_neg = -results.info.mu_in;
-
-  if (work.internal.do_ldlt) {
-    proxsuite::linalg::sparse::factorize_symbolic_non_zeros(
-      work.internal.ldl.nnz_counts.ptr_mut(),
-      work.internal.ldl.etree.ptr_mut(),
-      work.internal.ldl.perm_inv.ptr_mut(),
-      work.internal.ldl.perm.ptr_mut(),
-      kkt_active.symbolic(),
-      stack);
-
-    isize nnz = 0;
-    VEG_ONLY_USED_FOR_DEBUG(nnz);
-    for (usize j = 0; j < usize(kkt_active.ncols()); ++j) {
-      nnz += usize(kkt_active.col_end(j) - kkt_active.col_start(j));
-    }
-    VEG_ASSERT(kkt_active.nnz() == nnz);
-    auto _diag = stack.make_new_for_overwrite(xtag, n_tot);
-    T* diag = _diag.ptr_mut();
-
-    for (isize i = 0; i < data.dim; ++i) {
-      diag[i] = results.info.rho;
-    }
-    for (isize i = 0; i < data.n_eq; ++i) {
-      diag[data.dim + i] = mu_eq_neg;
-    }
-    for (isize i = 0; i < data.n_in; ++i) {
-      diag[(data.dim + data.n_eq) + i] =
-        active_constraints[i] ? mu_in_neg : T(1);
-    }
-
-    proxsuite::linalg::sparse::factorize_numeric(
-      work.internal.ldl.values.ptr_mut(),
-      work.internal.ldl.row_indices.ptr_mut(),
-      diag,
-      work.internal.ldl.perm.ptr_mut(),
-      work.internal.ldl.col_ptrs.ptr(),
-      work.internal.ldl.etree.ptr_mut(),
-      work.internal.ldl.perm_inv.ptr_mut(),
-      kkt_active.as_const(),
-      stack);
-  } else {
-    *work.internal.matrix_free_kkt = { { kkt_active.as_const(),
-                                         active_constraints.as_const(),
-                                         data.dim,
-                                         data.n_eq,
-                                         data.n_in,
-                                         results.info.rho,
-                                         results.info.mu_eq_inv,
-                                         results.info.mu_in_inv } };
-    (*work.internal.matrix_free_solver).compute(*work.internal.matrix_free_kkt);
-  }
-}
-
-template<typename T, typename I>
-struct Ldlt
-{
-  proxsuite::linalg::veg::Vec<I> etree;
-  proxsuite::linalg::veg::Vec<I> perm;
-  proxsuite::linalg::veg::Vec<I> perm_inv;
-  proxsuite::linalg::veg::Vec<I> col_ptrs;
-  proxsuite::linalg::veg::Vec<I> nnz_counts;
-  proxsuite::linalg::veg::Vec<I> row_indices;
-  proxsuite::linalg::veg::Vec<T> values;
-};
-
-template<typename T, typename I>
-struct Workspace
-{
-
-  struct /* NOLINT */
-  {
-    // temporary allocations
-    proxsuite::linalg::veg::Vec<proxsuite::linalg::veg::mem::byte>
-      storage; // memory of the stack with the requirements req which determines
-               // its size.
-    Ldlt<T, I> ldl;
-    bool do_ldlt;
-    bool do_symbolic_fact;
-    // persistent allocations
-
-    Eigen::Matrix<T, Eigen::Dynamic, 1> g_scaled;
-    Eigen::Matrix<T, Eigen::Dynamic, 1> b_scaled;
-    Eigen::Matrix<T, Eigen::Dynamic, 1> l_scaled;
-    Eigen::Matrix<T, Eigen::Dynamic, 1> u_scaled;
-    proxsuite::linalg::veg::Vec<I> kkt_nnz_counts;
-
-    // stored in unique_ptr because we need a stable address
-    std::unique_ptr<detail::AugmentedKkt<T, I>>
-      matrix_free_kkt; // view on active part of the KKT which includes the
-                       // regularizations
-    std::unique_ptr<Eigen::MINRES<detail::AugmentedKkt<T, I>,
-                                  Eigen::Upper | Eigen::Lower,
-                                  Eigen::IdentityPreconditioner>>
-      matrix_free_solver; // eigen based method which takes in entry vector, and
-                          // performs matrix vector products
-
-    auto stack_mut() -> proxsuite::linalg::veg::dynstack::DynStackMut
-    {
-      return {
-        proxsuite::linalg::veg::from_slice_mut,
-        storage.as_mut(),
-      };
-    } // exploits all available memory in storage
-
-    // Whether the workspace is dirty
-    bool dirty;
-    bool proximal_parameter_update;
-    bool is_initialized;
-
-  } internal;
-  VecBool active_set_up;
-  VecBool active_set_low;
-  proxsuite::linalg::veg::Vec<bool> active_inequalities;
-  isize lnnz;
-  /*!
-   * Constructor using the symbolic factorization.
-   * @param results solver's results.
-   * @param data solver's model.
-   * @param settings solver's settings.
-   * @param precond_req storage requirements for the solver's preconditioner.
-   * @param H symbolic structure of the quadratic cost input defining the QP
-   * model.
-   * @param A symbolic structure of the equality constraint matrix input
-   * defining the QP model.
-   * @param C symbolic structure of the inequality constraint matrix input
-   * defining the QP model.
-   */
-  void setup_symbolic_factorizaton(
-    Model<T, I>& data,
-    proxsuite::linalg::sparse::SymbolicMatRef<I> H,
-    proxsuite::linalg::sparse::SymbolicMatRef<I> AT,
-    proxsuite::linalg::sparse::SymbolicMatRef<I> CT)
-  {
-    auto& ldl = internal.ldl;
-
-    auto& storage = internal.storage;
-    auto& do_ldlt = internal.do_ldlt;
-    // persistent allocations
-
-    data.dim = H.nrows();
-    data.n_eq = AT.ncols();
-    data.n_in = CT.ncols();
-    data.H_nnz = H.nnz();
-    data.A_nnz = AT.nnz();
-    data.C_nnz = CT.nnz();
-
-    using namespace proxsuite::linalg::veg::dynstack;
-    using namespace proxsuite::linalg::sparse::util;
-    proxsuite::linalg::veg::Tag<I> itag;
-
-    isize n = H.nrows();
-    isize n_eq = AT.ncols();
-    isize n_in = CT.ncols();
-    isize n_tot = n + n_eq + n_in;
-
-    isize nnz_tot = H.nnz() + AT.nnz() + CT.nnz();
-
-    // form the full kkt matrix
-    // assuming H, AT, CT are sorted
-    // and H is upper triangular
-    {
-      data.kkt_col_ptrs.resize_for_overwrite(n_tot + 1); //
-      data.kkt_row_indices.resize_for_overwrite(nnz_tot);
-      data.kkt_values.resize_for_overwrite(nnz_tot);
-
-      I* kktp = data.kkt_col_ptrs.ptr_mut();
-      I* kkti = data.kkt_row_indices.ptr_mut();
-
-      kktp[0] = 0;
-      usize col = 0;
-      usize pos = 0;
-
-      auto insert_submatrix =
-        [&](proxsuite::linalg::sparse::SymbolicMatRef<I> m,
-            bool assert_sym_hi) -> void {
-        I const* mi = m.row_indices();
-        isize ncols = m.ncols();
-
-        for (usize j = 0; j < usize(ncols); ++j) {
-          usize col_start = m.col_start(j);
-          usize col_end = m.col_end(j);
-
-          kktp[col + 1] =
-            checked_non_negative_plus(kktp[col], I(col_end - col_start));
-          ++col;
-
-          for (usize p = col_start; p < col_end; ++p) {
-            usize i = zero_extend(mi[p]);
-            if (assert_sym_hi) {
-              VEG_ASSERT(i <= j);
-            }
-
-            kkti[pos] = proxsuite::linalg::veg::nb::narrow<I>{}(i);
-
-            ++pos;
-          }
-        }
-      };
-
-      insert_submatrix(H, true);
-      insert_submatrix(AT, false);
-      insert_submatrix(CT, false);
-    }
-
-    data.kkt_col_ptrs_unscaled = data.kkt_col_ptrs;
-    data.kkt_row_indices_unscaled = data.kkt_row_indices;
-
-    storage.resize_for_overwrite( //
-      (StackReq::with_len(itag, n_tot) &
-       proxsuite::linalg::sparse::factorize_symbolic_req( //
-         itag,                                            //
-         n_tot,                                           //
-         nnz_tot,                                         //
-         proxsuite::linalg::sparse::Ordering::amd))       //
-        .alloc_req()                                      //
-    );
-
-    ldl.col_ptrs.resize_for_overwrite(n_tot + 1);
-    ldl.perm_inv.resize_for_overwrite(n_tot);
-
-    DynStackMut stack = stack_mut();
-
-    bool overflow = false;
-    {
-      ldl.etree.resize_for_overwrite(n_tot);
-      auto etree_ptr = ldl.etree.ptr_mut();
-
-      using namespace proxsuite::linalg::veg::literals;
-      auto kkt_sym = proxsuite::linalg::sparse::SymbolicMatRef<I>{
-        proxsuite::linalg::sparse::from_raw_parts,
-        n_tot,
-        n_tot,
-        nnz_tot,
-        data.kkt_col_ptrs.ptr(),
-        nullptr,
-        data.kkt_row_indices.ptr(),
-      };
-      proxsuite::linalg::sparse::factorize_symbolic_non_zeros( //
-        ldl.col_ptrs.ptr_mut() +
-          1, // reimplements col counts to get the matrix free version as well
-        etree_ptr,
-        ldl.perm_inv.ptr_mut(),
-        static_cast<I const*>(nullptr),
-        kkt_sym,
-        stack);
-
-      auto pcol_ptrs = ldl.col_ptrs.ptr_mut();
-      pcol_ptrs[0] = I(0);
-
-      using proxsuite::linalg::veg::u64;
-      u64 acc = 0;
-
-      for (usize i = 0; i < usize(n_tot); ++i) {
-        acc += u64(zero_extend(pcol_ptrs[i + 1]));
-        if (acc != u64(I(acc))) {
-          overflow = true;
-        }
-        pcol_ptrs[(i + 1)] = I(acc);
-      }
-    }
-
-    lnnz = isize(zero_extend(ldl.col_ptrs[n_tot]));
-
-    // if ldlt is too sparse
-    // do_ldlt = !overflow && lnnz < (10000000);
-    do_ldlt = !overflow && lnnz < 10000000;
-
-    internal.do_symbolic_fact = false;
-  }
-  /*!
-   * Constructor.
-   * @param qp view on the qp problem.
-   * @param data solver's model.
-   * @param settings solver's settings.
-   * @param execute_or_not boolean option for execturing or not the
-   * preconditioner for scaling the problem (and reduce its ill conditioning).
-   * @param precond preconditioner chosen for the solver.
-   * @param precond_req storage requirements for the solver's preconditioner.
-   */
-  template<typename P>
-  void setup_impl(const QpView<T, I> qp,
-                  Model<T, I>& data,
-                  const Settings<T>& settings,
-                  bool execute_or_not,
-                  P& precond,
-                  proxsuite::linalg::veg::dynstack::StackReq precond_req)
-  {
-
-    auto& ldl = internal.ldl;
-
-    auto& storage = internal.storage;
-    auto& do_ldlt = internal.do_ldlt;
-    // persistent allocations
-
-    auto& g_scaled = internal.g_scaled;
-    auto& b_scaled = internal.b_scaled;
-    auto& l_scaled = internal.l_scaled;
-    auto& u_scaled = internal.u_scaled;
-    auto& kkt_nnz_counts = internal.kkt_nnz_counts;
-
-    // stored in unique_ptr because we need a stable address
-    auto& matrix_free_solver = internal.matrix_free_solver;
-    auto& matrix_free_kkt = internal.matrix_free_kkt;
-
-    data.dim = qp.H.nrows();
-    data.n_eq = qp.AT.ncols();
-    data.n_in = qp.CT.ncols();
-    data.H_nnz = qp.H.nnz();
-    data.A_nnz = qp.AT.nnz();
-    data.C_nnz = qp.CT.nnz();
-
-    data.g = qp.g.to_eigen();
-    data.b = qp.b.to_eigen();
-    data.l = qp.l.to_eigen();
-    data.u = qp.u.to_eigen();
-
-    using namespace proxsuite::linalg::veg::dynstack;
-    using namespace proxsuite::linalg::sparse::util;
-
-    using SR = StackReq;
-    proxsuite::linalg::veg::Tag<I> itag;
-    proxsuite::linalg::veg::Tag<T> xtag;
-
-    isize n = qp.H.nrows();
-    isize n_eq = qp.AT.ncols();
-    isize n_in = qp.CT.ncols();
-    isize n_tot = n + n_eq + n_in;
-
-    isize nnz_tot = qp.H.nnz() + qp.AT.nnz() + qp.CT.nnz();
-
-    if (internal.do_symbolic_fact) {
-
-      // form the full kkt matrix
-      // assuming H, AT, CT are sorted
-      // and H is upper triangular
-      {
-        data.kkt_col_ptrs.resize_for_overwrite(n_tot + 1);
-        data.kkt_row_indices.resize_for_overwrite(nnz_tot);
-        data.kkt_values.resize_for_overwrite(nnz_tot);
-
-        I* kktp = data.kkt_col_ptrs.ptr_mut();
-        I* kkti = data.kkt_row_indices.ptr_mut();
-        T* kktx = data.kkt_values.ptr_mut();
-
-        kktp[0] = 0;
-        usize col = 0;
-        usize pos = 0;
-
-        auto insert_submatrix = [&](proxsuite::linalg::sparse::MatRef<T, I> m,
-                                    bool assert_sym_hi) -> void {
-          I const* mi = m.row_indices();
-          T const* mx = m.values();
-          isize ncols = m.ncols();
-
-          for (usize j = 0; j < usize(ncols); ++j) {
-            usize col_start = m.col_start(j);
-            usize col_end = m.col_end(j);
-
-            kktp[col + 1] =
-              checked_non_negative_plus(kktp[col], I(col_end - col_start));
-            ++col;
-
-            for (usize p = col_start; p < col_end; ++p) {
-              usize i = zero_extend(mi[p]);
-              if (assert_sym_hi) {
-                VEG_ASSERT(i <= j);
-              }
-
-              kkti[pos] = proxsuite::linalg::veg::nb::narrow<I>{}(i);
-              kktx[pos] = mx[p];
-
-              ++pos;
-            }
-          }
-        };
-
-        insert_submatrix(qp.H, true);
-        insert_submatrix(qp.AT, false);
-        insert_submatrix(qp.CT, false);
-      }
-
-      data.kkt_col_ptrs_unscaled = data.kkt_col_ptrs;
-      data.kkt_row_indices_unscaled = data.kkt_row_indices;
-      data.kkt_values_unscaled = data.kkt_values;
-
-      storage.resize_for_overwrite( //
-        (StackReq::with_len(itag, n_tot) &
-         proxsuite::linalg::sparse::factorize_symbolic_req( //
-           itag,                                            //
-           n_tot,                                           //
-           nnz_tot,                                         //
-           proxsuite::linalg::sparse::Ordering::amd))       //
-          .alloc_req()                                      //
-      );
-
-      ldl.col_ptrs.resize_for_overwrite(n_tot + 1);
-      ldl.perm_inv.resize_for_overwrite(n_tot);
-
-      DynStackMut stack = stack_mut();
-
-      bool overflow = false;
-      {
-        ldl.etree.resize_for_overwrite(n_tot);
-        auto etree_ptr = ldl.etree.ptr_mut();
-
-        using namespace proxsuite::linalg::veg::literals;
-        auto kkt_sym = proxsuite::linalg::sparse::SymbolicMatRef<I>{
-          proxsuite::linalg::sparse::from_raw_parts,
-          n_tot,
-          n_tot,
-          nnz_tot,
-          data.kkt_col_ptrs.ptr(),
-          nullptr,
-          data.kkt_row_indices.ptr(),
-        };
-        proxsuite::linalg::sparse::factorize_symbolic_non_zeros( //
-          ldl.col_ptrs.ptr_mut() + 1,
-          etree_ptr,
-          ldl.perm_inv.ptr_mut(),
-          static_cast<I const*>(nullptr),
-          kkt_sym,
-          stack);
-
-        auto pcol_ptrs = ldl.col_ptrs.ptr_mut();
-        pcol_ptrs[0] = I(0); // pcol_ptrs +1: pointor towards the nbr of non
-                             // zero elts per column of the ldlt
-        // we need to compute its cumulative sum below to determine if there
-        // could be an overflow
-
-        using proxsuite::linalg::veg::u64;
-        u64 acc = 0;
-
-        for (usize i = 0; i < usize(n_tot); ++i) {
-          acc += u64(zero_extend(pcol_ptrs[i + 1]));
-          if (acc != u64(I(acc))) {
-            overflow = true;
-          }
-          pcol_ptrs[(i + 1)] = I(acc);
-        }
-      }
-
-      auto lnnz = isize(zero_extend(ldl.col_ptrs[n_tot]));
-
-      // if ldlt is too sparse
-      // do_ldlt = !overflow && lnnz < (10000000);
-      if (settings.sparse_backend == SparseBackend::Automatic) {
-        do_ldlt = !overflow && lnnz < 10000000;
-      } else if (settings.sparse_backend == SparseBackend::SparseCholesky) {
-        do_ldlt = true;
-      } else {
-        do_ldlt = false;
-      }
-
-    } else {
-      T* kktx = data.kkt_values.ptr_mut();
-      usize pos = 0;
-      auto insert_submatrix =
-        [&](proxsuite::linalg::sparse::MatRef<T, I> m) -> void {
-        T const* mx = m.values();
-        isize ncols = m.ncols();
-
-        for (usize j = 0; j < usize(ncols); ++j) {
-          usize col_start = m.col_start(j);
-          usize col_end = m.col_end(j);
-          for (usize p = col_start; p < col_end; ++p) {
-
-            kktx[pos] = mx[p];
-
-            ++pos;
-          }
-        }
-      };
-
-      insert_submatrix(qp.H);
-      insert_submatrix(qp.AT);
-      insert_submatrix(qp.CT);
-      data.kkt_values_unscaled = data.kkt_values;
-    }
-#define PROX_QP_ALL_OF(...)                                                    \
-  ::proxsuite::linalg::veg::dynstack::StackReq::and_(                          \
-    ::proxsuite::linalg::veg::init_list(__VA_ARGS__))
-#define PROX_QP_ANY_OF(...)                                                    \
-  ::proxsuite::linalg::veg::dynstack::StackReq::or_(                           \
-    ::proxsuite::linalg::veg::init_list(__VA_ARGS__))
-    //  ? --> if
-    auto refactorize_req =
-      do_ldlt
-        ? PROX_QP_ANY_OF({
-            proxsuite::linalg::sparse::factorize_symbolic_req( // symbolic ldl
-              itag,
-              n_tot,
-              nnz_tot,
-              proxsuite::linalg::sparse::Ordering::user_provided),
-            PROX_QP_ALL_OF({
-              SR::with_len(xtag, n_tot),                        // diag
-              proxsuite::linalg::sparse::factorize_numeric_req( // numeric ldl
-                xtag,
-                itag,
-                n_tot,
-                nnz_tot,
-                proxsuite::linalg::sparse::Ordering::user_provided),
-            }),
-          })
-        : PROX_QP_ALL_OF({
-            SR::with_len(itag, 0), // compute necessary space for storing n elts
-                                   // of type I (n = 0 here)
-            SR::with_len(xtag, 0), // compute necessary space for storing n elts
-                                   // of type T (n = 0 here)
-          });
-
-    auto x_vec = [&](isize n) noexcept -> StackReq {
-      return proxsuite::linalg::dense::temp_vec_req(xtag, n);
-    };
-
-    auto ldl_solve_in_place_req = PROX_QP_ALL_OF({
-      x_vec(n_tot), // tmp
-      x_vec(n_tot), // err
-      x_vec(n_tot), // work
-    });
-
-    auto unscaled_primal_dual_residual_req = x_vec(n); // Hx
-    auto line_search_req = PROX_QP_ALL_OF({
-      x_vec(2 * n_in), // alphas
-      x_vec(n),        // Cdx_active
-      x_vec(n_in),     // active_part_z
-      x_vec(n_in),     // tmp_lo
-      x_vec(n_in),     // tmp_up
-    });
-    // define memory needed for primal_dual_newton_semi_smooth
-    // PROX_QP_ALL_OF --> need to store all argument inside
-    // PROX_QP_ANY_OF --> au moins un de  ceux en entrée
-    auto primal_dual_newton_semi_smooth_req = PROX_QP_ALL_OF({
-      x_vec(n_tot), // dw
-      PROX_QP_ANY_OF({
-        ldl_solve_in_place_req,
-        PROX_QP_ALL_OF({
-          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
-                       n_in), // active_set_lo
-          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
-                       n_in), // active_set_up
-          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
-                       n_in), // new_active_constraints
-          (do_ldlt && n_in > 0) ? PROX_QP_ANY_OF({
-                                    proxsuite::linalg::sparse::add_row_req(
-                                      xtag, itag, n_tot, false, n, n_tot),
-                                    proxsuite::linalg::sparse::delete_row_req(
-                                      xtag, itag, n_tot, n_tot),
-                                  })
-                                : refactorize_req,
-        }),
-        PROX_QP_ALL_OF({
-          x_vec(n),    // Hdx
-          x_vec(n_eq), // Adx
-          x_vec(n_in), // Cdx
-          x_vec(n),    // ATdy
-          x_vec(n),    // CTdz
-        }),
-      }),
-      line_search_req,
-    });
-
-    auto iter_req = PROX_QP_ANY_OF({
-      PROX_QP_ALL_OF({ x_vec(n_eq), // primal_residual_eq_scaled
-                       x_vec(n_in), // primal_residual_in_scaled_lo
-                       x_vec(n_in), // primal_residual_in_scaled_up
-                       x_vec(n_in), // primal_residual_in_scaled_up
-                       x_vec(n),    // dual_residual_scaled
-                       PROX_QP_ANY_OF({
-                         unscaled_primal_dual_residual_req,
-                         PROX_QP_ALL_OF({
-                           x_vec(n),    // x_prev
-                           x_vec(n_eq), // y_prev
-                           x_vec(n_in), // z_prev
-                           primal_dual_newton_semi_smooth_req,
-                         }),
-                       }) }),
-      refactorize_req, // mu_update
-    });
-
-    auto req = //
-      PROX_QP_ALL_OF({
-        x_vec(n),    // g_scaled
-        x_vec(n_eq), // b_scaled
-        x_vec(n_in), // l_scaled
-        x_vec(n_in), // u_scaled
-        SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
-                     n_in),        // active constr
-        SR::with_len(itag, n_tot), // kkt nnz counts
-        refactorize_req,
-        PROX_QP_ANY_OF({
-          precond_req,
-          PROX_QP_ALL_OF({
-            do_ldlt ? PROX_QP_ALL_OF({
-                        SR::with_len(itag, n_tot), // perm
-                        SR::with_len(itag, n_tot), // etree
-                        SR::with_len(itag, n_tot), // ldl nnz counts
-                        SR::with_len(itag, lnnz),  // ldl row indices
-                        SR::with_len(xtag, lnnz),  // ldl values
-                      })
-                    : PROX_QP_ALL_OF({
-                        SR::with_len(itag, 0),
-                        SR::with_len(xtag, 0),
-                      }),
-            iter_req,
-          }),
-        }),
-      });
-
-    storage.resize_for_overwrite(
-      req.alloc_req()); // defines the maximal storage size
-    // storage.resize(n): if it is done twice in a row, the second times it does
-    // nothing, as the same resize has been asked
-
-    // preconditioner
-    auto kkt = data.kkt_mut();
-    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
-      proxsuite::linalg::veg::unsafe,
-      kkt,
-      n); //  top_rows_mut_unchecked: take a view of sparse matrix for n first
-          //  lines ; the function assumes all others lines are zeros;
-    /*
-            H AT CT
-            A
-            C
-
-            here we store the upper triangular part below
-
-            tirSup(H) AT CT
-            0 0 0
-            0 0 0
-
-            proxsuite::linalg::veg::unsafe:  precises that the function has
-       undefined behavior if upper condition is not respected.
-    */
-
-    proxsuite::linalg::sparse::MatMut<T, I> H_scaled =
-      detail::middle_cols_mut(kkt_top_n_rows, 0, n, data.H_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> AT_scaled =
-      detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, data.A_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> CT_scaled =
-      detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, data.C_nnz);
-
-    g_scaled = data.g;
-    b_scaled = data.b;
-    u_scaled =
-      (data.u.array() <= T(1.E20))
-        .select(data.u,
-                Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(data.n_in).array() +
-                  T(1.E20));
-    l_scaled =
-      (data.l.array() >= T(-1.E20))
-        .select(data.l,
-                Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(data.n_in).array() -
-                  T(1.E20));
-
-    QpViewMut<T, I> qp_scaled = {
-      H_scaled,
-      { proxsuite::linalg::sparse::from_eigen, g_scaled },
-      AT_scaled,
-      { proxsuite::linalg::sparse::from_eigen, b_scaled },
-      CT_scaled,
-      { proxsuite::linalg::sparse::from_eigen, l_scaled },
-      { proxsuite::linalg::sparse::from_eigen, u_scaled },
-    };
-
-    DynStackMut stack = stack_mut();
-    precond.scale_qp_in_place(qp_scaled,
-                              execute_or_not,
-                              settings.preconditioner_max_iter,
-                              settings.preconditioner_accuracy,
-                              stack);
-    kkt_nnz_counts.resize_for_overwrite(n_tot);
-
-    proxsuite::linalg::sparse::MatMut<T, I> kkt_active = {
-      proxsuite::linalg::sparse::from_raw_parts,
-      n_tot,
-      n_tot,
-      data.H_nnz +
-        data.A_nnz, // these variables are not used for the matrix vector
-                    // product in augmented KKT with Min res algorithm (to be
-                    // exact, it should depend of the initial guess)
-      kkt.col_ptrs_mut(),
-      kkt_nnz_counts.ptr_mut(),
-      kkt.row_indices_mut(),
-      kkt.values_mut(),
-    };
-
-    using MatrixFreeSolver = Eigen::MINRES<detail::AugmentedKkt<T, I>,
-                                           Eigen::Upper | Eigen::Lower,
-                                           Eigen::IdentityPreconditioner>;
-    matrix_free_solver = std::unique_ptr<MatrixFreeSolver>{
-      new MatrixFreeSolver,
-    };
-    matrix_free_kkt = std::unique_ptr<detail::AugmentedKkt<T, I>>{
-      new detail::AugmentedKkt<T, I>{
-        {
-          kkt_active.as_const(),
-          {},
-          n,
-          n_eq,
-          n_in,
-          {},
-          {},
-          {},
-        },
-      }
-    };
-
-    auto zx = proxsuite::linalg::sparse::util::zero_extend; // ?
-    auto max_lnnz = isize(zx(ldl.col_ptrs[n_tot]));
-    isize ldlt_ntot = do_ldlt ? n_tot : 0;
-    isize ldlt_lnnz = do_ldlt ? max_lnnz : 0;
-
-    ldl.nnz_counts.resize_for_overwrite(ldlt_ntot);
-    ldl.row_indices.resize_for_overwrite(ldlt_lnnz);
-    ldl.values.resize_for_overwrite(ldlt_lnnz);
-
-    ldl.perm.resize_for_overwrite(ldlt_ntot);
-    if (do_ldlt) {
-      // compute perm from perm_inv
-      for (isize i = 0; i < n_tot; ++i) {
-        ldl.perm[isize(zx(ldl.perm_inv[i]))] = I(i);
-      }
-    }
-
-    internal.dirty = false;
-  }
-  Timer<T> timer;
-  Workspace() = default;
-
-  auto ldl_col_ptrs() const -> I const* { return internal.ldl.col_ptrs.ptr(); }
-  auto ldl_col_ptrs_mut() -> I* { return internal.ldl.col_ptrs.ptr_mut(); }
-  auto stack_mut() -> proxsuite::linalg::veg::dynstack::DynStackMut
-  {
-    return internal.stack_mut();
-  }
-
-  void set_dirty() { internal.dirty = true; }
-};
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP
+#define PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP
+
+#include <proxsuite/linalg/dense/core.hpp>
+#include <proxsuite/linalg/sparse/core.hpp>
+#include <proxsuite/linalg/sparse/factorize.hpp>
+#include <proxsuite/linalg/sparse/update.hpp>
+#include <proxsuite/linalg/sparse/rowmod.hpp>
+#include <proxsuite/proxqp/timings.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/linalg/veg/vec.hpp>
+#include "proxsuite/proxqp/sparse/views.hpp"
+#include "proxsuite/proxqp/sparse/model.hpp"
+#include "proxsuite/proxqp/results.hpp"
+#include "proxsuite/proxqp/sparse/utils.hpp"
+
+#include <memory>
+#include <Eigen/IterativeLinearSolvers>
+#include <unsupported/Eigen/IterativeSolvers>
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+template<typename T, typename I>
+void
+refactorize(Workspace<T, I>& work,
+            Results<T> const& results,
+            proxsuite::linalg::sparse::MatMut<T, I> kkt_active,
+            proxsuite::linalg::veg::SliceMut<bool> active_constraints,
+            Model<T, I> const& data,
+            proxsuite::linalg::veg::dynstack::DynStackMut stack,
+            proxsuite::linalg::veg::Tag<T>& xtag)
+{
+  isize n_tot = kkt_active.nrows();
+  T mu_eq_neg = -results.info.mu_eq;
+  T mu_in_neg = -results.info.mu_in;
+
+  if (work.internal.do_ldlt) {
+    proxsuite::linalg::sparse::factorize_symbolic_non_zeros(
+      work.internal.ldl.nnz_counts.ptr_mut(),
+      work.internal.ldl.etree.ptr_mut(),
+      work.internal.ldl.perm_inv.ptr_mut(),
+      work.internal.ldl.perm.ptr_mut(),
+      kkt_active.symbolic(),
+      stack);
+
+    isize nnz = 0;
+    VEG_ONLY_USED_FOR_DEBUG(nnz);
+    for (usize j = 0; j < usize(kkt_active.ncols()); ++j) {
+      nnz += usize(kkt_active.col_end(j) - kkt_active.col_start(j));
+    }
+    VEG_ASSERT(kkt_active.nnz() == nnz);
+    auto _diag = stack.make_new_for_overwrite(xtag, n_tot);
+    T* diag = _diag.ptr_mut();
+
+    for (isize i = 0; i < data.dim; ++i) {
+      diag[i] = results.info.rho;
+    }
+    for (isize i = 0; i < data.n_eq; ++i) {
+      diag[data.dim + i] = mu_eq_neg;
+    }
+    for (isize i = 0; i < data.n_in; ++i) {
+      diag[(data.dim + data.n_eq) + i] =
+        active_constraints[i] ? mu_in_neg : T(1);
+    }
+
+    proxsuite::linalg::sparse::factorize_numeric(
+      work.internal.ldl.values.ptr_mut(),
+      work.internal.ldl.row_indices.ptr_mut(),
+      diag,
+      work.internal.ldl.perm.ptr_mut(),
+      work.internal.ldl.col_ptrs.ptr(),
+      work.internal.ldl.etree.ptr_mut(),
+      work.internal.ldl.perm_inv.ptr_mut(),
+      kkt_active.as_const(),
+      stack);
+  } else {
+    *work.internal.matrix_free_kkt = { { kkt_active.as_const(),
+                                         active_constraints.as_const(),
+                                         data.dim,
+                                         data.n_eq,
+                                         data.n_in,
+                                         results.info.rho,
+                                         results.info.mu_eq_inv,
+                                         results.info.mu_in_inv } };
+    (*work.internal.matrix_free_solver).compute(*work.internal.matrix_free_kkt);
+  }
+}
+
+template<typename T, typename I>
+struct Ldlt
+{
+  proxsuite::linalg::veg::Vec<I> etree;
+  proxsuite::linalg::veg::Vec<I> perm;
+  proxsuite::linalg::veg::Vec<I> perm_inv;
+  proxsuite::linalg::veg::Vec<I> col_ptrs;
+  proxsuite::linalg::veg::Vec<I> nnz_counts;
+  proxsuite::linalg::veg::Vec<I> row_indices;
+  proxsuite::linalg::veg::Vec<T> values;
+};
+
+template<typename T, typename I>
+struct Workspace
+{
+
+  struct /* NOLINT */
+  {
+    // temporary allocations
+    proxsuite::linalg::veg::Vec<proxsuite::linalg::veg::mem::byte>
+      storage; // memory of the stack with the requirements req which determines
+               // its size.
+    Ldlt<T, I> ldl;
+    bool do_ldlt;
+    bool do_symbolic_fact;
+    // persistent allocations
+
+    Eigen::Matrix<T, Eigen::Dynamic, 1> g_scaled;
+    Eigen::Matrix<T, Eigen::Dynamic, 1> b_scaled;
+    Eigen::Matrix<T, Eigen::Dynamic, 1> l_scaled;
+    Eigen::Matrix<T, Eigen::Dynamic, 1> u_scaled;
+    proxsuite::linalg::veg::Vec<I> kkt_nnz_counts;
+
+    // stored in unique_ptr because we need a stable address
+    std::unique_ptr<detail::AugmentedKkt<T, I>>
+      matrix_free_kkt; // view on active part of the KKT which includes the
+                       // regularizations
+    std::unique_ptr<Eigen::MINRES<detail::AugmentedKkt<T, I>,
+                                  Eigen::Upper | Eigen::Lower,
+                                  Eigen::IdentityPreconditioner>>
+      matrix_free_solver; // eigen based method which takes in entry vector, and
+                          // performs matrix vector products
+
+    auto stack_mut() -> proxsuite::linalg::veg::dynstack::DynStackMut
+    {
+      return {
+        proxsuite::linalg::veg::from_slice_mut,
+        storage.as_mut(),
+      };
+    } // exploits all available memory in storage
+
+    // Whether the workspace is dirty
+    bool dirty;
+    bool proximal_parameter_update;
+    bool is_initialized;
+
+  } internal;
+  VecBool active_set_up;
+  VecBool active_set_low;
+  proxsuite::linalg::veg::Vec<bool> active_inequalities;
+  isize lnnz;
+  /*!
+   * Constructor using the symbolic factorization.
+   * @param results solver's results.
+   * @param data solver's model.
+   * @param settings solver's settings.
+   * @param precond_req storage requirements for the solver's preconditioner.
+   * @param H symbolic structure of the quadratic cost input defining the QP
+   * model.
+   * @param A symbolic structure of the equality constraint matrix input
+   * defining the QP model.
+   * @param C symbolic structure of the inequality constraint matrix input
+   * defining the QP model.
+   */
+  void setup_symbolic_factorizaton(
+    Model<T, I>& data,
+    proxsuite::linalg::sparse::SymbolicMatRef<I> H,
+    proxsuite::linalg::sparse::SymbolicMatRef<I> AT,
+    proxsuite::linalg::sparse::SymbolicMatRef<I> CT)
+  {
+    auto& ldl = internal.ldl;
+
+    auto& storage = internal.storage;
+    auto& do_ldlt = internal.do_ldlt;
+    // persistent allocations
+
+    data.dim = H.nrows();
+    data.n_eq = AT.ncols();
+    data.n_in = CT.ncols();
+    data.H_nnz = H.nnz();
+    data.A_nnz = AT.nnz();
+    data.C_nnz = CT.nnz();
+
+    using namespace proxsuite::linalg::veg::dynstack;
+    using namespace proxsuite::linalg::sparse::util;
+    proxsuite::linalg::veg::Tag<I> itag;
+
+    isize n = H.nrows();
+    isize n_eq = AT.ncols();
+    isize n_in = CT.ncols();
+    isize n_tot = n + n_eq + n_in;
+
+    isize nnz_tot = H.nnz() + AT.nnz() + CT.nnz();
+
+    // form the full kkt matrix
+    // assuming H, AT, CT are sorted
+    // and H is upper triangular
+    {
+      data.kkt_col_ptrs.resize_for_overwrite(n_tot + 1); //
+      data.kkt_row_indices.resize_for_overwrite(nnz_tot);
+      data.kkt_values.resize_for_overwrite(nnz_tot);
+
+      I* kktp = data.kkt_col_ptrs.ptr_mut();
+      I* kkti = data.kkt_row_indices.ptr_mut();
+
+      kktp[0] = 0;
+      usize col = 0;
+      usize pos = 0;
+
+      auto insert_submatrix =
+        [&](proxsuite::linalg::sparse::SymbolicMatRef<I> m,
+            bool assert_sym_hi) -> void {
+        I const* mi = m.row_indices();
+        isize ncols = m.ncols();
+
+        for (usize j = 0; j < usize(ncols); ++j) {
+          usize col_start = m.col_start(j);
+          usize col_end = m.col_end(j);
+
+          kktp[col + 1] =
+            checked_non_negative_plus(kktp[col], I(col_end - col_start));
+          ++col;
+
+          for (usize p = col_start; p < col_end; ++p) {
+            usize i = zero_extend(mi[p]);
+            if (assert_sym_hi) {
+              VEG_ASSERT(i <= j);
+            }
+
+            kkti[pos] = proxsuite::linalg::veg::nb::narrow<I>{}(i);
+
+            ++pos;
+          }
+        }
+      };
+
+      insert_submatrix(H, true);
+      insert_submatrix(AT, false);
+      insert_submatrix(CT, false);
+    }
+
+    data.kkt_col_ptrs_unscaled = data.kkt_col_ptrs;
+    data.kkt_row_indices_unscaled = data.kkt_row_indices;
+
+    storage.resize_for_overwrite( //
+      (StackReq::with_len(itag, n_tot) &
+       proxsuite::linalg::sparse::factorize_symbolic_req( //
+         itag,                                            //
+         n_tot,                                           //
+         nnz_tot,                                         //
+         proxsuite::linalg::sparse::Ordering::amd))       //
+        .alloc_req()                                      //
+    );
+
+    ldl.col_ptrs.resize_for_overwrite(n_tot + 1);
+    ldl.perm_inv.resize_for_overwrite(n_tot);
+
+    DynStackMut stack = stack_mut();
+
+    bool overflow = false;
+    {
+      ldl.etree.resize_for_overwrite(n_tot);
+      auto etree_ptr = ldl.etree.ptr_mut();
+
+      using namespace proxsuite::linalg::veg::literals;
+      auto kkt_sym = proxsuite::linalg::sparse::SymbolicMatRef<I>{
+        proxsuite::linalg::sparse::from_raw_parts,
+        n_tot,
+        n_tot,
+        nnz_tot,
+        data.kkt_col_ptrs.ptr(),
+        nullptr,
+        data.kkt_row_indices.ptr(),
+      };
+      proxsuite::linalg::sparse::factorize_symbolic_non_zeros( //
+        ldl.col_ptrs.ptr_mut() +
+          1, // reimplements col counts to get the matrix free version as well
+        etree_ptr,
+        ldl.perm_inv.ptr_mut(),
+        static_cast<I const*>(nullptr),
+        kkt_sym,
+        stack);
+
+      auto pcol_ptrs = ldl.col_ptrs.ptr_mut();
+      pcol_ptrs[0] = I(0);
+
+      using proxsuite::linalg::veg::u64;
+      u64 acc = 0;
+
+      for (usize i = 0; i < usize(n_tot); ++i) {
+        acc += u64(zero_extend(pcol_ptrs[i + 1]));
+        if (acc != u64(I(acc))) {
+          overflow = true;
+        }
+        pcol_ptrs[(i + 1)] = I(acc);
+      }
+    }
+
+    lnnz = isize(zero_extend(ldl.col_ptrs[n_tot]));
+
+    // if ldlt is too sparse
+    // do_ldlt = !overflow && lnnz < (10000000);
+    do_ldlt = !overflow && lnnz < 10000000;
+
+    internal.do_symbolic_fact = false;
+  }
+  /*!
+   * Constructor.
+   * @param qp view on the qp problem.
+   * @param data solver's model.
+   * @param settings solver's settings.
+   * @param execute_or_not boolean option for execturing or not the
+   * preconditioner for scaling the problem (and reduce its ill conditioning).
+   * @param precond preconditioner chosen for the solver.
+   * @param precond_req storage requirements for the solver's preconditioner.
+   */
+  template<typename P>
+  void setup_impl(const QpView<T, I> qp,
+                  Model<T, I>& data,
+                  const Settings<T>& settings,
+                  bool execute_or_not,
+                  P& precond,
+                  proxsuite::linalg::veg::dynstack::StackReq precond_req)
+  {
+
+    auto& ldl = internal.ldl;
+
+    auto& storage = internal.storage;
+    auto& do_ldlt = internal.do_ldlt;
+    // persistent allocations
+
+    auto& g_scaled = internal.g_scaled;
+    auto& b_scaled = internal.b_scaled;
+    auto& l_scaled = internal.l_scaled;
+    auto& u_scaled = internal.u_scaled;
+    auto& kkt_nnz_counts = internal.kkt_nnz_counts;
+
+    // stored in unique_ptr because we need a stable address
+    auto& matrix_free_solver = internal.matrix_free_solver;
+    auto& matrix_free_kkt = internal.matrix_free_kkt;
+
+    data.dim = qp.H.nrows();
+    data.n_eq = qp.AT.ncols();
+    data.n_in = qp.CT.ncols();
+    data.H_nnz = qp.H.nnz();
+    data.A_nnz = qp.AT.nnz();
+    data.C_nnz = qp.CT.nnz();
+
+    data.g = qp.g.to_eigen();
+    data.b = qp.b.to_eigen();
+    data.l = qp.l.to_eigen();
+    data.u = qp.u.to_eigen();
+
+    using namespace proxsuite::linalg::veg::dynstack;
+    using namespace proxsuite::linalg::sparse::util;
+
+    using SR = StackReq;
+    proxsuite::linalg::veg::Tag<I> itag;
+    proxsuite::linalg::veg::Tag<T> xtag;
+
+    isize n = qp.H.nrows();
+    isize n_eq = qp.AT.ncols();
+    isize n_in = qp.CT.ncols();
+    isize n_tot = n + n_eq + n_in;
+
+    isize nnz_tot = qp.H.nnz() + qp.AT.nnz() + qp.CT.nnz();
+
+    if (internal.do_symbolic_fact) {
+
+      // form the full kkt matrix
+      // assuming H, AT, CT are sorted
+      // and H is upper triangular
+      {
+        data.kkt_col_ptrs.resize_for_overwrite(n_tot + 1);
+        data.kkt_row_indices.resize_for_overwrite(nnz_tot);
+        data.kkt_values.resize_for_overwrite(nnz_tot);
+
+        I* kktp = data.kkt_col_ptrs.ptr_mut();
+        I* kkti = data.kkt_row_indices.ptr_mut();
+        T* kktx = data.kkt_values.ptr_mut();
+
+        kktp[0] = 0;
+        usize col = 0;
+        usize pos = 0;
+
+        auto insert_submatrix = [&](proxsuite::linalg::sparse::MatRef<T, I> m,
+                                    bool assert_sym_hi) -> void {
+          I const* mi = m.row_indices();
+          T const* mx = m.values();
+          isize ncols = m.ncols();
+
+          for (usize j = 0; j < usize(ncols); ++j) {
+            usize col_start = m.col_start(j);
+            usize col_end = m.col_end(j);
+
+            kktp[col + 1] =
+              checked_non_negative_plus(kktp[col], I(col_end - col_start));
+            ++col;
+
+            for (usize p = col_start; p < col_end; ++p) {
+              usize i = zero_extend(mi[p]);
+              if (assert_sym_hi) {
+                VEG_ASSERT(i <= j);
+              }
+
+              kkti[pos] = proxsuite::linalg::veg::nb::narrow<I>{}(i);
+              kktx[pos] = mx[p];
+
+              ++pos;
+            }
+          }
+        };
+
+        insert_submatrix(qp.H, true);
+        insert_submatrix(qp.AT, false);
+        insert_submatrix(qp.CT, false);
+      }
+
+      data.kkt_col_ptrs_unscaled = data.kkt_col_ptrs;
+      data.kkt_row_indices_unscaled = data.kkt_row_indices;
+      data.kkt_values_unscaled = data.kkt_values;
+
+      storage.resize_for_overwrite( //
+        (StackReq::with_len(itag, n_tot) &
+         proxsuite::linalg::sparse::factorize_symbolic_req( //
+           itag,                                            //
+           n_tot,                                           //
+           nnz_tot,                                         //
+           proxsuite::linalg::sparse::Ordering::amd))       //
+          .alloc_req()                                      //
+      );
+
+      ldl.col_ptrs.resize_for_overwrite(n_tot + 1);
+      ldl.perm_inv.resize_for_overwrite(n_tot);
+
+      DynStackMut stack = stack_mut();
+
+      bool overflow = false;
+      {
+        ldl.etree.resize_for_overwrite(n_tot);
+        auto etree_ptr = ldl.etree.ptr_mut();
+
+        using namespace proxsuite::linalg::veg::literals;
+        auto kkt_sym = proxsuite::linalg::sparse::SymbolicMatRef<I>{
+          proxsuite::linalg::sparse::from_raw_parts,
+          n_tot,
+          n_tot,
+          nnz_tot,
+          data.kkt_col_ptrs.ptr(),
+          nullptr,
+          data.kkt_row_indices.ptr(),
+        };
+        proxsuite::linalg::sparse::factorize_symbolic_non_zeros( //
+          ldl.col_ptrs.ptr_mut() + 1,
+          etree_ptr,
+          ldl.perm_inv.ptr_mut(),
+          static_cast<I const*>(nullptr),
+          kkt_sym,
+          stack);
+
+        auto pcol_ptrs = ldl.col_ptrs.ptr_mut();
+        pcol_ptrs[0] = I(0); // pcol_ptrs +1: pointor towards the nbr of non
+                             // zero elts per column of the ldlt
+        // we need to compute its cumulative sum below to determine if there
+        // could be an overflow
+
+        using proxsuite::linalg::veg::u64;
+        u64 acc = 0;
+
+        for (usize i = 0; i < usize(n_tot); ++i) {
+          acc += u64(zero_extend(pcol_ptrs[i + 1]));
+          if (acc != u64(I(acc))) {
+            overflow = true;
+          }
+          pcol_ptrs[(i + 1)] = I(acc);
+        }
+      }
+
+      auto lnnz = isize(zero_extend(ldl.col_ptrs[n_tot]));
+
+      // if ldlt is too sparse
+      // do_ldlt = !overflow && lnnz < (10000000);
+      if (settings.sparse_backend == SparseBackend::Automatic) {
+        do_ldlt = !overflow && lnnz < 10000000;
+      } else if (settings.sparse_backend == SparseBackend::SparseCholesky) {
+        do_ldlt = true;
+      } else {
+        do_ldlt = false;
+      }
+
+    } else {
+      T* kktx = data.kkt_values.ptr_mut();
+      usize pos = 0;
+      auto insert_submatrix =
+        [&](proxsuite::linalg::sparse::MatRef<T, I> m) -> void {
+        T const* mx = m.values();
+        isize ncols = m.ncols();
+
+        for (usize j = 0; j < usize(ncols); ++j) {
+          usize col_start = m.col_start(j);
+          usize col_end = m.col_end(j);
+          for (usize p = col_start; p < col_end; ++p) {
+
+            kktx[pos] = mx[p];
+
+            ++pos;
+          }
+        }
+      };
+
+      insert_submatrix(qp.H);
+      insert_submatrix(qp.AT);
+      insert_submatrix(qp.CT);
+      data.kkt_values_unscaled = data.kkt_values;
+    }
+#define PROX_QP_ALL_OF(...)                                                    \
+  ::proxsuite::linalg::veg::dynstack::StackReq::and_(                          \
+    ::proxsuite::linalg::veg::init_list(__VA_ARGS__))
+#define PROX_QP_ANY_OF(...)                                                    \
+  ::proxsuite::linalg::veg::dynstack::StackReq::or_(                           \
+    ::proxsuite::linalg::veg::init_list(__VA_ARGS__))
+    //  ? --> if
+    auto refactorize_req =
+      do_ldlt
+        ? PROX_QP_ANY_OF({
+            proxsuite::linalg::sparse::factorize_symbolic_req( // symbolic ldl
+              itag,
+              n_tot,
+              nnz_tot,
+              proxsuite::linalg::sparse::Ordering::user_provided),
+            PROX_QP_ALL_OF({
+              SR::with_len(xtag, n_tot),                        // diag
+              proxsuite::linalg::sparse::factorize_numeric_req( // numeric ldl
+                xtag,
+                itag,
+                n_tot,
+                nnz_tot,
+                proxsuite::linalg::sparse::Ordering::user_provided),
+            }),
+          })
+        : PROX_QP_ALL_OF({
+            SR::with_len(itag, 0), // compute necessary space for storing n elts
+                                   // of type I (n = 0 here)
+            SR::with_len(xtag, 0), // compute necessary space for storing n elts
+                                   // of type T (n = 0 here)
+          });
+
+    auto x_vec = [&](isize n) noexcept -> StackReq {
+      return proxsuite::linalg::dense::temp_vec_req(xtag, n);
+    };
+
+    auto ldl_solve_in_place_req = PROX_QP_ALL_OF({
+      x_vec(n_tot), // tmp
+      x_vec(n_tot), // err
+      x_vec(n_tot), // work
+    });
+
+    auto unscaled_primal_dual_residual_req = x_vec(n); // Hx
+    auto line_search_req = PROX_QP_ALL_OF({
+      x_vec(2 * n_in), // alphas
+      x_vec(n),        // Cdx_active
+      x_vec(n_in),     // active_part_z
+      x_vec(n_in),     // tmp_lo
+      x_vec(n_in),     // tmp_up
+    });
+    // define memory needed for primal_dual_newton_semi_smooth
+    // PROX_QP_ALL_OF --> need to store all argument inside
+    // PROX_QP_ANY_OF --> au moins un de  ceux en entrée
+    auto primal_dual_newton_semi_smooth_req = PROX_QP_ALL_OF({
+      x_vec(n_tot), // dw
+      PROX_QP_ANY_OF({
+        ldl_solve_in_place_req,
+        PROX_QP_ALL_OF({
+          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
+                       n_in), // active_set_lo
+          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
+                       n_in), // active_set_up
+          SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
+                       n_in), // new_active_constraints
+          (do_ldlt && n_in > 0) ? PROX_QP_ANY_OF({
+                                    proxsuite::linalg::sparse::add_row_req(
+                                      xtag, itag, n_tot, false, n, n_tot),
+                                    proxsuite::linalg::sparse::delete_row_req(
+                                      xtag, itag, n_tot, n_tot),
+                                  })
+                                : refactorize_req,
+        }),
+        PROX_QP_ALL_OF({
+          x_vec(n),    // Hdx
+          x_vec(n_eq), // Adx
+          x_vec(n_in), // Cdx
+          x_vec(n),    // ATdy
+          x_vec(n),    // CTdz
+        }),
+      }),
+      line_search_req,
+    });
+
+    auto iter_req = PROX_QP_ANY_OF({
+      PROX_QP_ALL_OF({ x_vec(n_eq), // primal_residual_eq_scaled
+                       x_vec(n_in), // primal_residual_in_scaled_lo
+                       x_vec(n_in), // primal_residual_in_scaled_up
+                       x_vec(n_in), // primal_residual_in_scaled_up
+                       x_vec(n),    // dual_residual_scaled
+                       PROX_QP_ANY_OF({
+                         unscaled_primal_dual_residual_req,
+                         PROX_QP_ALL_OF({
+                           x_vec(n),    // x_prev
+                           x_vec(n_eq), // y_prev
+                           x_vec(n_in), // z_prev
+                           primal_dual_newton_semi_smooth_req,
+                         }),
+                       }) }),
+      refactorize_req, // mu_update
+    });
+
+    auto req = //
+      PROX_QP_ALL_OF({
+        x_vec(n),    // g_scaled
+        x_vec(n_eq), // b_scaled
+        x_vec(n_in), // l_scaled
+        x_vec(n_in), // u_scaled
+        SR::with_len(proxsuite::linalg::veg::Tag<bool>{},
+                     n_in),        // active constr
+        SR::with_len(itag, n_tot), // kkt nnz counts
+        refactorize_req,
+        PROX_QP_ANY_OF({
+          precond_req,
+          PROX_QP_ALL_OF({
+            do_ldlt ? PROX_QP_ALL_OF({
+                        SR::with_len(itag, n_tot), // perm
+                        SR::with_len(itag, n_tot), // etree
+                        SR::with_len(itag, n_tot), // ldl nnz counts
+                        SR::with_len(itag, lnnz),  // ldl row indices
+                        SR::with_len(xtag, lnnz),  // ldl values
+                      })
+                    : PROX_QP_ALL_OF({
+                        SR::with_len(itag, 0),
+                        SR::with_len(xtag, 0),
+                      }),
+            iter_req,
+          }),
+        }),
+      });
+
+    storage.resize_for_overwrite(
+      req.alloc_req()); // defines the maximal storage size
+    // storage.resize(n): if it is done twice in a row, the second times it does
+    // nothing, as the same resize has been asked
+
+    // preconditioner
+    auto kkt = data.kkt_mut();
+    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
+      proxsuite::linalg::veg::unsafe,
+      kkt,
+      n); //  top_rows_mut_unchecked: take a view of sparse matrix for n first
+          //  lines ; the function assumes all others lines are zeros;
+    /*
+            H AT CT
+            A
+            C
+
+            here we store the upper triangular part below
+
+            tirSup(H) AT CT
+            0 0 0
+            0 0 0
+
+            proxsuite::linalg::veg::unsafe:  precises that the function has
+       undefined behavior if upper condition is not respected.
+    */
+
+    proxsuite::linalg::sparse::MatMut<T, I> H_scaled =
+      detail::middle_cols_mut(kkt_top_n_rows, 0, n, data.H_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> AT_scaled =
+      detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, data.A_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> CT_scaled =
+      detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, data.C_nnz);
+
+    g_scaled = data.g;
+    b_scaled = data.b;
+    u_scaled =
+      (data.u.array() <= T(1.E20))
+        .select(data.u,
+                Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(data.n_in).array() +
+                  T(1.E20));
+    l_scaled =
+      (data.l.array() >= T(-1.E20))
+        .select(data.l,
+                Eigen::Matrix<T, Eigen::Dynamic, 1>::Zero(data.n_in).array() -
+                  T(1.E20));
+
+    QpViewMut<T, I> qp_scaled = {
+      H_scaled,
+      { proxsuite::linalg::sparse::from_eigen, g_scaled },
+      AT_scaled,
+      { proxsuite::linalg::sparse::from_eigen, b_scaled },
+      CT_scaled,
+      { proxsuite::linalg::sparse::from_eigen, l_scaled },
+      { proxsuite::linalg::sparse::from_eigen, u_scaled },
+    };
+
+    DynStackMut stack = stack_mut();
+    precond.scale_qp_in_place(qp_scaled,
+                              execute_or_not,
+                              settings.preconditioner_max_iter,
+                              settings.preconditioner_accuracy,
+                              stack);
+    kkt_nnz_counts.resize_for_overwrite(n_tot);
+
+    proxsuite::linalg::sparse::MatMut<T, I> kkt_active = {
+      proxsuite::linalg::sparse::from_raw_parts,
+      n_tot,
+      n_tot,
+      data.H_nnz +
+        data.A_nnz, // these variables are not used for the matrix vector
+                    // product in augmented KKT with Min res algorithm (to be
+                    // exact, it should depend of the initial guess)
+      kkt.col_ptrs_mut(),
+      kkt_nnz_counts.ptr_mut(),
+      kkt.row_indices_mut(),
+      kkt.values_mut(),
+    };
+
+    using MatrixFreeSolver = Eigen::MINRES<detail::AugmentedKkt<T, I>,
+                                           Eigen::Upper | Eigen::Lower,
+                                           Eigen::IdentityPreconditioner>;
+    matrix_free_solver = std::unique_ptr<MatrixFreeSolver>{
+      new MatrixFreeSolver,
+    };
+    matrix_free_kkt = std::unique_ptr<detail::AugmentedKkt<T, I>>{
+      new detail::AugmentedKkt<T, I>{
+        {
+          kkt_active.as_const(),
+          {},
+          n,
+          n_eq,
+          n_in,
+          {},
+          {},
+          {},
+        },
+      }
+    };
+
+    auto zx = proxsuite::linalg::sparse::util::zero_extend; // ?
+    auto max_lnnz = isize(zx(ldl.col_ptrs[n_tot]));
+    isize ldlt_ntot = do_ldlt ? n_tot : 0;
+    isize ldlt_lnnz = do_ldlt ? max_lnnz : 0;
+
+    ldl.nnz_counts.resize_for_overwrite(ldlt_ntot);
+    ldl.row_indices.resize_for_overwrite(ldlt_lnnz);
+    ldl.values.resize_for_overwrite(ldlt_lnnz);
+
+    ldl.perm.resize_for_overwrite(ldlt_ntot);
+    if (do_ldlt) {
+      // compute perm from perm_inv
+      for (isize i = 0; i < n_tot; ++i) {
+        ldl.perm[isize(zx(ldl.perm_inv[i]))] = I(i);
+      }
+    }
+
+    internal.dirty = false;
+  }
+  Timer<T> timer;
+  Workspace() = default;
+
+  auto ldl_col_ptrs() const -> I const* { return internal.ldl.col_ptrs.ptr(); }
+  auto ldl_col_ptrs_mut() -> I* { return internal.ldl.col_ptrs.ptr_mut(); }
+  auto stack_mut() -> proxsuite::linalg::veg::dynstack::DynStackMut
+  {
+    return internal.stack_mut();
+  }
+
+  void set_dirty() { internal.dirty = true; }
+};
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_WORKSPACE_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/wrapper.hpp

 * *Ordering differences only*

```diff
@@ -1,772 +1,772 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file wrapper.hpp
- */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP
-#define PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP
-#include <proxsuite/proxqp/results.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-#include <proxsuite/proxqp/sparse/solver.hpp>
-#include <proxsuite/proxqp/sparse/helpers.hpp>
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-///
-/// @brief This class defines the API of PROXQP solver with sparse backend.
-///
-/*!
- * Wrapper class for using proxsuite API with dense backend
- * for solving linearly constrained convex QP problem using ProxQp algorithm.
- *
- * Example usage:
- * ```cpp
-#include <Eigen/Core>
-#include <Eigen/Cholesky>
-#include <proxsuite/proxqp/dense/dense.hpp>
-#include <proxsuite/linalg/veg/util/dbg.hpp>
-#include <util.hpp>
-
-using T = double;
-using I = c_int;
-auto main() -> int {
-
-        // Generate a random QP problem with primal variable dimension of size
-dim; n_eq equality constraints and n_in inequality constraints
-        ::proxsuite::proxqp::test::rand::set_seed(1);
-        proxqp::isize dim = 10;
-        proxqp::isize n_eq(dim / 4);
-        proxqp::isize n_in(dim / 4);
-        T strong_convexity_factor(1.e-2);
-        T sparsity_factor = 0.15; // controls the sparsity of each matrix of the
-problem generated T eps_abs = T(1e-9); double p = 1.0; T conditioning(10.0);
-        auto H =
-::proxsuite::proxqp::test::rand::sparse_positive_definite_rand(n, conditioning,
-p); auto g = ::proxsuite::proxqp::test::rand::vector_rand<T>(n); auto A =
-::proxsuite::proxqp::test::rand::sparse_matrix_rand<T>(n_eq,n, p); auto b =
-::proxsuite::proxqp::test::rand::vector_rand<T>(n_eq); auto C =
-::proxsuite::proxqp::test::rand::sparse_matrix_rand<T>(n_in,n, p); auto l =
-::proxsuite::proxqp::test::rand::vector_rand<T>(n_in); auto u = (l.array() +
-1).matrix().eval();
-
-        proxqp::sparse::QP<T,I> Qp(n, n_eq, n_in);
-        Qp.settings.eps_abs = 1.E-9;
-        Qp.settings.verbose = true;
-        Qp.setup_sparse_matrices(H,g,A,b,C,u,l);
-        Qp.solve();
-
-        // Solve the problem
-        proxqp::sparse::QP<T,I> Qp(n, n_eq, n_in);
-        Qp.settings.eps_abs = 1.E-9;
-        Qp.settings.verbose = true;
-        Qp.setup_sparse_matrices(H,g,A,b,C,u,l);
-        Qp.solve();
-
-        // Verify solution accuracy
-        T pri_res = std::max(
-                        (qp.A * Qp.results.x - qp.b).lpNorm<Eigen::Infinity>(),
-                        (helpers::positive_part(qp.C * Qp.results.x -
-qp.u) + helpers::negative_part(qp.C * Qp.results.x - qp.l))
-                                        .lpNorm<Eigen::Infinity>());
-        T dua_res = (qp.H * Qp.results.x + qp.g + qp.A.transpose() *
-Qp.results.y + qp.C.transpose() * Qp.results.z) .lpNorm<Eigen::Infinity>();
-        VEG_ASSERT(pri_res <= eps_abs);
-        VEG_ASSERT(dua_res <= eps_abs);
-
-        // Some solver statistics
-        std::cout << "------solving qp with dim: " << dim
-                                                << " neq: " << n_eq << " nin: "
-<< n_in << std::endl; std::cout << "primal residual: " << pri_res << std::endl;
-        std::cout << "dual residual: " << dua_res << std::endl;
-        std::cout << "total number of iteration: " << Qp.results.info.iter
-                                                << std::endl;
-}
- * ```
- */
-template<typename T, typename I>
-struct QP
-{
-  Results<T> results;
-  Settings<T> settings;
-  Model<T, I> model;
-  Workspace<T, I> work;
-  preconditioner::RuizEquilibration<T, I> ruiz;
-  /*!
-   * Default constructor using the dimension of the matrices in entry.
-   * @param dim primal variable dimension.
-   * @param n_eq number of equality constraints.
-   * @param n_in number of inequality constraints.
-   */
-  QP(isize dim, isize n_eq, isize n_in)
-    : results(dim, n_eq, n_in)
-    , settings()
-    , model(dim, n_eq, n_in)
-    , work()
-    , ruiz(dim, n_eq + n_in, 1e-3, 10, preconditioner::Symmetry::UPPER)
-  {
-    work.timer.stop();
-    work.internal.do_symbolic_fact = true;
-    work.internal.is_initialized = false;
-  }
-  /*!
-   * Default constructor using the sparsity structure of the matrices in entry.
-   * @param H boolean mask of the quadratic cost input defining the QP model.
-   * @param A boolean mask of the equality constraint matrix input defining the
-   * QP model.
-   * @param C boolean mask of the inequality constraint matrix input defining
-   * the QP model.
-   */
-  QP(const SparseMat<bool, I>& H,
-     const SparseMat<bool, I>& A,
-     const SparseMat<bool, I>& C)
-    : QP(H.rows(), A.rows(), C.rows())
-  {
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    SparseMat<bool, I> H_triu = H.template triangularView<Eigen::Upper>();
-    SparseMat<bool, I> AT = A.transpose();
-    SparseMat<bool, I> CT = C.transpose();
-    proxsuite::linalg::sparse::MatRef<bool, I> Href = {
-      proxsuite::linalg::sparse::from_eigen, H_triu
-    };
-    proxsuite::linalg::sparse::MatRef<bool, I> ATref = {
-      proxsuite::linalg::sparse::from_eigen, AT
-    };
-    proxsuite::linalg::sparse::MatRef<bool, I> CTref = {
-      proxsuite::linalg::sparse::from_eigen, CT
-    };
-    work.setup_symbolic_factorizaton(
-      model, Href.symbolic(), ATref.symbolic(), CTref.symbolic());
-    if (settings.compute_timings) {
-      results.info.setup_time = work.timer.elapsed().user; // in microseconds
-    }
-  }
-
-  /*!
-   * Setups the QP model (with sparse matrix format) and equilibrates it.
-   * @param H quadratic cost input defining the QP model.
-   * @param g linear cost input defining the QP model.
-   * @param A equality constraint matrix input defining the QP model.
-   * @param b equality constraint vector input defining the QP model.
-   * @param C inequality constraint matrix input defining the QP model.
-   * @param l lower inequality constraint vector input defining the QP model.
-   * @param u upper inequality constraint vector input defining the QP model.
-   * @param compute_preconditioner boolean parameter for executing or not the
-   * preconditioner.
-   * @param rho proximal step size wrt primal variable.
-   * @param mu_eq proximal step size wrt equality constrained multiplier.
-   * @param mu_in proximal step size wrt inequality constrained multiplier.
-   */
-  void init(optional<SparseMat<T, I>> H,
-            optional<VecRef<T>> g,
-            optional<SparseMat<T, I>> A,
-            optional<VecRef<T>> b,
-            optional<SparseMat<T, I>> C,
-            optional<VecRef<T>> l,
-            optional<VecRef<T>> u,
-            bool compute_preconditioner_ = true,
-            optional<T> rho = nullopt,
-            optional<T> mu_eq = nullopt,
-            optional<T> mu_in = nullopt)
-  {
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    if (g != nullopt && g.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        g.value().size(),
-        model.dim,
-        "the dimension wrt the primal variable x variable for initializing g "
-        "is not valid.");
-    } else {
-      g.reset();
-    }
-    if (b != nullopt && b.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        b.value().size(),
-        model.n_eq,
-        "the dimension wrt equality constrained variables for initializing b "
-        "is not valid.");
-    } else {
-      b.reset();
-    }
-    if (u != nullopt && u.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        u.value().size(),
-        model.n_in,
-        "the dimension wrt inequality constrained variables for initializing u "
-        "is not valid.");
-    } else {
-      u.reset();
-    }
-    if (l != nullopt && l.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        l.value().size(),
-        model.n_in,
-        "the dimension wrt inequality constrained variables for initializing l "
-        "is not valid.");
-    } else {
-      l.reset();
-    }
-    if (H != nullopt && H.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().rows(),
-        model.dim,
-        "the row dimension for initializing H is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().cols(),
-        model.dim,
-        "the column dimension for initializing H is not valid.");
-    } else {
-      H.reset();
-    }
-    if (A != nullopt && A.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().rows(),
-        model.n_eq,
-        "the row dimension for initializing A is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().cols(),
-        model.dim,
-        "the column dimension for initializing A is not valid.");
-    } else {
-      A.reset();
-    }
-    if (C != nullopt && C.value().size() != 0) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().rows(),
-        model.n_in,
-        "the row dimension for initializing C is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().cols(),
-        model.dim,
-        "the column dimension for initializing C is not valid.");
-    } else {
-      C.reset();
-    }
-    work.internal.proximal_parameter_update = false;
-    PreconditionerStatus preconditioner_status;
-    if (compute_preconditioner_) {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
-    } else {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::IDENTITY;
-    }
-    proxsuite::proxqp::sparse::update_proximal_parameters(
-      settings, results, work, rho, mu_eq, mu_in);
-
-    if (g != nullopt) {
-      model.g = g.value();
-    } // else qpmodel.g remains initialzed to a matrix with zero elements or
-      // zero shape
-    if (b != nullopt) {
-      model.b = b.value();
-    } // else qpmodel.b remains initialzed to a matrix with zero elements or
-      // zero shape
-    if (u != nullopt) {
-      model.u = u.value();
-    } // else qpmodel.u remains initialzed to a matrix with zero elements or
-      // zero shape
-    if (l != nullopt) {
-      model.l = l.value();
-    } // else qpmodel.l remains initialzed to a matrix with zero elements or
-      // zero shape
-
-    // avoid allocations when H is not nullopt
-    SparseMat<T, I> AT(model.dim, model.n_eq);
-    if (A != nullopt) {
-      AT = (A.value()).transpose();
-    } else {
-      AT.setZero();
-    }
-    SparseMat<T, I> CT(model.dim, model.n_in);
-    if (C != nullopt) {
-      CT = (C.value()).transpose();
-    } else {
-      CT.setZero();
-    }
-    if (H != nullopt) {
-      SparseMat<T, I> H_triu =
-        (H.value()).template triangularView<Eigen::Upper>();
-      sparse::QpView<T, I> qp = {
-        { proxsuite::linalg::sparse::from_eigen, H_triu },
-        { proxsuite::linalg::sparse::from_eigen, model.g },
-        { proxsuite::linalg::sparse::from_eigen, AT },
-        { proxsuite::linalg::sparse::from_eigen, model.b },
-        { proxsuite::linalg::sparse::from_eigen, CT },
-        { proxsuite::linalg::sparse::from_eigen, model.l },
-        { proxsuite::linalg::sparse::from_eigen, model.u }
-      };
-      qp_setup(qp, results, model, work, settings, ruiz, preconditioner_status);
-    } else {
-      SparseMat<T, I> H_triu(model.dim, model.dim);
-      H_triu.setZero();
-      H_triu = (H.value()).template triangularView<Eigen::Upper>();
-      sparse::QpView<T, I> qp = {
-        { proxsuite::linalg::sparse::from_eigen, H_triu },
-        { proxsuite::linalg::sparse::from_eigen, model.g },
-        { proxsuite::linalg::sparse::from_eigen, AT },
-        { proxsuite::linalg::sparse::from_eigen, model.b },
-        { proxsuite::linalg::sparse::from_eigen, CT },
-        { proxsuite::linalg::sparse::from_eigen, model.l },
-        { proxsuite::linalg::sparse::from_eigen, model.u }
-      };
-      qp_setup(qp, results, model, work, settings, ruiz, preconditioner_status);
-    }
-    work.internal.is_initialized = true;
-
-    if (settings.compute_timings) {
-      results.info.setup_time += work.timer.elapsed().user; // in microseconds
-    }
-  };
-  /*!
-   * Updates the QP model (with sparse matrix format) and re-equilibrates it if
-   * specified by the user. If matrices in entry are not null, the update is
-   * effective only if the sparsity structure of entry is the same as the one
-   * used for the initialization.
-   * @param H quadratic cost input defining the QP model.
-   * @param g linear cost input defining the QP model.
-   * @param A equality constraint matrix input defining the QP model.
-   * @param b equality constraint vector input defining the QP model.
-   * @param C inequality constraint matrix input defining the QP model.
-   * @param l lower inequality constraint vector input defining the QP model.
-   * @param u lower inequality constraint vector input defining the QP model.
-   * @param update_preconditioner bool parameter for updating or not the
-   * preconditioner and the associated scaled model.
-   * @param rho proximal step size wrt primal variable.
-   * @param mu_eq proximal step size wrt equality constrained multiplier.
-   * @param mu_in proximal step size wrt inequality constrained multiplier.
-   * @note The init method should be called before update. If it has not been
-   * done before, init is called depending on the is_initialized flag.
-   */
-  void update(const optional<SparseMat<T, I>> H,
-              optional<VecRef<T>> g,
-              const optional<SparseMat<T, I>> A,
-              optional<VecRef<T>> b,
-              const optional<SparseMat<T, I>> C,
-              optional<VecRef<T>> l,
-              optional<VecRef<T>> u,
-              bool update_preconditioner = true,
-              optional<T> rho = nullopt,
-              optional<T> mu_eq = nullopt,
-              optional<T> mu_in = nullopt)
-  {
-    if (!work.internal.is_initialized) {
-      init(H, g, A, b, C, l, u, update_preconditioner, rho, mu_eq, mu_in);
-      return;
-    }
-    if (settings.compute_timings) {
-      work.timer.stop();
-      work.timer.start();
-    }
-    work.internal.dirty = false;
-    work.internal.proximal_parameter_update = false;
-    PreconditionerStatus preconditioner_status;
-    if (update_preconditioner) {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
-    } else {
-      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::KEEP;
-    }
-    isize n = model.dim;
-    isize n_eq = model.n_eq;
-    isize n_in = model.n_in;
-    proxsuite::linalg::sparse::MatMut<T, I> kkt_unscaled =
-      model.kkt_mut_unscaled();
-
-    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
-      proxsuite::linalg::veg::unsafe, kkt_unscaled, n);
-
-    proxsuite::linalg::sparse::MatMut<T, I> H_unscaled =
-      detail::middle_cols_mut(kkt_top_n_rows, 0, n, model.H_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> AT_unscaled =
-      detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, model.A_nnz);
-
-    proxsuite::linalg::sparse::MatMut<T, I> CT_unscaled =
-      detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, model.C_nnz);
-
-    // check the model is valid
-    if (g != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(g.value().size(),
-                                    model.dim,
-                                    "the dimension wrt the primal variable x "
-                                    "variable for updating g is not valid.");
-    }
-    if (b != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(b.value().size(),
-                                    model.n_eq,
-                                    "the dimension wrt equality constrained "
-                                    "variables for updating b is not valid.");
-    }
-    if (u != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(u.value().size(),
-                                    model.n_in,
-                                    "the dimension wrt inequality constrained "
-                                    "variables for updating u is not valid.");
-    }
-    if (l != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(l.value().size(),
-                                    model.n_in,
-                                    "the dimension wrt inequality constrained "
-                                    "variables for updating l is not valid.");
-    }
-    if (H != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().rows(),
-        model.dim,
-        "the row dimension for updating H is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        H.value().cols(),
-        model.dim,
-        "the column dimension for updating H is not valid.");
-    }
-    if (A != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().rows(),
-        model.n_eq,
-        "the row dimension for updating A is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        A.value().cols(),
-        model.dim,
-        "the column dimension for updating A is not valid.");
-    }
-    if (C != nullopt) {
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().rows(),
-        model.n_in,
-        "the row dimension for updating C is not valid.");
-      PROXSUITE_CHECK_ARGUMENT_SIZE(
-        C.value().cols(),
-        model.dim,
-        "the column dimension for updating C is not valid.");
-    }
-
-    // update the model
-
-    if (g != nullopt) {
-      model.g = g.value();
-    }
-    if (b != nullopt) {
-      model.b = b.value();
-    }
-    if (u != nullopt) {
-      model.u = u.value();
-    }
-    if (l != nullopt) {
-      model.l = l.value();
-    }
-    if (H != nullopt) {
-      SparseMat<T, I> H_triu =
-        H.value().template triangularView<Eigen::Upper>();
-      if (A != nullopt) {
-        if (C != nullopt) {
-          bool res =
-            have_same_structure(
-              H_unscaled.as_const(),
-              { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
-            have_same_structure(AT_unscaled.as_const(),
-                                { proxsuite::linalg::sparse::from_eigen,
-                                  SparseMat<T, I>(A.value().transpose()) }) &&
-            have_same_structure(CT_unscaled.as_const(),
-                                { proxsuite::linalg::sparse::from_eigen,
-                                  SparseMat<T, I>(C.value().transpose()) });
-          /* TO PUT IN DEBUG MODE
-          std::cout << "have same structure = " << res << std::endl;
-          */
-          if (res) {
-            copy(H_unscaled,
-                 { proxsuite::linalg::sparse::from_eigen,
-                   H_triu }); // copy rhs into lhs
-            copy(
-              AT_unscaled,
-              { proxsuite::linalg::sparse::from_eigen,
-                SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
-            copy(
-              CT_unscaled,
-              { proxsuite::linalg::sparse::from_eigen,
-                SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
-          }
-        } else {
-          bool res =
-            have_same_structure(
-              H_unscaled.as_const(),
-              { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
-            have_same_structure(AT_unscaled.as_const(),
-                                { proxsuite::linalg::sparse::from_eigen,
-                                  SparseMat<T, I>(A.value().transpose()) });
-          /* TO PUT IN DEBUG MODE
-          std::cout << "have same structure = " << res << std::endl;
-          */
-          if (res) {
-            copy(H_unscaled,
-                 { proxsuite::linalg::sparse::from_eigen,
-                   H_triu }); // copy rhs into lhs
-            copy(
-              AT_unscaled,
-              { proxsuite::linalg::sparse::from_eigen,
-                SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
-          }
-        }
-      } else if (C != nullopt) {
-        bool res =
-          have_same_structure(
-            H_unscaled.as_const(),
-            { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
-          have_same_structure(CT_unscaled.as_const(),
-                              { proxsuite::linalg::sparse::from_eigen,
-                                SparseMat<T, I>(C.value().transpose()) });
-        /* TO PUT IN DEBUG MODE
-        std::cout << "have same structure = " << res << std::endl;
-        */
-        if (res) {
-          copy(H_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 H_triu }); // copy rhs into lhs
-          copy(CT_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
-        }
-      } else {
-
-        bool res = have_same_structure(
-          H_unscaled.as_const(),
-          { proxsuite::linalg::sparse::from_eigen, H_triu });
-        /* TO PUT IN DEBUG MODE
-        std::cout << "have same structure = " << res << std::endl;
-        */
-        if (res) {
-          copy(H_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 H.value() }); // copy rhs into lhs
-        }
-      }
-    } else if (A != nullopt) {
-      if (C != nullopt) {
-        bool res =
-          have_same_structure(AT_unscaled.as_const(),
-                              { proxsuite::linalg::sparse::from_eigen,
-                                SparseMat<T, I>(A.value().transpose()) }) &&
-          have_same_structure(CT_unscaled.as_const(),
-                              { proxsuite::linalg::sparse::from_eigen,
-                                SparseMat<T, I>(C.value().transpose()) });
-        /* TO PUT IN DEBUG MODE
-        std::cout << "have same structure = " << res << std::endl;
-        */
-        if (res) {
-          copy(AT_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
-          copy(CT_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
-        }
-      } else {
-        bool res =
-          have_same_structure(AT_unscaled.as_const(),
-                              { proxsuite::linalg::sparse::from_eigen,
-                                SparseMat<T, I>(A.value().transpose()) });
-        /* TO PUT IN DEBUG MODE
-        std::cout << "have same structure = " << res << std::endl;
-        */
-        if (res) {
-          copy(AT_unscaled,
-               { proxsuite::linalg::sparse::from_eigen,
-                 SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
-        }
-      }
-    } else if (C != nullopt) {
-      bool res =
-        have_same_structure(CT_unscaled.as_const(),
-                            { proxsuite::linalg::sparse::from_eigen,
-                              SparseMat<T, I>(C.value().transpose()) });
-      /* TO PUT IN DEBUG MODE
-      std::cout << "have same structure = " << res << std::endl;
-      */
-      if (res) {
-        copy(CT_unscaled,
-             { proxsuite::linalg::sparse::from_eigen,
-               SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
-      }
-    }
-
-    SparseMat<T, I> H_triu =
-      H_unscaled.to_eigen().template triangularView<Eigen::Upper>();
-    sparse::QpView<T, I> qp = {
-      { proxsuite::linalg::sparse::from_eigen, H_triu },
-      { proxsuite::linalg::sparse::from_eigen, model.g },
-      { proxsuite::linalg::sparse::from_eigen, AT_unscaled.to_eigen() },
-      { proxsuite::linalg::sparse::from_eigen, model.b },
-      { proxsuite::linalg::sparse::from_eigen, CT_unscaled.to_eigen() },
-      { proxsuite::linalg::sparse::from_eigen, model.l },
-      { proxsuite::linalg::sparse::from_eigen, model.u }
-    };
-    proxsuite::proxqp::sparse::update_proximal_parameters(
-      settings, results, work, rho, mu_eq, mu_in);
-    qp_setup(qp,
-             results,
-             model,
-             work,
-             settings,
-             ruiz,
-             preconditioner_status); // store model value + performs scaling
-                                     // according to chosen options
-    if (settings.compute_timings) {
-      results.info.setup_time = work.timer.elapsed().user; // in microseconds
-    }
-  };
-
-  /*!
-   * Solves the QP problem using PRXOQP algorithm.
-   */
-  void solve()
-  {
-    qp_solve( //
-      results,
-      model,
-      settings,
-      work,
-      ruiz);
-  };
-  /*!
-   * Solves the QP problem using PROXQP algorithm and a warm start.
-   * @param x primal warm start.
-   * @param y dual equality warm start.
-   * @param z dual inequality warm start.
-   */
-  void solve(optional<VecRef<T>> x,
-             optional<VecRef<T>> y,
-             optional<VecRef<T>> z)
-  {
-    proxsuite::proxqp::sparse::warm_start(x, y, z, results, settings, model);
-    qp_solve( //
-      results,
-      model,
-      settings,
-      work,
-      ruiz);
-  };
-  /*!
-   * Clean-ups solver's results.
-   */
-  void cleanup() { results.cleanup(settings); }
-};
-/*!
- * Solves the QP problem using PROXQP algorithm without the need to define a QP
- * object, with matrices defined by Dense Eigen matrices. It is possible to set
- * up some of the solver parameters (warm start, initial guess option, proximal
- * step sizes, absolute and relative accuracies, maximum number of iterations,
- * preconditioner execution).
- * @param H quadratic cost input defining the QP model.
- * @param g linear cost input defining the QP model.
- * @param A equality constraint matrix input defining the QP model.
- * @param b equality constraint vector input defining the QP model.
- * @param C inequality constraint matrix input defining the QP model.
- * @param l lower inequality constraint vector input defining the QP model.
- * @param u upper inequality constraint vector input defining the QP model.
- * @param x primal warm start.
- * @param y dual equality constraint warm start.
- * @param z dual inequality constraint warm start.
- * @param verbose if set to true, the solver prints more information about each
- * iteration.
- * @param compute_preconditioner boolean parameter for executing or not the
- * preconditioner.
- * @param compute_timings boolean parameter for computing the solver timings.
- * @param rho proximal step size wrt primal variable.
- * @param mu_eq proximal step size wrt equality constrained multiplier.
- * @param mu_in proximal step size wrt inequality constrained multiplier.
- * @param eps_abs absolute accuracy threshold.
- * @param eps_rel relative accuracy threshold.
- * @param max_iter maximum number of iteration.
- * @param initial_guess initial guess option for warm starting or not the
- * initial iterate values.
- * @param check_duality_gap If set to true, include the duality gap in absolute
- * and relative stopping criteria.
- * @param eps_duality_gap_abs absolute accuracy threshold for the duality-gap
- * criterion.
- * @param eps_duality_gap_rel relative accuracy threshold for the duality-gap
- * criterion.
- */
-template<typename T, typename I>
-proxqp::Results<T>
-solve(
-  optional<SparseMat<T, I>> H,
-  optional<VecRef<T>> g,
-  optional<SparseMat<T, I>> A,
-  optional<VecRef<T>> b,
-  optional<SparseMat<T, I>> C,
-  optional<VecRef<T>> l,
-  optional<VecRef<T>> u,
-  optional<VecRef<T>> x = nullopt,
-  optional<VecRef<T>> y = nullopt,
-  optional<VecRef<T>> z = nullopt,
-  optional<T> eps_abs = nullopt,
-  optional<T> eps_rel = nullopt,
-  optional<T> rho = nullopt,
-  optional<T> mu_eq = nullopt,
-  optional<T> mu_in = nullopt,
-  optional<bool> verbose = nullopt,
-  bool compute_preconditioner = true,
-  bool compute_timings = false,
-  optional<isize> max_iter = nullopt,
-  proxsuite::proxqp::InitialGuessStatus initial_guess =
-    proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS,
-  proxsuite::proxqp::SparseBackend sparse_backend =
-    proxsuite::proxqp::SparseBackend::Automatic,
-  bool check_duality_gap = false,
-  optional<T> eps_duality_gap_abs = nullopt,
-  optional<T> eps_duality_gap_rel = nullopt)
-{
-
-  isize n(0);
-  isize n_eq(0);
-  isize n_in(0);
-  if (H != nullopt) {
-    n = H.value().rows();
-  }
-  if (A != nullopt) {
-    n_eq = A.value().rows();
-  }
-  if (C != nullopt) {
-    n_in = C.value().rows();
-  }
-
-  proxqp::sparse::QP<T, I> Qp(n, n_eq, n_in);
-  Qp.settings.initial_guess = initial_guess;
-  Qp.settings.check_duality_gap = check_duality_gap;
-
-  if (eps_abs != nullopt) {
-    Qp.settings.eps_abs = eps_abs.value();
-  }
-  if (eps_rel != nullopt) {
-    Qp.settings.eps_rel = eps_rel.value();
-  }
-  if (verbose != nullopt) {
-    Qp.settings.verbose = verbose.value();
-  }
-  if (max_iter != nullopt) {
-    Qp.settings.max_iter = max_iter.value();
-  }
-  if (eps_duality_gap_abs != nullopt) {
-    Qp.settings.eps_duality_gap_abs = eps_duality_gap_abs.value();
-  }
-  if (eps_duality_gap_rel != nullopt) {
-    Qp.settings.eps_duality_gap_rel = eps_duality_gap_rel.value();
-  }
-  Qp.settings.compute_timings = compute_timings;
-  Qp.settings.sparse_backend = sparse_backend;
-  Qp.init(H, g, A, b, C, l, u, compute_preconditioner, rho, mu_eq, mu_in);
-  Qp.solve(x, y, z);
-
-  return Qp.results;
-}
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file wrapper.hpp
+ */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP
+#define PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP
+#include <proxsuite/proxqp/results.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+#include <proxsuite/proxqp/sparse/solver.hpp>
+#include <proxsuite/proxqp/sparse/helpers.hpp>
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+///
+/// @brief This class defines the API of PROXQP solver with sparse backend.
+///
+/*!
+ * Wrapper class for using proxsuite API with dense backend
+ * for solving linearly constrained convex QP problem using ProxQp algorithm.
+ *
+ * Example usage:
+ * ```cpp
+#include <Eigen/Core>
+#include <Eigen/Cholesky>
+#include <proxsuite/proxqp/dense/dense.hpp>
+#include <proxsuite/linalg/veg/util/dbg.hpp>
+#include <util.hpp>
+
+using T = double;
+using I = c_int;
+auto main() -> int {
+
+        // Generate a random QP problem with primal variable dimension of size
+dim; n_eq equality constraints and n_in inequality constraints
+        ::proxsuite::proxqp::test::rand::set_seed(1);
+        proxqp::isize dim = 10;
+        proxqp::isize n_eq(dim / 4);
+        proxqp::isize n_in(dim / 4);
+        T strong_convexity_factor(1.e-2);
+        T sparsity_factor = 0.15; // controls the sparsity of each matrix of the
+problem generated T eps_abs = T(1e-9); double p = 1.0; T conditioning(10.0);
+        auto H =
+::proxsuite::proxqp::test::rand::sparse_positive_definite_rand(n, conditioning,
+p); auto g = ::proxsuite::proxqp::test::rand::vector_rand<T>(n); auto A =
+::proxsuite::proxqp::test::rand::sparse_matrix_rand<T>(n_eq,n, p); auto b =
+::proxsuite::proxqp::test::rand::vector_rand<T>(n_eq); auto C =
+::proxsuite::proxqp::test::rand::sparse_matrix_rand<T>(n_in,n, p); auto l =
+::proxsuite::proxqp::test::rand::vector_rand<T>(n_in); auto u = (l.array() +
+1).matrix().eval();
+
+        proxqp::sparse::QP<T,I> Qp(n, n_eq, n_in);
+        Qp.settings.eps_abs = 1.E-9;
+        Qp.settings.verbose = true;
+        Qp.setup_sparse_matrices(H,g,A,b,C,u,l);
+        Qp.solve();
+
+        // Solve the problem
+        proxqp::sparse::QP<T,I> Qp(n, n_eq, n_in);
+        Qp.settings.eps_abs = 1.E-9;
+        Qp.settings.verbose = true;
+        Qp.setup_sparse_matrices(H,g,A,b,C,u,l);
+        Qp.solve();
+
+        // Verify solution accuracy
+        T pri_res = std::max(
+                        (qp.A * Qp.results.x - qp.b).lpNorm<Eigen::Infinity>(),
+                        (helpers::positive_part(qp.C * Qp.results.x -
+qp.u) + helpers::negative_part(qp.C * Qp.results.x - qp.l))
+                                        .lpNorm<Eigen::Infinity>());
+        T dua_res = (qp.H * Qp.results.x + qp.g + qp.A.transpose() *
+Qp.results.y + qp.C.transpose() * Qp.results.z) .lpNorm<Eigen::Infinity>();
+        VEG_ASSERT(pri_res <= eps_abs);
+        VEG_ASSERT(dua_res <= eps_abs);
+
+        // Some solver statistics
+        std::cout << "------solving qp with dim: " << dim
+                                                << " neq: " << n_eq << " nin: "
+<< n_in << std::endl; std::cout << "primal residual: " << pri_res << std::endl;
+        std::cout << "dual residual: " << dua_res << std::endl;
+        std::cout << "total number of iteration: " << Qp.results.info.iter
+                                                << std::endl;
+}
+ * ```
+ */
+template<typename T, typename I>
+struct QP
+{
+  Results<T> results;
+  Settings<T> settings;
+  Model<T, I> model;
+  Workspace<T, I> work;
+  preconditioner::RuizEquilibration<T, I> ruiz;
+  /*!
+   * Default constructor using the dimension of the matrices in entry.
+   * @param dim primal variable dimension.
+   * @param n_eq number of equality constraints.
+   * @param n_in number of inequality constraints.
+   */
+  QP(isize dim, isize n_eq, isize n_in)
+    : results(dim, n_eq, n_in)
+    , settings()
+    , model(dim, n_eq, n_in)
+    , work()
+    , ruiz(dim, n_eq + n_in, 1e-3, 10, preconditioner::Symmetry::UPPER)
+  {
+    work.timer.stop();
+    work.internal.do_symbolic_fact = true;
+    work.internal.is_initialized = false;
+  }
+  /*!
+   * Default constructor using the sparsity structure of the matrices in entry.
+   * @param H boolean mask of the quadratic cost input defining the QP model.
+   * @param A boolean mask of the equality constraint matrix input defining the
+   * QP model.
+   * @param C boolean mask of the inequality constraint matrix input defining
+   * the QP model.
+   */
+  QP(const SparseMat<bool, I>& H,
+     const SparseMat<bool, I>& A,
+     const SparseMat<bool, I>& C)
+    : QP(H.rows(), A.rows(), C.rows())
+  {
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    SparseMat<bool, I> H_triu = H.template triangularView<Eigen::Upper>();
+    SparseMat<bool, I> AT = A.transpose();
+    SparseMat<bool, I> CT = C.transpose();
+    proxsuite::linalg::sparse::MatRef<bool, I> Href = {
+      proxsuite::linalg::sparse::from_eigen, H_triu
+    };
+    proxsuite::linalg::sparse::MatRef<bool, I> ATref = {
+      proxsuite::linalg::sparse::from_eigen, AT
+    };
+    proxsuite::linalg::sparse::MatRef<bool, I> CTref = {
+      proxsuite::linalg::sparse::from_eigen, CT
+    };
+    work.setup_symbolic_factorizaton(
+      model, Href.symbolic(), ATref.symbolic(), CTref.symbolic());
+    if (settings.compute_timings) {
+      results.info.setup_time = work.timer.elapsed().user; // in microseconds
+    }
+  }
+
+  /*!
+   * Setups the QP model (with sparse matrix format) and equilibrates it.
+   * @param H quadratic cost input defining the QP model.
+   * @param g linear cost input defining the QP model.
+   * @param A equality constraint matrix input defining the QP model.
+   * @param b equality constraint vector input defining the QP model.
+   * @param C inequality constraint matrix input defining the QP model.
+   * @param l lower inequality constraint vector input defining the QP model.
+   * @param u upper inequality constraint vector input defining the QP model.
+   * @param compute_preconditioner boolean parameter for executing or not the
+   * preconditioner.
+   * @param rho proximal step size wrt primal variable.
+   * @param mu_eq proximal step size wrt equality constrained multiplier.
+   * @param mu_in proximal step size wrt inequality constrained multiplier.
+   */
+  void init(optional<SparseMat<T, I>> H,
+            optional<VecRef<T>> g,
+            optional<SparseMat<T, I>> A,
+            optional<VecRef<T>> b,
+            optional<SparseMat<T, I>> C,
+            optional<VecRef<T>> l,
+            optional<VecRef<T>> u,
+            bool compute_preconditioner_ = true,
+            optional<T> rho = nullopt,
+            optional<T> mu_eq = nullopt,
+            optional<T> mu_in = nullopt)
+  {
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    if (g != nullopt && g.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        g.value().size(),
+        model.dim,
+        "the dimension wrt the primal variable x variable for initializing g "
+        "is not valid.");
+    } else {
+      g.reset();
+    }
+    if (b != nullopt && b.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        b.value().size(),
+        model.n_eq,
+        "the dimension wrt equality constrained variables for initializing b "
+        "is not valid.");
+    } else {
+      b.reset();
+    }
+    if (u != nullopt && u.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        u.value().size(),
+        model.n_in,
+        "the dimension wrt inequality constrained variables for initializing u "
+        "is not valid.");
+    } else {
+      u.reset();
+    }
+    if (l != nullopt && l.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        l.value().size(),
+        model.n_in,
+        "the dimension wrt inequality constrained variables for initializing l "
+        "is not valid.");
+    } else {
+      l.reset();
+    }
+    if (H != nullopt && H.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().rows(),
+        model.dim,
+        "the row dimension for initializing H is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().cols(),
+        model.dim,
+        "the column dimension for initializing H is not valid.");
+    } else {
+      H.reset();
+    }
+    if (A != nullopt && A.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().rows(),
+        model.n_eq,
+        "the row dimension for initializing A is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().cols(),
+        model.dim,
+        "the column dimension for initializing A is not valid.");
+    } else {
+      A.reset();
+    }
+    if (C != nullopt && C.value().size() != 0) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().rows(),
+        model.n_in,
+        "the row dimension for initializing C is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().cols(),
+        model.dim,
+        "the column dimension for initializing C is not valid.");
+    } else {
+      C.reset();
+    }
+    work.internal.proximal_parameter_update = false;
+    PreconditionerStatus preconditioner_status;
+    if (compute_preconditioner_) {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
+    } else {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::IDENTITY;
+    }
+    proxsuite::proxqp::sparse::update_proximal_parameters(
+      settings, results, work, rho, mu_eq, mu_in);
+
+    if (g != nullopt) {
+      model.g = g.value();
+    } // else qpmodel.g remains initialzed to a matrix with zero elements or
+      // zero shape
+    if (b != nullopt) {
+      model.b = b.value();
+    } // else qpmodel.b remains initialzed to a matrix with zero elements or
+      // zero shape
+    if (u != nullopt) {
+      model.u = u.value();
+    } // else qpmodel.u remains initialzed to a matrix with zero elements or
+      // zero shape
+    if (l != nullopt) {
+      model.l = l.value();
+    } // else qpmodel.l remains initialzed to a matrix with zero elements or
+      // zero shape
+
+    // avoid allocations when H is not nullopt
+    SparseMat<T, I> AT(model.dim, model.n_eq);
+    if (A != nullopt) {
+      AT = (A.value()).transpose();
+    } else {
+      AT.setZero();
+    }
+    SparseMat<T, I> CT(model.dim, model.n_in);
+    if (C != nullopt) {
+      CT = (C.value()).transpose();
+    } else {
+      CT.setZero();
+    }
+    if (H != nullopt) {
+      SparseMat<T, I> H_triu =
+        (H.value()).template triangularView<Eigen::Upper>();
+      sparse::QpView<T, I> qp = {
+        { proxsuite::linalg::sparse::from_eigen, H_triu },
+        { proxsuite::linalg::sparse::from_eigen, model.g },
+        { proxsuite::linalg::sparse::from_eigen, AT },
+        { proxsuite::linalg::sparse::from_eigen, model.b },
+        { proxsuite::linalg::sparse::from_eigen, CT },
+        { proxsuite::linalg::sparse::from_eigen, model.l },
+        { proxsuite::linalg::sparse::from_eigen, model.u }
+      };
+      qp_setup(qp, results, model, work, settings, ruiz, preconditioner_status);
+    } else {
+      SparseMat<T, I> H_triu(model.dim, model.dim);
+      H_triu.setZero();
+      H_triu = (H.value()).template triangularView<Eigen::Upper>();
+      sparse::QpView<T, I> qp = {
+        { proxsuite::linalg::sparse::from_eigen, H_triu },
+        { proxsuite::linalg::sparse::from_eigen, model.g },
+        { proxsuite::linalg::sparse::from_eigen, AT },
+        { proxsuite::linalg::sparse::from_eigen, model.b },
+        { proxsuite::linalg::sparse::from_eigen, CT },
+        { proxsuite::linalg::sparse::from_eigen, model.l },
+        { proxsuite::linalg::sparse::from_eigen, model.u }
+      };
+      qp_setup(qp, results, model, work, settings, ruiz, preconditioner_status);
+    }
+    work.internal.is_initialized = true;
+
+    if (settings.compute_timings) {
+      results.info.setup_time += work.timer.elapsed().user; // in microseconds
+    }
+  };
+  /*!
+   * Updates the QP model (with sparse matrix format) and re-equilibrates it if
+   * specified by the user. If matrices in entry are not null, the update is
+   * effective only if the sparsity structure of entry is the same as the one
+   * used for the initialization.
+   * @param H quadratic cost input defining the QP model.
+   * @param g linear cost input defining the QP model.
+   * @param A equality constraint matrix input defining the QP model.
+   * @param b equality constraint vector input defining the QP model.
+   * @param C inequality constraint matrix input defining the QP model.
+   * @param l lower inequality constraint vector input defining the QP model.
+   * @param u lower inequality constraint vector input defining the QP model.
+   * @param update_preconditioner bool parameter for updating or not the
+   * preconditioner and the associated scaled model.
+   * @param rho proximal step size wrt primal variable.
+   * @param mu_eq proximal step size wrt equality constrained multiplier.
+   * @param mu_in proximal step size wrt inequality constrained multiplier.
+   * @note The init method should be called before update. If it has not been
+   * done before, init is called depending on the is_initialized flag.
+   */
+  void update(const optional<SparseMat<T, I>> H,
+              optional<VecRef<T>> g,
+              const optional<SparseMat<T, I>> A,
+              optional<VecRef<T>> b,
+              const optional<SparseMat<T, I>> C,
+              optional<VecRef<T>> l,
+              optional<VecRef<T>> u,
+              bool update_preconditioner = true,
+              optional<T> rho = nullopt,
+              optional<T> mu_eq = nullopt,
+              optional<T> mu_in = nullopt)
+  {
+    if (!work.internal.is_initialized) {
+      init(H, g, A, b, C, l, u, update_preconditioner, rho, mu_eq, mu_in);
+      return;
+    }
+    if (settings.compute_timings) {
+      work.timer.stop();
+      work.timer.start();
+    }
+    work.internal.dirty = false;
+    work.internal.proximal_parameter_update = false;
+    PreconditionerStatus preconditioner_status;
+    if (update_preconditioner) {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::EXECUTE;
+    } else {
+      preconditioner_status = proxsuite::proxqp::PreconditionerStatus::KEEP;
+    }
+    isize n = model.dim;
+    isize n_eq = model.n_eq;
+    isize n_in = model.n_in;
+    proxsuite::linalg::sparse::MatMut<T, I> kkt_unscaled =
+      model.kkt_mut_unscaled();
+
+    auto kkt_top_n_rows = detail::top_rows_mut_unchecked(
+      proxsuite::linalg::veg::unsafe, kkt_unscaled, n);
+
+    proxsuite::linalg::sparse::MatMut<T, I> H_unscaled =
+      detail::middle_cols_mut(kkt_top_n_rows, 0, n, model.H_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> AT_unscaled =
+      detail::middle_cols_mut(kkt_top_n_rows, n, n_eq, model.A_nnz);
+
+    proxsuite::linalg::sparse::MatMut<T, I> CT_unscaled =
+      detail::middle_cols_mut(kkt_top_n_rows, n + n_eq, n_in, model.C_nnz);
+
+    // check the model is valid
+    if (g != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(g.value().size(),
+                                    model.dim,
+                                    "the dimension wrt the primal variable x "
+                                    "variable for updating g is not valid.");
+    }
+    if (b != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(b.value().size(),
+                                    model.n_eq,
+                                    "the dimension wrt equality constrained "
+                                    "variables for updating b is not valid.");
+    }
+    if (u != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(u.value().size(),
+                                    model.n_in,
+                                    "the dimension wrt inequality constrained "
+                                    "variables for updating u is not valid.");
+    }
+    if (l != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(l.value().size(),
+                                    model.n_in,
+                                    "the dimension wrt inequality constrained "
+                                    "variables for updating l is not valid.");
+    }
+    if (H != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().rows(),
+        model.dim,
+        "the row dimension for updating H is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        H.value().cols(),
+        model.dim,
+        "the column dimension for updating H is not valid.");
+    }
+    if (A != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().rows(),
+        model.n_eq,
+        "the row dimension for updating A is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        A.value().cols(),
+        model.dim,
+        "the column dimension for updating A is not valid.");
+    }
+    if (C != nullopt) {
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().rows(),
+        model.n_in,
+        "the row dimension for updating C is not valid.");
+      PROXSUITE_CHECK_ARGUMENT_SIZE(
+        C.value().cols(),
+        model.dim,
+        "the column dimension for updating C is not valid.");
+    }
+
+    // update the model
+
+    if (g != nullopt) {
+      model.g = g.value();
+    }
+    if (b != nullopt) {
+      model.b = b.value();
+    }
+    if (u != nullopt) {
+      model.u = u.value();
+    }
+    if (l != nullopt) {
+      model.l = l.value();
+    }
+    if (H != nullopt) {
+      SparseMat<T, I> H_triu =
+        H.value().template triangularView<Eigen::Upper>();
+      if (A != nullopt) {
+        if (C != nullopt) {
+          bool res =
+            have_same_structure(
+              H_unscaled.as_const(),
+              { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
+            have_same_structure(AT_unscaled.as_const(),
+                                { proxsuite::linalg::sparse::from_eigen,
+                                  SparseMat<T, I>(A.value().transpose()) }) &&
+            have_same_structure(CT_unscaled.as_const(),
+                                { proxsuite::linalg::sparse::from_eigen,
+                                  SparseMat<T, I>(C.value().transpose()) });
+          /* TO PUT IN DEBUG MODE
+          std::cout << "have same structure = " << res << std::endl;
+          */
+          if (res) {
+            copy(H_unscaled,
+                 { proxsuite::linalg::sparse::from_eigen,
+                   H_triu }); // copy rhs into lhs
+            copy(
+              AT_unscaled,
+              { proxsuite::linalg::sparse::from_eigen,
+                SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
+            copy(
+              CT_unscaled,
+              { proxsuite::linalg::sparse::from_eigen,
+                SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
+          }
+        } else {
+          bool res =
+            have_same_structure(
+              H_unscaled.as_const(),
+              { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
+            have_same_structure(AT_unscaled.as_const(),
+                                { proxsuite::linalg::sparse::from_eigen,
+                                  SparseMat<T, I>(A.value().transpose()) });
+          /* TO PUT IN DEBUG MODE
+          std::cout << "have same structure = " << res << std::endl;
+          */
+          if (res) {
+            copy(H_unscaled,
+                 { proxsuite::linalg::sparse::from_eigen,
+                   H_triu }); // copy rhs into lhs
+            copy(
+              AT_unscaled,
+              { proxsuite::linalg::sparse::from_eigen,
+                SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
+          }
+        }
+      } else if (C != nullopt) {
+        bool res =
+          have_same_structure(
+            H_unscaled.as_const(),
+            { proxsuite::linalg::sparse::from_eigen, H_triu }) &&
+          have_same_structure(CT_unscaled.as_const(),
+                              { proxsuite::linalg::sparse::from_eigen,
+                                SparseMat<T, I>(C.value().transpose()) });
+        /* TO PUT IN DEBUG MODE
+        std::cout << "have same structure = " << res << std::endl;
+        */
+        if (res) {
+          copy(H_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 H_triu }); // copy rhs into lhs
+          copy(CT_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
+        }
+      } else {
+
+        bool res = have_same_structure(
+          H_unscaled.as_const(),
+          { proxsuite::linalg::sparse::from_eigen, H_triu });
+        /* TO PUT IN DEBUG MODE
+        std::cout << "have same structure = " << res << std::endl;
+        */
+        if (res) {
+          copy(H_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 H.value() }); // copy rhs into lhs
+        }
+      }
+    } else if (A != nullopt) {
+      if (C != nullopt) {
+        bool res =
+          have_same_structure(AT_unscaled.as_const(),
+                              { proxsuite::linalg::sparse::from_eigen,
+                                SparseMat<T, I>(A.value().transpose()) }) &&
+          have_same_structure(CT_unscaled.as_const(),
+                              { proxsuite::linalg::sparse::from_eigen,
+                                SparseMat<T, I>(C.value().transpose()) });
+        /* TO PUT IN DEBUG MODE
+        std::cout << "have same structure = " << res << std::endl;
+        */
+        if (res) {
+          copy(AT_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
+          copy(CT_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
+        }
+      } else {
+        bool res =
+          have_same_structure(AT_unscaled.as_const(),
+                              { proxsuite::linalg::sparse::from_eigen,
+                                SparseMat<T, I>(A.value().transpose()) });
+        /* TO PUT IN DEBUG MODE
+        std::cout << "have same structure = " << res << std::endl;
+        */
+        if (res) {
+          copy(AT_unscaled,
+               { proxsuite::linalg::sparse::from_eigen,
+                 SparseMat<T, I>(A.value().transpose()) }); // copy rhs into lhs
+        }
+      }
+    } else if (C != nullopt) {
+      bool res =
+        have_same_structure(CT_unscaled.as_const(),
+                            { proxsuite::linalg::sparse::from_eigen,
+                              SparseMat<T, I>(C.value().transpose()) });
+      /* TO PUT IN DEBUG MODE
+      std::cout << "have same structure = " << res << std::endl;
+      */
+      if (res) {
+        copy(CT_unscaled,
+             { proxsuite::linalg::sparse::from_eigen,
+               SparseMat<T, I>(C.value().transpose()) }); // copy rhs into lhs
+      }
+    }
+
+    SparseMat<T, I> H_triu =
+      H_unscaled.to_eigen().template triangularView<Eigen::Upper>();
+    sparse::QpView<T, I> qp = {
+      { proxsuite::linalg::sparse::from_eigen, H_triu },
+      { proxsuite::linalg::sparse::from_eigen, model.g },
+      { proxsuite::linalg::sparse::from_eigen, AT_unscaled.to_eigen() },
+      { proxsuite::linalg::sparse::from_eigen, model.b },
+      { proxsuite::linalg::sparse::from_eigen, CT_unscaled.to_eigen() },
+      { proxsuite::linalg::sparse::from_eigen, model.l },
+      { proxsuite::linalg::sparse::from_eigen, model.u }
+    };
+    proxsuite::proxqp::sparse::update_proximal_parameters(
+      settings, results, work, rho, mu_eq, mu_in);
+    qp_setup(qp,
+             results,
+             model,
+             work,
+             settings,
+             ruiz,
+             preconditioner_status); // store model value + performs scaling
+                                     // according to chosen options
+    if (settings.compute_timings) {
+      results.info.setup_time = work.timer.elapsed().user; // in microseconds
+    }
+  };
+
+  /*!
+   * Solves the QP problem using PRXOQP algorithm.
+   */
+  void solve()
+  {
+    qp_solve( //
+      results,
+      model,
+      settings,
+      work,
+      ruiz);
+  };
+  /*!
+   * Solves the QP problem using PROXQP algorithm and a warm start.
+   * @param x primal warm start.
+   * @param y dual equality warm start.
+   * @param z dual inequality warm start.
+   */
+  void solve(optional<VecRef<T>> x,
+             optional<VecRef<T>> y,
+             optional<VecRef<T>> z)
+  {
+    proxsuite::proxqp::sparse::warm_start(x, y, z, results, settings, model);
+    qp_solve( //
+      results,
+      model,
+      settings,
+      work,
+      ruiz);
+  };
+  /*!
+   * Clean-ups solver's results.
+   */
+  void cleanup() { results.cleanup(settings); }
+};
+/*!
+ * Solves the QP problem using PROXQP algorithm without the need to define a QP
+ * object, with matrices defined by Dense Eigen matrices. It is possible to set
+ * up some of the solver parameters (warm start, initial guess option, proximal
+ * step sizes, absolute and relative accuracies, maximum number of iterations,
+ * preconditioner execution).
+ * @param H quadratic cost input defining the QP model.
+ * @param g linear cost input defining the QP model.
+ * @param A equality constraint matrix input defining the QP model.
+ * @param b equality constraint vector input defining the QP model.
+ * @param C inequality constraint matrix input defining the QP model.
+ * @param l lower inequality constraint vector input defining the QP model.
+ * @param u upper inequality constraint vector input defining the QP model.
+ * @param x primal warm start.
+ * @param y dual equality constraint warm start.
+ * @param z dual inequality constraint warm start.
+ * @param verbose if set to true, the solver prints more information about each
+ * iteration.
+ * @param compute_preconditioner boolean parameter for executing or not the
+ * preconditioner.
+ * @param compute_timings boolean parameter for computing the solver timings.
+ * @param rho proximal step size wrt primal variable.
+ * @param mu_eq proximal step size wrt equality constrained multiplier.
+ * @param mu_in proximal step size wrt inequality constrained multiplier.
+ * @param eps_abs absolute accuracy threshold.
+ * @param eps_rel relative accuracy threshold.
+ * @param max_iter maximum number of iteration.
+ * @param initial_guess initial guess option for warm starting or not the
+ * initial iterate values.
+ * @param check_duality_gap If set to true, include the duality gap in absolute
+ * and relative stopping criteria.
+ * @param eps_duality_gap_abs absolute accuracy threshold for the duality-gap
+ * criterion.
+ * @param eps_duality_gap_rel relative accuracy threshold for the duality-gap
+ * criterion.
+ */
+template<typename T, typename I>
+proxqp::Results<T>
+solve(
+  optional<SparseMat<T, I>> H,
+  optional<VecRef<T>> g,
+  optional<SparseMat<T, I>> A,
+  optional<VecRef<T>> b,
+  optional<SparseMat<T, I>> C,
+  optional<VecRef<T>> l,
+  optional<VecRef<T>> u,
+  optional<VecRef<T>> x = nullopt,
+  optional<VecRef<T>> y = nullopt,
+  optional<VecRef<T>> z = nullopt,
+  optional<T> eps_abs = nullopt,
+  optional<T> eps_rel = nullopt,
+  optional<T> rho = nullopt,
+  optional<T> mu_eq = nullopt,
+  optional<T> mu_in = nullopt,
+  optional<bool> verbose = nullopt,
+  bool compute_preconditioner = true,
+  bool compute_timings = false,
+  optional<isize> max_iter = nullopt,
+  proxsuite::proxqp::InitialGuessStatus initial_guess =
+    proxsuite::proxqp::InitialGuessStatus::EQUALITY_CONSTRAINED_INITIAL_GUESS,
+  proxsuite::proxqp::SparseBackend sparse_backend =
+    proxsuite::proxqp::SparseBackend::Automatic,
+  bool check_duality_gap = false,
+  optional<T> eps_duality_gap_abs = nullopt,
+  optional<T> eps_duality_gap_rel = nullopt)
+{
+
+  isize n(0);
+  isize n_eq(0);
+  isize n_in(0);
+  if (H != nullopt) {
+    n = H.value().rows();
+  }
+  if (A != nullopt) {
+    n_eq = A.value().rows();
+  }
+  if (C != nullopt) {
+    n_in = C.value().rows();
+  }
+
+  proxqp::sparse::QP<T, I> Qp(n, n_eq, n_in);
+  Qp.settings.initial_guess = initial_guess;
+  Qp.settings.check_duality_gap = check_duality_gap;
+
+  if (eps_abs != nullopt) {
+    Qp.settings.eps_abs = eps_abs.value();
+  }
+  if (eps_rel != nullopt) {
+    Qp.settings.eps_rel = eps_rel.value();
+  }
+  if (verbose != nullopt) {
+    Qp.settings.verbose = verbose.value();
+  }
+  if (max_iter != nullopt) {
+    Qp.settings.max_iter = max_iter.value();
+  }
+  if (eps_duality_gap_abs != nullopt) {
+    Qp.settings.eps_duality_gap_abs = eps_duality_gap_abs.value();
+  }
+  if (eps_duality_gap_rel != nullopt) {
+    Qp.settings.eps_duality_gap_rel = eps_duality_gap_rel.value();
+  }
+  Qp.settings.compute_timings = compute_timings;
+  Qp.settings.sparse_backend = sparse_backend;
+  Qp.init(H, g, A, b, C, l, u, compute_preconditioner, rho, mu_eq, mu_in);
+  Qp.solve(x, y, z);
+
+  return Qp.results;
+}
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_WRAPPER_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/identity.hpp

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP
-#define PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-namespace preconditioner {
-
-template<typename T, typename I>
-struct Identity
-{
-
-  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
-                                    isize /*n*/,
-                                    isize /*n_eq*/,
-                                    isize /*n_in*/)
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return { 0, 1 };
-  }
-
-  void scale_qp_in_place(
-    QpViewMut<T, I> /*qp*/,
-    proxsuite::linalg::veg::dynstack::DynStackMut /*stack*/)
-  {
-  }
-
-  // modifies variables in place
-  void scale_primal_in_place(VectorViewMut<T> /*primal*/) {}
-  void scale_dual_in_place(VectorViewMut<T> /*dual*/) {}
-
-  void scale_dual_in_place_eq(VectorViewMut<T> /*dual*/) {}
-  void scale_dual_in_place_in(VectorViewMut<T> /*dual*/) {}
-
-  void unscale_primal_in_place(VectorViewMut<T> /*primal*/) {}
-  void unscale_dual_in_place(VectorViewMut<T> /*dual*/) {}
-
-  void unscale_dual_in_place_eq(VectorViewMut<T> /*dual*/) {}
-
-  void unscale_dual_in_place_in(VectorViewMut<T> /*dual*/) {}
-  // modifies residuals in place
-  void scale_primal_residual_in_place(VectorViewMut<T> /*primal*/) {}
-
-  void scale_primal_residual_in_place_eq(VectorViewMut<T> /*primal_eq*/) {}
-  void scale_primal_residual_in_place_in(VectorViewMut<T> /*primal_in*/) {}
-  void scale_dual_residual_in_place(VectorViewMut<T> /*dual*/) {}
-  void unscale_primal_residual_in_place(VectorViewMut<T> /*primal*/) {}
-  void unscale_primal_residual_in_place_eq(VectorViewMut<T> /*primal_eq*/) {}
-  void unscale_primal_residual_in_place_in(VectorViewMut<T> /*primal_in*/) {}
-  void unscale_dual_residual_in_place(VectorViewMut<T> /*dual*/) {}
-};
-
-} // namespace preconditioner
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP
+#define PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+namespace preconditioner {
+
+template<typename T, typename I>
+struct Identity
+{
+
+  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> /*tag*/,
+                                    isize /*n*/,
+                                    isize /*n_eq*/,
+                                    isize /*n_in*/)
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return { 0, 1 };
+  }
+
+  void scale_qp_in_place(
+    QpViewMut<T, I> /*qp*/,
+    proxsuite::linalg::veg::dynstack::DynStackMut /*stack*/)
+  {
+  }
+
+  // modifies variables in place
+  void scale_primal_in_place(VectorViewMut<T> /*primal*/) {}
+  void scale_dual_in_place(VectorViewMut<T> /*dual*/) {}
+
+  void scale_dual_in_place_eq(VectorViewMut<T> /*dual*/) {}
+  void scale_dual_in_place_in(VectorViewMut<T> /*dual*/) {}
+
+  void unscale_primal_in_place(VectorViewMut<T> /*primal*/) {}
+  void unscale_dual_in_place(VectorViewMut<T> /*dual*/) {}
+
+  void unscale_dual_in_place_eq(VectorViewMut<T> /*dual*/) {}
+
+  void unscale_dual_in_place_in(VectorViewMut<T> /*dual*/) {}
+  // modifies residuals in place
+  void scale_primal_residual_in_place(VectorViewMut<T> /*primal*/) {}
+
+  void scale_primal_residual_in_place_eq(VectorViewMut<T> /*primal_eq*/) {}
+  void scale_primal_residual_in_place_in(VectorViewMut<T> /*primal_in*/) {}
+  void scale_dual_residual_in_place(VectorViewMut<T> /*dual*/) {}
+  void unscale_primal_residual_in_place(VectorViewMut<T> /*primal*/) {}
+  void unscale_primal_residual_in_place_eq(VectorViewMut<T> /*primal_eq*/) {}
+  void unscale_primal_residual_in_place_in(VectorViewMut<T> /*primal_in*/) {}
+  void unscale_dual_residual_in_place(VectorViewMut<T> /*dual*/) {}
+};
+
+} // namespace preconditioner
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_PRECOND_IDENTITY_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/ruiz.hpp

 * *Ordering differences only*

```diff
@@ -1,569 +1,569 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP
-#define PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP
-
-#include "proxsuite/proxqp/sparse/fwd.hpp"
-
-namespace proxsuite {
-namespace proxqp {
-namespace sparse {
-
-namespace preconditioner {
-enum struct Symmetry
-{
-  LOWER,
-  UPPER,
-};
-
-namespace detail {
-template<typename T, typename I>
-void
-rowwise_infty_norm(T* row_norm, proxsuite::linalg::sparse::MatRef<T, I> m)
-{
-  using namespace proxsuite::linalg::sparse::util;
-
-  I const* mi = m.row_indices();
-  T const* mx = m.values();
-
-  for (usize j = 0; j < usize(m.ncols()); ++j) {
-    auto col_start = m.col_start(j);
-    auto col_end = m.col_end(j);
-
-    for (usize p = col_start; p < col_end; ++p) {
-      usize i = zero_extend(mi[p]);
-      T mij = fabs(mx[p]);
-      row_norm[i] = std::max(row_norm[i], mij);
-    }
-  }
-}
-
-template<typename T, typename I>
-void
-colwise_infty_norm_symhi(T* col_norm, proxsuite::linalg::sparse::MatRef<T, I> h)
-{
-  using namespace proxsuite::linalg::sparse::util;
-
-  I const* hi = h.row_indices();
-  T const* hx = h.values();
-
-  for (usize j = 0; j < usize(h.ncols()); ++j) {
-    auto col_start = h.col_start(j);
-    auto col_end = h.col_end(j);
-
-    T norm_j = 0;
-
-    for (usize p = col_start; p < col_end; ++p) {
-      usize i = zero_extend(hi[p]);
-      if (i > j) {
-        break;
-      }
-
-      T hij = fabs(hx[p]);
-      norm_j = std::max(norm_j, hij);
-      col_norm[i] = std::max(col_norm[i], hij);
-    }
-
-    col_norm[j] = norm_j;
-  }
-}
-
-template<typename T, typename I>
-void
-colwise_infty_norm_symlo(T* col_norm, proxsuite::linalg::sparse::MatRef<T, I> h)
-{
-  using namespace proxsuite::linalg::sparse::util;
-
-  I const* hi = h.row_indices();
-  T const* hx = h.values();
-
-  for (usize j = 0; j < usize(h.ncols()); ++j) {
-    auto col_start = h.col_start(j);
-    auto col_end = h.col_end(j);
-
-    T norm_j = 0;
-
-    if (col_end > col_start) {
-      usize p = col_end;
-      while (true) {
-        --p;
-        usize i = zero_extend(hi[p]);
-        if (i < j) {
-          break;
-        }
-
-        T hij = fabs(hx[p]);
-        norm_j = std::max(norm_j, hij);
-        col_norm[i] = std::max(col_norm[i], hij);
-
-        if (p <= col_start) {
-          break;
-        }
-      }
-    }
-    col_norm[j] = std::max(col_norm[j], norm_j);
-  }
-}
-
-template<typename T, typename I>
-auto
-ruiz_scale_qp_in_place( //
-  VectorViewMut<T> delta_,
-  QpViewMut<T, I> qp,
-  T epsilon,
-  isize max_iter,
-  Symmetry sym,
-  proxsuite::linalg::veg::dynstack::DynStackMut stack) -> T
-{
-
-  T c = 1;
-  auto S = delta_.to_eigen();
-
-  isize n = qp.H.nrows();
-  isize n_eq = qp.AT.ncols();
-  isize n_in = qp.CT.ncols();
-
-  T gamma = 1;
-  i64 iter = 1;
-
-  LDLT_TEMP_VEC(T, delta, n + n_eq + n_in, stack);
-
-  I* Hi = qp.H.row_indices_mut();
-  T* Hx = qp.H.values_mut();
-
-  I* ATi = qp.AT.row_indices_mut();
-  T* ATx = qp.AT.values_mut();
-
-  I* CTi = qp.CT.row_indices_mut();
-  T* CTx = qp.CT.values_mut();
-
-  T const machine_eps = std::numeric_limits<T>::epsilon();
-
-  while (infty_norm((1 - delta.array()).matrix()) > epsilon) {
-    if (iter == max_iter) {
-      break;
-    } else {
-      ++iter;
-    }
-
-    // norm_infty of each column of A (resp. C), i.e.,
-    // each row of AT (resp. CT)
-    {
-      auto _a_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
-      auto _c_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
-      auto _h_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
-      T* a_infty_norm = _a_infty_norm.ptr_mut();
-      T* c_infty_norm = _c_infty_norm.ptr_mut();
-      T* h_infty_norm = _h_infty_norm.ptr_mut();
-
-      detail::rowwise_infty_norm(a_infty_norm, qp.AT.as_const());
-      detail::rowwise_infty_norm(c_infty_norm, qp.CT.as_const());
-      switch (sym) {
-        case Symmetry::LOWER: {
-          detail::colwise_infty_norm_symlo(h_infty_norm, qp.H.as_const());
-          break;
-        }
-        case Symmetry::UPPER: {
-          detail::colwise_infty_norm_symhi(h_infty_norm, qp.H.as_const());
-          break;
-        }
-      }
-
-      for (isize j = 0; j < n; ++j) {
-        delta(j) = T(1) / (machine_eps + sqrt(std::max({
-                                           h_infty_norm[j],
-                                           a_infty_norm[j],
-                                           c_infty_norm[j],
-                                         })));
-      }
-    }
-    using namespace proxsuite::linalg::sparse::util;
-    for (usize j = 0; j < usize(n_eq); ++j) {
-      T a_row_norm = 0;
-      qp.AT.to_eigen();
-      usize col_start = qp.AT.col_start(j);
-      usize col_end = qp.AT.col_end(j);
-
-      for (usize p = col_start; p < col_end; ++p) {
-        T aji = fabs(ATx[p]);
-        a_row_norm = std::max(a_row_norm, aji);
-      }
-
-      delta(n + isize(j)) = T(1) / (machine_eps + sqrt(a_row_norm));
-    }
-
-    for (usize j = 0; j < usize(n_in); ++j) {
-      T c_row_norm = 0;
-      usize col_start = qp.CT.col_start(j);
-      usize col_end = qp.CT.col_end(j);
-
-      for (usize p = col_start; p < col_end; ++p) {
-        T cji = fabs(CTx[p]);
-        c_row_norm = std::max(c_row_norm, cji);
-      }
-
-      delta(n + n_eq + isize(j)) = T(1) / (machine_eps + sqrt(c_row_norm));
-    }
-
-    // normalize A
-    for (usize j = 0; j < usize(n_eq); ++j) {
-      usize col_start = qp.AT.col_start(j);
-      usize col_end = qp.AT.col_end(j);
-
-      T delta_j = delta(n + isize(j));
-
-      for (usize p = col_start; p < col_end; ++p) {
-        usize i = zero_extend(ATi[p]);
-        T& aji = ATx[p];
-        T delta_i = delta(isize(i));
-        aji = delta_i * (aji * delta_j);
-      }
-    }
-
-    // normalize C
-    for (usize j = 0; j < usize(n_in); ++j) {
-      usize col_start = qp.CT.col_start(j);
-      usize col_end = qp.CT.col_end(j);
-
-      T delta_j = delta(n + n_eq + isize(j));
-
-      for (usize p = col_start; p < col_end; ++p) {
-        usize i = zero_extend(CTi[p]);
-        T& cji = CTx[p];
-        T delta_i = delta(isize(i));
-        cji = delta_i * (cji * delta_j);
-      }
-    }
-
-    // normalize H
-    switch (sym) {
-      case Symmetry::LOWER: {
-        for (usize j = 0; j < usize(n); ++j) {
-          usize col_start = qp.H.col_start(j);
-          usize col_end = qp.H.col_end(j);
-          T delta_j = delta(isize(j));
-
-          if (col_end > col_start) {
-            usize p = col_end;
-            while (true) {
-              --p;
-              usize i = zero_extend(Hi[p]);
-              if (i < j) {
-                break;
-              }
-              Hx[p] = delta_j * Hx[p] * delta(isize(i));
-
-              if (p <= col_start) {
-                break;
-              }
-            }
-          }
-        }
-        break;
-      }
-      case Symmetry::UPPER: {
-        for (usize j = 0; j < usize(n); ++j) {
-          usize col_start = qp.H.col_start(j);
-          usize col_end = qp.H.col_end(j);
-          T delta_j = delta(isize(j));
-
-          for (usize p = col_start; p < col_end; ++p) {
-            usize i = zero_extend(Hi[p]);
-            if (i > j) {
-              break;
-            }
-            Hx[p] = delta_j * Hx[p] * delta(isize(i));
-          }
-        }
-        break;
-      }
-    }
-
-    // normalize vectors
-    qp.g.to_eigen().array() *= delta.head(n).array();
-    qp.b.to_eigen().array() *= delta.segment(n, n_eq).array();
-    qp.l.to_eigen().array() *= delta.tail(n_in).array();
-    qp.u.to_eigen().array() *= delta.tail(n_in).array();
-
-    // additional normalization
-    auto _h_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
-    T* h_infty_norm = _h_infty_norm.ptr_mut();
-
-    switch (sym) {
-      case Symmetry::LOWER: {
-        detail::colwise_infty_norm_symlo(h_infty_norm, qp.H.as_const());
-        break;
-      }
-      case Symmetry::UPPER: {
-        detail::colwise_infty_norm_symhi(h_infty_norm, qp.H.as_const());
-        break;
-      }
-    }
-
-    T avg = 0;
-    for (isize i = 0; i < n; ++i) {
-      avg += h_infty_norm[i];
-    }
-    avg /= T(n);
-
-    gamma = 1 / std::max(avg, T(1));
-
-    qp.g.to_eigen() *= gamma;
-    qp.H.to_eigen() *= gamma;
-
-    S.array() *= delta.array();
-    c *= gamma;
-  }
-  return c;
-}
-} // namespace detail
-
-template<typename T, typename I>
-struct RuizEquilibration
-{
-  Vec<T> delta;
-  isize n;
-  T c;
-  T epsilon;
-  i64 max_iter;
-  Symmetry sym;
-
-  std::ostream* logger_ptr = nullptr;
-
-  RuizEquilibration(isize n_,
-                    isize n_eq_in,
-                    T epsilon_ = T(1e-3),
-                    i64 max_iter_ = 10,
-                    Symmetry sym_ = Symmetry::UPPER,
-                    std::ostream* logger = nullptr)
-    : delta(Vec<T>::Ones(n_ + n_eq_in))
-    , n(n_)
-    , c(1)
-    , epsilon(epsilon_)
-    , max_iter(max_iter_)
-    , sym(sym_)
-    , logger_ptr(logger)
-  {
-    delta.setOnes();
-  }
-
-  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> tag,
-                                    isize n,
-                                    isize n_eq,
-                                    isize n_in)
-    -> proxsuite::linalg::veg::dynstack::StackReq
-  {
-    return proxsuite::linalg::dense::temp_vec_req(tag, n + n_eq + n_in) &
-           proxsuite::linalg::veg::dynstack::StackReq::with_len(tag, 3 * n);
-  }
-
-  void scale_qp_in_place(QpViewMut<T, I> qp,
-                         bool execute_preconditioner,
-                         const isize max_iter,
-                         const T epsilon,
-                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
-  {
-    if (execute_preconditioner) {
-      delta.setOnes();
-      c = detail::ruiz_scale_qp_in_place( //
-        { proxqp::from_eigen, delta },
-        qp,
-        epsilon,
-        max_iter,
-        sym,
-        stack);
-    } else {
-      using proxsuite::linalg::sparse::util::zero_extend;
-      isize n = qp.H.nrows();
-      isize n_eq = qp.AT.ncols();
-      isize n_in = qp.CT.ncols();
-
-      I* Hi = qp.H.row_indices_mut();
-      T* Hx = qp.H.values_mut();
-
-      I* ATi = qp.AT.row_indices_mut();
-      T* ATx = qp.AT.values_mut();
-
-      I* CTi = qp.CT.row_indices_mut();
-      T* CTx = qp.CT.values_mut();
-
-      // normalize A
-      for (usize j = 0; j < usize(n_eq); ++j) {
-        usize col_start = qp.AT.col_start(j);
-        usize col_end = qp.AT.col_end(j);
-
-        T delta_j = delta(n + isize(j));
-
-        for (usize p = col_start; p < col_end; ++p) {
-          usize i = zero_extend(ATi[p]);
-          T& aji = ATx[p];
-          T delta_i = delta(isize(i));
-          aji = delta_i * (aji * delta_j);
-        }
-      }
-
-      // normalize C
-      for (usize j = 0; j < usize(n_in); ++j) {
-        usize col_start = qp.CT.col_start(j);
-        usize col_end = qp.CT.col_end(j);
-
-        T delta_j = delta(n + n_eq + isize(j));
-
-        for (usize p = col_start; p < col_end; ++p) {
-          usize i = zero_extend(CTi[p]);
-          T& cji = CTx[p];
-          T delta_i = delta(isize(i));
-          cji = delta_i * (cji * delta_j);
-        }
-      }
-
-      // normalize H
-      switch (sym) {
-        case Symmetry::LOWER: {
-          for (usize j = 0; j < usize(n); ++j) {
-            usize col_start = qp.H.col_start(j);
-            usize col_end = qp.H.col_end(j);
-            T delta_j = delta(isize(j));
-
-            if (col_end > col_start) {
-              usize p = col_end;
-              while (true) {
-                --p;
-                usize i = zero_extend(Hi[p]);
-                if (i < j) {
-                  break;
-                }
-                Hx[p] = delta_j * Hx[p] * delta(isize(i));
-
-                if (p <= col_start) {
-                  break;
-                }
-              }
-            }
-          }
-          break;
-        }
-        case Symmetry::UPPER: {
-          for (usize j = 0; j < usize(n); ++j) {
-            usize col_start = qp.H.col_start(j);
-            usize col_end = qp.H.col_end(j);
-            T delta_j = delta(isize(j));
-
-            for (usize p = col_start; p < col_end; ++p) {
-              usize i = zero_extend(Hi[p]);
-              if (i > j) {
-                break;
-              }
-              Hx[p] = delta_j * Hx[p] * delta(isize(i));
-            }
-          }
-          break;
-        }
-      }
-
-      // normalize vectors
-      qp.g.to_eigen().array() *= delta.head(n).array();
-      qp.b.to_eigen().array() *= delta.segment(n, n_eq).array();
-      qp.l.to_eigen().array() *= delta.tail(n_in).array();
-      qp.u.to_eigen().array() *= delta.tail(n_in).array();
-
-      qp.g.to_eigen() *= c;
-      qp.H.to_eigen() *= c;
-    }
-  }
-
-  // modifies variables in place
-  void scale_primal_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() /= delta.array().head(n);
-  }
-  void scale_dual_in_place(VectorViewMut<T> dual)
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
-                              delta.tail(delta.size() - n).array() * c;
-  }
-
-  void scale_dual_in_place_eq(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() =
-      dual.as_const().to_eigen().array() /
-      delta.middleRows(n, dual.to_eigen().size()).array() * c;
-  }
-  void scale_dual_in_place_in(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
-                              delta.tail(dual.to_eigen().size()).array() * c;
-  }
-
-  void unscale_primal_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() *= delta.array().head(n);
-  }
-  void unscale_dual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
-                              delta.tail(delta.size() - n).array() / c;
-  }
-
-  void unscale_dual_in_place_eq(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() =
-      dual.as_const().to_eigen().array() *
-      delta.middleRows(n, dual.to_eigen().size()).array() / c;
-  }
-
-  void unscale_dual_in_place_in(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
-                              delta.tail(dual.to_eigen().size()).array() / c;
-  }
-  // modifies residuals in place
-  void scale_primal_residual_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() *= delta.tail(delta.size() - n).array();
-  }
-
-  void scale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
-  {
-    primal_eq.to_eigen().array() *=
-      delta.middleRows(n, primal_eq.to_eigen().size()).array();
-  }
-  void scale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
-  {
-    primal_in.to_eigen().array() *=
-      delta.tail(primal_in.to_eigen().size()).array();
-  }
-  void scale_dual_residual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() *= delta.head(n).array() * c;
-  }
-  void unscale_primal_residual_in_place(VectorViewMut<T> primal) const
-  {
-    primal.to_eigen().array() /= delta.tail(delta.size() - n).array();
-  }
-  void unscale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
-  {
-    primal_eq.to_eigen().array() /=
-      delta.middleRows(n, primal_eq.to_eigen().size()).array();
-  }
-  void unscale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
-  {
-    primal_in.to_eigen().array() /=
-      delta.tail(primal_in.to_eigen().size()).array();
-  }
-  void unscale_dual_residual_in_place(VectorViewMut<T> dual) const
-  {
-    dual.to_eigen().array() /= delta.head(n).array() * c;
-  }
-};
-
-} // namespace preconditioner
-
-} // namespace sparse
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP
+#define PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP
+
+#include "proxsuite/proxqp/sparse/fwd.hpp"
+
+namespace proxsuite {
+namespace proxqp {
+namespace sparse {
+
+namespace preconditioner {
+enum struct Symmetry
+{
+  LOWER,
+  UPPER,
+};
+
+namespace detail {
+template<typename T, typename I>
+void
+rowwise_infty_norm(T* row_norm, proxsuite::linalg::sparse::MatRef<T, I> m)
+{
+  using namespace proxsuite::linalg::sparse::util;
+
+  I const* mi = m.row_indices();
+  T const* mx = m.values();
+
+  for (usize j = 0; j < usize(m.ncols()); ++j) {
+    auto col_start = m.col_start(j);
+    auto col_end = m.col_end(j);
+
+    for (usize p = col_start; p < col_end; ++p) {
+      usize i = zero_extend(mi[p]);
+      T mij = fabs(mx[p]);
+      row_norm[i] = std::max(row_norm[i], mij);
+    }
+  }
+}
+
+template<typename T, typename I>
+void
+colwise_infty_norm_symhi(T* col_norm, proxsuite::linalg::sparse::MatRef<T, I> h)
+{
+  using namespace proxsuite::linalg::sparse::util;
+
+  I const* hi = h.row_indices();
+  T const* hx = h.values();
+
+  for (usize j = 0; j < usize(h.ncols()); ++j) {
+    auto col_start = h.col_start(j);
+    auto col_end = h.col_end(j);
+
+    T norm_j = 0;
+
+    for (usize p = col_start; p < col_end; ++p) {
+      usize i = zero_extend(hi[p]);
+      if (i > j) {
+        break;
+      }
+
+      T hij = fabs(hx[p]);
+      norm_j = std::max(norm_j, hij);
+      col_norm[i] = std::max(col_norm[i], hij);
+    }
+
+    col_norm[j] = norm_j;
+  }
+}
+
+template<typename T, typename I>
+void
+colwise_infty_norm_symlo(T* col_norm, proxsuite::linalg::sparse::MatRef<T, I> h)
+{
+  using namespace proxsuite::linalg::sparse::util;
+
+  I const* hi = h.row_indices();
+  T const* hx = h.values();
+
+  for (usize j = 0; j < usize(h.ncols()); ++j) {
+    auto col_start = h.col_start(j);
+    auto col_end = h.col_end(j);
+
+    T norm_j = 0;
+
+    if (col_end > col_start) {
+      usize p = col_end;
+      while (true) {
+        --p;
+        usize i = zero_extend(hi[p]);
+        if (i < j) {
+          break;
+        }
+
+        T hij = fabs(hx[p]);
+        norm_j = std::max(norm_j, hij);
+        col_norm[i] = std::max(col_norm[i], hij);
+
+        if (p <= col_start) {
+          break;
+        }
+      }
+    }
+    col_norm[j] = std::max(col_norm[j], norm_j);
+  }
+}
+
+template<typename T, typename I>
+auto
+ruiz_scale_qp_in_place( //
+  VectorViewMut<T> delta_,
+  QpViewMut<T, I> qp,
+  T epsilon,
+  isize max_iter,
+  Symmetry sym,
+  proxsuite::linalg::veg::dynstack::DynStackMut stack) -> T
+{
+
+  T c = 1;
+  auto S = delta_.to_eigen();
+
+  isize n = qp.H.nrows();
+  isize n_eq = qp.AT.ncols();
+  isize n_in = qp.CT.ncols();
+
+  T gamma = 1;
+  i64 iter = 1;
+
+  LDLT_TEMP_VEC(T, delta, n + n_eq + n_in, stack);
+
+  I* Hi = qp.H.row_indices_mut();
+  T* Hx = qp.H.values_mut();
+
+  I* ATi = qp.AT.row_indices_mut();
+  T* ATx = qp.AT.values_mut();
+
+  I* CTi = qp.CT.row_indices_mut();
+  T* CTx = qp.CT.values_mut();
+
+  T const machine_eps = std::numeric_limits<T>::epsilon();
+
+  while (infty_norm((1 - delta.array()).matrix()) > epsilon) {
+    if (iter == max_iter) {
+      break;
+    } else {
+      ++iter;
+    }
+
+    // norm_infty of each column of A (resp. C), i.e.,
+    // each row of AT (resp. CT)
+    {
+      auto _a_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
+      auto _c_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
+      auto _h_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
+      T* a_infty_norm = _a_infty_norm.ptr_mut();
+      T* c_infty_norm = _c_infty_norm.ptr_mut();
+      T* h_infty_norm = _h_infty_norm.ptr_mut();
+
+      detail::rowwise_infty_norm(a_infty_norm, qp.AT.as_const());
+      detail::rowwise_infty_norm(c_infty_norm, qp.CT.as_const());
+      switch (sym) {
+        case Symmetry::LOWER: {
+          detail::colwise_infty_norm_symlo(h_infty_norm, qp.H.as_const());
+          break;
+        }
+        case Symmetry::UPPER: {
+          detail::colwise_infty_norm_symhi(h_infty_norm, qp.H.as_const());
+          break;
+        }
+      }
+
+      for (isize j = 0; j < n; ++j) {
+        delta(j) = T(1) / (machine_eps + sqrt(std::max({
+                                           h_infty_norm[j],
+                                           a_infty_norm[j],
+                                           c_infty_norm[j],
+                                         })));
+      }
+    }
+    using namespace proxsuite::linalg::sparse::util;
+    for (usize j = 0; j < usize(n_eq); ++j) {
+      T a_row_norm = 0;
+      qp.AT.to_eigen();
+      usize col_start = qp.AT.col_start(j);
+      usize col_end = qp.AT.col_end(j);
+
+      for (usize p = col_start; p < col_end; ++p) {
+        T aji = fabs(ATx[p]);
+        a_row_norm = std::max(a_row_norm, aji);
+      }
+
+      delta(n + isize(j)) = T(1) / (machine_eps + sqrt(a_row_norm));
+    }
+
+    for (usize j = 0; j < usize(n_in); ++j) {
+      T c_row_norm = 0;
+      usize col_start = qp.CT.col_start(j);
+      usize col_end = qp.CT.col_end(j);
+
+      for (usize p = col_start; p < col_end; ++p) {
+        T cji = fabs(CTx[p]);
+        c_row_norm = std::max(c_row_norm, cji);
+      }
+
+      delta(n + n_eq + isize(j)) = T(1) / (machine_eps + sqrt(c_row_norm));
+    }
+
+    // normalize A
+    for (usize j = 0; j < usize(n_eq); ++j) {
+      usize col_start = qp.AT.col_start(j);
+      usize col_end = qp.AT.col_end(j);
+
+      T delta_j = delta(n + isize(j));
+
+      for (usize p = col_start; p < col_end; ++p) {
+        usize i = zero_extend(ATi[p]);
+        T& aji = ATx[p];
+        T delta_i = delta(isize(i));
+        aji = delta_i * (aji * delta_j);
+      }
+    }
+
+    // normalize C
+    for (usize j = 0; j < usize(n_in); ++j) {
+      usize col_start = qp.CT.col_start(j);
+      usize col_end = qp.CT.col_end(j);
+
+      T delta_j = delta(n + n_eq + isize(j));
+
+      for (usize p = col_start; p < col_end; ++p) {
+        usize i = zero_extend(CTi[p]);
+        T& cji = CTx[p];
+        T delta_i = delta(isize(i));
+        cji = delta_i * (cji * delta_j);
+      }
+    }
+
+    // normalize H
+    switch (sym) {
+      case Symmetry::LOWER: {
+        for (usize j = 0; j < usize(n); ++j) {
+          usize col_start = qp.H.col_start(j);
+          usize col_end = qp.H.col_end(j);
+          T delta_j = delta(isize(j));
+
+          if (col_end > col_start) {
+            usize p = col_end;
+            while (true) {
+              --p;
+              usize i = zero_extend(Hi[p]);
+              if (i < j) {
+                break;
+              }
+              Hx[p] = delta_j * Hx[p] * delta(isize(i));
+
+              if (p <= col_start) {
+                break;
+              }
+            }
+          }
+        }
+        break;
+      }
+      case Symmetry::UPPER: {
+        for (usize j = 0; j < usize(n); ++j) {
+          usize col_start = qp.H.col_start(j);
+          usize col_end = qp.H.col_end(j);
+          T delta_j = delta(isize(j));
+
+          for (usize p = col_start; p < col_end; ++p) {
+            usize i = zero_extend(Hi[p]);
+            if (i > j) {
+              break;
+            }
+            Hx[p] = delta_j * Hx[p] * delta(isize(i));
+          }
+        }
+        break;
+      }
+    }
+
+    // normalize vectors
+    qp.g.to_eigen().array() *= delta.head(n).array();
+    qp.b.to_eigen().array() *= delta.segment(n, n_eq).array();
+    qp.l.to_eigen().array() *= delta.tail(n_in).array();
+    qp.u.to_eigen().array() *= delta.tail(n_in).array();
+
+    // additional normalization
+    auto _h_infty_norm = stack.make_new(proxsuite::linalg::veg::Tag<T>{}, n);
+    T* h_infty_norm = _h_infty_norm.ptr_mut();
+
+    switch (sym) {
+      case Symmetry::LOWER: {
+        detail::colwise_infty_norm_symlo(h_infty_norm, qp.H.as_const());
+        break;
+      }
+      case Symmetry::UPPER: {
+        detail::colwise_infty_norm_symhi(h_infty_norm, qp.H.as_const());
+        break;
+      }
+    }
+
+    T avg = 0;
+    for (isize i = 0; i < n; ++i) {
+      avg += h_infty_norm[i];
+    }
+    avg /= T(n);
+
+    gamma = 1 / std::max(avg, T(1));
+
+    qp.g.to_eigen() *= gamma;
+    qp.H.to_eigen() *= gamma;
+
+    S.array() *= delta.array();
+    c *= gamma;
+  }
+  return c;
+}
+} // namespace detail
+
+template<typename T, typename I>
+struct RuizEquilibration
+{
+  Vec<T> delta;
+  isize n;
+  T c;
+  T epsilon;
+  i64 max_iter;
+  Symmetry sym;
+
+  std::ostream* logger_ptr = nullptr;
+
+  RuizEquilibration(isize n_,
+                    isize n_eq_in,
+                    T epsilon_ = T(1e-3),
+                    i64 max_iter_ = 10,
+                    Symmetry sym_ = Symmetry::UPPER,
+                    std::ostream* logger = nullptr)
+    : delta(Vec<T>::Ones(n_ + n_eq_in))
+    , n(n_)
+    , c(1)
+    , epsilon(epsilon_)
+    , max_iter(max_iter_)
+    , sym(sym_)
+    , logger_ptr(logger)
+  {
+    delta.setOnes();
+  }
+
+  static auto scale_qp_in_place_req(proxsuite::linalg::veg::Tag<T> tag,
+                                    isize n,
+                                    isize n_eq,
+                                    isize n_in)
+    -> proxsuite::linalg::veg::dynstack::StackReq
+  {
+    return proxsuite::linalg::dense::temp_vec_req(tag, n + n_eq + n_in) &
+           proxsuite::linalg::veg::dynstack::StackReq::with_len(tag, 3 * n);
+  }
+
+  void scale_qp_in_place(QpViewMut<T, I> qp,
+                         bool execute_preconditioner,
+                         const isize max_iter,
+                         const T epsilon,
+                         proxsuite::linalg::veg::dynstack::DynStackMut stack)
+  {
+    if (execute_preconditioner) {
+      delta.setOnes();
+      c = detail::ruiz_scale_qp_in_place( //
+        { proxqp::from_eigen, delta },
+        qp,
+        epsilon,
+        max_iter,
+        sym,
+        stack);
+    } else {
+      using proxsuite::linalg::sparse::util::zero_extend;
+      isize n = qp.H.nrows();
+      isize n_eq = qp.AT.ncols();
+      isize n_in = qp.CT.ncols();
+
+      I* Hi = qp.H.row_indices_mut();
+      T* Hx = qp.H.values_mut();
+
+      I* ATi = qp.AT.row_indices_mut();
+      T* ATx = qp.AT.values_mut();
+
+      I* CTi = qp.CT.row_indices_mut();
+      T* CTx = qp.CT.values_mut();
+
+      // normalize A
+      for (usize j = 0; j < usize(n_eq); ++j) {
+        usize col_start = qp.AT.col_start(j);
+        usize col_end = qp.AT.col_end(j);
+
+        T delta_j = delta(n + isize(j));
+
+        for (usize p = col_start; p < col_end; ++p) {
+          usize i = zero_extend(ATi[p]);
+          T& aji = ATx[p];
+          T delta_i = delta(isize(i));
+          aji = delta_i * (aji * delta_j);
+        }
+      }
+
+      // normalize C
+      for (usize j = 0; j < usize(n_in); ++j) {
+        usize col_start = qp.CT.col_start(j);
+        usize col_end = qp.CT.col_end(j);
+
+        T delta_j = delta(n + n_eq + isize(j));
+
+        for (usize p = col_start; p < col_end; ++p) {
+          usize i = zero_extend(CTi[p]);
+          T& cji = CTx[p];
+          T delta_i = delta(isize(i));
+          cji = delta_i * (cji * delta_j);
+        }
+      }
+
+      // normalize H
+      switch (sym) {
+        case Symmetry::LOWER: {
+          for (usize j = 0; j < usize(n); ++j) {
+            usize col_start = qp.H.col_start(j);
+            usize col_end = qp.H.col_end(j);
+            T delta_j = delta(isize(j));
+
+            if (col_end > col_start) {
+              usize p = col_end;
+              while (true) {
+                --p;
+                usize i = zero_extend(Hi[p]);
+                if (i < j) {
+                  break;
+                }
+                Hx[p] = delta_j * Hx[p] * delta(isize(i));
+
+                if (p <= col_start) {
+                  break;
+                }
+              }
+            }
+          }
+          break;
+        }
+        case Symmetry::UPPER: {
+          for (usize j = 0; j < usize(n); ++j) {
+            usize col_start = qp.H.col_start(j);
+            usize col_end = qp.H.col_end(j);
+            T delta_j = delta(isize(j));
+
+            for (usize p = col_start; p < col_end; ++p) {
+              usize i = zero_extend(Hi[p]);
+              if (i > j) {
+                break;
+              }
+              Hx[p] = delta_j * Hx[p] * delta(isize(i));
+            }
+          }
+          break;
+        }
+      }
+
+      // normalize vectors
+      qp.g.to_eigen().array() *= delta.head(n).array();
+      qp.b.to_eigen().array() *= delta.segment(n, n_eq).array();
+      qp.l.to_eigen().array() *= delta.tail(n_in).array();
+      qp.u.to_eigen().array() *= delta.tail(n_in).array();
+
+      qp.g.to_eigen() *= c;
+      qp.H.to_eigen() *= c;
+    }
+  }
+
+  // modifies variables in place
+  void scale_primal_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() /= delta.array().head(n);
+  }
+  void scale_dual_in_place(VectorViewMut<T> dual)
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
+                              delta.tail(delta.size() - n).array() * c;
+  }
+
+  void scale_dual_in_place_eq(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() =
+      dual.as_const().to_eigen().array() /
+      delta.middleRows(n, dual.to_eigen().size()).array() * c;
+  }
+  void scale_dual_in_place_in(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() /
+                              delta.tail(dual.to_eigen().size()).array() * c;
+  }
+
+  void unscale_primal_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() *= delta.array().head(n);
+  }
+  void unscale_dual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
+                              delta.tail(delta.size() - n).array() / c;
+  }
+
+  void unscale_dual_in_place_eq(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() =
+      dual.as_const().to_eigen().array() *
+      delta.middleRows(n, dual.to_eigen().size()).array() / c;
+  }
+
+  void unscale_dual_in_place_in(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() = dual.as_const().to_eigen().array() *
+                              delta.tail(dual.to_eigen().size()).array() / c;
+  }
+  // modifies residuals in place
+  void scale_primal_residual_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() *= delta.tail(delta.size() - n).array();
+  }
+
+  void scale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
+  {
+    primal_eq.to_eigen().array() *=
+      delta.middleRows(n, primal_eq.to_eigen().size()).array();
+  }
+  void scale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
+  {
+    primal_in.to_eigen().array() *=
+      delta.tail(primal_in.to_eigen().size()).array();
+  }
+  void scale_dual_residual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() *= delta.head(n).array() * c;
+  }
+  void unscale_primal_residual_in_place(VectorViewMut<T> primal) const
+  {
+    primal.to_eigen().array() /= delta.tail(delta.size() - n).array();
+  }
+  void unscale_primal_residual_in_place_eq(VectorViewMut<T> primal_eq) const
+  {
+    primal_eq.to_eigen().array() /=
+      delta.middleRows(n, primal_eq.to_eigen().size()).array();
+  }
+  void unscale_primal_residual_in_place_in(VectorViewMut<T> primal_in) const
+  {
+    primal_in.to_eigen().array() /=
+      delta.tail(primal_in.to_eigen().size()).array();
+  }
+  void unscale_dual_residual_in_place(VectorViewMut<T> dual) const
+  {
+    dual.to_eigen().array() /= delta.head(n).array() * c;
+  }
+};
+
+} // namespace preconditioner
+
+} // namespace sparse
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_SPARSE_PRECOND_RUIZ_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/utils/prints.hpp

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/** \file */
-
-#ifndef PROXSUITE_PROXQP_UTILS_PRINTS_HPP
-#define PROXSUITE_PROXQP_UTILS_PRINTS_HPP
-
-#include <iostream>
-
-namespace proxsuite {
-namespace proxqp {
-
-inline void
-print_line()
-{
-  std::string the_line = "-----------------------------------------------------"
-                         "--------------------------------------------\0";
-  std::cout << the_line << "\n" << std::endl;
-}
-
-inline void
-print_header()
-{
-  std::cout << "iter    objective    pri res    dua res    mu_in  \n"
-            << std::endl;
-}
-
-inline void
-print_preambule()
-{
-  print_line();
-  std::cout
-    << "                              ProxQP - Primal-Dual Proximal QP "
-       "Solver\n"
-    << "     (c) Antoine Bambade, Sarah El Kazdadi, Fabian Schramm, Adrien "
-       "Taylor, and "
-       "Justin Carpentier\n"
-    << "                                         Inria Paris 2022        \n"
-    << std::endl;
-  print_line();
-}
-
-} // end namespace proxqp
-} // end namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_UTILS_PRINTS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/** \file */
+
+#ifndef PROXSUITE_PROXQP_UTILS_PRINTS_HPP
+#define PROXSUITE_PROXQP_UTILS_PRINTS_HPP
+
+#include <iostream>
+
+namespace proxsuite {
+namespace proxqp {
+
+inline void
+print_line()
+{
+  std::string the_line = "-----------------------------------------------------"
+                         "--------------------------------------------\0";
+  std::cout << the_line << "\n" << std::endl;
+}
+
+inline void
+print_header()
+{
+  std::cout << "iter    objective    pri res    dua res    mu_in  \n"
+            << std::endl;
+}
+
+inline void
+print_preambule()
+{
+  print_line();
+  std::cout
+    << "                              ProxQP - Primal-Dual Proximal QP "
+       "Solver\n"
+    << "     (c) Antoine Bambade, Sarah El Kazdadi, Fabian Schramm, Adrien "
+       "Taylor, and "
+       "Justin Carpentier\n"
+    << "                                         Inria Paris 2022        \n"
+    << std::endl;
+  print_line();
+}
+
+} // end namespace proxqp
+} // end namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_UTILS_PRINTS_HPP */
```

## cmeel.prefix/include/proxsuite/proxqp/utils/random_qp_problems.hpp

 * *Ordering differences only*

```diff
@@ -1,669 +1,669 @@
-#ifndef PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP
-#define PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP
-
-#include <Eigen/Core>
-#include <Eigen/SparseCore>
-#include <Eigen/Cholesky>
-#include <Eigen/Eigenvalues>
-#include <Eigen/QR>
-#include <utility>
-#include <proxsuite/proxqp/dense/views.hpp>
-#include <proxsuite/proxqp/dense/model.hpp>
-#include <proxsuite/proxqp/sparse/model.hpp>
-#include <map>
-#include <random>
-
-namespace proxsuite {
-namespace proxqp {
-namespace utils {
-
-using c_int = long long;
-using c_float = double;
-
-namespace proxqp = proxsuite::proxqp;
-
-template<typename T, proxqp::Layout L>
-using Mat =
-  Eigen::Matrix<T,
-                Eigen::Dynamic,
-                Eigen::Dynamic,
-                (L == proxqp::colmajor) ? Eigen::ColMajor : Eigen::RowMajor>;
-template<typename T>
-using Vec = Eigen::Matrix<T, Eigen::Dynamic, 1>;
-
-template<typename Scalar>
-using SparseMat = Eigen::SparseMatrix<Scalar, Eigen::ColMajor, c_int>;
-
-using namespace proxqp;
-namespace eigen {
-template<typename T>
-void
-llt_compute( //
-  Eigen::LLT<T>& out,
-  T const& mat)
-{
-  out.compute(mat);
-}
-template<typename T>
-void
-ldlt_compute( //
-  Eigen::LDLT<T>& out,
-  T const& mat)
-{
-  out.compute(mat);
-}
-LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f32, colmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f32, colmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f32, rowmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f32, rowmajor>>);
-
-LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f64, colmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f64, colmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f64, rowmajor>>);
-LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f64, rowmajor>>);
-} // namespace eigen
-namespace rand {
-
-using proxqp::u32;
-using proxqp::u64;
-
-#ifdef _MSC_VER
-/* Using the MSCV compiler on Windows causes problems because the type uint128
-is not available. Therefore, we use a random number generator from the stdlib
-instead of our custom Lehmer random number generator. The necessary lehmer
-functions used in in our code are remplaced with calls to the stdlib.*/
-std::mt19937 gen(1234);
-std::uniform_real_distribution<> uniform_dist(0.0, 1.0);
-std::normal_distribution<double> normal_dist;
-using u128 = u64;
-inline auto
-uniform_rand() -> double
-{
-  double output = double(uniform_dist(gen));
-  return output;
-}
-inline auto
-lehmer_global() -> u128&
-{
-  static u64 output = gen();
-  return output;
-}
-
-inline void
-set_seed(u64 seed)
-{
-  gen.seed(seed);
-}
-
-inline auto
-normal_rand() -> double
-{
-  return normal_dist(gen);
-}
-#else
-using u128 = __uint128_t;
-
-constexpr u128 lehmer64_constant(0xda942042e4dd58b5);
-inline auto
-lehmer_global() -> u128&
-{
-  static u128 g_lehmer64_state = lehmer64_constant * lehmer64_constant;
-  return g_lehmer64_state;
-}
-
-inline auto
-lehmer64() -> u64
-{ // [0, 2^64)
-  lehmer_global() *= lehmer64_constant;
-  return u64(lehmer_global() >> u128(64U));
-}
-
-inline void
-set_seed(u64 seed)
-{
-  lehmer_global() = u128(seed) + 1;
-  lehmer64();
-  lehmer64();
-}
-
-inline auto
-uniform_rand() -> double
-{ // [0, 2^53]
-  u64 a = lehmer64() / (1U << 11U);
-  return double(a) / double(u64(1) << 53U);
-}
-inline auto
-normal_rand() -> double
-{
-  static const double pi2 = std::atan(static_cast<double>(1)) * 8;
-
-  double u1 = uniform_rand();
-  double u2 = uniform_rand();
-
-  double ln = std::log(u1);
-  double sqrt = std::sqrt(-2 * ln);
-
-  return sqrt * std::cos(pi2 * u2);
-}
-#endif
-
-template<typename Scalar>
-auto
-vector_rand(isize nrows) -> Vec<Scalar>
-{
-  auto v = Vec<Scalar>(nrows);
-
-  for (isize i = 0; i < nrows; ++i) {
-    v(i) = Scalar(rand::normal_rand());
-  }
-
-  return v;
-}
-template<typename Scalar>
-auto
-matrix_rand(isize nrows, isize ncols) -> Mat<Scalar, colmajor>
-{
-  auto v = Mat<Scalar, colmajor>(nrows, ncols);
-
-  for (isize i = 0; i < nrows; ++i) {
-    for (isize j = 0; j < ncols; ++j) {
-      v(i, j) = Scalar(rand::normal_rand());
-    }
-  }
-
-  return v;
-}
-
-namespace detail {
-template<typename Scalar>
-auto
-orthonormal_rand_impl(isize n) -> Mat<Scalar, colmajor>
-{
-  auto mat = rand::matrix_rand<Scalar>(n, n);
-  auto qr = mat.householderQr();
-  Mat<Scalar, colmajor> q = qr.householderQ();
-  return q;
-}
-using Input = std::pair<u128, isize>;
-} // namespace detail
-
-template<typename Scalar>
-auto
-orthonormal_rand(isize n) -> Mat<Scalar, colmajor> const&
-{
-
-  static auto cache = std::map<detail::Input, Mat<Scalar, colmajor>>{};
-  auto input = detail::Input{ lehmer_global(), n };
-  auto it = cache.find(input);
-  if (it == cache.end()) {
-    auto res = cache.insert({
-      input,
-      detail::orthonormal_rand_impl<Scalar>(n),
-    });
-    it = res.first;
-  }
-  return (*it).second;
-}
-
-template<typename Scalar>
-auto
-positive_definite_rand(isize n, Scalar cond) -> Mat<Scalar, colmajor>
-{
-  auto const& q = rand::orthonormal_rand<Scalar>(n);
-  auto d = Vec<Scalar>(n);
-
-  {
-    using std::exp;
-    using std::log;
-    Scalar diff = log(cond);
-    for (isize i = 0; i < n; ++i) {
-      d(i) = exp(Scalar(i) / Scalar(n) * diff);
-    }
-  }
-
-  return q * d.asDiagonal() * q.transpose();
-}
-
-template<typename Scalar>
-auto
-sparse_positive_definite_rand(isize n, Scalar cond, Scalar p)
-  -> SparseMat<Scalar>
-{
-  auto H = SparseMat<Scalar>(n, n);
-
-  for (isize i = 0; i < n; ++i) {
-    auto random = Scalar(rand::normal_rand());
-    H.insert(i, i) = random;
-  }
-
-  for (isize i = 0; i < n; ++i) {
-    for (isize j = i + 1; j < n; ++j) {
-      auto urandom = rand::uniform_rand();
-      if (urandom < p / 2) {
-        auto random = Scalar(rand::normal_rand());
-        H.insert(i, j) = random;
-      }
-    }
-  }
-
-  Mat<Scalar, colmajor> H_dense = H.toDense();
-  Vec<Scalar> eigh =
-    H_dense.template selfadjointView<Eigen::Upper>().eigenvalues();
-
-  Scalar min = eigh.minCoeff();
-  Scalar max = eigh.maxCoeff();
-
-  // new_min = min + rho
-  // new_max = max + rho
-  //
-  // (max + rho)/(min + rho) = cond
-  // 1 + (max - min) / (min + rho) = cond
-  // (max - min) / (min + rho) = cond - 1
-  // min + rho = (max - min) / (cond - 1)
-  // rho = (max - min)/(cond - 1) - min
-  Scalar rho = (max - min) / (cond - 1) - min;
-  if (max == min) {
-    rho += 1;
-  }
-
-  for (isize i = 0; i < n; ++i) {
-    H.coeffRef(i, i) += rho;
-  }
-
-  H.makeCompressed();
-  return H;
-}
-
-template<typename Scalar>
-auto
-sparse_positive_definite_rand_compressed(isize n, Scalar rho, Scalar p)
-  -> SparseMat<Scalar>
-{
-  auto H = SparseMat<Scalar>(n, n);
-
-  H.setZero();
-
-  for (isize i = 0; i < n; ++i) {
-    for (isize j = i + 1; j < n; ++j) {
-      auto urandom = rand::uniform_rand();
-      if (urandom < p) {
-        auto random = Scalar(rand::normal_rand());
-        H.insert(i, j) = random;
-      }
-    }
-  }
-  Mat<Scalar, colmajor> H_dense = H.toDense();
-  Vec<Scalar> eigh =
-    H_dense.template selfadjointView<Eigen::Upper>().eigenvalues();
-  Scalar min = eigh.minCoeff();
-  for (isize i = 0; i < n; ++i) {
-    H.coeffRef(i, i) += (rho + abs(min));
-  }
-
-  H.makeCompressed();
-  return H;
-}
-
-template<typename Scalar>
-auto
-sparse_positive_definite_rand_not_compressed(isize n, Scalar rho, Scalar p)
-  -> Mat<Scalar, colmajor>
-{
-  auto H = Mat<Scalar, colmajor>(n, n);
-  H.setZero();
-
-  for (isize i = 0; i < n; ++i) {
-    for (isize j = 0; j < n; ++j) {
-      auto urandom = rand::uniform_rand();
-      if (urandom < p / 2) {
-        auto random = Scalar(rand::normal_rand());
-        H(i, j) = random;
-      }
-    }
-  }
-
-  H = ((H + H.transpose()) * 0.5)
-        .eval(); // safe no aliasing :
-                 // https://eigen.tuxfamily.org/dox/group__TopicAliasing.html
-  // H.array() /= 2.;
-  Vec<Scalar> eigh = H.template selfadjointView<Eigen::Upper>().eigenvalues();
-  Scalar min = eigh.minCoeff();
-  H.diagonal().array() += (rho + abs(min));
-
-  return H;
-}
-
-template<typename Scalar>
-auto
-sparse_matrix_rand(isize nrows, isize ncols, Scalar p) -> SparseMat<Scalar>
-{
-  auto A = SparseMat<Scalar>(nrows, ncols);
-
-  for (isize i = 0; i < nrows; ++i) {
-    for (isize j = 0; j < ncols; ++j) {
-      if (rand::uniform_rand() < p) {
-        A.insert(i, j) = Scalar(rand::normal_rand());
-      }
-    }
-  }
-  A.makeCompressed();
-  return A;
-}
-
-template<typename Scalar>
-auto
-sparse_matrix_rand_not_compressed(isize nrows, isize ncols, Scalar p)
-  -> Mat<Scalar, colmajor>
-{
-  auto A = Mat<Scalar, colmajor>(nrows, ncols);
-  A.setZero();
-  for (isize i = 0; i < nrows; ++i) {
-    for (isize j = 0; j < ncols; ++j) {
-      if (rand::uniform_rand() < p) {
-        A(i, j) = Scalar(rand::normal_rand());
-      }
-    }
-  }
-  return A;
-}
-
-} // namespace rand
-using proxqp::usize;
-
-namespace osqp {
-auto
-to_sparse(Mat<c_float, colmajor> const& mat) -> SparseMat<c_float>;
-auto
-to_sparse_sym(Mat<c_float, colmajor> const& mat) -> SparseMat<c_float>;
-} // namespace osqp
-
-template<typename T>
-auto
-matmul_impl( //
-  Mat<T, proxqp::colmajor> const& lhs,
-  Mat<T, proxqp::colmajor> const& rhs) -> Mat<T, proxqp::colmajor>
-{
-  return lhs.operator*(rhs);
-}
-template<typename To, typename From>
-auto
-mat_cast(Mat<From, proxqp::colmajor> const& from) -> Mat<To, proxqp::colmajor>
-{
-  return from.template cast<To>();
-}
-LDLT_EXPLICIT_TPL_DECL(2, matmul_impl<long double>);
-LDLT_EXPLICIT_TPL_DECL(1, mat_cast<proxqp::f64, long double>);
-LDLT_EXPLICIT_TPL_DECL(1, mat_cast<proxqp::f32, long double>);
-
-template<typename MatLhs, typename MatRhs, typename T = typename MatLhs::Scalar>
-auto
-matmul(MatLhs const& a, MatRhs const& b) -> Mat<T, proxqp::colmajor>
-{
-  using Upscaled = typename std::
-    conditional<std::is_floating_point<T>::value, long double, T>::type;
-
-  return mat_cast<T, Upscaled>(matmul_impl<Upscaled>(
-    Mat<T, proxqp::colmajor>(a).template cast<Upscaled>(),
-    Mat<T, proxqp::colmajor>(b).template cast<Upscaled>()));
-}
-
-template<typename MatLhs,
-         typename MatMid,
-         typename MatRhs,
-         typename T = typename MatLhs::Scalar>
-auto
-matmul3(MatLhs const& a, MatMid const& b, MatRhs const& c)
-  -> Mat<T, proxqp::colmajor>
-{
-  return matmul(matmul(a, b), c);
-}
-
-VEG_TAG(from_data, FromData);
-
-struct EigenNoAlloc
-{
-  EigenNoAlloc(EigenNoAlloc&&) = delete;
-  EigenNoAlloc(EigenNoAlloc const&) = delete;
-  auto operator=(EigenNoAlloc&&) -> EigenNoAlloc& = delete;
-  auto operator=(EigenNoAlloc const&) -> EigenNoAlloc& = delete;
-
-#if defined(EIGEN_RUNTIME_NO_MALLOC)
-  EigenNoAlloc() noexcept { Eigen::internal::set_is_malloc_allowed(false); }
-  ~EigenNoAlloc() noexcept { Eigen::internal::set_is_malloc_allowed(true); }
-#else
-  EigenNoAlloc() = default;
-#endif
-};
-
-template<typename Scalar>
-proxsuite::proxqp::dense::Model<Scalar>
-dense_unconstrained_qp(proxqp::isize dim,
-                       Scalar sparsity_factor,
-                       Scalar strong_convexity_factor = Scalar(1e-2))
-{
-
-  Mat<Scalar, colmajor> H =
-    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
-      dim, strong_convexity_factor, sparsity_factor);
-  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
-  Mat<Scalar, colmajor> A =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(0, dim, sparsity_factor);
-  Vec<Scalar> b = rand::vector_rand<Scalar>(0);
-  Mat<Scalar, colmajor> C =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(0, dim, sparsity_factor);
-  Vec<Scalar> u = rand::vector_rand<Scalar>(0);
-  Vec<Scalar> l = rand::vector_rand<Scalar>(0);
-  proxsuite::proxqp::dense::Model<Scalar> model(dim, 0, 0);
-  model.H = H;
-  model.g = g;
-  return model;
-}
-
-template<typename Scalar>
-proxsuite::proxqp::dense::Model<Scalar>
-dense_strongly_convex_qp(proxqp::isize dim,
-                         proxqp::isize n_eq,
-                         proxqp::isize n_in,
-                         Scalar sparsity_factor,
-                         Scalar strong_convexity_factor = Scalar(1e-2))
-{
-
-  Mat<Scalar, colmajor> H =
-    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
-      dim, strong_convexity_factor, sparsity_factor);
-  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
-  Mat<Scalar, colmajor> A =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
-  Mat<Scalar, colmajor> C =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
-
-  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
-  auto delta = Vec<Scalar>(n_in);
-
-  for (proxqp::isize i = 0; i < n_in; ++i) {
-    delta(i) = rand::uniform_rand();
-  }
-
-  Vec<Scalar> u = C * x_sol + delta;
-  Vec<Scalar> b = A * x_sol;
-  Vec<Scalar> l(n_in);
-  l.setZero();
-  l.array() -= 1.e20;
-
-  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
-  model.H = H;
-  model.g = g;
-  model.A = A;
-  model.b = b;
-  model.C = C;
-  model.u = u;
-  model.l = l;
-  return model;
-}
-
-template<typename Scalar>
-proxsuite::proxqp::dense::Model<Scalar>
-dense_not_strongly_convex_qp(proxqp::isize dim,
-                             proxqp::isize n_eq,
-                             proxqp::isize n_in,
-                             Scalar sparsity_factor)
-{
-
-  Mat<Scalar, colmajor> H =
-    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
-      dim, Scalar(0), sparsity_factor);
-  Mat<Scalar, colmajor> A =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
-  Mat<Scalar, colmajor> C =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
-
-  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
-  Vec<Scalar> y_sol = rand::vector_rand<Scalar>(n_eq);
-  Vec<Scalar> z_sol = rand::vector_rand<Scalar>(n_in);
-  auto delta = Vec<Scalar>(n_in);
-
-  for (proxqp::isize i = 0; i < n_in; ++i) {
-    delta(i) = rand::uniform_rand();
-  }
-  auto Cx = C * x_sol;
-  Vec<Scalar> u = Cx + delta;
-  Vec<Scalar> b = A * x_sol;
-  Vec<Scalar> l = Cx - delta;
-  Vec<Scalar> g = -(H * x_sol + C.transpose() * z_sol + A.transpose() * y_sol);
-
-  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
-  model.H = H;
-  model.g = g;
-  model.A = A;
-  model.b = b;
-  model.C = C;
-  model.u = u;
-  model.l = l;
-  return model;
-}
-
-template<typename Scalar>
-proxsuite::proxqp::dense::Model<Scalar>
-dense_degenerate_qp(proxqp::isize dim,
-                    proxqp::isize n_eq,
-                    proxqp::isize n_in,
-                    Scalar sparsity_factor,
-                    Scalar strong_convexity_factor = Scalar(1e-2))
-{
-
-  Mat<Scalar, colmajor> H =
-    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
-      dim, strong_convexity_factor, sparsity_factor);
-  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
-  Mat<Scalar, colmajor> A =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
-  Mat<Scalar, colmajor> C = Mat<Scalar, proxqp::colmajor>(2 * n_in, dim);
-
-  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
-  auto delta = Vec<Scalar>(2 * n_in);
-
-  for (proxqp::isize i = 0; i < 2 * n_in; ++i) {
-    delta(i) = rand::uniform_rand();
-  }
-  Vec<Scalar> b = A * x_sol;
-
-  auto C_ =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
-  C.setZero();
-  C.block(0, 0, n_in, dim) = C_;
-  C.block(n_in, 0, n_in, dim) = C_;
-  Vec<Scalar> u = C * x_sol + delta;
-  Vec<Scalar> l(2 * n_in);
-  l.setZero();
-  l.array() -= 1.e20;
-
-  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
-  model.H = H;
-  model.g = g;
-  model.A = A;
-  model.b = b;
-  model.C = C;
-  model.u = u;
-  model.l = l;
-  return model;
-}
-
-template<typename Scalar>
-proxsuite::proxqp::dense::Model<Scalar>
-dense_box_constrained_qp(proxqp::isize dim,
-                         proxqp::isize n_eq,
-                         proxqp::isize n_in,
-                         Scalar sparsity_factor,
-                         Scalar strong_convexity_factor = Scalar(1e-2))
-{
-
-  Mat<Scalar, colmajor> H =
-    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
-      dim, strong_convexity_factor, sparsity_factor);
-  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
-  Mat<Scalar, colmajor> A =
-    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
-  Mat<Scalar, colmajor> C = Mat<Scalar, proxqp::colmajor>(n_in, dim);
-
-  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
-  auto delta = Vec<Scalar>(n_in);
-
-  for (proxqp::isize i = 0; i < n_in; ++i) {
-    delta(i) = rand::uniform_rand();
-  }
-  Vec<Scalar> b = A * x_sol;
-  C.setZero();
-  C.diagonal().array() += 1;
-  Vec<Scalar> u = x_sol + delta;
-  Vec<Scalar> l = x_sol - delta;
-  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
-  model.H = H;
-  model.g = g;
-  model.A = A;
-  model.b = b;
-  model.C = C;
-  model.u = u;
-  model.l = l;
-  return model;
-}
-
-template<typename Scalar>
-proxsuite::proxqp::sparse::SparseModel<Scalar>
-sparse_strongly_convex_qp(proxqp::isize dim,
-                          proxqp::isize n_eq,
-                          proxqp::isize n_in,
-                          Scalar sparsity_factor,
-                          Scalar strong_convexity_factor = Scalar(1e-2))
-{
-
-  SparseMat<Scalar> H = rand::sparse_positive_definite_rand_compressed<Scalar>(
-    dim, strong_convexity_factor, sparsity_factor);
-  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
-  SparseMat<Scalar> A =
-    rand::sparse_matrix_rand<Scalar>(n_eq, dim, sparsity_factor);
-  SparseMat<Scalar> C =
-    rand::sparse_matrix_rand<Scalar>(n_in, dim, sparsity_factor);
-
-  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
-  auto delta = Vec<Scalar>(n_in);
-
-  for (proxqp::isize i = 0; i < n_in; ++i) {
-    delta(i) = rand::uniform_rand();
-  }
-
-  Vec<Scalar> u = C * x_sol + delta;
-  Vec<Scalar> b = A * x_sol;
-  Vec<Scalar> l(n_in);
-  l.setZero();
-  l.array() -= 1.e20;
-
-  proxsuite::proxqp::sparse::SparseModel<Scalar> res{ H, g, A, b, C, u, l };
-  return res;
-}
-
-} // namespace utils
-} // namespace proxqp
-} // namespace proxsuite
-
-#endif /* end of include guard PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP   \
-        */
+#ifndef PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP
+#define PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP
+
+#include <Eigen/Core>
+#include <Eigen/SparseCore>
+#include <Eigen/Cholesky>
+#include <Eigen/Eigenvalues>
+#include <Eigen/QR>
+#include <utility>
+#include <proxsuite/proxqp/dense/views.hpp>
+#include <proxsuite/proxqp/dense/model.hpp>
+#include <proxsuite/proxqp/sparse/model.hpp>
+#include <map>
+#include <random>
+
+namespace proxsuite {
+namespace proxqp {
+namespace utils {
+
+using c_int = long long;
+using c_float = double;
+
+namespace proxqp = proxsuite::proxqp;
+
+template<typename T, proxqp::Layout L>
+using Mat =
+  Eigen::Matrix<T,
+                Eigen::Dynamic,
+                Eigen::Dynamic,
+                (L == proxqp::colmajor) ? Eigen::ColMajor : Eigen::RowMajor>;
+template<typename T>
+using Vec = Eigen::Matrix<T, Eigen::Dynamic, 1>;
+
+template<typename Scalar>
+using SparseMat = Eigen::SparseMatrix<Scalar, Eigen::ColMajor, c_int>;
+
+using namespace proxqp;
+namespace eigen {
+template<typename T>
+void
+llt_compute( //
+  Eigen::LLT<T>& out,
+  T const& mat)
+{
+  out.compute(mat);
+}
+template<typename T>
+void
+ldlt_compute( //
+  Eigen::LDLT<T>& out,
+  T const& mat)
+{
+  out.compute(mat);
+}
+LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f32, colmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f32, colmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f32, rowmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f32, rowmajor>>);
+
+LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f64, colmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f64, colmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, llt_compute<Mat<f64, rowmajor>>);
+LDLT_EXPLICIT_TPL_DECL(2, ldlt_compute<Mat<f64, rowmajor>>);
+} // namespace eigen
+namespace rand {
+
+using proxqp::u32;
+using proxqp::u64;
+
+#ifdef _MSC_VER
+/* Using the MSCV compiler on Windows causes problems because the type uint128
+is not available. Therefore, we use a random number generator from the stdlib
+instead of our custom Lehmer random number generator. The necessary lehmer
+functions used in in our code are remplaced with calls to the stdlib.*/
+std::mt19937 gen(1234);
+std::uniform_real_distribution<> uniform_dist(0.0, 1.0);
+std::normal_distribution<double> normal_dist;
+using u128 = u64;
+inline auto
+uniform_rand() -> double
+{
+  double output = double(uniform_dist(gen));
+  return output;
+}
+inline auto
+lehmer_global() -> u128&
+{
+  static u64 output = gen();
+  return output;
+}
+
+inline void
+set_seed(u64 seed)
+{
+  gen.seed(seed);
+}
+
+inline auto
+normal_rand() -> double
+{
+  return normal_dist(gen);
+}
+#else
+using u128 = __uint128_t;
+
+constexpr u128 lehmer64_constant(0xda942042e4dd58b5);
+inline auto
+lehmer_global() -> u128&
+{
+  static u128 g_lehmer64_state = lehmer64_constant * lehmer64_constant;
+  return g_lehmer64_state;
+}
+
+inline auto
+lehmer64() -> u64
+{ // [0, 2^64)
+  lehmer_global() *= lehmer64_constant;
+  return u64(lehmer_global() >> u128(64U));
+}
+
+inline void
+set_seed(u64 seed)
+{
+  lehmer_global() = u128(seed) + 1;
+  lehmer64();
+  lehmer64();
+}
+
+inline auto
+uniform_rand() -> double
+{ // [0, 2^53]
+  u64 a = lehmer64() / (1U << 11U);
+  return double(a) / double(u64(1) << 53U);
+}
+inline auto
+normal_rand() -> double
+{
+  static const double pi2 = std::atan(static_cast<double>(1)) * 8;
+
+  double u1 = uniform_rand();
+  double u2 = uniform_rand();
+
+  double ln = std::log(u1);
+  double sqrt = std::sqrt(-2 * ln);
+
+  return sqrt * std::cos(pi2 * u2);
+}
+#endif
+
+template<typename Scalar>
+auto
+vector_rand(isize nrows) -> Vec<Scalar>
+{
+  auto v = Vec<Scalar>(nrows);
+
+  for (isize i = 0; i < nrows; ++i) {
+    v(i) = Scalar(rand::normal_rand());
+  }
+
+  return v;
+}
+template<typename Scalar>
+auto
+matrix_rand(isize nrows, isize ncols) -> Mat<Scalar, colmajor>
+{
+  auto v = Mat<Scalar, colmajor>(nrows, ncols);
+
+  for (isize i = 0; i < nrows; ++i) {
+    for (isize j = 0; j < ncols; ++j) {
+      v(i, j) = Scalar(rand::normal_rand());
+    }
+  }
+
+  return v;
+}
+
+namespace detail {
+template<typename Scalar>
+auto
+orthonormal_rand_impl(isize n) -> Mat<Scalar, colmajor>
+{
+  auto mat = rand::matrix_rand<Scalar>(n, n);
+  auto qr = mat.householderQr();
+  Mat<Scalar, colmajor> q = qr.householderQ();
+  return q;
+}
+using Input = std::pair<u128, isize>;
+} // namespace detail
+
+template<typename Scalar>
+auto
+orthonormal_rand(isize n) -> Mat<Scalar, colmajor> const&
+{
+
+  static auto cache = std::map<detail::Input, Mat<Scalar, colmajor>>{};
+  auto input = detail::Input{ lehmer_global(), n };
+  auto it = cache.find(input);
+  if (it == cache.end()) {
+    auto res = cache.insert({
+      input,
+      detail::orthonormal_rand_impl<Scalar>(n),
+    });
+    it = res.first;
+  }
+  return (*it).second;
+}
+
+template<typename Scalar>
+auto
+positive_definite_rand(isize n, Scalar cond) -> Mat<Scalar, colmajor>
+{
+  auto const& q = rand::orthonormal_rand<Scalar>(n);
+  auto d = Vec<Scalar>(n);
+
+  {
+    using std::exp;
+    using std::log;
+    Scalar diff = log(cond);
+    for (isize i = 0; i < n; ++i) {
+      d(i) = exp(Scalar(i) / Scalar(n) * diff);
+    }
+  }
+
+  return q * d.asDiagonal() * q.transpose();
+}
+
+template<typename Scalar>
+auto
+sparse_positive_definite_rand(isize n, Scalar cond, Scalar p)
+  -> SparseMat<Scalar>
+{
+  auto H = SparseMat<Scalar>(n, n);
+
+  for (isize i = 0; i < n; ++i) {
+    auto random = Scalar(rand::normal_rand());
+    H.insert(i, i) = random;
+  }
+
+  for (isize i = 0; i < n; ++i) {
+    for (isize j = i + 1; j < n; ++j) {
+      auto urandom = rand::uniform_rand();
+      if (urandom < p / 2) {
+        auto random = Scalar(rand::normal_rand());
+        H.insert(i, j) = random;
+      }
+    }
+  }
+
+  Mat<Scalar, colmajor> H_dense = H.toDense();
+  Vec<Scalar> eigh =
+    H_dense.template selfadjointView<Eigen::Upper>().eigenvalues();
+
+  Scalar min = eigh.minCoeff();
+  Scalar max = eigh.maxCoeff();
+
+  // new_min = min + rho
+  // new_max = max + rho
+  //
+  // (max + rho)/(min + rho) = cond
+  // 1 + (max - min) / (min + rho) = cond
+  // (max - min) / (min + rho) = cond - 1
+  // min + rho = (max - min) / (cond - 1)
+  // rho = (max - min)/(cond - 1) - min
+  Scalar rho = (max - min) / (cond - 1) - min;
+  if (max == min) {
+    rho += 1;
+  }
+
+  for (isize i = 0; i < n; ++i) {
+    H.coeffRef(i, i) += rho;
+  }
+
+  H.makeCompressed();
+  return H;
+}
+
+template<typename Scalar>
+auto
+sparse_positive_definite_rand_compressed(isize n, Scalar rho, Scalar p)
+  -> SparseMat<Scalar>
+{
+  auto H = SparseMat<Scalar>(n, n);
+
+  H.setZero();
+
+  for (isize i = 0; i < n; ++i) {
+    for (isize j = i + 1; j < n; ++j) {
+      auto urandom = rand::uniform_rand();
+      if (urandom < p) {
+        auto random = Scalar(rand::normal_rand());
+        H.insert(i, j) = random;
+      }
+    }
+  }
+  Mat<Scalar, colmajor> H_dense = H.toDense();
+  Vec<Scalar> eigh =
+    H_dense.template selfadjointView<Eigen::Upper>().eigenvalues();
+  Scalar min = eigh.minCoeff();
+  for (isize i = 0; i < n; ++i) {
+    H.coeffRef(i, i) += (rho + abs(min));
+  }
+
+  H.makeCompressed();
+  return H;
+}
+
+template<typename Scalar>
+auto
+sparse_positive_definite_rand_not_compressed(isize n, Scalar rho, Scalar p)
+  -> Mat<Scalar, colmajor>
+{
+  auto H = Mat<Scalar, colmajor>(n, n);
+  H.setZero();
+
+  for (isize i = 0; i < n; ++i) {
+    for (isize j = 0; j < n; ++j) {
+      auto urandom = rand::uniform_rand();
+      if (urandom < p / 2) {
+        auto random = Scalar(rand::normal_rand());
+        H(i, j) = random;
+      }
+    }
+  }
+
+  H = ((H + H.transpose()) * 0.5)
+        .eval(); // safe no aliasing :
+                 // https://eigen.tuxfamily.org/dox/group__TopicAliasing.html
+  // H.array() /= 2.;
+  Vec<Scalar> eigh = H.template selfadjointView<Eigen::Upper>().eigenvalues();
+  Scalar min = eigh.minCoeff();
+  H.diagonal().array() += (rho + abs(min));
+
+  return H;
+}
+
+template<typename Scalar>
+auto
+sparse_matrix_rand(isize nrows, isize ncols, Scalar p) -> SparseMat<Scalar>
+{
+  auto A = SparseMat<Scalar>(nrows, ncols);
+
+  for (isize i = 0; i < nrows; ++i) {
+    for (isize j = 0; j < ncols; ++j) {
+      if (rand::uniform_rand() < p) {
+        A.insert(i, j) = Scalar(rand::normal_rand());
+      }
+    }
+  }
+  A.makeCompressed();
+  return A;
+}
+
+template<typename Scalar>
+auto
+sparse_matrix_rand_not_compressed(isize nrows, isize ncols, Scalar p)
+  -> Mat<Scalar, colmajor>
+{
+  auto A = Mat<Scalar, colmajor>(nrows, ncols);
+  A.setZero();
+  for (isize i = 0; i < nrows; ++i) {
+    for (isize j = 0; j < ncols; ++j) {
+      if (rand::uniform_rand() < p) {
+        A(i, j) = Scalar(rand::normal_rand());
+      }
+    }
+  }
+  return A;
+}
+
+} // namespace rand
+using proxqp::usize;
+
+namespace osqp {
+auto
+to_sparse(Mat<c_float, colmajor> const& mat) -> SparseMat<c_float>;
+auto
+to_sparse_sym(Mat<c_float, colmajor> const& mat) -> SparseMat<c_float>;
+} // namespace osqp
+
+template<typename T>
+auto
+matmul_impl( //
+  Mat<T, proxqp::colmajor> const& lhs,
+  Mat<T, proxqp::colmajor> const& rhs) -> Mat<T, proxqp::colmajor>
+{
+  return lhs.operator*(rhs);
+}
+template<typename To, typename From>
+auto
+mat_cast(Mat<From, proxqp::colmajor> const& from) -> Mat<To, proxqp::colmajor>
+{
+  return from.template cast<To>();
+}
+LDLT_EXPLICIT_TPL_DECL(2, matmul_impl<long double>);
+LDLT_EXPLICIT_TPL_DECL(1, mat_cast<proxqp::f64, long double>);
+LDLT_EXPLICIT_TPL_DECL(1, mat_cast<proxqp::f32, long double>);
+
+template<typename MatLhs, typename MatRhs, typename T = typename MatLhs::Scalar>
+auto
+matmul(MatLhs const& a, MatRhs const& b) -> Mat<T, proxqp::colmajor>
+{
+  using Upscaled = typename std::
+    conditional<std::is_floating_point<T>::value, long double, T>::type;
+
+  return mat_cast<T, Upscaled>(matmul_impl<Upscaled>(
+    Mat<T, proxqp::colmajor>(a).template cast<Upscaled>(),
+    Mat<T, proxqp::colmajor>(b).template cast<Upscaled>()));
+}
+
+template<typename MatLhs,
+         typename MatMid,
+         typename MatRhs,
+         typename T = typename MatLhs::Scalar>
+auto
+matmul3(MatLhs const& a, MatMid const& b, MatRhs const& c)
+  -> Mat<T, proxqp::colmajor>
+{
+  return matmul(matmul(a, b), c);
+}
+
+VEG_TAG(from_data, FromData);
+
+struct EigenNoAlloc
+{
+  EigenNoAlloc(EigenNoAlloc&&) = delete;
+  EigenNoAlloc(EigenNoAlloc const&) = delete;
+  auto operator=(EigenNoAlloc&&) -> EigenNoAlloc& = delete;
+  auto operator=(EigenNoAlloc const&) -> EigenNoAlloc& = delete;
+
+#if defined(EIGEN_RUNTIME_NO_MALLOC)
+  EigenNoAlloc() noexcept { Eigen::internal::set_is_malloc_allowed(false); }
+  ~EigenNoAlloc() noexcept { Eigen::internal::set_is_malloc_allowed(true); }
+#else
+  EigenNoAlloc() = default;
+#endif
+};
+
+template<typename Scalar>
+proxsuite::proxqp::dense::Model<Scalar>
+dense_unconstrained_qp(proxqp::isize dim,
+                       Scalar sparsity_factor,
+                       Scalar strong_convexity_factor = Scalar(1e-2))
+{
+
+  Mat<Scalar, colmajor> H =
+    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
+      dim, strong_convexity_factor, sparsity_factor);
+  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
+  Mat<Scalar, colmajor> A =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(0, dim, sparsity_factor);
+  Vec<Scalar> b = rand::vector_rand<Scalar>(0);
+  Mat<Scalar, colmajor> C =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(0, dim, sparsity_factor);
+  Vec<Scalar> u = rand::vector_rand<Scalar>(0);
+  Vec<Scalar> l = rand::vector_rand<Scalar>(0);
+  proxsuite::proxqp::dense::Model<Scalar> model(dim, 0, 0);
+  model.H = H;
+  model.g = g;
+  return model;
+}
+
+template<typename Scalar>
+proxsuite::proxqp::dense::Model<Scalar>
+dense_strongly_convex_qp(proxqp::isize dim,
+                         proxqp::isize n_eq,
+                         proxqp::isize n_in,
+                         Scalar sparsity_factor,
+                         Scalar strong_convexity_factor = Scalar(1e-2))
+{
+
+  Mat<Scalar, colmajor> H =
+    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
+      dim, strong_convexity_factor, sparsity_factor);
+  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
+  Mat<Scalar, colmajor> A =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
+  Mat<Scalar, colmajor> C =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
+
+  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
+  auto delta = Vec<Scalar>(n_in);
+
+  for (proxqp::isize i = 0; i < n_in; ++i) {
+    delta(i) = rand::uniform_rand();
+  }
+
+  Vec<Scalar> u = C * x_sol + delta;
+  Vec<Scalar> b = A * x_sol;
+  Vec<Scalar> l(n_in);
+  l.setZero();
+  l.array() -= 1.e20;
+
+  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
+  model.H = H;
+  model.g = g;
+  model.A = A;
+  model.b = b;
+  model.C = C;
+  model.u = u;
+  model.l = l;
+  return model;
+}
+
+template<typename Scalar>
+proxsuite::proxqp::dense::Model<Scalar>
+dense_not_strongly_convex_qp(proxqp::isize dim,
+                             proxqp::isize n_eq,
+                             proxqp::isize n_in,
+                             Scalar sparsity_factor)
+{
+
+  Mat<Scalar, colmajor> H =
+    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
+      dim, Scalar(0), sparsity_factor);
+  Mat<Scalar, colmajor> A =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
+  Mat<Scalar, colmajor> C =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
+
+  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
+  Vec<Scalar> y_sol = rand::vector_rand<Scalar>(n_eq);
+  Vec<Scalar> z_sol = rand::vector_rand<Scalar>(n_in);
+  auto delta = Vec<Scalar>(n_in);
+
+  for (proxqp::isize i = 0; i < n_in; ++i) {
+    delta(i) = rand::uniform_rand();
+  }
+  auto Cx = C * x_sol;
+  Vec<Scalar> u = Cx + delta;
+  Vec<Scalar> b = A * x_sol;
+  Vec<Scalar> l = Cx - delta;
+  Vec<Scalar> g = -(H * x_sol + C.transpose() * z_sol + A.transpose() * y_sol);
+
+  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
+  model.H = H;
+  model.g = g;
+  model.A = A;
+  model.b = b;
+  model.C = C;
+  model.u = u;
+  model.l = l;
+  return model;
+}
+
+template<typename Scalar>
+proxsuite::proxqp::dense::Model<Scalar>
+dense_degenerate_qp(proxqp::isize dim,
+                    proxqp::isize n_eq,
+                    proxqp::isize n_in,
+                    Scalar sparsity_factor,
+                    Scalar strong_convexity_factor = Scalar(1e-2))
+{
+
+  Mat<Scalar, colmajor> H =
+    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
+      dim, strong_convexity_factor, sparsity_factor);
+  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
+  Mat<Scalar, colmajor> A =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
+  Mat<Scalar, colmajor> C = Mat<Scalar, proxqp::colmajor>(2 * n_in, dim);
+
+  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
+  auto delta = Vec<Scalar>(2 * n_in);
+
+  for (proxqp::isize i = 0; i < 2 * n_in; ++i) {
+    delta(i) = rand::uniform_rand();
+  }
+  Vec<Scalar> b = A * x_sol;
+
+  auto C_ =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_in, dim, sparsity_factor);
+  C.setZero();
+  C.block(0, 0, n_in, dim) = C_;
+  C.block(n_in, 0, n_in, dim) = C_;
+  Vec<Scalar> u = C * x_sol + delta;
+  Vec<Scalar> l(2 * n_in);
+  l.setZero();
+  l.array() -= 1.e20;
+
+  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
+  model.H = H;
+  model.g = g;
+  model.A = A;
+  model.b = b;
+  model.C = C;
+  model.u = u;
+  model.l = l;
+  return model;
+}
+
+template<typename Scalar>
+proxsuite::proxqp::dense::Model<Scalar>
+dense_box_constrained_qp(proxqp::isize dim,
+                         proxqp::isize n_eq,
+                         proxqp::isize n_in,
+                         Scalar sparsity_factor,
+                         Scalar strong_convexity_factor = Scalar(1e-2))
+{
+
+  Mat<Scalar, colmajor> H =
+    rand::sparse_positive_definite_rand_not_compressed<Scalar>(
+      dim, strong_convexity_factor, sparsity_factor);
+  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
+  Mat<Scalar, colmajor> A =
+    rand::sparse_matrix_rand_not_compressed<Scalar>(n_eq, dim, sparsity_factor);
+  Mat<Scalar, colmajor> C = Mat<Scalar, proxqp::colmajor>(n_in, dim);
+
+  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
+  auto delta = Vec<Scalar>(n_in);
+
+  for (proxqp::isize i = 0; i < n_in; ++i) {
+    delta(i) = rand::uniform_rand();
+  }
+  Vec<Scalar> b = A * x_sol;
+  C.setZero();
+  C.diagonal().array() += 1;
+  Vec<Scalar> u = x_sol + delta;
+  Vec<Scalar> l = x_sol - delta;
+  proxsuite::proxqp::dense::Model<Scalar> model(dim, n_eq, n_in);
+  model.H = H;
+  model.g = g;
+  model.A = A;
+  model.b = b;
+  model.C = C;
+  model.u = u;
+  model.l = l;
+  return model;
+}
+
+template<typename Scalar>
+proxsuite::proxqp::sparse::SparseModel<Scalar>
+sparse_strongly_convex_qp(proxqp::isize dim,
+                          proxqp::isize n_eq,
+                          proxqp::isize n_in,
+                          Scalar sparsity_factor,
+                          Scalar strong_convexity_factor = Scalar(1e-2))
+{
+
+  SparseMat<Scalar> H = rand::sparse_positive_definite_rand_compressed<Scalar>(
+    dim, strong_convexity_factor, sparsity_factor);
+  Vec<Scalar> g = rand::vector_rand<Scalar>(dim);
+  SparseMat<Scalar> A =
+    rand::sparse_matrix_rand<Scalar>(n_eq, dim, sparsity_factor);
+  SparseMat<Scalar> C =
+    rand::sparse_matrix_rand<Scalar>(n_in, dim, sparsity_factor);
+
+  Vec<Scalar> x_sol = rand::vector_rand<Scalar>(dim);
+  auto delta = Vec<Scalar>(n_in);
+
+  for (proxqp::isize i = 0; i < n_in; ++i) {
+    delta(i) = rand::uniform_rand();
+  }
+
+  Vec<Scalar> u = C * x_sol + delta;
+  Vec<Scalar> b = A * x_sol;
+  Vec<Scalar> l(n_in);
+  l.setZero();
+  l.array() -= 1.e20;
+
+  proxsuite::proxqp::sparse::SparseModel<Scalar> res{ H, g, A, b, C, u, l };
+  return res;
+}
+
+} // namespace utils
+} // namespace proxqp
+} // namespace proxsuite
+
+#endif /* end of include guard PROXSUITE_PROXQP_UTILS_RANDOM_QP_PROBLEMS_HPP   \
+        */
```

## cmeel.prefix/include/proxsuite/serialization/archive.hpp

 * *Ordering differences only*

```diff
@@ -1,231 +1,231 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file archive.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_ARCHIVE_HPP
-#define PROXSUITE_SERIALIZATION_ARCHIVE_HPP
-
-#include <fstream>
-#include <string>
-
-#include <cereal/cereal.hpp>
-#include <cereal/archives/binary.hpp>
-#include <cereal/archives/json.hpp>
-#include <cereal/archives/xml.hpp>
-
-namespace proxsuite {
-namespace serialization {
-
-///
-/// \brief Loads an object from a std::stringstream.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[out] object Object in which the loaded data are copied.
-/// \param[in]  is  string stream constaining the serialized content of the
-/// object.
-///
-template<typename T>
-inline void
-loadFromStringStream(T& object, std::istringstream& is)
-{
-  cereal::JSONInputArchive ia(is);
-  ia(object);
-}
-
-///
-/// \brief Saves an object inside a std::stringstream.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[in]   object Object in which the loaded data are copied.
-/// \param[out]  ss String stream constaining the serialized content of the
-/// object.
-///
-template<typename T>
-inline void
-saveToStringStream(const T& object, std::stringstream& ss)
-{
-  cereal::JSONOutputArchive oa(ss);
-  oa(object);
-}
-
-///
-/// \brief Loads an object from a std::string
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[out] object Object in which the loaded data are copied.
-/// \param[in]  str  string constaining the serialized content of the object.
-///
-template<typename T>
-inline void
-loadFromString(T& object, const std::string& str)
-{
-  std::istringstream is(str);
-  loadFromStringStream(object, is);
-}
-
-///
-/// \brief Saves an object inside a std::string
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[in] object Object in which the loaded data are copied.
-///
-/// \returns a string  constaining the serialized content of the object.
-///
-template<typename T>
-inline std::string
-saveToString(const T& object)
-{
-  std::stringstream ss;
-  saveToStringStream(object, ss);
-  return ss.str();
-}
-
-///
-/// \brief Loads an object from a binary file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[out] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-inline void
-loadFromBinary(T& object, const std::string& filename)
-{
-  std::ifstream ifs(filename.c_str(), std::ios::binary);
-  if (ifs) {
-    cereal::BinaryInputArchive ia(ifs);
-    ia(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-///
-/// \brief Saves an object inside a binary file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[in] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-void
-saveToBinary(const T& object, const std::string& filename)
-{
-  std::ofstream ofs(filename.c_str(), std::ios::binary);
-  if (ofs) {
-    cereal::BinaryOutputArchive oa(ofs);
-    oa(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-///
-/// \brief Loads an object from a JSON file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[out] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-inline void
-loadFromJSON(T& object, const std::string& filename)
-{
-  std::ifstream ifs(filename.c_str());
-  if (ifs) {
-    cereal::JSONInputArchive ia(ifs);
-    ia(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-///
-/// \brief Saves an object inside a JSON file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[in] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-void
-saveToJSON(const T& object, const std::string& filename)
-{
-  std::ofstream ofs(filename.c_str());
-  if (ofs) {
-    cereal::JSONOutputArchive oa(ofs);
-    oa(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-///
-/// \brief Loads an object from a XML file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[out] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-inline void
-loadFromXML(T& object, const std::string& filename)
-{
-  std::ifstream ifs(filename.c_str());
-  if (ifs) {
-    cereal::XMLInputArchive ia(ifs);
-    ia(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-///
-/// \brief Saves an object inside a XML file.
-///
-/// \tparam T Type of the object to deserialize.
-///
-/// \param[in] object Object in which the loaded data are copied.
-/// \param[in] filename Name of the file containing the serialized data.
-///
-template<typename T>
-void
-saveToXML(const T& object, const std::string& filename)
-{
-  std::ofstream ofs(filename.c_str());
-  if (ofs) {
-    cereal::XMLOutputArchive oa(ofs);
-    oa(object);
-  } else {
-    const std::string exception_message(filename +
-                                        " does not seem to be a valid file.");
-    throw std::invalid_argument(exception_message);
-  }
-}
-
-}
-}
-
-#endif /* end of include guard PROXSUITE_SERIALIZATION_ARCHIVE_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file archive.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_ARCHIVE_HPP
+#define PROXSUITE_SERIALIZATION_ARCHIVE_HPP
+
+#include <fstream>
+#include <string>
+
+#include <cereal/cereal.hpp>
+#include <cereal/archives/binary.hpp>
+#include <cereal/archives/json.hpp>
+#include <cereal/archives/xml.hpp>
+
+namespace proxsuite {
+namespace serialization {
+
+///
+/// \brief Loads an object from a std::stringstream.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[out] object Object in which the loaded data are copied.
+/// \param[in]  is  string stream constaining the serialized content of the
+/// object.
+///
+template<typename T>
+inline void
+loadFromStringStream(T& object, std::istringstream& is)
+{
+  cereal::JSONInputArchive ia(is);
+  ia(object);
+}
+
+///
+/// \brief Saves an object inside a std::stringstream.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[in]   object Object in which the loaded data are copied.
+/// \param[out]  ss String stream constaining the serialized content of the
+/// object.
+///
+template<typename T>
+inline void
+saveToStringStream(const T& object, std::stringstream& ss)
+{
+  cereal::JSONOutputArchive oa(ss);
+  oa(object);
+}
+
+///
+/// \brief Loads an object from a std::string
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[out] object Object in which the loaded data are copied.
+/// \param[in]  str  string constaining the serialized content of the object.
+///
+template<typename T>
+inline void
+loadFromString(T& object, const std::string& str)
+{
+  std::istringstream is(str);
+  loadFromStringStream(object, is);
+}
+
+///
+/// \brief Saves an object inside a std::string
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[in] object Object in which the loaded data are copied.
+///
+/// \returns a string  constaining the serialized content of the object.
+///
+template<typename T>
+inline std::string
+saveToString(const T& object)
+{
+  std::stringstream ss;
+  saveToStringStream(object, ss);
+  return ss.str();
+}
+
+///
+/// \brief Loads an object from a binary file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[out] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+inline void
+loadFromBinary(T& object, const std::string& filename)
+{
+  std::ifstream ifs(filename.c_str(), std::ios::binary);
+  if (ifs) {
+    cereal::BinaryInputArchive ia(ifs);
+    ia(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+///
+/// \brief Saves an object inside a binary file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[in] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+void
+saveToBinary(const T& object, const std::string& filename)
+{
+  std::ofstream ofs(filename.c_str(), std::ios::binary);
+  if (ofs) {
+    cereal::BinaryOutputArchive oa(ofs);
+    oa(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+///
+/// \brief Loads an object from a JSON file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[out] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+inline void
+loadFromJSON(T& object, const std::string& filename)
+{
+  std::ifstream ifs(filename.c_str());
+  if (ifs) {
+    cereal::JSONInputArchive ia(ifs);
+    ia(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+///
+/// \brief Saves an object inside a JSON file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[in] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+void
+saveToJSON(const T& object, const std::string& filename)
+{
+  std::ofstream ofs(filename.c_str());
+  if (ofs) {
+    cereal::JSONOutputArchive oa(ofs);
+    oa(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+///
+/// \brief Loads an object from a XML file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[out] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+inline void
+loadFromXML(T& object, const std::string& filename)
+{
+  std::ifstream ifs(filename.c_str());
+  if (ifs) {
+    cereal::XMLInputArchive ia(ifs);
+    ia(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+///
+/// \brief Saves an object inside a XML file.
+///
+/// \tparam T Type of the object to deserialize.
+///
+/// \param[in] object Object in which the loaded data are copied.
+/// \param[in] filename Name of the file containing the serialized data.
+///
+template<typename T>
+void
+saveToXML(const T& object, const std::string& filename)
+{
+  std::ofstream ofs(filename.c_str());
+  if (ofs) {
+    cereal::XMLOutputArchive oa(ofs);
+    oa(object);
+  } else {
+    const std::string exception_message(filename +
+                                        " does not seem to be a valid file.");
+    throw std::invalid_argument(exception_message);
+  }
+}
+
+}
+}
+
+#endif /* end of include guard PROXSUITE_SERIALIZATION_ARCHIVE_HPP */
```

## cmeel.prefix/include/proxsuite/serialization/eigen.hpp

 * *Ordering differences only*

```diff
@@ -1,107 +1,107 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file eigen.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_EIGEN_HPP
-#define PROXSUITE_SERIALIZATION_EIGEN_HPP
-
-#include <Eigen/Sparse>
-#include <Eigen/Dense>
-
-#include <cereal/cereal.hpp>
-
-namespace cereal {
-
-// dense matrices
-template<class Archive, class Derived>
-inline void
-save(Archive& ar, Eigen::PlainObjectBase<Derived> const& m)
-{
-  typedef Eigen::PlainObjectBase<Derived> PlainType;
-
-  Eigen::Index rows = m.rows();
-  Eigen::Index cols = m.cols();
-  ar(CEREAL_NVP(rows));
-  ar(CEREAL_NVP(cols));
-  bool is_row_major = PlainType::IsRowMajor;
-  ar(CEREAL_NVP(is_row_major));
-
-  for (Eigen::Index i = 0; i < m.size(); i++)
-    ar(m.data()[i]);
-}
-
-template<class Archive, class Derived>
-inline void
-load(Archive& ar, Eigen::PlainObjectBase<Derived>& m)
-{
-  typedef Eigen::PlainObjectBase<Derived> PlainType;
-
-  Eigen::Index rows;
-  Eigen::Index cols;
-  bool is_row_major;
-  ar(CEREAL_NVP(rows));
-  ar(CEREAL_NVP(cols));
-  ar(CEREAL_NVP(is_row_major));
-
-  m.resize(rows, cols);
-
-  for (Eigen::Index i = 0; i < m.size(); i++)
-    ar(m.data()[i]);
-
-  // Account for different storage orders
-  if (is_row_major != PlainType::IsRowMajor) {
-#if EIGEN_VERSION_AT_LEAST(3, 4, 0)
-    m.transposeInPlace();
-#else
-    m = m.transpose().eval();
-#endif
-  }
-}
-
-// sparse matrices
-template<class Archive, typename _Scalar, int _Options, typename _StorageIndex>
-inline void
-save(Archive& ar,
-     Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex> const& m)
-{
-  Eigen::Index innerSize = m.innerSize();
-  Eigen::Index outerSize = m.outerSize();
-  typedef typename Eigen::Triplet<_Scalar> Triplet;
-  std::vector<Triplet> triplets;
-
-  for (Eigen::Index i = 0; i < outerSize; ++i) {
-    for (typename Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex>::
-           InnerIterator it(m, i);
-         it;
-         ++it) {
-      triplets.push_back(Triplet(it.row(), it.col(), it.value()));
-    }
-  }
-  ar(innerSize);
-  ar(outerSize);
-  ar(triplets);
-}
-
-template<class Archive, typename _Scalar, int _Options, typename _StorageIndex>
-inline void
-load(Archive& ar, Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex>& m)
-{
-  Eigen::Index innerSize;
-  Eigen::Index outerSize;
-  ar(innerSize);
-  ar(outerSize);
-  Eigen::Index rows = m.IsRowMajor ? outerSize : innerSize;
-  Eigen::Index cols = m.IsRowMajor ? innerSize : outerSize;
-  m.resize(rows, cols);
-  typedef typename Eigen::Triplet<_Scalar> Triplet;
-  std::vector<Triplet> triplets;
-  ar(triplets);
-  m.setFromTriplets(triplets.begin(), triplets.end());
-}
-
-} // namespace cereal
-
-#endif /* end of include guard PROXSUITE_SERIALIZATION_EIGEN_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file eigen.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_EIGEN_HPP
+#define PROXSUITE_SERIALIZATION_EIGEN_HPP
+
+#include <Eigen/Sparse>
+#include <Eigen/Dense>
+
+#include <cereal/cereal.hpp>
+
+namespace cereal {
+
+// dense matrices
+template<class Archive, class Derived>
+inline void
+save(Archive& ar, Eigen::PlainObjectBase<Derived> const& m)
+{
+  typedef Eigen::PlainObjectBase<Derived> PlainType;
+
+  Eigen::Index rows = m.rows();
+  Eigen::Index cols = m.cols();
+  ar(CEREAL_NVP(rows));
+  ar(CEREAL_NVP(cols));
+  bool is_row_major = PlainType::IsRowMajor;
+  ar(CEREAL_NVP(is_row_major));
+
+  for (Eigen::Index i = 0; i < m.size(); i++)
+    ar(m.data()[i]);
+}
+
+template<class Archive, class Derived>
+inline void
+load(Archive& ar, Eigen::PlainObjectBase<Derived>& m)
+{
+  typedef Eigen::PlainObjectBase<Derived> PlainType;
+
+  Eigen::Index rows;
+  Eigen::Index cols;
+  bool is_row_major;
+  ar(CEREAL_NVP(rows));
+  ar(CEREAL_NVP(cols));
+  ar(CEREAL_NVP(is_row_major));
+
+  m.resize(rows, cols);
+
+  for (Eigen::Index i = 0; i < m.size(); i++)
+    ar(m.data()[i]);
+
+  // Account for different storage orders
+  if (is_row_major != PlainType::IsRowMajor) {
+#if EIGEN_VERSION_AT_LEAST(3, 4, 0)
+    m.transposeInPlace();
+#else
+    m = m.transpose().eval();
+#endif
+  }
+}
+
+// sparse matrices
+template<class Archive, typename _Scalar, int _Options, typename _StorageIndex>
+inline void
+save(Archive& ar,
+     Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex> const& m)
+{
+  Eigen::Index innerSize = m.innerSize();
+  Eigen::Index outerSize = m.outerSize();
+  typedef typename Eigen::Triplet<_Scalar> Triplet;
+  std::vector<Triplet> triplets;
+
+  for (Eigen::Index i = 0; i < outerSize; ++i) {
+    for (typename Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex>::
+           InnerIterator it(m, i);
+         it;
+         ++it) {
+      triplets.push_back(Triplet(it.row(), it.col(), it.value()));
+    }
+  }
+  ar(innerSize);
+  ar(outerSize);
+  ar(triplets);
+}
+
+template<class Archive, typename _Scalar, int _Options, typename _StorageIndex>
+inline void
+load(Archive& ar, Eigen::SparseMatrix<_Scalar, _Options, _StorageIndex>& m)
+{
+  Eigen::Index innerSize;
+  Eigen::Index outerSize;
+  ar(innerSize);
+  ar(outerSize);
+  Eigen::Index rows = m.IsRowMajor ? outerSize : innerSize;
+  Eigen::Index cols = m.IsRowMajor ? innerSize : outerSize;
+  m.resize(rows, cols);
+  typedef typename Eigen::Triplet<_Scalar> Triplet;
+  std::vector<Triplet> triplets;
+  ar(triplets);
+  m.setFromTriplets(triplets.begin(), triplets.end());
+}
+
+} // namespace cereal
+
+#endif /* end of include guard PROXSUITE_SERIALIZATION_EIGEN_HPP */
```

## cmeel.prefix/include/proxsuite/serialization/model.hpp

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file model.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_MODEL_HPP
-#define PROXSUITE_SERIALIZATION_MODEL_HPP
-
-#include <cereal/cereal.hpp>
-#include <proxsuite/proxqp/dense/model.hpp>
-
-namespace cereal {
-
-template<class Archive, typename T>
-void
-serialize(Archive& archive, proxsuite::proxqp::dense::Model<T>& model)
-{
-  archive(CEREAL_NVP(model.dim),
-          CEREAL_NVP(model.n_eq),
-          CEREAL_NVP(model.n_in),
-          CEREAL_NVP(model.n_total),
-          CEREAL_NVP(model.H),
-          CEREAL_NVP(model.g),
-          CEREAL_NVP(model.A),
-          CEREAL_NVP(model.b),
-          CEREAL_NVP(model.C),
-          CEREAL_NVP(model.l),
-          CEREAL_NVP(model.u));
-}
-} // namespace cereal
-
-#endif /* end of include guard PROXSUITE_SERIALIZATION_MODEL_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file model.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_MODEL_HPP
+#define PROXSUITE_SERIALIZATION_MODEL_HPP
+
+#include <cereal/cereal.hpp>
+#include <proxsuite/proxqp/dense/model.hpp>
+
+namespace cereal {
+
+template<class Archive, typename T>
+void
+serialize(Archive& archive, proxsuite::proxqp::dense::Model<T>& model)
+{
+  archive(CEREAL_NVP(model.dim),
+          CEREAL_NVP(model.n_eq),
+          CEREAL_NVP(model.n_in),
+          CEREAL_NVP(model.n_total),
+          CEREAL_NVP(model.H),
+          CEREAL_NVP(model.g),
+          CEREAL_NVP(model.A),
+          CEREAL_NVP(model.b),
+          CEREAL_NVP(model.C),
+          CEREAL_NVP(model.l),
+          CEREAL_NVP(model.u));
+}
+} // namespace cereal
+
+#endif /* end of include guard PROXSUITE_SERIALIZATION_MODEL_HPP */
```

## cmeel.prefix/include/proxsuite/serialization/results.hpp

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file results.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_RESULTS_HPP
-#define PROXSUITE_SERIALIZATION_RESULTS_HPP
-
-#include <cereal/cereal.hpp>
-#include <proxsuite/proxqp/results.hpp>
-
-namespace cereal {
-
-template<class Archive, typename T>
-void
-serialize(Archive& archive, proxsuite::proxqp::Info<T>& info)
-{
-  archive(CEREAL_NVP(info.mu_eq),
-          CEREAL_NVP(info.mu_eq_inv),
-          CEREAL_NVP(info.mu_in),
-          CEREAL_NVP(info.mu_in_inv),
-          CEREAL_NVP(info.rho),
-          CEREAL_NVP(info.nu),
-          CEREAL_NVP(info.iter),
-          CEREAL_NVP(info.iter_ext),
-          CEREAL_NVP(info.mu_updates),
-          CEREAL_NVP(info.rho_updates),
-          CEREAL_NVP(info.status),
-          CEREAL_NVP(info.setup_time),
-          CEREAL_NVP(info.solve_time),
-          CEREAL_NVP(info.run_time),
-          CEREAL_NVP(info.objValue),
-          CEREAL_NVP(info.pri_res),
-          CEREAL_NVP(info.dua_res),
-          CEREAL_NVP(info.duality_gap),
-          CEREAL_NVP(info.sparse_backend));
-}
-
-template<class Archive, typename T>
-void
-serialize(Archive& archive, proxsuite::proxqp::Results<T>& results)
-{
-  archive(CEREAL_NVP(results.x),
-          CEREAL_NVP(results.y),
-          CEREAL_NVP(results.z),
-          CEREAL_NVP(results.info));
-}
-
-template<class Archive>
-void
-save(Archive& ar, proxsuite::linalg::veg::Vec<bool> const& vec_bool)
-{
-  proxsuite::linalg::veg::isize len = vec_bool.len();
-  ar(CEREAL_NVP(len));
-  for (proxsuite::linalg::veg::isize i = 0; i < len; i++)
-    ar(vec_bool[i]);
-}
-
-template<class Archive>
-void
-load(Archive& ar, proxsuite::linalg::veg::Vec<bool>& vec_bool)
-{
-  proxsuite::linalg::veg::isize len;
-  ar(len);
-  vec_bool.reserve(len);
-  for (proxsuite::linalg::veg::isize i = 0; i < len; i++)
-    ar(vec_bool[i]);
-}
-
-} // namespace cereal
-
-#endif /* end of include guard PROXSUITE_SERIALIZATION_RESULTS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file results.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_RESULTS_HPP
+#define PROXSUITE_SERIALIZATION_RESULTS_HPP
+
+#include <cereal/cereal.hpp>
+#include <proxsuite/proxqp/results.hpp>
+
+namespace cereal {
+
+template<class Archive, typename T>
+void
+serialize(Archive& archive, proxsuite::proxqp::Info<T>& info)
+{
+  archive(CEREAL_NVP(info.mu_eq),
+          CEREAL_NVP(info.mu_eq_inv),
+          CEREAL_NVP(info.mu_in),
+          CEREAL_NVP(info.mu_in_inv),
+          CEREAL_NVP(info.rho),
+          CEREAL_NVP(info.nu),
+          CEREAL_NVP(info.iter),
+          CEREAL_NVP(info.iter_ext),
+          CEREAL_NVP(info.mu_updates),
+          CEREAL_NVP(info.rho_updates),
+          CEREAL_NVP(info.status),
+          CEREAL_NVP(info.setup_time),
+          CEREAL_NVP(info.solve_time),
+          CEREAL_NVP(info.run_time),
+          CEREAL_NVP(info.objValue),
+          CEREAL_NVP(info.pri_res),
+          CEREAL_NVP(info.dua_res),
+          CEREAL_NVP(info.duality_gap),
+          CEREAL_NVP(info.sparse_backend));
+}
+
+template<class Archive, typename T>
+void
+serialize(Archive& archive, proxsuite::proxqp::Results<T>& results)
+{
+  archive(CEREAL_NVP(results.x),
+          CEREAL_NVP(results.y),
+          CEREAL_NVP(results.z),
+          CEREAL_NVP(results.info));
+}
+
+template<class Archive>
+void
+save(Archive& ar, proxsuite::linalg::veg::Vec<bool> const& vec_bool)
+{
+  proxsuite::linalg::veg::isize len = vec_bool.len();
+  ar(CEREAL_NVP(len));
+  for (proxsuite::linalg::veg::isize i = 0; i < len; i++)
+    ar(vec_bool[i]);
+}
+
+template<class Archive>
+void
+load(Archive& ar, proxsuite::linalg::veg::Vec<bool>& vec_bool)
+{
+  proxsuite::linalg::veg::isize len;
+  ar(len);
+  vec_bool.reserve(len);
+  for (proxsuite::linalg::veg::isize i = 0; i < len; i++)
+    ar(vec_bool[i]);
+}
+
+} // namespace cereal
+
+#endif /* end of include guard PROXSUITE_SERIALIZATION_RESULTS_HPP */
```

## cmeel.prefix/include/proxsuite/serialization/settings.hpp

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file settings.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_SETTINGS_HPP
-#define PROXSUITE_SERIALIZATION_SETTINGS_HPP
-
-#include <cereal/cereal.hpp>
-#include <proxsuite/proxqp/settings.hpp>
-
-namespace cereal {
-
-template<class Archive, typename T>
-void
-serialize(Archive& archive, proxsuite::proxqp::Settings<T>& settings)
-{
-  archive(CEREAL_NVP(settings.default_rho),
-          CEREAL_NVP(settings.default_mu_eq),
-          CEREAL_NVP(settings.default_mu_in),
-          CEREAL_NVP(settings.alpha_bcl),
-          CEREAL_NVP(settings.beta_bcl),
-          CEREAL_NVP(settings.refactor_dual_feasibility_threshold),
-          CEREAL_NVP(settings.refactor_rho_threshold),
-          CEREAL_NVP(settings.mu_min_eq),
-          CEREAL_NVP(settings.mu_min_in),
-          CEREAL_NVP(settings.mu_max_eq_inv),
-          CEREAL_NVP(settings.mu_update_factor),
-          CEREAL_NVP(settings.mu_update_inv_factor),
-          CEREAL_NVP(settings.cold_reset_mu_eq),
-          CEREAL_NVP(settings.cold_reset_mu_in),
-          CEREAL_NVP(settings.cold_reset_mu_eq_inv),
-          CEREAL_NVP(settings.cold_reset_mu_in_inv),
-          CEREAL_NVP(settings.eps_abs),
-          CEREAL_NVP(settings.eps_rel),
-          CEREAL_NVP(settings.max_iter),
-          CEREAL_NVP(settings.max_iter_in),
-          CEREAL_NVP(settings.safe_guard),
-          CEREAL_NVP(settings.nb_iterative_refinement),
-          CEREAL_NVP(settings.eps_refact),
-          CEREAL_NVP(settings.verbose),
-          CEREAL_NVP(settings.initial_guess),
-          CEREAL_NVP(settings.update_preconditioner),
-          CEREAL_NVP(settings.compute_preconditioner),
-          CEREAL_NVP(settings.compute_timings),
-          CEREAL_NVP(settings.check_duality_gap),
-          CEREAL_NVP(settings.eps_duality_gap_abs),
-          CEREAL_NVP(settings.eps_duality_gap_rel),
-          CEREAL_NVP(settings.preconditioner_max_iter),
-          CEREAL_NVP(settings.preconditioner_accuracy),
-          CEREAL_NVP(settings.eps_primal_inf),
-          CEREAL_NVP(settings.eps_dual_inf),
-          CEREAL_NVP(settings.bcl_update),
-          CEREAL_NVP(settings.sparse_backend));
-}
-} // namespace cereal
-
-#endif /* end of include guard PROXSUITE_SERIALIZATION_SETTINGS_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file settings.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_SETTINGS_HPP
+#define PROXSUITE_SERIALIZATION_SETTINGS_HPP
+
+#include <cereal/cereal.hpp>
+#include <proxsuite/proxqp/settings.hpp>
+
+namespace cereal {
+
+template<class Archive, typename T>
+void
+serialize(Archive& archive, proxsuite::proxqp::Settings<T>& settings)
+{
+  archive(CEREAL_NVP(settings.default_rho),
+          CEREAL_NVP(settings.default_mu_eq),
+          CEREAL_NVP(settings.default_mu_in),
+          CEREAL_NVP(settings.alpha_bcl),
+          CEREAL_NVP(settings.beta_bcl),
+          CEREAL_NVP(settings.refactor_dual_feasibility_threshold),
+          CEREAL_NVP(settings.refactor_rho_threshold),
+          CEREAL_NVP(settings.mu_min_eq),
+          CEREAL_NVP(settings.mu_min_in),
+          CEREAL_NVP(settings.mu_max_eq_inv),
+          CEREAL_NVP(settings.mu_update_factor),
+          CEREAL_NVP(settings.mu_update_inv_factor),
+          CEREAL_NVP(settings.cold_reset_mu_eq),
+          CEREAL_NVP(settings.cold_reset_mu_in),
+          CEREAL_NVP(settings.cold_reset_mu_eq_inv),
+          CEREAL_NVP(settings.cold_reset_mu_in_inv),
+          CEREAL_NVP(settings.eps_abs),
+          CEREAL_NVP(settings.eps_rel),
+          CEREAL_NVP(settings.max_iter),
+          CEREAL_NVP(settings.max_iter_in),
+          CEREAL_NVP(settings.safe_guard),
+          CEREAL_NVP(settings.nb_iterative_refinement),
+          CEREAL_NVP(settings.eps_refact),
+          CEREAL_NVP(settings.verbose),
+          CEREAL_NVP(settings.initial_guess),
+          CEREAL_NVP(settings.update_preconditioner),
+          CEREAL_NVP(settings.compute_preconditioner),
+          CEREAL_NVP(settings.compute_timings),
+          CEREAL_NVP(settings.check_duality_gap),
+          CEREAL_NVP(settings.eps_duality_gap_abs),
+          CEREAL_NVP(settings.eps_duality_gap_rel),
+          CEREAL_NVP(settings.preconditioner_max_iter),
+          CEREAL_NVP(settings.preconditioner_accuracy),
+          CEREAL_NVP(settings.eps_primal_inf),
+          CEREAL_NVP(settings.eps_dual_inf),
+          CEREAL_NVP(settings.bcl_update),
+          CEREAL_NVP(settings.sparse_backend));
+}
+} // namespace cereal
+
+#endif /* end of include guard PROXSUITE_SERIALIZATION_SETTINGS_HPP */
```

## cmeel.prefix/include/proxsuite/serialization/wrapper.hpp

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-//
-// Copyright (c) 2022 INRIA
-//
-/**
- * @file wrapper.hpp
- */
-
-#ifndef PROXSUITE_SERIALIZATION_WRAPPER_HPP
-#define PROXSUITE_SERIALIZATION_WRAPPER_HPP
-
-#include <cereal/cereal.hpp>
-#include <proxsuite/proxqp/dense/wrapper.hpp>
-
-namespace cereal {
-
-template<class Archive, typename T>
-void
-serialize(Archive& archive, proxsuite::proxqp::dense::QP<T>& qp)
-{
-  archive(
-    CEREAL_NVP(qp.model), CEREAL_NVP(qp.results), CEREAL_NVP(qp.settings));
-}
-} // namespace cereal
-#endif /* end of include guard PROXSUITE_SERIALIZATION_WRAPPER_HPP */
+//
+// Copyright (c) 2022 INRIA
+//
+/**
+ * @file wrapper.hpp
+ */
+
+#ifndef PROXSUITE_SERIALIZATION_WRAPPER_HPP
+#define PROXSUITE_SERIALIZATION_WRAPPER_HPP
+
+#include <cereal/cereal.hpp>
+#include <proxsuite/proxqp/dense/wrapper.hpp>
+
+namespace cereal {
+
+template<class Archive, typename T>
+void
+serialize(Archive& archive, proxsuite::proxqp::dense::QP<T>& qp)
+{
+  archive(
+    CEREAL_NVP(qp.model), CEREAL_NVP(qp.results), CEREAL_NVP(qp.settings));
+}
+} // namespace cereal
+#endif /* end of include guard PROXSUITE_SERIALIZATION_WRAPPER_HPP */
```

## cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-
-####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() #######
-####### Any changes to this file will be overwritten by the next CMake run ####
-####### The input file was Config.cmake.in                            ########
-
-get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../../../" ABSOLUTE)
-
-macro(set_and_check _var _file)
-  set(${_var} "${_file}")
-  if(NOT EXISTS "${_file}")
-    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
-  endif()
-endmacro()
-
-macro(check_required_components _NAME)
-  foreach(comp ${${_NAME}_FIND_COMPONENTS})
-    if(NOT ${_NAME}_${comp}_FOUND)
-      if(${_NAME}_FIND_REQUIRED_${comp})
-        set(${_NAME}_FOUND FALSE)
-      endif()
-    endif()
-  endforeach()
-endmacro()
-
-####################################################################################
-
-set(skip_this_file TRUE)
-if(NOT proxsuite_FOUND)
-  set(skip_this_file FALSE)
-endif()
-if(skip_this_file)
-  foreach(component ${proxsuite_FIND_COMPONENTS})
-    if(NOT "proxsuite_${component}_FOUND")
-      set(skip_this_file FALSE)
-    endif()
-  endforeach()
-endif()
-if(skip_this_file)
-  return()
-endif()
-
-set("proxsuite_INCLUDE_DIRS" "${PACKAGE_PREFIX_DIR}/include")
-set("PROXSUITE_INCLUDE_DIRS" "${PACKAGE_PREFIX_DIR}/include")
-set("proxsuite_DOXYGENDOCDIR" "${PACKAGE_PREFIX_DIR}/share/doc/proxsuite/doxygen-html")
-set("PROXSUITE_DOXYGENDOCDIR" "${PACKAGE_PREFIX_DIR}/share/doc/proxsuite/doxygen-html")
-set("proxsuite_DEPENDENCIES" "Eigen3;Simde")
-set("proxsuite_PKG_CONFIG_DEPENDENCIES" "")
-
-set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} 
- ${PACKAGE_PREFIX_DIR}/lib/cmake/proxsuite/find-external/Simde)
-
-# Find absolute library paths for all _PKG_CONFIG_LIBS as CMake expects full paths, while pkg-config does not.
-set(_PACKAGE_CONFIG_LIBRARIES "")
-set("_proxsuite_PKG_CONFIG_LIBDIR" "${pcfiledir}/../../lib")
-set("_proxsuite_PKG_CONFIG_LIBS_LIST" "")
-if(_proxsuite_PKG_CONFIG_LIBS_LIST)
-  string(FIND ${_proxsuite_PKG_CONFIG_LIBS_LIST} ", " _is_comma_space)
-  while(_is_comma_space GREATER -1)
-    string(REPLACE ", " "," _proxsuite_PKG_CONFIG_LIBS_LIST "${_proxsuite_PKG_CONFIG_LIBS_LIST}")
-    string(FIND ${_proxsuite_PKG_CONFIG_LIBS_LIST} ", " _is_comma_space)
-  endwhile()
-  string(REPLACE " " ";" _proxsuite_PKG_CONFIG_LIBS_LIST "${_proxsuite_PKG_CONFIG_LIBS_LIST}")
-  set(LIBDIR_HINTS ${_proxsuite_PKG_CONFIG_LIBDIR})
-  foreach(component ${_proxsuite_PKG_CONFIG_LIBS_LIST})
-    string(STRIP ${component} component)
-    # If the component is a link directory ("-L/full/path"), append to LIBDIR_HINTS.
-    string(FIND ${component} "-L" _is_library_dir)
-    if(${_is_library_dir} EQUAL 0)
-      string(REGEX REPLACE "^-L" "" lib_path ${component})
-      list(APPEND LIBDIR_HINTS "${lib_path}")
-      continue()
-    endif()
-    # If the component is a library name
-    string(FIND ${component} "-l" _is_library_name)
-    if(${_is_library_name} EQUAL 0)
-      string(REGEX REPLACE "^-l" "" lib ${component})
-      find_library(abs_lib_${lib} ${lib} HINTS ${LIBDIR_HINTS})
-      if(NOT abs_lib_${lib})
-        IF(_LIBDIR_HINTS)
-          message(STATUS "${lib} searched on ${_LIBDIR_HINTS} not FOUND.")
-        ELSE()
-          message(STATUS "${lib} not FOUND.")
-        ENDIF()
-      else()
-        IF(_LIBDIR_HINTS)
-          message(STATUS "${lib} searched on ${_LIBDIR_HINTS} FOUND. ${lib} at ${abs_lib_${lib}}")
-        ELSE()
-          message(STATUS "${lib} FOUND. ${lib} at ${abs_lib_${lib}}")
-        ENDIF()
-        list(APPEND _PACKAGE_CONFIG_LIBRARIES "${abs_lib_${lib}}")
-      endif()
-      unset(abs_lib_${lib} CACHE)
-      continue()
-    endif()
-    # If the component contains a collection of additional arguments
-    string(FIND ${component} "," _is_collection)
-    if(${_is_collection} GREATER -1)
-      string(REPLACE "," ";" component_list "${component}")
-      list(GET component_list -1 lib_info)
-      set(options ${component})
-      list(REMOVE_AT options -1)
-      string(FIND ${lib_info} "-l" _is_library_name)
-      if(${_is_library_name} GREATER -1)
-        string(REGEX REPLACE "^-l" "" lib ${lib_info})
-        find_library(abs_lib_${lib} ${lib} HINTS ${LIBDIR_HINTS})
-        if(NOT abs_lib_${lib})
-          IF(_LIBDIR_HINTS)
-            message(STATUS "${lib} searched on ${_LIBDIR_HINTS} not FOUND.")
-          ELSE()
-            message(STATUS "${lib} not FOUND.")
-          ENDIF()
-        else()
-          IF(_LIBDIR_HINTS)
-            message(STATUS "${lib} searched on ${_LIBDIR_HINTS} FOUND. ${lib} at ${abs_lib_${lib}}")
-          ELSE()
-            message(STATUS "${lib} FOUND. ${lib} at ${abs_lib_${lib}}")
-          ENDIF()
-          list(APPEND _PACKAGE_CONFIG_LIBRARIES "${abs_lib_${lib}}")
-        endif()
-        unset(abs_lib_${lib} CACHE)
-        continue()
-      else() # This is an absolute lib
-        list(APPEND _PACKAGE_CONFIG_LIBRARIES "${component}")
-      endif()
-      continue()
-    endif()
-    # Else, this is just an absolute lib
-    if(EXISTS "${component}")
-      list(APPEND _PACKAGE_CONFIG_LIBRARIES "${component}")
-    endif()
-  endforeach()
-endif(_proxsuite_PKG_CONFIG_LIBS_LIST)
-
-set("proxsuite_LIBRARIES" ${_PACKAGE_CONFIG_LIBRARIES})
-set("PROXSUITE_LIBRARIES" ${_PACKAGE_CONFIG_LIBRARIES})
-
-
-
-
-
-include(CMakeFindDependencyMacro)
-if(${CMAKE_VERSION} VERSION_LESS "3.15.0")
-  find_package(Eigen3 REQUIRED)
-  find_package(Simde REQUIRED)
-else()
-  find_dependency(Eigen3 REQUIRED)
-  find_dependency(Simde REQUIRED)
-endif()
-
-IF(COMMAND ADD_REQUIRED_DEPENDENCY)
-  FOREACH(pkgcfg_dep ${proxsuite_PKG_CONFIG_DEPENDENCIES})
-    # Avoid duplicated lookup.
-    LIST (FIND $_PKG_CONFIG_REQUIRES "${pkgcfg_dep}" _index)
-    IF(${_index} EQUAL -1)
-      ADD_REQUIRED_DEPENDENCY(${pkgcfg_dep})
-    ENDIF()
-  ENDFOREACH()
-ENDIF(COMMAND ADD_REQUIRED_DEPENDENCY)
-
-include("${CMAKE_CURRENT_LIST_DIR}/proxsuiteTargets.cmake")
-
-foreach(component ${proxsuite_FIND_COMPONENTS})
-  set(comp_file "${CMAKE_CURRENT_LIST_DIR}/${component}Config.cmake")
-  if(EXISTS ${comp_file})
-    include(${comp_file})
-  else()
-    set(proxsuite_${component}_FOUND FALSE)
-  endif()
-  if(proxsuite_${component}_FOUND)
-    message(STATUS "proxsuite: ${component} found.")
-  else()
-    message(STATUS "proxsuite: ${component} not found.")
-  endif()
-endforeach()
-check_required_components("proxsuite")
-
-
+
+####### Expanded from @PACKAGE_INIT@ by configure_package_config_file() #######
+####### Any changes to this file will be overwritten by the next CMake run ####
+####### The input file was Config.cmake.in                            ########
+
+get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/../../../" ABSOLUTE)
+
+macro(set_and_check _var _file)
+  set(${_var} "${_file}")
+  if(NOT EXISTS "${_file}")
+    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
+  endif()
+endmacro()
+
+macro(check_required_components _NAME)
+  foreach(comp ${${_NAME}_FIND_COMPONENTS})
+    if(NOT ${_NAME}_${comp}_FOUND)
+      if(${_NAME}_FIND_REQUIRED_${comp})
+        set(${_NAME}_FOUND FALSE)
+      endif()
+    endif()
+  endforeach()
+endmacro()
+
+####################################################################################
+
+set(skip_this_file TRUE)
+if(NOT proxsuite_FOUND)
+  set(skip_this_file FALSE)
+endif()
+if(skip_this_file)
+  foreach(component ${proxsuite_FIND_COMPONENTS})
+    if(NOT "proxsuite_${component}_FOUND")
+      set(skip_this_file FALSE)
+    endif()
+  endforeach()
+endif()
+if(skip_this_file)
+  return()
+endif()
+
+set("proxsuite_INCLUDE_DIRS" "${PACKAGE_PREFIX_DIR}/include")
+set("PROXSUITE_INCLUDE_DIRS" "${PACKAGE_PREFIX_DIR}/include")
+set("proxsuite_DOXYGENDOCDIR" "${PACKAGE_PREFIX_DIR}/share/doc/proxsuite/doxygen-html")
+set("PROXSUITE_DOXYGENDOCDIR" "${PACKAGE_PREFIX_DIR}/share/doc/proxsuite/doxygen-html")
+set("proxsuite_DEPENDENCIES" "Eigen3;Simde")
+set("proxsuite_PKG_CONFIG_DEPENDENCIES" "")
+
+set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} 
+ ${PACKAGE_PREFIX_DIR}/lib/cmake/proxsuite/find-external/Simde)
+
+# Find absolute library paths for all _PKG_CONFIG_LIBS as CMake expects full paths, while pkg-config does not.
+set(_PACKAGE_CONFIG_LIBRARIES "")
+set("_proxsuite_PKG_CONFIG_LIBDIR" "${pcfiledir}/../../lib")
+set("_proxsuite_PKG_CONFIG_LIBS_LIST" "")
+if(_proxsuite_PKG_CONFIG_LIBS_LIST)
+  string(FIND ${_proxsuite_PKG_CONFIG_LIBS_LIST} ", " _is_comma_space)
+  while(_is_comma_space GREATER -1)
+    string(REPLACE ", " "," _proxsuite_PKG_CONFIG_LIBS_LIST "${_proxsuite_PKG_CONFIG_LIBS_LIST}")
+    string(FIND ${_proxsuite_PKG_CONFIG_LIBS_LIST} ", " _is_comma_space)
+  endwhile()
+  string(REPLACE " " ";" _proxsuite_PKG_CONFIG_LIBS_LIST "${_proxsuite_PKG_CONFIG_LIBS_LIST}")
+  set(LIBDIR_HINTS ${_proxsuite_PKG_CONFIG_LIBDIR})
+  foreach(component ${_proxsuite_PKG_CONFIG_LIBS_LIST})
+    string(STRIP ${component} component)
+    # If the component is a link directory ("-L/full/path"), append to LIBDIR_HINTS.
+    string(FIND ${component} "-L" _is_library_dir)
+    if(${_is_library_dir} EQUAL 0)
+      string(REGEX REPLACE "^-L" "" lib_path ${component})
+      list(APPEND LIBDIR_HINTS "${lib_path}")
+      continue()
+    endif()
+    # If the component is a library name
+    string(FIND ${component} "-l" _is_library_name)
+    if(${_is_library_name} EQUAL 0)
+      string(REGEX REPLACE "^-l" "" lib ${component})
+      find_library(abs_lib_${lib} ${lib} HINTS ${LIBDIR_HINTS})
+      if(NOT abs_lib_${lib})
+        IF(_LIBDIR_HINTS)
+          message(STATUS "${lib} searched on ${_LIBDIR_HINTS} not FOUND.")
+        ELSE()
+          message(STATUS "${lib} not FOUND.")
+        ENDIF()
+      else()
+        IF(_LIBDIR_HINTS)
+          message(STATUS "${lib} searched on ${_LIBDIR_HINTS} FOUND. ${lib} at ${abs_lib_${lib}}")
+        ELSE()
+          message(STATUS "${lib} FOUND. ${lib} at ${abs_lib_${lib}}")
+        ENDIF()
+        list(APPEND _PACKAGE_CONFIG_LIBRARIES "${abs_lib_${lib}}")
+      endif()
+      unset(abs_lib_${lib} CACHE)
+      continue()
+    endif()
+    # If the component contains a collection of additional arguments
+    string(FIND ${component} "," _is_collection)
+    if(${_is_collection} GREATER -1)
+      string(REPLACE "," ";" component_list "${component}")
+      list(GET component_list -1 lib_info)
+      set(options ${component})
+      list(REMOVE_AT options -1)
+      string(FIND ${lib_info} "-l" _is_library_name)
+      if(${_is_library_name} GREATER -1)
+        string(REGEX REPLACE "^-l" "" lib ${lib_info})
+        find_library(abs_lib_${lib} ${lib} HINTS ${LIBDIR_HINTS})
+        if(NOT abs_lib_${lib})
+          IF(_LIBDIR_HINTS)
+            message(STATUS "${lib} searched on ${_LIBDIR_HINTS} not FOUND.")
+          ELSE()
+            message(STATUS "${lib} not FOUND.")
+          ENDIF()
+        else()
+          IF(_LIBDIR_HINTS)
+            message(STATUS "${lib} searched on ${_LIBDIR_HINTS} FOUND. ${lib} at ${abs_lib_${lib}}")
+          ELSE()
+            message(STATUS "${lib} FOUND. ${lib} at ${abs_lib_${lib}}")
+          ENDIF()
+          list(APPEND _PACKAGE_CONFIG_LIBRARIES "${abs_lib_${lib}}")
+        endif()
+        unset(abs_lib_${lib} CACHE)
+        continue()
+      else() # This is an absolute lib
+        list(APPEND _PACKAGE_CONFIG_LIBRARIES "${component}")
+      endif()
+      continue()
+    endif()
+    # Else, this is just an absolute lib
+    if(EXISTS "${component}")
+      list(APPEND _PACKAGE_CONFIG_LIBRARIES "${component}")
+    endif()
+  endforeach()
+endif(_proxsuite_PKG_CONFIG_LIBS_LIST)
+
+set("proxsuite_LIBRARIES" ${_PACKAGE_CONFIG_LIBRARIES})
+set("PROXSUITE_LIBRARIES" ${_PACKAGE_CONFIG_LIBRARIES})
+
+
+
+
+
+include(CMakeFindDependencyMacro)
+if(${CMAKE_VERSION} VERSION_LESS "3.15.0")
+  find_package(Eigen3 REQUIRED)
+  find_package(Simde REQUIRED)
+else()
+  find_dependency(Eigen3 REQUIRED)
+  find_dependency(Simde REQUIRED)
+endif()
+
+IF(COMMAND ADD_REQUIRED_DEPENDENCY)
+  FOREACH(pkgcfg_dep ${proxsuite_PKG_CONFIG_DEPENDENCIES})
+    # Avoid duplicated lookup.
+    LIST (FIND $_PKG_CONFIG_REQUIRES "${pkgcfg_dep}" _index)
+    IF(${_index} EQUAL -1)
+      ADD_REQUIRED_DEPENDENCY(${pkgcfg_dep})
+    ENDIF()
+  ENDFOREACH()
+ENDIF(COMMAND ADD_REQUIRED_DEPENDENCY)
+
+include("${CMAKE_CURRENT_LIST_DIR}/proxsuiteTargets.cmake")
+
+foreach(component ${proxsuite_FIND_COMPONENTS})
+  set(comp_file "${CMAKE_CURRENT_LIST_DIR}/${component}Config.cmake")
+  if(EXISTS ${comp_file})
+    include(${comp_file})
+  else()
+    set(proxsuite_${component}_FOUND FALSE)
+  endif()
+  if(proxsuite_${component}_FOUND)
+    message(STATUS "proxsuite: ${component} found.")
+  else()
+    message(STATUS "proxsuite: ${component} not found.")
+  endif()
+endforeach()
+check_required_components("proxsuite")
+
+
```

## cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake

```diff
@@ -1,70 +1,65 @@
-# This is a basic version file for the Config-mode of find_package().
-# It is used by write_basic_package_version_file() as input file for configure_file()
-# to create a version-file which can be installed along a config.cmake file.
-#
-# The created file sets PACKAGE_VERSION_EXACT if the current version string and
-# the requested version string are exactly the same and it sets
-# PACKAGE_VERSION_COMPATIBLE if the current version is >= requested version,
-# but only if the requested major version is the same as the current one.
-# The variable CVF_VERSION must be set before calling configure_file().
-
-
-set(PACKAGE_VERSION "0.3.6")
-
-if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
-  set(PACKAGE_VERSION_COMPATIBLE FALSE)
-else()
-
-  if("0.3.6" MATCHES "^([0-9]+)\\.")
-    set(CVF_VERSION_MAJOR "${CMAKE_MATCH_1}")
-    if(NOT CVF_VERSION_MAJOR VERSION_EQUAL 0)
-      string(REGEX REPLACE "^0+" "" CVF_VERSION_MAJOR "${CVF_VERSION_MAJOR}")
-    endif()
-  else()
-    set(CVF_VERSION_MAJOR "0.3.6")
-  endif()
-
-  if(PACKAGE_FIND_VERSION_RANGE)
-    # both endpoints of the range must have the expected major version
-    math (EXPR CVF_VERSION_MAJOR_NEXT "${CVF_VERSION_MAJOR} + 1")
-    if (NOT PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
-        OR ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND NOT PACKAGE_FIND_VERSION_MAX_MAJOR STREQUAL CVF_VERSION_MAJOR)
-          OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND NOT PACKAGE_FIND_VERSION_MAX VERSION_LESS_EQUAL CVF_VERSION_MAJOR_NEXT)))
-      set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    elseif(PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
-        AND ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_LESS_EQUAL PACKAGE_FIND_VERSION_MAX)
-        OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION_MAX)))
-      set(PACKAGE_VERSION_COMPATIBLE TRUE)
-    else()
-      set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    endif()
-  else()
-    if(PACKAGE_FIND_VERSION_MAJOR STREQUAL CVF_VERSION_MAJOR)
-      set(PACKAGE_VERSION_COMPATIBLE TRUE)
-    else()
-      set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    endif()
-
-    if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
-      set(PACKAGE_VERSION_EXACT TRUE)
-    endif()
-  endif()
-endif()
-
-
-# if the installed project requested no architecture check, don't perform the check
-if("FALSE")
-  return()
-endif()
-
-# if the installed or the using project don't have CMAKE_SIZEOF_VOID_P set, ignore it:
-if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "" OR "8" STREQUAL "")
-  return()
-endif()
-
-# check that the installed version has the same 32/64bit-ness as the one which is currently searching:
-if(NOT CMAKE_SIZEOF_VOID_P STREQUAL "8")
-  math(EXPR installedBits "8 * 8")
-  set(PACKAGE_VERSION "${PACKAGE_VERSION} (${installedBits}bit)")
-  set(PACKAGE_VERSION_UNSUITABLE TRUE)
-endif()
+# This is a basic version file for the Config-mode of find_package().
+# It is used by write_basic_package_version_file() as input file for configure_file()
+# to create a version-file which can be installed along a config.cmake file.
+#
+# The created file sets PACKAGE_VERSION_EXACT if the current version string and
+# the requested version string are exactly the same and it sets
+# PACKAGE_VERSION_COMPATIBLE if the current version is >= requested version,
+# but only if the requested major version is the same as the current one.
+# The variable CVF_VERSION must be set before calling configure_file().
+
+
+set(PACKAGE_VERSION "0.3.7")
+
+if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+else()
+
+  if("0.3.7" MATCHES "^([0-9]+)\\.")
+    set(CVF_VERSION_MAJOR "${CMAKE_MATCH_1}")
+    if(NOT CVF_VERSION_MAJOR VERSION_EQUAL 0)
+      string(REGEX REPLACE "^0+" "" CVF_VERSION_MAJOR "${CVF_VERSION_MAJOR}")
+    endif()
+  else()
+    set(CVF_VERSION_MAJOR "0.3.7")
+  endif()
+
+  if(PACKAGE_FIND_VERSION_RANGE)
+    # both endpoints of the range must have the expected major version
+    math (EXPR CVF_VERSION_MAJOR_NEXT "${CVF_VERSION_MAJOR} + 1")
+    if (NOT PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
+        OR ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND NOT PACKAGE_FIND_VERSION_MAX_MAJOR STREQUAL CVF_VERSION_MAJOR)
+          OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND NOT PACKAGE_FIND_VERSION_MAX VERSION_LESS_EQUAL CVF_VERSION_MAJOR_NEXT)))
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    elseif(PACKAGE_FIND_VERSION_MIN_MAJOR STREQUAL CVF_VERSION_MAJOR
+        AND ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_LESS_EQUAL PACKAGE_FIND_VERSION_MAX)
+        OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION_MAX)))
+      set(PACKAGE_VERSION_COMPATIBLE TRUE)
+    else()
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    endif()
+  else()
+    if(PACKAGE_FIND_VERSION_MAJOR STREQUAL CVF_VERSION_MAJOR)
+      set(PACKAGE_VERSION_COMPATIBLE TRUE)
+    else()
+      set(PACKAGE_VERSION_COMPATIBLE FALSE)
+    endif()
+
+    if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
+      set(PACKAGE_VERSION_EXACT TRUE)
+    endif()
+  endif()
+endif()
+
+
+# if the installed or the using project don't have CMAKE_SIZEOF_VOID_P set, ignore it:
+if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "" OR "8" STREQUAL "")
+  return()
+endif()
+
+# check that the installed version has the same 32/64bit-ness as the one which is currently searching:
+if(NOT CMAKE_SIZEOF_VOID_P STREQUAL "8")
+  math(EXPR installedBits "8 * 8")
+  set(PACKAGE_VERSION "${PACKAGE_VERSION} (${installedBits}bit)")
+  set(PACKAGE_VERSION_UNSUITABLE TRUE)
+endif()
```

## cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake

```diff
@@ -1,118 +1,119 @@
-# Generated by CMake
-
-if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.8)
-   message(FATAL_ERROR "CMake >= 2.8.0 required")
-endif()
-if(CMAKE_VERSION VERSION_LESS "2.8.3")
-   message(FATAL_ERROR "CMake >= 2.8.3 required")
-endif()
-cmake_policy(PUSH)
-cmake_policy(VERSION 2.8.3...3.23)
-#----------------------------------------------------------------
-# Generated CMake target import file.
-#----------------------------------------------------------------
-
-# Commands may need to know the format version.
-set(CMAKE_IMPORT_FILE_VERSION 1)
-
-# Protect against multiple inclusion, which would fail when already imported targets are added once more.
-set(_cmake_targets_defined "")
-set(_cmake_targets_not_defined "")
-set(_cmake_expected_targets "")
-foreach(_cmake_expected_target IN ITEMS proxsuite::proxsuite proxsuite::proxsuite-vectorized proxsuite::instructionset)
-  list(APPEND _cmake_expected_targets "${_cmake_expected_target}")
-  if(TARGET "${_cmake_expected_target}")
-    list(APPEND _cmake_targets_defined "${_cmake_expected_target}")
-  else()
-    list(APPEND _cmake_targets_not_defined "${_cmake_expected_target}")
-  endif()
-endforeach()
-unset(_cmake_expected_target)
-if(_cmake_targets_defined STREQUAL _cmake_expected_targets)
-  unset(_cmake_targets_defined)
-  unset(_cmake_targets_not_defined)
-  unset(_cmake_expected_targets)
-  unset(CMAKE_IMPORT_FILE_VERSION)
-  cmake_policy(POP)
-  return()
-endif()
-if(NOT _cmake_targets_defined STREQUAL "")
-  string(REPLACE ";" ", " _cmake_targets_defined_text "${_cmake_targets_defined}")
-  string(REPLACE ";" ", " _cmake_targets_not_defined_text "${_cmake_targets_not_defined}")
-  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_cmake_targets_defined_text}\nTargets not yet defined: ${_cmake_targets_not_defined_text}\n")
-endif()
-unset(_cmake_targets_defined)
-unset(_cmake_targets_not_defined)
-unset(_cmake_expected_targets)
-
-
-# Compute the installation prefix relative to this file.
-get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
-get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
-get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
-get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
-if(_IMPORT_PREFIX STREQUAL "/")
-  set(_IMPORT_PREFIX "")
-endif()
-
-# Create imported target proxsuite::proxsuite
-add_library(proxsuite::proxsuite INTERFACE IMPORTED)
-
-set_target_properties(proxsuite::proxsuite PROPERTIES
-  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
-  INTERFACE_LINK_LIBRARIES "Eigen3::Eigen"
-)
-
-# Create imported target proxsuite::proxsuite-vectorized
-add_library(proxsuite::proxsuite-vectorized INTERFACE IMPORTED)
-
-set_target_properties(proxsuite::proxsuite-vectorized PROPERTIES
-  INTERFACE_COMPILE_DEFINITIONS "PROXSUITE_VECTORIZE"
-  INTERFACE_LINK_LIBRARIES "proxsuite::proxsuite;simde"
-)
-
-# Create imported target proxsuite::instructionset
-add_library(proxsuite::instructionset MODULE IMPORTED)
-
-if(CMAKE_VERSION VERSION_LESS 3.0.0)
-  message(FATAL_ERROR "This file relies on consumers using CMake 3.0.0 or greater.")
-endif()
-
-# Load information for each installed configuration.
-file(GLOB _cmake_config_files "${CMAKE_CURRENT_LIST_DIR}/proxsuiteTargets-*.cmake")
-foreach(_cmake_config_file IN LISTS _cmake_config_files)
-  include("${_cmake_config_file}")
-endforeach()
-unset(_cmake_config_file)
-unset(_cmake_config_files)
-
-# Cleanup temporary variables.
-set(_IMPORT_PREFIX)
-
-# Loop over all imported files and verify that they actually exist
-foreach(_cmake_target IN LISTS _cmake_import_check_targets)
-  foreach(_cmake_file IN LISTS "_cmake_import_check_files_for_${_cmake_target}")
-    if(NOT EXISTS "${_cmake_file}")
-      message(FATAL_ERROR "The imported target \"${_cmake_target}\" references the file
-   \"${_cmake_file}\"
-but this file does not exist.  Possible reasons include:
-* The file was deleted, renamed, or moved to another location.
-* An install or uninstall procedure did not complete successfully.
-* The installation package was faulty and contained
-   \"${CMAKE_CURRENT_LIST_FILE}\"
-but not all the files it references.
-")
-    endif()
-  endforeach()
-  unset(_cmake_file)
-  unset("_cmake_import_check_files_for_${_cmake_target}")
-endforeach()
-unset(_cmake_target)
-unset(_cmake_import_check_targets)
-
-# This file does not depend on other imported targets which have
-# been exported from the same project but in a separate export set.
-
-# Commands beyond this point should not need to know the version.
-set(CMAKE_IMPORT_FILE_VERSION)
-cmake_policy(POP)
+# Generated by CMake
+
+if("${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}" LESS 2.8)
+   message(FATAL_ERROR "CMake >= 2.8.0 required")
+endif()
+if(CMAKE_VERSION VERSION_LESS "2.8.3")
+   message(FATAL_ERROR "CMake >= 2.8.3 required")
+endif()
+cmake_policy(PUSH)
+cmake_policy(VERSION 2.8.3...3.24)
+#----------------------------------------------------------------
+# Generated CMake target import file.
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Protect against multiple inclusion, which would fail when already imported targets are added once more.
+set(_cmake_targets_defined "")
+set(_cmake_targets_not_defined "")
+set(_cmake_expected_targets "")
+foreach(_cmake_expected_target IN ITEMS proxsuite::proxsuite proxsuite::proxsuite-vectorized proxsuite::instructionset)
+  list(APPEND _cmake_expected_targets "${_cmake_expected_target}")
+  if(TARGET "${_cmake_expected_target}")
+    list(APPEND _cmake_targets_defined "${_cmake_expected_target}")
+  else()
+    list(APPEND _cmake_targets_not_defined "${_cmake_expected_target}")
+  endif()
+endforeach()
+unset(_cmake_expected_target)
+if(_cmake_targets_defined STREQUAL _cmake_expected_targets)
+  unset(_cmake_targets_defined)
+  unset(_cmake_targets_not_defined)
+  unset(_cmake_expected_targets)
+  unset(CMAKE_IMPORT_FILE_VERSION)
+  cmake_policy(POP)
+  return()
+endif()
+if(NOT _cmake_targets_defined STREQUAL "")
+  string(REPLACE ";" ", " _cmake_targets_defined_text "${_cmake_targets_defined}")
+  string(REPLACE ";" ", " _cmake_targets_not_defined_text "${_cmake_targets_not_defined}")
+  message(FATAL_ERROR "Some (but not all) targets in this export set were already defined.\nTargets Defined: ${_cmake_targets_defined_text}\nTargets not yet defined: ${_cmake_targets_not_defined_text}\n")
+endif()
+unset(_cmake_targets_defined)
+unset(_cmake_targets_not_defined)
+unset(_cmake_expected_targets)
+
+
+# Compute the installation prefix relative to this file.
+get_filename_component(_IMPORT_PREFIX "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+get_filename_component(_IMPORT_PREFIX "${_IMPORT_PREFIX}" PATH)
+if(_IMPORT_PREFIX STREQUAL "/")
+  set(_IMPORT_PREFIX "")
+endif()
+
+# Create imported target proxsuite::proxsuite
+add_library(proxsuite::proxsuite INTERFACE IMPORTED)
+
+set_target_properties(proxsuite::proxsuite PROPERTIES
+  INTERFACE_COMPILE_OPTIONS "/permissive-;\$<\$<COMPILE_LANGUAGE:CXX>:/bigobj>"
+  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
+  INTERFACE_LINK_LIBRARIES "Eigen3::Eigen"
+)
+
+# Create imported target proxsuite::proxsuite-vectorized
+add_library(proxsuite::proxsuite-vectorized INTERFACE IMPORTED)
+
+set_target_properties(proxsuite::proxsuite-vectorized PROPERTIES
+  INTERFACE_COMPILE_DEFINITIONS "PROXSUITE_VECTORIZE"
+  INTERFACE_LINK_LIBRARIES "proxsuite::proxsuite;simde"
+)
+
+# Create imported target proxsuite::instructionset
+add_library(proxsuite::instructionset MODULE IMPORTED)
+
+if(CMAKE_VERSION VERSION_LESS 3.0.0)
+  message(FATAL_ERROR "This file relies on consumers using CMake 3.0.0 or greater.")
+endif()
+
+# Load information for each installed configuration.
+file(GLOB _cmake_config_files "${CMAKE_CURRENT_LIST_DIR}/proxsuiteTargets-*.cmake")
+foreach(_cmake_config_file IN LISTS _cmake_config_files)
+  include("${_cmake_config_file}")
+endforeach()
+unset(_cmake_config_file)
+unset(_cmake_config_files)
+
+# Cleanup temporary variables.
+set(_IMPORT_PREFIX)
+
+# Loop over all imported files and verify that they actually exist
+foreach(_cmake_target IN LISTS _cmake_import_check_targets)
+  foreach(_cmake_file IN LISTS "_cmake_import_check_files_for_${_cmake_target}")
+    if(NOT EXISTS "${_cmake_file}")
+      message(FATAL_ERROR "The imported target \"${_cmake_target}\" references the file
+   \"${_cmake_file}\"
+but this file does not exist.  Possible reasons include:
+* The file was deleted, renamed, or moved to another location.
+* An install or uninstall procedure did not complete successfully.
+* The installation package was faulty and contained
+   \"${CMAKE_CURRENT_LIST_FILE}\"
+but not all the files it references.
+")
+    endif()
+  endforeach()
+  unset(_cmake_file)
+  unset("_cmake_import_check_files_for_${_cmake_target}")
+endforeach()
+unset(_cmake_target)
+unset(_cmake_import_check_targets)
+
+# This file does not depend on other imported targets which have
+# been exported from the same project but in a separate export set.
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
+cmake_policy(POP)
```

## cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-#
-# Copyright (c) 2022 INRIA
-#
-
-find_path(Simde_INCLUDE_DIR simde/simde-math.h)
-
-if(NOT SIMDE_HINT_FAILURE)
-  set(SIMDE_HINT_FAILURE None)
-endif()
-
-if(${CMAKE_VERSION} VERSION_LESS "3.16.0")
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(
-    Simde
-    FOUND_VAR Simde_FOUND
-    REQUIRED_VARS Simde_INCLUDE_DIR)
-else()
-  include(FindPackageHandleStandardArgs)
-  find_package_handle_standard_args(
-    Simde
-    FOUND_VAR Simde_FOUND
-    REQUIRED_VARS Simde_INCLUDE_DIR REASON_FAILURE_MESSAGE
-                  ${SIMDE_HINT_FAILURE})
-endif()
-
-if(Simde_FOUND)
-  add_library(simde INTERFACE IMPORTED)
-  set_target_properties(simde PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
-                                         "${Simde_INCLUDE_DIR}")
-endif()
-
-mark_as_advanced(SIMDE_INCLUDE_DIR)
-
-include(FeatureSummary)
-set_package_properties(
-  Simde PROPERTIES
-  DESCRIPTION
-    "Implementations of SIMD instruction sets for systems which don't natively support them."
-  URL "https://github.com/simd-everywhere/simde")
+#
+# Copyright (c) 2022 INRIA
+#
+
+find_path(Simde_INCLUDE_DIR simde/simde-math.h)
+
+if(NOT SIMDE_HINT_FAILURE)
+  set(SIMDE_HINT_FAILURE None)
+endif()
+
+if(${CMAKE_VERSION} VERSION_LESS "3.16.0")
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(
+    Simde
+    FOUND_VAR Simde_FOUND
+    REQUIRED_VARS Simde_INCLUDE_DIR)
+else()
+  include(FindPackageHandleStandardArgs)
+  find_package_handle_standard_args(
+    Simde
+    FOUND_VAR Simde_FOUND
+    REQUIRED_VARS Simde_INCLUDE_DIR REASON_FAILURE_MESSAGE
+                  ${SIMDE_HINT_FAILURE})
+endif()
+
+if(Simde_FOUND)
+  add_library(simde INTERFACE IMPORTED)
+  set_target_properties(simde PROPERTIES INTERFACE_INCLUDE_DIRECTORIES
+                                         "${Simde_INCLUDE_DIR}")
+endif()
+
+mark_as_advanced(SIMDE_INCLUDE_DIR)
+
+include(FeatureSummary)
+set_package_properties(
+  Simde PROPERTIES
+  DESCRIPTION
+    "Implementations of SIMD instruction sets for systems which don't natively support them."
+  URL "https://github.com/simd-everywhere/simde")
```

## cmeel.prefix/lib/pkgconfig/proxsuite.pc

```diff
@@ -1,22 +1,22 @@
-prefix=${pcfiledir}/../..
-exec_prefix=${pcfiledir}/../..
-libdir=${pcfiledir}/../../lib
-bindir=${pcfiledir}/../../bin
-pkglibdir=${pcfiledir}/../../lib/proxsuite
-includedir=${pcfiledir}/../../include
-datarootdir=${pcfiledir}/../../share
-pkgdatarootdir=${pcfiledir}/../../share
-docdir=
-doxygendocdir=
-
-Name: proxsuite
-Description: The Advanced Proximal Optimization Toolbox
-URL: http://github.com/Simple-Robotics/proxsuite
-Version: 0.3.6
-Requires: eigen3 >= 3.0.5, simde
-Conflicts: 
-Libs: -L${libdir} 
-Libs.private: 
-Cflags:  -I${includedir}
-
-
+prefix=${pcfiledir}/../..
+exec_prefix=${pcfiledir}/../..
+libdir=${pcfiledir}/../../lib
+bindir=${pcfiledir}/../../bin
+pkglibdir=${pcfiledir}/../../lib/proxsuite
+includedir=${pcfiledir}/../../include
+datarootdir=${pcfiledir}/../../share
+pkgdatarootdir=${pcfiledir}/../../share
+docdir=
+doxygendocdir=
+
+Name: proxsuite
+Description: The Advanced Proximal Optimization Toolbox
+URL: http://github.com/Simple-Robotics/proxsuite
+Version: 0.3.7
+Requires: eigen3 >= 3.0.5, simde
+Conflicts: 
+Libs: -L${libdir} 
+Libs.private: 
+Cflags:  -I${includedir}
+
+
```

## cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py

 * *Ordering differences only*

```diff
@@ -1,40 +1,40 @@
-import platform
-
-machine = platform.machine()
-has_vectorization_instructions = not machine.startswith(
-    ("arm", "aarch64", "power", "ppc64", "s390x", "sparc")
-)
-if has_vectorization_instructions:
-    from . import instructionset
-
-
-def load_main_module(globals):
-    def load_module(main_module_name):
-        import importlib
-
-        try:
-            main_module = importlib.import_module("." + main_module_name, __name__)
-            globals.update(main_module.__dict__)
-            del globals[main_module_name]
-            return True
-        except ModuleNotFoundError:
-            return False
-
-    if has_vectorization_instructions:
-        all_modules = [
-            ("proxsuite_pywrap_avx512", instructionset.has_AVX512F),
-            ("proxsuite_pywrap_avx2", instructionset.has_AVX2),
-        ]
-
-        for module_name, checker in all_modules:
-            if checker() and load_module(module_name):
-                return
-
-    assert load_module("proxsuite_pywrap") == True
-
-
-load_main_module(globals=globals())
-del load_main_module
-del platform
-del has_vectorization_instructions
-del machine
+import platform
+
+machine = platform.machine()
+has_vectorization_instructions = not machine.startswith(
+    ("arm", "aarch64", "power", "ppc64", "s390x", "sparc")
+)
+if has_vectorization_instructions:
+    from . import instructionset
+
+
+def load_main_module(globals):
+    def load_module(main_module_name):
+        import importlib
+
+        try:
+            main_module = importlib.import_module("." + main_module_name, __name__)
+            globals.update(main_module.__dict__)
+            del globals[main_module_name]
+            return True
+        except ModuleNotFoundError:
+            return False
+
+    if has_vectorization_instructions:
+        all_modules = [
+            ("proxsuite_pywrap_avx512", instructionset.has_AVX512F),
+            ("proxsuite_pywrap_avx2", instructionset.has_AVX2),
+        ]
+
+        for module_name, checker in all_modules:
+            if checker() and load_module(module_name):
+                return
+
+    assert load_module("proxsuite_pywrap") == True
+
+
+load_main_module(globals=globals())
+del load_main_module
+del platform
+del has_vectorization_instructions
+del machine
```

## cmeel.prefix/share/proxsuite/package.xml

### cmeel.prefix/share/proxsuite/package.xml

```diff
@@ -1,11 +1,11 @@
 <?xml version="1.0" encoding="utf-8"?>
 <package format="3">
   <name>proxsuite</name>
-  <version>0.3.6</version>
+  <version>0.3.7</version>
   <description>The Advanced Proximal Optimization Toolbox</description>
   <!-- Project maintainers -->
   <maintainer email="justin.carpentier@inria.fr">Justin Carpentier</maintainer>
   <!-- ROS buildfarm release -->
   <maintainer email="opensource@wolfgangmerkt.com">Wolfgang Merkt</maintainer>
   <license>BSD-2</license>
   <!-- Core authors - cf. CITATION.bib and CITATION.cff -->
@@ -17,15 +17,15 @@
   <url type="website">https://simple-robotics.github.io/proxsuite</url>
   <url type="repository">https://github.com/Simple-Robotics/proxsuite</url>
   <url type="bugtracker">https://github.com/Simple-Robotics/proxsuite/issues</url>
   <build_depend>git</build_depend>
   <build_depend>doxygen</build_depend>
   <depend>eigen</depend>
   <!-- simde is only available for Ubuntu 22.04 -->
-  <depend condition="$ROS_DISTRO == humble or $ROS_DISTRO == rolling">simde</depend>
+  <depend condition="$ROS_DISTRO == humble or $ROS_DISTRO == rolling or $ROS_DISTRO == iron">simde</depend>
   <depend condition="$ROS_PYTHON_VERSION == 2">python-numpy</depend>
   <depend condition="$ROS_PYTHON_VERSION == 3">python3-numpy</depend>
   <depend condition="$ROS_PYTHON_VERSION == 2">python-scipy</depend>
   <depend condition="$ROS_PYTHON_VERSION == 3">python3-scipy</depend>
   <test_depend>matio</test_depend>
   <!-- The following tag is recommended by REP-136 -->
   <exec_depend condition="$ROS_VERSION == 1">catkin</exec_depend>
```

## cmeel.prefix/share/proxsuite/hook/python_path.dsv

```diff
@@ -1 +1 @@
-prepend-non-duplicate;PYTHONPATH;lib/python3.9/site-packages
+prepend-non-duplicate;PYTHONPATH;lib\python3.9\site-packages
```

## Comparing `cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-release.cmake` & `cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-debug.cmake`

 * *Files 20% similar despite different names*

```diff
@@ -1,20 +1,19 @@
-#----------------------------------------------------------------
-# Generated CMake target import file for configuration "Release".
-#----------------------------------------------------------------
-
-# Commands may need to know the format version.
-set(CMAKE_IMPORT_FILE_VERSION 1)
-
-# Import target "proxsuite::instructionset" for configuration "Release"
-set_property(TARGET proxsuite::instructionset APPEND PROPERTY IMPORTED_CONFIGURATIONS RELEASE)
-set_target_properties(proxsuite::instructionset PROPERTIES
-  IMPORTED_COMMON_LANGUAGE_RUNTIME_RELEASE ""
-  IMPORTED_LOCATION_RELEASE "${PACKAGE_PREFIX_DIR}/lib/python3.9/site-packages/proxsuite/instructionset.so"
-  IMPORTED_NO_SONAME_RELEASE "TRUE"
-  )
-
-list(APPEND _cmake_import_check_targets proxsuite::instructionset )
-list(APPEND _cmake_import_check_files_for_proxsuite::instructionset "${PACKAGE_PREFIX_DIR}/lib/python3.9/site-packages/proxsuite/instructionset.so" )
-
-# Commands beyond this point should not need to know the version.
-set(CMAKE_IMPORT_FILE_VERSION)
+#----------------------------------------------------------------
+# Generated CMake target import file for configuration "Debug".
+#----------------------------------------------------------------
+
+# Commands may need to know the format version.
+set(CMAKE_IMPORT_FILE_VERSION 1)
+
+# Import target "proxsuite::instructionset" for configuration "Debug"
+set_property(TARGET proxsuite::instructionset APPEND PROPERTY IMPORTED_CONFIGURATIONS DEBUG)
+set_target_properties(proxsuite::instructionset PROPERTIES
+  IMPORTED_COMMON_LANGUAGE_RUNTIME_DEBUG ""
+  IMPORTED_LOCATION_DEBUG "C:/Users/runneradmin/AppData/Local/Temp/cmeel-x5c9bvta/whl/cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.pyd"
+  )
+
+list(APPEND _cmake_import_check_targets proxsuite::instructionset )
+list(APPEND _cmake_import_check_files_for_proxsuite::instructionset "C:/Users/runneradmin/AppData/Local/Temp/cmeel-x5c9bvta/whl/cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.pyd" )
+
+# Commands beyond this point should not need to know the version.
+set(CMAKE_IMPORT_FILE_VERSION)
```

## Comparing `proxsuite-0.3.6.dist-info/METADATA` & `proxsuite-0.3.7.dist-info/METADATA`

 * *Files 7% similar despite different names*

```diff
@@ -1,160 +1,164 @@
-Metadata-Version: 2.1
-Name: proxsuite
-Version: 0.3.6
-Summary: Quadratic Programming Solver for Robotics and beyond.
-License-Expression: BSD-2-Clause
-Requires-Python: >= 3.7
-Home-page: https://github.com/Simple-Robotics/proxsuite
-Project-URL: Repository, https://github.com/Simple-Robotics/proxsuite.git
-Requires-Dist: cmeel
-Requires-Dist: numpy
-Requires-Dist: scipy
-Description-Content-Type: text/markdown
-
-<p align="center">
-  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/proxsuite-logo.png" width="700" alt="Proxsuite Logo" align="center"/>
-</p>
-
-<p align="center">
-  <a href="https://opensource.org/licenses/BSD-2-Clause"><img src="https://img.shields.io/badge/License-BSD%202--Clause-green.svg" alt="License"/></a>
-  <a href="https://simple-robotics.github.io/proxsuite/"><img src="https://img.shields.io/badge/docs-online-brightgreen" alt="Documentation"/></a>
-  <a href="https://github.com/Simple-Robotics/proxsuite/actions/workflows/ci-linux-osx-win-conda.yml"><img src="https://github.com/Simple-Robotics/proxsuite/actions/workflows/ci-linux-osx-win-conda.yml/badge.svg?branch=main" alt="CI - Linux/OSX/Windows - Conda"></a>
-  <a href="https://badge.fury.io/py/proxsuite"><img src="https://badge.fury.io/py/proxsuite.svg" alt="PyPI version" height="20"></a>
-  <a href="https://anaconda.org/conda-forge/proxsuite"><img src="https://anaconda.org/conda-forge/proxsuite/badges/version.svg" alt="Conda version" height="20"></a>
-</p>
-
-**ProxSuite** is a collection of open-source, numerically robust, precise and efficient numerical solvers (e.g., LPs, QPs, etc.) rooted in revisited primal-dual proximal algorithms.
-Through **ProxSuite**, we aim to offer the community scalable optimizers that can deal with dense, sparse or matrix-free problems. While the first targeted application is Robotics, **ProxSuite** can be used in other contexts without limits.
-
-**ProxSuite** is actively developped and supported by the [Willow](https://www.di.ens.fr/willow/) and [Sierra](https://www.di.ens.fr/sierra/) research groups, joint research teams between [Inria](https://www.inria.fr/en), [École Normale Supérieure de Paris](https://www.ens.fr) and [Centre National de la Recherche Scientifique](https://www.cnrs.fr) localized in France.
-
-**ProxSuite** is already integrated into:
-- [CVXPY](https://www.cvxpy.org/) modeling language for convex optimization problems,
-- [CasADi](https://web.casadi.org/)'s symbolic framework for numerical optimization in general and optimal control. ProxQP is available in CasADi as plugin to [solve quadratic programs](https://web.casadi.org/docs/#quadratic-programming),
-- [TSID](https://github.com/stack-of-tasks/tsid): robotic software for efficient robot inverse dynamics with contacts and based on [Pinocchio](https://github.com/stack-of-tasks/pinocchio).
-
-We are ready to integrate **ProxSuite** within other optimization ecosystems.
-
-## ProxSuite main features
-
-**Proxsuite** is fast:
-
-   - C++ template library,
-   - cache-friendly.
-
-**Proxsuite** is versatile, offering through a unified API advanced algorithms specialized for efficiently exploiting problem structures:
-
-   - dense, sparse and matrix-free matrix factorization backends,
-   - advanced warm-starting options (e.g., equality-constrained initial guess, warm-start or cold-start options from previous results).
-
-**Proxsuite** is flexible:
-
-   - header only,
-   - C++ 14/17/20 compliant,
-   - Python and Julia bindings for easy code prototyping without sacrificing performance.
-
-**Proxsuite** is extensible.
-**Proxsuite** is reliable and extensively tested, showing the best performances on the hardest problems of the literature.
-**Proxsuite** is supported and tested on Windows, Mac OS X, Unix and Linux.
-
-## Documentation
-
-The online **ProxSuite** documentation of the last release is available [here](https://simple-robotics.github.io/proxsuite/).
-
-## Getting started
-
-**ProxSuite** is distributed on many well-known package managers.
-
-### Quick install with <img src="https://www.python.org/static/community_logos/python-logo-inkscape.svg" height="30" style="vertical-align: -1em;">:
-
-```bash
-   pip install proxsuite
-```
-This approach is available on Linux, Windows and Mac OS X.
-
-### Quick install with <img src="https://s3.amazonaws.com/conda-dev/conda_logo.svg" height="18">:
-
-```bash
-   conda install proxsuite -c conda-forge
-```
-This approach is available on Linux, Windows and Mac OS X.
-
-### Quick install with <img src="https://brew.sh/assets/img/homebrew-256x256.png" height="30">:
-
-```bash
-   brew install proxsuite
-```
-This approach is available on Linux and Mac OS X.
-
-### Alternative approaches
-
-Installation from source is presented [here](https://github.com/Simple-Robotics/proxsuite/blob/main/doc/5-installation.md).
-
-### Compiling a first example program
-For the fastest performance use the following command to enable vectorization when compiling the simple [example](https://github.com/Simple-Robotics/proxsuite/blob/main/examples/cpp/first_example_dense.cpp).
-```bash
-g++ -O3 -march=native -DNDEBUG -std=gnu++17 -DPROXSUITE_VECTORIZE examples/first_example_dense.cpp -o first_example_dense $(pkg-config --cflags proxsuite)
-```
-### Using ProxSuite with CMake
-If you want to use ProxSuite with CMake, the following tiny example should help you:
-```cmake
-cmake_minimum_required(VERSION 3.10)
-
-project(Example CXX)
-find_package(proxsuite REQUIRED)
-set(CMAKE_CXX_STANDARD 17) # set(CMAKE_CXX_STANDARD 14) will work too
-
-add_executable(example example.cpp)
-target_link_libraries(example PUBLIC proxsuite::proxsuite)
-
-# Vectorization support via SIMDE and activated by the compilation options '-march=native' or `-mavx2 -mavx512f`
-add_executable(example_with_full_vectorization_support example.cpp)
-target_link_libraries(example_with_full_vectorization_support PUBLIC proxsuite::proxsuite-vectorized)
-target_compile_options(example_with_full_vectorization_support PUBLIC "-march=native")
-```
-If you have compiled ProxSuite with the vectorization support, you might also use the CMake target `proxsuite::proxsuite-vectorized` to also link against SIMDE.
-Don't forget to use `-march=native` for getting the best performance.
-
-## **ProxQP**
-
-The **ProxQP** algorithm is a numerical optimization approach for solving quadratic programming problems of the form:
-
-$$
-\begin{align}
-\min_{x} &  ~\frac{1}{2}x^{T}Hx+g^{T}x \\
-\text{s.t.} & ~A x = b \\
-& ~l \leq C x \leq u
-\end{align}
-$$
-
-where $x \in \mathbb{R}^n$ is the optimization variable. The objective function is defined by a positive semidefinite matrix $H \in \mathcal{S}^n_+$ and a vector $g \in \mathbb{R}^n$. The linear constraints are defined by the equality-contraint matrix $A \in \mathbb{R}^{n_\text{eq} \times n}$ and the inequality-constraint matrix $C \in \mathbb{R}^{n_\text{in} \times n}$ and the vectors $b \in \mathbb{R}^{n_\text{eq}}$, $l \in \mathbb{R}^{n_\text{in}}$ and $u \in \mathbb{R}^{n_\text{in}}$ so that $b_i \in \mathbb{R},~ \forall i = 1,...,n_\text{eq}$ and $l_i \in \mathbb{R} \cup \{ -\infty \}$ and $u_i \in \mathbb{R} \cup \{ +\infty \}, ~\forall i = 1,...,n_\text{in}$.
-
-### Citing **ProxQP**
-
-If you are using **ProxQP** for your work, we encourage you to [cite the related paper](https://hal.inria.fr/hal-03683733/file/Yet_another_QP_solver_for_robotics_and_beyond.pdf/).
-
-### Numerical benchmarks
-
-The numerical benchmarks of **ProxQP** against other commercial and open-source solvers are available [here](https://github.com/Simple-Robotics/proxqp_benchmark).
-
-For dense Convex Quadratic Programs with inequality and equality constraints, when asking for relatively high accuracy (e.g., 1e-6), one obtains the following results.
-
-<p align="center">
-  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/time_series_barplot_Random Mixed QP_dense_eps_abs_1e-6.jpg" width="600" alt="Random Mixed QP_dense_eps_abs_1e-6" align="center"/>
-</p>
-
-On the y-axis, you can see timings in seconds, and on the x-axis dimension wrt to the primal variable of the random Quadratic problems generated (the number of constraints of the generated problem is half the size of its primal dimension). For every dimension, the problem is generated over different seeds and timings are obtained as averages over successive runs for the same problems. This chart shows for every benchmarked solver and random Quadratic program generated, barplot timings including median (as a dot) and minimal and maximal values obtained (defining the amplitude of the bar). You can see that **ProxQP** is always below over solvers, which means it is the quickest for this test.
-
-For hard problems from the [Maros Meszaros testset](http://www.cuter.rl.ac.uk/Problems/marmes.shtml), when asking for high accuracy (e.g., 1e-9), one obtains the results below.
-
-<p align="center">
-  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/performance_profile_maros_meszaros_problems_high_accuracy.jpg" width="600" alt="maros_meszaros_problems_high_accuracy" align="center"/>
-</p>
-
-The chart above reports the performance profiles of different solvers. It is classic for benchmarking solvers. Performance profiles correspond to the fraction of problems solved (on y-axis) as a function of certain runtime (on x-axis, measured in terms of a multiple of the runtime of the fastest solver for that problem). So the higher on the chart the better. You can see that **ProxQP** solves the quickest over 60% of the problems (i.e., for $\tau=1$), and that for solving about 90% of the problems, it is at most 2 times slower than the fastest solvers solving these problems (i.e., for $\tau\approx2$).
-
-*Note: All these results have been obtained with a 11th Gen Intel(R) Core(TM) i7-11850H @ 2.50GHz CPU.*
-
-## Installation procedure
-
-Please follow the installation procedure [here](https://github.com/Simple-Robotics/proxsuite/blob/main/doc/5-installation.md).
+Metadata-Version: 2.1
+Name: proxsuite
+Version: 0.3.7
+Summary: Quadratic Programming Solver for Robotics and beyond.
+Requires-Python: >= 3.7
+License-Expression: BSD-2-Clause
+License-File: LICENSE
+Home-page: https://github.com/Simple-Robotics/proxsuite
+Project-URL: Repository, https://github.com/Simple-Robotics/proxsuite.git
+Requires-Dist: cmeel
+Requires-Dist: numpy
+Requires-Dist: scipy
+Provides-Extra: build
+Requires-Dist: cmeel-eigen ; extra == "build"
+Requires-Dist: cmeel-simde ; extra == "build"
+Description-Content-Type: text/markdown
+
+<p align="center">
+  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/proxsuite-logo.png" width="700" alt="Proxsuite Logo" align="center"/>
+</p>
+
+<p align="center">
+  <a href="https://opensource.org/licenses/BSD-2-Clause"><img src="https://img.shields.io/badge/License-BSD%202--Clause-green.svg" alt="License"/></a>
+  <a href="https://simple-robotics.github.io/proxsuite/"><img src="https://img.shields.io/badge/docs-online-brightgreen" alt="Documentation"/></a>
+  <a href="https://github.com/Simple-Robotics/proxsuite/actions/workflows/ci-linux-osx-win-conda.yml"><img src="https://github.com/Simple-Robotics/proxsuite/actions/workflows/ci-linux-osx-win-conda.yml/badge.svg?branch=main" alt="CI - Linux/OSX/Windows - Conda"></a>
+  <a href="https://badge.fury.io/py/proxsuite"><img src="https://badge.fury.io/py/proxsuite.svg" alt="PyPI version" height="20"></a>
+  <a href="https://anaconda.org/conda-forge/proxsuite"><img src="https://anaconda.org/conda-forge/proxsuite/badges/version.svg" alt="Conda version" height="20"></a>
+</p>
+
+**ProxSuite** is a collection of open-source, numerically robust, precise and efficient numerical solvers (e.g., LPs, QPs, etc.) rooted in revisited primal-dual proximal algorithms.
+Through **ProxSuite**, we aim to offer the community scalable optimizers that can deal with dense, sparse or matrix-free problems. While the first targeted application is Robotics, **ProxSuite** can be used in other contexts without limits.
+
+**ProxSuite** is actively developped and supported by the [Willow](https://www.di.ens.fr/willow/) and [Sierra](https://www.di.ens.fr/sierra/) research groups, joint research teams between [Inria](https://www.inria.fr/en), [École Normale Supérieure de Paris](https://www.ens.fr) and [Centre National de la Recherche Scientifique](https://www.cnrs.fr) localized in France.
+
+**ProxSuite** is already integrated into:
+- [CVXPY](https://www.cvxpy.org/) modeling language for convex optimization problems,
+- [CasADi](https://web.casadi.org/)'s symbolic framework for numerical optimization in general and optimal control. ProxQP is available in CasADi as plugin to [solve quadratic programs](https://web.casadi.org/docs/#quadratic-programming),
+- [TSID](https://github.com/stack-of-tasks/tsid): robotic software for efficient robot inverse dynamics with contacts and based on [Pinocchio](https://github.com/stack-of-tasks/pinocchio).
+
+We are ready to integrate **ProxSuite** within other optimization ecosystems.
+
+## ProxSuite main features
+
+**Proxsuite** is fast:
+
+   - C++ template library,
+   - cache-friendly.
+
+**Proxsuite** is versatile, offering through a unified API advanced algorithms specialized for efficiently exploiting problem structures:
+
+   - dense, sparse and matrix-free matrix factorization backends,
+   - advanced warm-starting options (e.g., equality-constrained initial guess, warm-start or cold-start options from previous results).
+
+**Proxsuite** is flexible:
+
+   - header only,
+   - C++ 14/17/20 compliant,
+   - Python and Julia bindings for easy code prototyping without sacrificing performance.
+
+**Proxsuite** is extensible.
+**Proxsuite** is reliable and extensively tested, showing the best performances on the hardest problems of the literature.
+**Proxsuite** is supported and tested on Windows, Mac OS X, Unix and Linux.
+
+## Documentation
+
+The online **ProxSuite** documentation of the last release is available [here](https://simple-robotics.github.io/proxsuite/).
+
+## Getting started
+
+**ProxSuite** is distributed on many well-known package managers.
+
+### Quick install with <img src="https://www.python.org/static/community_logos/python-logo-inkscape.svg" height="30" style="vertical-align: -1em;">:
+
+```bash
+   pip install proxsuite
+```
+This approach is available on Linux, Windows and Mac OS X.
+
+### Quick install with <img src="https://s3.amazonaws.com/conda-dev/conda_logo.svg" height="18">:
+
+```bash
+   conda install proxsuite -c conda-forge
+```
+This approach is available on Linux, Windows and Mac OS X.
+
+### Quick install with <img src="https://brew.sh/assets/img/homebrew-256x256.png" height="30">:
+
+```bash
+   brew install proxsuite
+```
+This approach is available on Linux and Mac OS X.
+
+### Alternative approaches
+
+Installation from source is presented [here](https://github.com/Simple-Robotics/proxsuite/blob/main/doc/5-installation.md).
+
+### Compiling a first example program
+For the fastest performance use the following command to enable vectorization when compiling the simple [example](https://github.com/Simple-Robotics/proxsuite/blob/main/examples/cpp/first_example_dense.cpp).
+```bash
+g++ -O3 -march=native -DNDEBUG -std=gnu++17 -DPROXSUITE_VECTORIZE examples/first_example_dense.cpp -o first_example_dense $(pkg-config --cflags proxsuite)
+```
+### Using ProxSuite with CMake
+If you want to use ProxSuite with CMake, the following tiny example should help you:
+```cmake
+cmake_minimum_required(VERSION 3.10)
+
+project(Example CXX)
+find_package(proxsuite REQUIRED)
+set(CMAKE_CXX_STANDARD 17) # set(CMAKE_CXX_STANDARD 14) will work too
+
+add_executable(example example.cpp)
+target_link_libraries(example PUBLIC proxsuite::proxsuite)
+
+# Vectorization support via SIMDE and activated by the compilation options '-march=native' or `-mavx2 -mavx512f`
+add_executable(example_with_full_vectorization_support example.cpp)
+target_link_libraries(example_with_full_vectorization_support PUBLIC proxsuite::proxsuite-vectorized)
+target_compile_options(example_with_full_vectorization_support PUBLIC "-march=native")
+```
+If you have compiled ProxSuite with the vectorization support, you might also use the CMake target `proxsuite::proxsuite-vectorized` to also link against SIMDE.
+Don't forget to use `-march=native` for getting the best performance.
+
+## **ProxQP**
+
+The **ProxQP** algorithm is a numerical optimization approach for solving quadratic programming problems of the form:
+
+$$
+\begin{align}
+\min_{x} &  ~\frac{1}{2}x^{T}Hx+g^{T}x \\
+\text{s.t.} & ~A x = b \\
+& ~l \leq C x \leq u
+\end{align}
+$$
+
+where $x \in \mathbb{R}^n$ is the optimization variable. The objective function is defined by a positive semidefinite matrix $H \in \mathcal{S}^n_+$ and a vector $g \in \mathbb{R}^n$. The linear constraints are defined by the equality-contraint matrix $A \in \mathbb{R}^{n_\text{eq} \times n}$ and the inequality-constraint matrix $C \in \mathbb{R}^{n_\text{in} \times n}$ and the vectors $b \in \mathbb{R}^{n_\text{eq}}$, $l \in \mathbb{R}^{n_\text{in}}$ and $u \in \mathbb{R}^{n_\text{in}}$ so that $b_i \in \mathbb{R},~ \forall i = 1,...,n_\text{eq}$ and $l_i \in \mathbb{R} \cup \{ -\infty \}$ and $u_i \in \mathbb{R} \cup \{ +\infty \}, ~\forall i = 1,...,n_\text{in}$.
+
+### Citing **ProxQP**
+
+If you are using **ProxQP** for your work, we encourage you to [cite the related paper](https://hal.inria.fr/hal-03683733/file/Yet_another_QP_solver_for_robotics_and_beyond.pdf/).
+
+### Numerical benchmarks
+
+The numerical benchmarks of **ProxQP** against other commercial and open-source solvers are available [here](https://github.com/Simple-Robotics/proxqp_benchmark).
+
+For dense Convex Quadratic Programs with inequality and equality constraints, when asking for relatively high accuracy (e.g., 1e-6), one obtains the following results.
+
+<p align="center">
+  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/time_series_barplot_Random Mixed QP_dense_eps_abs_1e-6.jpg" width="600" alt="Random Mixed QP_dense_eps_abs_1e-6" align="center"/>
+</p>
+
+On the y-axis, you can see timings in seconds, and on the x-axis dimension wrt to the primal variable of the random Quadratic problems generated (the number of constraints of the generated problem is half the size of its primal dimension). For every dimension, the problem is generated over different seeds and timings are obtained as averages over successive runs for the same problems. This chart shows for every benchmarked solver and random Quadratic program generated, barplot timings including median (as a dot) and minimal and maximal values obtained (defining the amplitude of the bar). You can see that **ProxQP** is always below over solvers, which means it is the quickest for this test.
+
+For hard problems from the [Maros Meszaros testset](http://www.cuter.rl.ac.uk/Problems/marmes.shtml), when asking for high accuracy (e.g., 1e-9), one obtains the results below.
+
+<p align="center">
+  <img src="https://github.com/Simple-Robotics/proxsuite/raw/main/doc/images/performance_profile_maros_meszaros_problems_high_accuracy.jpg" width="600" alt="maros_meszaros_problems_high_accuracy" align="center"/>
+</p>
+
+The chart above reports the performance profiles of different solvers. It is classic for benchmarking solvers. Performance profiles correspond to the fraction of problems solved (on y-axis) as a function of certain runtime (on x-axis, measured in terms of a multiple of the runtime of the fastest solver for that problem). So the higher on the chart the better. You can see that **ProxQP** solves the quickest over 60% of the problems (i.e., for $\tau=1$), and that for solving about 90% of the problems, it is at most 2 times slower than the fastest solvers solving these problems (i.e., for $\tau\approx2$).
+
+*Note: All these results have been obtained with a 11th Gen Intel(R) Core(TM) i7-11850H @ 2.50GHz CPU.*
+
+## Installation procedure
+
+Please follow the installation procedure [here](https://github.com/Simple-Robotics/proxsuite/blob/main/doc/5-installation.md).
```

### html2text {}

```diff
@@ -1,13 +1,15 @@
-Metadata-Version: 2.1 Name: proxsuite Version: 0.3.6 Summary: Quadratic
-Programming Solver for Robotics and beyond. License-Expression: BSD-2-Clause
-Requires-Python: >= 3.7 Home-page: https://github.com/Simple-Robotics/proxsuite
-Project-URL: Repository, https://github.com/Simple-Robotics/proxsuite.git
-Requires-Dist: cmeel Requires-Dist: numpy Requires-Dist: scipy Description-
-Content-Type: text/markdown
+Metadata-Version: 2.1 Name: proxsuite Version: 0.3.7 Summary: Quadratic
+Programming Solver for Robotics and beyond. Requires-Python: >= 3.7 License-
+Expression: BSD-2-Clause License-File: LICENSE Home-page: https://github.com/
+Simple-Robotics/proxsuite Project-URL: Repository, https://github.com/Simple-
+Robotics/proxsuite.git Requires-Dist: cmeel Requires-Dist: numpy Requires-Dist:
+scipy Provides-Extra: build Requires-Dist: cmeel-eigen ; extra == "build"
+Requires-Dist: cmeel-simde ; extra == "build" Description-Content-Type: text/
+markdown
                                [Proxsuite Logo]
   [License] [Documentation] [CI_-_Linux/OSX/Windows_-_Conda] [PyPI_version]
                                 [Conda_version]
 **ProxSuite** is a collection of open-source, numerically robust, precise and
 efficient numerical solvers (e.g., LPs, QPs, etc.) rooted in revisited primal-
 dual proximal algorithms. Through **ProxSuite**, we aim to offer the community
 scalable optimizers that can deal with dense, sparse or matrix-free problems.
```

## Comparing `proxsuite-0.3.6.dist-info/RECORD` & `proxsuite-0.3.7.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,114 +1,115 @@
-cmeel.prefix/include/proxsuite/config.hpp,sha256=IH7Ma5bqP6fLMIhYzuos4M54VAhoIZKBGPVTXL2BueY,3067
-cmeel.prefix/include/proxsuite/deprecated.hpp,sha256=PjkcoMG6cF05g7gVwxIyhwIa0eV_9lz2zso6lDsmAeE,2158
-cmeel.prefix/include/proxsuite/fwd.hpp,sha256=mVshLalhV-XQs0Y9KbfPp_ZmaWgJG_P7oOl6nvfUcTY,1404
-cmeel.prefix/include/proxsuite/warning.hpp,sha256=kTMiopWNLcw0yLIiRjasYsCiPmIHLwDkW4cgRlVjp5o,1108
-cmeel.prefix/include/proxsuite/helpers/common.hpp,sha256=pO-5xDI96WnFU82kvaCFydSQlqo4U3GiQW9_jce2qUI,2292
-cmeel.prefix/include/proxsuite/helpers/instruction-set.hpp,sha256=wM5B-Jg8dAQ_8BuBcDxr1pll9xN8KQ1OGA5G7xlwR2k,8714
-cmeel.prefix/include/proxsuite/helpers/optional.hpp,sha256=3Vh0qNzcu1_acD5rnGNEPQbqDhhUjzkQqAVWNubKEEY,1156
-cmeel.prefix/include/proxsuite/helpers/tl-optional.hpp,sha256=Z6jTT3hNTJl6EcnUm8DYfJli0WNGIIg6vJWOMSPZMwA,73389
-cmeel.prefix/include/proxsuite/helpers/version.hpp,sha256=tdYJ2Lz3gdI7uasaMo6Wus4LmZ9raLROGy0CRXnJal8,811
-cmeel.prefix/include/proxsuite/linalg/dense/core.hpp,sha256=o7EqZEsbJwJI36P1svlQdeeSBJcaSzRWy0H1xtPyZJU,26100
-cmeel.prefix/include/proxsuite/linalg/dense/factorize.hpp,sha256=fvaRU5MwG_AJ-Bzgv_MfKkDD5ryQK1Lb1MO3lWgpFOs,9696
-cmeel.prefix/include/proxsuite/linalg/dense/ldlt.hpp,sha256=rJi2r8aVXeOaKZ6lhWPTO24qvYLv2ls2aRM3-qrK8-k,23225
-cmeel.prefix/include/proxsuite/linalg/dense/modify.hpp,sha256=wRNvkvRXFF6lEMRepJbm83P3awxQloWiSvh_dKL5dNw,8795
-cmeel.prefix/include/proxsuite/linalg/dense/solve.hpp,sha256=EX7zOHJEFpVID1gmOWRw1DmQ2aiF7B75ydErNuHte9g,915
-cmeel.prefix/include/proxsuite/linalg/dense/update.hpp,sha256=IPfVJXR-D3AmOyO22tGGuzPRAb3AvnUnVGgctYuSAyE,7791
-cmeel.prefix/include/proxsuite/linalg/sparse/core.hpp,sha256=sUipDsjvTC9hxBwVhTTmKo4Mb1inIhJEuLOg3br8-hQ,12865
-cmeel.prefix/include/proxsuite/linalg/sparse/factorize.hpp,sha256=VnnJMy0Woo-MIqgaaiWjxqrP7F3iye8DLmXFHUN3je0,36154
-cmeel.prefix/include/proxsuite/linalg/sparse/rowmod.hpp,sha256=lgP3nSbff6tnKz2RLG57xDpQfIRErP-ruJb9RKgJ_vk,15390
-cmeel.prefix/include/proxsuite/linalg/sparse/update.hpp,sha256=YO7gluZi6iTrrqQqvlk4H48YoAPDwX1bQ9GEGsWnquo,10394
-cmeel.prefix/include/proxsuite/linalg/veg/ref.hpp,sha256=oVGAKboyW3kSwV_EW1kxXGeoGo2OBut0pSs1G0L_z80,3032
-cmeel.prefix/include/proxsuite/linalg/veg/slice.hpp,sha256=oL-lOXcKPU3sjv-Y5HVw2-sXSwpVDHPpzX0MyuNrVNE,5354
-cmeel.prefix/include/proxsuite/linalg/veg/tuple.hpp,sha256=iD3RDvJ5dYfd78NsLsWul-EE17Xb1Okm0P5Bl82bJP4,27087
-cmeel.prefix/include/proxsuite/linalg/veg/vec.hpp,sha256=HVPOJJiU0NDbVPsP7WIL-82NxNzlErRIbAIpQLnL4NM,29817
-cmeel.prefix/include/proxsuite/linalg/veg/internal/assert_impl.hpp,sha256=N8CAEFOs6eyZwgQpxCMyBhPbDNOFVzCjKhjJxBFWbwg,788
-cmeel.prefix/include/proxsuite/linalg/veg/internal/collection_algo.hpp,sha256=0L04-Mg6ycrhFRf8wjT5vbUBpi8ocDlcqcGw_kpnygs,2444
-cmeel.prefix/include/proxsuite/linalg/veg/internal/dbg.hpp,sha256=u_umyxfr6gJHTgBlLJbK8_PDPhfSMUQPq_uhVS-LdlE,539
-cmeel.prefix/include/proxsuite/linalg/veg/internal/delete_special_members.hpp,sha256=8oMq5PcGRdnQqPLtP02SAQkXVJeIueajGtnChWIspec,2164
-cmeel.prefix/include/proxsuite/linalg/veg/internal/dyn_index.hpp,sha256=w47v-2Q1Hgf_TD_JjdKGCVH2Z6-SruakrbAVLkKU-zg,8861
-cmeel.prefix/include/proxsuite/linalg/veg/internal/epilogue.hpp,sha256=mMR4MzoyzlEgpqa8XhO48lQaFFlBc1HvdjlxDWkj0O0,710
-cmeel.prefix/include/proxsuite/linalg/veg/internal/fix_index.hpp,sha256=RL89aFso6nCHJItSrYemWdo5oOLRJ387diL1bWXdZrw,10323
-cmeel.prefix/include/proxsuite/linalg/veg/internal/has_asan.hpp,sha256=EOfSfy3N8Io3jpm8VHb1YVF-uGogl1joU00c7TCudDM,377
-cmeel.prefix/include/proxsuite/linalg/veg/internal/integer_seq.hpp,sha256=-4RHjuW9aaAefHqYIPm92-_RQpPczb1UZBfsPFqrk-g,6749
-cmeel.prefix/include/proxsuite/linalg/veg/internal/macros.hpp,sha256=6Z8PIaTWRO0NyV4ptanhAyIIJ-wATk-SdfO8kGayc6g,54801
-cmeel.prefix/include/proxsuite/linalg/veg/internal/narrow.hpp,sha256=qkdiCp9ZWfj3a7f98U5ENHuUeWoaJ3AixpNN91y4YF8,1251
-cmeel.prefix/include/proxsuite/linalg/veg/internal/preprocessor.hpp,sha256=-89S-MwtygJ9gPZ21ZxJgQIruLxroAiOi43-sj5LA2E,26076
-cmeel.prefix/include/proxsuite/linalg/veg/internal/prologue.hpp,sha256=kmZg15uJ99_mTqAGSv5Z6HURJfTz9SuP80-2q1aW6d4,5933
-cmeel.prefix/include/proxsuite/linalg/veg/internal/std.hpp,sha256=T6YeRUY-67IyjbsRblC9vOOaJMSvbJJP0Ra79eRoNWE,323
-cmeel.prefix/include/proxsuite/linalg/veg/internal/terminate.hpp,sha256=X6LH9gcmMqiVEX1wJ3FDqvWXFs8ukVEa3VJ2SPffPxs,502
-cmeel.prefix/include/proxsuite/linalg/veg/internal/typedefs.hpp,sha256=Nzcnm2__UxfiJI69dyODWLCVpw6qZgrwkAZs_61ZyYw,1120
-cmeel.prefix/include/proxsuite/linalg/veg/internal/external/hedley.ext.hpp,sha256=r10h6e671_ARTq31A3o433UfWheHznzOVa6pPQWld1w,91845
-cmeel.prefix/include/proxsuite/linalg/veg/internal/external/unhedley.ext.hpp,sha256=QxLNNs1HEdy62zukOGKs48qrZ2xCoZuSAxiVUb8P1sw,4401
-cmeel.prefix/include/proxsuite/linalg/veg/memory/address.hpp,sha256=YztQSnlAnaZl3i7ZOptNN2F5U8DvJgstfeSqiZVaD_A,2184
-cmeel.prefix/include/proxsuite/linalg/veg/memory/alloc.hpp,sha256=h3s4y6gOqEvToWtr0XHTI6NX9kg-MW6Rdz-zxIws2KU,10111
-cmeel.prefix/include/proxsuite/linalg/veg/memory/dynamic_stack.hpp,sha256=pxJHnTqp4bGtKKrFspTh0qIUXd61y5a2098D0On7p4g,13133
-cmeel.prefix/include/proxsuite/linalg/veg/memory/placement.hpp,sha256=7S7w5eLRNKr_Dbo05bM2v4aKNPWF1Nlds5mbxw2mAcM,5854
-cmeel.prefix/include/proxsuite/linalg/veg/memory/stack_alloc.hpp,sha256=iRNjGkWx1hrlQ1bl-n1__Vw6cOwsIFaMbO7Mj36-480,6799
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/alloc.hpp,sha256=HGAeVj85hDO3V18wOOs-V67ahLnluFUQ0nXX656jtT8,4920
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/assignable.hpp,sha256=m--WhB4YntUj7WTAuyey3YPbdzy7RJ3IOm8iboS-RvQ,1984
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/constructible.hpp,sha256=eFl3ajb8e58BxUklRrTrjzoKEgRYKiPRAQUUAZI3J-A,6798
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/core.hpp,sha256=4xrWWyHNdkUxnpAf90oaucH-KEk-dXIruvwD7vP1sA4,7909
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/invocable.hpp,sha256=VuxSo1qN_3IxLkK6WoH26oaajRS7Vxjj8WdeWZi0QvU,1606
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/primitives.hpp,sha256=6Hq4oJ3o7Ftb6onkA_3F0SZeMWS9Fdfgk2WfbqU8q5o,1627
-cmeel.prefix/include/proxsuite/linalg/veg/type_traits/tags.hpp,sha256=HJZGBezz1ixBfQ4xMJwxAphBoC3Cm9QoHYvwbvvm71w,1088
-cmeel.prefix/include/proxsuite/linalg/veg/util/assert.hpp,sha256=_lM4e14SkC_PvE3rGdXES4v36Q15XI3dtpMI2AMF6-o,1666
-cmeel.prefix/include/proxsuite/linalg/veg/util/dbg.hpp,sha256=TZeNJS0-azw7L84vPnonFrGrOrXajkwUMabsB_FbNo8,167
-cmeel.prefix/include/proxsuite/linalg/veg/util/defer.hpp,sha256=OlFsVjcVI_aqaNKFMZcKENZPaFUxo5Glk3ivYr-elEY,1436
-cmeel.prefix/include/proxsuite/linalg/veg/util/dynstack_alloc.hpp,sha256=pQDyaUWF52CmX80P3qS5P_NCQIfxXOdCyGpQ3csWdog,985
-cmeel.prefix/include/proxsuite/linalg/veg/util/get.hpp,sha256=ux_UH2LXqYvZlX6KCxsxHbV8uTUBFZQ1dl2mVsWhV8Y,4151
-cmeel.prefix/include/proxsuite/linalg/veg/util/index.hpp,sha256=S0Zl5ZvKVxxB9DF1R-zk5JDPrKpiwccmOJ6R5mbwvR8,179
-cmeel.prefix/include/proxsuite/linalg/veg/util/unreachable.hpp,sha256=PAJ6fVnDpL7a5A8wT7kNS931LAwt1r76fN4sQ1cFO0I,946
-cmeel.prefix/include/proxsuite/proxqp/results.hpp,sha256=57S96fUIujgmXTBP2WtvKw3NlQzmgU7vr8CRD2xULQc,5233
-cmeel.prefix/include/proxsuite/proxqp/settings.hpp,sha256=cQTqvsfjoqIlHAfBgVFuwQOzKGslGBVKlVmfPAZMx70,11192
-cmeel.prefix/include/proxsuite/proxqp/status.hpp,sha256=Jt9VY-_lR0vWDEVjvUwxxja2J6ZRRr4QsoxoAi3uaUY,1247
-cmeel.prefix/include/proxsuite/proxqp/timings.hpp,sha256=9TlPvfMDI_LsOrHZHmikYRoLDZMl46LTyp3AxndmJEk,1892
-cmeel.prefix/include/proxsuite/proxqp/dense/dense.hpp,sha256=H2vb7Gl3QXOSb0AXQqtdnK_KV7HpBhf7T-5HRW7JPJk,267
-cmeel.prefix/include/proxsuite/proxqp/dense/fwd.hpp,sha256=6fAuqNSnW5jFgomInpbxCXh3n_bntApfYBh_eaoKdyM,1365
-cmeel.prefix/include/proxsuite/proxqp/dense/helpers.hpp,sha256=7VG-gA2r1qvkHCwrP5pmhC7DYdMRQ2GBs_hdmZoa224,16045
-cmeel.prefix/include/proxsuite/proxqp/dense/linesearch.hpp,sha256=3oRxcGHJYMIVDRM9AkDS9hXPq0oyzmmNRL1qj9eEzhY,17874
-cmeel.prefix/include/proxsuite/proxqp/dense/model.hpp,sha256=vQP9o5euTbapx9YgrbHRSnT7XB14Iyn3lRNRRgu7KSQ,4072
-cmeel.prefix/include/proxsuite/proxqp/dense/solver.hpp,sha256=KgGjHrBbWyKUHjBr4mkIaNNXuef6P4Pa727WBhFFfl0,46602
-cmeel.prefix/include/proxsuite/proxqp/dense/utils.hpp,sha256=oWOdQOoAET-YdL_PTJcnGSV8avQK3zc_k-x9_cbB23g,15150
-cmeel.prefix/include/proxsuite/proxqp/dense/views.hpp,sha256=QzZxQIhr73S5TRv_t7qOVusM0GBhdPKctxSBTw-_OeI,37758
-cmeel.prefix/include/proxsuite/proxqp/dense/workspace.hpp,sha256=owKMOSSw3Sl7i4z-pr23FdBEw7ahx2jhA9MDNcPUdyc,6553
-cmeel.prefix/include/proxsuite/proxqp/dense/wrapper.hpp,sha256=zDmCgM_me1oRmNTZFKwJTHhOZ-ZLflB9AdoqMWQT8lg,17306
-cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/identity.hpp,sha256=cAv0slngHw6DDAUM2v3BeaIr-Nb9HvKoxSD6VuI_n7Q,2515
-cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/ruiz.hpp,sha256=5J6--aEpXgljuVr-X-sDp7Sj3b679XPiU_XMUjhohR4,17026
-cmeel.prefix/include/proxsuite/proxqp/sparse/fwd.hpp,sha256=e9exINUy94kfnyYMOvGtMSAFucBLv9xw554XCS9hfQI,1507
-cmeel.prefix/include/proxsuite/proxqp/sparse/helpers.hpp,sha256=t6DV1w4hBzZBVcT9Nr3TQFdrG6NQuNoGUdcrrRneWis,8974
-cmeel.prefix/include/proxsuite/proxqp/sparse/model.hpp,sha256=2kNTfaGeBJp3eOfmjxdHL-MuUll7KEwvz6Jxq4TPKgo,5900
-cmeel.prefix/include/proxsuite/proxqp/sparse/solver.hpp,sha256=wSmNohjRBuOPYJcPpvtsKNKNoBFihiF02y5FBrDrWGM,53641
-cmeel.prefix/include/proxsuite/proxqp/sparse/sparse.hpp,sha256=2tOMoMEHkVYy8PH7slBUWggWhXmYaPqrgEp9HbqAgRo,274
-cmeel.prefix/include/proxsuite/proxqp/sparse/utils.hpp,sha256=ngsF1EPXrP6vnJCReBy7aORziyWulmqWd-DXwthy2QI,25494
-cmeel.prefix/include/proxsuite/proxqp/sparse/views.hpp,sha256=wbhVzbfUrZ9-NrO01-yT4JmmRyvIsfoVFtiMC1voqf0,1802
-cmeel.prefix/include/proxsuite/proxqp/sparse/workspace.hpp,sha256=mQZyWayO_amVeOl7Wh_YBSrR3zbmqOcSbv7ohXNL9eY,26363
-cmeel.prefix/include/proxsuite/proxqp/sparse/wrapper.hpp,sha256=X4UEihUYDXUyTGZkjvCOibPtDFNA4Oo-9QUP8BVKE2c,28790
-cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/identity.hpp,sha256=c_sn6UMZMXMQgj3dMBc0lOhIfWZ2Rce786VAvmTIO60,2051
-cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/ruiz.hpp,sha256=g6HowCBRJiik-eRVYwkMX4t8WWURkFATePUwPLHhJsI,15487
-cmeel.prefix/include/proxsuite/proxqp/utils/prints.hpp,sha256=PRHV3owNopqzkBPKT-XXnuee_P_vFDTIUwgmQWRFXi0,1073
-cmeel.prefix/include/proxsuite/proxqp/utils/random_qp_problems.hpp,sha256=-rI2S9Ig2gUuQniRIFm1yYIonsX62UDdcyQ0qDN47Kc,17647
-cmeel.prefix/include/proxsuite/serialization/archive.hpp,sha256=P98qTgTNs_Kd4SL_87RbjQtWYtbWmmeUmjJKmXy27pc,6014
-cmeel.prefix/include/proxsuite/serialization/eigen.hpp,sha256=CrlScnajhVYOxQ9Ew1zhD4cFPamWn5-OXhHsG6CmWo0,2627
-cmeel.prefix/include/proxsuite/serialization/model.hpp,sha256=OdeFXAvQAO5-79fnYnyu9ccA7HbJgiXwSWCGaJc5-Bg,804
-cmeel.prefix/include/proxsuite/serialization/results.hpp,sha256=BxM5BwUPkfCIXkyXLaaXug-tdMDYKisa-Ty7UhZZIRY,1901
-cmeel.prefix/include/proxsuite/serialization/settings.hpp,sha256=w0ygYuT9nz-FnzBxc0QS7bstsIk1isRBC24ZSGBt8GE,2233
-cmeel.prefix/include/proxsuite/serialization/wrapper.hpp,sha256=z-0jNBeXHtSAa6f0wAhhma7Boi-l-fInPZyxc5zWNaE,538
-cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake,sha256=8lVzDKWNFovSW5BBCcUm8w8ljgxWHZUDBaOaeakCSRM,6307
-cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake,sha256=k5bHG1u4lafjiJgRwFERNw7idEMt2BFA2vruRikVC0A,2878
-cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-release.cmake,sha256=sQgxU9NkD7OdfizUmI5ceJpDvDAwjIFjlbzLM5XfvkQ,1018
-cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake,sha256=RUBcGxhaoRaX4i7ZHpviRNk2YT23aJ4n-3Ljbg6rIUc,4567
-cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake,sha256=ZXeTsvYyFru-xqjBEGfRSz367bftJrw96IdHNt7peMg,1035
-cmeel.prefix/lib/pkgconfig/proxsuite.pc,sha256=NpUBvu7-c663PYWqGbhhLbLIPvM4QE5rZIibn4FqaTo,541
-cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py,sha256=RkY6Funmhu1880nwh0X4Jv7zO7pnER6wBR6H8jjhjxs,1109
-cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.so,sha256=Mw2fo07JwpWdXXRCMd9zYNELnAPSdle_jKWcWLlprcc,259392
-cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.so,sha256=HTwk9gskGwliL1ijs11R1fBU-O12pOoGCUPCbTl9HAo,1411400
-cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.so,sha256=275hEzpdUP6vWathF35QjOEphi1xnur-El3jCWaoCWs,1532128
-cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.so,sha256=sjlyTu4sP25tF7-pZhnUiByOTN8ZgHY4WpCsia6qFfs,1598968
+cmeel.prefix/include/proxsuite/config.hpp,sha256=tzMadddxp6glmDIW_wnlwwrJ7hFS00lEAXFsYnQSkYM,3135
+cmeel.prefix/include/proxsuite/deprecated.hpp,sha256=H_OzAoaDq39DHrf68e7djP1fIQxZyw1C0dqpvK68LSg,2214
+cmeel.prefix/include/proxsuite/fwd.hpp,sha256=CaTke3j0dbWeF04YK5NFc72Xls6z_4KxmQJkuUC5YgM,1456
+cmeel.prefix/include/proxsuite/warning.hpp,sha256=18bpzJMLta8NdnKk5dDQqBgvO9sJoE21M7K6uomY9Gs,1143
+cmeel.prefix/include/proxsuite/helpers/common.hpp,sha256=Z5C1l-7_3yrq64wyMQ-ZEwkwbUy3FvfIoMcR4QxTJ_c,2362
+cmeel.prefix/include/proxsuite/helpers/instruction-set.hpp,sha256=WJFs5_vbeWGtzI5vLLB0h9DGB2H8ogA65gQ2Ud1MljE,8989
+cmeel.prefix/include/proxsuite/helpers/optional.hpp,sha256=txTuXlCIwxTl4EHzQbxGulo-rhCTuSTtLZbjyM-iE5c,1202
+cmeel.prefix/include/proxsuite/helpers/tl-optional.hpp,sha256=UQ2Omqc9nZ4vzruarrB4-ZYwOyvQdYCx58-RhFYHiUE,75861
+cmeel.prefix/include/proxsuite/helpers/version.hpp,sha256=_nPGSWSLkFTKFHzehqvSpbF5gWFtsE-zyooXGRrnQyY,850
+cmeel.prefix/include/proxsuite/linalg/dense/core.hpp,sha256=GQyRN8ibMkvzXzkHqzgBhAv4dWRmbwuw3A6qr-Hl4SY,26959
+cmeel.prefix/include/proxsuite/linalg/dense/factorize.hpp,sha256=-i4YW82btGzDvukO98ADDfCBMhw4oIj0LzBcxwg2-z8,10071
+cmeel.prefix/include/proxsuite/linalg/dense/ldlt.hpp,sha256=ZpENkfDf2iBp39ziSiNQJQzb9ieiPtzPHLHDB_rjcVs,24042
+cmeel.prefix/include/proxsuite/linalg/dense/modify.hpp,sha256=iWLjf4NcciCc0pYU5NWHyrzUmX_dugNYg35NSH8cCqY,9128
+cmeel.prefix/include/proxsuite/linalg/dense/solve.hpp,sha256=nEwlTV96wTdO2uerD-ymKLOlbiR64tzyijqGEZDHUc4,953
+cmeel.prefix/include/proxsuite/linalg/dense/update.hpp,sha256=0X__ZHINlIyTECDUY3c1lom-prL_WrgQskP-qZYAZG0,8121
+cmeel.prefix/include/proxsuite/linalg/sparse/core.hpp,sha256=-YKQv5fTMBnmYK2kXphShGqLAALEfRNzQd2zochgkto,13396
+cmeel.prefix/include/proxsuite/linalg/sparse/factorize.hpp,sha256=iCu47c5zfJeOdjPGVRwTOziUE_6QABw_Eg95EZz2mOo,37457
+cmeel.prefix/include/proxsuite/linalg/sparse/rowmod.hpp,sha256=FLBHjNCdiQXb91bmwtggYra2knToS0c20XtkXhbPQKA,15833
+cmeel.prefix/include/proxsuite/linalg/sparse/update.hpp,sha256=xEs_lNGegQ15Uf-ahdcuNNiMDj37q7PHiwIm6Di8GHA,10742
+cmeel.prefix/include/proxsuite/linalg/veg/ref.hpp,sha256=jQb00LWAwajjBI0Za6KTJGLfikSm08D8xkqNDcZXIeg,3180
+cmeel.prefix/include/proxsuite/linalg/veg/slice.hpp,sha256=U0Ie4_3zyy47vLN0FdWLzVXzvn7qKxgBPPGiInMcS38,5594
+cmeel.prefix/include/proxsuite/linalg/veg/tuple.hpp,sha256=GRZSXDdJ-mtFTwkCqxYW42rQMjkbVgqV8e7wC4y5v_M,27963
+cmeel.prefix/include/proxsuite/linalg/veg/vec.hpp,sha256=G4z6qIaG1PTksTUz7uK1J-j6-wFlBmlZ5jrQy9xj_mg,30851
+cmeel.prefix/include/proxsuite/linalg/veg/internal/assert_impl.hpp,sha256=s982TrOzgH5YI9AiarzeJLb7_5yPqUdY_273XPj8btU,808
+cmeel.prefix/include/proxsuite/linalg/veg/internal/collection_algo.hpp,sha256=kRf7qwdd-vEdy3B1qO4hBxJd1TSxeTRdSTDCDNt450o,2537
+cmeel.prefix/include/proxsuite/linalg/veg/internal/dbg.hpp,sha256=tNBtkRya8Sy4kO_KUoaO5zIYNn_OefxEJYd_e7VVH5k,554
+cmeel.prefix/include/proxsuite/linalg/veg/internal/delete_special_members.hpp,sha256=PhyI0ZOzzjjWgNEaJg1lhcycFkbRzTGi3d30lMqUFdY,2241
+cmeel.prefix/include/proxsuite/linalg/veg/internal/dyn_index.hpp,sha256=If4dgLXjfXobQjxEAmdr_-NXWR9_XCSAfMTT8SxHxHA,9153
+cmeel.prefix/include/proxsuite/linalg/veg/internal/epilogue.hpp,sha256=dJKYaffdC70zHDsfKfb1X9MU09i3xUMKDrs_PbKpFLU,741
+cmeel.prefix/include/proxsuite/linalg/veg/internal/fix_index.hpp,sha256=odT6qCJbmt6EQeXiXlH2T9Up0rqXtc-eTafaiFe7JYM,10663
+cmeel.prefix/include/proxsuite/linalg/veg/internal/has_asan.hpp,sha256=btHPLn2r7KPvV2wYG95PAmKbdG1ExZYCxQZ5RYiKOIU,394
+cmeel.prefix/include/proxsuite/linalg/veg/internal/integer_seq.hpp,sha256=Ejip-2FTUegmKoXDPeZe--3zclQOmIU60J2ZSsc10Wo,6997
+cmeel.prefix/include/proxsuite/linalg/veg/internal/macros.hpp,sha256=aYQTNUoKG45irLwLsDAHDT9rUaZeOfs3GsEpRyAvG7E,56354
+cmeel.prefix/include/proxsuite/linalg/veg/internal/narrow.hpp,sha256=Uvi5cumd-M6ebVMmrIQdOifFFDtyFTU-WK1pfX9soWM,1297
+cmeel.prefix/include/proxsuite/linalg/veg/internal/preprocessor.hpp,sha256=2GHuZPfpvVf0GSuqiAE5dyIYIJSxwOqwGeW8r_jCVaw,26510
+cmeel.prefix/include/proxsuite/linalg/veg/internal/prologue.hpp,sha256=YjbIr6GPEB571BPZOjnx9vgCMfLV2g47kKma7auhGYM,6090
+cmeel.prefix/include/proxsuite/linalg/veg/internal/std.hpp,sha256=L3QHFeTHQ64bIyRiycqwENKx5b63ju4xfBH3GTpVO3k,336
+cmeel.prefix/include/proxsuite/linalg/veg/internal/terminate.hpp,sha256=bbn9tPxnIJ-kZ4m7CTfqiR63QDUKcc7nxPTJhSzx3gw,524
+cmeel.prefix/include/proxsuite/linalg/veg/internal/typedefs.hpp,sha256=o1q5KgIihYuq322-Y0ruBTUQ3ylyYVWSOP6fsOzNRvA,1178
+cmeel.prefix/include/proxsuite/linalg/veg/internal/external/hedley.ext.hpp,sha256=iai1Wk5CmEcdsFDK8PjQLR9NFA9TM3aOfht0ZV6Ynxo,93934
+cmeel.prefix/include/proxsuite/linalg/veg/internal/external/unhedley.ext.hpp,sha256=BVSgqDqMUxPcad2myLYuCfhicBHTu8f_qxXpw7Kwibg,4549
+cmeel.prefix/include/proxsuite/linalg/veg/memory/address.hpp,sha256=ME9EHJPn6R9E_fbhKcZN5Zrkg-7sR5ZIpKnZk7ARTTY,2281
+cmeel.prefix/include/proxsuite/linalg/veg/memory/alloc.hpp,sha256=tIBrJvwB-eikqTXNAx7kHhpG7BZWUYQEw5ecER4RuPo,10463
+cmeel.prefix/include/proxsuite/linalg/veg/memory/dynamic_stack.hpp,sha256=2CYZYs-nzZEjRaOxT7ETbO-zzQdSnqKg9hSwsxjNQ40,13637
+cmeel.prefix/include/proxsuite/linalg/veg/memory/placement.hpp,sha256=vah4GJGxHL91m8XkNGKG2gbGScz1XwtBqFYNhs3uXuw,6056
+cmeel.prefix/include/proxsuite/linalg/veg/memory/stack_alloc.hpp,sha256=v3DBL1awxwOAUEKs4xJTFkhxZdAoWpJKArlUu46mAfY,7038
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/alloc.hpp,sha256=tUkUp1oHQycQuqg9XV1IGkaaXaW3ac8DgBqhVKW6Zbs,5089
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/assignable.hpp,sha256=aqZVN8-QDWMj9AX4RbRyINBNiib72tfbZL6GA4gSWFk,2037
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/constructible.hpp,sha256=eieVuwCs6vGverjhMUfBJuWXAIF3d90jvC0T5ilMmKI,7015
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/core.hpp,sha256=y5iI8QvWoHCyif7Ftmi8eFlQc8ApeGYgucJCHZMsPzw,8207
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/invocable.hpp,sha256=GrRUdBgrTRpaLLq5B5vToolorKNFWBecHJz3Igrwuj8,1651
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/primitives.hpp,sha256=y0A5a9vY5lNowyDEaB2ildr5P79TIyjC0JZFWm5TBcU,1670
+cmeel.prefix/include/proxsuite/linalg/veg/type_traits/tags.hpp,sha256=QtPDBa8laY8i8_JyE41z1aYywm92BjMFWkUjfp7ZbaA,1135
+cmeel.prefix/include/proxsuite/linalg/veg/util/assert.hpp,sha256=c3aDqtnrHzO-Zm9jPpbIxCJjBACaxqhwilVA5WZxZqY,1714
+cmeel.prefix/include/proxsuite/linalg/veg/util/dbg.hpp,sha256=xGI41wBPaMNsk3-cA5qsXN8zJikqZsaopwQxe92OaZw,173
+cmeel.prefix/include/proxsuite/linalg/veg/util/defer.hpp,sha256=7PqjKwmFHOk2rgtTmEMW2rUY8bEhU9PlLxtp6J5qWxo,1493
+cmeel.prefix/include/proxsuite/linalg/veg/util/dynstack_alloc.hpp,sha256=G-DPxJvJ4pswaWs1xyRo-bjcWxIpzCc7DrgmJ5KcfNc,1004
+cmeel.prefix/include/proxsuite/linalg/veg/util/get.hpp,sha256=PRLYyQ6MJ5KtrckWDp0Y8KbZ7pJhjkOBDdGHa6wvo3g,4299
+cmeel.prefix/include/proxsuite/linalg/veg/util/index.hpp,sha256=Sdcu6OD2VLYWnTtFQVU7EPw4320Fv_Pt1DnxoO9hQKc,185
+cmeel.prefix/include/proxsuite/linalg/veg/util/unreachable.hpp,sha256=dtgebuJ9LlAEkqfUFLbeBmT59fFXHXUWgnIL5lGtNro,987
+cmeel.prefix/include/proxsuite/proxqp/results.hpp,sha256=97wsTDrWAU4RpWjWXjmv4EeJMGvccIzchaMxvYTBcbA,5445
+cmeel.prefix/include/proxsuite/proxqp/settings.hpp,sha256=NQSWb6yEDV09wrVaKxf9U_H9lBk_TMWGKVRZ7kfnh-c,11494
+cmeel.prefix/include/proxsuite/proxqp/status.hpp,sha256=ARmDj1_2h62ZB5603qD2RPD9G74rIG1beyPc9DGbaUg,1293
+cmeel.prefix/include/proxsuite/proxqp/timings.hpp,sha256=7LTQbnkI6OMeKBSR7CFW8MzF41nwbwdhiRYgJUvWRB4,1993
+cmeel.prefix/include/proxsuite/proxqp/dense/dense.hpp,sha256=tKxDATZISZgnBCDIAFSmu4NzhOnSVJdt3WuNVawezRY,277
+cmeel.prefix/include/proxsuite/proxqp/dense/fwd.hpp,sha256=p6mLbaoAJbCtLPtLuFpcM7Qu-V6OAD-8ttdxsalOP94,1420
+cmeel.prefix/include/proxsuite/proxqp/dense/helpers.hpp,sha256=LidPUUyj-wJW-LWBQ3AuPyo01tTOD8moV9hW-QXpipo,16565
+cmeel.prefix/include/proxsuite/proxqp/dense/linesearch.hpp,sha256=UMn-g_lJweLGvApW7PQtp4wx1_VcUhE9Z2y6G5Blcj8,18391
+cmeel.prefix/include/proxsuite/proxqp/dense/model.hpp,sha256=vvRn_hxCrYgoJ2MaA8utUIEE9AkOURHIsgFn3OvgMtE,4219
+cmeel.prefix/include/proxsuite/proxqp/dense/solver.hpp,sha256=ysl5vXRwCC0FIErrdyMvdNjVYUeUDan7aKWrZrt6I3c,47932
+cmeel.prefix/include/proxsuite/proxqp/dense/utils.hpp,sha256=l2ezE2oh8_k9dvqanUco2qHIEIKHW2WHoPchQYAqi8k,15565
+cmeel.prefix/include/proxsuite/proxqp/dense/views.hpp,sha256=NjbJFM1RUeM_48D81NJ_xa9mmlVRbYybmsGEnzYcnIY,39206
+cmeel.prefix/include/proxsuite/proxqp/dense/workspace.hpp,sha256=1cOVk75XqRL7KzV9TI5p8HsberdDRZXEjzj0WroKztk,6817
+cmeel.prefix/include/proxsuite/proxqp/dense/wrapper.hpp,sha256=jcD4QLokte4kISqUtZjHXy3EfDEGWFRNjiiN_SjCD3M,17797
+cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/identity.hpp,sha256=nxfUtbUO6HMQ5tskP8ThUdNib7bNnTGVktTMwMqayM0,2628
+cmeel.prefix/include/proxsuite/proxqp/dense/preconditioner/ruiz.hpp,sha256=Kqw2ORi8pHDOyxcqgmSa5etnwIaNcGQo_rl9o4kFM6Q,17597
+cmeel.prefix/include/proxsuite/proxqp/sparse/fwd.hpp,sha256=iCy6-O8UXFjZNSyLAVfWbQdly9WylQBhbRi1VzI03Kc,1565
+cmeel.prefix/include/proxsuite/proxqp/sparse/helpers.hpp,sha256=8bGOcmB11Hf_JJPEcwdZ_9zNCoXF8RVAA4agpReDigQ,9283
+cmeel.prefix/include/proxsuite/proxqp/sparse/model.hpp,sha256=6Elrpv65uhkDgWU1tmaVKo2LSUIKmFYdtPkvjLskOp8,6128
+cmeel.prefix/include/proxsuite/proxqp/sparse/solver.hpp,sha256=2v54ggKA1H6ZrUBzP5XEDiHJk98ArkfT3nB5MS1Iwqs,55082
+cmeel.prefix/include/proxsuite/proxqp/sparse/sparse.hpp,sha256=FxUJPlYyS-fJKrEumZmwLhv8wJ0CxR0gSHmBNT8mgww,284
+cmeel.prefix/include/proxsuite/proxqp/sparse/utils.hpp,sha256=cgCpWpU9FRK604vB_eI3edQeKSmNtLmLiz0EbcK2i30,26309
+cmeel.prefix/include/proxsuite/proxqp/sparse/views.hpp,sha256=S9408cK6oPymKaPgTTMogThWk12UbFUvdBKLhvgF1zM,1865
+cmeel.prefix/include/proxsuite/proxqp/sparse/workspace.hpp,sha256=i3cfk-v_cTRsbNg6rP9lPXtEk59Z-X7JMw7p3r0d5Xw,27153
+cmeel.prefix/include/proxsuite/proxqp/sparse/wrapper.hpp,sha256=sa91I7UTkULSeD7UEubudADwdzJyQz20IEixNNzIR5k,29562
+cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/identity.hpp,sha256=wGX0IEKTFjaC4cmyVGYZQgQRNFuy6z58xmtCELR7bTY,2115
+cmeel.prefix/include/proxsuite/proxqp/sparse/preconditioner/ruiz.hpp,sha256=f-aJqELQ99RE-Phv4_jIqSFPdzMKbq97QJoejPYBWig,16056
+cmeel.prefix/include/proxsuite/proxqp/utils/prints.hpp,sha256=o-5awNu86CMleT6SmwXsGs-qb1ojwrE5Q6P8UHIZMNA,1120
+cmeel.prefix/include/proxsuite/proxqp/utils/random_qp_problems.hpp,sha256=pT8n0IvjL7pXnMl1o5WmS5IbpalLbABLbpwYZ_bC9V8,18316
+cmeel.prefix/include/proxsuite/serialization/archive.hpp,sha256=B4-v_mE9iO2aG8JAVGudY8VrvMWiyUMIISKZOuU0LMA,6245
+cmeel.prefix/include/proxsuite/serialization/eigen.hpp,sha256=NFwu4cIu-CNANrijLLDplhMIDA6LFiarDUXmXMm0Fbk,2734
+cmeel.prefix/include/proxsuite/serialization/model.hpp,sha256=rq5aEFSfsLQOOsX0iGb_Of41ySq0VrOpozIOVKUlwxE,838
+cmeel.prefix/include/proxsuite/serialization/results.hpp,sha256=sFVhjvLe1XS8onPZCnbEBlDmS5MgjoMU1AO13huyIRg,1975
+cmeel.prefix/include/proxsuite/serialization/settings.hpp,sha256=OBNf1TjiAncl_JWSU1zpZPJGnjDKU_O9j-IMBsj0wPU,2293
+cmeel.prefix/include/proxsuite/serialization/wrapper.hpp,sha256=OlacdTD5Kc8uxtMN0mfgu9V62vL0v_cuQlYYT3s2Vzc,562
+cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfig.cmake,sha256=l7DZLwCkiI91sdJ7Ab7MT9oq-rFdIqOeSpf6LxjbhQg,6484
+cmeel.prefix/lib/cmake/proxsuite/proxsuiteConfigVersion.cmake,sha256=Dz4mvbUYLoOOaV1X48pXOtMER9wjtGROHVsmzwTLnWM,2827
+cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets-debug.cmake,sha256=3GozHJXRYmcufwTGhQeE7OUT_msQXnBnYfhXF3MTlkY,1093
+cmeel.prefix/lib/cmake/proxsuite/proxsuiteTargets.cmake,sha256=0-wlestV9Ext-GSl1_P6f5RnxHoim6O9Wr6wO1_4HN8,4766
+cmeel.prefix/lib/cmake/proxsuite/find-external/Simde/FindSimde.cmake,sha256=hRXLKwziG8vWo2GVA6cc_6ODZJdllJ4PzDw6zwO3vXE,1074
+cmeel.prefix/lib/pkgconfig/proxsuite.pc,sha256=xS7sejWcWSLBulMyBmUyhYG2cX53QQ-5ZFLYWfPDV4M,563
+cmeel.prefix/lib/python3.9/site-packages/proxsuite/__init__.py,sha256=ujMZHtXZN0zOSwcHuj7UM2bozkrHhpr80c4QkA4xVwY,1149
+cmeel.prefix/lib/python3.9/site-packages/proxsuite/instructionset.pyd,sha256=A8LADhLmgI64a9CmSgcRjCoEmeNq5Xe0fnwUAlOa_X8,616448
+cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap.pyd,sha256=qorJATYnXCHLRsfAJWIbWHLH13kM5yuh_WCihCSTqeA,5119488
+cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx2.pyd,sha256=UbIc5_7RzM7sLM26q68YaTq3lFF-OSFFT8s0fnGETBw,5143040
+cmeel.prefix/lib/python3.9/site-packages/proxsuite/proxsuite_pywrap_avx512.pyd,sha256=ULCOYnQ5lkQpey2GlxCvD7uIiTsKDa1QI7Yw1hUdDFU,5157888
 cmeel.prefix/share/ament_index/resource_index/packages/proxsuite,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cmeel.prefix/share/proxsuite/package.xml,sha256=D39AznuxphX67yIUXJ-oz6u2D1Kpi_WqhVyozRmNr7g,1774
+cmeel.prefix/share/proxsuite/package.xml,sha256=NwdEVMNDN8fl8dnh-FV4Q6mFvHXubL7Rgt5oMscNXx4,1840
 cmeel.prefix/share/proxsuite/hook/ament_prefix_path.dsv,sha256=ZLwqQ4MXIgnWq81BeVZXJXsJvGDAlg3rFooKRZA-V9A,40
-cmeel.prefix/share/proxsuite/hook/python_path.dsv,sha256=--96YKWkjwdo77nqp8Rs6-j8vdxmm4DcmhFKPkWATGU,60
-proxsuite-0.3.6.dist-info/METADATA,sha256=SWY4xUmY52URudJHHHTy0tFwlO14y8-Fc9OMVJOuN0I,9886
-proxsuite-0.3.6.dist-info/WHEEL,sha256=mJGUJodhd761hykDvbkDV72cNqsUKNW6CiUv_N0jNEs,120
-proxsuite-0.3.6.dist-info/top_level.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-proxsuite-0.3.6.dist-info/RECORD,,
+cmeel.prefix/share/proxsuite/hook/python_path.dsv,sha256=UXwPujvPm9mFfC5nzFsZEe67ye3xy-E3Q9dAkDfLd0s,60
+proxsuite-0.3.7.dist-info/license/LICENSE,sha256=38t5txroKTFMIt-rHAmD5ixbgRTIxmQUJZkT37-9HCc,1345
+proxsuite-0.3.7.dist-info/METADATA,sha256=zGSm4kfxeFs8ywO47Wj2wiiJ-2VeuH9lD5Darr0DsgM,10186
+proxsuite-0.3.7.dist-info/WHEEL,sha256=tsOPFgp4Y6Tliz3HE2isC1xju5Y0fYTI9x1wXtV1ECI,105
+proxsuite-0.3.7.dist-info/top_level.txt,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+proxsuite-0.3.7.dist-info/RECORD,,
```

