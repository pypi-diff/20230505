# Comparing `tmp/qrisp-0.0.15.tar.gz` & `tmp/qrisp-0.0.16.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "qrisp-0.0.15.tar", last modified: Wed Apr 26 12:26:13 2023, max compression
+gzip compressed data, was "qrisp-0.0.16.tar", last modified: Fri May  5 09:23:02 2023, max compression
```

## Comparing `qrisp-0.0.15.tar` & `qrisp-0.0.16.tar`

### file list

```diff
@@ -1,164 +1,164 @@
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.577317 qrisp-0.0.15/
--rw-rw-rw-   0        0        0    14474 2023-04-24 14:39:30.000000 qrisp-0.0.15/LICENSE
--rw-rw-rw-   0        0        0      638 2023-04-26 12:26:13.577317 qrisp-0.0.15/PKG-INFO
--rw-rw-rw-   0        0        0       48 2022-05-11 14:39:01.000000 qrisp-0.0.15/README.md
--rw-rw-rw-   0        0        0      108 2023-04-24 15:55:10.000000 qrisp-0.0.15/pyproject.toml
--rw-rw-rw-   0        0        0      588 2023-04-26 12:26:13.580676 qrisp-0.0.15/setup.cfg
--rw-rw-rw-   0        0        0     1668 2023-04-24 16:35:17.000000 qrisp-0.0.15/setup.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.022115 qrisp-0.0.15/src/
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.058523 qrisp-0.0.15/src/qrisp/
--rw-rw-rw-   0        0        0      705 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/__init__.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.106862 qrisp-0.0.15/src/qrisp/arithmetic/
--rw-rw-rw-   0        0        0    33345 2023-04-25 09:24:44.000000 qrisp-0.0.15/src/qrisp/arithmetic/SBP_arithmetic.py
--rw-rw-rw-   0        0        0      703 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/arithmetic/__init__.py
--rw-rw-rw-   0        0        0     7316 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/arithmetic/comparisons.py
--rw-rw-rw-   0        0        0     5374 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/arithmetic/incrementation.py
--rw-rw-rw-   0        0        0    26518 2023-04-24 21:55:26.000000 qrisp-0.0.15/src/qrisp/arithmetic/matrix_multiplication.py
--rw-rw-rw-   0        0        0     3293 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/arithmetic/poly_tools.py
--rw-rw-rw-   0        0        0    11041 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/arithmetic/ripple_carry_adder.py
--rw-rw-rw-   0        0        0    16527 2023-04-24 21:55:00.000000 qrisp-0.0.15/src/qrisp/arithmetic/ripple_division.py
--rw-rw-rw-   0        0        0     1166 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/arithmetic/ripple_mult.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.148966 qrisp-0.0.15/src/qrisp/circuit/
--rw-rw-rw-   0        0        0      745 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/circuit/__init__.py
--rw-rw-rw-   0        0        0     1239 2023-04-24 21:55:26.000000 qrisp-0.0.15/src/qrisp/circuit/clbit.py
--rw-rw-rw-   0        0        0     5939 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/circuit/controlled_operations.py
--rw-rw-rw-   0        0        0     3776 2023-04-24 21:55:28.000000 qrisp-0.0.15/src/qrisp/circuit/instruction.py
--rw-rw-rw-   0        0        0      504 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/circuit/library.py
--rw-rw-rw-   0        0        0    20068 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/circuit/multi_cx.py
--rw-rw-rw-   0        0        0    28263 2023-04-25 11:57:49.000000 qrisp-0.0.15/src/qrisp/circuit/operation.py
--rw-rw-rw-   0        0        0    68568 2023-04-25 12:05:38.000000 qrisp-0.0.15/src/qrisp/circuit/quantum_circuit.py
--rw-rw-rw-   0        0        0     1532 2023-04-25 09:12:59.000000 qrisp-0.0.15/src/qrisp/circuit/qubit.py
--rw-rw-rw-   0        0        0     5374 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/circuit/standard_operations.py
--rw-rw-rw-   0        0        0     5457 2023-04-24 21:55:11.000000 qrisp-0.0.15/src/qrisp/circuit/transpiler.py
--rw-rw-rw-   0        0        0     4163 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/circuit/transpiler_old.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.184730 qrisp-0.0.15/src/qrisp/core/
--rw-rw-rw-   0        0        0      774 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/core/__init__.py
--rw-rw-rw-   0        0        0    34329 2023-04-25 12:10:42.000000 qrisp-0.0.15/src/qrisp/core/compilation.py
--rw-rw-rw-   0        0        0    38448 2023-04-24 21:55:23.000000 qrisp-0.0.15/src/qrisp/core/library.py
--rw-rw-rw-   0        0        0    33439 2023-04-26 12:08:04.000000 qrisp-0.0.15/src/qrisp/core/quantum_array.py
--rw-rw-rw-   0        0        0     9295 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/core/quantum_dictionary.py
--rw-rw-rw-   0        0        0    41602 2023-04-24 14:38:09.000000 qrisp-0.0.15/src/qrisp/core/quantum_session.py
--rw-rw-rw-   0        0        0    48739 2023-04-25 09:14:41.000000 qrisp-0.0.15/src/qrisp/core/quantum_variable.py
--rw-rw-rw-   0        0        0    13782 2023-04-24 21:55:23.000000 qrisp-0.0.15/src/qrisp/core/session_merging_tools.py
--rw-rw-rw-   0        0        0      641 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/default_backend.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.215287 qrisp-0.0.15/src/qrisp/environments/
--rw-rw-rw-   0        0        0     6672 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/environments/GMS_environment.py
--rw-rw-rw-   0        0        0      791 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/environments/__init__.py
--rw-rw-rw-   0        0        0    11065 2023-04-24 21:55:22.000000 qrisp-0.0.15/src/qrisp/environments/control_environment.py
--rw-rw-rw-   0        0        0     5697 2023-04-24 21:54:35.000000 qrisp-0.0.15/src/qrisp/environments/gate_wrap_environment.py
--rw-rw-rw-   0        0        0    26541 2023-04-24 21:55:22.000000 qrisp-0.0.15/src/qrisp/environments/quantum_conditionals.py
--rw-rw-rw-   0        0        0    15439 2023-04-24 21:54:42.000000 qrisp-0.0.15/src/qrisp/environments/quantum_environments.py
--rw-rw-rw-   0        0        0    20117 2023-04-24 21:55:26.000000 qrisp-0.0.15/src/qrisp/environments/quantum_inversion.py
--rw-rw-rw-   0        0        0     4008 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/environments/temp_var_environment.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.223271 qrisp-0.0.15/src/qrisp/grover/
--rw-rw-rw-   0        0        0      451 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/grover/__init__.py
--rw-rw-rw-   0        0        0    12659 2023-04-24 21:55:23.000000 qrisp-0.0.15/src/qrisp/grover/grover_tools.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.232409 qrisp-0.0.15/src/qrisp/interface/
--rw-rw-rw-   0        0        0      672 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/__init__.py
--rw-rw-rw-   0        0        0     8119 2023-04-24 14:42:14.000000 qrisp-0.0.15/src/qrisp/interface/backends.py
--rw-rw-rw-   0        0        0    13273 2023-04-25 11:46:06.000000 qrisp-0.0.15/src/qrisp/interface/circuit_converter.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.246842 qrisp-0.0.15/src/qrisp/interface/openapi_interface/
--rw-rw-rw-   0        0        0      857 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/openapi_interface/__init__.py
--rw-rw-rw-   0        0        0     1528 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/openapi_interface/backend_client.py
--rw-rw-rw-   0        0        0     3921 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/openapi_interface/backend_server.py
--rw-rw-rw-   0        0        0     1099 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/openapi_interface/interface_types.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.263807 qrisp-0.0.15/src/qrisp/interface/thrift_interface/
--rw-rw-rw-   0        0        0      624 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/__init__.py
--rw-rw-rw-   0        0        0     3406 2023-04-24 21:54:39.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/backend_client.py
--rw-rw-rw-   0        0        0     5847 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/backend_server.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.279033 qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/
--rw-rw-rw-   0        0        0    15406 2023-04-24 21:55:28.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/BackendService.py
--rw-rw-rw-   0        0        0      463 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/__init__.py
--rw-rw-rw-   0        0        0      790 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/constants.py
--rw-rw-rw-   0        0        0    26161 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/ttypes.py
--rw-rw-rw-   0        0        0      975 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/interface_types.py
--rw-rw-rw-   0        0        0     1692 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/interface/thrift_interface/stoppable_thrift_server.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.286498 qrisp-0.0.15/src/qrisp/iterators/
--rw-rw-rw-   0        0        0      479 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/iterators/__init__.py
--rw-rw-rw-   0        0        0     3967 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/iterators/qrange.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.302563 qrisp-0.0.15/src/qrisp/logic_synthesis/
--rw-rw-rw-   0        0        0      592 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/logic_synthesis/__init__.py
--rw-rw-rw-   0        0        0    19780 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/logic_synthesis/gray_synthesis.py
--rw-rw-rw-   0        0        0     2768 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/logic_synthesis/pprm_synthesis.py
--rw-rw-rw-   0        0        0    15620 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/logic_synthesis/truth_tables.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.317921 qrisp-0.0.15/src/qrisp/misc/
--rw-rw-rw-   0        0        0    17658 2023-04-24 21:55:27.000000 qrisp-0.0.15/src/qrisp/misc/GMS_tools.py
--rw-rw-rw-   0        0        0      488 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/misc/__init__.py
--rw-rw-rw-   0        0        0     4076 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/misc/depth_reduction.py
--rw-rw-rw-   0        0        0    60377 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/misc/utility.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.340210 qrisp-0.0.15/src/qrisp/qtypes/
--rw-rw-rw-   0        0        0      607 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/qtypes/__init__.py
--rw-rw-rw-   0        0        0     6397 2023-04-24 21:55:22.000000 qrisp-0.0.15/src/qrisp/qtypes/quantum_bool.py
--rw-rw-rw-   0        0        0     2239 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/qtypes/quantum_char.py
--rw-rw-rw-   0        0        0    28131 2023-04-25 09:38:48.000000 qrisp-0.0.15/src/qrisp/qtypes/quantum_float.py
--rw-rw-rw-   0        0        0     4976 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/qtypes/quantum_string.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.361545 qrisp-0.0.15/src/qrisp/quantum_network/
--rw-rw-rw-   0        0        0      624 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/__init__.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.364508 qrisp-0.0.15/src/qrisp/quantum_network/interface/
--rw-rw-rw-   0        0        0      410 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface/__init__.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.383691 qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/
--rw-rw-rw-   0        0        0    52890 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/QuantumNetworkService.py
--rw-rw-rw-   0        0        0      470 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/__init__.py
--rw-rw-rw-   0        0        0      790 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/constants.py
--rw-rw-rw-   0        0        0    21148 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/ttypes.py
--rw-rw-rw-   0        0        0     1360 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/interface_connection_example.py
--rw-rw-rw-   0        0        0    13570 2023-04-24 21:54:51.000000 qrisp-0.0.15/src/qrisp/quantum_network/qn_client.py
--rw-rw-rw-   0        0        0     5602 2023-04-24 21:54:54.000000 qrisp-0.0.15/src/qrisp/quantum_network/qn_server.py
--rw-rw-rw-   0        0        0     5722 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/quantum_network/qn_simulator_server.py
--rw-rw-rw-   0        0        0     6919 2023-04-24 21:54:48.000000 qrisp-0.0.15/src/qrisp/quantum_network/quantum_network_session.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.435127 qrisp-0.0.15/src/qrisp/simulator/
--rw-rw-rw-   0        0        0      786 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/__init__.py
--rw-rw-rw-   0        0        0     8518 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/bi_array_helper.py
--rw-rw-rw-   0        0        0    49714 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/bi_arrays.py
--rw-rw-rw-   0        0        0    49650 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/bi_arrays_new.py
--rw-rw-rw-   0        0        0    26922 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/circuit_preprocessing.py
--rw-rw-rw-   0        0        0    13881 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/circuit_reordering.py
--rw-rw-rw-   0        0        0     7995 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/impure_quantum_state.py
--rw-rw-rw-   0        0        0      493 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/numerics_config.py
--rw-rw-rw-   0        0        0     6077 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/quantum_state.py
--rw-rw-rw-   0        0        0    13911 2023-04-25 09:18:14.000000 qrisp-0.0.15/src/qrisp/simulator/simulator.py
--rw-rw-rw-   0        0        0     7462 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/tensor_factor.py
--rw-rw-rw-   0        0        0    11761 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/simulator/unitary_management.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.452091 qrisp-0.0.15/src/qrisp/uncomputation/
--rw-rw-rw-   0        0        0      549 2023-04-24 14:36:50.000000 qrisp-0.0.15/src/qrisp/uncomputation/__init__.py
--rw-rw-rw-   0        0        0     6192 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/uncomputation/type_checker.py
--rw-rw-rw-   0        0        0     4442 2023-04-24 21:55:24.000000 qrisp-0.0.15/src/qrisp/uncomputation/uncomputation.py
--rw-rw-rw-   0        0        0    11629 2023-04-24 21:55:25.000000 qrisp-0.0.15/src/qrisp/uncomputation/unqomp.py
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.074266 qrisp-0.0.15/src/qrisp.egg-info/
--rw-rw-rw-   0        0        0      638 2023-04-26 12:26:12.000000 qrisp-0.0.15/src/qrisp.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     5228 2023-04-26 12:26:13.000000 qrisp-0.0.15/src/qrisp.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-04-26 12:26:12.000000 qrisp-0.0.15/src/qrisp.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      116 2023-04-26 12:26:12.000000 qrisp-0.0.15/src/qrisp.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2023-04-26 12:26:12.000000 qrisp-0.0.15/src/qrisp.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2023-04-26 12:26:13.573076 qrisp-0.0.15/tests/
--rw-rw-rw-   0        0        0     1121 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_GMS_environment_example.py
--rw-rw-rw-   0        0        0     1475 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_GXX_converter_example.py
--rw-rw-rw-   0        0        0     2202 2023-04-24 21:55:27.000000 qrisp-0.0.15/tests/test_GXX_gates_example.py
--rw-rw-rw-   0        0        0     3047 2023-04-24 21:55:27.000000 qrisp-0.0.15/tests/test_GZZ_gates_example.py
--rw-rw-rw-   0        0        0     2476 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_abstract_parameters.py
--rw-rw-rw-   0        0        0      940 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_array_entry_manipulation.py
--rw-rw-rw-   0        0        0     4149 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_comparisons.py
--rw-rw-rw-   0        0        0     3442 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_conditional_environments_example.py
--rw-rw-rw-   0        0        0     3037 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_controlled_gates.py
--rw-rw-rw-   0        0        0     4231 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_diagonal_hamiltonian_application.py
--rw-rw-rw-   0        0        0     1603 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_gray_synthesis_example.py
--rw-rw-rw-   0        0        0     3848 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_grovers_algorithm.py
--rw-rw-rw-   0        0        0      675 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_hello_world.py
--rw-rw-rw-   0        0        0     1693 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_inpl_matrix_multiplication_example.py
--rw-rw-rw-   0        0        0     1569 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_interface.py
--rw-rw-rw-   0        0        0      973 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_loops.py
--rw-rw-rw-   0        0        0     2058 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_matrix_multiplication_example.py
--rw-rw-rw-   0        0        0     2432 2023-04-24 21:55:26.000000 qrisp-0.0.15/tests/test_mcx.py
--rw-rw-rw-   0        0        0      682 2023-04-24 21:55:27.000000 qrisp-0.0.15/tests/test_measurement_reduction.py
--rw-rw-rw-   0        0        0      663 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_outcome_array.py
--rw-rw-rw-   0        0        0     1894 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_qiskit_backend_client.py
--rw-rw-rw-   0        0        0      806 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_qompiler.py
--rw-rw-rw-   0        0        0     3099 2023-04-24 21:55:05.000000 qrisp-0.0.15/tests/test_quantum_arithmetic.py
--rw-rw-rw-   0        0        0     2912 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_quantum_dictionary.py
--rw-rw-rw-   0        0        0     1047 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_quantum_division.py
--rw-rw-rw-   0        0        0     4896 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_quantum_teleportation.py
--rw-rw-rw-   0        0        0     1236 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_state_preparation.py
--rw-rw-rw-   0        0        0      958 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_string_test.py
--rw-rw-rw-   0        0        0     5218 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_uncomputation_example.py
--rw-rw-rw-   0        0        0     1600 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/test_unitary_calculation.py
--rw-rw-rw-   0        0        0     4023 2023-04-24 14:36:50.000000 qrisp-0.0.15/tests/tests_doc_examples.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.770154 qrisp-0.0.16/
+-rw-rw-rw-   0        0        0    14474 2023-04-24 14:39:30.000000 qrisp-0.0.16/LICENSE
+-rw-rw-rw-   0        0        0     3120 2023-05-05 09:23:02.771153 qrisp-0.0.16/PKG-INFO
+-rw-rw-rw-   0        0        0     2528 2023-05-04 15:01:28.000000 qrisp-0.0.16/README.md
+-rw-rw-rw-   0        0        0      206 2023-05-03 15:23:04.000000 qrisp-0.0.16/pyproject.toml
+-rw-rw-rw-   0        0        0      588 2023-05-05 09:23:02.774156 qrisp-0.0.16/setup.cfg
+-rw-rw-rw-   0        0        0     1518 2023-04-26 12:33:10.000000 qrisp-0.0.16/setup.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:01.924755 qrisp-0.0.16/src/
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:01.967676 qrisp-0.0.16/src/qrisp/
+-rw-rw-rw-   0        0        0      715 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/__init__.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.059435 qrisp-0.0.16/src/qrisp/arithmetic/
+-rw-rw-rw-   0        0        0    33229 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/SBP_arithmetic.py
+-rw-rw-rw-   0        0        0      717 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/__init__.py
+-rw-rw-rw-   0        0        0     6820 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/comparisons.py
+-rw-rw-rw-   0        0        0     5350 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/incrementation.py
+-rw-rw-rw-   0        0        0    26444 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/matrix_multiplication.py
+-rw-rw-rw-   0        0        0     3293 2023-04-24 14:36:50.000000 qrisp-0.0.16/src/qrisp/arithmetic/poly_tools.py
+-rw-rw-rw-   0        0        0    11049 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/ripple_carry_adder.py
+-rw-rw-rw-   0        0        0    16425 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/ripple_division.py
+-rw-rw-rw-   0        0        0     1137 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/arithmetic/ripple_mult.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.121772 qrisp-0.0.16/src/qrisp/circuit/
+-rw-rw-rw-   0        0        0      759 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/__init__.py
+-rw-rw-rw-   0        0        0     1237 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/clbit.py
+-rw-rw-rw-   0        0        0     5906 2023-05-04 12:50:14.000000 qrisp-0.0.16/src/qrisp/circuit/controlled_operations.py
+-rw-rw-rw-   0        0        0     3773 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/instruction.py
+-rw-rw-rw-   0        0        0      504 2023-04-24 14:36:50.000000 qrisp-0.0.16/src/qrisp/circuit/library.py
+-rw-rw-rw-   0        0        0    28278 2023-05-04 12:07:53.000000 qrisp-0.0.16/src/qrisp/circuit/operation.py
+-rw-rw-rw-   0        0        0    68121 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/quantum_circuit.py
+-rw-rw-rw-   0        0        0     1510 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/qubit.py
+-rw-rw-rw-   0        0        0     5371 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/standard_operations.py
+-rw-rw-rw-   0        0        0     5529 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/transpiler.py
+-rw-rw-rw-   0        0        0     4119 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/circuit/transpiler_old.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.190731 qrisp-0.0.16/src/qrisp/core/
+-rw-rw-rw-   0        0        0      782 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/core/__init__.py
+-rw-rw-rw-   0        0        0    34131 2023-05-04 12:56:12.000000 qrisp-0.0.16/src/qrisp/core/compilation.py
+-rw-rw-rw-   0        0        0    38339 2023-05-04 13:03:20.000000 qrisp-0.0.16/src/qrisp/core/library.py
+-rw-rw-rw-   0        0        0    32223 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/core/quantum_array.py
+-rw-rw-rw-   0        0        0     9072 2023-05-04 12:17:44.000000 qrisp-0.0.16/src/qrisp/core/quantum_dictionary.py
+-rw-rw-rw-   0        0        0    41472 2023-05-04 12:13:38.000000 qrisp-0.0.16/src/qrisp/core/quantum_session.py
+-rw-rw-rw-   0        0        0    47245 2023-05-04 12:22:18.000000 qrisp-0.0.16/src/qrisp/core/quantum_variable.py
+-rw-rw-rw-   0        0        0    13528 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/core/session_merging_tools.py
+-rw-rw-rw-   0        0        0      626 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/default_backend.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.300172 qrisp-0.0.16/src/qrisp/environments/
+-rw-rw-rw-   0        0        0     6710 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/GMS_environment.py
+-rw-rw-rw-   0        0        0      803 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/__init__.py
+-rw-rw-rw-   0        0        0    11072 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/control_environment.py
+-rw-rw-rw-   0        0        0     5682 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/gate_wrap_environment.py
+-rw-rw-rw-   0        0        0    26090 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/quantum_conditionals.py
+-rw-rw-rw-   0        0        0    15094 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/quantum_environments.py
+-rw-rw-rw-   0        0        0    20097 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/quantum_inversion.py
+-rw-rw-rw-   0        0        0     4008 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/environments/temp_var_environment.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.320663 qrisp-0.0.16/src/qrisp/grover/
+-rw-rw-rw-   0        0        0      465 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/grover/__init__.py
+-rw-rw-rw-   0        0        0    13152 2023-05-04 12:46:08.000000 qrisp-0.0.16/src/qrisp/grover/grover_tools.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.344581 qrisp-0.0.16/src/qrisp/interface/
+-rw-rw-rw-   0        0        0      680 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/__init__.py
+-rw-rw-rw-   0        0        0     8052 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/backends.py
+-rw-rw-rw-   0        0        0    13521 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/circuit_converter.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.373002 qrisp-0.0.16/src/qrisp/interface/openapi_interface/
+-rw-rw-rw-   0        0        0      869 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/openapi_interface/__init__.py
+-rw-rw-rw-   0        0        0     1539 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/openapi_interface/backend_client.py
+-rw-rw-rw-   0        0        0     3878 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/openapi_interface/backend_server.py
+-rw-rw-rw-   0        0        0     1184 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/openapi_interface/interface_types.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.414106 qrisp-0.0.16/src/qrisp/interface/thrift_interface/
+-rw-rw-rw-   0        0        0      638 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/__init__.py
+-rw-rw-rw-   0        0        0     3340 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/backend_client.py
+-rw-rw-rw-   0        0        0     5900 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/backend_server.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.448330 qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/
+-rw-rw-rw-   0        0        0    16486 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/BackendService.py
+-rw-rw-rw-   0        0        0      475 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/__init__.py
+-rw-rw-rw-   0        0        0      835 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/constants.py
+-rw-rw-rw-   0        0        0    28640 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/ttypes.py
+-rw-rw-rw-   0        0        0     1068 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/interface_types.py
+-rw-rw-rw-   0        0        0     1645 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/interface/thrift_interface/stoppable_thrift_server.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.461677 qrisp-0.0.16/src/qrisp/iterators/
+-rw-rw-rw-   0        0        0      492 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/iterators/__init__.py
+-rw-rw-rw-   0        0        0     3616 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/iterators/qrange.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.486121 qrisp-0.0.16/src/qrisp/logic_synthesis/
+-rw-rw-rw-   0        0        0      605 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/logic_synthesis/__init__.py
+-rw-rw-rw-   0        0        0    19564 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/logic_synthesis/gray_synthesis.py
+-rw-rw-rw-   0        0        0     2724 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/logic_synthesis/pprm_synthesis.py
+-rw-rw-rw-   0        0        0    15282 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/logic_synthesis/truth_tables.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.515331 qrisp-0.0.16/src/qrisp/misc/
+-rw-rw-rw-   0        0        0    17523 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/misc/GMS_tools.py
+-rw-rw-rw-   0        0        0      500 2023-05-04 12:59:01.000000 qrisp-0.0.16/src/qrisp/misc/__init__.py
+-rw-rw-rw-   0        0        0     3989 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/misc/depth_reduction.py
+-rw-rw-rw-   0        0        0    20826 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/misc/multi_cx.py
+-rw-rw-rw-   0        0        0    58870 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/misc/utility.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.539742 qrisp-0.0.16/src/qrisp/qtypes/
+-rw-rw-rw-   0        0        0      618 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/qtypes/__init__.py
+-rw-rw-rw-   0        0        0     6095 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/qtypes/quantum_bool.py
+-rw-rw-rw-   0        0        0     2199 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/qtypes/quantum_char.py
+-rw-rw-rw-   0        0        0    27432 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/qtypes/quantum_float.py
+-rw-rw-rw-   0        0        0     4697 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/qtypes/quantum_string.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.567019 qrisp-0.0.16/src/qrisp/quantum_network/
+-rw-rw-rw-   0        0        0      636 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/__init__.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.571411 qrisp-0.0.16/src/qrisp/quantum_network/interface/
+-rw-rw-rw-   0        0        0      420 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface/__init__.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.590633 qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/
+-rw-rw-rw-   0        0        0    56700 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/QuantumNetworkService.py
+-rw-rw-rw-   0        0        0      482 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/__init__.py
+-rw-rw-rw-   0        0        0      835 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/constants.py
+-rw-rw-rw-   0        0        0    23289 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/ttypes.py
+-rw-rw-rw-   0        0        0     1348 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/interface_connection_example.py
+-rw-rw-rw-   0        0        0    13103 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/qn_client.py
+-rw-rw-rw-   0        0        0     5468 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/qn_server.py
+-rw-rw-rw-   0        0        0     5246 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/qn_simulator_server.py
+-rw-rw-rw-   0        0        0     6427 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/quantum_network/quantum_network_session.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.640527 qrisp-0.0.16/src/qrisp/simulator/
+-rw-rw-rw-   0        0        0      834 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/__init__.py
+-rw-rw-rw-   0        0        0     9181 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/bi_array_helper.py
+-rw-rw-rw-   0        0        0    49803 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/bi_arrays.py
+-rw-rw-rw-   0        0        0    49731 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/bi_arrays_new.py
+-rw-rw-rw-   0        0        0    27103 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/circuit_preprocessing.py
+-rw-rw-rw-   0        0        0    13706 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/circuit_reordering.py
+-rw-rw-rw-   0        0        0     7394 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/impure_quantum_state.py
+-rw-rw-rw-   0        0        0      514 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/numerics_config.py
+-rw-rw-rw-   0        0        0     6109 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/quantum_state.py
+-rw-rw-rw-   0        0        0    13159 2023-05-04 11:22:09.000000 qrisp-0.0.16/src/qrisp/simulator/simulator.py
+-rw-rw-rw-   0        0        0     7455 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/tensor_factor.py
+-rw-rw-rw-   0        0        0    11931 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/simulator/unitary_management.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.655588 qrisp-0.0.16/src/qrisp/uncomputation/
+-rw-rw-rw-   0        0        0      563 2023-05-03 15:23:04.000000 qrisp-0.0.16/src/qrisp/uncomputation/__init__.py
+-rw-rw-rw-   0        0        0     5987 2023-05-04 11:07:25.000000 qrisp-0.0.16/src/qrisp/uncomputation/type_checker.py
+-rw-rw-rw-   0        0        0     4223 2023-05-04 11:07:25.000000 qrisp-0.0.16/src/qrisp/uncomputation/uncomputation.py
+-rw-rw-rw-   0        0        0    11619 2023-05-04 12:40:04.000000 qrisp-0.0.16/src/qrisp/uncomputation/unqomp.py
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:01.994176 qrisp-0.0.16/src/qrisp.egg-info/
+-rw-rw-rw-   0        0        0     3120 2023-05-05 09:23:01.000000 qrisp-0.0.16/src/qrisp.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0     5225 2023-05-05 09:23:01.000000 qrisp-0.0.16/src/qrisp.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-05-05 09:23:01.000000 qrisp-0.0.16/src/qrisp.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0      116 2023-05-05 09:23:01.000000 qrisp-0.0.16/src/qrisp.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2023-05-05 09:23:01.000000 qrisp-0.0.16/src/qrisp.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2023-05-05 09:23:02.768151 qrisp-0.0.16/tests/
+-rw-rw-rw-   0        0        0     1127 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_GMS_environment_example.py
+-rw-rw-rw-   0        0        0     1505 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_GXX_converter_example.py
+-rw-rw-rw-   0        0        0     2391 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_GXX_gates_example.py
+-rw-rw-rw-   0        0        0     3155 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_GZZ_gates_example.py
+-rw-rw-rw-   0        0        0     2599 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_abstract_parameters.py
+-rw-rw-rw-   0        0        0      915 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_array_entry_manipulation.py
+-rw-rw-rw-   0        0        0     4089 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_comparisons.py
+-rw-rw-rw-   0        0        0     3554 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_conditional_environments_example.py
+-rw-rw-rw-   0        0        0     3168 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_controlled_gates.py
+-rw-rw-rw-   0        0        0     4369 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_diagonal_hamiltonian_application.py
+-rw-rw-rw-   0        0        0     1692 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_gray_synthesis_example.py
+-rw-rw-rw-   0        0        0     4087 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_grovers_algorithm.py
+-rw-rw-rw-   0        0        0      696 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_hello_world.py
+-rw-rw-rw-   0        0        0     1721 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_inpl_matrix_multiplication_example.py
+-rw-rw-rw-   0        0        0     1479 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_interface.py
+-rw-rw-rw-   0        0        0     1006 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_loops.py
+-rw-rw-rw-   0        0        0     2131 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_matrix_multiplication_example.py
+-rw-rw-rw-   0        0        0     2424 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_mcx.py
+-rw-rw-rw-   0        0        0      680 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_measurement_reduction.py
+-rw-rw-rw-   0        0        0      658 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_outcome_array.py
+-rw-rw-rw-   0        0        0     1948 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_qiskit_backend_client.py
+-rw-rw-rw-   0        0        0      835 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_qompiler.py
+-rw-rw-rw-   0        0        0     2963 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_quantum_arithmetic.py
+-rw-rw-rw-   0        0        0     3016 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_quantum_dictionary.py
+-rw-rw-rw-   0        0        0     1087 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_quantum_division.py
+-rw-rw-rw-   0        0        0     5053 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_quantum_teleportation.py
+-rw-rw-rw-   0        0        0     1255 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_state_preparation.py
+-rw-rw-rw-   0        0        0      994 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_string_test.py
+-rw-rw-rw-   0        0        0     5332 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_uncomputation_example.py
+-rw-rw-rw-   0        0        0     1651 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/test_unitary_calculation.py
+-rw-rw-rw-   0        0        0     4137 2023-05-03 15:23:04.000000 qrisp-0.0.16/tests/tests_doc_examples.py
```

### Comparing `qrisp-0.0.15/LICENSE` & `qrisp-0.0.16/LICENSE`

 * *Files identical despite different names*

### Comparing `qrisp-0.0.15/setup.cfg` & `qrisp-0.0.16/setup.cfg`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 00000000: 5b6d 6574 6164 6174 615d 0d0a 6e61 6d65  [metadata]..name
 00000010: 203d 2071 7269 7370 0d0a 7665 7273 696f   = qrisp..versio
-00000020: 6e20 3d20 302e 302e 3135 0d0a 6175 7468  n = 0.0.15..auth
+00000020: 6e20 3d20 302e 302e 3136 0d0a 6175 7468  n = 0.0.16..auth
 00000030: 6f72 203d 2052 6170 6861 656c 2053 6569  or = Raphael Sei
 00000040: 6465 6c0d 0a61 7574 686f 725f 656d 6169  del..author_emai
 00000050: 6c20 3d20 7261 7068 6165 6c2e 7365 6964  l = raphael.seid
 00000060: 656c 4066 6f6b 7573 2e66 7261 756e 686f  el@fokus.fraunho
 00000070: 6665 722e 6465 0d0a 6465 7363 7269 7074  fer.de..descript
 00000080: 696f 6e20 3d20 4120 736d 616c 6c20 6578  ion = A small ex
 00000090: 616d 706c 6520 7061 636b 6167 650d 0a6c  ample package..l
```

### Comparing `qrisp-0.0.15/setup.py` & `qrisp-0.0.16/setup.py`

 * *Files 18% similar despite different names*

```diff
@@ -29,18 +29,14 @@
 setuptools.setup(
     name="qrisp",
     author="Raphael Seidel",
     author_email="raphael.seidel@fokus.fraunhofer.de",
     description="Qrisp - A high level language for gate-based quantum computing",
     long_description=long_description,
     long_description_content_type="text/markdown",
-    url="https://github.com/pypa/sampleproject",
-    project_urls={
-        "Bug Tracker": "https://github.com/pypa/sampleproject/issues",
-    },
     classifiers=[
         "Programming Language :: Python :: 3",
         "License :: OSI Approved :: Eclipse Public License 2.0 (EPL-2.0)",
         "Operating System :: OS Independent",
     ],
     package_dir={"": "src"},
     install_requires = REQUIREMENTS,
```

### Comparing `qrisp-0.0.15/src/qrisp/__init__.py` & `qrisp-0.0.16/src/qrisp/arithmetic/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,26 +1,20 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-from qrisp.core import *
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
-from qrisp.misc import *
-from qrisp.circuit import *
-from qrisp.uncomputation import *
 
-from qrisp.environments import *
-from qrisp.arithmetic import *
-
-from qrisp.iterators.qrange import *
-from qrisp.qtypes import *
-
-from qrisp.default_backend import *
+from qrisp.arithmetic.comparisons import *
+from qrisp.arithmetic.SBP_arithmetic import *
+from qrisp.arithmetic.ripple_carry_adder import *
+from qrisp.arithmetic.ripple_division import *
+from qrisp.arithmetic.incrementation import *
+from qrisp.arithmetic.matrix_multiplication import *
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/SBP_arithmetic.py` & `qrisp-0.0.16/src/qrisp/arithmetic/SBP_arithmetic.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,24 +7,24 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-import sympy as sp
 import numpy as np
-from qrisp.core import QuantumVariable, QuantumArray
-from qrisp.misc import gate_wrap
+import sympy as sp
+
 from qrisp.arithmetic.poly_tools import (
-    get_ordered_symbol_list,
     expr_to_list,
     filter_pow,
+    get_ordered_symbol_list,
 )
-from qrisp.core import mcx, cp, cx, p , cz, h
+from qrisp.core import QuantumArray, QuantumVariable, cp, cx, cz, h, mcx, p
+from qrisp.misc import gate_wrap
 
 # Threshold of rounding used in detecting integer multiples of pi
 pi_mult_round_threshold = 11
 
 depth_tracker = {}
 
 
@@ -101,45 +101,44 @@
     env.manual_allocation_management = True
     with env:
         phase_accumulator = 0
         cz_counter = 0
 
         # Execute controlled rotations
         for i in range(output_qf.size):
-
             # The -i (instead of i) reverses the gate order implying that
             # we can leave out the swaps of the QFT
-            
-            rot_angle = 2*np.pi*2**(-i-1)*y
-            rot_angle = rot_angle%(2*np.pi)
-            
-            if np.round(rot_angle, pi_mult_round_threshold) != 0 \
-                    and np.round((-rot_angle)%(2*np.pi), pi_mult_round_threshold) != 0:
-                
-                #If phase is equal to pi, execute cz gate (costs one CNOT less than CP)
+
+            rot_angle = 2 * np.pi * 2 ** (-i - 1) * y
+            rot_angle = rot_angle % (2 * np.pi)
+
+            if (
+                np.round(rot_angle, pi_mult_round_threshold) != 0
+                and np.round((-rot_angle) % (2 * np.pi), pi_mult_round_threshold) != 0
+            ):
+                # If phase is equal to pi, execute cz gate (costs one CNOT less than CP)
                 if False:
-                # if np.round(abs(rot_angle) - np.pi, pi_mult_round_threshold) == 0:
+                    # if np.round(abs(rot_angle) - np.pi, pi_mult_round_threshold) == 0:
                     cz(ancilla[0], output_qf.reg[i])
                     cz_counter += 1
-                    
-                    phase_accumulator += rot_angle/2
-                #Otherwise execute cp gate
+
+                    phase_accumulator += rot_angle / 2
+                # Otherwise execute cp gate
                 else:
                     cx(ancilla[0], output_qf.reg[i])
-                    p(-rot_angle/2, output_qf.reg[i])
+                    p(-rot_angle / 2, output_qf.reg[i])
                     cx(ancilla[0], output_qf.reg[i])
-                    p(rot_angle/2, output_qf.reg[i])
-                    
-                    phase_accumulator += rot_angle/2
+                    p(rot_angle / 2, output_qf.reg[i])
+
+                    phase_accumulator += rot_angle / 2
                     # cp(rot_angle, ancilla_qb, output_qf.reg[i])
                     # crz(rot_angle, ancilla[0], output_qf.reg[i])
-        p(phase_accumulator-np.pi*cz_counter/2, ancilla[0])
-                
-    
-    #Uncompute boolean multiplication
+        p(phase_accumulator - np.pi * cz_counter / 2, ancilla[0])
+
+    # Uncompute boolean multiplication
     if len(control_qb_list) != 1:
         if not use_gms:
             toffoli_method += "_inv"
 
         mcx(control_qb_list, ancilla[0], method=toffoli_method)
         # gray_logic_synth_qb_list(control_qb_list,
         # ancilla_qb, ancilla_qv.qs, tt, inverse = True)
@@ -164,15 +163,14 @@
 # This function encodes a semi-boolean polynomial into a circuit i.e.
 # For the polynomial p(x_0, x_1, x_2) = 4*x_0*x_1 + 2*x_0*x_2
 # the effect of this function is:
 # U_f |x_0, x_1, x_2>|0> = |x_0, x_1, x_2>|p(x_1,x_2,x_3)>
 def sb_polynomial_encoder(
     input_qf_list, output_qf, poly, inplace_mult=1, use_gms=False, init_op="auto"
 ):
-    
     # As the polynomial has only boolean variables,
     # powers can be ignored since x**k = x for x in GF(2)
     poly = filter_pow(poly.expand()).expand() / 2.0**output_qf.exponent
 
     # Acquire list of symbols present in the polynomial
     symbol_list = []
 
@@ -186,25 +184,24 @@
         raise Exception(
             "Input variables do not the required amount of qubits to encode polynomial"
         )
 
     # Acquire monomials in list form
     monomial_list = expr_to_list(poly)
 
-
     from qrisp import QFT
+
     QFT(
         output_qf,
         inv=False,
         exec_swap=False,
         inplace_mult=inplace_mult,
         use_gms=use_gms,
     )
 
-
     # The list of qubits contained in the variables of input_var_list
     input_qubits = sum([list(var.reg) for var in input_qf_list], [])
 
     control_qubit_list = []
     y_list = []
 
     # Iterate through the monomials
@@ -243,20 +240,18 @@
 
         # Prepare the qubits on which the U_g should be controlled
         control_qubit_numbers = [symbol_list.index(var) for var in variables]
 
         control_qubits = [input_qubits[nr] for nr in control_qubit_numbers]
 
         control_qubits = list(set(control_qubits))
-        
-        control_qubits.sort(key = lambda x : x.identifier)
-        
+
+        control_qubits.sort(key=lambda x: x.identifier)
+
         control_qubit_list.append(control_qubits)
-        
-        
 
     # Now we apply the multi controlled U_g gate
     # Here the order in which they are applied makes a huge difference
     # In order to determine, which U_g to apply next, we evaluate a cost function
     # (which we determined through trial and error)
     # and choose the U_g with the lowest cost
 
@@ -653,15 +648,15 @@
     >>> qf_1[:] = 4
     >>> qf_res = hybrid_mult(qf_0, qf_1, cl_factor = 2)
     >>> print(qf_res)
     {24: 1.0}
 
     """
 
-    from qrisp import cx, h, z, QFT, merge
+    from qrisp import QFT, cx, h, merge, z
 
     # The two factors take asymetrical roles in this algorithm
     # This implies that there is most likely a prefered choice
     # for the roles depending on the size of the factors
     # Several trials showed that these roles work best
     if not x.size > y.size:
         x, y = y, x
@@ -856,79 +851,78 @@
     # Perform exponent shifts
 
     x.exp_shift(x_exp)
     y.exp_shift(y_exp)
 
     return output_qf
 
-#Wrapper for choosing the best multiplication algorithm
-def q_mult(factor_1, factor_2, target = None, method = "auto"):
-    
+
+# Wrapper for choosing the best multiplication algorithm
+def q_mult(factor_1, factor_2, target=None, method="auto"):
     if method == "auto":
-        
         if factor_1.reg == factor_2.reg:
-            return q_mult(factor_1, factor_2, target, method = "sbp")
+            return q_mult(factor_1, factor_2, target, method="sbp")
         else:
-            return q_mult(factor_1, factor_2, target, method = "hybrid")
+            return q_mult(factor_1, factor_2, target, method="hybrid")
 
     elif method == "sbp":
-        
         from qrisp.qtypes.quantum_float import create_output_qf
+
         if target is None:
-            target = create_output_qf([factor_1, factor_2], op = "mul")
-        
+            target = create_output_qf([factor_1, factor_2], op="mul")
+
         sbp_mult(factor_1, factor_2, target)
         return target
-    
+
     elif method == "hybrid":
         from qrisp.arithmetic import hybrid_mult
-        return hybrid_mult(factor_1, factor_2)
 
+        return hybrid_mult(factor_1, factor_2)
 
 
-def QFT_inpl_mult(qv, inplace_mult = 1):
-    
+def QFT_inpl_mult(qv, inplace_mult=1):
     from qrisp.misc import is_inv
-    
-    
+
     qv = list(qv)
     qv = qv[::-1]
     n = len(qv)
 
     if not is_inv(inplace_mult, n):
-        raise Exception("Tried to perform non-invertible inplace multiplication during Fourier-Transform")
-    
-    #Perform QFT with inplace multiplication
+        raise Exception(
+            "Tried to perform non-invertible inplace multiplication during Fourier-Transform"
+        )
+
+    # Perform QFT with inplace multiplication
     for i in range(n):
-        if i != n-1:
+        if i != n - 1:
             h(qv[i])
-        
-        if i == n-1:
+
+        if i == n - 1:
             break
-        
-        for k in range(n-i-1):
-            if k+i+1 != n-1:
-                cp(inplace_mult*2*np.pi/2**(k+2), qv[k+i+1], qv[i])
+
+        for k in range(n - i - 1):
+            if k + i + 1 != n - 1:
+                cp(inplace_mult * 2 * np.pi / 2 ** (k + 2), qv[k + i + 1], qv[i])
             else:
-                #The -1 here cancels some cp gates of the inverse qft
-                cp((inplace_mult-1)*2*np.pi/2**(k+2), qv[k+i+1], qv[i])
+                # The -1 here cancels some cp gates of the inverse qft
+                cp((inplace_mult - 1) * 2 * np.pi / 2 ** (k + 2), qv[k + i + 1], qv[i])
 
-    #Perform reversed QFT without inplace multiplication and without canceled steps
+    # Perform reversed QFT without inplace multiplication and without canceled steps
     for i in range(n)[::-1]:
-        
-        for k in range(n-i-1)[::-1]:
-            if k+i+1 != n-1:
-                cp(-2*np.pi/2**(k+2), qv[k+i+1], qv[i])
-        
-        if i != n-1:
+        for k in range(n - i - 1)[::-1]:
+            if k + i + 1 != n - 1:
+                cp(-2 * np.pi / 2 ** (k + 2), qv[k + i + 1], qv[i])
+
+        if i != n - 1:
             h(qv[i])
-    
+
     return qv
 
-def inpl_mult(qf, mult_int, treat_overflow = True):
+
+def inpl_mult(qf, mult_int, treat_overflow=True):
     """
     Performs inplace multiplication of a :ref:`QuantumFloat` with a classical integer.
     To prevent overflow errors, this function automatically adjusts the mantissa size.
     If you want to prevent this behavior, set ``treat_overflow = False``.
 
     Parameters
     ----------
@@ -937,45 +931,48 @@
     mult_int : int
         The integer to perform the multiplication with.
     treat_overflow : bool
         If set to ``False``, the mantissa will not be extended to prevent overflow errors. The default is ``True``.
 
     Examples
     --------
-    
+
     We create a QuantumFloat, bring it to superposition and perform an inplace multiplication.
-    
+
     >>> from qrisp import QuantumFloat, h, inpl_mult
     >>> a = QuantumFloat(5, signed = True)
     >>> h(a[0])
     >>> h(a[-1])
     >>> print(a)
     {0: 0.25, 1: 0.25, -32: 0.25, -31: 0.25}
     >>> inpl_mult(a, -5)
     >>> print(a)
     {0: 0.25, 155: 0.25, 160: 0.25, -5: 0.25}
 
     """
     if not isinstance(mult_int, int):
-        raise Exception("Tried to inplace multiply QuantumFloat with non-integer factor")
-    
+        raise Exception(
+            "Tried to inplace multiply QuantumFloat with non-integer factor"
+        )
+
     if mult_int < 0 and not qf.signed:
-        raise Exception("Tried to inplace-multiply unsigned QuantumFloat with negative factor")
-    
+        raise Exception(
+            "Tried to inplace-multiply unsigned QuantumFloat with negative factor"
+        )
+
     bit_shift = 0
-    while not mult_int%2:
+    while not mult_int % 2:
         bit_shift += 1
-        mult_int = mult_int//2
-    
+        mult_int = mult_int // 2
+
     if mult_int != 1:
         if treat_overflow:
-            
             extension_size = int(np.ceil(np.log2(abs(mult_int))))
-            qf.extend(extension_size, position = qf.size-1)
+            qf.extend(extension_size, position=qf.size - 1)
             if qf.signed:
-                cx(qf[-1], qf[-1-extension_size:-1])
-        
+                cx(qf[-1], qf[-1 - extension_size : -1])
+
         from qrisp.arithmetic.SBP_arithmetic import QFT_inpl_mult
-        
-        QFT_inpl_mult(qf, inplace_mult = mult_int)
-    
+
+        QFT_inpl_mult(qf, inplace_mult=mult_int)
+
     qf << bit_shift
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/comparisons.py` & `qrisp-0.0.16/src/qrisp/arithmetic/comparisons.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,293 +1,290 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
-from qrisp import lifted
 
-def less_than_gate(a,b):
-    from qrisp import QuantumBool, cx, inpl_add, QuantumFloat
+from qrisp.misc.utility import lifted
+from qrisp.environments import adaptive_condition
+
+
+def less_than_gate(a, b):
+    from qrisp import QuantumBool, QuantumFloat, cx, inpl_add
 
     a = a.duplicate()
-    
+
     if isinstance(b, QuantumFloat):
-        b = b.duplicate(qs = a.qs)
-    
+        b = b.duplicate(qs=a.qs)
+
     # a[:] = -5
     added_sign = False
     if not a.signed:
-        a.extend(1, position = -1)
-        a.mshape[1]-= 1
+        a.extend(1, position=-1)
+        a.mshape[1] -= 1
         a.signed = True
         added_sign = True
-    
+
     added_qubits_upper = 0
 
     while True:
-        a.extend(1, position = a.size-1)
-        
+        a.extend(1, position=a.size - 1)
+
         if not added_sign:
             cx(a[-1], a[-2])
-        
+
         added_qubits_upper += 1
-        
+
         if isinstance(b, QuantumFloat):
             if not a.mshape[1] < b.mshape[1] + 1:
                 break
         else:
             break
 
-
     added_qubits_lower = 0
-    
+
     if isinstance(b, QuantumFloat):
         while a.mshape[0] > b.mshape[0]:
-            a.extend(1, position = 0)
-            
+            a.extend(1, position=0)
+
             a.mshape -= 1
             a.exponent -= 1
-            
+
             added_qubits_lower += 1
-    
+
     a -= b
     # x(a)
     # inpl_add(a, b, ignore_rounding_error=True, ignore_overflow_error=False)
     # x(a)
-    
-    
+
     if added_sign:
         res = a[-1]
-        
+
         a.reduce(a[-1])
         a.qs.data.pop(-1)
     else:
         res_qbl = QuantumBool()
         res = res_qbl[0]
         cx(a[-1], res)
-    
+
     a += b
     # inpl_add(a, b, ignore_rounding_error=True, ignore_overflow_error=False)
-    
+
     for i in range(added_qubits_upper):
         if not added_sign:
             cx(a[-1], a[-2])
-            
+
         if added_sign:
-            a.reduce(a[-1], verify = False)
+            a.reduce(a[-1], verify=False)
         else:
-            a.reduce(a[-2], verify = False)
-    
+            a.reduce(a[-2], verify=False)
+
     for i in range(added_qubits_lower):
-        
-        a.reduce(a[0], verify = False)
+        a.reduce(a[0], verify=False)
         a.mshape += 1
         a.exponent += 1
-    
-        
-    
+
     if added_sign:
         a.mshape[1] += 1
         a.signed = False
-    
+
     if isinstance(b, QuantumFloat):
         reordered_qubits = a.reg + b.reg + [res]
     else:
         reordered_qubits = a.reg + [res]
-    qc = a.qs.compile(cancel_qfts = False)
+    qc = a.qs.compile(cancel_qfts=False)
     # qc = a.qs
-    
+
     for qb in qc.qubits:
         if qb not in reordered_qubits:
             reordered_qubits.append(qb)
-    
+
     qc.qubits = reordered_qubits
-    
+
     res_gate = qc.to_gate("less_than")
     res_gate.is_qfree = True
-    res_gate.permeability = {i : i < qc.qubits.index(res) for i in range(res_gate.num_qubits)}
-    
-    
+    res_gate.permeability = {
+        i: i < qc.qubits.index(res) for i in range(res_gate.num_qubits)
+    }
+
     return res_gate
 
 
+def less_than(a, b):
+    from qrisp import QuantumBool, QuantumFloat, QuantumVariable, x
 
-def less_than(a,b):
-    from qrisp import QuantumBool, QuantumVariable, QuantumFloat, x
     if isinstance(a, QuantumFloat) and isinstance(b, QuantumFloat):
-        
-        
-        lt_gate = less_than_gate(a,b)
-        
+        lt_gate = less_than_gate(a, b)
+
         lt_qbl = QuantumBool()
-        
+
         anc_amount = lt_gate.num_qubits - a.size - b.size - 1
-        
+
         if anc_amount:
             lt_ancilla = QuantumVariable(anc_amount)
             ancillae = lt_ancilla.reg
         else:
             ancillae = []
-            
+
         a.qs.append(lt_gate, a.reg + b.reg + lt_qbl.reg + ancillae)
-        
+
         if anc_amount:
-            lt_ancilla.delete(verify = False)
-        
+            lt_ancilla.delete(verify=False)
+
         return lt_qbl
 
     elif isinstance(a, QuantumFloat):
-        
-            
         labels = [a.decoder(i) for i in range(2**a.size)]
         labels.sort()
-        
+
         if labels[-1] < b:
             return always_true()
         if labels[0] >= b:
             return always_false()
-        
-        for i in range(len(labels)-1):
-            if labels[i] < b <= labels[i+1]:
-                b = labels[i+1]
+
+        for i in range(len(labels) - 1):
+            if labels[i] < b <= labels[i + 1]:
+                b = labels[i + 1]
                 break
         else:
             b = labels[-1]
-        
-        lt_gate = less_than_gate(a,b)
-        
+
+        lt_gate = less_than_gate(a, b)
+
         lt_qbl = QuantumBool()
-        
+
         anc_amount = lt_gate.num_qubits - a.size - 1
-        
+
         if anc_amount:
             lt_ancilla = QuantumVariable(anc_amount)
             ancillae = lt_ancilla.reg
         else:
             ancillae = []
-        
+
         a.qs.append(lt_gate, a.reg + lt_qbl.reg + ancillae)
-        
+
         if anc_amount:
-            lt_ancilla.delete(verify = False)
-            
+            lt_ancilla.delete(verify=False)
+
         return lt_qbl
-    
+
     elif isinstance(b, QuantumFloat):
-        
         added_sign = False
         if not b.signed:
             b.extend(1, b.size)
             b.mshape[1] -= 1
             b.signed = True
             added_sign = True
-        
+
         x(b)
         res = less_than(b, -a - 2**b.exponent)
-        
+
         x(b)
-        
+
         if added_sign:
             b.reduce(b.reg[-1])
             b.mshape[1] += 1
             b.signed = False
-        
+
         return res
 
+
 @lifted
 def equal(qf_0, qf_1):
-    
-    from qrisp import QuantumBool, QuantumFloat, cx, mcx  
+    from qrisp import QuantumBool, QuantumFloat, cx, mcx
+
     eq_qbl = QuantumBool()
-    
+
     if isinstance(qf_1, QuantumFloat):
-        
         if qf_1.signed and not qf_0.signed:
             qf_0, qf_1 = qf_1, qf_0
-            
+
         mcx_qubits = []
-        
+
         if qf_1.signed and qf_0.signed:
             cx(qf_1.sign(), qf_0.sign())
             mcx_qubits.append(qf_0.sign())
-            
+
         elif qf_0.signed:
             mcx_qubits.append(qf_0.sign())
-        
+
         significance_dict = {}
-        
+
         for i in range(qf_0.msize):
             significance_dict[qf_0.exponent + i] = [qf_0[i]]
             mcx_qubits.append(qf_0[i])
-            
+
         for i in range(qf_1.msize):
             if i + qf_1.exponent in significance_dict:
                 cx(qf_1[i], significance_dict[i + qf_1.exponent])
             else:
                 mcx_qubits.append(qf_1[i])
-                
-        mcx(mcx_qubits, eq_qbl, ctrl_state = 0)
-        
+
+        mcx(mcx_qubits, eq_qbl, ctrl_state=0)
+
         for i in range(qf_1.msize):
             if i + qf_1.exponent in significance_dict:
                 cx(qf_1[i], significance_dict[i + qf_1.exponent])
-            
+
         if qf_1.signed and qf_0.signed:
-            cx(qf_1.sign(), qf_0.sign())    
-            
+            cx(qf_1.sign(), qf_0.sign())
+
         return eq_qbl
-    
+
     if qf_0.truncate(qf_1) != qf_1:
         return always_false()
-        
-    mcx(qf_0, eq_qbl, ctrl_state = qf_0.encoder(qf_1))
-    
-    return eq_qbl
-    
 
+    mcx(qf_0, eq_qbl, ctrl_state=qf_0.encoder(qf_1))
+
+    return eq_qbl
 
 
 def always_true():
     from qrisp import QuantumBool
+
     true_qbl = QuantumBool()
     true_qbl.flip()
     return true_qbl
 
+
 def always_false():
     from qrisp import QuantumBool
+
     false_qbl = QuantumBool()
     return false_qbl
 
-from qrisp.environments import adaptive_condition
 
 @adaptive_condition
 def lt(a, b):
     return less_than(a, b)
 
+
 @adaptive_condition
 def gt(a, b):
     return less_than(b, a)
 
+
 @adaptive_condition
 def geq(a, b):
-    return lt(a,b).flip()
+    return lt(a, b).flip()
+
 
 @adaptive_condition
 def leq(a, b):
     return gt(a, b).flip()
 
+
 @adaptive_condition
 def eq(a, b):
     return equal(a, b)
 
+
 @adaptive_condition
 def neq(a, b):
     return equal(a, b).flip()
-
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/incrementation.py` & `qrisp-0.0.16/src/qrisp/arithmetic/incrementation.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,16 +7,16 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
+from qrisp import QuantumVariable, x
 from qrisp.misc import gate_wrap
-from qrisp import x, QuantumVariable
 
 
 @gate_wrap(is_qfree=True)
 def increment(qf, amount):
     if amount == 0:
         return
 
@@ -77,17 +77,15 @@
 
     for i in range(2, n - 1):
         qs.mcx([qubit_list[i], incr_anc[i - 2]], incr_anc[i - 1], method="gray_pt")
 
     qs.cx(incr_anc[-1], qubit_list[-1])
 
     for i in range(n - 2, 1, -1):
-        qs.mcx(
-            [qubit_list[i], incr_anc[i - 2]], incr_anc[i - 1], method="gray_pt_inv"
-        )
+        qs.mcx([qubit_list[i], incr_anc[i - 2]], incr_anc[i - 1], method="gray_pt_inv")
         qs.cx(incr_anc[i - 2], qubit_list[i])
 
     qs.mcx([qubit_list[0], qubit_list[1]], incr_anc[0], method="gray_pt_inv")
     qs.cx(qubit_list[0], qubit_list[1])
     qs.x(qubit_list[0])
 
     incr_anc.delete()
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/matrix_multiplication.py` & `qrisp-0.0.16/src/qrisp/arithmetic/matrix_multiplication.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,21 +7,20 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-
+import numpy as np
 import sympy as sp
 
-from qrisp.arithmetic.SBP_arithmetic import hybrid_mult, polynomial_encoder
 from qrisp import QuantumArray, p, z
+from qrisp.arithmetic.SBP_arithmetic import hybrid_mult, polynomial_encoder
 from qrisp.qtypes import QuantumFloat
-import numpy as np
 
 
 def q_matmul(
     q_array_0, q_array_1, output_array=None, res_bit_shape="eq", phase_tolerant=False
 ):
     """
     Matrix multiplication for QuantumArrays.
@@ -275,15 +274,15 @@
 
 
     """
     if q_matrix.shape[1] != cl_matrix.shape[0]:
         raise Exception(
             "Tried to apply matrix multiplication with unfitting dimensions"
         )
-        
+
     L = q_matrix.shape[0]
     K = q_matrix.shape[1]
     J = cl_matrix.shape[1]
 
     from sympy import Symbol
 
     if output_array is None:
@@ -325,16 +324,15 @@
             symbol_dic[q_matrix[i, k].name] = temp_symb
 
     res_symb_matrix = symb_matrix @ cl_matrix
 
     qv_list = list(q_matrix.flatten())
     for i in range(L):
         for j in range(J):
-            
-            if res_symb_matrix[i,j] != 0:
+            if res_symb_matrix[i, j] != 0:
                 polynomial_encoder(
                     qv_list,
                     output_array[i, j],
                     res_symb_matrix[i, j],
                     encoding_dic=symbol_dic,
                 )
 
@@ -610,18 +608,17 @@
     {OutcomeArray([[ 0, -1],
                    [ 1,  0]]): 1.0}
 
     """
     from qrisp.arithmetic import QuantumFloat
 
     if isinstance(a, QuantumFloat) or isinstance(b, QuantumFloat):
-        return np.dot(a, b, out)    
+        return np.dot(a, b, out)
 
     else:
-        
         if len(a.shape) == 1 and len(b.shape) == 1:
             temp_0 = a.reshape((1, a.shape[0]))
             temp_1 = b.reshape((a.shape[0], 1))
             res = (auto_matmul_wrapper(temp_0, temp_1, out))[0, 0]
             return res
 
         elif len(a.shape) == 2 and len(b.shape) == 2:
@@ -655,15 +652,15 @@
 
             return np.reshape(res, res_shape)
 
 
 def tensordot(a, b, axes):
     r"""
     Port of `numpy tensordot
-    <https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html>`_ 
+    <https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html>`_
     with similar semantics.
 
     Parameters
     ----------
     a : QuantumArray
         The first operand.
     b : QuantumArray
@@ -675,43 +672,45 @@
     -------
     QuantumArray
         The QuantumArray containing the result of tensordot.
 
     Examples
     --------
 
-    Using ``tensordot`` we can perform the arithmetic for simulating a quantum computer *on a quantum computer*.
-    
+    Using ``tensordot`` we can perform the arithmetic for simulating a quantum computer
+    *on a quantum computer*.
+
     >>> import numpy as np
     >>> from qrisp import QuantumFloat, QuantumArray, tensordot
-    
-    Initiate the QuantumArray holding the statevector. We initate the state of uniform superposition 
-    
+
+    Initiate the QuantumArray holding the statevector. We initate the state of uniform
+    superposition
+
     .. math::
-        
+
         \ket{+} = \frac{1}{\sqrt{2^n}} \sum_{i = 0}^{2^n - 1} \ket{i}
-    
+
     >>> qfloat_type = QuantumFloat(3, -2, signed = True)
     >>> num_qubits = 4
     >>> statevector = QuantumArray(shape = 2**num_qubits, qtype = qfloat_type)
     >>> statevector[:] = [1/(2**num_qubits)**0.5]*2**num_qubits
     >>> print(statevector)
-    {OutcomeArray([0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 
+    {OutcomeArray([0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,
                    0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]): 1.0}
-    
+
     Initiate the QuantumArray holding the unitary of a Z-gate
-    
+
     >>> z_gate = QuantumArray(shape = (2,2), qtype = qfloat_type)
     >>> z_gate[:] = [[1,0], [0,-1]]
     >>> print(z_gate)
     {OutcomeArray([[ 1.,  0.],
                   [ 0., -1.]]): 1.0}
-    
+
     Perform the contraction
-    
+
     >>> statevector = statevector.reshape(num_qubits*[2])
     >>> target_qubit = 3
     >>> new_statevector = tensordot(z_gate, statevector, (1, target_qubit))
     >>> new_statevector = new_statevector.reshape(2**num_qubits)
     >>> print(new_statevector)
     {OutcomeArray([ 0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.25,  0.25,
                    -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25, -0.25]): 1.0}
@@ -726,15 +725,15 @@
     >>> statevector = statevector.reshape(num_qubits*[2])
     >>> z_gate = np.zeros((2,2))
     >>> z_gate[:] = [[1,0], [0,-1]]
     >>> new_statevector = tensordot(z_gate, statevector, (1, target_qubit))
     >>> print(new_statevector.reshape(2**num_qubits))
     [ 0.25  0.25  0.25  0.25  0.25  0.25  0.25  0.25 -0.25 -0.25 -0.25 -0.25
      -0.25 -0.25 -0.25 -0.25]
-    
+
     """
 
     try:
         iter(axes)
     except Exception:
         axes_a = list(range(-axes, 0))
         axes_b = list(range(0, axes))
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/poly_tools.py` & `qrisp-0.0.16/src/qrisp/arithmetic/poly_tools.py`

 * *Files identical despite different names*

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/ripple_carry_adder.py` & `qrisp-0.0.16/src/qrisp/arithmetic/ripple_carry_adder.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,20 +9,20 @@
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 import numpy as np
 
-# Implementation of the modular Cuccaro-Adder https://arxiv.org/pdf/quant-ph/0410184.pdf
-# Has complexity O(log(N)) (Fourier-Adding has O(log(N)^2))
-
 from qrisp import QuantumCircuit
 from qrisp.misc import gate_wrap
 
+# Implementation of the modular Cuccaro-Adder https://arxiv.org/pdf/quant-ph/0410184.pdf
+# Has complexity O(log(N)) (Fourier-Adding has O(log(N)^2))
+
 
 def MAJ_gate():
     qc = QuantumCircuit(3)
 
     qc.cx(2, 1)
     qc.cx(2, 0)
     qc.mcx([0, 1], 2)
@@ -204,15 +204,16 @@
     # amount of input qubits
 
     from qrisp.core import QuantumVariable
 
     if max_sig > max(significance_range_qf2):
         # print(max_sig-max(significance_range_qf2))
         ancilla_var = QuantumVariable(
-            max_sig - max(significance_range_qf2) - int(qf2.signed))
+            max_sig - max(significance_range_qf2) - int(qf2.signed)
+        )
         augmented_qf2_qbs = qf2.reg + ancilla_var.reg
     else:
         augmented_qf2_qbs = qf2.reg
 
     # Determine the bit window of which bits should participate in the Cuccaro-procedure
     bit_window_1 = [
         significance_range_qf1.index(min_sig),
@@ -287,15 +288,14 @@
                 qs.cx(qf2[-1], ancilla_var[i])
 
     try:
         ancilla_var.delete()
     except NameError:
         pass
 
-
     if qf1.signed and not qf2.signed:
         ancilla_var_2.delete()
 
 
 # Workaround for protecting the docstring from the decorator
 temp = inpl_add.__doc__
 inpl_add = gate_wrap(inpl_add)
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/ripple_division.py` & `qrisp-0.0.16/src/qrisp/arithmetic/ripple_division.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
-from qrisp import x, gate_wrap
+from qrisp import gate_wrap, x
 
 
 @gate_wrap(is_qfree=True, permeability="args")
 def q_int_div(numerator, divisor, adder="cuccaro", n=None, log_output=True):
     # This function performs integer division based on the following algorithm
     # Which is a reformulation of the division algorithm presented in
     # https://en.wikipedia.org/wiki/Division_algorithm#Non-restoring_division
@@ -112,16 +112,15 @@
 
     # Therefore, the required maximum significance is acquired
     # with the formula for addition max_sig_add = max(max_sig_a, max_sig_b) + 1
     remainder_max_sig = max(numerator.mshape[1], divisor.mshape[1]) + 1
 
     # Create remainder float
     remainder_size = remainder_max_sig - remainder_exponent
-    remainder = QuantumFloat(
-        remainder_size, remainder_exponent, signed=True)
+    remainder = QuantumFloat(remainder_size, remainder_exponent, signed=True)
 
     # We now can initialize the remainder as the value of the numerator
     remainder.init_from(numerator)
 
     # If the divisor is signed we need to flip the quotient sign bit (why?)
     if divisor.signed:
         qs.cx(divisor[-1], quotient[-1])
@@ -149,33 +148,32 @@
         # Therefore we need to move this bit from the remainder to the quotient
         # We do this in a very "hacky" fashion
 
         # Remove from remainder
         remainder_sign_bit = remainder.reg.pop(-1)
         remainder.size -= 1
         remainder.mshape[1] -= 1
-        
+
         # Add to quotient at position 0
         quotient.reg.insert(0, remainder_sign_bit)
         quotient.size += 1
         quotient.mshape[1] += 1
-        
+
         # This next instruction is a bit involved to understand
 
         # If we didn't use the technique of transfering the bits from the remainder
         # to the quotient, we would have to call quotient.x() in order to realize
         # the initial Q = 2**n - 1 statement. In this case we would then afterwards
         # CNOT from remainder sign bit it the quotient sign bit from this iteration
         # Since x gate on the quotient qubit and the CNOT commute,
         # we can also perform the x gate after the CNOT
 
         # Translating this to our case we replaced the CNOT with the bit transfer,
         # we arive at the neccessity of an x at this point
         x(quotient[0])
-        
 
         # Since the new bit was added at the least significant end,
         # we need to lower the exponent
         quotient.exp_shift(-1)
 
         # This is to handle the D part of the statement "np.sign(D)*np.sign(R) != 1"
         if divisor.signed:
@@ -191,55 +189,53 @@
         divisor.exp_shift(-1)
 
         # We wrap the remainder in CNOT gates to make use of
         # (R' + D)' = (R - D)
         # where the prime denotes the negation
         for j in range(remainder.size):
             qs.cx(quotient[0], remainder[j])
-        
+
         # This perform the addition R += D or R -= D
         inpl_add(
             remainder,
             divisor,
             ignore_rounding_error=True,
             ignore_overflow_error=True,
             adder=adder,
         )
-        
-        #Instead of executing this layer of CNOT gates,
-        #we use the layer from the next iteration and only
-        #CNOT the control qubit from this layer
+
+        # Instead of executing this layer of CNOT gates,
+        # we use the layer from the next iteration and only
+        # CNOT the control qubit from this layer
         # for j in range(remainder.size):
-            # qs.cx(quotient[0], remainder[j])
-        
-        #We still need to make up for the fact that the next layer of CNOT
-        #gates doesnt include remainder[-1]
-        
+        # qs.cx(quotient[0], remainder[j])
+
+        # We still need to make up for the fact that the next layer of CNOT
+        # gates doesnt include remainder[-1]
+
         # qs.cx(quotient[0], remainder[-1])
-        
-        #However remainder[-1] is also the control qubit of the next iteration
-        #implying our plan of CNOTting the next control qubit cancels the
-        #previous line
-        
+
+        # However remainder[-1] is also the control qubit of the next iteration
+        # implying our plan of CNOTting the next control qubit cancels the
+        # previous line
+
         # qs.cx(quotient[0], remainder[-1])
-        
+
         # In any iteration apart from the first, quotient[0] does not contain
         # the desired value because of the sheenanigans of the previous lines.
         # In detail: It contains the desired value (+) the quotient[0] qubit
         # of the previous iteration. We cancel with this command
         if i != n - 1:
             qs.cx(quotient[1], quotient[0])
-            
 
-    #Since there is no more upcoming iteration, we simply perform the CNOT layer
-    #without any further tricks.
+    # Since there is no more upcoming iteration, we simply perform the CNOT layer
+    # without any further tricks.
     for j in range(remainder.size):
         qs.cx(quotient[0], remainder[j])
 
-
     # This performs the Q -= 2**(n-1) instruction (the -1 qubit is the sign bit =>
     # the -2 qubit is the significance n-1 bit)
     x(quotient[-2])
 
     # Handle the case that the divisor is signed
     if divisor.signed:
         # Create Qubit to account for the fact that we will add 0.5 to the quotient,
@@ -426,15 +422,15 @@
     >>> div[:] = 8
     >>> quotient = q_div(num, div, prec = 2)
     >>> print(quotient)
     {1.25: 1.0}
 
     """
 
-    from qrisp import hybrid_mult, U_g_inpl_adder, h
+    from qrisp import U_g_inpl_adder, h, hybrid_mult
 
     if prec is None:
         prec = divisor.size - numerator.exponent
 
     quotient, remainder = q_divmod(numerator, divisor, prec=prec)
 
     hybrid_mult(quotient, divisor, remainder, init_op="qft", terminal_op=None)
```

### Comparing `qrisp-0.0.15/src/qrisp/arithmetic/ripple_mult.py` & `qrisp-0.0.16/src/qrisp/arithmetic/ripple_mult.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,17 +7,16 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp import x, cx
-from qrisp.arithmetic import inpl_add
-from qrisp.arithmetic import create_output_qf
+from qrisp import cx, x
+from qrisp.arithmetic import create_output_qf, inpl_add
 
 
 def ripple_mult(factor_1, factor_2):
     if factor_1.signed or factor_2.signed:
         raise Exception("Signed ripple multiplication currently not supported")
 
     s = create_output_qf([factor_1, factor_2], op="mul")
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/__init__.py` & `qrisp-0.0.16/src/qrisp/circuit/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,20 +1,21 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 from qrisp.circuit.qubit import *
 from qrisp.circuit.clbit import *
 from qrisp.circuit.operation import *
 from qrisp.circuit.instruction import *
 from qrisp.circuit.transpiler import *
 from qrisp.circuit.quantum_circuit import *
 from qrisp.circuit.standard_operations import *
 from qrisp.circuit.controlled_operations import *
+
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/clbit.py` & `qrisp-0.0.16/src/qrisp/circuit/clbit.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-
 class Clbit:
     """
     This class represents classical bits. Classical bits are created by supplying the
     identifier string.
 
     Examples
     --------
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/controlled_operations.py` & `qrisp-0.0.16/src/qrisp/circuit/controlled_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,16 +7,15 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.circuit import QuantumCircuit
-from qrisp.circuit import Qubit, XGate
+from qrisp.circuit import QuantumCircuit, Qubit, XGate
 
 
 # This function takes a circuit and turns it into it's controlled version
 def multi_controlled_circuit(
     input_circuit, control_amount=1, ctrl_state=-1, method="gray"
 ):
     # Create result circuit
@@ -45,15 +44,15 @@
         )
 
     return controlled_circuit
 
 
 # This function takes an U3Gate object and turns it into it's controlled version
 def multi_controlled_u3_circ(u3_gate, control_amount, ctrl_state, method="gray"):
-    from qrisp.circuit.multi_cx import multi_cx
+    from qrisp.misc.multi_cx import multi_cx
     from qrisp.logic_synthesis import gray_phase_synth_qb_list
 
     qc = QuantumCircuit(control_amount + 1)
 
     # Apply control state specification
     for i in range(len(ctrl_state)):
         if ctrl_state[i] == "0":
@@ -105,20 +104,20 @@
 
     elif u3_gate.phi == 0 and u3_gate.lam == 0 and u3_gate.theta == 0:
         pass
 
     # Treat pauli gates
     elif u3_gate.name == "y":
         qc.s(-1)
-        qc.append(XGate().control(control_amount, method = method), qc.qubits)
+        qc.append(XGate().control(control_amount, method=method), qc.qubits)
         qc.s_dg(-1)
 
     elif u3_gate.name == "z":
         qc.h(-1)
-        qc.append(XGate().control(control_amount, method = method), qc.qubits)
+        qc.append(XGate().control(control_amount, method=method), qc.qubits)
         qc.h(-1)
 
     elif u3_gate.name == "x":
         qc.append(multi_cx(control_amount, method), qc.qubits)
 
     # Treat general U3Gates
     else:
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/instruction.py` & `qrisp-0.0.16/src/qrisp/circuit/instruction.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,22 +7,21 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-
 class Instruction:
     """
     This class combines Operation objects with their operands (ie. qubits and classical
     bits). The data attribut of the QuantumCircuit class consists of a list of
     Instructions.
 
-    Instructions can be added to QuantumCircuits using the 
+    Instructions can be added to QuantumCircuits using the
     `append <qrisp.QuantumCircuit.append>` method without any
     qubit/ classical bit arguments.
 
     Parameters
     ----------
     op : Operation
         The Operation object.
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/multi_cx.py` & `qrisp-0.0.16/src/qrisp/misc/multi_cx.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,686 +1,722 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-import numpy as np
-from qrisp import QuantumCircuit, RYGate, QuantumBool, cx, x, h, s, s_dg, mcx, invert, bin_rep, QuantumVariable, TruthTable, XGate, PGate, QuantumSession
-from qrisp.misc.GMS_tools import GXX_wrapper
-
-#Interface function to quickly change between different implementations of multi controlled not gates
-def multi_cx(n, method = None):
-    
-    #from qrisp.circuit import transpile
-    
-    if method == "gms":
-        return gms_multi_cx(n)    
-        
-
-    elif method == "gray_pt":
-        
-        return pt_multi_cx(n)
-    
-    elif method == "gray_pt_inv":
-        
-        return pt_multi_cx(n).inverse()
-        
-    elif method in ["gray", "auto", None]:
-        
-        return gray_multi_cx(n)
-    
-    else:
-        raise Exception("method \"" + method + "\" not implemented")
-
-
-#Function to synthesize a multi controlled CX gate from GMS gates
-def gms_multi_cx(n):
-    
-    qc = QuantumCircuit(n+1)
-    
-    if n == 2:
-        for i in range(3):
-            qc.ry(np.pi/2, i)
-        
-        qc.rz(np.pi/4, 2)
-        
-        qc.append(GXX_wrapper(3, 3*[3*[np.pi/2]]), qc.qubits)
-        
-        for i in range(3):
-            qc.rx(-np.pi/2, i)
-            
-        qc.rz(-np.pi/2, 2)
-        
-        for i in range(3):
-            qc.rx(-np.pi/4, i)
-        
-        qc.append(GXX_wrapper(3, 3*[3*[np.pi/4]]), qc.qubits)
-        
-        qc.rz(np.pi/2, 2)
-
-        qc.append(GXX_wrapper(3, 3*[3*[np.pi/2]]), qc.qubits)
-        
-        for i in range(3):
-            qc.rx(np.pi/2,i)
-            qc.ry(-np.pi/2,i)
-        
-        result = qc.to_gate()
-        
-        result.name = "GMS toffoli"
-        
-        return result
-    else:
-        raise Exception(str(n) + "-controlled x gate not implemented for gms method")
-        
-
-def gray_pt_mcx(n, ctrl_state):
-    
-    input_qv = QuantumVariable(n)
-    output_qv = QuantumVariable(1, qs = input_qv.qs)
-    
-    
-    tt_str = 2**n*["0"]
-    tt_str[int(ctrl_state[::-1], 2)] = "1"
-    
-    tt = TruthTable([tt_str])
-    
-    tt.q_synth(input_qv, output_qv, method = "gray_pt")
-
-    res = input_qv.qs.copy()
-    return res.to_gate(f"pt{n}cx")
-
-#Function to synthesize a phase tolerant multi controlled X gate
-def pt_multi_cx(n, reduced = False):
-    
-    res = QuantumCircuit(n+1)
-
-    if n == 1:
-        res.cx(0,1)
-        
-    #The special cases n = 2 and n = 3 are handled as described in https://arxiv.org/pdf/1508.03273.pdf
-    elif n == 2:
-        
-        if reduced:
-            res.append(reduced_margolus_qc.to_gate("reduced margolus"), res.qubits)
-        else:
-            res.append(margolus_qc.to_gate("margolus"), res.qubits)
-    
-    
-    elif n == 3:
-        
-        if reduced:
-            res.append(reduced_maslov_qc.to_gate("reduced maslov"), res.qubits)
-        else:
-            res.append(maslov_qc.to_gate("maslov"), res.qubits)
-    else:
-        
-        input_qv = QuantumVariable(n)
-        output_qv = QuantumVariable(1, qs = input_qv.qs)
-        
-        tt = TruthTable([(2**(n)-1)*"0"+"1"])
-        
-        tt.q_synth(input_qv, output_qv, method = "gray_pt")
-    
-        res = input_qv.qs.copy()
-        
-    return res.to_gate(f"pt{n}cx")
-
-
-#Toffoli Implementation according to https://arxiv.org/pdf/1206.0758.pdf
-toffoli_qc = QuantumCircuit(3)
-
-toffoli_qc.h(2)
-toffoli_qc.p(-np.pi/4, [0,1])
-toffoli_qc.cx(2,0)
-toffoli_qc.cx(1,2)
-toffoli_qc.p(np.pi/4, 0)
-toffoli_qc.cx(1,0)
-toffoli_qc.p(np.pi/4, 2)
-toffoli_qc.cx(1,2)
-toffoli_qc.p(-np.pi/4, 0)
-toffoli_qc.cx(2,0)
-toffoli_qc.p(np.pi/4, 0)
-toffoli_qc.p(-np.pi/4, 2)
-toffoli_qc.cx(1,0)
-toffoli_qc.h(2)
-
-
-margolus_qc = QuantumCircuit(3)
-G = RYGate(np.pi/4)
-
-margolus_qc.append(G, 2)
-margolus_qc.cx(1,2)
-margolus_qc.append(G, 2)
-margolus_qc.cx(0,2)
-
-reduced_margolus_qc = margolus_qc.copy()
-
-margolus_qc.append(G.inverse(), 2)
-margolus_qc.cx(1,2)
-margolus_qc.append(G.inverse(), 2)
-
-
-
-maslov_qc = QuantumCircuit(4)
-
-maslov_qc.h(3)
-maslov_qc.t(3)        
-maslov_qc.cx(2,3)
-maslov_qc.t_dg(3)        
-maslov_qc.h(3)
-maslov_qc.cx(0,3)
-maslov_qc.t(3)
-maslov_qc.cx(1,3)
-maslov_qc.t_dg(3)
-maslov_qc.cx(0,3)
-
-reduced_maslov_qc = maslov_qc.copy()
-
-maslov_qc.t(3)
-maslov_qc.cx(1,3)
-maslov_qc.t_dg(3)
-maslov_qc.h(3)
-maslov_qc.t(3)
-maslov_qc.cx(2,3)
-maslov_qc.t_dg(3)
-maslov_qc.h(3)
-
-
-#Ancilla supported multi controlled X gates from https://arxiv.org/pdf/1508.03273.pdf
-def maslov_mcx(n, ctrl_state = -1):
-    if not isinstance(ctrl_state, str):
-        if ctrl_state == -1:
-            ctrl_state += 2**n
-        ctrl_state = bin_rep(ctrl_state, n)
-    
-    res = QuantumCircuit(n+1)
-    for i in range(len(ctrl_state)):
-        if ctrl_state[i] == "0":
-            res.x(i)
-    
-    if n == 1:
-        res.cx(0,1)
-    elif n == 2:
-        res.append(toffoli_qc.to_gate("toffoli"), res.qubits)
-    elif n == 3:
-        res.add_qubit()
-        res.append(margolus_qc.to_gate(), [0,1,3])
-        res.append(toffoli_qc.to_gate(), [2,3,4])
-        res.append(margolus_qc.inverse().to_gate(), [0,1,3])
-    elif n == 4:
-        res.add_qubit()
-        res.append(maslov_qc.to_gate(), [0,1,2,4])
-        res.append(toffoli_qc.to_gate(), [3,4,5])
-        res.append(maslov_qc.inverse().to_gate(), [0,1,2,4])
-    else:
-        raise Exception("Multi CX for method \"Maslov\" only defined for n <= 4")
-    
-    for i in range(len(ctrl_state)):
-        if ctrl_state[i] == "0":
-            res.x(i)
-            
-    return res.to_gate(f"maslov {n}cx")
-
-
-
-#Function to synthesize a multi controlled X gate using gray synthesis
-def gray_multi_cx(n):
-    qs = QuantumSession()
-    input_qv = QuantumVariable(n, qs)
-    output_qv = QuantumVariable(1, qs)
-
-    if n == 1:
-        qs.cx(0,1)
-    elif n == 2:
-        qs = toffoli_qc.copy()
-        
-    else:
-        tt_array = np.zeros((2**n,1))
-        tt_array[-1,0] = 1
-        
-        tt = TruthTable(tt_array)
-        
-        tt.q_synth(input_qv, output_qv, method = "gray")
-    
-    
-    result = qs.to_gate()
-    result.name = "gray multi cx"
-    
-    return result
-
-
-#Ancilla supported multi controlled X with logarithmic depth based on https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf
-def balauca_mcx(input_qubits, target, ctrl_state = None, phase = None):
-    hybrid_mcx(input_qubits, target, ctrl_state = ctrl_state, phase = phase, num_ancilla = np.inf)
-
-
-#Algorithm based on https://link.springer.com/article/10.1007/s10773-017-3389-4
-def yong_mcx(input_qubits, target, ancilla = None, ctrl_state = None):
-    
-    if isinstance(target, list):
-        if len(target) != 1:
-            raise Exception("Tried to execute yong algorithm with multiple targets")
-        target = target[0]
-    
-    if not ctrl_state is None:
-        for i in range(len(input_qubits)):
-            input_qubits[i].ctrl_state = ctrl_state[i]
-    
-    if len(input_qubits) < 3:
-        ctrl_state = ""
-        for i in range(len(input_qubits)):
-            if hasattr(input_qubits[i], "ctrl_state"):
-                ctrl_state += input_qubits[i].ctrl_state
-            else:
-                ctrl_state += "1"
-    
-    
-    if len(input_qubits) == 2:
-        if ancilla is None:
-            mcx(input_qubits, target, method = "gray", ctrl_state = ctrl_state)
-        else:
-            target.qs().append(gray_pt_mcx(2, ctrl_state = ctrl_state), input_qubits + [target])
-            # mcx(input_qubits, target, method = "gray_pt", ctrl_state = ctrl_state)
-        return
-    
-    ancilla_allocated = False
-    
-    if ancilla is None:
-        ancilla_allocated = True
-        ancilla_bl = QuantumBool(name = "yong_anc*")
-        ancilla = ancilla_bl[0]
-    
-    n = len(input_qubits)
-        
-    partition_k_1 = input_qubits[n//2:]
-    partition_k_2 = input_qubits[:n//2]
-    
-    h(target)
-    
-    yong_mcx(input_qubits = partition_k_1, 
-             target = ancilla, 
-             ancilla = partition_k_2[-1])
-    
-    s(ancilla)
-    
-    yong_mcx(input_qubits = partition_k_2 + [target], 
-             target = ancilla, 
-             ancilla = partition_k_1[-1])
-    
-    s_dg(ancilla)
-    
-    with invert():
-        
-        s(ancilla)
-        
-        yong_mcx(input_qubits = partition_k_2 + [target], 
-                 target = ancilla, 
-                 ancilla = partition_k_1[0])
-        
-        s_dg(ancilla)
-        
-        yong_mcx(input_qubits = partition_k_1, 
-                 target = ancilla, 
-                 ancilla = partition_k_2[0])
-    
-    h(target)
-    
-    if ancilla_allocated:
-        ancilla_bl.delete()
-    
-    if not ctrl_state is None:
-        for i in range(len(input_qubits)):
-            del input_qubits[i].ctrl_state
-
-
-
-#Hybrid algorithm of yong and balauca with customizable ancilla qubit count.
-#Performs several balauca layers and cancels the recursion with yong.
-def hybrid_mcx(input_qubits, target, ctrl_state = None, phase = None, num_ancilla = np.inf, num_dirty_ancilla = 0):
-    """
-    Function to dynamically generate mcx gates for a given amount of ancilla qubits.
-
-    Parameters
-    ----------
-    input_qubits : list[Qubit]
-        The Qubits to control on.
-    target : Qubit
-        The Qubit to target.
-    ctrl_state : str, optional
-        The control state to activate the X Gate on. The default is "11..".
-    phase : float or sympy.Symbol, optional
-        If given, this function performs a mcp instead of an mcx. The default is None.
-    num_ancilla : int, optional
-        The amount of ancillae this function is allowed to use. The default is np.inf.
-    count_yong : bool, optional
-        If set to False, the ancilla that is used by the yong recursion termintation is not counted (because it can be dirty). The default is True.
-
-    Returns
-    -------
-    None.
-
-    """
-    
-    input_qubits = list(input_qubits)
-    for i in range(len(input_qubits)):
-        if isinstance(input_qubits[i], QuantumBool):
-            input_qubits[i] = input_qubits[i][0]
-    
-    if not ctrl_state is None:
-        for i in range(len(input_qubits)):
-            input_qubits[i].ctrl_state = ctrl_state[i]
-            
-    target = list(target)
-    
-    qs = target[0].qs()
-    
-    if len(input_qubits) <= 3 or num_ancilla == 0:
-        ctrl_state = ""
-        for qb in input_qubits:
-            if hasattr(qb, "ctrl_state"):
-                ctrl_state += qb.ctrl_state
-            else:
-                ctrl_state += "1"
-        
-        if len(input_qubits) == 2:
-            if phase is None:
-                qs.append(XGate().control(2, ctrl_state = ctrl_state, method = "gray"), input_qubits + [target])
-            else:
-                qs.append(PGate(phase).control(2, ctrl_state = ctrl_state), input_qubits + [target])
-
-        elif num_dirty_ancilla and phase is None:
-            balauca_dirty(input_qubits, target, k = num_dirty_ancilla, ctrl_state = ctrl_state)
-            
-        else:
-            if phase is None:
-                qs.append(XGate().control(len(input_qubits), ctrl_state = ctrl_state, method = "gray"), input_qubits + [target])
-            else:
-                qs.append(PGate(phase).control(len(input_qubits), ctrl_state = ctrl_state), input_qubits + [target])
-        return
-    
-    structure = structure_decider(len(input_qubits), num_ancilla)#[::-1]
-    layer_input = []
-    layer_structure = []
-    layer_output = []
-    remainder = list(input_qubits)
-    
-    
-    for i in range(len(structure)):
-        if not structure[0] <= len(remainder):
-            break
-            
-        layer_output.append(QuantumBool(name = "balauca_anc*"))
-        
-        for j in range(structure[0]):
-            layer_input.append(remainder.pop(0))
-
-        layer_structure.append(structure.pop(0))
-    
-    
-    balauca_layer(layer_input, layer_output, structure = layer_structure, invert = False)
-
-    hybrid_mcx(layer_output + remainder, target, num_ancilla = num_ancilla - len(layer_output), num_dirty_ancilla = num_dirty_ancilla, phase = phase)
-
-    balauca_layer(layer_input, layer_output, structure = layer_structure, invert = True)
-    
-    
-    [qbl.delete() for qbl in layer_output]
-    
-    if not ctrl_state is None:
-        for i in range(len(input_qubits)):
-            del input_qubits[i].ctrl_state
-    
-    return
-    
-
-def balauca_layer(input_qubits, output_qubits, structure, invert = False):
-    
-    if not output_qubits:
-        return
-    
-    qs = output_qubits[0].qs()
-    input_qubits = list(input_qubits)
-    
-    counter = 0
-    for i in range(len(output_qubits)):
-        
-        if structure[i] == 3:
-            
-            ctrl_qubits = [input_qubits[counter], input_qubits[counter+1], input_qubits[counter+2]]
-            counter += 3
-            
-            ctrl_state = ""
-            for qb in ctrl_qubits:
-                
-                if hasattr(qb, "ctrl_state"):
-                    ctrl_state += qb.ctrl_state
-                else:
-                    ctrl_state += "1"
-            
-            
-            gate = XGate().control(3, method = "gray_pt", ctrl_state = ctrl_state)
-            
-            if invert:
-                gate = gate.inverse()
-                
-            qs.append(gate, ctrl_qubits + [output_qubits[i]])
-        else:
-            
-            ctrl_qubits = [input_qubits[counter], input_qubits[counter+1]]
-            counter += 2
-            
-            ctrl_state = ""
-            for qb in ctrl_qubits:
-                
-                if hasattr(qb, "ctrl_state"):
-                    ctrl_state += qb.ctrl_state
-                else:
-                    ctrl_state += "1"
-            
-            
-            
-            gate = XGate().control(2, method = "gray_pt", ctrl_state = ctrl_state)
-            
-            if invert:
-                gate = gate.inverse()
-            
-            qs.append(gate, ctrl_qubits + [output_qubits[i]])
-            
-    return
-
-def structure_decider(n, k):
-    #Each element of a Balauca layer reduces the amount of
-    #Control qubits for the next layer either by 1 (margolous gate)
-    #or by 2 (phase toleratn maslov gate). Ideally, we reduce the amount
-    #of control qubits to 3 so we can cancel the recursion
-    #and deploy a Toffoli.
-    
-    #If we have n controls, p = n - 2 is the amount of reductions,
-    #that need to be performed.
-    
-    #If we have k ancillae at our disposal, we need to satisfy:
-        
-    #p = 2*triple_mcx + (k-triple_mcx_count) = k + triple_mcx_count
-    
-    # <=> triple_mcx_count = n - 2 - k
-    
-    triple_mcx_count = n - 2 - k
-    
-    if triple_mcx_count <= 0:
-        if n%2:
-            return (n-3)//2*[2] + [3]
-        else:
-            return n//2*[2]
-    elif triple_mcx_count > k:
-        return k*[3]
-    else:
-        return triple_mcx_count*[3] + (k-triple_mcx_count)*[2]
-    
-    
-    
-from qrisp import convert_to_qb_list
-def vchain_2_dirty(control, target, dirty_ancillae = None):
-    
-    
-    control = convert_to_qb_list(control)
-    target = convert_to_qb_list(target)
-    
-    
-    if len(control) == 1:
-        cx(control, target)
-        return
-    elif len(control) == 2:
-        mcx(control, target, method = "gray")
-    
-    
-    n = len(control)
-    k = n - 2
-    
-    dirty_ancilla_qbls = []
-    if dirty_ancillae is None:
-        dirty_ancilla_qbls = [QuantumBool(name = "vchain_2_dirty*") for i in range(k)]
-        dirty_ancillae = [qbl[0] for qbl in dirty_ancilla_qbls]
-    
-    def reduced_margolus(control, target):
-        qs = target.qs()
-        
-        control = list(control)
-        qs.append(reduced_margolus_qc.to_gate("reduced_margolus"), control + [target])
-        # qs.append(XGate().control(2), control + [target])
-    
-    def margolus(control, target):
-        qs = target.qs()
-        
-        control = list(control)
-        qs.append(margolus_qc.to_gate("margolus"), control + [target])
-        # qs.append(XGate().control(2), control + [target])
-    
-    
-    control_temp_list = list(control)
-    dirty_ancillae_temp_list = list(dirty_ancillae)
-    qubit_list = []
-    
-    qubit_list.append(control_temp_list.pop(0))
-    qubit_list.append(control_temp_list.pop(0))
-    
-    while control_temp_list:
-        qubit_list.append(dirty_ancillae_temp_list.pop(0))
-        qubit_list.append(control_temp_list.pop(0))
-    
-    
-    qubit_list.append(target[0])
-    
-    m = len(qubit_list)
-    
-    for i in range(k):
-        if i == k - 1:
-            margolus([qubit_list[m-5-2*i], qubit_list[m-4-2*i]], qubit_list[m-3-2*i])
-        else:
-            reduced_margolus([qubit_list[m-5-2*i], qubit_list[m-4-2*i]], qubit_list[m-3-2*i])
-    
-    
-    for i in range(k):
-        if i == k - 1:
-            reduced_margolus([qubit_list[2*i+2], qubit_list[2*i+3]], qubit_list[2*i+4])
-        else:
-            with invert():
-                reduced_margolus([qubit_list[2*i+2], qubit_list[2*i+3]], qubit_list[2*i+4])
-    
-    
-    for i in range(k):
-        if i == k - 1:
-            with invert():
-                margolus([qubit_list[m-5-2*i], qubit_list[m-4-2*i]], qubit_list[m-3-2*i])
-        else:
-            reduced_margolus([qubit_list[m-5-2*i], qubit_list[m-4-2*i]], qubit_list[m-3-2*i])
-    
-    
-    for i in range(k):
-        if i == k - 1:
-            with invert():
-                reduced_margolus([qubit_list[2*i+2], qubit_list[2*i+3]], qubit_list[2*i+4])
-        else:
-            with invert():
-                reduced_margolus([qubit_list[2*i+2], qubit_list[2*i+3]], qubit_list[2*i+4])        
-
-
-    [qbl.delete() for qbl in dirty_ancilla_qbls]
-    
-
-def balauca_dirty(control, target, k, dirty_ancillae = None, ctrl_state = None):
-    
-    control = convert_to_qb_list(control)
-    target = convert_to_qb_list(target)
-    qs = target[0].qs()
-    
-    n = len(control)
-    
-    k = min((n-2)//2+1, k)
-    
-    if k == 0:
-        qs.append(XGate().control(n, ctrl_state = ctrl_state, method = "gray"), list(control) + [target])
-        return
-    
-    
-    if not ctrl_state is None:
-        for i in range(len(ctrl_state)):
-            if ctrl_state[i] == "0":
-                x(control[i])
-    
-    
-    def reduced_maslov(control, target):
-        qs = target.qs()
-        
-        qs.append(reduced_maslov_qc.to_gate("reduced_maslov"), control + [target])
-        # qs.append(XGate().control(2), control + [target])
-    
-    
-    m_1 = int(np.ceil((n - 2*(k-1))/2))
-    m_2 = int(np.floor((n - 2*(k-1))/2))
-    
-    dirty_ancilla_qbls = []
-    if dirty_ancillae is None:
-        dirty_ancilla_qbls = [QuantumBool(name = "balauca_dirty*", qs = qs) for i in range(k)]
-        dirty_ancillae = [qbl[0] for qbl in dirty_ancilla_qbls]
-    
-    
-    upper_block_qubits = control[:m_1] + [dirty_ancillae[0]]
-    lower_block_qubits = control[-m_2:] + [dirty_ancillae[-1]]
-    
-    def balauca_dirty_helper(control, target, ancillae):
-        
-        if len(ancillae) == 0:
-            vchain_2_dirty(control, target, dirty_ancillae = lower_block_qubits)
-            # mcx(control, target)
-            return
-        
-        reduced_maslov([ancillae[-1]] + control[-2:], target)
-        
-        balauca_dirty_helper(control[:-2], ancillae[-1], ancillae[:-1])
-        
-        with invert():
-            reduced_maslov([ancillae[-1]] + control[-2:], target)
-            
-    
-    vchain_2_dirty(lower_block_qubits, target, dirty_ancillae = upper_block_qubits)
-    
-    balauca_dirty_helper(control[:-m_2], dirty_ancillae[-1], dirty_ancillae[:-1])
-    
-    vchain_2_dirty(lower_block_qubits, target, dirty_ancillae = upper_block_qubits)
-    
-    balauca_dirty_helper(control[:-m_2], dirty_ancillae[-1], dirty_ancillae[:-1])
-
-    [qbl.delete() for qbl in dirty_ancilla_qbls]
-    
-    if not ctrl_state is None:
-        for i in range(len(ctrl_state)):
-            if ctrl_state[i] == "0":
-                x(control[i])
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+import numpy as np
+
+from qrisp import (
+    PGate,
+    QuantumBool,
+    QuantumCircuit,
+    QuantumSession,
+    QuantumVariable,
+    convert_to_qb_list,
+    RYGate,
+    TruthTable,
+    XGate,
+    bin_rep,
+    cx,
+    h,
+    invert,
+    mcx,
+    s,
+    s_dg,
+    x,
+)
+from qrisp.misc.GMS_tools import GXX_wrapper
+
+
+# Interface function to quickly change between different implementations of
+# multi controlled not gates
+def multi_cx(n, method=None):
+    # from qrisp.circuit import transpile
+
+    if method == "gms":
+        return gms_multi_cx(n)
+
+    elif method == "gray_pt":
+        return pt_multi_cx(n)
+
+    elif method == "gray_pt_inv":
+        return pt_multi_cx(n).inverse()
+
+    elif method in ["gray", "auto", None]:
+        return gray_multi_cx(n)
+
+    else:
+        raise Exception('method "' + method + '" not implemented')
+
+
+# Function to synthesize a multi controlled CX gate from GMS gates
+def gms_multi_cx(n):
+    qc = QuantumCircuit(n + 1)
+
+    if n == 2:
+        for i in range(3):
+            qc.ry(np.pi / 2, i)
+
+        qc.rz(np.pi / 4, 2)
+
+        qc.append(GXX_wrapper(3, 3 * [3 * [np.pi / 2]]), qc.qubits)
+
+        for i in range(3):
+            qc.rx(-np.pi / 2, i)
+
+        qc.rz(-np.pi / 2, 2)
+
+        for i in range(3):
+            qc.rx(-np.pi / 4, i)
+
+        qc.append(GXX_wrapper(3, 3 * [3 * [np.pi / 4]]), qc.qubits)
+
+        qc.rz(np.pi / 2, 2)
+
+        qc.append(GXX_wrapper(3, 3 * [3 * [np.pi / 2]]), qc.qubits)
+
+        for i in range(3):
+            qc.rx(np.pi / 2, i)
+            qc.ry(-np.pi / 2, i)
+
+        result = qc.to_gate()
+
+        result.name = "GMS toffoli"
+
+        return result
+    else:
+        raise Exception(str(n) + "-controlled x gate not implemented for gms method")
+
+
+def gray_pt_mcx(n, ctrl_state):
+    input_qv = QuantumVariable(n)
+    output_qv = QuantumVariable(1, qs=input_qv.qs)
+
+    tt_str = 2 ** n * ["0"]
+    tt_str[int(ctrl_state[::-1], 2)] = "1"
+
+    tt = TruthTable([tt_str])
+
+    tt.q_synth(input_qv, output_qv, method="gray_pt")
+
+    res = input_qv.qs.copy()
+    return res.to_gate(f"pt{n}cx")
+
+
+# Function to synthesize a phase tolerant multi controlled X gate
+def pt_multi_cx(n, reduced=False):
+    res = QuantumCircuit(n + 1)
+
+    if n == 1:
+        res.cx(0, 1)
+
+    # The special cases n = 2 and n = 3 are handled as described in
+    # https://arxiv.org/pdf/1508.03273.pdf
+    elif n == 2:
+        if reduced:
+            res.append(reduced_margolus_qc.to_gate("reduced margolus"), res.qubits)
+        else:
+            res.append(margolus_qc.to_gate("margolus"), res.qubits)
+
+    elif n == 3:
+        if reduced:
+            res.append(reduced_maslov_qc.to_gate("reduced maslov"), res.qubits)
+        else:
+            res.append(maslov_qc.to_gate("maslov"), res.qubits)
+    else:
+        input_qv = QuantumVariable(n)
+        output_qv = QuantumVariable(1, qs=input_qv.qs)
+
+        tt = TruthTable([(2 ** (n) - 1) * "0" + "1"])
+
+        tt.q_synth(input_qv, output_qv, method="gray_pt")
+
+        res = input_qv.qs.copy()
+
+    return res.to_gate(f"pt{n}cx")
+
+
+# Toffoli Implementation according to https://arxiv.org/pdf/1206.0758.pdf
+toffoli_qc = QuantumCircuit(3)
+
+toffoli_qc.h(2)
+toffoli_qc.p(-np.pi / 4, [0, 1])
+toffoli_qc.cx(2, 0)
+toffoli_qc.cx(1, 2)
+toffoli_qc.p(np.pi / 4, 0)
+toffoli_qc.cx(1, 0)
+toffoli_qc.p(np.pi / 4, 2)
+toffoli_qc.cx(1, 2)
+toffoli_qc.p(-np.pi / 4, 0)
+toffoli_qc.cx(2, 0)
+toffoli_qc.p(np.pi / 4, 0)
+toffoli_qc.p(-np.pi / 4, 2)
+toffoli_qc.cx(1, 0)
+toffoli_qc.h(2)
+
+margolus_qc = QuantumCircuit(3)
+G = RYGate(np.pi / 4)
+
+margolus_qc.append(G, 2)
+margolus_qc.cx(1, 2)
+margolus_qc.append(G, 2)
+margolus_qc.cx(0, 2)
+
+reduced_margolus_qc = margolus_qc.copy()
+
+margolus_qc.append(G.inverse(), 2)
+margolus_qc.cx(1, 2)
+margolus_qc.append(G.inverse(), 2)
+
+maslov_qc = QuantumCircuit(4)
+
+maslov_qc.h(3)
+maslov_qc.t(3)
+maslov_qc.cx(2, 3)
+maslov_qc.t_dg(3)
+maslov_qc.h(3)
+maslov_qc.cx(0, 3)
+maslov_qc.t(3)
+maslov_qc.cx(1, 3)
+maslov_qc.t_dg(3)
+maslov_qc.cx(0, 3)
+
+reduced_maslov_qc = maslov_qc.copy()
+
+maslov_qc.t(3)
+maslov_qc.cx(1, 3)
+maslov_qc.t_dg(3)
+maslov_qc.h(3)
+maslov_qc.t(3)
+maslov_qc.cx(2, 3)
+maslov_qc.t_dg(3)
+maslov_qc.h(3)
+
+
+# Ancilla supported multi controlled X gates from https://arxiv.org/pdf/1508.03273.pdf
+def maslov_mcx(n, ctrl_state=-1):
+    if not isinstance(ctrl_state, str):
+        if ctrl_state == -1:
+            ctrl_state += 2 ** n
+        ctrl_state = bin_rep(ctrl_state, n)
+
+    res = QuantumCircuit(n + 1)
+    for i in range(len(ctrl_state)):
+        if ctrl_state[i] == "0":
+            res.x(i)
+
+    if n == 1:
+        res.cx(0, 1)
+    elif n == 2:
+        res.append(toffoli_qc.to_gate("toffoli"), res.qubits)
+    elif n == 3:
+        res.add_qubit()
+        res.append(margolus_qc.to_gate(), [0, 1, 3])
+        res.append(toffoli_qc.to_gate(), [2, 3, 4])
+        res.append(margolus_qc.inverse().to_gate(), [0, 1, 3])
+    elif n == 4:
+        res.add_qubit()
+        res.append(maslov_qc.to_gate(), [0, 1, 2, 4])
+        res.append(toffoli_qc.to_gate(), [3, 4, 5])
+        res.append(maslov_qc.inverse().to_gate(), [0, 1, 2, 4])
+    else:
+        raise Exception('Multi CX for method "Maslov" only defined for n <= 4')
+
+    for i in range(len(ctrl_state)):
+        if ctrl_state[i] == "0":
+            res.x(i)
+
+    return res.to_gate(f"maslov {n}cx")
+
+
+# Function to synthesize a multi controlled X gate using gray synthesis
+def gray_multi_cx(n):
+    qs = QuantumSession()
+    input_qv = QuantumVariable(n, qs)
+    output_qv = QuantumVariable(1, qs)
+
+    if n == 1:
+        qs.cx(0, 1)
+    elif n == 2:
+        qs = toffoli_qc.copy()
+
+    else:
+        tt_array = np.zeros((2 ** n, 1))
+        tt_array[-1, 0] = 1
+
+        tt = TruthTable(tt_array)
+
+        tt.q_synth(input_qv, output_qv, method="gray")
+
+    result = qs.to_gate()
+    result.name = "gray multi cx"
+
+    return result
+
+
+# Ancilla supported multi controlled X with logarithmic depth based on
+# https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf
+def balauca_mcx(input_qubits, target, ctrl_state=None, phase=None):
+    hybrid_mcx(
+        input_qubits, target, ctrl_state=ctrl_state, phase=phase, num_ancilla=np.inf
+    )
+
+
+# Algorithm based on https://link.springer.com/article/10.1007/s10773-017-3389-4
+def yong_mcx(input_qubits, target, ancilla=None, ctrl_state=None):
+    if isinstance(target, list):
+        if len(target) != 1:
+            raise Exception("Tried to execute yong algorithm with multiple targets")
+        target = target[0]
+
+    if ctrl_state is not None:
+        for i in range(len(input_qubits)):
+            input_qubits[i].ctrl_state = ctrl_state[i]
+
+    if len(input_qubits) < 3:
+        ctrl_state = ""
+        for i in range(len(input_qubits)):
+            if hasattr(input_qubits[i], "ctrl_state"):
+                ctrl_state += input_qubits[i].ctrl_state
+            else:
+                ctrl_state += "1"
+
+    if len(input_qubits) == 2:
+        if ancilla is None:
+            mcx(input_qubits, target, method="gray", ctrl_state=ctrl_state)
+        else:
+            target.qs().append(
+                gray_pt_mcx(2, ctrl_state=ctrl_state), input_qubits + [target]
+            )
+            # mcx(input_qubits, target, method = "gray_pt", ctrl_state = ctrl_state)
+        return
+
+    ancilla_allocated = False
+
+    if ancilla is None:
+        ancilla_allocated = True
+        ancilla_bl = QuantumBool(name="yong_anc*")
+        ancilla = ancilla_bl[0]
+
+    n = len(input_qubits)
+
+    partition_k_1 = input_qubits[n // 2:]
+    partition_k_2 = input_qubits[: n // 2]
+
+    h(target)
+
+    yong_mcx(input_qubits=partition_k_1, target=ancilla, ancilla=partition_k_2[-1])
+
+    s(ancilla)
+
+    yong_mcx(
+        input_qubits=partition_k_2 + [target], target=ancilla, ancilla=partition_k_1[-1]
+    )
+
+    s_dg(ancilla)
+
+    with invert():
+        s(ancilla)
+
+        yong_mcx(
+            input_qubits=partition_k_2 + [target],
+            target=ancilla,
+            ancilla=partition_k_1[0],
+        )
+
+        s_dg(ancilla)
+
+        yong_mcx(input_qubits=partition_k_1, target=ancilla, ancilla=partition_k_2[0])
+
+    h(target)
+
+    if ancilla_allocated:
+        ancilla_bl.delete()
+
+    if ctrl_state is not None:
+        for i in range(len(input_qubits)):
+            del input_qubits[i].ctrl_state
+
+
+# Hybrid algorithm of yong and balauca with customizable ancilla qubit count.
+# Performs several balauca layers and cancels the recursion with yong.
+def hybrid_mcx(
+        input_qubits,
+        target,
+        ctrl_state=None,
+        phase=None,
+        num_ancilla=np.inf,
+        num_dirty_ancilla=0,
+):
+    """
+    Function to dynamically generate mcx gates for a given amount of ancilla qubits.
+
+    Parameters
+    ----------
+    input_qubits : list[Qubit]
+        The Qubits to control on.
+    target : Qubit
+        The Qubit to target.
+    ctrl_state : str, optional
+        The control state to activate the X Gate on. The default is "11...".
+    phase : float or sympy.Symbol, optional
+        If given, this function performs a mcp instead of a mcx. The default is None.
+    num_ancilla : int, optional
+        The amount of ancillae this function is allowed to use. The default is np.inf.
+    count_yong : bool, optional
+        If set to False, the ancilla that is used by the yong recursion termination is
+        not counted (because it can be dirty). The default is True.
+
+    Returns
+    -------
+    None.
+
+    """
+
+    input_qubits = list(input_qubits)
+    for i in range(len(input_qubits)):
+        if isinstance(input_qubits[i], QuantumBool):
+            input_qubits[i] = input_qubits[i][0]
+
+    if ctrl_state is not None:
+        for i in range(len(input_qubits)):
+            input_qubits[i].ctrl_state = ctrl_state[i]
+
+    target = list(target)
+
+    qs = target[0].qs()
+
+    if len(input_qubits) <= 3 or num_ancilla == 0:
+        ctrl_state = ""
+        for qb in input_qubits:
+            if hasattr(qb, "ctrl_state"):
+                ctrl_state += qb.ctrl_state
+            else:
+                ctrl_state += "1"
+
+        if len(input_qubits) == 2:
+            if phase is None:
+                qs.append(
+                    XGate().control(2, ctrl_state=ctrl_state, method="gray"),
+                    input_qubits + [target],
+                )
+            else:
+                qs.append(
+                    PGate(phase).control(2, ctrl_state=ctrl_state),
+                    input_qubits + [target],
+                )
+
+        elif num_dirty_ancilla and phase is None:
+            balauca_dirty(
+                input_qubits, target, k=num_dirty_ancilla, ctrl_state=ctrl_state
+            )
+
+        else:
+            if phase is None:
+                qs.append(
+                    XGate().control(
+                        len(input_qubits), ctrl_state=ctrl_state, method="gray"
+                    ),
+                    input_qubits + [target],
+                )
+            else:
+                qs.append(
+                    PGate(phase).control(len(input_qubits), ctrl_state=ctrl_state),
+                    input_qubits + [target],
+                )
+        return
+
+    structure = structure_decider(len(input_qubits), num_ancilla)  # [::-1]
+    layer_input = []
+    layer_structure = []
+    layer_output = []
+    remainder = list(input_qubits)
+
+    for i in range(len(structure)):
+        if not structure[0] <= len(remainder):
+            break
+
+        layer_output.append(QuantumBool(name="balauca_anc*"))
+
+        for j in range(structure[0]):
+            layer_input.append(remainder.pop(0))
+
+        layer_structure.append(structure.pop(0))
+
+    balauca_layer(layer_input, layer_output, structure=layer_structure, invert=False)
+
+    hybrid_mcx(
+        layer_output + remainder,
+        target,
+        num_ancilla=num_ancilla - len(layer_output),
+        num_dirty_ancilla=num_dirty_ancilla,
+        phase=phase,
+    )
+
+    balauca_layer(layer_input, layer_output, structure=layer_structure, invert=True)
+
+    [qbl.delete() for qbl in layer_output]
+
+    if ctrl_state is not None:
+        for i in range(len(input_qubits)):
+            del input_qubits[i].ctrl_state
+
+    return
+
+
+def balauca_layer(input_qubits, output_qubits, structure, invert=False):
+    if not output_qubits:
+        return
+
+    qs = output_qubits[0].qs()
+    input_qubits = list(input_qubits)
+
+    counter = 0
+    for i in range(len(output_qubits)):
+        if structure[i] == 3:
+            ctrl_qubits = [
+                input_qubits[counter],
+                input_qubits[counter + 1],
+                input_qubits[counter + 2],
+            ]
+            counter += 3
+
+            ctrl_state = ""
+            for qb in ctrl_qubits:
+                if hasattr(qb, "ctrl_state"):
+                    ctrl_state += qb.ctrl_state
+                else:
+                    ctrl_state += "1"
+
+            gate = XGate().control(3, method="gray_pt", ctrl_state=ctrl_state)
+
+            if invert:
+                gate = gate.inverse()
+
+            qs.append(gate, ctrl_qubits + [output_qubits[i]])
+        else:
+            ctrl_qubits = [input_qubits[counter], input_qubits[counter + 1]]
+            counter += 2
+
+            ctrl_state = ""
+            for qb in ctrl_qubits:
+                if hasattr(qb, "ctrl_state"):
+                    ctrl_state += qb.ctrl_state
+                else:
+                    ctrl_state += "1"
+
+            gate = XGate().control(2, method="gray_pt", ctrl_state=ctrl_state)
+
+            if invert:
+                gate = gate.inverse()
+
+            qs.append(gate, ctrl_qubits + [output_qubits[i]])
+
+    return
+
+
+def structure_decider(n, k):
+    # Each element of a Balauca layer reduces the amount of
+    # Control qubits for the next layer either by 1 (margolous gate)
+    # or by 2 (phase toleratn maslov gate). Ideally, we reduce the amount
+    # of control qubits to 3, so we can cancel the recursion
+    # and deploy a Toffoli.
+
+    # If we have n controls, p = n - 2 is the amount of reductions,
+    # that need to be performed.
+
+    # If we have k ancillae at our disposal, we need to satisfy:
+
+    # p = 2*triple_mcx + (k-triple_mcx_count) = k + triple_mcx_count
+
+    # <=> triple_mcx_count = n - 2 - k
+
+    triple_mcx_count = n - 2 - k
+
+    if triple_mcx_count <= 0:
+        if n % 2:
+            return (n - 3) // 2 * [2] + [3]
+        else:
+            return n // 2 * [2]
+    elif triple_mcx_count > k:
+        return k * [3]
+    else:
+        return triple_mcx_count * [3] + (k - triple_mcx_count) * [2]
+
+
+def vchain_2_dirty(control, target, dirty_ancillae=None):
+    control = convert_to_qb_list(control)
+    target = convert_to_qb_list(target)
+
+    if len(control) == 1:
+        cx(control, target)
+        return
+    elif len(control) == 2:
+        mcx(control, target, method="gray")
+
+    n = len(control)
+    k = n - 2
+
+    dirty_ancilla_qbls = []
+    if dirty_ancillae is None:
+        dirty_ancilla_qbls = [QuantumBool(name="vchain_2_dirty*") for i in range(k)]
+        dirty_ancillae = [qbl[0] for qbl in dirty_ancilla_qbls]
+
+    def reduced_margolus(control, target):
+        qs = target.qs()
+
+        control = list(control)
+        qs.append(reduced_margolus_qc.to_gate("reduced_margolus"), control + [target])
+        # qs.append(XGate().control(2), control + [target])
+
+    def margolus(control, target):
+        qs = target.qs()
+
+        control = list(control)
+        qs.append(margolus_qc.to_gate("margolus"), control + [target])
+        # qs.append(XGate().control(2), control + [target])
+
+    control_temp_list = list(control)
+    dirty_ancillae_temp_list = list(dirty_ancillae)
+    qubit_list = []
+
+    qubit_list.append(control_temp_list.pop(0))
+    qubit_list.append(control_temp_list.pop(0))
+
+    while control_temp_list:
+        qubit_list.append(dirty_ancillae_temp_list.pop(0))
+        qubit_list.append(control_temp_list.pop(0))
+
+    qubit_list.append(target[0])
+
+    m = len(qubit_list)
+
+    for i in range(k):
+        if i == k - 1:
+            margolus(
+                [qubit_list[m - 5 - 2 * i], qubit_list[m - 4 - 2 * i]],
+                qubit_list[m - 3 - 2 * i],
+            )
+        else:
+            reduced_margolus(
+                [qubit_list[m - 5 - 2 * i], qubit_list[m - 4 - 2 * i]],
+                qubit_list[m - 3 - 2 * i],
+            )
+
+    for i in range(k):
+        if i == k - 1:
+            reduced_margolus(
+                [qubit_list[2 * i + 2], qubit_list[2 * i + 3]], qubit_list[2 * i + 4]
+            )
+        else:
+            with invert():
+                reduced_margolus(
+                    [qubit_list[2 * i + 2], qubit_list[2 * i + 3]],
+                    qubit_list[2 * i + 4],
+                )
+
+    for i in range(k):
+        if i == k - 1:
+            with invert():
+                margolus(
+                    [qubit_list[m - 5 - 2 * i], qubit_list[m - 4 - 2 * i]],
+                    qubit_list[m - 3 - 2 * i],
+                )
+        else:
+            reduced_margolus(
+                [qubit_list[m - 5 - 2 * i], qubit_list[m - 4 - 2 * i]],
+                qubit_list[m - 3 - 2 * i],
+            )
+
+    for i in range(k):
+        if i == k - 1:
+            with invert():
+                reduced_margolus(
+                    [qubit_list[2 * i + 2], qubit_list[2 * i + 3]],
+                    qubit_list[2 * i + 4],
+                )
+        else:
+            with invert():
+                reduced_margolus(
+                    [qubit_list[2 * i + 2], qubit_list[2 * i + 3]],
+                    qubit_list[2 * i + 4],
+                )
+
+    [qbl.delete() for qbl in dirty_ancilla_qbls]
+
+
+def balauca_dirty(control, target, k, dirty_ancillae=None, ctrl_state=None):
+    control = convert_to_qb_list(control)
+    target = convert_to_qb_list(target)
+    qs = target[0].qs()
+
+    n = len(control)
+
+    k = min((n - 2) // 2 + 1, k)
+
+    if k == 0:
+        qs.append(
+            XGate().control(n, ctrl_state=ctrl_state, method="gray"),
+            list(control) + [target],
+        )
+        return
+
+    if ctrl_state is not None:
+        for i in range(len(ctrl_state)):
+            if ctrl_state[i] == "0":
+                x(control[i])
+
+    def reduced_maslov(control, target):
+        qs = target.qs()
+
+        qs.append(reduced_maslov_qc.to_gate("reduced_maslov"), control + [target])
+        # qs.append(XGate().control(2), control + [target])
+
+    m_1 = int(np.ceil((n - 2 * (k - 1)) / 2))
+    m_2 = int(np.floor((n - 2 * (k - 1)) / 2))
+
+    dirty_ancilla_qbls = []
+    if dirty_ancillae is None:
+        dirty_ancilla_qbls = [
+            QuantumBool(name="balauca_dirty*", qs=qs) for i in range(k)
+        ]
+        dirty_ancillae = [qbl[0] for qbl in dirty_ancilla_qbls]
+
+    upper_block_qubits = control[:m_1] + [dirty_ancillae[0]]
+    lower_block_qubits = control[-m_2:] + [dirty_ancillae[-1]]
+
+    def balauca_dirty_helper(control, target, ancillae):
+        if len(ancillae) == 0:
+            vchain_2_dirty(control, target, dirty_ancillae=lower_block_qubits)
+            # mcx(control, target)
+            return
+
+        reduced_maslov([ancillae[-1]] + control[-2:], target)
+
+        balauca_dirty_helper(control[:-2], ancillae[-1], ancillae[:-1])
+
+        with invert():
+            reduced_maslov([ancillae[-1]] + control[-2:], target)
+
+    vchain_2_dirty(lower_block_qubits, target, dirty_ancillae=upper_block_qubits)
+
+    balauca_dirty_helper(control[:-m_2], dirty_ancillae[-1], dirty_ancillae[:-1])
+
+    vchain_2_dirty(lower_block_qubits, target, dirty_ancillae=upper_block_qubits)
+
+    balauca_dirty_helper(control[:-m_2], dirty_ancillae[-1], dirty_ancillae[:-1])
+
+    [qbl.delete() for qbl in dirty_ancilla_qbls]
+
+    if ctrl_state is not None:
+        for i in range(len(ctrl_state)):
+            if ctrl_state[i] == "0":
+                x(control[i])
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/operation.py` & `qrisp-0.0.16/src/qrisp/circuit/operation.py`

 * *Files 1% similar despite different names*

```diff
@@ -31,28 +31,31 @@
 # Class that describes an operation which can be performed on a quantum computer
 # Example would be an X gate or a measurement
 class Operation:
     """
     This class describes operations like quantum gates, measurements or classical logic
     gates. Operation objects do not carry information about which Qubit/Clbits they are
     applied to. This can be found in the Instruction class, which is a combination of an
-    Operation object together with it's operands.
+    Operation object together with its operands.
 
     Operation objects consist of five basic attributes:
 
     * ``.name`` : A string identifying the operation
     * ``.num_qubits`` : An integer specifying the amount qubits on which to operate
-    * ``.num_clbits`` : An integer specifying the amount of classical bits on which to operate.
+    * ``.num_clbits`` : An integer specifying the amount of classical bits on which to
+      operate.
     * ``.params`` : A list of floats specifying the parameters of the Operation
-    * ``.definition`` : A :ref:`QuantumCircuit`. For synthesized (ie. non-elementary) operations, this QuantumCircuit specifies the operation.
+    * ``.definition`` : A :ref:`QuantumCircuit`. For synthesized (i.e. non-elementary)
+      operations, this QuantumCircuit specifies the operation.
 
     Operation objects together with their Operands can be appended to QuantumCircuits by
     using the :meth:`append <qrisp.QuantumCircuit.append>` method.
 
-    QuantumCircuits can be turned into Operations by using the :meth:`to_gate <qrisp.QuantumCircuit.to_gate>` method.
+    QuantumCircuits can be turned into Operations by using the
+    :meth:`to_gate <qrisp.QuantumCircuit.to_gate>` method.
 
     Examples
     --------
 
     We create a QuantumCircuit and append a couple of operations
 
     >>> from qrisp import QuantumCircuit, XGate, CXGate, PGate
@@ -130,15 +133,15 @@
                 definition.abstract_params
             )
 
         else:
             self.definition = None
 
         # If a unitary (numpy array) is given, save the unitary
-        if not unitary is None:
+        if unitary is not None:
             self.unitary = unitary
 
         # These attributes store some information for the uncomputation algorithm
         # Qfree basically means that the unitary is a permutation matrix
         # (up to local phase shifts). Permeability means that this gate commutes with
         # the z operator on a given qubit
         self.is_qfree = None
@@ -289,19 +292,19 @@
         ----------
         num_ctrl_qubits : int, optional
             The amount of control qubits. The default is 1.
         ctrl_state : int or str, optional
             The state on which to activate the basis gate. The default is "1111...".
         method : str, optional
             The method for synthesizing the required multi-controlled X gates.
-            Available are ``gray`` and ``gray_pt`` and ``auto``. 
-            Note that "gray_pt" introduces an extra phase (which needs to be uncomputed) 
-            but is more resource efficient. ``auto`` will be transformed into a more efficient
-            ancilla supported version at compile time if used in a QuantumSession.
-            The default is ``gray``.
+            Available are ``gray`` and ``gray_pt`` and ``auto``.
+            Note that "gray_pt" introduces an extra phase (which needs to be uncomputed)
+            but is more resource efficient. ``auto`` will be transformed into a more
+            efficient ancilla supported version at compile time if used in a
+            QuantumSession. The default is ``gray``.
 
         Raises
         ------
         AttributeError
             Tried to control non-unitary operation.
 
         Returns
@@ -517,28 +520,29 @@
 id_matrix = np.eye(2, dtype=np.complex64)
 
 pauli_x = np.asarray([[0, 1], [1, 0]], dtype=np.complex64)
 pauli_y = np.asarray([[0, 0], [0, 0]]) + 1j * np.asarray([[0, -1], [1, 0]])
 pauli_z = np.asarray([[1, 0], [0, -1]], dtype=np.complex64)
 
 pi = float(np.pi)
+
+
 # This class is special for pauli gates. In principle, we could also use the U3Gate
 # class, but this could lead to unneccessary floating point errors
 class PauliGate(U3Gate):
     def __init__(self, name):
-
         if name == "x":
             super().__init__(pi, 0, pi)
             self.unitary = pauli_x
 
             self.is_qfree = True
             self.permeability[0] = False
 
         elif name == "y":
-            super().__init__(pi, pi/2, pi/2)
+            super().__init__(pi, pi / 2, pi / 2)
             self.unitary = pauli_y
 
             self.is_qfree = True
             self.permeability[0] = False
 
         elif name == "z":
             super().__init__(0, 0, pi)
@@ -606,15 +610,15 @@
                 num_ctrl_qubits=num_ctrl_qubits + len(base_operation.controls),
                 ctrl_state=self.ctrl_state + base_operation.ctrl_state,
                 method=method,
             )
             return
 
         if base_operation.name == "gphase":
-            from qrisp import QuantumCircuit, PGate, bin_rep
+            from qrisp import PGate, QuantumCircuit, bin_rep
 
             definition_circ = QuantumCircuit(num_ctrl_qubits + 1)
 
             if num_ctrl_qubits > 1:
                 temp_gate = PGate(base_operation.params[0]).control(
                     num_ctrl_qubits - 1, ctrl_state=self.ctrl_state[1:], method=method
                 )
@@ -758,15 +762,15 @@
     def bind_parameters(self, subs_dic):
         from copy import copy
 
         res = copy(self)
         if not isinstance(self.definition, type(None)):
             res.definition = self.definition.bind_parameters(subs_dic)
         res.base_operation = self.base_operation.bind_parameters(subs_dic)
-        
+
         res.params = []
         for p in self.params:
             if p in subs_dic:
                 res.params.append(subs_dic[p])
             else:
                 res.params.append(p)
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/quantum_circuit.py` & `qrisp-0.0.16/src/qrisp/circuit/quantum_circuit.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,41 +7,42 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.circuit import Operation, Clbit, Qubit, Instruction
-
 import numpy as np
 import sympy
-import qrisp.circuit.standard_operations as ops
 
+import qrisp.circuit.standard_operations as ops
+from qrisp.circuit import Clbit, Instruction, Operation, Qubit
 
 # Class to describe quantum circuits
 # The naming of the attributes is rather similar to the qiskit equivalent
 # in order to allow compatibility of qiskit programs to qrisp
 # The key attributes are
 
 # The list of qubits (.qubits).
 # the list of classical bits (.clbits)
 # the list of instructions (.data)
 
 
 class QuantumCircuit:
     """
     This class describes quantum circuits. Many of the attribute and method names are
-    oriented at the `Qiskit QuantumCircuit <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html>`_ class in order to provide a high degree of
-    compatibility.
+    oriented at the `Qiskit QuantumCircuit
+    <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.html>`_ class
+    in order to provide a high degree of compatibility.
 
     QuantumCircuits can be visualized by calling ``print`` on them.
 
     Qrisp QuantumCircuits can be quickly generated out of existing Qiskit
-    QuantumCircuits with the :meth:`from_qiskit <qrisp.QuantumCircuit.from_qiskit>` method.
+    QuantumCircuits with the :meth:`from_qiskit <qrisp.QuantumCircuit.from_qiskit>`
+    method.
 
 
     Parameters
     ----------
 
     num_qubits : integer, optional
         The amount of qubits, this QuantumCircuit is initialized with. The default is 0.
@@ -65,16 +66,17 @@
     qb_1: ┤ X ├──┼────┼──
           └───┘┌─┴─┐  │
     qb_2: ─────┤ X ├──┼──
                └───┘┌─┴─┐
     qb_3: ──────────┤ X ├
                     └───┘
 
-    Note that the :meth:`cx gate appending method <qrisp.QuantumCircuit.cx>` (like all other gate appending methods) can
-    be called with integers, Qubit objects, lists of integers or lists of Qubit objects.
+    Note that the :meth:`cx gate appending method <qrisp.QuantumCircuit.cx>` (like all
+    other gate appending methods) can be called with integers, Qubit objects,
+    lists of integers or lists of Qubit objects.
 
     We now turn this QuantumCircuit into a gate and append to another QuantumCircuit to
     generate a GHZ state:
 
     >>> qc_1 = QuantumCircuit(4)
     >>> qc_1.h(0)
     >>> qc_1.append(qc_0.to_gate(), qc_1.qubits)
@@ -125,31 +127,34 @@
     q_1: ┤ X ├──┼────┼──
          └───┘┌─┴─┐  │
     q_2: ─────┤ X ├──┼──
               └───┘┌─┴─┐
     q_3: ──────────┤ X ├
                    └───┘
 
-    To acquire the Qrisp QuantumCircuit we call the :meth:`from_qiskit <qrisp.QuantumCircuit.from_qiskit>` method. Note that
-    we don't need to create a QuantumCircuit object first as this is a class method.
+    To acquire the Qrisp QuantumCircuit we call the
+    :meth:`from_qiskit <qrisp.QuantumCircuit.from_qiskit>` method. Note that we don't
+    need to create a QuantumCircuit object first as this is a class method.
 
     >>> qrisp_qc_2 = QuantumCircuit.from_qiskit(qc_2)
     >>> print(qrisp_qc_2)
      qb_8: ──■────■────■──
            ┌─┴─┐  │    │
      qb_9: ┤ X ├──┼────┼──
            └───┘┌─┴─┐  │
     qb_10: ─────┤ X ├──┼──
                 └───┘┌─┴─┐
     qb_11: ──────────┤ X ├
                      └───┘
 
     **Abstract Parameters**
 
-    Abstract parameters are represented by `Sympy symbols <https://docs.sympy.org/latest/modules/core.html#module-sympy.core.symbol>`_ in Qrisp.
+    Abstract parameters are represented by `Sympy symbols
+    <https://docs.sympy.org/latest/modules/core.html#module-sympy.core.symbol>`_
+    in Qrisp.
 
     We create a QuantumCircuit with some abstract parameters and bind them subsequently.
 
     >>> from qrisp import QuantumCircuit
     >>> from sympy import symbols
     >>> qc = QuantumCircuit(3)
 
@@ -172,15 +177,15 @@
           └──────┘
 
     """
 
     qubit_index_counter = np.zeros(1, dtype=int)
     fast_append = False
 
-    def __init__(self, num_qubits = 0, num_clbits = 0, name=None):
+    def __init__(self, num_qubits=0, num_clbits=0, name=None):
         object.__setattr__(self, "data", [])
         object.__setattr__(self, "qubits", [])
         object.__setattr__(self, "clbits", [])
 
         self.abstract_params = set([])
 
         if name is None:
@@ -190,23 +195,25 @@
 
         if isinstance(num_qubits, int):
             for i in range(num_qubits):
                 self.qubit_index_counter[0] += 1
                 self.qubits.append(Qubit("qb_" + str(self.qubit_index_counter[0])))
         else:
             raise Exception(
-                f"Tried to initialize QuantumCircuit with type {type(num_qubits)}")
+                f"Tried to initialize QuantumCircuit with type {type(num_qubits)}"
+            )
 
         if isinstance(num_clbits, int):
             for i in range(num_clbits):
                 self.add_clbit()
         else:
             raise Exception(
-                f"Tried to initialize QuantumCircuit with type {type(num_clbits)}")
-            
+                f"Tried to initialize QuantumCircuit with type {type(num_clbits)}"
+            )
+
         self.last_qubit_count = -1
 
     # Method to add qubit objects to the circuit
     def add_qubit(self, qubit=None):
         """
         Adds a Qubit to the QuantumCircuit.
 
@@ -230,15 +237,14 @@
         [qb_0]
 
         """
 
         self.qubit_index_counter += 1
         if qubit is None:
             qubit = Qubit("qb_" + str(self.qubit_index_counter[0]))
-            
 
         if not isinstance(qubit, Qubit):
             raise Exception(f"Tried to add type {type(qubit)} as a qubit")
 
         for qb in self.qubits:
             if qb.identifier == qubit.identifier:
                 raise Exception(f"Qubit name {qubit.identifier} already exists")
@@ -281,20 +287,21 @@
     # Method to transform the given circuit into an operation object
     def to_op(self, name=None):
         """
         Method to return an Operation object generated out of this QuantumCircuit.
 
         Operation objects can be appended to other QuantumCircuits.
 
-        An alias for Qiskit compatibility is the :meth:`to_gate<qrisp.QuantumCircuit.to_gate>` method.
+        An alias for Qiskit compatibility is the
+        :meth:`to_gate<qrisp.QuantumCircuit.to_gate>` method.
 
         Parameters
         ----------
         name : string, optional
-            The name of the gate. By default the QuantumCircuit's name will be used.
+            The name of the gate. By default, the QuantumCircuit's name will be used.
 
         Returns
         -------
         Operation
             The Operation defined by this QuantumCircuit.
 
         Examples
@@ -328,17 +335,19 @@
             definition=definition,
             params=[],
         )
 
     # Wrapper to increase Qiskit compatibility
     def to_gate(self, name=None):
         """
-        Similar to :meth:`to_op <qrisp.QuantumCircuit.to_op>` but raises an exception 
-        if self contains classical bits (like the 
-        `Qiskit equivalent <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.to_gate.html#qiskit.circuit.QuantumCircuit.to_gate>`_).
+        Similar to :meth:`to_op <qrisp.QuantumCircuit.to_op>` but raises an exception
+        if self contains classical bits (like the
+        `Qiskit equivalent
+        <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.to_gate.html>`_).
+        # noqa
 
         Parameters
         ----------
         name : str, optional
             A name for the resulting gate. The default is None.
 
         Raises
@@ -448,35 +457,35 @@
         Returns
         -------
         QuantumCircuit
             The copied QuantumCircuit.
 
         """
         # If an inital circuit is given we construct a new instance
-        
+
         res = QuantumCircuit()
-        
+
         object.__setattr__(res, "data", list(self.data))
         object.__setattr__(res, "qubits", list(self.qubits))
         object.__setattr__(res, "clbits", list(self.clbits))
-        
+
         try:
             res.abstract_params = set(self.abstract_params)
         except AttributeError:
             pass
 
         return res
-        
-        
+
         return QuantumCircuit(init_qc=self)
 
     # Returns a copy of self but with no instructions
     def clearcopy(self):
         """
-        Returns a copy of the given QuantumCircuit but without any data (i.e. just the Qubits and Clbits).
+        Returns a copy of the given QuantumCircuit but without any data
+        (i.e. just the Qubits and Clbits).
 
         Returns
         -------
         QuantumCircuit
             The empty, copied QuantumCircuit.
 
         """
@@ -492,14 +501,15 @@
     def __str__(self):
         if self.abstract_params:
             raise Exception(
                 "Tried to print QuantumCircuit with unspecified abstract parameters"
             )
 
         from qiskit.visualization.circuit_visualization import circuit_drawer
+
         from qrisp.interface.circuit_converter import convert_circuit
 
         try:
             res_str = str(
                 circuit_drawer(
                     convert_circuit(self, target_api="qiskit", transpile=False),
                     style="text",
@@ -744,24 +754,23 @@
 
         res = calc_circuit_unitary(self)
 
         if decimals != -1:
             if res.dtype == np.dtype("O"):
                 raveled_res = res.ravel()
                 for i in range(len(raveled_res)):
-                    
                     expression = raveled_res[i]
                     for a in sympy.preorder_traversal(expression):
                         if isinstance(a, sympy.Float):
                             rounded_float = round(a, decimals)
                             if abs(rounded_float - 1) < 10**-decimals:
-                                expression = expression.subs(a, 1)    
+                                expression = expression.subs(a, 1)
                             else:
                                 expression = expression.subs(a, rounded_float)
-                    
+
                     raveled_res[i] = expression
             else:
                 res = np.round(res, decimals)
 
         return res
 
     def get_depth_dic(self):
@@ -783,15 +792,15 @@
         from qrisp.misc import cnot_count
 
         return cnot_count(self)
 
     def transpile(self, transpilation_level=np.inf, **qiskit_kwargs):
         """
         Transpiles the QuantumCircuit in the sense that there are no longer any
-        synthesized gate objects. Furthermore we can call the `Qiskit transpiler
+        synthesized gate objects. Furthermore, we can call the `Qiskit transpiler
         <https://qiskit.org/documentation/stubs/qiskit.compiler.transpile.html>`__
         by supplying keyword arguments.
 
         The Qiskit transpiler is not called, if no keyword arguments are given.
 
         Parameters
         ----------
@@ -824,17 +833,17 @@
               ┌──────────┐                 ┌───┐┌─────────┐   ┌───┐   ┌──────────┐┌───┐»
         qb_1: ┤ Rz(-π/4) ├─────────────────┤ X ├┤ Rz(π/4) ├───┤ X ├───┤ Rz(-π/4) ├┤ X ├»
               ├──────────┤                 └─┬─┘└─────────┘   └─┬─┘   └──────────┘└─┬─┘»
         qb_2: ┤ Rz(-π/4) ├───────────────────┼───────■──────────■──────────■────────┼──»
               ├─────────┬┘┌────┐┌─────────┐  │     ┌─┴─┐   ┌─────────┐   ┌─┴─┐      │  »
         qb_3: ┤ Rz(π/2) ├─┤ √X ├┤ Rz(π/2) ├──■─────┤ X ├───┤ Rz(π/4) ├───┤ X ├──────■──»
               └─────────┘ └────┘└─────────┘        └───┘   └─────────┘   └───┘         »
-        «      ┌─────────┐┌───┐            
+        «      ┌─────────┐┌───┐
         «qb_1: ┤ Rz(π/4) ├┤ X ├────────────
-        «      └─────────┘└─┬─┘            
+        «      └─────────┘└─┬─┘
         «qb_2: ─────────────■──────────────
         «      ┌─────────┐┌────┐┌─────────┐
         «qb_3: ┤ Rz(π/4) ├┤ √X ├┤ Rz(π/2) ├
         «      └─────────┘└────┘└─────────┘
 
         """
         from qrisp.circuit import transpile
@@ -891,16 +900,16 @@
         else:
             res = self.copy()
             res.append(other.to_gate(), qubits, clbits)
             return res
 
     def bind_parameters(self, subs_dic):
         """
-        Returns a QuantumCircuit where the abstract parameters in ``subs_dic`` are bound to
-        their specified values.
+        Returns a QuantumCircuit where the abstract parameters in ``subs_dic`` are bound
+        to their specified values.
 
         Parameters
         ----------
         subs_dic : dict
             A dictionary containing the abstract parameters of this QuantumCircuit as
             keys and the desired parameters as values.
 
@@ -964,15 +973,17 @@
     def to_latex(self, **kwargs):
         """
         Deploys the Qiskit circuit drawer to generate LaTeX output.
 
         Parameters
         ----------
         **kwargs : dict
-            Dictionary of keyword args for Qiskits `circuit_drawer <https://qiskit.org/documentation/stable/0.19/stubs/qiskit.visualization.circuit_drawer.html>`_ function.
+            Dictionary of keyword args for Qiskits `circuit_drawer
+            <https://qiskit.org/documentation/stable/0.19/stubs/qiskit.visualization.circuit_drawer.html>`_
+            function.
 
         Returns
         -------
         string
             A string containing the latex code.
 
         """
@@ -1008,15 +1019,15 @@
         """
         return self.to_qiskit().qasm(formatted, filename, encoding)
 
     def depth(self, transpile=True):
         """
         Returns the depth of the QuantumCircuit. Note that the depth on QuantumCircuit
         which are not transpiled, might have very little correlation with the runtime.
-        
+
         Parameters
         ----------
         transpile : bool, optional
             Boolean to indicate wether the QuantumCircuit should be transpiled before
             the depth is calculated. The default is True.
 
         Returns
@@ -1139,15 +1150,14 @@
         # unless the input is a single qubit/integer.
         # In this case we have
         # qubit_0 ==> [qubit_0]
 
         qubits = convert_to_qb_list(qubits, circuit=self)
         clbits = convert_to_cb_list(clbits, circuit=self)
 
-
         # Now we check which of the arguments is a list
         # For user convenience we allow to execute multiple gates at the same time
         # This comes with some restrictions where the operation to execute could be
         # ambigous.
         # When appending n gates with a single call of this function,
         # each qubit argument must either be a list of n qubits or a single qubit
 
@@ -1197,101 +1207,97 @@
 
                 clbit_constellation = []
                 for j in range(len(clbits)):
                     if j in cb_argument_is_list:
                         clbit_constellation.append(clbits[j][i])
                     else:
                         clbit_constellation.append(clbits[j])
-                
+
                 # Append instruction (qubit_constellation and clbit_constellation) now
                 # contains no lists but only qubit/clbit arguments
                 self.append(operation, qubit_constellation, clbit_constellation)
 
             return
 
-
         if len(qubits) != operation.num_qubits:
             raise Exception(
                 f"Provided incorrect amount ({len(qubits)}) of qubits for operation "
                 + str(operation.name)
             )
 
         if len(clbits) != operation.num_clbits:
             raise Exception(
                 f"Provided incorrect amount ({len(clbits)}) of clbits for operation "
                 + str(operation.name)
             )
 
-        
         if len(set(qubits)) != len(qubits):
             raise Exception(
                 f"Duplicate qubit arguments in {qubits} for operation {operation.name}"
             )
 
-
-        #Building up the list of identifiers seems to slow down this function
-        #We therefore check first if the qubit objects match and if this is not the
-        #case we check if the identifiers match
-        if not set(qubits).issubset(
-            set(self.qubits)
-        ):
-            
+        # Building up the list of identifiers seems to slow down this function
+        # We therefore check first if the qubit objects match and if this is not the
+        # case we check if the identifiers match
+        if not set(qubits).issubset(set(self.qubits)):
             op_identifiers = [qb.identifier for qb in qubits]
             qc_identifiers = [qb.identifier for qb in self.qubits]
-            
+
             if not set(op_identifiers).issubset(qc_identifiers):
                 raise Exception(
                     "Instruction Qubits "
                     + str(set(qubits) - set(self.qubits))
                     + " not present in circuit"
                 )
             else:
-                qubits = [self.qubits[qc_identifiers.index(op_id)] for op_id in op_identifiers]
-            
+                qubits = [
+                    self.qubits[qc_identifiers.index(op_id)] for op_id in op_identifiers
+                ]
+
         if len(set([cb.identifier for cb in clbits])) != len(clbits):
             raise Exception("Duplicate clbit arguments")
 
         if not set([cb.identifier for cb in clbits]).issubset(
             set([cb.identifier for cb in self.clbits])
         ):
             raise Exception("Instruction Clbits not present in circuit")
 
-        
         # Log which abstract parameters have been added to the circuit
         try:
             self.abstract_params = self.abstract_params.union(operation.abstract_params)
         except AttributeError:
             pass
 
         critical_qubits = []
         perm_critical_qubits = []
-        
+
         for qb in qubits:
             if qb.lock:
                 critical_qubits.append(qb)
             if qb.perm_lock:
                 perm_critical_qubits.append(qb)
 
         critical_qubits = [qb for qb in qubits if qb.lock]
         if critical_qubits:
             if critical_qubits[0].lock_message:
                 raise Exception(critical_qubits[0].lock_message)
             else:
-                raise Exception(f"Tried to perform operation {operation.name}"
-                                "on locked qubit {critical_qubits[0]}")
+                raise Exception(
+                    f"Tried to perform operation {operation.name}"
+                    "on locked qubit {critical_qubits[0]}"
+                )
 
         # Check if there are non-permeable operations on pt_locked qubits
         critical_qubits = [qb for qb in qubits if qb.perm_lock]
-        
+
         if critical_qubits:
             from qrisp.uncomputation import is_permeable
 
             critical_qubit_indices = [qubits.index(qb) for qb in critical_qubits]
             if not is_permeable(operation, critical_qubit_indices):
-                
                 if critical_qubits[0].perm_lock_message:
                     raise Exception(critical_qubits[0].perm_lock_message)
                 else:
                     raise Exception(
                         f"Tried to perform non-permeable operation {operation.name} on"
                         f" perm_locked qubit {critical_qubits[0]}"
                     )
@@ -1330,106 +1336,111 @@
         """
         if backend is None:
             from qrisp.default_backend import def_backend
 
             backend = def_backend
 
         return backend.run(self, shots)
-    
+
     def statevector_array(self):
         """
-        Performs a simulation of the statevector of self and returns a numpy array of complex numbers.
+        Performs a simulation of the statevector of self and returns a numpy array of
+        complex numbers.
 
         .. note::
-            
-            Qrisps qubit ordering convention is reversed when compared to Qiskit, because of simulation efficiency reasons.
+
+            Qrisps qubit ordering convention is reversed when compared to Qiskit,
+            because of simulation efficiency reasons.
             As a rule of thumb you can remember:
-                
-            The statevector array of the following circuit has the amplitude 1 at the index ``0010 = 2``
-            
+
+            The statevector array of the following circuit has the amplitude 1 at the
+            index ``0010 = 2``
+
             ::
-                
+
                 qb.0: ─────
-                           
+
                 qb.1: ─────
                       ┌───┐
                 qb.2: ┤ X ├
                       └───┘
                 qb.3: ─────
-                           
+
         Returns
         -------
         numpy.ndarray
             The statevector of this circuit.
-            
+
         Examples
         --------
-        
-        We create a QuantumCircuit, perform some operations and retrieve the statevector array
-        
+
+        We create a QuantumCircuit, perform some operations and retrieve the
+        statevector array.
+
         >>> from qrisp import QuantumCircuit
         >>> qc = QuantumCircuit(4)
         >>> qc.h(qc.qubits)
         >>> qc.z(-1)
         >>> qc.statevector_array()
         array([ 0.24999997+0.j, -0.24999997+0.j,  0.24999997+0.j, -0.24999997+0.j,
                 0.24999997+0.j, -0.24999997+0.j,  0.24999997+0.j, -0.24999997+0.j,
                 0.24999997+0.j, -0.24999997+0.j,  0.24999997+0.j, -0.24999997+0.j,
                 0.24999997+0.j, -0.24999997+0.j,  0.24999997+0.j, -0.24999997+0.j],
               dtype=complex64)
-        
+
 
         """
         from qrisp.simulator import statevector_sim
+
         return statevector_sim(self)
 
     def __hash__(self):
         from hashlib import sha256
+
         res = 0
-        
+
         def hash_(x):
             temp = str(x).encode("utf-8")
             hex_value = sha256(temp).hexdigest()
             return int(hex_value, 16)
 
         transpiled_qc = self
-        
+
         n = len(self.qubits)
         for i in range(len(transpiled_qc.data)):
-            
             instr = transpiled_qc.data[i]
-            
+
             qubit_indices = {}
-            
+
             for j in range(n):
                 try:
                     qubit_indices[instr.qubits.index(self.qubits[j])] = j
                 except ValueError:
                     pass
-            
+
             qubit_indices = [qubit_indices[j] for j in range(len(instr.qubits))]
-            
+
             index_hash = hash(tuple(qubit_indices))
-            
+
             params = []
             for j in range(len(instr.op.params)):
                 p = hash((instr.op.params[j], i))
                 params.append(p)
-                
+
             param_hash = hash(tuple(params))
-                
+
             if instr.op.definition:
                 op_hash = hash(instr.op.definition)
             else:
                 op_hash = hash(instr.op.name)
-            
-            res += hash((index_hash, param_hash, op_hash))*(i+1)**2
 
-        res *= len(self.qubits)**2
-        
+            res += hash((index_hash, param_hash, op_hash)) * (i + 1) ** 2
+
+        res *= len(self.qubits) ** 2
+
         return hash(res)
 
     @classmethod
     def from_qiskit(self, qiskit_qc):
         """
         Class method to create QuantumCircuits from Qiskit QuantumCircuits.
 
@@ -1882,15 +1893,15 @@
 
         if qubits is None:
             qubits = self.qubits
 
         self.append(ops.Barrier(len(qubits)), qubits)
 
     def reset(self, qubits):
-        """
+        r"""
         Instruct a reset. This resets this Qubit into the $\ket{0}$ state regardless
         of its previous state.
 
         Parameters
         ----------
         qubits : Qubit
             The Qubit to reset.
@@ -1992,75 +2003,75 @@
             The Qubit to apply the gate on.
         """
 
         self.append(ops.IDGate(), [qubits])
 
 
 class AppendingAccelerator:
-    
     def __enter__(self):
-        
         self.original_appending_mode = bool(QuantumCircuit.fast_append)
-        
+
         QuantumCircuit.fast_append = True
-    
+
     def __exit__(self, exception_type, exception_value, traceback):
-        
         from qrisp import QuantumCircuit
-        
+
         QuantumCircuit.fast_append = self.original_appending_mode
-        
-fast_append = AppendingAccelerator
 
 
+fast_append = AppendingAccelerator
+
 
-#Converts various inputs (eg. integers, qubits or quantum variables) to lists of qubit
-#used in the append method of QuantumCircuit and QuantumSession
-def convert_to_qb_list(input, circuit = None, top_level = True):
-    
+# Converts various inputs (eg. integers, qubits or quantum variables) to lists of qubit
+# used in the append method of QuantumCircuit and QuantumSession
+def convert_to_qb_list(input, circuit=None, top_level=True):
     if issubclass(input.__class__, Qubit):
         if top_level:
             result = [input]
         else:
             result = input
-    
+
     elif hasattr(input, "__iter__"):
         result = []
         for i in range(len(input)):
-            result.append(convert_to_qb_list(input[i], circuit, top_level = False))
-            
+            result.append(convert_to_qb_list(input[i], circuit, top_level=False))
+
     elif hasattr(input, "reg"):
         result = list(input.reg)
-        
+
     elif isinstance(input, int):
         if isinstance(circuit, type(None)):
-            raise Exception("Tried to convert integer argument to qubit without given circuit")
-        
-        result = convert_to_qb_list(circuit.qubits[input], top_level = top_level)
+            raise Exception(
+                "Tried to convert integer argument to qubit without given circuit"
+            )
+
+        result = convert_to_qb_list(circuit.qubits[input], top_level=top_level)
 
     else:
         raise Exception("Couldn't convert type " + str(type(input)) + " to qubit list")
-    
+
     return result
-    
-def convert_to_cb_list(input, circuit = None, top_level = True):
-    
+
+
+def convert_to_cb_list(input, circuit=None, top_level=True):
     from qrisp.circuit import Clbit
-    
+
     if hasattr(input, "__iter__"):
         result = []
         for i in range(len(input)):
-            result.append(convert_to_cb_list(input[i], circuit, top_level = False))
-            
+            result.append(convert_to_cb_list(input[i], circuit, top_level=False))
+
     elif isinstance(input, int):
         if isinstance(circuit, type(None)):
-            raise Exception("Tried to convert integer argument to qubit without given circuit")
-        
-        result = convert_to_cb_list(circuit.clbits[input], top_level = top_level)
-    
+            raise Exception(
+                "Tried to convert integer argument to qubit without given circuit"
+            )
+
+        result = convert_to_cb_list(circuit.clbits[input], top_level=top_level)
+
     elif issubclass(input.__class__, Clbit):
         if top_level:
             result = [input]
         else:
             result = input
-    
-    return result 
+
+    return result
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/qubit.py` & `qrisp-0.0.16/src/qrisp/circuit/qubit.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,49 +6,54 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
+
 class Qubit:
     """
     This class describes qubits. Qubits are created by supplying the identifier string.
-    
+
     Attributes
     ----------
     identifier : str
         A string to identify the Qubit.
-    
+
     Examples
     --------
-    
+
     We create a Qubit and add it to a :ref:`QuantumCircuit`:
-    
+
     >>> from qrisp import QuantumCircuit, Qubit
-    >>> qb = Qubit("alphonse")    
+    >>> qb = Qubit("alphonse")
     >>> qc = QuantumCircuit()
     >>> qc.add_qubit(qb)
     >>> qc.x(qb)
     >>> print(qc)
               ┌───┐
     alphonse: ┤ X ├
               └───┘
-    
+
 
     """
+
     def __init__(self, identifier):
         if identifier == "qb_[127]":
             raise
         self.identifier = identifier
         self.hash_value = id(self)
         self.lock = False
         self.perm_lock = False
-        
+
     def __str__(self):
         return self.identifier
+
     def __repr__(self):
         return "Qubit(" + self.identifier + ")"
+
     def __hash__(self):
         return self.hash_value
+
     def __eq__(self, other):
         return self.hash_value == other.hash_value
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/standard_operations.py` & `qrisp-0.0.16/src/qrisp/circuit/standard_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,25 +11,27 @@
 """
 
 
 # This file uses the gate constructor from operation.py to define
 # some standard operations
 
 import types
+
+import numpy as np
+
 from qrisp.circuit import PauliGate, U3Gate
 from qrisp.circuit.operation import Operation
-import numpy as np
 
 # TODO: properly treat all gates
 # from Aer.get_backend('qasm_simulator').configuration().basis_gates
 
 
 def Measurement():
     res = Operation(name="measure", num_qubits=1, num_clbits=1)
-    res.permeability = {0 : True}
+    res.permeability = {0: True}
     return res
 
 
 def XGate():
     return PauliGate(name="x")
 
 
@@ -164,16 +166,16 @@
     return Operation(
         name="rzz", num_qubits=2, num_clbits=0, params=[phi], definition=qc
     )
 
 
 def Barrier(num_qubits=1):
     res = Operation(num_qubits=num_qubits, name="barrier")
-    
-    res.permeability = {i : False for i in range(num_qubits)}
+
+    res.permeability = {i: False for i in range(num_qubits)}
     res.is_qfree = True
 
     return res
 
 
 def u3Gate(theta=0, phi=0, lam=0):
     return U3Gate(theta, phi, lam)
@@ -184,15 +186,15 @@
     res.name = "u1"
     res.params = [phi]
     return res
 
 
 def Reset():
     res = Operation("reset", 1)
-    res.permeability = {0 : False}
+    res.permeability = {0: False}
     return res
 
 
 def SXGate():
     res = RXGate(np.pi / 2)
     res.name = "sx"
     res.params = []
```

### Comparing `qrisp-0.0.15/src/qrisp/circuit/transpiler.py` & `qrisp-0.0.16/src/qrisp/circuit/transpiler.py`

 * *Files 20% similar despite different names*

```diff
@@ -6,139 +6,165 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
-
-
 import numpy as np
-from qrisp.circuit.operation import PTControlledOperation, ControlledOperation
+
 from qrisp.circuit.instruction import Instruction
-from qrisp.circuit.operation import Operation
+from qrisp.circuit.operation import (
+    Operation,
+)
 from qrisp.circuit.quantum_circuit import fast_append
 
-#This function dissolves any Operation objects that have a definition circuit such that the result only consists of elementary gates
-def transpile(qc, transpilation_level = np.inf, transpile_predicate = None, **kwargs):
-    
-    from qrisp.circuit import Operation, QuantumCircuit, Qubit, Clbit
+
+# This function dissolves any Operation objects that have a definition circuit such
+# that the result only consists of elementary gates
+def transpile(qc, transpilation_level=np.inf, transpile_predicate=None, **kwargs):
+    from qrisp.circuit import QuantumCircuit, Clbit, Qubit
 
     with fast_append():
-        from qrisp.circuit import Qubit, Clbit
+
         transpiled_qc = QuantumCircuit()
-        
+
         # [transpiled_qc.add_qubit(Qubit(qb.identifier)) for qb in qc.qubits]
         # [transpiled_qc.add_clbit(Clbit(cb.identifier)) for cb in qc.clbits]
-        
+
         for qb in qc.qubits:
             if isinstance(qb, Qubit):
                 transpiled_qc.add_qubit(qb)
             else:
                 transpiled_qc.add_qubit(Qubit(qb.identifier))
-                
+
         for cb in qc.clbits:
             if isinstance(qb, Qubit):
                 transpiled_qc.add_clbit(cb)
             else:
                 transpiled_qc.add_clbit(Clbit(cb.identifier))
-    
-        translation_dic = {qc.qubits[i].identifier : transpiled_qc.qubits[i] for i in range(len(qc.qubits))}
-        translation_dic.update({qc.clbits[i].identifier : transpiled_qc.clbits[i] for i in range(len(qc.clbits))})
-        
+
+        translation_dic = {
+            qc.qubits[i].identifier: transpiled_qc.qubits[i]
+            for i in range(len(qc.qubits))
+        }
+        translation_dic.update(
+            {
+                qc.clbits[i].identifier: transpiled_qc.clbits[i]
+                for i in range(len(qc.clbits))
+            }
+        )
+
         if transpile_predicate is None:
-            transpile_predicate_ = lambda i, op : i < transpilation_level
+            transpile_predicate_ = lambda i, op: i < transpilation_level
         else:
-            transpile_predicate_ = lambda i, op : i < transpilation_level and transpile_predicate(op)
-        
+            transpile_predicate_ = (
+                lambda i, op: i < transpilation_level and transpile_predicate(op)
+            )
+
         transpile_inner(qc, transpiled_qc, translation_dic, transpile_predicate_)
-        
+
         QuantumCircuit.fast_append = False
-        
+
         if not kwargs or not hasattr(qc, "to_qiskit"):
             return transpiled_qc
         else:
             from qrisp import QuantumCircuit
+
             qiskit_qc = transpiled_qc.to_qiskit()
-            
+
             from qiskit import transpile as qiskit_transpile
-            
+
             transpiled_qiskit_qc = qiskit_transpile(qiskit_qc, **kwargs)
-            
+
             qrisp_qc = QuantumCircuit.from_qiskit(transpiled_qiskit_qc)
-            
+
             return qrisp_qc
 
 
-def transpile_inner(transpilation_qc, target_qc, translation_dic, transpile_predicate, transpilation_level = 0):
-    
+def transpile_inner(
+        transpilation_qc,
+        target_qc,
+        translation_dic,
+        transpile_predicate,
+        transpilation_level=0,
+):
     for i in range(len(transpilation_qc.data)):
         instr = transpilation_qc.data[i]
         if instr.op.definition:
-            
             if transpile_predicate(transpilation_level, instr.op):
-                
                 definition = instr.op.definition
-                
-                new_translation_dic = {definition.qubits[j].identifier : translation_dic[instr.qubits[j].identifier] for j in range(len(instr.qubits))}
-                
-                new_translation_dic.update({definition.clbits[j].identifier : translation_dic[instr.clbits[j].identifier] for j in range(len(instr.clbits))})
-                
-                transpile_inner(instr.op.definition, 
-                                target_qc, 
-                                new_translation_dic, 
-                                transpile_predicate, 
-                                transpilation_level + 1)
+
+                new_translation_dic = {
+                    definition.qubits[j].identifier: translation_dic[
+                        instr.qubits[j].identifier
+                    ]
+                    for j in range(len(instr.qubits))
+                }
+
+                new_translation_dic.update(
+                    {
+                        definition.clbits[j].identifier: translation_dic[
+                            instr.clbits[j].identifier
+                        ]
+                        for j in range(len(instr.clbits))
+                    }
+                )
+
+                transpile_inner(
+                    instr.op.definition,
+                    target_qc,
+                    new_translation_dic,
+                    transpile_predicate,
+                    transpilation_level + 1,
+                )
                 continue
-        
+
         if not isinstance(instr.op, Operation):
-            op = Operation(init_op = instr.op)
+            op = Operation(init_op=instr.op)
         else:
             op = instr.op
-        
-        target_qc.data.append(Instruction(op, [translation_dic[qb.identifier] for qb in instr.qubits], [translation_dic[cb.identifier] for cb in instr.clbits]))
+
+        target_qc.data.append(
+            Instruction(
+                op,
+                [translation_dic[qb.identifier] for qb in instr.qubits],
+                [translation_dic[cb.identifier] for cb in instr.clbits],
+            )
+        )
         # target_qc.append()
-        
-    
 
 
-def extend(qc_0, qc_1, translation_dic = "id"):
-    
+def extend(qc_0, qc_1, translation_dic="id"):
     if translation_dic == "id":
-        
         translation_dic = {}
         for qb in qc_1.qubits:
             translation_dic[qb] = qb
-            if not qb in qc_0.qubits:
+            if qb not in qc_0.qubits:
                 qc_0.add_qubit(qb)
-            
+
         for cb in qc_1.clbits:
             translation_dic[qb] = qb
-            if not cb in qc_0.clbits:
+            if cb not in qc_0.clbits:
                 qc_0.add_clbit(cb)
-            
 
-    #Copy in order to prevent modification
+    # Copy in order to prevent modification
     translation_dic = dict(translation_dic)
 
     for key in list(translation_dic.keys()):
-        
         if not isinstance(key, str):
             translation_dic[key.identifier] = translation_dic[key]
 
-
     for i in range(len(qc_1.data)):
-        
         instruction_other = qc_1.data[i]
         qubits = []
         for qb in instruction_other.qubits:
             qubits.append(translation_dic[qb.identifier])
-        
+
         clbits = []
-        
+
         for cb in instruction_other.clbits:
             clbits.append(translation_dic[cb.identifier])
-        
+
         instr_type = type(instruction_other)
-        
+
         qc_0.data.append(instr_type(instruction_other.op, qubits, clbits))
-
```

### Comparing `qrisp-0.0.15/src/qrisp/core/__init__.py` & `qrisp-0.0.16/src/qrisp/core/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,22 +1,20 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 from qrisp.core.session_merging_tools import *
 from qrisp.core.compilation import *
 from qrisp.core.quantum_variable import QuantumVariable
 from qrisp.core.quantum_session import QuantumSession
 from qrisp.core.quantum_array import QuantumArray, OutcomeArray
 from qrisp.core.quantum_dictionary import QuantumDictionary
 from qrisp.core.library import *
-
-
```

### Comparing `qrisp-0.0.15/src/qrisp/core/compilation.py` & `qrisp-0.0.16/src/qrisp/core/compilation.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,847 +15,907 @@
 import networkx as nx
 from numba import njit, prange
 
 from qrisp.circuit import QuantumCircuit, Qubit, PTControlledOperation, ControlledOperation, transpile, QubitAlloc, Instruction, fast_append
 from qrisp.misc import get_depth_dic, retarget_instructions, reduce_depth
 
 
-
-#The purpose of this function is to dynamically (de)allocate qubits when they are need or not needed anymore.
-#The qompiler function knows when a qubit is ready to deallocate (ie. it is in |0> state) due to a gate called QubitDealloc.
-#After some preprocessing steps, this function will iterate through the data and dynamically (de)allocate if it is required.
-#Another feature of this function is that it replaces mcx gates where the method is set to "auto" with implementations that
-#fit the situation ie. it takes into consideration how many clean/dirty ancilla qubits are available and synthesizes an
-# mcx implementation based on this information.
-
-#The parameter workspace can be given to extend the amount of qubits of the resulting QuantumCircuit by that amount.
-#This extension can be helpfull because it gives the compiler more options to pick when allocating a new qubit.
-#Since the allocation is based on a depth-reduction heuristic, giving more workspace results in many case in less depth circuits.
-
-#It is however not only depth that can be improved by an increased workspace. Due to more clean/dirty ancillae beeing available,
-#in many cases it is also possible to generate more efficient mcx implementations, thus also reducing the gate count.
-def qompiler(qs, workspace = 0, disable_uncomputation = True, intended_measurements = [], cancel_qfts = True):
-    
+# The purpose of this function is to dynamically (de)allocate qubits when they are
+# needed or not needed anymore. The qompiler function knows when a qubit is ready to
+# deallocate (ie. it is in |0> state) due to a gate called QubitDealloc. After some
+# preprocessing steps, this function will iterate through the data and dynamically
+# (de)allocate if it is required. Another feature of this function is that it replaces
+# mcx gates where the method is set to "auto" with implementations that fit the
+# situation i.e. it takes into consideration how many clean/dirty ancilla qubits are
+# available and synthesizes and mcx implementation based on this information.
+
+# The parameter workspace can be given to extend the amount of qubits of the resulting
+# QuantumCircuit by that amount. This extension can be helpfull because it gives the
+# compiler more options to pick when allocating a new qubit. Since the allocation is
+# based on a depth-reduction heuristic, giving more workspace results in many case in
+# less depth circuits.
+
+
+# It is however not only depth that can be improved by an increased workspace. Due to
+# more clean/dirty ancillae beeing available, in many cases it is also possible to
+# generate more efficient mcx implementations, thus also reducing the gate count.
+def qompiler(
+    qs,
+    workspace=0,
+    disable_uncomputation=True,
+    intended_measurements=[],
+    cancel_qfts=True,
+):
     if len(qs.data) == 0:
         return QuantumCircuit(0)
-    
+
     with fast_append():
         qc = qs.copy()
-        
+
         if not disable_uncomputation:
             local_qvs = qs.get_local_qvs()
-            
+
             from qrisp.uncomputation.unqomp import uncompute_qc
-            
+
             for qv in local_qvs:
                 try:
                     qc = uncompute_qc(qc, qv.reg)
                 except:
                     print(f"Warning: Automatic uncomputation for {qv.name} failed")
-            
+
         if intended_measurements:
-            #This function reorders the circuit such that the intended measurements can be executed as early as possible
-            #additionally, any instructions that are not needed for the intended measurements are removed
+            # This function reorders the circuit such that the intended measurements can
+            # be executed as early as possible additionally, any instructions that are
+            # not needed for the intended measurements are removed
             try:
                 qc = measurement_reduction(qc, intended_measurements)
             except Exception as e:
                 if "Unitary of operation " not in str(e):
                     raise e
-    
+
         def reordering_transpile_predicate(op):
-            if (isinstance(op, PTControlledOperation) and op.base_operation.name in ["x"]) or isinstance(op, LogicSynthGate):
+            if (
+                isinstance(op, PTControlledOperation)
+                and op.base_operation.name in ["x"]
+            ) or isinstance(op, LogicSynthGate):
                 return False
             return True
-    
-        
+
         from qrisp.logic_synthesis import LogicSynthGate
-        
+
         if cancel_qfts:
-            # The first step is to cancel adjacent QFT gates, which are inverse to each other
-            # This can happen alot because of the heavy use of Fourier arithmetic
-            qft_transpile_predicate = lambda op : not "QFT" in op.name and reordering_transpile_predicate(op)
-            
-            qc = transpile(qc, transpile_predicate = qft_transpile_predicate)
-            
+            # The first step is to cancel adjacent QFT gates, which are inverse to each
+            # other. This can happen alot because of the heavy use of Fourier arithmetic
+            qft_transpile_predicate = (
+                lambda op: "QFT" not in op.name and reordering_transpile_predicate(op)
+            )
+
+            qc = transpile(qc, transpile_predicate=qft_transpile_predicate)
+
             qc = qft_cancellation(qc)
-        
-        #We now reorder the transpiled QuantumCircuit. Reordering is performed based on the DAG representation
-        #of Unqomp. The advantage of this representation is that it abstracts away non-trivial commutation relations
-        #between permeable gates. The actual ordering is performed by performing a topological sort on this dag.
-        #Contrary to unqomp, we don't use a modified version of Kahns algorithm here (for more information check 
-        #the topological sort function)
-    
-        #The reordering process aims to find an order that minimizes that maximum amount of qubits that is needed.
-        #Losely speaking it tries to reorder the data that allocations are performed as late as possible and deallocations
-        #are performed as early as possible.
-    
-        #Note that the more aggressive we transpile, the more optimization is possible through reordering ie. less qubits.
-        #By reordering we however also destroy any previous order which might have been intentionally picked to optimize depth.
-        #In summary: Transpiling more aggressively leads to less qubits but more depth.#
-        
-        #Only letting mcx and logic synthesis survive has shown to be a good compromise
-        
-        transpiled_qc = transpile(qc, transpile_predicate = reordering_transpile_predicate)
+
+        # We now reorder the transpiled QuantumCircuit. Reordering is performed based on
+        # the DAG representation of Unqomp. The advantage of this representation is that
+        # it abstracts away non-trivial commutation relations between permeable gates.
+        # The actual ordering is performed by performing a topological sort on this dag.
+        # Contrary to unqomp, we don't use a modified version of Kahns algorithm here
+        # (for more information check the topological sort function)
+
+        # The reordering process aims to find an order that minimizes that maximum
+        # amount of qubits that is needed. Losely speaking it tries to reorder the data,
+        # that allocations are performed as late as possible and deallocations are
+        # performed as early as possible.
+
+        # Note that the more aggressive we transpile, the more optimization is possible
+        # through reordering i.e. less qubits. By reordering we however also destroy any
+        # previous order which might have been intentionally picked to optimize depth.
+        # In summary: Transpiling more aggressively leads to less qubits but more depth.
+
+        # Only letting mcx and logic synthesis survive has shown to be a good compromise
+
+        transpiled_qc = transpile(
+            qc, transpile_predicate=reordering_transpile_predicate
+        )
         reordered_qc = reorder_qc(transpiled_qc)
-        
-        #Transpile logic synthesis
-        reordered_qc = transpile(reordered_qc, transpile_predicate = lambda op : not (isinstance(op, PTControlledOperation) and op.base_operation.name in ["x"]))
-        
+
+        # Transpile logic synthesis
+        reordered_qc = transpile(
+            reordered_qc,
+            transpile_predicate=lambda op: not (
+                isinstance(op, PTControlledOperation)
+                and op.base_operation.name in ["x"]
+            ),
+        )
+
         # We combine adjacent single qubit gates
         if not qs.abstract_params:
             reordered_qc = combine_single_qubit_gates(reordered_qc)
-        
-        #We now determine the amount of Qubits the circuit will need    
+
+        # We now determine the amount of Qubits the circuit will need
         required_qubits = 0
         max_required_qubits = 0
-        
+
         for instr in reordered_qc.data:
             if instr.op.name == "qb_alloc":
                 required_qubits += 1
             elif instr.op.name == "qb_dealloc":
                 required_qubits -= 1
             if max_required_qubits < required_qubits:
                 max_required_qubits += 1
-        
-        #Create a the QuantumCircuit. Note that we make sure that the Qubit naming is consistent,
-        #since we don't want any non-deterministic elements in the function, as this can hinder bugfixing
+
+        # Create a QuantumCircuit. Note that we make sure that the Qubit naming is
+        # consistent, since we don't want any non-deterministic elements in the
+        # function, as this can hinder bugfixing
         qc = QuantumCircuit()
         for i in range(workspace + max_required_qubits):
             qc.add_qubit(Qubit(str(i)))
-    
-        
-        
+
         qc.clbits = list(qs.clbits)
-    
-    
-        #This dictionary translates between the qubits of the input QuantumSession and the compiled circuit
+
+        # This dictionary translates between the qubits of the input QuantumSession and
+        # the compiled circuit
         translation_dic = {}
-        
-        #This list contains the Qubits which are currently not allocated
+
+        # This list contains the Qubits which are currently not allocated
         free_qb_list = list(qc.qubits)
-        
+
         allocated_qb_list = []
-        
-        depth_dic = {b : 0 for b in qc.qubits + qc.clbits}
-        
-        
-        #We now iterate through the data of the preprocessed QuantumCircuit
+
+        depth_dic = {b: 0 for b in qc.qubits + qc.clbits}
+
+        # We now iterate through the data of the preprocessed QuantumCircuit
         for i in range(len(reordered_qc.data)):
-            
             QuantumCircuit.fast_append = True
             instr = reordered_qc.data[i]
             if instr.op.name == "barrier":
                 continue
-            
+
             if instr.op.name == "qb_alloc":
-                #We delay the allocation until an actual gate is executed
+                # We delay the allocation until an actual gate is executed
                 allocated_qb_list.append(instr.qubits[0])
                 continue
-            
-            #Check if any of the involved qubits need an allocation
+
+            # Check if any of the involved qubits need an allocation
             for qb in instr.qubits:
-                
-                if not qb in translation_dic:
-                    #To pick a good allocation, we determine the depth dic and sort the
-                    #available Qubits by their corresponding depth.
-                    #Note that we add the hash value in order to prevent non-deterministic behavior
-                    free_qb_list.sort(key = lambda x : depth_dic[x] + qc.qubits.index(x)*1E-5)
-                    
+                if qb not in translation_dic:
+                    # To pick a good allocation, we determine the depth dic and sort the
+                    # available Qubits by their corresponding depth. Note that we add
+                    # the hash value in order to prevent non-deterministic behavior
+                    free_qb_list.sort(
+                        key=lambda x: depth_dic[x] + qc.qubits.index(x) * 1e-5
+                    )
+
                     translation_dic[qb] = free_qb_list.pop(0)
-                    
+
                     qc.append(QubitAlloc(), [translation_dic[qb]])
-    
+
             if instr.op.name == "qb_dealloc":
-                #For the deallocation, we simply remove the qubits from the translation dic
-                #and append it to the free_qb_list
+                # For the deallocation, we simply remove the qubits from the translation
+                # dict and append it to the free_qb_list
                 free_qb_list.append(translation_dic[instr.qubits[0]])
                 allocated_qb_list.remove(instr.qubits[0])
-                
-                qc.append(instr.op, [translation_dic[qb] for qb in instr.qubits], instr.clbits)
-                
+
+                qc.append(
+                    instr.op, [translation_dic[qb] for qb in instr.qubits], instr.clbits
+                )
+
                 del translation_dic[instr.qubits[0]]
-                
+
                 continue
-    
-            if isinstance(instr.op, ControlledOperation) and instr.op.base_operation.name == "x" and instr.op.method == "auto" and len(instr.qubits) > 3:
-                
-                #This section deals with the automatic recompilation of mcx gates
-                #The reason why we do this is, that it might not be clear how many free ancillae are
-                #available for mcx gates. If we set the method to auto in the mcx function,
-                #this section is called and replaces the generated mcx gate with an implementation
-                #that is better fit to suit the amount of available ancillae.
-                #We first determine the free ancillae
-                
-                
+
+            if (
+                isinstance(instr.op, ControlledOperation)
+                and instr.op.base_operation.name == "x"
+                and instr.op.method == "auto"
+                and len(instr.qubits) > 3
+            ):
+                # This section deals with the automatic recompilation of mcx gates.
+                # The reason why we do this is, that it might not be clear how many free
+                # ancillae are available for mcx gates. If we set the method to auto in
+                # the mcx function, this section is called and replaces the generated
+                # mcx gate with an implementation that is better fit to suit the amount
+                # of available ancillae. We first determine the free ancillae
+
                 clean_ancillae = list(free_qb_list)
-                clean_ancillae.sort(key = lambda x : depth_dic[x] + qc.qubits.index(x)*1E-5)
-                
-                dirty_ancillae = list(set(translation_dic.values()) - set([translation_dic[qb] for qb in instr.qubits]))
-                dirty_ancillae.sort(key = lambda x : depth_dic[x] + qc.qubits.index(x)*1E-5)
-                
+                clean_ancillae.sort(
+                    key=lambda x: depth_dic[x] + qc.qubits.index(x) * 1e-5
+                )
+
+                dirty_ancillae = list(
+                    set(translation_dic.values())
+                    - set([translation_dic[qb] for qb in instr.qubits])
+                )
+                dirty_ancillae.sort(
+                    key=lambda x: depth_dic[x] + qc.qubits.index(x) * 1e-5
+                )
+
                 QuantumCircuit.fast_append = False
-                #This function generates the data for the hybrid implementation
-                compiled_mcx_data = gen_hybrid_mcx_data(instr.qubits[:-1], instr.qubits[-1], instr.op.ctrl_state, clean_ancillae, dirty_ancillae)
-                
-                
-                #We now append the data
+                # This function generates the data for the hybrid implementation
+                compiled_mcx_data = gen_hybrid_mcx_data(
+                    instr.qubits[:-1],
+                    instr.qubits[-1],
+                    instr.op.ctrl_state,
+                    clean_ancillae,
+                    dirty_ancillae,
+                )
+
+                # We now append the data
                 for qb in clean_ancillae + dirty_ancillae:
                     translation_dic[qb] = qb
-                    
+
                 for instr in compiled_mcx_data:
                     qc.append(instr.op, [translation_dic[qb] for qb in instr.qubits])
                     update_depth_dic(qc.data[-1], depth_dic)
-                
-                #And free up the qubits
+
+                # And free up the qubits
                 for qb in clean_ancillae + dirty_ancillae:
                     del translation_dic[qb]
-                
+
                 QuantumCircuit.fast_append = True
-            
-            #Finally if all of the above cases are not met, we simply append the operation to the translated qubits
+
+            # Finally if all of the above cases are not met, we simply append the
+            # operation to the translated qubits
             else:
-                
                 try:
-                    qc.data.append(Instruction(instr.op, [translation_dic[qb] for qb in instr.qubits], instr.clbits))
-                    
+                    qc.data.append(
+                        Instruction(
+                            instr.op,
+                            [translation_dic[qb] for qb in instr.qubits],
+                            instr.clbits,
+                        )
+                    )
+
                 except KeyError:
-                    raise Exception("Found operation " + instr.op.name + " on unallocated qubit during compilation.")
-                
+                    raise Exception(
+                        "Found operation "
+                        + instr.op.name
+                        + " on unallocated qubit during compilation."
+                    )
+
                 update_depth_dic(qc.data[-1], depth_dic)
-        
-        #Allocate the qubits which had an alloc gate but no actual gates
+
+        # Allocate the qubits which had an alloc gate but no actual gates
         for qb in allocated_qb_list:
             if qb not in translation_dic:
                 translation_dic[qb] = free_qb_list.pop(0)
-        
-        
-        #The following code is mostly about renaming and ordering the resulting circuit
-        #in order to make the compiled circuit still comprehensible
-        
-        #We rename the allocated qubits to their name from the quantum session
+
+        # The following code is mostly about renaming and ordering the resulting circuit
+        # in order to make the compiled circuit still comprehensible
+
+        # We rename the allocated qubits to their name from the quantum session
         for i in range(len(qs.qubits)):
             if qs.qubits[i] in translation_dic:
                 translation_dic[qs.qubits[i]].identifier = qs.qubits[i].identifier
                 translation_dic[qs.qubits[i]].hash_value = qs.qubits[i].hash_value
-    
-        #We also want the qubits to be sorted according the order of the QuantumVariables
-        #ie. the order of creation
+
+        # We also want the qubits to be sorted according the order of the
+        # QuantumVariables, i.e. the order of creation
         sorted_qubit_list = []
         for qv in qs.qv_list:
-            
-            #Due to the measurement reduction feature, not all qubits of quantum variables
-            #that are live, are guaranteed to be represented in the translation dic
-            #Therefore we need the try - except structure here
+            # Due to the measurement reduction feature, not all qubits of quantum
+            # variables that are live, are guaranteed to be represented in the
+            # translation dict. Therefore, we need the try - except structure here
             try:
                 sorted_qubit_list.extend([translation_dic[qb] for qb in qv.reg])
             except KeyError:
                 pass
-        
-        #Furthermore, not all qubits that have been deallocated in the QuantumSession
-        #are guaranteed to be removed from the translation dic, since the 
-        #measurement_reduction function might have removed their uncomputation/deallocation gates
+
+        # Furthermore, not all qubits that have been deallocated in the QuantumSession
+        # are guaranteed to be removed from the translation dic, since the
+        # measurement_reduction function might have removed their
+        # uncomputation/deallocation gates
         temp = list(set(translation_dic.values()) - set(sorted_qubit_list))
-        temp.sort(key = lambda x : x.identifier)
+        temp.sort(key=lambda x: x.identifier)
         sorted_qubit_list.extend(temp)
-    
-        
-        #Finally, we rename the deallocated qubits to "workspace"    
+
+        # Finally, we rename the deallocated qubits to "workspace"
         workspace_naming_counter = 0
         td_values = list(translation_dic.values())
         for i in range(len(qc.qubits)):
             if not qc.qubits[i] in td_values:
                 qc.qubits[i].identifier = "workspace_" + str(workspace_naming_counter)
                 workspace_naming_counter += 1
                 sorted_qubit_list.append(qc.qubits[i])
-    
+
         qc.qubits = sorted_qubit_list
-        
+
         reduced_qc = reduce_depth(qc)
-        
+
     if reduced_qc.depth() > qc.depth():
         return qc
     else:
         return reduced_qc
 
 
 def gen_hybrid_mcx_data(controls, target, ctrl_state, clean_ancillae, dirty_ancillae):
-    #This function generates the data for the hybrid mcx implementation
-    
-    from qrisp.circuit.multi_cx import hybrid_mcx
+    # This function generates the data for the hybrid mcx implementation
+
+    from qrisp.misc.multi_cx import hybrid_mcx
     from qrisp.core import QuantumVariable
-    #Specify QuantumVariables to call mcx function
-    control_qv = QuantumVariable(len(controls), name = "control")
-    target_qv = QuantumVariable(1, name = "target")
-    
+
+    # Specify QuantumVariables to call mcx function
+    control_qv = QuantumVariable(len(controls), name="control")
+    target_qv = QuantumVariable(1, name="target")
+
     # dirty_ancillae = dirty_ancillae + clean_ancillae
-    hybrid_mcx(control_qv, target_qv, ctrl_state = ctrl_state, num_ancilla = len(clean_ancillae), num_dirty_ancilla = len(dirty_ancillae))
-    
-    #Get the list of used ancillae    
-    used_ancillae_set = set(control_qv.qs.qubits) - set(control_qv.reg) - set(target_qv.reg)
-    
-    #If we used the list() function to transform the set, this introduces a non-deterministic
-    #element in the compilation algorithm, which can hamper bugfixing
+    hybrid_mcx(
+        control_qv,
+        target_qv,
+        ctrl_state=ctrl_state,
+        num_ancilla=len(clean_ancillae),
+        num_dirty_ancilla=len(dirty_ancillae),
+    )
+
+    # Get the list of used ancillae
+    used_ancillae_set = (
+        set(control_qv.qs.qubits) - set(control_qv.reg) - set(target_qv.reg)
+    )
+
+    # If we used the list() function to transform the set, this introduces a
+    # non-deterministic element in the compilation algorithm, which can hamper bugfixing
     used_clean_ancillae = []
     used_dirty_ancillae = []
-    
+
     for qb in control_qv.qs.qubits:
         if qb in used_ancillae_set:
             if "dirty" in qb.identifier:
                 used_dirty_ancillae.append(qb)
             else:
                 used_clean_ancillae.append(qb)
-    
-    
+
     depth_dic = get_depth_dic(control_qv.qs)
-    
-    used_clean_ancillae.sort(key = lambda x : -depth_dic[x])
-    used_dirty_ancillae.sort(key = lambda x : -depth_dic[x])
-    
-    
+
+    used_clean_ancillae.sort(key=lambda x: -depth_dic[x])
+    used_dirty_ancillae.sort(key=lambda x: -depth_dic[x])
+
     # ancilla_list = list(clean_ancillae)
-    
+
     # for i in range(len(used_ancillae)):
     #     if "yong" in used_ancillae[i].identifier:
     #         used_ancillae.insert(0, used_ancillae.pop(i))
     #         ancilla_list.insert(0, dirty_ancillae[0])
     #         break
-    
-    #Now retarget the instructions such that they use the appropriate qubits
+
+    # Now retarget the instructions such that they use the appropriate qubits
     data = control_qv.qs.data
-    
+
     retarget_instructions(data, list(control_qv), controls)
     retarget_instructions(data, list(target_qv), [target])
     retarget_instructions(data, used_clean_ancillae, clean_ancillae)
     retarget_instructions(data, used_dirty_ancillae, dirty_ancillae)
-    
+
     i = 0
-    #Remove (de)allocation gates
+    # Remove (de)allocation gates
     while i < len(data):
         if data[i].op.name in ["qb_dealloc", "qb_alloc"]:
             data.pop(i)
             continue
         i += 1
-        
-    return data
 
+    return data
 
 
 def reorder_qc(qc):
-    
     from qrisp.uncomputation import dag_from_qc
-    G = dag_from_qc(qc, remove_init_nodes = True)
-    
+
+    G = dag_from_qc(qc, remove_init_nodes=True)
+
     qc_new = qc.clearcopy()
-    
-    dealloc_identifier = lambda x : x.op.name == "qb_dealloc"
-    alloc_identifer = lambda x : x.op.name == "qb_alloc"
-    
+
+    dealloc_identifier = lambda x: x.op.name == "qb_dealloc"
+    alloc_identifer = lambda x: x.op.name == "qb_alloc"
+
     # mcx_identifier = lambda x : isinstance(x.op, PTControlledOperation) and x.op.base_operation.name == "x"
     # nmcx_identifier = lambda x : not mcx_identifier(x)
     # sub_sort = lambda G : topological_sort(G, prefer = mcx_identifier, delay = nmcx_identifier)
     # for n in topological_sort(G, prefer = dealloc_identifier, delay = alloc_identifer, sub_sort = sub_sort):
-        
-    for n in topological_sort(G, prefer = dealloc_identifier, delay = alloc_identifer):
+
+    for n in topological_sort(G, prefer=dealloc_identifier, delay=alloc_identifer):
         qc_new.append(n.instr)
-    
-    return qc_new
 
+    return qc_new
 
 
-#This function performs a topological sort of the graph G where we try to execute any deallocation gates
-#as early as possible while still adhering to the topological order.
-#We to perform a depth-first search as described here: https://en.wikipedia.org/wiki/Topological_sorting
-#According to the Wikipedia page, we are allowed to pick any node as a "starting point" of the DF-search,
-#which allows us to have modify the algorithm such that it optimizes the (de)allocation order.
-#The general idea is to pick the deallocation nodes as starting points, where we order them,
-#such that those deallocation nodes that "require" the least allocation nodes are executed first.
-#"Require" here means that there is a causal relationship between the allocation and deallocation nodes,
-#ie. there is a path from the allocation node to the deallocation node.
-
-#We can thus determine the amount of allocation nodes required for a deallocation node n by counting, the amount
-#of allocation nodes in the "ancestors" subgraph of n.
-def topological_sort(G, prefer = None, delay = None, sub_sort = nx.topological_sort):
+# This function performs a topological sort of the graph G where we try to execute any
+# deallocation gates as early as possible while still adhering to the topological order.
+# We try to perform a depth-first search as described here:
+# https://en.wikipedia.org/wiki/Topological_sorting
+# According to the Wikipedia page, we are allowed to pick any node as a "starting point"
+# of the DF-search, which allows us to modify the algorithm such that it optimizes the
+# (de)allocation order. The general idea is to pick the deallocation nodes as
+# starting points, where we order them, such that those deallocation nodes that
+# "require" the least allocation nodes are executed first. "Require" here means that
+# there is a causal relationship between the allocation and deallocation nodes,
+# i.e. there is a path from the allocation node to the deallocation node.
+
+
+# We can thus determine the amount of allocation nodes required for a deallocation node
+# n by counting, the amount of allocation nodes in the "ancestors" subgraph of n.
+def topological_sort(G, prefer=None, delay=None, sub_sort=nx.topological_sort):
     """
-    Function to perform a topological sort on an Unqomp DAG which allows prefering/delaying specific types of nodes
+    Function to perform a topological sort on an Unqomp DAG which allows preferring/
+    delaying specific types of nodes
 
     Parameters
     ----------
     G : nx.DiGraph
         The Unqomp DAG.
     prefer : function, optional
-        Function which returns True, when presented with an Instruction, that should be prefered. The default is the function that returns False on all Operations
+        Function which returns True, when presented with an Instruction, that should be
+        preferred. The default is the function that returns False on all Operations
     delay : function, optional
-        Function which returns True, when presented with an Instruction, that should be delayed. The default is the function that returns False on all Operations
+        Function which returns True, when presented with an Instruction, that should be
+        delayed. The default is the function that returns False on all Operations
     sub_sort : function, optional
-        A function which performs a topological sort, which can sorting preferences of secondary importance. The default is nx.topological_sort.
+        A function which performs a topological sort, which can sorting preferences of
+        secondary importance. The default is nx.topological_sort.
 
     Returns
     -------
     lin : list[UnqompNode]
         The linearized list of UnqompNodes. The init nodes are not included.
 
     """
-    
+
     if prefer is None:
-        prefer = lambda x : False
-    
+        prefer = lambda x: False
+
     if delay is None:
-        delay = lambda x : False
-    
+        delay = lambda x: False
+
     G = G.copy()
-    #Collect the prefered nodes
+    # Collect the prefered nodes
     prefered_nodes = []
-    
+
     for n in G.nodes():
         if prefer(n.instr):
-            
             prefered_nodes.append(n)
-            
+
         n.processed = False
-    
-    #For large scales, finding the ancestors is a bottle neck. We therefore use a jitted version
-    if len(G)*len(prefered_nodes) > 10000:
+
+    # For large scales, finding the ancestors is a bottleneck. We therefore use a
+    # jitted version
+    if len(G) * len(prefered_nodes) > 10000:
         anc_lists = ancestors(G, prefered_nodes)
-        node_ancs = {prefered_nodes[i] : anc_lists[i] for i in range(len(prefered_nodes))}
+        node_ancs = {
+            prefered_nodes[i]: anc_lists[i] for i in range(len(prefered_nodes))
+        }
     else:
-        node_ancs = {prefered_nodes[i] : list(nx.ancestors(G, prefered_nodes[i])) for i in range(len(prefered_nodes))}
-    #Determine the required delay nodes for each prefered nodes
-    required_delay_nodes = {n : [] for n in prefered_nodes}
-    
+        node_ancs = {
+            prefered_nodes[i]: list(nx.ancestors(G, prefered_nodes[i]))
+            for i in range(len(prefered_nodes))
+        }
+    # Determine the required delay nodes for each prefered nodes
+    required_delay_nodes = {n: [] for n in prefered_nodes}
+
     for n in prefered_nodes:
         for k in node_ancs[n]:
             if delay(k.instr):
                 required_delay_nodes[n].append(k)
-    
-    required_delay_nodes = {n : set(required_delay_nodes[n]) for n in prefered_nodes}
-            
-    #Generate linearization
+
+    required_delay_nodes = {n: set(required_delay_nodes[n]) for n in prefered_nodes}
+
+    # Generate linearization
     lin = []
-    
+
     while prefered_nodes:
-        
-        #Sort nodes accordingly
-        prefered_nodes.sort(key = lambda x : len(required_delay_nodes[x]))
-        
-        
+        # Sort nodes accordingly
+        prefered_nodes.sort(key=lambda x: len(required_delay_nodes[x]))
+
         node = prefered_nodes.pop(0)
         ancs = []
-        
+
         for n in node_ancs[node] + [node]:
             if n.processed:
                 continue
             else:
                 n.processed = True
                 ancs.append(n)
-        
+
         sub_graph = G.subgraph(ancs)
-        
+
         lin += list(sub_sort(sub_graph))
-        
+
         continue
+
         for n in prefered_nodes:
-            required_delay_nodes[n] = required_delay_nodes[n] - required_delay_nodes[node]
-        
-    #Linearize the remainder
+            required_delay_nodes[n] = (
+                required_delay_nodes[n] - required_delay_nodes[node]
+            )
+
+    # Linearize the remainder
     remainder = []
     for n in G.nodes():
         if n.processed:
             continue
         else:
             n.processed = True
             remainder.append(n)
-    
+
     # lin += list(sub_sort(G))
     lin += list(sub_sort(G.subgraph(remainder)))
-    
+
     return lin
 
 
-#Function to combine any sequences of single qubit gates into a single U3
+# Function to combine any sequences of single qubit gates into a single U3
 def combine_single_qubit_gates(qc):
-    
     def apply_combined_gates(qc_new, gate_list, qb):
-        
         if not len(gate_list):
             return
-        
+
         n = len(gate_list)
-        
+
         m = np.eye(2)
         while gate_list:
             gate = gate_list.pop(-1)
             m = np.dot(m, gate.get_unitary())
-        
-        if np.linalg.norm(m - np.eye(2)) < 1E-10:
+
+        if np.linalg.norm(m - np.eye(2)) < 1e-10:
             return
-            
+
         if n == 1:
             qc_new.append(gate, [qb])
             return
-        
+
         qc_new.unitary(m, [qb])
-        
-    qb_dic = {qb : [] for qb in qc.qubits}
-    
+
+    qb_dic = {qb: [] for qb in qc.qubits}
+
     qc_new = qc.clearcopy()
-    
+
     for instr in qc.data:
-        if len(instr.qubits) > 1 or instr.op.name in ["qb_alloc", "qb_dealloc"] or len(instr.clbits) > 0:
-            
+        if (
+            len(instr.qubits) > 1
+            or instr.op.name in ["qb_alloc", "qb_dealloc"]
+            or len(instr.clbits) > 0
+        ):
             for qb in instr.qubits:
                 apply_combined_gates(qc_new, qb_dic[qb], qb)
             qc_new.append(instr)
         else:
             qb_dic[instr.qubits[0]].append(instr.op)
-            
+
     for qb in qc.qubits:
         apply_combined_gates(qc_new, qb_dic[qb], qb)
-    
+
     return qc_new
 
-   
 
-#This function reorders the circuit such that the intended measurements can be executed as early as possible.
-#Additionally, any instructions that are not needed for the intended measurements are removed
+# This function reorders the circuit such that the intended measurements can be executed
+# as early as possible. Additionally, any instructions that are not needed for the
+# intended measurements are removed
 
-#Intended measurements has to be a list of qubits
+# Intended measurements has to be a list of qubits
 
-#The strategy is similar to the one presented in reorder_circuit:
-#We bring the circuit in the dag representation and perform a topological sort with
-#the intended measurement as prefered instructions
+# The strategy is similar to the one presented in reorder_circuit:
+# We bring the circuit in the dag representation and perform a topological sort with
+# the intended measurement as prefered instructions
 
-#After that we investigate the circuit for instructions that can be removed
+
+# After that we investigate the circuit for instructions that can be removed
 def measurement_reduction(qc, intended_measurements):
-    
     qc = qc.copy()
-    
-    #Insert intended measurements into the circuit
+
+    # Insert intended measurements into the circuit
     for qb in intended_measurements:
         qc.measure(qb)
 
-    #Generate dag representation    
+    # Generate dag representation
     from qrisp.uncomputation import dag_from_qc
-    G = dag_from_qc(qc, remove_init_nodes = True)
-    
-    #Create result qc
+
+    G = dag_from_qc(qc, remove_init_nodes=True)
+
+    # Create result qc
     qc_new = qc.clearcopy()
 
-    #Define prefered instructions    
-    measure_identifier = lambda x : x.op.name == "measure" and x.qubits[0] in intended_measurements
-    
-    
-    #Perform topological sort
-    for n in topological_sort(G, prefer = measure_identifier):
+    # Define prefered instructions
+    measure_identifier = (
+        lambda x: x.op.name == "measure" and x.qubits[0] in intended_measurements
+    )
+
+    # Perform topological sort
+    for n in topological_sort(G, prefer=measure_identifier):
         qc_new.append(n.instr)
 
-    #Check which instructions come after the final measurement        
+    # Check which instructions come after the final measurement
     for i in range(len(qc_new.data))[::-1]:
         if measure_identifier(qc_new.data[i]):
             break
-    
+
     redundant_qc = qc_new.clearcopy()
-    
-    redundant_qc.data = qc_new.data[i+1:]
-    
-    
-
-    G = dag_from_qc(redundant_qc, remove_init_nodes = True)
-    
-    
+
+    redundant_qc.data = qc_new.data[i + 1 :]
+
+    G = dag_from_qc(redundant_qc, remove_init_nodes=True)
+
     # alloc_graph = allocation_graph(redundant_qc)
-    
-    
+
     for node in G.nodes():
-        
         if node.instr.op.name == "qb_dealloc":
             ancs = nx.ancestors(G, node)
             for pred in ancs:
                 if pred.instr.op.name == "qb_alloc":
                     break
             else:
                 redundant_qc.data.remove(node.instr)
                 # print(f"removed {node.instr}")
                 for pred in ancs:
-                    
                     try:
                         redundant_qc.data.remove(pred.instr)
                     except ValueError:
                         pass
-                    
-                    
-        
-    # print(redundant_qc)    
-    
+
+    # print(redundant_qc)
+
     redundant_instructions = redundant_qc.data
     # print(redundant_instructions)
-    
-    
+
     # redundanct_instructions = qc_new.data[i+1:]
     # #Now we need to make sure we don't remove deallocation gates from the data
     # #because this would inflate the qubit count of the compiled circuit
-    
+
     # #The strategy here is that if we find a deallocation gate
-    # #we remove any instruction involving the deallocated qubit from the list 
+    # #we remove any instruction involving the deallocated qubit from the list
     # #redundant instructions.
-    
+
     # #If we however find an allocation gate, this chain of instructions can be
     # #safely removed and therefore stay in the redundant instructions
-    
+
     # i = 0
     # while i < len(redundant_instructions):
     #     if redundant_instructions[i].op.name == "qb_dealloc":
     #         dealloc_qubit = redundant_instructions[i].qubits[0]
-            
+
     #         j = 0
     #         while j < len(redundant_instructions):
     #             if dealloc_qubit in redundant_instructions[j].qubits:
     #                 if redundant_instructions[j].op.name == "qb_alloc":
     #                     i += 1
     #                     break
-                    
+
     #                 redundant_instructions.pop(j)
     #                 continue
     #             j += 1
     #         continue
     #     i += 1
-            
-    #We now remove the redundant instructions and the inserted 
-    #measurements from the circuit data
+
+    # We now remove the redundant instructions and the inserted
+    # measurements from the circuit data
     i = 0
     while i < len(qc_new.data):
-        
         if measure_identifier(qc_new.data[i]):
             qc_new.data.pop(i)
             continue
         if qc_new.data[i] in redundant_instructions:
             qc_new.data.pop(i)
             continue
         i += 1
-    
-    
+
     return qc_new
 
 
 def allocation_graph(qc):
     from qrisp.uncomputation.unqomp import dag_from_qc
-    dag = dag_from_qc(qc, remove_init_nodes = True)
-    
+
+    dag = dag_from_qc(qc, remove_init_nodes=True)
+
     res = nx.DiGraph()
-    
+
     dealloc_nodes = []
     for n in dag.nodes():
         if n.instr.op.name in ["qb_alloc", "qb_dealloc"]:
             res.add_node(n)
         if n.instr.op.name == "qb_dealloc":
             dealloc_nodes.append(n)
-    
+
     for n in dealloc_nodes:
         for anc in nx.ancestors(n, dag):
             if anc.instr.op.name == "qb_alloc":
                 res.add_edge(anc, n)
-                
+
     return n
-    
-    
+
+
 def update_depth_dic(instruction, depth_dic):
-    
     if instruction.op.definition:
         qc = QuantumCircuit()
         qc.qubits = instruction.qubits
         qc.append(instruction)
         instr_list = qc.transpile().data
     else:
         instr_list = [instruction]
-    
+
     # Assign each bit in the circuit a unique integer
     # to index into op_stack.
     # If no bits, return 0
 
-
     # Here we are playing a modified version of
     # Tetris where we stack gates, but multi-qubit
     # gates, or measurements have a block for each
     # qubit or cbit that are connected by a virtual
     # line so that they all stacked at the same depth.
     # Conditional gates act on all cbits in the register
     # they are conditioned on.
     # We treat barriers or snapshots different as
     # They are transpiler and simulator directives.
     # The max stack height is the circuit depth.
-    
+
     for instr in instr_list:
-        
         if instr.op.name in ["qb_alloc", "qb_dealloc"]:
             continue
         qargs = instr.qubits
         cargs = instr.clbits
-        
+
         levels = []
         # If count then add one to stack heights
-        
+
         for b in qargs + cargs:
             # Add to the stacks of the qubits and
             # cbits used in the gate.
             levels.append(depth_dic[b] + 1)
-    
+
         max_level = max(levels)
-            
+
         for b in qargs + cargs:
             depth_dic[b] = max_level
 
 
-@njit(cache = True)
+@njit(cache=True)
 def ancestors_jitted(start_index, indptr, indices, node_amount):
-    
-    to_do_array = np.zeros(node_amount, dtype = np.byte)
+    to_do_array = np.zeros(node_amount, dtype=np.byte)
     to_do_array[start_index] = 1
-    done_array = np.zeros(node_amount, dtype = np.byte)
-    
+    done_array = np.zeros(node_amount, dtype=np.byte)
+
     stack = 1
     while stack:
-        
         node = np.argmax(to_do_array)
         to_do_array[node] = 0
-        
-        for i in range(indptr[node], indptr[node+1]):
+
+        for i in range(indptr[node], indptr[node + 1]):
             new_node = indices[i]
             if done_array[new_node] == 0:
                 to_do_array[new_node] = 1
                 stack += 1
-        
+
         done_array[node] = 1
         stack -= 1
-        
+
     return np.nonzero(done_array)[0]
 
-@njit(parallel = True, cache = True)
+
+@njit(parallel=True, cache=True)
 def ancestors_jitted_wrapper(start_indices, indptr, indices, node_amount):
-    
-    res = [np.zeros(1, dtype = np.int64)]*len(start_indices)
+    res = [np.zeros(1, dtype=np.int64)] * len(start_indices)
     for i in prange(len(start_indices)):
         start_index = start_indices[i]
         res[i] = ancestors_jitted(start_index, indptr, indices, node_amount)
-    
+
     return res
-        
+
 
 def ancestors(dag, start_nodes):
-    
     node_list = list(dag.nodes())
-    
-    sprs_mat = nx.to_scipy_sparse_array(dag, format = "csc")
-    
+
+    sprs_mat = nx.to_scipy_sparse_array(dag, format="csc")
+
     start_indices = []
     for i in range(len(dag)):
         if node_list[i] in start_nodes:
             start_indices.append(i)
-    
-    res_list_indices = ancestors_jitted_wrapper(np.array(start_indices).astype(np.int32), sprs_mat.indptr, sprs_mat.indices.astype(np.int32), len(dag))
-    
-    node_list = [[node_list[j] for j in anc_indices] for anc_indices in res_list_indices]
-    
+
+    res_list_indices = ancestors_jitted_wrapper(
+        np.array(start_indices).astype(np.int32),
+        sprs_mat.indptr,
+        sprs_mat.indices.astype(np.int32),
+        len(dag),
+    )
+
+    node_list = [
+        [node_list[j] for j in anc_indices] for anc_indices in res_list_indices
+    ]
+
     return node_list
 
 
 # Function to cancel adjacent QFT, which are inverse to each other
 # Due to the heavy use of Fourier arithmetic, this can happen alot
 # especially if multiple arithmetic operation on a single target are executed
 def qft_cancellation(qc):
-    
     # The idea is to iterate through the instructions of the circuit
     # and save the last instruction acting on each qubit.
     # If a QFT is appended, we check if the last instruction was an inverse QFT
     # or an allocation and denote the index if so
     # Afterwards, we remove the QFTs or replace them with H gates
-    
-    last_instr_dic = {qb : None for qb in qc.qubits}
+
+    last_instr_dic = {qb: None for qb in qc.qubits}
     cancellation_indices = []
     h_replacements = []
     dealloc_replacements = []
     from numpy.linalg import norm
-    
+
     for i in range(len(qc.data)):
-        
         instr = qc.data[i]
         if "QFT" in instr.op.name:
             previous_instruction_type = []
-            
+
             for qb in instr.qubits:
-                
                 previous_instruction = qc.data[last_instr_dic[qb]]
-                
+
                 if previous_instruction.op.num_qubits != instr.op.num_qubits:
                     break
-                
+
                 if "QFT" in previous_instruction.op.name:
-                    
                     if instr.op.num_qubits < 8:
-                        
                         unitary_self = instr.op.get_unitary()
-                        inv_unitary_other = previous_instruction.op.get_unitary().transpose().conjugate()
+                        inv_unitary_other = (
+                            previous_instruction.op.get_unitary()
+                            .transpose()
+                            .conjugate()
+                        )
 
                         if bool(norm(unitary_self - inv_unitary_other) < 10**-4):
                             previous_instruction_type.append("QFT")
                         else:
                             break
-                        
-                    elif hash(instr.op.definition) == hash(previous_instruction.op.definition.inverse()):
+
+                    elif hash(instr.op.definition) == hash(
+                        previous_instruction.op.definition.inverse()
+                    ):
                         previous_instruction_type.append("QFT")
                     else:
                         break
-                    
+
                 elif previous_instruction.op.name == "qb_alloc":
-                   previous_instruction_type.append("alloc")
+                    previous_instruction_type.append("alloc")
                 else:
                     break
             else:
                 if len(set(previous_instruction_type)) == 1:
                     if previous_instruction_type[0] == "QFT":
                         cancellation_indices.append(i)
                         cancellation_indices.append(last_instr_dic[qb])
                     else:
                         h_replacements.append(i)
-        
+
         if instr.op.name == "qb_dealloc":
-            
             deallocated_qubit = instr.qubits[0]
             previous_instruction = qc.data[last_instr_dic[deallocated_qubit]]
-            
+
             if "QFT" in previous_instruction.op.name:
                 try:
                     previous_instruction.deallocated_qubits[deallocated_qubit] = True
                 except AttributeError:
-                    previous_instruction.deallocated_qubits = {qb : False for qb in previous_instruction.qubits}
+                    previous_instruction.deallocated_qubits = {
+                        qb: False for qb in previous_instruction.qubits
+                    }
                     previous_instruction.deallocated_qubits[deallocated_qubit] = True
                     dealloc_replacements.append(last_instr_dic[deallocated_qubit])
-                        
+
         for qb in instr.qubits:
             last_instr_dic[qb] = i
-    
-    
+
     for i in dealloc_replacements:
         instr = qc.data[i]
         for qb in instr.qubits:
             if not instr.deallocated_qubits[qb]:
                 break
         else:
             h_replacements.append(i)
-    
+
     new_qc = qc.clearcopy()
-    
+
     # print(len(qc.data))
     for i in range(len(qc.data)):
-        
         if i in h_replacements:
             for qb in qc.data[i].qubits:
                 new_qc.h(qb)
             # print("H replacement successfull")
             continue
-                
+
         if i in cancellation_indices:
             continue
         else:
             new_qc.append(qc.data[i])
-    # print(len(new_qc.data))    
+    # print(len(new_qc.data))
     # print("====")
     return new_qc
-
```

### Comparing `qrisp-0.0.15/src/qrisp/core/library.py` & `qrisp-0.0.16/src/qrisp/core/library.py`

 * *Files 11% similar despite different names*

```diff
@@ -7,222 +7,249 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-import qrisp.circuit.standard_operations as std_ops
 import numpy as np
+
+import qrisp.circuit.standard_operations as std_ops
 from qrisp.core import recursive_qs_search
 
-def append_operation(operation, qubits = [], clbits = []):
-    
+
+def append_operation(operation, qubits=[], clbits=[]):
     qs_list = recursive_qs_search([qubits, clbits])
-    
+
     if len(qs_list) == 0:
         raise Exception("Could not find QuantumSession object to append operation")
-    
-    qs_list[0].append(operation, qubits, clbits)
-        
 
+    qs_list[0].append(operation, qubits, clbits)
 
 
 def cx(control, target):
     """
     Applies a CX gate.
 
     Parameters
     ----------
     control : Qubit or list[Qubit] or QuantumVariable
         The Qubit to control on.
     target : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the X gate on.
     """
     append_operation(std_ops.CXGate(), [control, target])
-    
+
     # std_ops.CXGate().append([qubits_0, qubits_1])
-    
+
     return control, target
 
+
 def cy(control, target):
     """
     Applies a CY gate.
 
     Parameters
     ----------
     control : Qubit or list[Qubit] or QuantumVariable
         The Qubit to control on.
     target : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the Y gate on.
     """
-    
+
     append_operation(std_ops.CYGate(), [control, target])
     return control, target
 
+
 def cz(control, target):
     """
     Applies a CZ gate.
 
     Parameters
     ----------
     control : Qubit or list[Qubit] or QuantumVariable
         The Qubit to control on.
     target : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the Z gate on.
     """
-    
+
     append_operation(std_ops.CZGate(), [control, target])
     return control, target
-    
+
+
 def h(qubits):
     """
     Applies an H gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the H gate on.
     """
     append_operation(std_ops.HGate(), [qubits])
-    
+
     # std_ops.HGate().append([qubits])
-    
+
     return qubits
-    
+
+
 def x(qubits):
     """
     Applies an X gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the X gate on.
     """
-    
+
     append_operation(std_ops.XGate(), [qubits])
-    
+
     # std_ops.XGate().append([qubits])
-    
+
     return qubits
 
+
 def y(qubits):
     """
     Applies a Y gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the Y gate on.
     """
-    
+
     append_operation(std_ops.YGate(), [qubits])
-    
+
     # std_ops.YGate().append([qubits])
-    
+
     return qubits
 
+
 def z(qubits):
     """
     Applies a Z gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the Z gate on.
     """
     append_operation(std_ops.ZGate(), [qubits])
-    
+
     # std_ops.ZGate().append([qubits])
     return qubits
-    
 
-def mcx(controls, target, method = "auto", ctrl_state = -1, num_ancilla = 1):
+
+def mcx(controls, target, method="auto", ctrl_state=-1, num_ancilla=1):
     r"""
     Applies a multi-controlled X gate.
-    
+
     The following methods are available:
+
+    * ``gray`` performs a gray code traversal which requires no ancillae 
+      but is rather inefficient for large numbers of control qubits.
     
-    * ``gray`` performs a gray code traversal which requires no ancillae but is rather inefficient for large numbers of control qubits.
-    
-    * ``gray_pt`` and ``gray_pt_inv`` are more efficient but introduce extra phases that need to be uncomputed by performing the inverse of this gate on the same inputs. For more information on phase tolerance, check `this paper <https://iopscience.iop.org/article/10.1088/2058-9565/acaf9d/meta>`_.
-    
-    * ``balauca`` is a method based on this `paper <https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf>`_ with logarithmic depth but requires many ancilla qubits.
-    
-    * ``maslov`` is documented `here <https://arxiv.org/abs/1508.03273>`_, requires less ancilla qubits but is only available for 4 or less control qubits.
-    
-    * ``yong`` can be found int this `article <https://link.springer.com/article/10.1007/s10773-017-3389-4>`_. This method requires only a single ancilla and has moderate scaling in depth and gate count.
-    
-    * ``hybrid`` is a flexible method which combines the other available methods, such that the amount of used ancillae is customizable. After several ``balauca``-layers, the recursion is canceled by either a ``yong``, ``maslov`` or ``gray`` mcx, depending on what fits the most.
+    * ``gray_pt`` and ``gray_pt_inv`` are more efficient but introduce extra 
+      phases that need to be uncomputed by performing the inverse of this gate 
+      on the same inputs. For more information on phase tolerance, check
+      `this paper <https://iopscience.iop.org/article/10.1088/2058-9565/acaf9d/meta>`_.
+    
+    * ``balauca`` is a method based on this `paper
+      <https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf>`_ with
+      logarithmic depth but requires many ancilla qubits.
+    
+    * ``maslov`` is documented `here <https://arxiv.org/abs/1508.03273>`_, requires less
+      ancilla qubits but is only available for 4 or less control qubits.
+    
+    * ``yong`` can be found int this `article
+      <https://link.springer.com/article/10.1007/s10773-017-3389-4>`_.This method requires
+      only a single ancilla and has moderate scaling in depth and gate count.
+    
+    * ``hybrid`` is a flexible method which combines the other available methods, such
+      that the amount of used ancillae is customizable. After several ``balauca``-layers,
+      the recursion is canceled by either a ``yong``, ``maslov`` or ``gray`` mcx,
+      depending on what fits the most.
+    
+    * ``auto`` recompiles the mcx gate at compile time using the hybrid algorithm
+      together with the information about how many clean/dirty ancillae qubits are
+      available. For more information check :meth:`qrisp.QuantumSession.compile`.
     
-    * ``auto`` recompiles the mcx gate at compile time using the hybrid algorithm together with the information about how many clean/dirty ancillae qubits are available. For more information check :meth:`qrisp.QuantumSession.compile`.
     
     .. note::
-        Due to Qrisp's automatic qubit management, clean ancilla qubits are not as much of a sparse resource as one might think. Even though the ``balauca`` method requires a considerable amount of ancillae, many other functions also do, implying there is alot of recycling potential. The net effect is that in more complex programs, the amount of qubits of the circuit returned by the :meth:`compile method <qrisp.QuantumSession.compile>` increases only slightly.
+        Due to Qrisp's automatic qubit management, clean ancilla qubits are not as much
+        of a sparse resource as one might think. Even though the ``balauca`` method
+        requires a considerable amount of ancillae, many other functions also do,
+        implying there is alot of recycling potential. The net effect is that in more
+        complex programs, the amount of qubits of the circuit returned by the
+        :meth:`compile method <qrisp.QuantumSession.compile>` increases only slightly.
+
 
-    
     Parameters
     ----------
     controls : list[Qubits] or QuantumVariable
         The Qubits to control on.
     target : Qubit
         The Qubit to perform the X gate on.
     method : str, optional
-        The synthesis method. Available are ``auto``, ``gray``, ``gray_pt``, ``gray_pt_inv``, ``maslov``, ``balauca`` and ``yong``. The default is ``auto``.
+        The synthesis method. Available are ``auto``, ``gray``, ``gray_pt``,
+        ``gray_pt_inv``, ``maslov``, ``balauca`` and ``yong``. The default is ``auto``.
     ctrl_state : int or str, optional
         The state on which to activate the X gate. The default is "1111..".
     num_ancilla : int, optional
-        Specifies the amount of ancilla qubits to use. This parameter is used only if the method is set to ``hybrid``. The default is 1.
-    
-    
+        Specifies the amount of ancilla qubits to use. This parameter is used only if
+        the method is set to ``hybrid``. The default is 1.
+
+
     Examples
     --------
-    
+
     We apply a 3-contolled X gate
-    
+
     >>> from qrisp import QuantumVariable, mcx
     >>> control = QuantumVariable(3)
     >>> target = QuantumVariable(1)
     >>> mcx(control, target, method = "gray")
     >>> print(control.qs)
     QuantumCircuit:
     ---------------
     control.0: ──■──
-                 │  
+                 │
     control.1: ──■──
-                 │  
+                 │
     control.2: ──■──
                ┌─┴─┐
      target.0: ┤ X ├
                └───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable control
-    QuantumVariable target  
-    
+    QuantumVariable target
+
     We compare different performance indicators. ::
-        
+
         from qrisp import QuantumVariable, mcx
-        
+
         def benchmark_mcx(n, methods):
             for method in methods:
-                
+
                 controls = QuantumVariable(n)
                 target = QuantumVariable(1)
-                
+
                 mcx(controls, target, method = method)
-                
+
                 compiled_qc = controls.qs.compile()
-                
+
                 print(f"==================\nMethod: {method}\n------------------")
                 print(f"Depth: \t\t\t{compiled_qc.depth()}")
                 print(f"CNOT count: \t{compiled_qc.cnot_count()}")
                 print(f"Qubit count: \t{compiled_qc.num_qubits()}")
-    
-        
+
+
     >>> benchmark_mcx(4, methods = ["gray", "gray_pt", "maslov", "balauca", "yong"])
     ==================
     Method: gray
     ------------------
     Depth:          50
     CNOT count:     30
     Qubit count:    5
@@ -270,440 +297,465 @@
     CNOT count:     54
     Qubit count:    18
     ==================
     Method: yong
     ------------------
     Depth:          621
     CNOT count:     264
-    Qubit count:    12    
+    Qubit count:    12
 
     """
-    
+
     from qrisp.circuit.quantum_circuit import convert_to_qb_list
     from qrisp.misc import bin_rep
+
     qubits_0 = convert_to_qb_list(controls)
     qubits_1 = convert_to_qb_list(target)
-    
+
     n = len(qubits_0)
-    
+
     if n == 0:
         return controls, target
-    
+
     if not isinstance(ctrl_state, str):
         if ctrl_state == -1:
             ctrl_state += 2**n
         ctrl_state = bin_rep(ctrl_state, n)[::-1]
-        
+
     if len(ctrl_state) != n:
-        raise Exception(f"Given control state {ctrl_state} does not match control qubit amount {n}")
-    
-    from qrisp.circuit.multi_cx import maslov_mcx, balauca_mcx, yong_mcx, hybrid_mcx, balauca_dirty
-    
-    
+        raise Exception(
+            f"Given control state {ctrl_state} does not match control qubit amount {n}"
+        )
+
+    from qrisp.misc.multi_cx import (
+        balauca_dirty,
+        balauca_mcx,
+        hybrid_mcx,
+        maslov_mcx,
+        yong_mcx,
+    )
+
     if method in ["gray", "gray_pt", "gray_pt_inv"] or len(qubits_0) == 1:
         if len(qubits_0) == 1:
             method = "gray"
-        append_operation(std_ops.MCXGate(len(qubits_0), ctrl_state, method = method), qubits_0 + qubits_1)
-    
+        append_operation(
+            std_ops.MCXGate(len(qubits_0), ctrl_state, method=method),
+            qubits_0 + qubits_1,
+        )
+
     elif method == "maslov":
         from qrisp import QuantumBool
+
         if n >= 3:
-            ancilla = [QuantumBool(name = "maslov_anc_")]
+            ancilla = [QuantumBool(name="maslov_anc_")]
         else:
             ancilla = []
         append_operation(maslov_mcx(n, ctrl_state), qubits_0 + ancilla + qubits_1)
-        
+
         [qv.delete() for qv in ancilla]
-    
+
     elif method == "balauca":
-        
-        balauca_mcx(qubits_0, qubits_1, ctrl_state = ctrl_state)
-        
+        balauca_mcx(qubits_0, qubits_1, ctrl_state=ctrl_state)
+
     elif method == "balauca_dirty":
-        
-        balauca_dirty(qubits_0, qubits_1, k = num_ancilla, ctrl_state = ctrl_state)
-    
+        balauca_dirty(qubits_0, qubits_1, k=num_ancilla, ctrl_state=ctrl_state)
+
     elif method == "yong":
-        yong_mcx(qubits_0, qubits_1, ctrl_state = ctrl_state)
-        
+        yong_mcx(qubits_0, qubits_1, ctrl_state=ctrl_state)
+
     elif method == "hybrid":
-        hybrid_mcx(qubits_0, qubits_1, ctrl_state = ctrl_state, num_ancilla = num_ancilla)
-        
+        hybrid_mcx(qubits_0, qubits_1, ctrl_state=ctrl_state, num_ancilla=num_ancilla)
+
     elif method == "auto":
-        
         # if n <= 3:
         #     return mcx(qubits_0, qubits_1, method = "gray", ctrl_state = ctrl_state)
         # if 3 < n < 5:
         #     return mcx(qubits_0, qubits_1, method = "maslov", ctrl_state = ctrl_state)
         # else:
-        #     return mcx(qubits_0, qubits_1, method = "balauca", ctrl_state = ctrl_state)
+        #     return mcx(qubits_0, qubits_1, method = "balauca", ctrl_state = ctrl_state) # noqa:501
 
-        
-        gate = std_ops.MCXGate(len(qubits_0), ctrl_state, method = "auto")
+        gate = std_ops.MCXGate(len(qubits_0), ctrl_state, method="auto")
         append_operation(gate, qubits_0 + qubits_1)
-        
+
     return controls, target
-    
 
-def mcz(qubits, method = "auto", ctrl_state = -1, num_ancilla = 1):
+
+def mcz(qubits, method="auto", ctrl_state=-1, num_ancilla=1):
     """
     Applies a multi-controlled Z gate.
 
-    For more information on the available methods, check :meth:`the mcx documentation page <qrisp.mcx>`.
+    For more information on the available methods, check
+    :meth:`the mcx documentation page <qrisp.mcx>`.
 
     Parameters
     ----------
     qubits : QuantumVariable or list[Qubits]
         The Qubits to control on.
     method : str, optional
-        The synthesis method. Available are ``auto``, ``gray``, ``gray_pt``, ``gray_pt_inv``, ``maslov``, ``balauca``, ``yong`` and ``hybrid``. The default is ``auto``.
+        The synthesis method. Available are ``auto``, ``gray``, ``gray_pt``,
+        ``gray_pt_inv``, ``maslov``, ``balauca``, ``yong`` and ``hybrid``. The default
+        is ``auto``.
     ctrl_state : int or str, optional
-        The state on which to activate the Z gate. The default is "1111..".
+        The state on which to activate the Z gate. The default is "1111...".
     num_ancilla : int, optional
-        Specifies the amount of ancilla qubits to use. This parameter is used only if the method is set to ``hybrid``. The default is 1.
+        Specifies the amount of ancilla qubits to use. This parameter is used only if
+        the method is set to ``hybrid``. The default is 1.
 
     """
-    
-    from qrisp.misc import gate_wrap
 
+    from qrisp.misc import gate_wrap
 
-    @gate_wrap(permeability = "full", is_qfree = True, name = "anc supported mcz")
-    def mcz_inner(qubits, method = "auto", ctrl_state = -1):
-        
+    @gate_wrap(permeability="full", is_qfree=True, name="anc supported mcz")
+    def mcz_inner(qubits, method="auto", ctrl_state=-1):
         if len(ctrl_state) != n:
-            raise Exception(f"Given control state {ctrl_state} does not match control qubit amount {n}")
-        
-        from qrisp import x, h
-        
+            raise Exception(
+                f"Given control state {ctrl_state} does not match"
+                f"control qubit amount {n}"
+            )
+
+        from qrisp import h, x
+
         if ctrl_state[-1] == "0":
             x(qubits[-1])
-            
+
         h(qubits[-1])
-        mcx(qubits[:-1], qubits[-1], method = method, ctrl_state = ctrl_state[:-1])
+        mcx(qubits[:-1], qubits[-1], method=method, ctrl_state=ctrl_state[:-1])
         h(qubits[-1])
-        
+
         if ctrl_state[-1] == "0":
             x(qubits[-1])
-        
+
         return qubits
-    
-    
+
     n = len(qubits)
-    
+
     from qrisp import bin_rep
+
     if not isinstance(ctrl_state, str):
         if ctrl_state == -1:
             ctrl_state += 2**n
         ctrl_state = bin_rep(ctrl_state, n)
-    
-    
+
     if method in ["gray", "auto"]:
-        
         if ctrl_state[-1] == "0":
             x(qubits[-1])
-        
-        append_operation(std_ops.ZGate().control(len(qubits)-1, method = method, ctrl_state = ctrl_state[:-1]), qubits)
-        
+
+        append_operation(
+            std_ops.ZGate().control(
+                len(qubits) - 1, method=method, ctrl_state=ctrl_state[:-1]
+            ),
+            qubits,
+        )
+
         if ctrl_state[-1] == "0":
             x(qubits[-1])
-        
+
         return qubits
-    
+
     return mcz_inner(qubits, method, ctrl_state)
 
-def mcp(phi, qubits, method = "auto", ctrl_state = -1):
+
+def mcp(phi, qubits, method="auto", ctrl_state=-1):
     """
     Applies a multi-controlled phase gate.
-    
+
     The available methods are:
-        
+
     * ``gray`` , which performs a traversal of the gray code.
-    
-    * ``balauca`` , which is a modified version of the algorithm presented `here <https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf>`_.
-    
-    * ``auto`` , which picks ``gray`` for any qubit count less than 4 and ``balauca`` otherwise.
+
+    * ``balauca`` , which is a modified version of the algorithm presented `here
+      <https://www.iccs-meeting.org/archive/iccs2022/papers/133530169.pdf>`_.
+
+    * ``auto`` , which picks ``gray`` for any qubit count less than 4 and ``balauca``
+      otherwise.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The phase to apply.
     qubits : list[Qubit] or QuantumVariable
         The qubits to apply the multi-controlled phase gate on.
     method : str, optional
         The method to deploy. The default is "auto".
     ctrl_state : str or int, optional
         The control state on which to apply the phase. The default is "111...".
 
     """
-    
+
+    from qrisp.misc.multi_cx import balauca_mcx
     from qrisp.misc import bin_rep, gate_wrap
-    from qrisp.circuit.multi_cx import balauca_mcx
-    
-    @gate_wrap(permeability = "full", is_qfree = True, name = "anc supported mcp")
+
+    @gate_wrap(permeability="full", is_qfree=True, name="anc supported mcp")
     def balauca_mcp(phi, qubits, ctrl_state):
-        
         from qrisp.circuit.quantum_circuit import convert_to_qb_list
-        qubits  = convert_to_qb_list(qubits)
+
+        qubits = convert_to_qb_list(qubits)
         if ctrl_state[-1] == "0":
             x(qubits[-1])
-        
-        balauca_mcx(qubits[:-1], [qubits[-1]], ctrl_state = ctrl_state, phase = phi)
-        
+
+        balauca_mcx(qubits[:-1], [qubits[-1]], ctrl_state=ctrl_state, phase=phi)
+
         if ctrl_state[-1] == "0":
-            x(qubits[-1])    
-        
-    
+            x(qubits[-1])
+
     n = len(qubits)
-    
+
     if not isinstance(ctrl_state, str):
         if ctrl_state == -1:
             ctrl_state += 2**n
         ctrl_state = bin_rep(ctrl_state, n)[::-1]
-    
-    
+
     n = len(qubits)
-    
-    
+
     if method == "gray":
-        
         if ctrl_state[-1] == "0":
-            x(qubits[-1])    
-        
-        append_operation(std_ops.PGate(phi).control(n-1, ctrl_state = ctrl_state[:-1]), qubits)
-        
+            x(qubits[-1])
+
+        append_operation(
+            std_ops.PGate(phi).control(n - 1, ctrl_state=ctrl_state[:-1]), qubits
+        )
+
         if ctrl_state[-1] == "0":
             x(qubits[-1])
         return qubits
-        
+
     elif method == "balauca":
-        balauca_mcp(phi, qubits, ctrl_state = ctrl_state)
+        balauca_mcp(phi, qubits, ctrl_state=ctrl_state)
         return qubits
-        
+
     elif method == "auto":
         if n < 4:
-            return mcp(phi, qubits, method = "gray", ctrl_state = ctrl_state)
+            return mcp(phi, qubits, method="gray", ctrl_state=ctrl_state)
         else:
-            return mcp(phi, qubits, method = "balauca", ctrl_state = ctrl_state)
-        
+            return mcp(phi, qubits, method="balauca", ctrl_state=ctrl_state)
+
     else:
         raise Exception(f"Don't know method {method}")
-        
-    
-        
+
+
 def p(phi, qubits):
     """
     Applies a phase gate.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The phase to apply.
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit on which to apply the phase gate.
 
     """
-    
+
     append_operation(std_ops.PGate(phi), [qubits])
-    
+
     # std_ops.PGate(phi).append([qubits])
-    
+
     return qubits
-    
+
+
 def cp(phi, qubits_0, qubits_1):
     """
     Applies a controlled phase gate.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The phase to apply.
     qubits_0 : Qubit or list[Qubit] or QuantumVariable
         The first Qubit.
     qubits_1 : Qubit or list[Qubit] or QuantumVariable
         The second Qubit.
 
     """
-    
+
     append_operation(std_ops.CPGate(phi), [qubits_0, qubits_1])
-    
+
     # std_ops.CPGate(phi).append([qubits_0, qubits_1])
-    
+
     return qubits_0, qubits_1
 
+
 def rx(phi, qubits):
     """
     Applies an RX gate.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The angle parameter.
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the RX gate on.
 
     """
-    
+
     append_operation(std_ops.RXGate(phi), [qubits])
-    
+
     # std_ops.RXGate(phi).append([qubits])
-    
+
     return qubits
 
+
 def ry(phi, qubits):
     """
     Applies an RY gate.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The angle parameter.
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the RY gate on.
 
     """
-    
+
     append_operation(std_ops.RYGate(phi), [qubits])
-    
+
     # std_ops.RYGate(phi).append([qubits])
-    
+
     return qubits
 
+
 def rz(phi, qubits):
     """
     Applies an RY gate.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The angle parameter.
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the RY gate on.
 
     """
-    
+
     append_operation(std_ops.RZGate(phi), [qubits])
-    
+
     # std_ops.RZGate(phi).append([qubits])
-    
+
     return qubits
 
+
 def crz(phi, qubits_0, qubits_1):
     """
     Applies controled RZ gate
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The angle parameter.
     qubits_0 : Qubit or list[Qubit] or QuantumVariable
         The first Qubit.
     qubits_1 : Qubit or list[Qubit] or QuantumVariable
         The second Qubit.
 
     """
-    
+
     append_operation(std_ops.RZGate(phi).control(1), [qubits_0, qubits_1])
     return qubits_0, qubits_1
-    
+
 
 def s(qubits):
     """
     Applies an S gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the S gate on.
     """
-    
+
     append_operation(std_ops.SGate(), [qubits])
     return qubits
 
+
 def t(qubits):
     """
     Applies a T gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the T gate on.
     """
     append_operation(std_ops.TGate(), [qubits])
     return qubits
 
+
 def s_dg(qubits):
     """
     Applies a daggered S gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the daggered S gate on.
     """
-    
+
     append_operation(std_ops.SGate().inverse(), [qubits])
     return qubits
-    
+
 
 def t_dg(phi, qubits):
     """
     Applies a daggered T gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the daggered T gate on.
     """
     append_operation(std_ops.TGate().inverse(), [qubits])
     return qubits
 
+
 def sx(qubits):
     """
     Applies an SX gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the SX gate on.
     """
-    
+
     append_operation(std_ops.SXGate().inverse(), [qubits])
-    
+
     return qubits
 
 
 def sx_dg(qubits):
     """
     Applies a daggered SX gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the daggered SX gate on.
     """
     append_operation(std_ops.SXDGGate().inverse(), [qubits])
     return qubits
-    
+
 
 def gphase(phi, qubits):
     """
     Applies a global phase. This gate turns into a phase gate when controlled.
 
     Parameters
     ----------
     phi : float or sympy.Symbol
         The global phase to apply.
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to perform the global phase gate on.
     """
-    
+
     append_operation(std_ops.GPhaseGate(phi), qubits)
     return qubits
 
-def measure(qubits, clbits = None):
+
+def measure(qubits, clbits=None):
     """
     Performs a measurement of the specified Qubit.
 
     Parameters
     ----------
     qubit : Qubit or list[Qubit] or QuantumVariable
         The Qubit to measure.
@@ -715,34 +767,34 @@
         clbits = []
         if hasattr(qubits, "__len__"):
             for qb in qubits:
                 try:
                     clbits.append(qubits[0].qs.add_clbit())
                 except AttributeError:
                     clbits.append(qubits[0].qs().add_clbit())
-                    
+
         else:
             clbits = qubits.qs.add_clbit()
     append_operation(std_ops.Measurement(), [qubits], [clbits])
-    
+
     return qubits
 
 
 def barrier(qubits):
     """
     A visual marker for structuring the QuantumCircuit.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The Qubit to apply the barrier to.
 
     Examples
     --------
-    
+
     >>> from qrisp import QuantumVariable, x, y, barrier
     >>> qv = QuantumVariable(5)
     >>> x(qv)
     >>> barrier(qv)
     >>> y(qv)
     >>> print(qv.qs)
     QuantumCircuit:
@@ -759,147 +811,181 @@
     qv.4: ┤ X ├─░─┤ Y ├
           └───┘ ░ └───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable qv
 
     """
-    
+
     append_operation(std_ops.Barrier(len(qubits)), qubits)
-    
+
     return qubits
-    
+
 
 def swap(qubits_0, qubits_1):
     """
     Applies a SWAP gate.
 
     Parameters
     ----------
     qubits_0 : Qubit or list[Qubit] or QuantumVariable
         The first Qubit.
     qubits_1 : Qubit or list[Qubit] or QuantumVariable
         The second Qubit.
 
     """
     append_operation(std_ops.SwapGate(), [qubits_0, qubits_1])
-    
+
     return qubits_0, qubits_1
 
 
 def id(qubits):
     """
     Applies an ID gate.
 
     Parameters
     ----------
     qubits : Qubit or list[Qubit] or QuantumVariable
         The qubits to perform the ID gate on.
 
     """
     append_operation(std_ops.IDGate(), [qubits])
-    
+
     return qubits
-    
-def QFT_inner(qv, exec_swap = True, qiskit_endian = True, inplace_mult = 1, use_gms = False):
-    
-    
+
+
+def QFT_inner(qv, exec_swap=True, qiskit_endian=True, inplace_mult=1, use_gms=False):
     from qrisp.misc import is_inv
+
     qv = list(qv)
     n = len(qv)
-    
+
     if qiskit_endian:
         qv = qv[::-1]
-    
+
     if not use_gms:
         from qrisp.environments.quantum_environments import QuantumEnvironment
+
         env = QuantumEnvironment
-    
+
     else:
         from qrisp.environments.GMS_environment import GMSEnvironment
+
         env = GMSEnvironment
-        
+
     if not is_inv(inplace_mult, n):
-        raise Exception("Tried to perform non-invertible inplace multiplication during Fourier-Transform")
-    
+        raise Exception(
+            "Tried to perform non-invertible inplace multiplication"
+            "during Fourier-Transform"
+        )
+
     for i in range(n):
         h(qv[i])
-        
-        if i == n-1:
+
+        if i == n - 1:
             break
-        
+
         with env():
-            for k in range(n-i-1):
-                cp(inplace_mult*2*np.pi/2**(k+2), qv[k+i+1], qv[i])
-        
+            for k in range(n - i - 1):
+                cp(inplace_mult * 2 * np.pi / 2 ** (k + 2), qv[k + i + 1], qv[i])
+
     if exec_swap:
-        for i in range(n//2):
-            swap(qv[i], qv[n-i-1])
-    
+        for i in range(n // 2):
+            swap(qv[i], qv[n - i - 1])
+
     return qv
 
 
-def QFT(qv, inv = False, exec_swap = True, qiskit_endian = True, inplace_mult = 1, use_gms = False):
+def QFT(
+    qv, inv=False, exec_swap=True, qiskit_endian=True, inplace_mult=1, use_gms=False
+):
     """
     Performs the quantum fourier transform on the input.
 
     Parameters
     ----------
     qv : QuantumVariable
         QuantumVariable to transform (in-place).
     inv : bool, optional
         If set to True, the inverse transform will be applied. The default is False.
     exec_swap : bool, optional
-        If set to False, the swaps at the end of the transformation will be skipped. The default is True.
+        If set to False, the swaps at the end of the transformation will be skipped.
+        The default is True.
     qiskit_endian : bool, optional
         If set to False the order of bits will be reversed. The default is True.
     inplace_mult : int, optional
-        Allows multiplying the QuantumVariable with an extra factor during the transformation. For more information check `our publication <https://ieeexplore.ieee.org/document/9815035>`_. The default is 1.
+        Allows multiplying the QuantumVariable with an extra factor during the
+        transformation. For more information check `the publication
+        <https://ieeexplore.ieee.org/document/9815035>`_. The default is 1.
     use_gms : bool, optional
-        If set to True, the QFT will be compiled using only GMS gates as entanglers. The default is False.
+        If set to True, the QFT will be compiled using only GMS gates as entangling
+        gates. The default is False.
+
 
-    
     """
     from qrisp import gate_wrap, invert
-    
+
     name = "QFT"
     if not exec_swap:
         name += " no swap"
     if inplace_mult != 1:
         name += " inpl mult " + str(inplace_mult)
-        
+
     if inv:
-        with invert():        
-            gate_wrap(permeability = [], is_qfree = False, name = name)(QFT_inner)(qv, exec_swap = exec_swap, qiskit_endian = qiskit_endian, inplace_mult = inplace_mult, use_gms = use_gms)
+        with invert():
+            gate_wrap(permeability=[], is_qfree=False, name=name)(QFT_inner)(
+                qv,
+                exec_swap=exec_swap,
+                qiskit_endian=qiskit_endian,
+                inplace_mult=inplace_mult,
+                use_gms=use_gms,
+            )
     else:
-        gate_wrap(permeability = [], is_qfree = False, name = name)(QFT_inner)(qv, exec_swap = exec_swap, qiskit_endian = qiskit_endian, inplace_mult = inplace_mult, use_gms = use_gms)
-        
+        gate_wrap(permeability=[], is_qfree=False, name=name)(QFT_inner)(
+            qv,
+            exec_swap=exec_swap,
+            qiskit_endian=qiskit_endian,
+            inplace_mult=inplace_mult,
+            use_gms=use_gms,
+        )
+
     return qv
 
 
-def QPE(args, U, precision = None, target = None, iter_spec = False, ctrl_method = None, kwargs = {}):
-    """
-    Evaluates the `quantum phase estimation algorithm <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`_.
-    
-    The unitary to estimate is expected to be given as Python function, which is called on ``args``.
+def QPE(
+    args, U, precision=None, target=None, iter_spec=False, ctrl_method=None, kwargs={}
+):
+    r"""
+    Evaluates the `quantum phase estimation algorithm
+    <https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm>`_.
+
+    The unitary to estimate is expected to be given as Python function, which is called
+    on ``args``.
 
     Parameters
     ----------
     args : list
-        A list of arguments (could be QuantumVariables) which represent the state, the quantum phase estimation is performed on.
+        A list of arguments (could be QuantumVariables) which represent the state,
+        the quantum phase estimation is performed on.
     U : function
-        A Python function, which will receive the list ``args`` as arguments in the course of this algorithm.
+        A Python function, which will receive the list ``args`` as arguments in the
+        course of this algorithm.
     precision : int, optional
         The precision of the estimation. The default is None.
     target : QuantumFloat, optional
-        A target QuantumFloat to perform the estimation into. The default is None. If given neither a precision nor a target, an Exception will be raised.
+        A target QuantumFloat to perform the estimation into. The default is None.
+        If given neither a precision nor a target, an Exception will be raised.
     iter_spec : bool, optional
-        If set to ``True``, ``U`` will be called with the additional keyword ``iter = i`` where ``i`` is the amount of iterations to perform (instead of simply calling ``U`` for ``i`` times. The default is False.
+        If set to ``True``, ``U`` will be called with the additional keyword
+        ``iter = i`` where ``i`` is the amount of iterations to perform (instead of
+        simply calling ``U`` for ``i`` times). The default is False.
     ctrl_method : string, optional
-        Allows to specify which method should be used to generate the controlled U circuit. For more information check :meth:`.control <qrisp.Operation.control>`. The default is None.
+        Allows to specify which method should be used to generate the
+        controlled U circuit. For more information check
+        :meth:`.control <qrisp.Operation.control>`. The default is None.
     kwargs : dict, optional
         A dictionary of keyword arguments to pass to ``U``. The default is {}.
 
     Raises
     ------
     Exception
         Tried to perform quantum phase estimation without precision specification.
@@ -907,90 +993,96 @@
     Returns
     -------
     res : QuantumFloat
         The QuantumFloat containing the estimated phase as a fraction of $2 \pi$.
 
     Examples
     --------
-    
-    We define a function that applies two phase gates onto its input and estimate the applied phase. ::
-        
+
+    We define a function that applies two phase gates onto its input and estimate the
+    applied phase. ::
+
         from qrisp import p, QuantumVariable, QPE, multi_measurement
 
         def U(qv):
             x = 0.5
             y = 0.125
-            
+
             p(x*2*np.pi, qv[0])
             p(y*2*np.pi, qv[1])
-        
+
         qv = QuantumVariable(2)
 
         h(qv)
-        
+
         res = QPE(qv, U, precision = 3)
 
     >>> multi_measurement([qv, res])
     {('00', 0.0): 0.25,
      ('10', 0.5): 0.25,
      ('01', 0.125): 0.25,
      ('11', 0.625): 0.25}
     >>> res.qs.depth()
-    66        
-    
-    During the phase estimation, ``U`` is called $2^{\\text{precision}}$ times. We can reduce that number by abusing that we can bundle repeated calls into a single call with a modified phase. ::
+    66
+
+    During the phase estimation, ``U`` is called $2^{\\text{precision}}$ times. We can
+    reduce that number by abusing that we can bundle repeated calls into a single call
+    with a modified phase. ::
 
         def U(qv, iter = None):
             x = 0.5
             y = 0.125
-            
+
             p(x*2*np.pi*iter, qv[0])
             p(y*2*np.pi*iter, qv[1])
-            
+
         qv = QuantumVariable(2)
 
         h(qv)
-        
-        res = QPE(qv, U, precision = 3, iter_spec = True)    
-    
+
+        res = QPE(qv, U, precision = 3, iter_spec = True)
+
     >>> multi_measurement([qv, res])
     {('00', 0.0): 0.25,
      ('10', 0.5): 0.25,
      ('01', 0.125): 0.25,
-     ('11', 0.625): 0.25}    
+     ('11', 0.625): 0.25}
     >>> res.qs.depth()
     34
-    
+
     """
-    
+
     from qrisp import QuantumFloat, control
-    
+
     if target is None:
-        if precision == None:
-            raise Exception("Tried to perform quantum phase estimation without precision specification")
+        if precision is None:
+            raise Exception(
+                "Tried to perform quantum phase estimation without"
+                "precision specification"
+            )
         res = QuantumFloat(precision, -precision, signed=False)
     else:
         res = target
-    
-    h(res)
 
+    h(res)
 
     for i in range(res.size):
         if iter_spec:
-            with control(res[i], ctrl_method = ctrl_method):
-                U(args, iter = 2**i, **kwargs)
+            with control(res[i], ctrl_method=ctrl_method):
+                U(args, iter=2**i, **kwargs)
         else:
-            with control(res[i], ctrl_method = ctrl_method):
-                for j in range(2 ** i):
-                        U(args, **kwargs)
-                    
+            with control(res[i], ctrl_method=ctrl_method):
+                for j in range(2**i):
+                    U(args, **kwargs)
+
     QFT(res, inv=True)
-    
+
     return res
 
+
 def quantum_counting(qv, oracle, precision):
     """
     This algorithm estimates the amount of solutions for a given Grover oracle.
 
     Parameters
     ----------
     qv : QuantumVariable
@@ -1000,59 +1092,59 @@
     precision : int
         The precision to perform the quantum phase estimation with.
 
     Returns
     -------
     M : float
         An estimate of the amount of solutions.
-        
+
     Examples
     --------
-    
+
     We create an oracle, which performs a simple phase flip on the last qubit. ::
-        
+
         from qrisp import quantum_counting, z, QuantumVariable
-        
+
         def oracle(qv):
             z(qv[-1])
-            
-    
+
+
     We expect half of the state-space of the input to be a solution.
-    
+
     For 3 qubits, the state space is $2^3 = 8$ dimensional.
-    
+
     >>> quantum_counting(QuantumVariable(3), oracle, 3)
     3.999999999999999
-    
+
     For 4 qubits, the state space is $2^4 = 16$ dimensional.
-    
+
     >>> quantum_counting(QuantumVariable(4), oracle, 3)
     7.999999999999998
-    
+
 
     """
-    
-    from qrisp.grover import diffuser
+
     from qrisp import gate_wrap
-    
+    from qrisp.grover import diffuser
+
     @gate_wrap
     def grover_operator(qv):
         oracle(qv)
         diffuser(qv)
-    
+
     h(qv)
-    res = QPE(qv, grover_operator, precision = precision)
-    
+    res = QPE(qv, grover_operator, precision=precision)
+
     mes_res = res.get_measurement()
 
-    theta = min(list(mes_res.keys())[:1])*2*np.pi
+    theta = min(list(mes_res.keys())[:1]) * 2 * np.pi
 
     N = 2**qv.size
-    M = N*np.sin(theta/2)**2
-    
+    M = N * np.sin(theta / 2) ** 2
+
     return M
 
 
 def HHL(qv, hamiltonian_evolution, ev_inversion, precision):
     """
     Evaluates the HHL algorithm.
 
@@ -1070,182 +1162,215 @@
     Returns
     -------
     ancilla : TYPE
         DESCRIPTION.
 
     """
     from qrisp import QuantumBool, invert
-    
+
     # Perform quantum phase estimation
     res = QPE(qv, hamiltonian_evolution, precision)
-    
+
     ancilla = QuantumBool()
-    
+
     ev_inversion(res, ancilla)
 
     # Perform quantum phase estimation inverse
     with invert():
-        QPE(qv, hamiltonian_evolution, target = res)
-    
+        QPE(qv, hamiltonian_evolution, target=res)
+
     res.delete()
-    
+
     return ancilla
 
-def fredkin_qc(num_ctrl_qubits = 1, ctrl_state = -1, method = "gray"):
-    from qrisp import XGate, QuantumCircuit
-    
-    mcx_gate = XGate().control().control(ctrl_state = ctrl_state, method = method)
-    
+
+def fredkin_qc(num_ctrl_qubits=1, ctrl_state=-1, method="gray"):
+    from qrisp import QuantumCircuit, XGate
+
+    mcx_gate = XGate().control().control(ctrl_state=ctrl_state, method=method)
+
     qc = QuantumCircuit(num_ctrl_qubits + 2)
     qc.cx(-1, -2)
     qc.append(mcx_gate, qc.qubits)
     qc.cx(-1, -2)
-    
+
     return qc
 
 
-def demux(input, ctrl_qv, output = None, ctrl_method = None, permit_mismatching_size = False):
+def demux(input, ctrl_qv, output=None, ctrl_method=None, permit_mismatching_size=False):
     """
-    This functions allows moving an input value into an iterable output, where the position is specified by a ``QuantumFloat``.
-    Demux is short for demultiplexer and is a standard component in `classical electrical circuitry <https://en.wikipedia.org/wiki/Multiplexer>`_.
-    
-    Demux can either move qubit states into a QuantumVariable or ``QuantumVariables`` into ``QuantumArrays``.
-    
-    This function can also be used to "in-place demux" the 0-th entry of an iterable to the position specified by ``ctrl_qv``. For more information on this, check the second example.
+    This functions allows moving an input value into an iterable output, where the
+    position is specified by a ``QuantumFloat``. Demux is short for demultiplexer and
+    is a standard component in `classical electrical circuitry
+    <https://en.wikipedia.org/wiki/Multiplexer>`_.
+
+    Demux can either move qubit states into a QuantumVariable or ``QuantumVariables``
+    into ``QuantumArrays``.
+
+    This function can also be used to "in-place demux" the 0-th entry of an iterable to
+    the position specified by ``ctrl_qv``. For more information on this, check the
+    second example.
 
     Parameters
     ----------
     input : Qubit or QuantumVariable
         The input value that is supposed to be moved.
     ctrl_qv : QuantumFloat
-        The QuantumFloat specifying to which output the input should be moved..
+        The QuantumFloat specifying to which output the input should be moved.
     output : QuantumVariable or QuantumArray, optional
-        The output object, where the input should end up. By default, a new object (QuantumVariable or QuantumArray) is created. Note that when this parameter is given, it is guaranteed, that the 0-th entry will be moved to the desired position, the other entries can also be permuted away from their original position.
+        The output object, where the input should end up. By default, a new object
+        (QuantumVariable or QuantumArray) is created. Note that when this parameter is
+        given, it is guaranteed, that the 0-th entry will be moved to the desired
+        position, the other entries can also be permuted away from their original
+        position.
     ctrl_method : string, optional
-        The ``ctrl_method`` string passed to the :ref:`control environment <ControlEnvironment>` to generate controlled swaps.
+        The ``ctrl_method`` string passed to the
+        :ref:`control environment <ControlEnvironment>` to generate controlled swaps.
     permit_mismatching_size : bool, optional
-        If set to False, an exception will be raised, if the state-space dimension of ``ctrl_qv`` is differing from the amount of outputs. The default is False.
+        If set to False, an exception will be raised, if the state-space dimension of
+        `ctrl_qv`` is differing from the amount of outputs. The default is False.
 
     Raises
     ------
     Exception
         Tried to demux with mismatchingly sized control input.
 
     Returns
     -------
     output : QuantumVariable or QuantumArray
-        The output object with the input signal placed at the index specified by ``ctrl_qv``.
+        The output object with the input signal placed at the index specified by
+        ``ctrl_qv``.
 
     Examples
     --------
-    
+
     We create a ``QuantumBool`` and demux it into a ``QuantumArray`` ::
-        
+
         from qrisp import *
-        
+
         qb = QuantumBool()
         qb.flip()
-        
+
         index = QuantumFloat(2)
-        
+
         h(index[1])
-        
+
         res_array = demux(qb, index)
-    
+
     >>> print(multi_measurement([index, res_array]))
     {(0, OutcomeArray([1., 0., 0., 0.])): 0.5, (2, OutcomeArray([0., 0., 1., 0.])): 0.5}
-    
+
     Demux can also be used to move the 0-th entry of a ``QuantumArray`` in-place. ::
-        
+
         qa = QuantumArray(shape = 4, qtype = qb)
-        
+
         qa[0].flip()
-        
+
         demux(qa[0], index, qa)
-        
+
     >>> print(multi_measurement([index, qa]))
     {(0, OutcomeArray([1., 0., 0., 0.])): 0.5, (2, OutcomeArray([0., 0., 1., 0.])): 0.5}
-    
-    For low-level manipulations, demux can move information within ``QuantumVariables``. ::
-    
+
+    For low-level manipulations, demux can move information within ``QuantumVariables``.
+    ::
+
         qf = QuantumVariable(4)
-        
+
         qf[:] = "1000"
-        
+
         demux(qf[0], index, qf)
-        
+
     >>> print(multi_measurement([index, qf]))
     {(0, '1000'): 0.5, (2, '0010'): 0.5}
     """
-    
-    from qrisp import control, swap, QuantumArray, QuantumVariable, Qubit
-    
-    
+
+    from qrisp import QuantumArray, QuantumVariable, Qubit, control, swap
+
     if output is None:
         if isinstance(input, QuantumVariable):
-            output = QuantumArray(input, 2**len(ctrl_qv))
+            output = QuantumArray(input, 2 ** len(ctrl_qv))
         elif isinstance(input, Qubit):
-            output = QuantumVariable(2**len(ctrl_qv))
+            output = QuantumVariable(2 ** len(ctrl_qv))
         else:
             raise Exception("Don't know how to handle input type " + str(type(input)))
     else:
-        
         if isinstance(output, QuantumArray):
             for qv in output.flatten()[1:]:
                 if qv.name == input.name:
-                    raise Exception("Tried to in-place demux QuantumArry entry, which is not a 0-th position")
+                    raise Exception(
+                        "Tried to in-place demux QuantumArray entry,"
+                        "which is not a 0-th position"
+                    )
         elif isinstance(output, QuantumVariable):
             for qb in output.reg[1:]:
                 if qb.identifier == input.identifier:
-                    raise Exception("Tried to in-place demux QuantumVariable entry, which is not a 0-th position")
-                    
-    
+                    raise Exception(
+                        "Tried to in-place demux QuantumVariable entry,"
+                        "which is not a 0-th position"
+                    )
+
     n = int(np.ceil(np.log2(len(output))))
     N = 2**n
-    
-    
-    if len(output) != 2**len(ctrl_qv) and not permit_mismatching_size:
-        raise Exception("Tried to demux with mismatchingly sized control input")
-    
+
+    if len(output) != 2 ** len(ctrl_qv) and not permit_mismatching_size:
+        raise Exception("Tried to demux with mismatching sized control input")
+
     if hash(input) != hash(output[0]):
         swap(input, output[0])
-    
+
     if not len(ctrl_qv):
         return output
-    
-    if len(output) > 2**(len(ctrl_qv) -1):
-        
-        with control(ctrl_qv[-1], ctrl_method = ctrl_method):
-            swap(output[0], output[N//2])
+
+    if len(output) > 2 ** (len(ctrl_qv) - 1):
+        with control(ctrl_qv[-1], ctrl_method=ctrl_method):
+            swap(output[0], output[N // 2])
     else:
-        demux(output[0], ctrl_qv[:-1], output, ctrl_method = ctrl_method, permit_mismatching_size = permit_mismatching_size)
+        demux(
+            output[0],
+            ctrl_qv[:-1],
+            output,
+            ctrl_method=ctrl_method,
+            permit_mismatching_size=permit_mismatching_size,
+        )
         return output
-    
+
     if n > 1:
-        demux(output[0], ctrl_qv[:-1], output[:N//2], ctrl_method = ctrl_method, permit_mismatching_size = permit_mismatching_size)
-        demux(output[N//2], ctrl_qv[:-1], output[N//2:], ctrl_method = ctrl_method, permit_mismatching_size = permit_mismatching_size)
-    
+        demux(
+            output[0],
+            ctrl_qv[:-1],
+            output[: N // 2],
+            ctrl_method=ctrl_method,
+            permit_mismatching_size=permit_mismatching_size,
+        )
+        demux(
+            output[N // 2],
+            ctrl_qv[:-1],
+            output[N // 2 :],
+            ctrl_method=ctrl_method,
+            permit_mismatching_size=permit_mismatching_size,
+        )
+
     return output
 
+
 def q_indexing(q_array, index):
     from qrisp import invert
-    
+
     with invert():
-        demux(q_array[0], index, q_array, ctrl_method = "gray_pt")
-    
-    res = q_array[0].duplicate(init = True)
-    
-    demux(q_array[0], index, q_array, ctrl_method = "gray_pt")
-    
+        demux(q_array[0], index, q_array, ctrl_method="gray_pt")
+
+    res = q_array[0].duplicate(init=True)
+
+    demux(q_array[0], index, q_array, ctrl_method="gray_pt")
+
     return res
 
 
 def q_swap_into(q_array, index, qv):
-    
     from qrisp import invert, swap
-    
+
     with invert():
-        demux(q_array[0], index, q_array, ctrl_method = "gray_pt")
-    
+        demux(q_array[0], index, q_array, ctrl_method="gray_pt")
+
     swap(q_array[0], qv)
-    
-    demux(q_array[0], index, q_array, ctrl_method = "gray_pt")
+
+    demux(q_array[0], index, q_array, ctrl_method="gray_pt")
```

### Comparing `qrisp-0.0.15/src/qrisp/core/quantum_array.py` & `qrisp-0.0.16/src/qrisp/core/quantum_array.py`

 * *Files 10% similar despite different names*

```diff
@@ -8,283 +8,300 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 from itertools import product
-import copy
-from qrisp.core import QuantumVariable
-from qrisp.misc import bin_rep, int_encoder
-from qrisp.circuit import transpile
-
 
 import numpy as np
 
+from qrisp.circuit import transpile
+from qrisp.core import QuantumVariable
+from qrisp.misc import bin_rep
+from qrisp.environments.temp_var_environment import temp_qv
+
 
 class QuantumArray(np.ndarray):
     """
-    This class allows the convenient management of multiple QuantumVariables of one type. As a subclass of `numpy's ndarray <https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html>`_, the QuantumArray supports many convenient array manipulation methods.
-    Similar to the numpy equivalent, creating a QuantumArray can be achieved by specifying a shape and a ``qtype``:
-    
+    This class allows the convenient management of multiple QuantumVariables of one
+    type. As a subclass of `numpy's ndarray
+    <https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html>`_, the
+    QuantumArray supports many convenient array manipulation methods. Similar to the
+    numpy equivalent, creating a QuantumArray can be achieved by specifying a shape and
+    a ``qtype``:
+
     >>> import numpy as np
     >>> from qrisp import QuantumArray, QuantumFloat
     >>> qtype = QuantumFloat(5, -2)
     >>> q_array = QuantumArray(qtype = qtype, shape = (2, 2, 2))
-    
-    Note that ``qtype`` is not a type object but a QuantumVariable which serves as an "example".
-    
-    To retrieve the entries (ie. QuantumVariables) from the QuantumArray, we simply index as with regular numpy arrays:
-    
+
+    Note that ``qtype`` is not a type object but a QuantumVariable which serves as an
+    "example".
+
+    To retrieve the entries (i.e. QuantumVariables) from the QuantumArray, we simply
+    index as with regular numpy arrays:
+
     >>> from qrisp import h
     >>> qv = q_array[0,0,1]
     >>> h(qv[0])
     >>> print(q_array)
     {OutcomeArray([[[0., 0.],
                     [0., 0.]],
                    [[0., 0.],
-                    [0., 0.]]]): 0.5, 
+                    [0., 0.]]]): 0.5,
      OutcomeArray([[[0.  , 0.25],
                     [0.  , 0.  ]],
                    [[0.  , 0.  ],
                     [0.  , 0.  ]]]): 0.5}
-    
-    We see the value 0.25 in the second entry because we applied an H-gate onto the 0-th qubit of the QuantumVariable at position (0,0,1). Since the type of this array is a QuantumFloat, with exponent -2, the significance of this qubit is 0.25.
-    
-    Note that the keys of the dictionary returned by the get_measurement method are no regular numpy arrays, as key objects need to be hashable. Instead they are objects of an immutable subclass of np.ndarray called OutcomeArray, that supports hashing.
-    
+
+    We see the value 0.25 in the second entry because we applied an H-gate onto the 0-th
+    qubit of the QuantumVariable at position (0,0,1). Since the type of this array is a
+    QuantumFloat, with exponent -2, the significance of this qubit is 0.25.
+
+    Note that the keys of the dictionary returned by the get_measurement method are no
+    regular numpy arrays, as key objects need to be hashable. Instead, they are objects
+    of an immutable subclass of np.ndarray called OutcomeArray, that supports hashing.
+
     For QuantumArrays, many methods known from numpy arrays work here too:
-    
+
     >>> q_array = q_array.reshape(2,4)
-    
-    Not only do the ndarray methods work but also many other convenience functions from the numpy module:
-        
+
+    Not only do the ndarray methods work but also many other convenience functions from
+    the numpy module:
+
     >>> q_array_swap = np.swapaxes(q_array, 0, 1)
     >>> print(q_array_swap)
     {OutcomeArray([[0., 0.],
                    [0., 0.],
                    [0., 0.],
-                   [0., 0.]]): 0.5, 
+                   [0., 0.]]): 0.5,
      OutcomeArray([[0.  , 0.  ],
                    [0.25, 0.  ],
                    [0.  , 0.  ],
                    [0.  , 0.  ]]): 0.5}
-    
-    To initiate the array, we use the :meth:`encode <qrisp.QuantumArray.encode>` method. Similar to QuantumVariables, we can also use the slicing operator, but this time non-trivial slices are possible as well:
-    
+
+    To initiate the array, we use the :meth:`encode <qrisp.QuantumArray.encode>` method.
+    Similar to QuantumVariables, we can also use the slicing operator, but this time
+    non-trivial slices are possible as well:
+
     >>> q_array[1:,:] = 2*np.ones((1,4))
     >>> print(q_array)
     {OutcomeArray([[0., 0., 0., 0.],
                    [2., 2., 2., 2.]]): 0.5,
      OutcomeArray([[0.  , 0.25, 0.  , 0.  ],
                    [2.  , 2.  , 2.  , 2.  ]]): 0.5}
-    
 
-    The shape of a QuantumArray does not have to be specified at creation. We can either set it through the :meth:`set_shape <qrisp.QuantumArray.set_shape>` method or by initiating:
-    
+
+    The shape of a QuantumArray does not have to be specified at creation. We can either
+    set it through the :meth:`set_shape <qrisp.QuantumArray.set_shape>` method or by
+    initiating:
+
     >>> q_array_1 = QuantumArray(qtype = qtype)
     >>> q_array_1.set_shape((2,2))
     >>> print(q_array_1)
     {OutcomeArray([[0., 0.],
                    [0., 0.]]): 1.0}
     >>> q_array_2 = QuantumArray(qtype = qtype)
     >>> q_array_2[:] = np.eye(2)
     >>> print(q_array_2)
     {OutcomeArray([[1., 0.],
                    [0., 1.]]): 1.0}
-    
+
     **Quantum indexing**
-    
-    QuantumArrays can be dereferenced by :ref:`QuantumFloats <QuantumFloat>`. This returns a :ref:`QuantumEnvironment` in which the corresponding entry is avaliable as a QuantumVariable. ::
-        
+
+    QuantumArrays can be dereferenced by :ref:`QuantumFloats <QuantumFloat>`. This
+    returns a :ref:`QuantumEnvironment` in which the corresponding entry is avaliable as
+    a QuantumVariable. ::
+
         from qrisp import QuantumBool, QuantumArray, QuantumFloat, h, multi_measurement
-    
+
         q_array = QuantumArray(QuantumBool(), shape = (4,4))
         index_0 = QuantumFloat(2)
         index_1 = QuantumFloat(2)
-    
-    
+
+
         index_0[:] = 2
         index_1[:] = 1
-    
+
         h(index_0[0])
-    
+
         with q_array[index_0, index_1] as entry:
             entry.flip()
-    
+
     >>> print(multi_measurement([index_0, index_1, q_array]))
     {(2, 1, OutcomeArray([[0., 0., 0., 0.],
                           [0., 0., 0., 0.],
                           [0., 1., 0., 0.],
-                          [0., 0., 0., 0.]])): 0.5, 
+                          [0., 0., 0., 0.]])): 0.5,
      (3, 1, OutcomeArray([[0., 0., 0., 0.],
                           [0., 0., 0., 0.],
                           [0., 0., 0., 0.],
                           [0., 1., 0., 0.]])): 0.5}
-    
+
     .. note::
         This only works for arrays which have a size of an integer power of 2.
-    
+
     **Matrix multiplication**
-    
+
     For QuantumArrays with ``qtype`` QuantumFloat, matrix multiplication is available.
-    
+
     >>> q_array_1 = QuantumArray(qtype)
     >>> q_array_2 = QuantumArray(qtype)
     >>> q_array_1[:] = 2*np.eye(2)
     >>> q_array_2[:] = [[1,2],[3,4]]
     >>> print(q_array_1 @ q_array_2)
     {OutcomeArray([[2., 4.],
                    [6., 0.]]): 1.0}
-    
+
     .. note::
-        By default, the output matrix will have the same ``qtype`` as the first input matrix. Here, the ``qtype`` is a QuantumFloat with 5 mantissa bits and exponent -2, implying that the result 8 yields overflow. Since qrisps unsigend arithmetic is modular, we get a 0.
-    
+        By default, the output matrix will have the same ``qtype`` as the first input
+        matrix. Here, the ``qtype`` is a QuantumFloat with 5 mantissa bits and exponent
+        -2, implying that the result 8 yields overflow. Since qrisps unsigend arithmetic
+        is modular, we get a 0.
+
     It is also possible to multiply classical and quantum matrices
-    
+
     >>> q_array = QuantumArray(qtype)
     >>> q_array[:] = 3*np.eye(2)
     >>> cl_array = np.array([[1,2],[3,4]])
     >>> print(q_array @ cl_array)
     {OutcomeArray([[3., 6.],
                    [1., 4.]]): 1.0}
     """
-    
-    def __new__(subtype, qtype, shape = 0, qs = None, name = None):
-        
+
+    def __new__(subtype, qtype, shape=0, qs=None, name=None):
         if isinstance(shape, QuantumVariable):
             raise Exception
-        
-        obj = super().__new__(subtype, shape, dtype = "object")
-        
+
+        obj = super().__new__(subtype, shape, dtype="object")
+
         if shape == 0:
             obj.shape_specified = False
         else:
             obj.shape_specified = True
-        
-        
+
         from qrisp.misc import find_calling_line
-        
-        
+
         if name is None:
-            
             if type(obj) is QuantumArray:
                 line = find_calling_line(1)
             else:
                 line = find_calling_line(2)
-            
+
             split_line = line.split("=")
-            
+
             if len(split_line) == 2 and False:
                 python_var_name = split_line[0]
                 python_var_name = python_var_name.split(" ")[0]
                 python_var_name = python_var_name.split(" ")[-1]
                 name = python_var_name
             else:
-                from qrisp import QuantumFloat, QuantumBool, QuantumChar
-                
+                from qrisp import QuantumBool, QuantumChar, QuantumFloat
+
                 if isinstance(qtype, QuantumFloat):
                     name = qtype.get_unique_name("qf_array")
                 elif isinstance(qtype, QuantumBool):
                     name = qtype.get_unique_name("qbl_array")
                 elif isinstance(qtype, QuantumChar):
                     name = qtype.get_unique_name("qch_array")
                 else:
                     name = qtype.get_unique_name("qv_array")
-                    
+
         else:
             if name[-1] == "*":
                 name = qtype.get_unique_name(name[:-1])
-            
+
         obj.name = qtype.name
-        
-        #Set data size
+
+        # Set data size
         obj.msize = qtype.size
-        obj.qtype = qtype.duplicate(name = obj.name)
-        
-        
+        obj.qtype = qtype.duplicate(name=obj.name)
+
         if qs is None:
             from qrisp.core import QuantumSession
+
             qs = QuantumSession()
-        
-        
+
         if isinstance(shape, int):
-            shape = (shape, )
+            shape = (shape,)
         indices = list(product(*[list(range(i)) for i in shape]))
-        
+
         for i in indices:
-            temp_dup = qtype.duplicate(qs = qs)
+            temp_dup = qtype.duplicate(qs=qs)
             np.ndarray.__setitem__(obj, i, temp_dup)
         obj.qs = qs
-            
+
         return obj
-    
-    
+
     def decoder(self, code_int):
         """
-        The decoder method specifies how a QuantumArray turns the outcomes of measurements into human readable values. It recieves an integer i and returns an OutcomeArray.
-        
+        The decoder method specifies how a QuantumArray turns the outcomes of
+        measurements into human-readable values. It recieves an integer i and returns an
+        OutcomeArray.
+
         Parameters
         ----------
         i : int
-            Integer representing the outcome of a measurement of the qubits of this QuantumArray.
+            Integer representing the outcome of a measurement of the qubits of this
+            QuantumArray.
 
         Returns
         -------
-        res : np.ndarray        
-            An array with entries of the type of the results of the .decoder of the qtype of this array.
+        res : np.ndarray
+            An array with entries of the type of the results of the .decoder of the
+            qtype of this array.
 
         Examples
         --------
-        
-        We create a QuantumFloat and inspect it's decoder:
-        
+
+        We create a QuantumFloat and inspect its decoder:
+
         >>> from qrisp import QuantumArray, QuantumFloat
         >>> qtype = QuantumFloat(3)
         >>> q_array = QuantumArray(qtype, (2,2))
         >>> print(q_array.decoder(1))
         [[0 0]
          [0 1]]
-        
+
         """
-        
-        
+
         flattened_array = self.flatten()
-        
+
         from qrisp.qtypes.quantum_float import QuantumFloat
+
         if isinstance(self.qtype, QuantumFloat):
             if self.qtype.exponent >= 0:
-                res = np.zeros(len(flattened_array), dtype = np.int64)
+                res = np.zeros(len(flattened_array), dtype=np.int64)
             else:
                 res = np.zeros(len(flattened_array))
         else:
             res = np.zeros(len(flattened_array))
-        
-        
+
         n = len(self.qtype)
-        
-        bin_string = bin_rep(code_int, len(flattened_array)*n)
-        
+
+        bin_string = bin_rep(code_int, len(flattened_array) * n)
+
         for i in range(len(flattened_array)):
             try:
-                res[i] = self.qtype.decoder(int(bin_string[i*n:(i+1)*n], 2))
+                res[i] = self.qtype.decoder(int(bin_string[i * n : (i + 1) * n], 2))
             except ValueError:
                 res = res.astype("object")
-                res[i] = self.qtype.decoder(int(bin_string[i*n:(i+1)*n], 2))
-        
+                res[i] = self.qtype.decoder(int(bin_string[i * n : (i + 1) * n], 2))
+
         return OutcomeArray(res.reshape(self.shape))
-    
-    
+
     def encoder(self, encoding_array):
         """
-        The encoder reverses the decoder, it turns arrays into integers based on the encoder of the ``qtype`` of this array.
-        
+        The encoder reverses the decoder, it turns arrays into integers based on the
+        encoder of the ``qtype`` of this array.
+
         Parameters
         ----------
-        encoding_array : 
+        encoding_array :
             An array where the entries can be read by the decoder of qtype.
 
         Raises
         ------
         Exception
             Tried to call encoder on array with mismatching shape.
 
@@ -293,41 +310,41 @@
         i : int
             The integer encoding the given array.
 
         Examples
         --------
 
         We create a QuantumArray and inspect it's encoder:
-        
+
         >>> from qrisp import QuantumArray, QuantumFloat
         >>> qtype = QuantumFloat(3)
         >>> q_array = QuantumArray(qtype, (2,2))
         >>> print(q_array.encoder(np.eye(2)))
         513
         """
-        
+
         if isinstance(encoding_array, list):
             encoding_array = np.array(encoding_array)
-        
+
         if self.shape != encoding_array.shape:
             raise Exception("Tried to call encoder on array with mismatching shape")
-        
-        
+
         flattened_encoding_array = encoding_array.flatten()
         flattened_quantum_array = self.flatten()
-        
+
         encoding_int_str = ""
-        
+
         for i in range(len(flattened_encoding_array)):
             qv = flattened_quantum_array[i]
-            encoding_int_str += bin_rep(qv.encoder(flattened_encoding_array[i]), qv.size)[::-1]
-        
+            encoding_int_str += bin_rep(
+                qv.encoder(flattened_encoding_array[i]), qv.size
+            )[::-1]
+
         return int(encoding_int_str[::-1], 2)
-        
-    
+
     def set_shape(self, shape):
         """
         Method to specify a shape for arrays which have been created without one.
 
         Parameters
         ----------
         shape : tuple
@@ -335,601 +352,607 @@
 
         Raises
         ------
         Exception
             QuantumArray already has a shape.
 
         """
-        
-        
+
         if self.shape_specified:
-            raise Exception("Tried to set shape of QuantumArray, which already has a shape")
-        
+            raise Exception(
+                "Tried to set shape of QuantumArray, which already has a shape"
+            )
+
         if isinstance(shape, int):
-            shape = (shape, )
-        
-        
-        self.resize(shape, refcheck = False)
-        
+            shape = (shape,)
+
+        self.resize(shape, refcheck=False)
+
         indices = list(product(*[list(range(i)) for i in shape]))
-        
+
         for i in indices:
-            
-            temp_dup = self.qtype.duplicate(qs = self.qs)
+            temp_dup = self.qtype.duplicate(qs=self.qs)
             np.ndarray.__setitem__(self, i, temp_dup)
-        
+
         self.shape_specified = True
-        
 
     def __setitem__(self, key, value):
-        
         if not self.shape_specified:
             if not hasattr(value, "shape"):
                 value = np.array(value)
             self.set_shape(value.shape)
-        
-        
+
         if isinstance(value, QuantumArray):
             self[key].init_from(value)
             return
-        
-        
+
         if isinstance(value, QuantumVariable):
             return
         self[key].encode(value)
-        return self    
+        return self
 
-        
     def __array_function__(self, func, types, args, kwargs):
-        
         if func.__name__ == "concatenate":
-            
             from qrisp import merge
-            
+
             if id(args[0][0].qtype) != id(args[0][1].qtype):
-                raise Exception("Tried to concatenate arrays with differing qtype objects")
-            
+                raise Exception(
+                    "Tried to concatenate arrays with differing qtype objects"
+                )
+
             merge(args)
-            
+
             ndarray_res = np.ndarray.__array_function__(self, func, types, args, kwargs)
-            
-            res = QuantumArray(self.qtype, shape = ndarray_res.shape)
-            
+
+            res = QuantumArray(self.qtype, shape=ndarray_res.shape)
+
             indices = product(*[list(range(i)) for i in ndarray_res.shape])
             for i in indices:
                 np.ndarray.__setitem__(res, i, ndarray_res[i])
-            
+
             res.qs = args[0][0].qs
             res.qtype = args[0][0].qtype
-            
-            return res
 
+            return res
 
         else:
-            return np.ndarray.__array_function__(self, func, types, args, kwargs)            
-                
-    
-
-    
-    #Retrieves a measurement of the arrays state
-    #Returns a list of tuples of the type (array, count)
-    #ie. [(array([1,1,0]), 232), (array([1,1,3]), 115), ...]
-    def get_measurement(self, backend = None, shots = 10000, compile = True, compilation_kwargs = {}, subs_dic = {}, circuit_preprocessor = None):
-        """
-        Method for acquiring measurement results for the given array. The semantics are similar to the :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>` method of QuantumVariable. The results are returned as a dictionary of another numpy subtype called OutcomeArray.
+            return np.ndarray.__array_function__(self, func, types, args, kwargs)
+
+    # Retrieves a measurement of the arrays state
+    # Returns a list of tuples of the type (array, count)
+    # ie. [(array([1,1,0]), 232), (array([1,1,3]), 115), ...]
+    def get_measurement(
+        self,
+        backend=None,
+        shots=10000,
+        compile=True,
+        compilation_kwargs={},
+        subs_dic={},
+        circuit_preprocessor=None,
+    ):
+        """
+        Method for acquiring measurement results for the given array. The semantics are
+        similar to the :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>`
+        method of QuantumVariable. The results are returned as a dictionary of another
+        numpy subtype called OutcomeArray.
 
         Parameters
         ----------
         backend : BackendClient, optional
-            The backend on which to evaluate the quantum circuit. The default can be specified in the file default_backend.py.
+            The backend on which to evaluate the quantum circuit. The default can be
+            specified in the file default_backend.py.
         shots : integer, optional
             The amount of shots to evaluate the circuit. The default is 10000.
         compile : bool, optional
-            Boolean indicating if the .compile method of the underlying QuantumSession should be called before. The default is True.
+            Boolean indicating if the .compile method of the underlying QuantumSession
+            should be called before. The default is True.
         compilation_kwargs  : dict, optional
-            Keyword arguments for the compile method. For more details check :meth:`QuantumSession.compile <qrisp.QuantumSession.compile>`. The default is ``{}``.
+            Keyword arguments for the compile method. For more details check
+            :meth:`QuantumSession.compile <qrisp.QuantumSession.compile>`.
+            The default is ``{}``.
         subs_dic : dict, optional
-            A dictionary of sympy symbols and floats to specify parameters in the case of a circuit with unspecified, abstract parameters. The default is {}.
+            A dictionary of sympy symbols and floats to specify parameters in the case
+            of a circuit with unspecified, abstract parameters. The default is {}.
         circuit_preprocessor : Python function, optional
-            A function which recieves a QuantumCircuit and returns one, which is applied after compilation and parameter substitution. The default is None.
-        
+            A function which recieves a QuantumCircuit and returns one, which is applied
+            after compilation and parameter substitution. The default is None.
+
         Raises
         ------
         Exception
             Tried to get measurement within open environment.
 
         Returns
         -------
         list of tuples
             The measurement results in the form [(outcome_label, probability), ...].
 
         Examples
         --------
-        
+
         >>> from qrisp import QuantumFloat, QuantumArray
         >>> qtype = QuantumFloat(3)
         >>> q_array = QuantumArray(qtype)
         >>> q_array[:] = [[1,0],[0,1]]
         >>> res = q_array.get_measurement()
         >>> print(res)
         {OutcomeArray([[1, 0],
                        [0, 1]]): 1.0}
         """
-        
+
         for qv in self.flatten():
             if qv.is_deleted():
-                raise Exception("Tried to measure QuantumArray containing deleted QuantumVariables")
-        
+                raise Exception(
+                    "Tried to measure QuantumArray containing deleted QuantumVariables"
+                )
+
         if not self.shape_specified:
             raise Exception("Tried to measure QuantumArray without shape specification")
-        
-        
-        if backend == None:
-            if self.qs.backend == None:
+
+        if backend is None:
+            if self.qs.backend is None:
                 from qrisp.default_backend import def_backend
+
                 backend = def_backend
             else:
                 backend = self.qs.backend
-            
-            
+
         if len(self.qs.env_stack) != 0:
             raise Exception("Tried to get measurement within open environment")
-        
+
         qubits = sum([qv.reg for qv in self.flatten()[::-1]], [])
-        #Copy circuit in over to prevent modification
+        # Copy circuit in over to prevent modification
         from qrisp.quantum_network import QuantumNetworkClient
-        
+
         if isinstance(backend, QuantumNetworkClient):
             qc = self.qs.copy()
             self.qs.clear_data()
             shots = 1
         else:
             if compile:
                 from qrisp.core.compilation import qompiler
-                
-                qc = qompiler(self.qs, intended_measurements = qubits, **compilation_kwargs)
+
+                qc = qompiler(
+                    self.qs, intended_measurements=qubits, **compilation_kwargs
+                )
                 # qc = self.qs.compile(compilation_workspace)
             else:
                 qc = self.qs.copy()
-        
-        
-        #Bind parameters
+
+        # Bind parameters
         if subs_dic:
             qc = qc.bind_parameters(subs_dic)
-        
-        #Execute user specified circuit_preprocessor
-        if circuit_preprocessor != None:
+
+        # Execute user specified circuit_preprocessor
+        if circuit_preprocessor is not None:
             qc = circuit_preprocessor(qc)
-            
-        #Transpile circuit        
+
+        # Transpile circuit
         qc = transpile(qc)
-        
-        
+
         from qrisp.misc import get_measurement_from_qc
-        
-        
+
         counts = get_measurement_from_qc(qc, qubits, backend, shots)
-        
-        
-        #Insert outcome labels (if available and hashable)
+
+        # Insert outcome labels (if available and hashable)
         new_counts_dic = {}
         for key in counts.keys():
-            
             outcome_label = self.decoder(key)
-            
+
             new_counts_dic[outcome_label] = counts[key]
-        
+
         counts = new_counts_dic
-        
-        #Sort keys
+
+        # Sort keys
         sorted_key_list = list(counts.keys())
-        sorted_key_list.sort(key = lambda x : -counts[x])
-        counts = {key : counts[key] for key in sorted_key_list}
+        sorted_key_list.sort(key=lambda x: -counts[x])
+        counts = {key: counts[key] for key in sorted_key_list}
 
-        
-        
         return counts
-    
+
     def encode(self, encoding_array):
         """
-        The encode method allows to quickly bring a QuantumArray in a desired computational basis state. For this, it performs a circuit, bringing fresh qubits into the integer state specified by the encoder.
-        
+        The encode method allows to quickly bring a QuantumArray in a desired
+        computational basis state. For this, it performs a circuit, bringing fresh
+        qubits into the integer state specified by the encoder.
+
         A shorthand for this method is given by the ``[:]`` operator.
-        
-        Note that the qubits to initialize have to be fresh (ie. no operations performed on them).
-        
+
+        Note that the qubits to initialize have to be fresh (i.e. no operations
+        performed on them).
+
         Parameters
         ----------
-        value : 
+        value :
             A value supported by the encoder.
 
         Examples
         --------
-        
+
         We create a QuantumArray and encode the identity matrix.
-        
+
         >>> from qrisp import QuantumArray, QuantumFloat
         >>> qtype = QuantumFloat(5)
         >>> q_array = QuantumArray(qtype, (4,4))
         >>> q_array.encode(np.eye(4))
         >>> print(q_array)
         {OutcomeArray([[1, 0, 0, 0],
                        [0, 1, 0, 0],
                        [0, 0, 1, 0],
                        [0, 0, 0, 1]]): 1.0}
-        
+
         Using the slice operator we can also encode on slices of QuantumArrays
-        
+
         >>> q_array = QuantumArray(qtype, (4,4))
         >>> q_array[:,:2] = np.ones((4,2))
         >>> print(q_array)
         {OutcomeArray([[1, 1, 0, 0],
                        [1, 1, 0, 0],
                        [1, 1, 0, 0],
                        [1, 1, 0, 0]]): 1.0}
         """
-        
-        
+
         flattened_array = self.flatten()
-        
+
         qubit_list = sum([qv.reg for qv in flattened_array], [])
-        
-        from qrisp.misc import int_encoder, check_if_fresh
-        
+
+        from qrisp.misc import check_if_fresh, int_encoder
+
         if not check_if_fresh(qubit_list, self.qs):
             raise Exception("Tried to initialize qubits which are not fresh anymore.")
-        
-        
+
         int_encoder(qubit_list, self.encoder(encoding_array))
-        
+
         return
-        
-    
-    def delete(self, verify = False):
-        """
-        Performs the :meth:`delete <qrisp.QuantumVariable.delete>` method on all QuantumVariables in this array.
+
+    def delete(self, verify=False):
+        r"""
+        Performs the :meth:`delete <qrisp.QuantumVariable.delete>` method on all
+        QuantumVariables in this array.
 
         Parameters
         ----------
         verify : bool, optional
-            If this keyword is set to true, a simulator is queried to check if the deleted qubits are in the $\ket{0}$ state. The default is False.
+            If this keyword is set to true, a simulator is queried to check if the
+            deleted qubits are in the $\ket{0}$ state. The default is False.
 
         """
         temp = self.flatten()
         for i in range(len(temp)):
             temp.qv_array[i].delete()
-        
 
     def __repr__(self):
         return str(self.get_measurement())
-    
+
     def __str__(self):
         return str(self.get_measurement())
-    
+
     def __matmul__(self, other):
         from qrisp import QuantumFloat
+
         if isinstance(self.qtype, QuantumFloat):
             if isinstance(other, QuantumArray):
                 from qrisp.arithmetic import q_matmul
+
                 return q_matmul(self, other)
-        
+
             elif isinstance(other, np.ndarray):
                 from qrisp.arithmetic import semi_classic_matmul
+
                 return semi_classic_matmul(self, other)
-            
+
         raise Exception("Matrix multiplication for non-float types not implemented")
-        
+
     def __rmatmul__(self, other):
         from qrisp import QuantumFloat
+
         if isinstance(self.qtype, QuantumFloat):
             return (self.transpose() @ other.transpose()).transpose()
-    
+
     def __getitem__(self, index):
         if isinstance(index, QuantumVariable):
             return manipulate_array(self, index)
-        
+
         if isinstance(index, tuple):
             if isinstance(index[0], QuantumVariable):
                 return manipulate_array(self, index)
-        
+
         return np.ndarray.__getitem__(self, index)
-                
-        
+
     def init_state(self, tuple_list):
         """
-        Method to initiate arbitrary quantum states in this array. The semantics are similar to the :meth:`QuantumVariable equivalent <qrisp.QuantumVariable.init_state>` of this method.
+        Method to initiate arbitrary quantum states in this array. The semantics are
+        similar to the :meth:`QuantumVariable equivalent
+        <qrisp.QuantumVariable.init_state>` of this method.
 
         The given state will be normalized.
-        
+
         Parameters
         ----------
         tuple_list : list of tuples
-            The list of tuples describing the quantum state. The first componenet of the tuples needs to represent the array and the second the required amplitude.
+            The list of tuples describing the quantum state. The first componenet of the
+            tuples needs to represent the array and the second the required amplitude.
 
         Raises
         ------
         Exception
             Tried to initialize quantum state on qubits which are not fresh anymore.
 
         Examples
         --------
 
-        We initiate a quantum state on an array and evaluate the measurement probabilities.
-        
+        We initiate a quantum state on an array and evaluate the measurement
+        probabilities.
+
         >>> from qrisp import QuantumArray, QuantumFloat
         >>> qtype = QuantumFloat(3)
         >>> q_array = QuantumArray(qtype, shape = 3)
         >>> q_array.init_state([(np.array([1, 2, 3]), 1), (np.array([1, 2, 2]), 0.5j)])
         >>> print(q_array)
         {OutcomeArray([1, 2, 3]): 0.8, OutcomeArray([1, 2, 2]): 0.2}
 
         """
-        
-        from qrisp import bin_rep
+
         if isinstance(tuple_list, dict):
             tuple_list = [(k, v) for k, v in tuple_list.items()]
-        
+
         flattened_array = self.flatten()
         qubit_list = []
-        
+
         for qv in flattened_array:
             qubit_list += qv.reg
             from qrisp.misc import check_if_fresh
+
             if not check_if_fresh(qv.reg, qv.qs):
-                raise Exception("Tried to initialize quantum state on qubits which are not fresh anymore")
-            
-        
-        
-        target_array = np.zeros(2**len(qubit_list), dtype = np.complex128)
-        
-        
+                raise Exception(
+                    "Tried to initialize quantum state on qubits,"
+                    "which are not fresh anymore"
+                )
+
+        target_array = np.zeros(2 ** len(qubit_list), dtype=np.complex128)
+
         for i in range(len(tuple_list)):
-                            
             target_array[self.encoder(tuple_list[i][0])] = tuple_list[i][1]
-        
-        
-        target_array = target_array/np.vdot(target_array, target_array)**0.5
-        
+
+        target_array = target_array / np.vdot(target_array, target_array) ** 0.5
+
         from qrisp import init_state
-        
+
         init_state(qubit_list, target_array)
 
     def init_from(self, other):
         """
-        Performs the :meth:`init_from <qrisp.QuantumVariable.init_from>` method on all containing QuantumVariables based on their equivalent in the QuantumArray other.
-        Note that this method does not copy the quantum state. For more details check the documentation of the init_from method of QuantumVariable.
-        
+        Performs the :meth:`init_from <qrisp.QuantumVariable.init_from>` method on all
+        containing QuantumVariables based on their equivalent in the QuantumArray other.
+        Note that this method does not copy the quantum state. For more details check
+        the documentation of the init_from method of QuantumVariable.
+
         A shorthand for this method is the slicing operator ``[:]``.
-        
+
         Parameters
         ----------
         other : QuantumArray
             The QuantumArray from which to initiate.
 
         Raises
         ------
         Exception
             Tried to initialize from array of invalied shape or qtype.
 
         Examples
         --------
-        
+
         We create a QuantumArray and bring it into superposition
-        
+
         >>> import numpy as np
         >>> from qrisp import QuantumArray, QuantumFloat, h, multi_measurement
         >>> qtype = QuantumFloat(5)
         >>> q_array_a = QuantumArray(qtype)
         >>> q_array_a[:] = np.eye(3)
         >>> h(q_array_a[0,0][0])
         >>> print(q_array_a)
         {OutcomeArray([[0, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1]]): 0.5,
          OutcomeArray([[1, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1]]): 0.5}
-        
+
         We now duplicate this array and initiate
-        
+
         >>> q_array_b = q_array_a.duplicate()
         >>> q_array_b.init_from(q_array_a)
         >>> print(multi_measurement([q_array_a, q_array_b]))
                 {(OutcomeArray([[0, 0, 0],
                                 [0, 1, 0],
-                                [0, 0, 1]]), 
+                                [0, 0, 1]]),
                   OutcomeArray([[0, 0, 0],
                                 [0, 1, 0],
                                 [0, 0, 1]])): 0.5,
                  (OutcomeArray([[1, 0, 0],
                                 [0, 1, 0],
-                                [0, 0, 1]]), 
+                                [0, 0, 1]]),
                   OutcomeArray([[1, 0, 0],
                                 [0, 1, 0],
                                 [0, 0, 1]])): 0.5}
-    
-    
+
+
         We can achieve the same with the slicing operator
-        
+
         >>> q_array_c = QuantumArray(qtype, shape = (3, 3))
         >>> q_array_c[1,:] = q_array_a[0,:]
         >>> print(multi_measurement([q_array_b, q_array_c]))
         {(OutcomeArray([[0, 0, 0],
                         [0, 0, 0],
-                        [0, 0, 0]]), 
+                        [0, 0, 0]]),
           OutcomeArray([[0, 0, 0],
                         [0, 0, 0],
-                        [0, 0, 0]])): 0.5, 
+                        [0, 0, 0]])): 0.5,
          (OutcomeArray([[0, 0, 0],
                         [1, 0, 0],
-                        [0, 0, 0]]), 
+                        [0, 0, 0]]),
           OutcomeArray([[0, 0, 0],
                         [1, 0, 0],
                         [0, 0, 0]])): 0.5}
         """
         if id(self.qtype) != id(other.qtype) or self.shape != other.shape:
-            raise Exception("Tried to initialize from array of invalied shape or qtype")
-        
+            raise Exception("Tried to initialize from array of invalid shape or qtype")
+
         self_fl = self.flatten()
         other_fl = other.flatten()
-        
+
         for i in range(len(self_fl)):
             self_fl[i].init_from(other_fl[i])
-        
-    def duplicate(self, init = False, qs = None):
+
+    def duplicate(self, init=False, qs=None):
         """
         This method returns a fresh QuantumArray, with equal ``qtype`` and shape.
 
         Parameters
         ----------
         init : bool, optional
-            If set to True, the :meth:`init_from <qrisp.QuantumArray.init_from>` method will be called after creation. The default is False.
+            If set to True, the :meth:`init_from <qrisp.QuantumArray.init_from>` method
+            will be called after creation. The default is False.
         qs : QuantumSession, optional
-            The QuantumSession where the duplicate should be registered. By default, the duplicate will be registered in a new QuantumSession.
+            The QuantumSession where the duplicate should be registered. By default,
+            the duplicate will be registered in a new QuantumSession.
 
         Returns
         -------
         res : QuantumArray
             The duplicated array.
-            
+
         Examples
         --------
-        
-        We duplicate a QuantumArray consisting of QuantumFloats with and without initiation
-        
-        
+
+        We duplicate a QuantumArray consisting of QuantumFloats with and without
+        initiation.
+
+
         >>> from qrisp import QuantumArray, QuantumFloat
         >>> qtype = QuantumFloat(4)
         >>> q_array_0 = QuantumArray(qtype, (2,2))
         >>> q_array_0[:] = np.ones((2,2))
         >>> print(q_array_0)
         {OutcomeArray([[1, 1],
                        [1, 1]]): 1.0}
         >>> q_array_1 = q_array_0.duplicate()
         >>> print(q_array_1)
         {OutcomeArray([[0, 0],
                        [0, 0]]): 1.0}
-        
+
         Note that no values have been carried over:
-        
+
         >>> q_array_2 = q_array_0.duplicate(init = True)
         >>> print(q_array_2)
         {OutcomeArray([[1, 1],
                        [1, 1]]): 1.0}
-        
-        Now the values have been carried over. Note that this does NOT copy the state. For more information on this check the documentation of the :meth:`init_from <qrisp.QuantumVariable.init_from>` method of QuantumVariable.
+
+        Now the values have been carried over. Note that this does NOT copy the state.
+        For more information on this check the documentation of the
+        :meth:`init_from <qrisp.QuantumVariable.init_from>` method of QuantumVariable.
         """
-        
+
         res = self.copy()
-        
-        
-        if qs == None:
+
+        if qs is None:
             from qrisp import QuantumSession
+
             qs = QuantumSession()
-            
+
         indices = product(*[list(range(i)) for i in self.shape])
-        
+
         for i in indices:
-            temp_dup = self.qtype.duplicate(qs = qs)
+            temp_dup = self.qtype.duplicate(qs=qs)
             np.ndarray.__setitem__(res, i, temp_dup)
-        
+
         res.msize = self.qtype.size
         res.qtype = self.qtype
         res.qs = qs
         if init:
             res.init_from(self)
-            
+
         return res
 
     def __array_finalize__(self, obj):
+        if obj is None:
+            return
 
-        if obj is None: return
-        
-        
         self.shape_specified = bool(obj.shape_specified)
         self.qtype = obj.qtype
         self.qs = obj.qs
-        
+
     def most_likely(self, **kwargs):
         """
         Performs a measurement and returns the most likely outcome.
 
         Parameters
         ----------
         **kwargs : Keyword arguments for the get_measurement call.
-        
+
         Examples
         --------
-        
+
         >>> from qrisp import QuantumFloat, QuantumArray, ry
         >>> import numpy as np
         >>> qa = QuantumArray(QuantumFloat(3), shape = 4)
         >>> ry(np.pi*9/8, qa[0][0])
         >>> print(qa)
         {OutcomeArray([1, 0, 0, 0]): 0.9619, OutcomeArray([0, 0, 0, 0]): 0.0381}
         >>> qa.most_likely()
         OutcomeArray([1, 0, 0, 0])
         """
         return list(self.get_measurement(**kwargs))[0]
-        
 
-from qrisp.environments.temp_var_environment import temp_qv
 
 @temp_qv
 def manipulate_array(q_array, index):
-    from qrisp import demux, invert, QuantumFloat
+    from qrisp import QuantumFloat, demux, invert
+
     if isinstance(index, tuple):
-        
-        
-        
         if len(q_array.shape) != len(index):
-            raise Exception("Tried to quantum deref QuantumArray with index of mismatching shape")
-            
+            raise Exception(
+                "Tried to quantum deref QuantumArray with index of mismatching shape"
+            )
+
         for qf in index:
             if isinstance(qf, QuantumFloat):
                 if qf.signed:
                     raise Exception("Tried to quantum deref with a signed QuantumFloat")
                 if qf.exponent != 0:
                     raise Exception("Tried to quantum deref with a non-integer")
-                
-        
+
         index = sum([qv.reg for qv in index[::-1]], [])
         q_array = q_array.flatten()
-    
+
     with invert():
         demux(q_array[0], index, q_array)
-    
-    return q_array[0]
-
 
+    return q_array[0]
 
 
 class OutcomeArray(np.ndarray):
-    
     def __new__(subtype, ndarray):
-        
         if isinstance(ndarray, list):
             ndarray = np.array(ndarray)
-        
-        obj = super().__new__(subtype, ndarray.shape, dtype = ndarray.dtype)
+
+        obj = super().__new__(subtype, ndarray.shape, dtype=ndarray.dtype)
         indices = product(*[list(range(i)) for i in ndarray.shape])
         for i in indices:
-            
             np.ndarray.__setitem__(obj, i, ndarray[i])
-        
+
         obj.flags.writeable = False
         return obj
-    
+
     def __hash__(self):
         return hash(str(self))
-    
+
     def __eq__(self, other):
         if isinstance(other, str):
             return str(self) == other
         else:
             return np.array_equal(self, other)
-        
+
     def __repr__(self):
         res = np.ndarray.__repr__(self).replace(", dtype=int64", "")
-        
+
         return res
-
```

### Comparing `qrisp-0.0.15/src/qrisp/core/quantum_dictionary.py` & `qrisp-0.0.16/src/qrisp/core/quantum_dictionary.py`

 * *Files 13% similar despite different names*

```diff
@@ -6,250 +6,270 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
-import numpy as np
-from qrisp.core import recursive_qv_search, QuantumVariable
-from qrisp.misc import custom_qv, bin_rep, int_as_array, gate_wrap
 import itertools
+
+import numpy as np
+
+from qrisp.core import QuantumVariable, recursive_qv_search
 from qrisp.logic_synthesis import TruthTable
+from qrisp.misc import bin_rep, custom_qv, int_as_array
 
 
 class QuantumDictionary(dict):
-    """
-    This class can be used for loading data relations into the quantum computer which are not based on a quantum algorithm.
-    
-    As an inheritor of the Python dictionary it has all of the functionality we are used to
-    
+    r"""
+    This class can be used for loading data relations into the quantum computer which
+    are not based on a quantum algorithm.
+
+    As an inheritor of the Python dictionary it has all the functionality we are used to
+
     >>> from qrisp import QuantumDictionary, QuantumVariable, multi_measurement
     >>> qd = QuantumDictionary()
     >>> qd[1] = 2
     >>> qd[42] = (3,4)
     >>> qd["hello"] = "hallo"
     >>> qd["world"] = "welt"
     >>> print(qd[42])
     (3,4)
-    
-    The key difference is that the QuantumDictionary can also recieve :ref:`QuantumVariables <QuantumVariable>` as keys and return the corresponding values as an entangled QuantumVariable.
-    
-    We demonstrate this by preparing a QuantumVariable which has the keys of ``qd`` as outcome labels:
-    
+
+    The key difference is that the QuantumDictionary can also recieve
+    :ref:`QuantumVariables <QuantumVariable>` as keys and return the corresponding
+    values as an entangled QuantumVariable.
+
+    We demonstrate this by preparing a QuantumVariable which has the keys of ``qd`` as
+    outcome labels:
+
     >>> key_qv = QuantumVariable.custom([1, 42, "hello", "world"])
     >>> key_qv[:] = {"hello" : 1, "world" : 1}
     >>> print(key_qv)
     {'hello': 0.5, 'world': 0.5}
-    
-    We now load the data from the QuantumDictionary into the quantum algorithm by dereferencing ``qd`` with ``key_qv``:
-    
+
+    We now load the data from the QuantumDictionary into the quantum algorithm by
+    dereferencing ``qd`` with ``key_qv``:
+
     >>> value_qv = qd[key_qv]
-    >>> multi_measurement([key_qv, value_qv])    
+    >>> multi_measurement([key_qv, value_qv])
     {('hello', 'hallo'): 0.5, ('world', 'welt'): 0.5}
-    
-    We see that the states of ``key_qv`` are now entangled with the states of the values. 
-    
+
+    We see that the states of ``key_qv`` are now entangled with the states of the
+    values.
+
     QuantumDictionaries can also load from tuples of QuantumVariables:
-        
+
     >>> qd[(1,2)] = 73
     >>> qd[(0,2)] = 37
     >>> qf1 = QuantumFloat(1)
     >>> qf2 = QuantumFloat(2)
     >>> h(qf1)
     >>> qf2[:] = 2
     >>> res = qd[(qf1, qf2)]
     >>> multi_measurement([qf1, qf2, res])
     {(0, 2, 37): 0.5, (1, 2, 73): 0.5}
-    
+
     Mathematically we have
-    
+
     .. math::
-        
-        U_{\\text{qd}} \\left( \\sum_{x \\in \\text{labels}} a_x \ket{x} \\right) \ket{0} = \\sum_{x \\in \\text{labels}} a_x \ket{x} \ket{\\text{qd}[x]}
-        
-    Note that this quantum operation is realized through quantum logic synthesis, which scales rather badly compared to algorithmic generation of data relations.
-    Therefore performing as much logic on the quantum computer is preferable over performing the logic on the classical computer and inserting the results using QuantumDictionaries.
-    
-    
+
+        U_{\text{qd}} \left( \sum_{x \in \text{labels}} a_x \ket{x} \right)
+        \ket{0} = \sum_{x \in \text{labels}} a_x \ket{x} \ket{\text{qd}[x]}
+
+    Note that this quantum operation is realized through quantum logic synthesis, which
+    scales rather badly compared to algorithmic generation of data relations.
+    Therefore, performing as much logic on the quantum computer is preferable over
+    performing the logic on the classical computer and inserting the results using
+    QuantumDictionaries.
+
+
     **Specifying the return type**
-    
-    The returned QuantumVariable ``value_qv`` is (similar to ``key_qv``) a CustomQuantumVariable:
-    
+
+    The returned QuantumVariable ``value_qv`` is (similar to ``key_qv``) a
+    CustomQuantumVariable:
+
     >>> print(type(value_qv))
     <class 'qrisp.misc.misc_functions.custom_qv.<locals>.CustomQuantumVariable'>
-    
-    If we want to apply further processing this might not be helpfull since custom QuantumVariables lack many methods that are available in more specific quantum types.
-    In this case we can supply the QuantumDictionary with a return type:
-        
+
+    If we want to apply further processing this might not be helpfull since custom
+    QuantumVariables lack many methods that are available in more specific quantum
+    types. In this case we can supply the QuantumDictionary with a return type:
+
     >>> from qrisp import QuantumFloat
     >>> qtype = QuantumFloat(4, -2, signed = True)
     >>> float_qd = QuantumDictionary(return_type = qtype)
-    
+
     We fill again with some example values
-    
+
     >>> float_qd["hello"] = 0.5
     >>> float_qd["world"] = -1
-    
+
     And retrieve the value:
-        
+
     >>> value_qv = float_qd[key_qv]
     >>> print(type(value_qv))
     <class 'qrisp.qtypes.quantum_float.QuantumFloat'>
-    
-    Since ``value_qv`` is a QuantumFloat now, we can use the established methods for arithmetic - for instance the inplace addition:
-    
+
+    Since ``value_qv`` is a QuantumFloat now, we can use the established methods for
+    arithmetic - for instance the inplace addition:
+
     >>> value_qv += 1.5
     >>> print(multi_measurement([key_qv, value_qv]))
     {('hello', 2.0): 0.5, ('world', 0.5): 0.5}
-    
-    
+
+
     **Advanced usage**
-    
-    In some cases, (such as manual uncomputation) it is required to specify into which variable the QuantumDictionary should load. We do this with the :meth:`load <qrisp.QuantumDictionary.load>` method:
-        
+
+    In some cases, (such as manual uncomputation) it is required to specify into which
+    variable the QuantumDictionary should load. We do this with the
+    :meth:`load <qrisp.QuantumDictionary.load>` method:
+
     >>> qf = qtype.duplicate()
     >>> float_qd.load(key_qv, qf)
     >>> print(qf)
     {0.5: 0.5, -1.0: 0.5}
-    
-    The ``load`` method furthermore allows to specify which logic synthesis algorithm should be used.
-    
+
+    The ``load`` method furthermore allows to specify which logic synthesis algorithm
+    should be used.
+
     >>> qf2 = qtype.duplicate()
     >>> float_qd.load(key_qv, qf2, synth_method = "gray")
-    
+
     """
-    
-    
-    def __init__(self, init_dict = {}, return_type = None):
-        
+
+    def __init__(self, init_dict={}, return_type=None):
         super().__init__(init_dict)
-        
+
         self.return_type = return_type
-    
+
     def __getitem__(self, key):
-        
         return self.load(key)
-    
-    def load(self, key, value_qv = None, synth_method = "gray"):
+
+    def load(self, key, value_qv=None, synth_method="gray"):
         """
         Loads the values of the QuantumDictionary into a given QuantumVariable.
 
         Parameters
         ----------
         key_qv : QuantumVariable
-            A QuantumVariable with a decoder supporting the keys of this QuantumDictionary.
+            A QuantumVariable with a decoder supporting the keys of this
+            QuantumDictionary.
         value_qv : QuantumVariable, optional
-            The QuantumVariable to load the values into. If given None, a new QuantumVariable is generated.
+            The QuantumVariable to load the values into. If given None, a new
+            QuantumVariable is generated.
         synth_method : string, optional
-            The method of logic synthesis to use for loading. Currently available are "gray", "gray_pt", "pprm" and "pprm_pt". The default is "gray".
+            The method of logic synthesis to use for loading. Currently available are
+            "gray", "gray_pt", "pprm" and "pprm_pt". The default is "gray".
 
         Raises
         ------
         Exception
             Tried to load value from empty dictionary.
-        
+
         Examples
         --------
-        
+
         We create a QuantumDictionary with return type QuantumFloat
-        
+
         >>> from qrisp import QuantumDictionary, QuantumFloat, h
         >>> qtype = QuantumFloat(4, -2)
         >>> float_qd = QuantumDictionary(return_type = qtype)
         >>> float_qd[0] = 1
         >>> float_qd[1] = 2
-        
+
         Create the key and the value variable:
-        
+
         >>> key_qv = QuantumFloat(1, signed = False)
         >>> h(key_qv)
         >>> value_qv = qtype.duplicate()
-        
+
         And load the values
-        
+
         >>> float_qd.load(key_qv, value_qv, synth_method = "pprm")
         >>> print(value_qv)
         {1.0: 0.5, 2.0: 0.5}
 
         """
-        
+
         qv_list = recursive_qv_search(key)
         if not len(qv_list):
             return dict.__getitem__(self, key)
 
         if not isinstance(key, tuple):
             key = (key,)
 
         labels = []
 
         for qv in key:
             if not isinstance(qv, QuantumVariable):
-                raise Exception("Tried to deref QuantumDictionary with mixed (classical + quantum) input.")
-                
+                raise Exception(
+                    "Tried to deref QuantumDictionary with mixed"
+                    "(classical + quantum) input."
+                )
+
             labels.append([qv.decoder(i) for i in range(2**qv.size)])
-            
+
         quantum_key = key
 
         if len(labels) == 1:
             constellations = labels[0]
         else:
             constellations = itertools.product(*labels)
 
         relevant_dic = {}
 
         for const in constellations:
             if const in self:
                 relevant_dic[const] = dict.__getitem__(self, const)
 
         if value_qv is None:
-            
             if isinstance(self.return_type, type(None)):
                 value_qv = custom_qv(list(relevant_dic.values()))
             else:
                 value_qv = self.return_type.duplicate()
-            
+
         n = sum([qv.size for qv in key])
 
         tt_array = np.zeros((2**n, value_qv.size))
 
-
         for k in relevant_dic:
-            
             bin_string = ""
-            
+
             for i in range(len(quantum_key)):
                 qv = quantum_key[i]
-                
+
                 if isinstance(k, tuple):
                     bin_string += bin_rep(qv.encoder(k[i]), qv.size)[::-1]
                 else:
                     bin_string += bin_rep(qv.encoder(k), qv.size)[::-1]
-            
-            
+
             row_number = int(bin_string[::-1], 2)
-            tt_array[row_number, :] = int_as_array(value_qv.encoder(relevant_dic[k]), value_qv.size)[::-1]
+            tt_array[row_number, :] = int_as_array(
+                value_qv.encoder(relevant_dic[k]), value_qv.size
+            )[::-1]
 
         tt = TruthTable(tt_array)
-        
-        
+
         qv_temp_0 = QuantumVariable(n)
-        qv_temp_1 = QuantumVariable(value_qv.size, qs = qv_temp_0.qs)
-        
-        tt.q_synth(qv_temp_0, qv_temp_1, method = synth_method)
-        
+        qv_temp_1 = QuantumVariable(value_qv.size, qs=qv_temp_0.qs)
+
+        tt.q_synth(qv_temp_0, qv_temp_1, method=synth_method)
+
         if len(qv_temp_0.qs.qubits) != qv_temp_0.size + qv_temp_1.size:
-            synth_ancilla = QuantumVariable(len(qv_temp_0.qs.qubits) - qv_temp_0.size + qv_temp_1.size)
+            synth_ancilla = QuantumVariable(
+                len(qv_temp_0.qs.qubits) - qv_temp_0.size + qv_temp_1.size
+            )
             quantum_key.append(synth_ancilla)
 
         res_gate = qv_temp_0.qs.to_gate("quantum deref")
         res_gate.is_qfree = True
-        res_gate.permeability = {i : i < n for i in range(res_gate.num_qubits)}
-        
-        
-        quantum_key[0].qs.append(res_gate, sum([qv.reg for qv in quantum_key], []) + value_qv.reg)
-        
+        res_gate.permeability = {i: i < n for i in range(res_gate.num_qubits)}
+
+        quantum_key[0].qs.append(
+            res_gate, sum([qv.reg for qv in quantum_key], []) + value_qv.reg
+        )
+
         if len(qv_temp_0.qs.qubits) != qv_temp_0.size + qv_temp_1.size:
             synth_ancilla.delete()
-        
-        return value_qv 
 
+        return value_qv
```

### Comparing `qrisp-0.0.15/src/qrisp/core/quantum_session.py` & `qrisp-0.0.16/src/qrisp/core/quantum_variable.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,987 +1,1350 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-import weakref
-import numpy as np
-
-from qrisp.circuit import QuantumCircuit, QubitAlloc, QubitDealloc, Qubit, Clbit
-
-from qrisp.misc import get_depth_dic
-from qrisp.core.session_merging_tools import multi_session_merge
-
-class QuantumSession(QuantumCircuit):
-    """
-    The QuantumSession class manages the life cycle of QuantumVariables and enables features such as :ref:`QuantumEnvironments <QuantumEnvironment>` or :ref:`Uncomputation`.
-    To create a QuantumSession, we call the constructor
-    
-    >>> from qrisp import QuantumSession
-    >>> qs = QuantumSession()
-    
-    To create a QuantumVariable within that QuantumSession, we hand it over to the QuantumVariable constructor:
-    
-    >>> from qrisp import QuantumVariable
-    >>> qv = QuantumVariable(3, qs = qs)
-    
-    As an inheritor of the :ref:`QuantumCircuit` class, QuantumSession objects can also be used for circuit construction
-    
-    >>> qv.qs.cx(qv[0], qv[1])
-    
-    Nevertheless, users are encouraged to use the :ref:`designated gate application function <gate_application_functions>` in order to reduce code cluttering.
-        
-    >>> from qrisp import cx
-    >>> cx(qv[0], qv[1])
-    
-    QuantumSessions can be visualized by calling ``print`` on them.
-    
-    >>> print(qv.qs)
-    QuantumCircuit:
-    ---------------
-    qv.0: ──■────■──
-          ┌─┴─┐┌─┴─┐
-    qv.1: ┤ X ├┤ X ├
-          └───┘└───┘
-    qv.2: ──────────
-    <BLANKLINE>
-    Live QuantumVariables:
-    ----------------------
-    QuantumVariable qv
-    
-    If not specified, QuantumVariables will create their own QuantumSession and register themselves in it.
-    
-    QuantumSessions can be manually merged using the merge function.
-        
-    >>> from qrisp import merge
-    >>> qs_2 = QuantumSession()
-    >>> qs_2 == qs
-    False
-    >>> merge(qs, qs_2)
-    >>> qs == qs_2
-    True
-
-    Note that merge also works for QuantumVariables, lists of QuantumSession and lists of QuantumVariables.
-    
-    If an entangling operation between two QuantumVariables which are registered in different QuantumSessions is executed, these QuantumSessions are automatically merged. For more details on automatic QuantumSession merging check the :ref:`session merging documentation<SessionMerging>`.
-    
-    >>> qv_a = QuantumVariable(2)
-    >>> qv_b = QuantumVariable(2)
-    >>> qv_a.qs == qv_b.qs
-    False
-    >>> from qrisp import cx
-    >>> cx(qv_a[0], qv_b[0])
-    >>> qv_a.qs == qv_b.qs
-    True
-    
-    QuantumSessions can be given a default backend on which to evaluate circuits:
-    
-    >>> from qrisp.interface import VirtualQiskitBackend
-    >>> qiskit_backend = instantiate_qiskit_backend()
-    >>> qs = QuantumSession(backend = VirtualQiskitBackend(qiskit_backend))
-
-    In this piece of code, we assume that the function ``instantiate_qiskit_backend`` creates a Qiskit backend instance (which could either be the QASM Simulator or a real backend). We then hand this to the :ref:`VirtualQiskitBackend` constructor to turn it into a Qrisp backend. Now, any measurements of variables that are registered in this session will be evaluated on that backend.
-    
-    If no backend is given, the backend specified in ``default_backend.py`` will be used.
-    
-    Note that it is not possible to merge two QuantumSessions with differing, non-trivial backends.
-    """
-    
-    qs_tracker = []
-    def __init__(self, backend = None):
-        """
-        Constructs a QuantumSession
-
-        Parameters
-        ----------
-        backend : BackendClient, optional
-            The backend on which to execute the circuits created by this QuantumSession. This choice can be overwritten by specifying a backend in the :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>` method of QuantumVariable.
-
-        Returns
-        -------
-        None.
-
-        Examples
-        --------
-        
-        We create a QuantumSession with the QASM simulator as default backend and register a QuantumFloat in it:
-        
-        >>> from qiskit import Aer
-        >>> qasm_sim = Aer.get_backend("qasm_simulator")
-        >>> from qrisp.interface import VirtualQiskitBackend
-        >>> vrtl_qasm_sim = VirtualQiskitBackend(qasm_sim)
-        >>> from qrisp import QuantumSession, QuantumFloat
-        >>> qs = QuantumSession(vrtl_qasm_sim)
-        >>> qf = QuantumFloat(4, qs = qs)
-        
-        
-        """
-        
-        
-        if isinstance(backend, int):
-            raise Exception
-        
-        super().__init__()
-
-        
-        self.backend = backend
-        
-        #Set up list of quantum variables appearing in this session
-        
-        self.qv_list = []
-        self.deleted_qv_list = []
-        
-        #Set up environment stack
-        #This list will be filled, once we enter an environment
-        self.env_stack = []
-        
-        
-        #This list will be filled with variables which are marked for uncomputation
-        #Variables will be marked once there is no longer any reference to them apart from
-        #the one in qv_list. This is for instance the case with local variables 
-        #inside a function after the function finished
-        self.uncomp_stack = []
-        
-        self.qs_tracker.append(weakref.ref(self))
-        
-        #This list will contain the QuantumSessions which have been merged into this session.
-        #It needs to be tracked in order to also update the shadow sessions when this session is merged into another session.
-        self.shadow_sessions = []
-    
-    def register_qv(self, qv):
-        """
-        Method to register QuantumVariables
-
-        Parameters
-        ----------
-        qv : QuantumVariable
-            QuantumVariable to register.
-
-        Raises
-        ------
-        RuntimeError
-            Name of qv is already used in this QuantumSession.
-
-        Returns
-        -------
-        None.
-
-        """
-        if qv.name in [temp_qv.name for temp_qv in self.qv_list + self.deleted_qv_list]:
-            raise RuntimeError("Variable name " + str(qv.name) + " already exists in quantum session")
-        
-        
-        #Determine amount of required qubits
-        req_qubits = qv.size
-        
-        
-        #Hand qubits to quantum variable
-        qv.reg = self.request_qubits(req_qubits, name = qv.name)
-        
-        
-        #Register in the list of active quantum variable
-        self.qv_list.append(qv)
-        
-    def get_qv(self, key):
-        for qv in self.qv_list:
-            if qv.name == key:
-                return qv()
-        raise Exception("Could not find QuantumVariable " + str(key))
-    
-    def __str__(self):
-        
-        
-        temp_data = list(self.data)
-        self.data = []
-        i = 0
-        
-        from qrisp import QuantumEnvironment
-        
-        while temp_data:
-            instr = temp_data.pop(i)
-            if isinstance(instr, QuantumEnvironment):
-                instr.compile()
-            else:
-                self.append(instr)
-        
-        
-        
-        
-        
-        res = "QuantumCircuit:\n---------------\n"
-        
-        qc_str = QuantumCircuit.__str__(self)
-        
-        
-        #Remove blank line
-        lines = qc_str.split("\n")
-        if len(set(lines[0])) == 1:
-            lines.pop(0)
-        # if len(set(lines[-1])) == 1:
-            # lines.pop(-1)
-        
-        
-        
-        for l in lines:
-            res += l + "\n"
-        
-        
-        if len(self.env_stack):
-            res += "QuantumEnvironment Stack:\n-------------------------\n"
-            for i in range(len(self.env_stack)):
-                env = self.env_stack[i]
-                res += "Level " + str(i) + ": " + str(type(env)).split(".")[-1][:-2] + "\n"
-            res += "\n"
-        
-        res += "Live QuantumVariables:\n----------------------" 
-        
-        
-        qv_name_list = []
-        for qv in self.qv_list:
-            qv_name_list.append(str(type(qv)).split(".")[-1][:-2] + " " + qv.name)
-        
-        for qv_name in qv_name_list:
-            res += "\n" + qv_name
-        
-        return res
-    
-    def get_depth_dic(self):
-        return get_depth_dic(self)
-        
-    def add_qubit(self, qubit = None):
-        qb = super().add_qubit(qubit)
-        qb.qs = weakref.ref(self)
-        qb.perm_lock = False
-        qb.lock = False
-        return qb
-    
-    
-    def __call__(self):
-        return self
-        
-    def add_clbit(self, clbit = None):
-        cb = super().add_clbit(clbit)
-        cb.qs = weakref.ref(self)
-        return cb
-    
-    def request_qubits(self, request_amount, name = None):
-        
-        
-        
-        #Create qubits and add to circuit
-        return_qubits = []
-        
-        for i in range(request_amount):
-            if name == None:
-                qb = self.add_qubit()
-            else:
-                qb = self.add_qubit(Qubit(name + "." + str(i)))
-            
-            return_qubits.append(self.qubits[-1])
-                
-        for qb in return_qubits:
-            self.append(QubitAlloc(), qb)
-        
-        return return_qubits
-    
-    def clear_qubits(self, qubits, verify = False):
-        
-        
-        #Apply initialization operation
-        #The following is uncommented because the QASM simulator speed drastically
-        #drops when having non unitary operations
-        #Uncomment, when executing on real backends
-        if not len(self.env_stack):
-            pass
-            # self.reset(qubits)
-        
-        if verify:
-            verification_qc = self.copy()
-            for qb in qubits: verification_qc.measure(qb)
-            
-            from qrisp.simulator import run
-            res = run(verification_qc, 1000, insert_reset = False)
-            for key in res.keys():
-                if key[:len(qubits)] != len(qubits)*"0":
-                    raise Exception("Tried to delete qubits not in |0> state")
-
-        
-        if not set(qubits).issubset(set(self.qubits)):
-            raise Exception("Tried to free up qubits not registered in this quantum session")
-        
-        for qb in qubits:
-            self.append(QubitDealloc(), qb)
-        
-    
-    #Procedure to free up space for quantum variables not used anymore
-    def delete_qv(self, qv, verify = False):
-       
-        
-        #Check if quantum variable appears in this session
-        if not qv.name in [qv.name for qv in self.qv_list]:
-            raise Exception("Tried to remove a non existent quantum variable from quantum session")
-        
-        self.clear_qubits(qv.reg, verify)
-        
-        #Remove quantum variable from list
-        for i in range(len(self.qv_list)):
-            temp_qv = self.qv_list[i]
-            
-            if temp_qv.name == qv.name:
-                self.qv_list.pop(i)
-                break
-            
-        self.deleted_qv_list.append(qv)
-        
-    def cnot_count(self):
-        """
-        Method to determine the amount of CNOT gates used in this QuantumSession.
-
-        Raises
-        ------
-        Exception
-            Tried to compute the CNOT count with open environments.
-
-        Returns
-        -------
-        int
-            The amount of CNOT gates.
-
-        """
-        
-        
-        if len(self.env_stack) != 0:
-            raise Exception("Tried to count CNOT gates with open if environments")
-        from qrisp.misc import cnot_count
-        return cnot_count(self)
-    
-    def get_local_qvs(self):
-        import sys
-        local_qvs = []
-        for qv in object.__getattribute__(self, "qv_list"):
-            if sys.getrefcount(qv) == 3:
-                local_qvs.append(qv)
-        
-        return local_qvs
-        
-        # self.uncomp_stack = []
-        
-            
-    def logic_synth(self, input_qubits, output_qubits, tt, method = "best", inv = False):
-        
-        if len(input_qubits) != tt.bit_amount:
-            raise Exception("Given truth table has unfitting amount of input variables")
-            
-        if len(output_qubits) != tt.shape[1]:
-            raise Exception("Given truth table has unfitting amount of output columns")
-            
-        self.append(tt.gate_synth(method = method, inv = False), input_qubits + output_qubits)
-    
-    def depth(self):
-        """
-        Method to calculate the circuit depth of this QuantumSession
-
-        Returns
-        -------
-        int
-            The circuit depth.
-
-        """
-        depth_dic  = self.get_depth_dic()
-        return max(depth_dic.values())
-    
-    def __eq__(self, other):
-        if other == None:
-            return False
-        return id(self().data) == id(other().data)
-    
-    
-    
-    def append(self, operation_or_instruction, qubits = [], clbits = []):
-        
-        #Check the type of the instruction/operation
-        from qrisp.circuit import Instruction, Operation
-        
-        if issubclass(operation_or_instruction.__class__, Instruction):            
-            instruction = operation_or_instruction
-            self.append(instruction.op, instruction.qubits, instruction.clbits)
-            return
-    
-        
-        elif issubclass(operation_or_instruction.__class__, Operation):
-            operation = operation_or_instruction
-            
-        else:
-            raise Exception("Tried to append object type " + str(type(operation_or_instruction)) + " which is neither Instruction nor Operation")
-            
-        
-        #Convert arguments (possibly integers) to list
-        #The logic here is that the list structure gets preserved ie.
-        #[[0, 1] ,2] ==> [[qubit_0, qubit_1], qubit_2]
-        #unless the input is a single qubit/integer.
-        #In this case we have
-        #qubit_0 ==> [qubit_0]
-        
-        from qrisp.circuit.quantum_circuit import convert_to_qb_list, convert_to_cb_list
-        qubits = convert_to_qb_list(qubits, circuit = self)
-        clbits = convert_to_cb_list(clbits, circuit = self)
-       
-        
-       
-        def check_alloc(input, res = None):
-            if isinstance(input, list):
-                for item in input:
-                    check_alloc(item)
-            else:
-                if not input.allocated:
-                    raise Exception(f"Tried to perform operation {operation.name} on unallocated qubit {input}")
-
-        if not operation.name in ["qb_alloc", "barrier"]:
-            check_alloc(qubits)
-            
-        elif operation.name == "qb_alloc":
-            qubits[0].allocated = True
-            
-       #We now need to merge the sessions and treat their differing environment levels
-       #The idea here is that if a quantum session A is not identical to the environment session B,
-       #there have been no gates applied within that environment so far (otherwise merging would have occured).
-       #Thus all data of A belongs into the original_data attribute of the environment with the highest level environment,
-       #where the environment quantum session is not identical to A.
-        
-        
-        flattened_qubits = []
-        for item in qubits:
-            if isinstance(item, Qubit):
-                flattened_qubits.append(item)
-            else:
-                flattened_qubits.extend(item)
-        
-        flattened_clbits = []
-        for item in clbits:
-            if isinstance(item, Clbit):
-                flattened_qubits.append(item)
-            else:
-                flattened_qubits.extend(item)
-        
-        #Find the list of all quantum sessions that need to be treated
-        qs_list = [qb.qs() for qb in flattened_qubits] + [cb.qs() for cb in flattened_clbits] + [self]
-        
-        
-        # #We now iterate through every quantum session and insert it's data into the correct original_data attribute
-        # for qs in qs_list:
-            
-        #     #We need to find the environment where the env_qs quantum session is not merged into qs.
-        #     #This implies that the instructions of this session have been appended in this environment's parent.
-        #     #Therefore all the data needs to go into the original_data attribute of this environment.
-        #     for env in qs.env_stack:
-        #         if not env.env_qs == qs:
-        #             env.original_data.extend(qs.data)
-        #             qs.data = []
-        #             merge([qs, env.env_qs])
-                    
-        
-        #We merge qs_list again since no merge happened incase there were no environments
-        multi_session_merge(qs_list)
-
-        super().append(operation, qubits, clbits)
-        
-        if operation.name == "qb_dealloc":
-            qubits[0].allocated = False
-        
-        
-    def __getitem__(self, key):
-        for qv in self.qv_list:
-            if qv.name == key:
-                return qv
-        raise Exception(f"Could not find QuantumVariable {key}")
-        
-        
-    
-    #Instead of just resetting the list, we have to use this method.
-    #This is because merging two quantum session works essentially by handing them
-    #a pointer to the same data list (which contains the merged circuits)
-    #If we clear the data list by setting it to an empty list, any session
-    #that has been merged with self.qs doesnt point to the same data list anymore.
-    #This method tackles this problem by keeping the pointer to the list alive,
-    #but removing every single element
-    def clear_data(self):
-        self.data.clear()
-
-    def statevector(self, return_type = "sympy", plot = False, decimals = None):
-        """
-        Returns a representation of the statevector. Three options are available:
-            
-        * ``sympy`` returns a `Sympy quantum state <https://docs.sympy.org/latest/modules/physics/quantum/state.html>`_, which is great for visualization and symbolic investigation. The tensor factors are in the order of the creation of the QuantumVariables (or equivalently: as they appear, when listed in ``print(self)``).
-        
-        * ``latex`` returns the latex code for the Sympy quantum state.
-        
-        * ``function`` returns a statevector function, such that the amplitudes can be investigated by calling this function on a dictionary of this QuantumSession's QuantumVariables.
-        
-        If you need to retrieve the statevector as a numpy array, please use the corresponding :meth:`QuantumCircuit method <qrisp.QuantumCircuit.statevector_array>`.
-
-        Parameters
-        ----------
-        return_type : str, optional
-            String indicating how the statevector should be returned. Available are ``sympy``, ``array`` and ``function``. The default is ``sympy``.
-        plot : bool, optional
-            If the return type is set to ``array``, this boolean will trigger a plot of the statevector. The default is ``False``.
-        decimals : int, optional
-            The decimals to round in the statevector. The default is 5 for return type ``sympy`` and infinite otherwise.
-
-        Returns
-        -------
-        sympy.Expression or LaTeX string or function 
-            An object representing the statevector.
-
-        Examples
-        --------
-        
-        We create some QuantumFloats and encode values in them:
-        
-        >>> from qrisp import QuantumFloat
-        >>> qf_0 = QuantumFloat(3,-1)
-        >>> qf_1 = QuantumFloat(3,-1)
-        >>> qf_0[:] = 2
-        >>> qf_1[:] = {0.5 : 1, 3.5: -1j}
-
-        This encoded the state
-        
-        .. math::
-            \ket{\psi} = \ket{\\text{qf_0}} \ket{\\text{qf_1}} = \\frac{1}{\\sqrt{2}}  \ket{2} (\ket{0.5} - i \ket{3.5})
-
-        Now we add ``qf_0`` and ``qf_1``:
-        
-        >>> qf_res = qf_0 + qf_1
-        
-        This gives us the state
-        
-        .. math::
-        
-            \ket{\phi} = \\frac{1}{\\sqrt{2}}(\ket{2}\ket{0.5}\ket{2 + 0.5} - i \ket{2} \ket{3.5}\ket{2 + 3.5})
-        
-        
-        
-        We retrieve the statevector as a Sympy expression:
-
-        >>> sv = qf_0.qs.statevector()
-        >>> print(sv)
-        sqrt(2)*(|2.0>*|0.5>*|2.5> - I*|2.0>*|3.5>*|5.5>)/4
-        
-        If you have Sympy's `pretty printing <https://docs.sympy.org/latest/tutorials/intro-tutorial/printing.html>`_ enabled in your IPython console, it will even give you a nice Latex rendering:
-        
-        >>> sv
-        
-        .. image:: ./statevector_print.png
-            :width: 300
-            :alt: Statevector print
-            :align: left
-        
-        |
-        |
-        
-        This feature also works with symbolic parameters:
-            
-        >>> from qrisp import QuantumVariable, ry, h, p
-        >>> from sympy import Symbol
-        >>> qv = QuantumVariable(1)
-        >>> ry(Symbol("omega"), qv)
-        >>> h(qv)
-        >>> p(-Symbol("phi"), qv)
-        >>> qv.qs.statevector()
-        
-        .. image:: ./symbolic_statevector_print.png
-            :width: 350
-            :alt: Statevector print
-            :align: left
-        
-        |
-        |
-        
-        .. note::
-            
-            Statevector simulation with symbolic parameters is significantly more demanding than simulation with numeric parameters.
-        
-        To retrieve the above expressions as latex code, we use ``return_type = "latex"``
-        
-        >>> print(qf_0.qs.statevector(return_type = "latex"))
-        '\\frac{\\sqrt{2} \\left({\\left|2.0\\right\\rangle } {\\left|0.5\\right\\rangle } {\\left|2.5\\right\\rangle } - i {\\left|2.0\\right\\rangle } {\\left|3.5\\right\\rangle } {\\left|5.5\\right\\rangle }\\right)}{2}'
-        
-        
-        We can also retrieve the statevector as a Python function:
-            
-        >>> sv_function = qf_0.qs.statevector("function")
-        
-        Specify the label constellations:
-        
-        >>> label_constellation_a = {qf_0 : 2, qf_1 : 0.5, qf_res : 2+0.5}
-        >>> label_constellation_b = {qf_0 : 2, qf_1 : 3.5, qf_res : 2+3.5}
-        >>> label_constellation_c = {qf_0 : 2, qf_1 : 3.5, qf_res : 4}
-        
-        And evaluate the function:
-        
-        >>> sv_function(label_constellation_a)
-        (0.7071048-1.3411045e-07j)
-        
-        This is the expected amplitude up to floating point errors.
-        
-        To get a quicker understanding, we can tell the statevector function to round the amplitudes using the ``round`` keyword.
-        
-        >>> sv_function(label_constellation_b, round = 6)
-        (-0-0.707105j)
-        
-        Finally, the last amplitude is 0 since the state of ``qf_res`` is not the sum of ``qf_0`` and ``qf_1``
-        
-        >>> sv_function(label_constellation_c, round = 6)
-        0j
-
-        
-        """
-        
-        from qrisp import get_sympy_state, get_statevector_function
-        
-        if return_type == "array":
-
-            from qrisp.simulator import statevector_sim
-            
-            #Simulate the statevector        
-            statevector_array = statevector_sim(self.compile())
-            # statevector_array = statevector_sim(self)
-            
-                #Execute simulation
-                
-                #Plot results if required
-            if plot:
-                import matplotlib.pyplot as plt
-                plt.plot(np.real(statevector_array), "o", label = "Re(psi)")
-                plt.plot(np.imag(statevector_array), "o", label = "Im(psi)")
-                plt.grid()
-                plt.legend()
-                plt.show()
-            if decimals is None:    
-                return statevector_array
-            else:
-                return np.round(statevector_array, decimals)
-        
-        elif return_type == "sympy":
-            if decimals is None:
-                decimals = 6
-            return get_sympy_state(self, decimals)
-        
-        elif return_type == "latex":
-            from sympy import latex
-            return latex(self.statevector(return_type = "sympy", decimals = decimals))
-        
-        elif return_type == "function":
-            if decimals is None:
-                decimals = 15
-            
-            return get_statevector_function(self, decimals)
-        
-        else:
-            raise Exception(f"Don't know return type {return_type}")
-    
-    def compile(self, workspace = 0, intended_measurements = [], cancel_qfts = True, disable_uncomputation = True):
-        r"""
-        Method to compile the QuantumSession into a :ref:`QuantumCircuit`. The compiler dynamically allocates the qubits of the QuantumSession on qubits that might have been used by priorly deleted :ref:`QuantumVariables <QuantumVariable>`.
-        
-        Using the ``workspace`` keyword, we can grant the compiler a number of extra qubits to use in order to reduce the circuit depth.
-        
-        Furthermore, the compiler recompiles any :meth:`mcx <qrisp.mcx>` instruction with ``method = auto`` using a dynamically generated mcx implementation that makes use of as much of the currently available clean and dirty ancillae. This feature will never allocate additional qubits on its own. If required, it can be supplied with additional space using the ``workspace`` keyword.
-        
-        The .compile method is called by default, when executing the :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>` method of :ref:`QuantumVariable`. This method also allows specification of compilation option through the ``compilation_kwargs`` argument.
-        
-        
-        
-        Parameters
-        ----------
-        workspace : int, optional
-            The amount of workspace qubits to be granted. The default is 0.
-        intended_measurements : list[Qubit], optional
-            A list of :ref:`Qubits <Qubit>` that are supposed to be measured. The compiler will remove any instructions that are not directly neccessary to perform the measurements. Note that the resulting :ref:`QuantumCircuit` contains no measurements, such that the user can still specify a classical bit for the measurement. The default ist [].
-        cancel_qfts : bool, optional
-            If set to True, any :meth:`QFT <qrisp.QFT>` instruction that is executed on a set of qubits that have just been allocated (ie. the $\ket{0}$ state) will be replaced by a set of H gates. The same goes for QFT instructions executed directly before deallocation. The default is ``True``.
-        disable_uncomputation : bool, optional
-            Experimental feature the allows fully automized uncomputation. If set to ``False`` any :ref:`QuantumVariable` that went out of scope will be uncomputed by the compiler. The default is ``True``.
-        
-        Returns
-        -------
-        QuantumCircuit
-            The compiled QuantumCircuit.
-            
-        Examples
-        --------
-        
-        **Workspace**
-        
-        We calculate a product of 2 :ref:`QuantumFloats <QuantumFloat>` using the :meth:`sbp_mult <qrisp.sbp_mult>` function which heavily profits from more workspace
-        
-        >>> from qrisp import QuantumFloat, sbp_mult
-        >>> qf_0 = QuantumFloat(5)
-        >>> qf_0[:] = 3
-        >>> qf_1 = QuantumFloat(5)
-        >>> qf_1[:] = 5
-        
-        Calculate product:
-            
-        >>> qf_res = sbp_mult(qf_0, qf_1)
-        >>> qf_res.qs.num_qubits()
-        45
-        
-        Compile circuit with no workspace
-        
-        >>> qc_0 = qf_res.qs.compile(0)
-        >>> qc_0.num_qubits()
-        21
-        >>> qc_0.depth()
-        497
-        
-        Compile circuit with 4 workspace qubits
-        
-        >>> qc_1 = qf_res.qs.compile(4)
-        >>> qc_1.num_qubits()
-        25
-        >>> qc_1.depth()
-        258
-        
-        **mcx recompilation**
-        
-        To demonstrate the recompilation feature, we create two :ref:`QuantumVariables <QuantumVariable>`.
-        
-        >>> from qrisp import QuantumVariable, mcx, cx
-        >>> ctrl = QuantumVariable(4)
-        >>> target = QuantumVariable(1)
-        >>> mcx(ctrl, target)
-        >>> print(ctrl.qs)
-        QuantumCircuit:
-        ---------------
-          ctrl.0: ──■──
-                    │  
-          ctrl.1: ──■──
-                    │  
-          ctrl.2: ──■──
-                    │  
-          ctrl.3: ──■──
-                  ┌─┴─┐
-        target.0: ┤ X ├
-                  └───┘
-        Live QuantumVariables:
-        ----------------------
-        QuantumVariable ctrl
-        QuantumVariable target
-        
-        We can now call the ``.compile`` method
-        
-        >>> compiled_qc = ctrl.qs.compile()
-        >>> compiled_qc.depth()
-        50
-        >>> print(compiled_qc)
-            ctrl.0: ──■──
-                      │  
-            ctrl.1: ──■──
-                      │  
-            ctrl.2: ──■──
-                      │  
-            ctrl.3: ──■──
-                    ┌─┴─┐
-          target.0: ┤ X ├
-                    └───┘
-        
-        We see no change here, because there was no free space to execute a more optimal mcx implementation. We can grant additional space using the ``workspace`` argument:
-        
-        >>> compiled_qc = ctrl.qs.compile(workspace = 2)
-        >>> compiled_qc.depth()
-        22
-        >>> print(compiled_qc)
-                     ┌────────┐               ┌────────┐          
-             ctrl.0: ┤0       ├───────────────┤0       ├──────────
-                     │        │               │        │          
-             ctrl.1: ┤1       ├───────────────┤1       ├──────────
-                     │        │┌────────┐     │        │┌────────┐
-             ctrl.2: ┤        ├┤0       ├─────┤        ├┤0       ├
-                     │  pt2cx ││        │     │  pt2cx ││        │
-             ctrl.3: ┤        ├┤1       ├─────┤        ├┤1       ├
-                     │        ││        │┌───┐│        ││        │
-           target.0: ┤        ├┤  pt2cx ├┤ X ├┤        ├┤  pt2cx ├
-                     │        ││        │└─┬─┘│        ││        │
-        workspace_0: ┤2       ├┤        ├──■──┤2       ├┤        ├
-                     └────────┘│        │  │  └────────┘│        │
-        workspace_1: ──────────┤2       ├──■────────────┤2       ├
-                               └────────┘               └────────┘
-        
-        Granting extra qubits to use this feature is however not usually necessary. The compiler automatically detects and reuses qubit resources available at the corresponding stage of the compilation.
-        To demonstrate this feature, we allocate a third QuantumVariable:
-        
-        >>> qv = QuantumVariable(2)
-        >>> cx(target[0], qv)
-        >>> print(ctrl.qs.compile())
-                  ┌────────┐               ┌────────┐                    
-          ctrl.0: ┤0       ├───────────────┤0       ├────────────────────
-                  │        │               │        │                    
-          ctrl.1: ┤1       ├───────────────┤1       ├────────────────────
-                  │        │┌────────┐     │        │┌────────┐          
-          ctrl.2: ┤        ├┤0       ├─────┤        ├┤0       ├──────────
-                  │  pt2cx ││        │     │  pt2cx ││        │          
-          ctrl.3: ┤        ├┤1       ├─────┤        ├┤1       ├──────────
-                  │        ││        │┌───┐│        ││        │          
-        target.0: ┤        ├┤  pt2cx ├┤ X ├┤        ├┤  pt2cx ├──■────■──
-                  │        ││        │└─┬─┘│        ││        │┌─┴─┐  │  
-            qv.0: ┤2       ├┤        ├──■──┤2       ├┤        ├┤ X ├──┼──
-                  └────────┘│        │  │  └────────┘│        │└───┘┌─┴─┐
-            qv.1: ──────────┤2       ├──■────────────┤2       ├─────┤ X ├
-                            └────────┘               └────────┘     └───┘
-        
-        We see how the qubits that will later hold ``qv`` are used to efficiently compile the mcx gate.
-        
-        In situations of no free clean ancilla qubits, the Qrisp compiler even makes use of dirty ancillae. To demonstrate, we again create three QuantumVariables
-        but this time we execute a :meth:`cx<qrisp.cx>`-gate before executing the :meth:`mcx<qrisp.mcx>`-gate. This way ``qv`` has to be allocated before the ``mcx`` gate.
-            
-        >>> ctrl = QuantumVariable(4)
-        >>> target = QuantumVariable(1)
-        >>> qv = QuantumVariable(2)
-        >>> cx(target[0], qv)
-        >>> mcx(ctrl, target)
-        >>> print(ctrl.qs.compile())
-          ctrl.0: ────────────────────────────────────■──────────────────────────»
-                                 ┌─────────────────┐  │  ┌─────────────────┐     »
-          ctrl.1: ───────────────┤1                ├──┼──┤1                ├─────»
-                                 │                 │  │  │                 │     »
-          ctrl.2: ───────────────┤2                ├──┼──┤2                ├─────»
-                                 │                 │  │  │                 │     »
-          ctrl.3: ────────────■──┤                 ├──┼──┤                 ├──■──»
-                            ┌─┴─┐│  reduced_maslov │  │  │  reduced_maslov │┌─┴─┐»
-        target.0: ──■────■──┤ X ├┤                 ├──┼──┤                 ├┤ X ├»
-                  ┌─┴─┐  │  └─┬─┘│                 │┌─┴─┐│                 │└─┬─┘»
-            qv.0: ┤ X ├──┼────┼──┤0                ├┤ X ├┤0                ├──┼──»
-                  └───┘┌─┴─┐  │  │                 │└───┘│                 │  │  »
-            qv.1: ─────┤ X ├──■──┤3                ├─────┤3                ├──■──»
-                       └───┘     └─────────────────┘     └─────────────────┘     »
-        «                                                     
-        «  ctrl.0: ─────────────────────■─────────────────────
-        «          ┌─────────────────┐  │  ┌─────────────────┐
-        «  ctrl.1: ┤1                ├──┼──┤1                ├
-        «          │                 │  │  │                 │
-        «  ctrl.2: ┤2                ├──┼──┤2                ├
-        «          │                 │  │  │                 │
-        «  ctrl.3: ┤                 ├──┼──┤                 ├
-        «          │  reduced_maslov │  │  │  reduced_maslov │
-        «target.0: ┤                 ├──┼──┤                 ├
-        «          │                 │┌─┴─┐│                 │
-        «    qv.0: ┤0                ├┤ X ├┤0                ├
-        «          │                 │└───┘│                 │
-        «    qv.1: ┤3                ├─────┤3                ├
-        «          └─────────────────┘     └─────────────────┘
-        
-        We see how the qubits of ``qv`` are utilized as dirty ancilla qubits in order to facilitate a more efficient ``mcx`` implementation compared to no ancillae at all.
-        
-        **Fully automized uncomputation**
-        
-        This feature is as of right now experimental. To demonstrate, we create a test function, creating a local :ref:`QuantumBool` ::
-            
-            from qrisp import QuantumBool, mcx
-            
-            def triple_AND(a, b, c):
-                
-                local = QuantumBool()
-                result = QuantumBool()
-                
-                mcx([a,b], local)
-                
-                mcx([c, local], result)
-                
-                return result
-                
-        
-        >>> a = QuantumBool()
-        >>> b = QuantumBool()
-        >>> c = QuantumBool()
-        >>> res = triple_AND(a,b,c)
-        >>> print(res.qs)
-        QuantumCircuit:
-        ---------------
-             a.0: ──■───────
-                    │       
-             b.0: ──■───────
-                    │       
-             c.0: ──┼────■──
-                  ┌─┴─┐  │  
-         local.0: ┤ X ├──■──
-                  └───┘┌─┴─┐
-        result.0: ─────┤ X ├
-                       └───┘
-        Live QuantumVariables:
-        ----------------------
-        QuantumBool a
-        QuantumBool b
-        QuantumBool c
-        QuantumBool local
-        QuantumBool result
-        
-        We now compile with the corresponding keyword argument:
-            
-        >>> print(a.qs.compile(disable_uncomputation = False))
-                     ┌────────┐     ┌────────┐
-                a.0: ┤0       ├─────┤0       ├
-                     │        │     │        │
-                b.0: ┤1       ├─────┤1       ├
-                     │        │     │        │
-                c.0: ┤  pt2cx ├──■──┤  pt2cx ├
-                     │        │┌─┴─┐│        │
-           result.0: ┤        ├┤ X ├┤        ├
-                     │        │└─┬─┘│        │
-        workspace_0: ┤2       ├──■──┤2       ├
-                     └────────┘     └────────┘
-        
-        We see that the ``local`` QuantumBool is no longer allocated but has been uncomputed and it's qubits are available as workspace.
-                     
-        
-        """
-        from qrisp.core.compilation import qompiler
-        
-        
-        return qompiler(self, 
-                        workspace, 
-                        disable_uncomputation=disable_uncomputation, 
-                        intended_measurements=intended_measurements, 
-                        cancel_qfts=cancel_qfts)
-    
-    def __del__(self):
-        i = 0
-        while i < len(self.qs_tracker):
-            if self.qs_tracker[i]() == None or id(self) == id(self.qs_tracker[i]()):
-                self.qs_tracker.pop(i)
-                continue
-            i += 1
-                
-    def __hash__(self):
-        return id(self.data)
-    
-    
-    #The .data attribute is used to identify QuantumSessions with each other even though they are different object
-    #If the .data attribute is set to a new list, this identification is no longer possible because the two different
-    #QuantumSession no longer share the same data list. We overload setattr such that setting a new list
-    #results in keeping the old one but with new content    
-    def __setattr__(self, name, value):
-        if name in ["data"]:
-            attr = self.__dict__[name]
-            attr.clear()
-            attr.extend(value)
-        else:
-            QuantumCircuit.__setattr__(self, name, value)
-          
-    @classmethod
-    def get_active_quantum_sessions(self):
-        
-        
-        #Remove potential duplicates
-        qs_list = list(set([qs() for qs in QuantumSession.qs_tracker if not qs() is None]))
-        
-        
-        self.qs_tracker = [weakref.ref(qs) for qs in qs_list]
-        
-        return qs_list
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+
+import copy
+import weakref
+
+import matplotlib.pyplot as plt
+import numpy as np
+
+from qrisp.core.compilation import qompiler
+
+
+class QuantumVariable:
+    """
+    The QuantumVariable is the quantum equivalent of a regular variable in classical
+    programming languages. All :ref:`quantum types <QuantumTypes>` inherit from this
+    class. The QuantumVariable allows many automizations and quality of life
+    improvements such as hidden qubit management, de/encoding to human readable labels
+    or typing.
+
+    Each QuantumVariable is registered in a :ref:`QuantumSession`. It can be accessed
+    using the ``.qs`` attribute:
+
+    >>> from qrisp import QuantumVariable
+    >>> example_qv = QuantumVariable(3)
+    >>> quantum_session = example_qv.qs
+
+    The qubits of the QuantumVariable are stored as a list in the ``.reg`` attribute
+
+    >>> qubits = example_qv.reg
+
+    To quickly access the qubits of a given variable, we use the [ ] operator:
+
+    >>> qubit_2 = example_qv[2]
+
+    We can find out about the amount of qubits in the QuantumVariable with the ``.size``
+    attribute
+
+    >>> example_qv.size
+    3
+
+    **Naming**
+
+    QuantumVariables can be given names to identify them independently of their naming
+    as Python objects.
+
+    >>> example_qv_2 = QuantumVariable(3, name = "alice")
+    >>> example_qv_2.name
+    'alice'
+
+    If not explicitely specified during construction, a name is determined
+    automatically. Qrisp will try to infer the name of the Python variable and if that
+    fails, a generic name is given.
+
+    >>> example_qv.name
+    'example_qv'
+
+    In order to keep the generated quantum circuits comprehensive, the qubits are named
+    after their containing QuantumVariable with an extra number, which indicates their
+    index.
+
+    >>> from qrisp import cx
+    >>> cx(example_qv, example_qv_2)
+    >>> print(example_qv.qs)
+    QuantumCircuit:
+    ---------------
+    example_qv.0: ──■────────────
+                    │
+    example_qv.1: ──┼────■───────
+                    │    │
+    example_qv.2: ──┼────┼────■──
+                  ┌─┴─┐  │    │
+         alice.0: ┤ X ├──┼────┼──
+                  └───┘┌─┴─┐  │
+         alice.1: ─────┤ X ├──┼──
+                       └───┘┌─┴─┐
+         alice.2: ──────────┤ X ├
+                            └───┘
+    Live QuantumVariables:
+    ----------------------
+    QuantumVariable example_qv
+    QuantumVariable alice
+
+    QuantumSessions can only contain uniquely named QuantumVariables. If two
+    QuantumSessions are :ref:`merged <SessionMerging>` containing identically named
+    QuantumVariables, the more recently created QuantumVariable will be renamed:
+
+    ::
+
+        from qrisp import QuantumFloat
+
+        s = QuantumFloat(5)
+
+        for i in range(4):
+            temp = QuantumFloat(4)
+            temp[:] = 2**i
+            s += temp
+
+    >>> print(s.qs)
+    QuantumCircuit:
+    ---------------
+                   ┌───────────┐┌───────────┐┌───────────┐┌───────────┐
+         s.0: ─────┤0          ├┤0          ├┤0          ├┤0          ├
+                   │           ││           ││           ││           │
+         s.1: ─────┤1          ├┤1          ├┤1          ├┤1          ├
+                   │           ││           ││           ││           │
+         s.2: ─────┤2          ├┤2          ├┤2          ├┤2          ├
+                   │           ││           ││           ││           │
+         s.3: ─────┤3          ├┤3          ├┤3          ├┤3          ├
+                   │           ││           ││           ││           │
+         s.4: ─────┤4 __iadd__ ├┤4          ├┤4          ├┤4          ├
+              ┌───┐│           ││           ││           ││           │
+      temp.0: ┤ X ├┤5          ├┤           ├┤           ├┤           ├
+              └───┘│           ││           ││           ││           │
+      temp.1: ─────┤6          ├┤  __iadd__ ├┤           ├┤           ├
+                   │           ││           ││           ││           │
+      temp.2: ─────┤7          ├┤           ├┤           ├┤           ├
+                   │           ││           ││           ││           │
+      temp.3: ─────┤8          ├┤           ├┤  __iadd__ ├┤           ├
+                   └───────────┘│           ││           ││           │
+    temp_1.0: ──────────────────┤5          ├┤           ├┤           ├
+              ┌───┐             │           ││           ││           │
+    temp_1.1: ┤ X ├─────────────┤6          ├┤           ├┤  __iadd__ ├
+              └───┘             │           ││           ││           │
+    temp_1.2: ──────────────────┤7          ├┤           ├┤           ├
+                                │           ││           ││           │
+    temp_1.3: ──────────────────┤8          ├┤           ├┤           ├
+                                └───────────┘│           ││           │
+    temp_2.0: ───────────────────────────────┤5          ├┤           ├
+                                             │           ││           │
+    temp_2.1: ───────────────────────────────┤6          ├┤           ├
+              ┌───┐                          │           ││           │
+    temp_2.2: ┤ X ├──────────────────────────┤7          ├┤           ├
+              └───┘                          │           ││           │
+    temp_2.3: ───────────────────────────────┤8          ├┤           ├
+                                             └───────────┘│           │
+    temp_3.0: ────────────────────────────────────────────┤5          ├
+                                                          │           │
+    temp_3.1: ────────────────────────────────────────────┤6          ├
+                                                          │           │
+    temp_3.2: ────────────────────────────────────────────┤7          ├
+              ┌───┐                                       │           │
+    temp_3.3: ┤ X ├───────────────────────────────────────┤8          ├
+              └───┘                                       └───────────┘
+    Live QuantumVariables:
+    ----------------------
+    QuantumFloat s
+    QuantumFloat temp
+    QuantumFloat temp_1
+    QuantumFloat temp_2
+    QuantumFloat temp_3
+
+    Renaming does not happen for names given through the ``name`` keyword, unless the
+    name ends with a ``*``.
+
+    >>> example_qv_3 = QuantumVariable(3, name = "alice")
+    >>> cx(example_qv, example_qv_3)
+    Exception: Tried to merge QuantumSession containing identically named
+    QuantumVariables
+    >>> example_qv_4 = QuantumVariable(3, name = "alice*")
+    >>> cx(example_qv, example_qv_4)
+    >>> example_qv_4.name
+    'alice_1'
+
+
+    Examples
+    --------
+
+    Writing a function that brings an arbitrary QuantumVariable into a GHZ state
+
+    ::
+
+        from qrisp import QuantumVariable, h, cx
+        def GHZ(qv):
+             h(qv[0])
+             for i in range(1, qv.size):
+                 cx(qv[0], qv[i])
+
+    Evaluation:
+
+    >>> qv = QuantumVariable(5)
+    >>> GHZ(qv)
+    >>> print(qv)
+    {'00000': 0.5, '11111': 0.5}
+
+
+    """
+
+    live_qvs = []
+    creation_counter = np.zeros(1)
+    name_tracker = {}
+
+    def __init__(self, size, qs=None, name=None):
+        r"""
+        Constructs a QuantumVariable - possibly with a given name or in a given
+        QuantumSession.
+
+        Parameters
+        ----------
+        size : int
+            The amount of qubits this QuantumVariable contains.
+        qs : QuantumSession, optional
+            A QuantumSession object, where the QuantumVariable is supposed to be
+            registered. The default is None.
+        name : string, optional
+            A name which uniquely identifies the QuantumVariable. If ended with a
+            \*, name is allowed to be updated if a naming collision arises. By default,
+            Qrisp will try to infer the name of the Python variable - otherwise a
+            generic name is given.
+
+        """
+
+        if size < 0:
+            raise Exception(
+                f"Tried to create QuantumVariable with invalid qubit amount {size}"
+            )
+
+        # Store quantum session
+        from qrisp.core import QuantumSession, merge_sessions
+
+        self.qs = QuantumSession()
+
+        if qs is not None:
+            merge_sessions(self.qs, qs)
+
+        self.size = int(size)
+
+        self.user_given_name = False
+        # If name is given, register variable in session manager
+        if name is not None:
+            self.user_given_name = True
+
+            if name[-1] == "*":
+                name = name[:-1]
+                self.user_given_name = False
+
+                try:
+                    self.name = name
+                    self.qs.register_qv(self)
+
+                except RuntimeError:
+                    i = 0
+                    while True:
+                        try:
+                            self.name = name + "_" + str(i)
+                            self.qs.register_qv(self)
+                        except RuntimeError:
+                            i += 1
+                            continue
+                        break
+
+            else:
+                self.name = name
+                self.qs.register_qv(self)
+
+        # Otherwise try to infer from code inspection
+        else:
+            from qrisp.misc import find_calling_line
+
+            if type(self) is QuantumVariable:
+                line = find_calling_line(1)
+            else:
+                line = find_calling_line(2)
+            split_line = line.split("=")
+            name_found = False
+
+            if len(split_line) >= 2:
+                python_var_name = split_line[0]
+
+                if split_line[1].replace(" ", "")[:7] == "Quantum":
+                    python_var_name = python_var_name.split(" ")[0]
+                    python_var_name = python_var_name.split(" ")[-1]
+
+                    # name = self.get_unique_name(python_var_name)
+                    name = python_var_name
+
+                    self.name = name
+                    self.qs.register_qv(self)
+                    name_found = True
+
+            # If this didn't work, generate a generic, unique name
+            if not name_found:
+                while True:
+                    try:
+                        self.name = self.get_unique_name()
+                        self.qs.register_qv(self)
+                        break
+                    except RuntimeError:
+                        pass
+
+        import weakref
+
+        # This attribute tracks the created QuantumVariables for the
+        # auto_uncompute decorator
+        # We use weak references as some qrisp modules rely on reference counting
+        QuantumVariable.live_qvs.append(weakref.ref(self))
+        self.creation_time = int(self.creation_counter[0])
+        self.creation_counter += 1
+
+    def delete(self, verify=False, recompute=False):
+        r"""
+        This method is for deleting a QuantumVariable and thus freeing up and resetting
+        the used qubits.
+
+        Note that this method has a different function than the destructor. Calling this
+        method will tell the QuantumSession to mark the used qubits as free and apply a
+        reset gate.
+        If set to True, the keyword verify will cause a simulation to check, wether the
+        deleted qubits are in the $\ket{0}$ state prior to resetting. This is helpfull
+        during debugging, as it indicates wether the uncomputation of this
+        QuantumVariable was successfull.
+
+        After deletion, the QuantumVariable object is basically unchanged but an error
+        will be raised if further operations on the deleted qubits are attempted.
+
+        Parameters
+        ----------
+        verify : bool, optional
+            If this bool is set to True, Qrisp will verify that the deleted qubits are
+            indeed in the $\ket{0}$ state. The default is ``False``.
+        recompute : bool, optional
+            If set to ``True``, this QuantumVariable can be recomputed if it is required
+            for the uncomputation of another QuantumVariable. For more information on
+            the (dis)advantages check :ref:`recomputation <recomputation>`. The default
+            is ``False``.
+
+        Raises
+        ------
+        Exception
+            Tried to delete qubits not in \|0> state.
+
+
+        Examples
+        --------
+
+        We create a QuantumVariable, execute some gates and try to delete with
+        verify = True
+
+        >>> from qrisp import QuantumVariable, x, h
+        >>> qv = QuantumVariable(2)
+        >>> x(qv[0])
+        >>> h(qv[1])
+        >>> qv.delete(verify = True)
+        Exception: Tried to delete qubits not in |0> state.
+
+        We now (manually) uncompute the gates
+
+        >>> x(qv[0])
+        >>> h(qv[1])
+        >>> qv.delete(verify = True)
+        >>> qv.is_deleted()
+        True
+        >>> x(qv[0])
+        Exception: Tried to perform operation x on unallocated qubit qv_1.0.
+
+        """
+
+        if self.is_deleted():
+            return
+
+        self.qs.delete_qv(self, verify)
+
+        i = 0
+        while i < len(QuantumVariable.live_qvs):
+            if QuantumVariable.live_qvs[i]() is None:
+                QuantumVariable.live_qvs.pop(i)
+                continue
+
+            if QuantumVariable.live_qvs[i]().name == self.name:
+                QuantumVariable.live_qvs.pop(i)
+                break
+
+            i += 1
+
+        if recompute:
+            for qb in self.reg:
+                qb.recompute = True
+
+    def is_deleted(self):
+        for qb in self.reg:
+            if qb.allocated:
+                return False
+        else:
+            return True
+
+    def duplicate(self, name=None, qs=None, init=False):
+        r"""
+        Duplicates the QuantumVariable in the sense that a new QuantumVariable is
+        created with same type and parameters but initialized in the $\ket{0}$ state.
+
+        Parameters
+        ----------
+        name : string, optional
+            A unique name to identify that QuantumVariable. If not given, a name will be
+            generated.
+        qs : QuantumSession, optional
+            A QuantumSession, where the result should be registered. If not given, a new
+            QuantumSession will be generated.
+        init : bool, optional
+            If set to True, the :meth:`init_from <qrisp.QuantumVariable.init_from>`
+            method of the result will be called on self. The default is False.
+
+        Returns
+        -------
+        duplicate : Type of self
+            The duplicated QuantumVariable.
+
+        Examples
+        --------
+
+        We create a QuantumFloat and duplicate:
+
+        >>> from qrisp import QuantumFloat
+        >>> qf_0 = QuantumFloat(4, signed = False)
+        >>> qf_1 = qf_0.duplicate()
+        >>> type(qf_1)
+        qrisp.qtypes.quantum_float.QuantumFloat
+        >>> qf_1.size
+        4
+
+        """
+
+        duplicate = copy.copy(self)
+
+        from qrisp.core import QuantumSession
+
+        new_qs = QuantumSession()
+
+        # Register duplicate variable in session manager
+
+        if name is not None:
+            duplicate.name = name
+            new_qs.register_qv(duplicate)
+            duplicate.user_given_name = True
+
+        else:
+            duplicate.user_given_name = False
+
+            try:
+                duplicate.name = self.name
+                new_qs.register_qv(duplicate)
+            except NameError:
+                i = 0
+                while True:
+                    try:
+                        duplicate.name = self.name + "_" + str(i)
+                        new_qs.register_qv(duplicate)
+                        break
+                    except NameError:
+                        pass
+                    i += 1
+
+        from qrisp import merge
+
+        duplicate.qs = new_qs
+
+        if qs is not None:
+            merge(qs, new_qs)
+
+        # This attribute tracks the created QuantumVariables for the
+        # auto_uncompute decorator
+        # We use weak references as some qrisp modules rely on reference counting
+        QuantumVariable.live_qvs.append(weakref.ref(duplicate))
+        duplicate.creation_time = int(self.creation_counter[0])
+        duplicate.creation_counter += 1
+
+        if init:
+            duplicate.init_from(self)
+
+        return duplicate
+
+    def decoder(self, i):
+        """
+        The decoder method specifies how a QuantumVariable turns the outcomes of
+        measurements into human-readable values. It recieves an integer ``i`` and
+        returns a human-readable value.
+
+        This method is supposed to be overloaded when defining new
+        :ref:`quantum types <QuantumTypes>`.
+
+
+        Parameters
+        ----------
+        i : int
+            Integer representing the outcome of a measurement of the qubits of this
+            QuantumVariable.
+
+        Returns
+        -------
+
+            A human-readable value. Has to be hashable.
+
+        Examples
+        --------
+
+        We create a QuantumFloat and inspect its decoder:
+
+        >>> from qrisp import QuantumFloat
+        >>> qf = QuantumFloat(3, -1, signed = False)
+        >>> print(qf.decoder(1))
+        0.5
+
+        This implies that if the 3 qubits of this QuantumFloat are measured in state
+        001, this outcome corresponds to the value 0.5.
+        """
+
+        from qrisp.misc import bin_rep
+
+        return bin_rep(i, self.size)[::-1]
+
+    def encoder(self, value):
+        """
+        The encoder reverses the decoder, it turns human-readable values into integers.
+
+        If not overloaded, the encoder will perform a linear search on decoder inputs to
+        match the given value.
+
+        Parameters
+        ----------
+        label :
+            A human-readable value.
+
+        Raises
+        ------
+        Exception
+            Unknown input value.
+
+        Returns
+        -------
+        i : int
+            The integer encoding the given value.
+
+        Examples
+        --------
+
+        We create a QuantumChar and inspect it's encoder:
+
+        >>> from qrisp import QuantumChar
+        >>> q_ch = QuantumChar()
+        >>> print(q_ch.encoder("f"))
+        5
+
+        This implies that if the 5 qubits of this QuantumChar are measured to
+        ``5 = 00101``, the out come will be displayed as f.
+
+        """
+        for i in range(2**self.size):
+            if self.decoder(i) == value:
+                return i
+
+        raise Exception("Value " + str(value) + " not supported by encoder.")
+
+    def encode(self, value):
+        """
+        The encode method allows to quickly bring a QuantumVariable in a desired
+        computational basis state.
+
+        A shorthand for this method is given by the ``[:]`` operator.
+
+        Note that the qubits to initialize have to be fresh (i.e. no operations
+        performed on them).
+
+        Parameters
+        ----------
+        value :
+            A value supported by the encoder.
+
+        Returns
+        -------
+        None.
+
+        Examples
+        --------
+
+        We create two quantum floats and encode the value 2.5. For one of them, we
+        perform an x gate onto the corresponding qubits, resulting in an error.
+
+        >>> from qrisp import QuantumFloat, x
+        >>> qf_0 = QuantumFloat(3, -1, signed = False)
+        >>> qf_1 = QuantumFloat(3, -1, signed = False)
+        >>> x(qf_0)
+        >>> qf_0.encode(2.5)
+        Exception: Tried to initialize qubits which are not fresh anymore.
+        >>> qf_1[:] = 2.5
+        >>> print(qf_1)
+        {2.5: 1.0}
+
+        """
+
+        from qrisp.misc import check_if_fresh, int_encoder
+
+        if not check_if_fresh(self.reg, self.qs):
+            raise Exception("Tried to initialize qubits which are not fresh anymore.")
+
+        int_encoder(self, self.encoder(value))
+
+    def init_state(self, state_dic):
+        r"""
+        The ``init_state`` method allows the initialization of arbitrary quantum states.
+        It recieves a dictionary of the type
+
+        **{value : complex number}**
+
+        and initializes the **normalized** state. Amplitudes not specified are assumed
+        to be zero.
+
+        Note that the state initialization algorithm requires it's qubits to be in
+        state $\ket{0}$.
+
+        A shorthand for this method is the ``[:]`` operator, when handed the
+        corresponding dictionary
+
+        Parameters
+        ----------
+        state_dic : dict
+            Dictionary describing the wave function to be initialized.
+
+        Raises
+        ------
+        Exception
+            Tried to initialize qubits which are not fresh anymore.
+
+        Examples
+        --------
+
+        We create a QuantumFloat and encode the state
+
+        .. math::
+
+            \ket{\psi} = \sqrt{\frac{1}{3}} \ket{0.5} + i\sqrt{\frac{2}{3}} \ket{2}
+
+        >>> from qrisp import QuantumFloat
+        >>> qf = QuantumFloat(3, -1)
+
+        We can now use either
+
+        >>> qf.init_state({0.5: (1/3)**0.5, 2.0 : 1j*(2/3)**0.5})
+
+        or:
+
+        >>> qf[:] = {0.5: (1/3)**0.5, 2.0 : 1j*(2/3)**0.5}
+
+        To acquire the expected result
+
+        >>> print(qf)
+        {2.0: 0.6667, 0.5: 0.3333}
+
+        """
+
+        from qrisp.misc import check_if_fresh
+
+        if not check_if_fresh(self.reg, self.qs):
+            raise Exception("Tried to initialize qubits which are not fresh anymore.")
+
+        from qrisp import init_state
+
+        target_array = np.zeros(2**self.size, dtype=np.complex128)
+
+        for key in state_dic.keys():
+            target_array[self.encoder(key)] = state_dic[key]
+
+        target_array = target_array / np.vdot(target_array, target_array) ** 0.5
+
+        init_state(self, target_array)
+
+    def append(self, operation):
+        self.qs.append(operation, self)
+
+    def extend(self, amount, position=-1):
+        """
+        This method is used to add more qubits to the QuantumVariable. Using the
+        position keyword it is possible to specify the position where the qubits should
+        be added. By default, the qubits are added at the end.
+
+        Parameters
+        ----------
+        amount : int
+            The amount of qubits to add.
+        position : int, optional
+            The position of where to add the qubits. By default, qubits are added at the
+            end.
+            st of qubits which are to be added to the QuantumVariable.
+            The default is None.
+
+        Raises
+        ------
+        Exception
+            Missmatch between proposed qubits and amount integer.
+
+        Returns
+        -------
+        None.
+
+        Examples
+        --------
+
+        We create a QuantumVariable and extend it with some extra qubits.
+
+        >>> from qrisp import QuantumVariable
+        >>> qv = QuantumVariable(3)
+        >>> print(qv.reg)
+        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2)]
+        >>> qv.extend(3)
+        >>> print(qv.reg)
+        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2), Qubit(qv.6), Qubit(qv.6), Qubit(qv.6)]
+
+        """
+
+        if position == -1:
+            position = self.size
+
+        insertion_qubits = self.qs.request_qubits(amount)
+
+        for i in range(amount):
+            insertion_qubits[i].identifier = self.name + "." + str(self.size)
+            self.reg.insert(position + i, insertion_qubits[i])
+            self.size += 1
+
+    def reduce(self, qubits, verify=False):
+        r"""
+        Reduces the qubit count of the QuantumVariable by removing a specified set of
+        qubits.
+
+        Parameters
+        ----------
+        qubits : list
+            The qubits to remove from the QuantumVariable.
+
+        verify : bool
+            Boolean value which indicates wether Qrisp should verify that the reduced
+            qubits are in the $\ket{0}$ state.
+
+        Raises
+        ------
+        Exception
+            Qubits not present in QuantumVariable.
+
+        Exception
+            Verification that the given qubits are in $\ket{0}$ state failed.
+
+        Examples
+        --------
+
+        We create a QuantumVariable with 5 qubits and remove the first 2
+
+        >>> from qrisp import QuantumVariable
+        >>> qv = QuantumVariable(5)
+        >>> print(qv.reg)
+        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2), Qubit(qv.3), Qubit(qv.4)]
+        >>> qv.reduce(qv[:2])
+        >>> print(qv.reg)
+        [Qubit(qv.2), Qubit(qv.3), Qubit(qv.4)]
+
+        """
+
+        try:
+            len(qubits)
+        except TypeError:
+            qubits = [qubits]
+
+        if not set(qubits).issubset(self.reg):
+            raise Exception("Tried to reduce QuantumVariable by invalid qubits")
+
+        # Find Qubits to be cleared
+        for i in range(len(qubits)):
+            for j in range(self.size):
+                if self.reg[j] == qubits[i]:
+                    self.reg[j].identifier = "qb_" + str(self.qs.qubit_index_counter[0])
+                    self.qs.qubit_index_counter += 1
+                    self.reg.pop(j)
+                    break
+
+        self.qs.clear_qubits(qubits, verify)
+        # Adjust variable size
+        self.size -= len(qubits)
+
+    def get_measurement(
+        self,
+        plot=False,
+        backend=None,
+        shots=10000,
+        compile=True,
+        compilation_kwargs={},
+        subs_dic={},
+        circuit_preprocessor=None,
+        filename=None,
+    ):
+        r"""
+        Method for quick access to the measurement results of the state of the variable.
+        This method returns a dictionary of the type {value : p} where p indicates the
+        probability with which that value is measured.
+
+
+        Parameters
+        ----------
+        plot : Bool, optional
+            Plots the measurement results as a historgram. The default is False.
+        backend : BackendClient, optional
+            The backend on which to evaluate the quantum circuit. The default can be
+            specified in the file default_backend.py.
+        shots : integer, optional
+            The amount of shots to evaluate the circuit. The default is 10000.
+        compile : bool, optional
+            Boolean indicating if the .compile method of the underlying QuantumSession
+            should be called before. The default is True.
+        compilation_kwargs  : dict, optional
+            Keyword arguments for the compile method. For more details check
+            :meth:`QuantumSession.compile <qrisp.QuantumSession.compile>`. The default
+            is ``{}``.
+        subs_dic : dict, optional
+            A dictionary of Sympy symbols and floats to specify parameters in the case
+            of a circuit with unspecified, :ref:`abstract parameters<QuantumCircuit>`.
+            The default is {}.
+        circuit_preprocessor : Python function, optional
+            A function which recieves a QuantumCircuit and returns one, which is applied
+            after compilation and parameter substitution. The default is None.
+        filename : string, optional
+            The location of where to save a generated plot. The default is None.
+
+        Raises
+        ------
+        Exception
+            If the containing QuantumSession is in a quantum environment, it is not
+            possible to execute measurements.
+
+        Returns
+        -------
+        dict
+            A dictionary of values and their corresponding measurement probabilities.
+
+        Examples
+        --------
+
+        We create an integer :ref:`QuantumFloat`, encode the value 1 and bring the qubit
+        with significance 2 in superposition. We utilize the Qiskit transpiler by
+        transpiling into the gate set $\{\text{CX}, \text{U}\}$
+
+        >>> from qrisp import QuantumFloat, h
+        >>> qf = QuantumFloat(3,-1)
+        >>> qf[:] = 1
+        >>> h(qf[2])
+        >>> mes_results = qf.get_measurement(transpilation_kwargs = {"basis_gates" : ["cx", "u"]})  # noqa:501
+        >>> print(mes_results)
+        {1.0: 0.5, 3.0: 0.5}
+        """
+
+        if backend is None:
+            if self.qs.backend is None:
+                from qrisp.default_backend import def_backend
+
+                backend = def_backend
+            else:
+                backend = self.qs.backend
+
+        if len(self.qs.env_stack) != 0:
+            raise Exception("Tried to get measurement within open environment")
+
+        if self.is_deleted():
+            raise Exception("Tried to get measurement from deleted QuantumVariable")
+
+        if self.size == 0:
+            return {"": 1.0}
+
+        # Bind parameters
+        if subs_dic:
+            qc = self.qs.bind_parameters(subs_dic)
+
+        else:
+            if compile:
+                qc = qompiler(
+                    self.qs, intended_measurements=self.reg, **compilation_kwargs
+                )
+            else:
+                qc = self.qs.copy()
+
+        # Copy circuit in over to prevent modification
+        from qrisp.quantum_network import QuantumNetworkClient
+
+        if isinstance(backend, QuantumNetworkClient):
+            self.qs.data = []
+            shots = 1
+
+        # Execute user specified circuit_preprocessor
+        if circuit_preprocessor is not None:
+            qc = circuit_preprocessor(qc)
+
+        qc = qc.transpile()
+
+        from qrisp.misc import get_measurement_from_qc
+
+        counts = get_measurement_from_qc(qc, self.reg, backend, shots)
+
+        # Insert outcome labels (if available and hashable)
+        try:
+            new_counts_dic = {}
+
+            sorted_keys = list(counts.keys())
+            sorted_keys.sort()
+
+            for key in sorted_keys:
+                new_counts_dic[self.decoder(key)] = counts[key]
+
+            counts = new_counts_dic
+
+            # Sort keys
+            sorted_key_list = list(counts.keys())
+            sorted_key_list.sort(key=lambda x: -counts[x])
+            counts = {key: counts[key] for key in sorted_key_list}
+
+        except TypeError:
+            counts_tuple_list = []
+
+            for key in counts.keys():
+                counts_tuple_list.append((key, counts[key]))
+
+            counts = counts_tuple_list
+
+            counts.sorted(key=lambda x: x[1])
+
+        if plot:
+            outcome_labels = []
+            for i in range(2**self.size):
+                temp = self.decoder(i)
+                try:
+                    hash(temp)
+                except TypeError:
+                    raise Exception(
+                        "Outcome value " + str(self.decoder(i)) + " is not hashable"
+                    )
+
+                outcome_labels.append(temp)
+
+            if outcome_labels[0] == int(self.size) * "0":
+                outcome_labels = list(range(2**self.size))
+            plot_histogram(outcome_labels, counts, filename)
+            plt.show()
+
+        # Return dictionary of measurement results
+        return counts
+
+    def most_likely(self, **kwargs):
+        """
+        Performs a measurement and returns the most likely outcome.
+
+        Parameters
+        ----------
+        **kwargs : Keyword arguments for the get_measurement call.
+
+        Examples
+        --------
+
+        >>> from qrisp import QuantumFloat, ry
+        >>> import numpy as np
+        >>> qf = QuantumFloat(3)
+        >>> ry(np.pi*9/8, qf[0])
+        >>> print(qf)
+        {1: 0.9619, 0: 0.0381}
+        >>> qf.most_likely()
+        1
+
+        """
+
+        return list(self.get_measurement())[0]
+
+    def __getitem__(self, key):
+        return self.reg[key]
+
+    def __str__(self):
+        return str(self.get_measurement())
+
+    def __repr__(self):
+        return "<" + str(type(self)).split(".")[-1][:-2] + " '" + self.name + "'>"
+        return str(type(self)).split(".")[-1][:-2] + "(name = " + self.name + ")"
+        return str(self)
+
+    def __len__(self):
+        return self.size
+
+    # Overload equality operator to use python syntax for if environments?
+    # Not sure if the possible user confusion is worth it
+    def __eq__(self, other):
+        from qrisp.environments import q_eq
+
+        return q_eq(self, other)
+
+    def __hash__(self):
+        return id(self)
+
+    def __setitem__(self, key, value):
+        if key != slice(None, None, None):
+            raise Exception(
+                "Tried to encode value into QuantumVariable using non-trivial slicing."
+            )
+
+        if isinstance(type(value), type(None)):
+            return
+
+        if isinstance(value, dict):
+            self.init_state(value)
+            return
+
+        if isinstance(value, QuantumVariable):
+            self.init_from(value)
+            return
+
+        self.encode(value)
+
+    def app_phase_function(self, phi):
+        r"""
+        Applies a previously specified phase function to each computational basis state
+        of the QuantumVariable using Gray-Synthesis.
+
+        For a given phase function $\phi(x)$ and a QuantumVariable in state
+        $\ket{\psi} = \sum_{x \in \text{Labels}} a_x \ket{x}$  this method acts as:
+
+        .. math::
+
+            U_{\phi} \sum_{x \in \text{Labels}} a_x \ket{x} =
+            \sum_{x \in \text{Labels}} \text{exp}(i\phi(x)) a_x \ket{x}
+
+        Parameters
+        ----------
+        phi : Python function
+            A Python function which turns the labels of the QuantumVariable into floats.
+
+        Examples
+        --------
+
+        We create a QuantumFloat and encode the k-th basis state of the Fourier basis.
+        Finally, we will apply an inverse Fourier transformation to measure k in the
+        computational basis.
+
+        >>> import numpy as np
+        >>> from qrisp import QuantumFloat, h, QFT
+        >>> n = 5
+        >>> qf = QuantumFloat(n, signed = False)
+        >>> h(qf)
+
+        After this, qf is in the state
+
+        .. math::
+
+            \ket{\text{qf}} = \frac{1}{\sqrt{2^n}} \sum_{x = 0}^{2^n} \ket{x}
+
+        We specify phi
+
+        >>> k = 4
+        >>> def phi(x):
+        >>>     return 2*np.pi*x*k/2**n
+
+        And apply phi as a phase function
+
+        >>> qf.app_phase_function(phi)
+
+        qf is now in the state
+
+        .. math::
+
+            \ket{\text{qf}} = \frac{1}{\sqrt{2^n}} \sum_{x = 0}^{2^n}
+            \text{exp}\left( \frac{2\pi ikx}{2^n}\right) \ket{x}
+
+
+        Finally we apply the inverse Fourier transformation and measure:
+
+        >>> QFT(qf, inv = True)
+        >>> print(qf)
+        {4: 1.0}
+
+
+        """
+
+        from qrisp.misc import app_phase_function
+
+        app_phase_function([self], phi)
+
+    def uncompute(self, do_it=True, recompute=False):
+        """
+        Method for automatic uncomputation. Uses a generalized form of
+        `this algorithm <https://dl.acm.org/doi/10.1145/3453483.3454040>`_.
+
+        For more information check the
+        :ref:`uncomputation documentation<uncomputation>`.
+
+        Parameters
+        ----------
+        do_it : bool, optional
+            If set to False, this variable will be appended to the uncomputation stack
+            of it's QuantumSession and uncomputed once an uncompute call with
+            ``do_it = True`` is performed. The default is True.
+        recompute : bool, optional
+            If set to True, this QuantumVariable will be uncomputed but temporarily
+            recomputed, if it is required for the uncomputation of another
+            QuantumVariable. For more information check
+            :ref:`recomputation <recomputation>`. The default is False.
+
+        Examples
+        --------
+
+        We create two QuantumVariables, apply some gates and perform automatic
+        uncomputation:
+
+        >>> from qrisp import QuantumVariable, x, cx, h, p, mcx
+        >>> a = QuantumVariable(3)
+        >>> b = QuantumVariable(2)
+        >>> mcx(a, b[0])
+        >>> h(a[:2])
+        >>> x(b[0])
+        >>> cx(b[0], b[1])
+        >>> p(0.5, b[1])
+        >>> print(a.qs)
+        QuantumCircuit:
+        ---------------
+                  ┌───┐
+        a.0: ──■──┤ H ├───────────────
+               │  ├───┤
+        a.1: ──■──┤ H ├───────────────
+               │  └───┘
+        a.2: ──■──────────────────────
+             ┌─┴─┐┌───┐
+        b.0: ┤ X ├┤ X ├──■────────────
+             └───┘└───┘┌─┴─┐┌────────┐
+        b.1: ──────────┤ X ├┤ P(0.5) ├
+                       └───┘└────────┘
+        Live QuantumVariables:
+        ----------------------
+        QuantumVariable a
+        QuantumVariable b
+
+        >>> b.uncompute()
+        >>> print(b.qs)
+        QuantumCircuit:
+        ---------------
+             ┌────────┐                              ┌────────┐┌───┐
+        a.0: ┤0       ├──────────────────────────────┤0       ├┤ H ├
+             │        │                              │        │├───┤
+        a.1: ┤1       ├──────────────────────────────┤1       ├┤ H ├
+             │  pt3cx │                              │  pt3cx │└───┘
+        a.2: ┤2       ├──────────────────────────────┤2       ├─────
+             │        │┌───┐                    ┌───┐│        │
+        b.0: ┤3       ├┤ X ├──■──────────────■──┤ X ├┤3       ├─────
+             └────────┘└───┘┌─┴─┐┌────────┐┌─┴─┐└───┘└────────┘
+        b.1: ───────────────┤ X ├┤ P(0.5) ├┤ X ├────────────────────
+                            └───┘└────────┘└───┘
+        Live QuantumVariables:
+        ----------------------
+        QuantumVariable a
+
+
+        """
+
+        if self.is_deleted():
+            raise Exception("Tried to uncompute deleted QuantumVariable")
+
+        if do_it:
+            from qrisp.uncomputation import uncompute
+
+            uncompute(self.qs, self.qs.uncomp_stack + [self], recompute)
+            self.qs.uncomp_stack = []
+        else:
+            self.qs.uncomp_stack.append(self)
+
+    def get_unique_name(self, name=None):
+        if name is None:
+            from qrisp import QuantumBool, QuantumChar, QuantumFloat
+
+            if isinstance(self, QuantumBool):
+                name = "qbl"
+            elif isinstance(self, QuantumFloat):
+                name = "qf"
+            elif isinstance(self, QuantumChar):
+                name = "qch"
+            else:
+                name = "qv"
+
+        while True:
+            try:
+                naming_number = self.name_tracker[name]
+                self.name_tracker[name] += 1
+                name = name + "_" + str(naming_number)
+            except KeyError:
+                self.name_tracker[name] = 1
+                name = name + "_0"
+
+            i = 0
+            while i < len(QuantumVariable.live_qvs):
+                qv = QuantumVariable.live_qvs[i]()
+                if qv is None:
+                    QuantumVariable.live_qvs.pop(i)
+                    continue
+                if qv.name == name:
+                    break
+                i += 1
+            else:
+                break
+
+        return name
+
+    def init_from(self, other):
+        r"""
+        Method to initiate a QuantumVariable based on the state of another. This method
+        does NOT copy the state. Much rather it performs the operation
+
+
+        .. math::
+
+            U_{\text{init_from}} \left( \sum_{x \in \text{labels}} a_x \ket{x}
+            \right)  \ket{0} = \sum_{x \in \text{labels}} a_x \ket{x} \ket{x}
+
+
+        This is different from a state copying operation:
+
+        .. math::
+
+            U_{\text{copy}} \left( \sum_{x \in \text{labels}} a_x \ket{x} \right)
+            \ket{0} = \left( \sum_{x \in \text{labels}} a_x \ket{x} \right)
+            \left( \sum_{x \in \text{labels}} a_x \ket{x} \right)
+
+
+        A shorthand for initiating this way is the ``[:]`` operator.
+
+
+        Parameters
+        ----------
+        other : QuantumVariable
+            The QuantumVariable from which to initiate.
+
+        Raises
+        ------
+        Exception
+            Tried to initialize qubits which are not fresh anymore.
+
+        Examples
+        --------
+
+        We create a QuantumFloat, and bring it into superposition.
+
+        >>> from qrisp import QuantumFloat, h, multi_measurement
+        >>> qf_a = QuantumFloat(8)
+        >>> qf_a[:] = 6
+        >>> h(qf_a[0])
+        >>> print(qf_a)
+        {6: 0.5, 7: 0.5}
+
+        We now duplicate and initiate the duplicate
+
+        >>> qf_b = qf_a.duplicate()
+        >>> print(qf_b)
+        {0: 1.0}
+        >>> qf_b.init_from(qf_a)
+        >>> print(multi_measurement([qf_a, qf_b]))
+        {(6, 6): 0.5, (7, 7): 0.5}
+
+        The slicing operator achieves the same:
+
+        >>> qf_c = qf_a.duplicate()
+        >>> qf_c[:] = qf_b
+        >>> print(multi_measurement([qf_a, qf_b, qf_c]))
+        {(6, 6, 6): 0.5, (7, 7, 7): 0.5}
+
+
+
+        """
+
+        if not type(self) == type(other):
+            raise Exception(
+                "Tried to initialize " + str(type(self)) + " from " + str(type(other))
+            )
+
+        from qrisp.misc import check_if_fresh
+
+        if not check_if_fresh(self.reg, self.qs):
+            raise Exception("Tried to initialize qubits which are not fresh anymore")
+
+        self.qs.cx(other.reg, self.reg)
+
+    @classmethod
+    def custom(self, label_list, decoder=None, qs=None, name=None):
+        """
+        Creates a QuantumVariable with customized outcome labels.
+
+        Note that this is a class method, implying there is no need to create another
+        QuantumVariable first to call this method.
+
+        Parameters
+        ----------
+        label_list : list
+            A list of outcome labels.
+        decoder : function, optional
+            The decoder function. If given none, the labels will be encoded according to
+            their placement in the ``label_list``.
+        qs : QuantumSession, optional
+            The :ref:`QuantumSession` in which to register the customized
+            QuantumVariable. If given none, the QuantumVariable will be registered in a
+            new QuantumSession.
+        name : string, optional
+            The name of the QuantumVariable. If given none, a suited name will be
+            generated.
+
+        Returns
+        -------
+        CustomQuantumVariable
+            A QuantumVariable with the desired outcome labels.
+
+        Examples
+        --------
+
+        We create a QuantumVariable with some examples values as outcome labels and
+        bring it into uniform superposition.
+
+        >>> from qrisp import QuantumVariable, h
+        >>> qv = QuantumVariable.custom(["lorem", "ipsum", "dolor", "sit", 42, (1,2,3)])
+        >>> h(qv)
+        >>> print(qv)
+        {'lorem': 0.125, 'ipsum': 0.125, 'dolor': 0.125, 'sit': 0.125, 42: 0.125,
+        (1, 2, 3): 0.125, 'undefined_label_6': 0.125, 'undefined_label_7': 0.125}
+
+        """
+        from qrisp.misc import custom_qv
+
+        return custom_qv(label_list, decoder=decoder, qs=qs, name=name)
+
+
+def plot_histogram(outcome_labels, counts, filename=None):
+    res_list = []
+
+    for k in range(len(outcome_labels)):
+        try:
+            res_list.append(counts[outcome_labels[k]])
+        except KeyError:
+            res_list.append(0)
+
+    plt.bar(outcome_labels, res_list, width=1 / len(outcome_labels))
+    plt.grid()
+    plt.ylabel("Measurement probability")
+    plt.xlabel("QuantumVariable value")
+
+    if filename:
+        plt.savefig(filename, dpi=400, bbox_inches="tight")
+    else:
+        plt.show()
```

### Comparing `qrisp-0.0.15/src/qrisp/core/quantum_variable.py` & `qrisp-0.0.16/src/qrisp/core/quantum_session.py`

 * *Files 14% similar despite different names*

```diff
@@ -6,1268 +6,1054 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
-
-import copy
 import weakref
 
 import numpy as np
-import matplotlib.pyplot as plt
 
-from qrisp.circuit import transpile
-from qrisp.core.compilation import qompiler
+from qrisp.circuit import Clbit, QuantumCircuit, Qubit, QubitAlloc, QubitDealloc
+from qrisp.core.session_merging_tools import multi_session_merge
+from qrisp.misc import get_depth_dic
+
 
-class QuantumVariable:
+class QuantumSession(QuantumCircuit):
     """
-    The QuantumVariable is the quantum equivalent of a regular variable in classical programming languages. All :ref:`quantum types <QuantumTypes>` inherit from this class.
-    The QuantumVariable allows many automizations and quality of life improvements such as hidden qubit management, de/encoding to human readable labels or typing.
-    
-    Each QuantumVariable is registered in a :ref:`QuantumSession`. It can be accessed using the ``.qs`` attribute:
-        
+    The QuantumSession class manages the life cycle of QuantumVariables and enables
+    features such as :ref:`QuantumEnvironments <QuantumEnvironment>` or
+    :ref:`Uncomputation`. To create a QuantumSession, we call the constructor
+
+    >>> from qrisp import QuantumSession
+    >>> qs = QuantumSession()
+
+    To create a QuantumVariable within that QuantumSession, we hand it over to the
+    QuantumVariable constructor:
+
     >>> from qrisp import QuantumVariable
-    >>> example_qv = QuantumVariable(3)
-    >>> quantum_session = example_qv.qs
+    >>> qv = QuantumVariable(3, qs = qs)
 
-    The qubits of the QuantumVariable are stored as a list in the ``.reg`` attribute
+    As an inheritor of the :ref:`QuantumCircuit` class, QuantumSession objects can also
+    be used for circuit construction.
+
+    >>> qv.qs.cx(qv[0], qv[1])
+
+    Nevertheless, users are encouraged to use the :ref:`designated gate application
+    function <gate_application_functions>` in order to reduce code cluttering.
 
-    >>> qubits = example_qv.reg
-    
-    To quickly access the qubits of a given variable, we use the [ ] operator:
-    
-    >>> qubit_2 = example_qv[2]
-    
-    We can find out about the amount of qubits in the QuantumVariable with the ``.size`` attribute
-    
-    >>> example_qv.size
-    3
-    
-    **Naming**
-    
-    QuantumVariables can be given names to identify them independently of their naming as Python objects. 
-    
-    >>> example_qv_2 = QuantumVariable(3, name = "alice")
-    >>> example_qv_2.name
-    'alice'
-    
-    If not explicitely specified during construction, a name is determined automatically. Qrisp will try to infer the name of the Python variable and if that fails, a generic name is given.
-    
-    >>> example_qv.name
-    'example_qv'
-    
-    In order to keep the generated quantum circuits comprehensive, the qubits are named after their containing QuantumVariable with an extra number, which indicates their index.
-    
     >>> from qrisp import cx
-    >>> cx(example_qv, example_qv_2)
-    >>> print(example_qv.qs)
-    QuantumCircuit:
-    ---------------
-    example_qv.0: ──■────────────
-                    │            
-    example_qv.1: ──┼────■───────
-                    │    │       
-    example_qv.2: ──┼────┼────■──
-                  ┌─┴─┐  │    │  
-         alice.0: ┤ X ├──┼────┼──
-                  └───┘┌─┴─┐  │  
-         alice.1: ─────┤ X ├──┼──
-                       └───┘┌─┴─┐
-         alice.2: ──────────┤ X ├
-                            └───┘
-    Live QuantumVariables:
-    ----------------------
-    QuantumVariable example_qv
-    QuantumVariable alice    
-    
-    QuantumSessions can only contain uniquely named QuantumVariables. If two QuantumSessions are :ref:`merged <SessionMerging>` containing identically named QuantumVariables, the more recently created QuantumVariable will be renamed:
-    
-    ::
-        
-        from qrisp import QuantumFloat
-        
-        s = QuantumFloat(5)
-        
-        for i in range(4):
-            temp = QuantumFloat(4)
-            temp[:] = 2**i
-            s += temp
-            
-    >>> print(s.qs)
+    >>> cx(qv[0], qv[1])
+
+    QuantumSessions can be visualized by calling ``print`` on them.
+
+    >>> print(qv.qs)
     QuantumCircuit:
     ---------------
-                   ┌───────────┐┌───────────┐┌───────────┐┌───────────┐
-         s.0: ─────┤0          ├┤0          ├┤0          ├┤0          ├
-                   │           ││           ││           ││           │
-         s.1: ─────┤1          ├┤1          ├┤1          ├┤1          ├
-                   │           ││           ││           ││           │
-         s.2: ─────┤2          ├┤2          ├┤2          ├┤2          ├
-                   │           ││           ││           ││           │
-         s.3: ─────┤3          ├┤3          ├┤3          ├┤3          ├
-                   │           ││           ││           ││           │
-         s.4: ─────┤4 __iadd__ ├┤4          ├┤4          ├┤4          ├
-              ┌───┐│           ││           ││           ││           │
-      temp.0: ┤ X ├┤5          ├┤           ├┤           ├┤           ├
-              └───┘│           ││           ││           ││           │
-      temp.1: ─────┤6          ├┤  __iadd__ ├┤           ├┤           ├
-                   │           ││           ││           ││           │
-      temp.2: ─────┤7          ├┤           ├┤           ├┤           ├
-                   │           ││           ││           ││           │
-      temp.3: ─────┤8          ├┤           ├┤  __iadd__ ├┤           ├
-                   └───────────┘│           ││           ││           │
-    temp_1.0: ──────────────────┤5          ├┤           ├┤           ├
-              ┌───┐             │           ││           ││           │
-    temp_1.1: ┤ X ├─────────────┤6          ├┤           ├┤  __iadd__ ├
-              └───┘             │           ││           ││           │
-    temp_1.2: ──────────────────┤7          ├┤           ├┤           ├
-                                │           ││           ││           │
-    temp_1.3: ──────────────────┤8          ├┤           ├┤           ├
-                                └───────────┘│           ││           │
-    temp_2.0: ───────────────────────────────┤5          ├┤           ├
-                                             │           ││           │
-    temp_2.1: ───────────────────────────────┤6          ├┤           ├
-              ┌───┐                          │           ││           │
-    temp_2.2: ┤ X ├──────────────────────────┤7          ├┤           ├
-              └───┘                          │           ││           │
-    temp_2.3: ───────────────────────────────┤8          ├┤           ├
-                                             └───────────┘│           │
-    temp_3.0: ────────────────────────────────────────────┤5          ├
-                                                          │           │
-    temp_3.1: ────────────────────────────────────────────┤6          ├
-                                                          │           │
-    temp_3.2: ────────────────────────────────────────────┤7          ├
-              ┌───┐                                       │           │
-    temp_3.3: ┤ X ├───────────────────────────────────────┤8          ├
-              └───┘                                       └───────────┘
+    qv.0: ──■────■──
+          ┌─┴─┐┌─┴─┐
+    qv.1: ┤ X ├┤ X ├
+          └───┘└───┘
+    qv.2: ──────────
+    <BLANKLINE>
     Live QuantumVariables:
     ----------------------
-    QuantumFloat s
-    QuantumFloat temp
-    QuantumFloat temp_1
-    QuantumFloat temp_2
-    QuantumFloat temp_3
-        
-    Renaming does not happen for names given through the ``name`` keyword, unless the name ends with a ``*``.
-    
-    >>> example_qv_3 = QuantumVariable(3, name = "alice")
-    >>> cx(example_qv, example_qv_3)
-    Exception: Tried to merge QuantumSession containing identically named QuantumVariables
-    >>> example_qv_4 = QuantumVariable(3, name = "alice*")    
-    >>> cx(example_qv, example_qv_4)
-    >>> example_qv_4.name
-    'alice_1'
-    
-    
-    Examples
-    --------
-    
-    Writing a function that brings an arbitrary QuantumVariable into a GHZ state
-    
-    ::
-        
-        from qrisp import QuantumVariable, h, cx
-        def GHZ(qv):
-             h(qv[0])
-             for i in range(1, qv.size): 
-                 cx(qv[0], qv[i])
-        
-    Evaluation:
-    
-    >>> qv = QuantumVariable(5)
-    >>> GHZ(qv)
-    >>> print(qv)
-    {'00000': 0.5, '11111': 0.5}
-    
-    
-    """
-    
-    
-    
-    live_qvs = []
-    creation_counter = np.zeros(1)
-    name_tracker = {}
-    
-    def __init__(self, size, qs = None, name = None):
-        """
-        Constructs a QuantumVariable - possibly with a given name or in a given QuantumSession.
+    QuantumVariable qv
 
-        Parameters
-        ----------
-        size : int
-            The amount of qubits this QuantumVariable contains.
-        qs : QuantumSession, optional
-            A QuantumSession object, where the QuantumVariable is supposed to be registerd. The default is None.
-        name : string, optional
-            A name which uniquely identifies the QuantumVariable. If ended with a \*, name is allowed to be updated if a naming collision arises. By default, Qrisp will try to infer the name of the Python variable - otherwise a generic name is given.
+    If not specified, QuantumVariables will create their own QuantumSession and register
+    themselves in it.
 
-        """
+    QuantumSessions can be manually merged using the merge function.
 
-        if size < 0:
-            raise Exception(f"Tried to create QuantumVariable with invalid qubit amount {size}")
-        
-
-        #Store quantum session        
-        from qrisp.core import QuantumSession, merge_sessions
-        self.qs = QuantumSession()
-        
-        if not qs is None:
-            merge_sessions(self.qs, qs)
-            
+    >>> from qrisp import merge
+    >>> qs_2 = QuantumSession()
+    >>> qs_2 == qs
+    False
+    >>> merge(qs, qs_2)
+    >>> qs == qs_2
+    True
+
+    Note that merge also works for QuantumVariables, lists of QuantumSession and lists
+    of QuantumVariables.
+
+    If an entangling operation between two QuantumVariables which are registered in
+    different QuantumSessions is executed, these QuantumSessions are automatically
+    merged. For more details on automatic QuantumSession merging check the
+    :ref:`session merging documentation<SessionMerging>`.
+
+    >>> qv_a = QuantumVariable(2)
+    >>> qv_b = QuantumVariable(2)
+    >>> qv_a.qs == qv_b.qs
+    False
+    >>> from qrisp import cx
+    >>> cx(qv_a[0], qv_b[0])
+    >>> qv_a.qs == qv_b.qs
+    True
+
+    QuantumSessions can be given a default backend on which to evaluate circuits:
+
+    >>> from qrisp.interface import VirtualQiskitBackend
+    >>> qiskit_backend = instantiate_qiskit_backend()
+    >>> qs = QuantumSession(backend = VirtualQiskitBackend(qiskit_backend))
+
+    In this piece of code, we assume that the function ``instantiate_qiskit_backend``
+    creates a Qiskit backend instance (which could either be the QASM Simulator or a
+    real backend). We then hand this to the :ref:`VirtualQiskitBackend` constructor to
+    turn it into a Qrisp backend. Now, any measurements of variables that are registered
+    in this session will be evaluated on that backend.
 
-        self.size = int(size)
-        
-        
-        self.user_given_name = False
-        #If name is given, register variable in session manager
-        if not name is None:
-            self.user_given_name = True
-            
-            if name[-1] == "*":
-                name = name[:-1]
-                self.user_given_name = False
-                
-                try:
-                    self.name = name
-                    self.qs.register_qv(self)
-                    
-                except RuntimeError:
-                    i = 0
-                    while True:
-                        try:
-                            self.name = name + "_" + str(i)
-                            self.qs.register_qv(self)
-                        except RuntimeError:
-                            i += 1
-                            continue
-                        break
-                    
-            else:
-                self.name = name
-                self.qs.register_qv(self)
-        
-        #Otherwise try to infer from code inspection
-        else:
-            from qrisp.misc import find_calling_line
-            
-            if type(self) is QuantumVariable:
-                line = find_calling_line(1)
-            else:
-                line = find_calling_line(2)
-            split_line = line.split("=")
-            name_found = False
-            
-            if len(split_line) >= 2:
-                python_var_name = split_line[0]
-                
-                if split_line[1].replace(" ", "")[:7] == "Quantum":
-                    
-                    python_var_name = python_var_name.split(" ")[0]
-                    python_var_name = python_var_name.split(" ")[-1]
-                    
-                    # name = self.get_unique_name(python_var_name)
-                    name = python_var_name
-                    
-                    self.name = name
-                    self.qs.register_qv(self)    
-                    name_found = True
-
-            #If this didn't work, generate a generic, unique name
-            if not name_found:
-                while True:
-                    try:
-                        self.name = self.get_unique_name()
-                        self.qs.register_qv(self)
-                        break
-                    except RuntimeError:
-                        pass
-        
-        import weakref
-        #This attribute tracks the created QuantumVariables for the 
-        #auto_uncompute decorator
-        #We use weak references as some qrisp modules rely on reference counting
-        QuantumVariable.live_qvs.append(weakref.ref(self))
-        self.creation_time = int(self.creation_counter[0])
-        self.creation_counter += 1
-    
-    
-    def delete(self, verify = False, recompute = False):
-        """
-        This method is for deleting a QuantumVariable and thus freeing up and resetting the used qubits.
-        
-        Note that this method has a different function than the destructor. Calling this method will tell the QuantumSession to mark the used qubits as free and apply a reset gate.
-        If set to True, the keyword verify will cause a simulation to check, wether the deleted qubits are in the $\ket{0}$ state prior to resetting. This is helpfull during debugging, as it indicates wether the uncomputation of this QuantumVariable was successfull.
-        
-        After deletion, the QuantumVariable object is basically unchanged but an error will be raised if further operations on the deleted qubits are attempted.
+    If no backend is given, the backend specified in ``default_backend.py`` will be
+    used.
 
-        Parameters
-        ----------
-        verify : bool, optional
-            If this bool is set to True, Qrisp will verify that the deleted qubits are indeed in the $\ket{0}$ state. The default is ``False``.
-        recompute : bool, optional
-            If set to ``True``, this QuantumVariable can be recomputed if it is required for the uncomputation of another QuantumVariable. For more information on the (dis)advantages check :ref:`recomputation <recomputation>`. The default is ``False``.
+    Note that it is not possible to merge two QuantumSessions with differing,
+    non-trivial backends.
+    """
 
-        Raises
-        ------
-        Exception
-            Tried to delete qubits not in \|0> state.
+    qs_tracker = []
 
-        
-        Examples
-        --------
-        
-        We create a QuantumVariable, execute some gates and try to delete with verify = True
-            
-        >>> from qrisp import QuantumVariable, x, h
-        >>> qv = QuantumVariable(2)
-        >>> x(qv[0])
-        >>> h(qv[1])
-        >>> qv.delete(verify = True)
-        Exception: Tried to delete qubits not in |0> state.
-        
-        We now (manually) uncompute the gates
-        
-        >>> x(qv[0])
-        >>> h(qv[1])
-        >>> qv.delete(verify = True)
-        >>> qv.is_deleted()
-        True
-        >>> x(qv[0])
-        Exception: Tried to perform operation x on unallocated qubit qv_1.0.
-        
+    def __init__(self, backend=None):
         """
-        
-        if self.is_deleted():
-            return
-        
-        self.qs.delete_qv(self, verify)
-        
-        i = 0
-        while i < len(QuantumVariable.live_qvs):
-            if QuantumVariable.live_qvs[i]() is None:
-                QuantumVariable.live_qvs.pop(i)
-                continue
-            
-            if QuantumVariable.live_qvs[i]().name == self.name:
-                QuantumVariable.live_qvs.pop(i)
-                break
-            
-            i += 1
-        
-        if recompute:
-            for qb in self.reg:
-                qb.recompute = True
-        
-            
-    def is_deleted(self):
-        for qb in self.reg:
-            if qb.allocated:
-                return False
-        else:
-            return True
-        
-    
-    def duplicate(self, name = None, qs = None, init = False):
-        """
-        Duplicates the QuantumVariable in the sense that a new QuantumVariable is created with same type and parameters but initialized in the $\ket{0}$ state.
-        
+        Constructs a QuantumSession
+
         Parameters
         ----------
-        name : string, optional
-            A unique name to identify that QuantumVariable. If not given, a name will be generated.
-        qs : QuantumSession, optional
-            A QuantumSession, where the result should be registered. If not given, a new QuantumSession will be generated.
-        init : bool, optional
-            If set to True, the :meth:`init_from <qrisp.QuantumVariable.init_from>` method of the result will be called on self. The default is False.
+        backend : BackendClient, optional
+            The backend on which to execute the circuits created by this QuantumSession.
+            This choice can be overwritten by specifying a backend in the
+            :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>` method of
+            QuantumVariable.
 
         Returns
         -------
-        duplicate : Type of self
-            The duplicated QuantumVariable.
+        None.
 
         Examples
         --------
-        
-        We create a QuantumFloat and duplicate:
-        
-        >>> from qrisp import QuantumFloat
-        >>> qf_0 = QuantumFloat(4, signed = False)
-        >>> qf_1 = qf_0.duplicate()
-        >>> type(qf_1)
-        qrisp.qtypes.quantum_float.QuantumFloat
-        >>> qf_1.size
-        4
-        
-        """
-        
-        duplicate = copy.copy(self)
-        
-        from qrisp.core import QuantumSession
-        new_qs = QuantumSession()
-
-        #Register duplicate variable in session manager
-        
-        
-        if not name is None:
-            duplicate.name = name
-            new_qs.register_qv(duplicate)
-            duplicate.user_given_name = True
-            
-        else:
-            duplicate.user_given_name = False
-            
-            try:
-                duplicate.name = self.name
-                new_qs.register_qv(duplicate)
-            except NameError:
-                i = 0
-                while True:
-                    try:
-                        duplicate.name = self.name + "_" + str(i)
-                        new_qs.register_qv(duplicate)
-                        break
-                    except NameError:
-                        pass
-                    i += 1
-
-        from qrisp import merge
-        
-        
-        
-        duplicate.qs = new_qs
-        
-        if not qs is None:
-            merge(qs, new_qs)
-        
-        #This attribute tracks the created QuantumVariables for the 
-        #auto_uncompute decorator
-        #We use weak references as some qrisp modules rely on reference counting
-        QuantumVariable.live_qvs.append(weakref.ref(duplicate))
-        duplicate.creation_time = int(self.creation_counter[0])
-        duplicate.creation_counter += 1
-        
-        
-        if init:
-            duplicate.init_from(self)
-
-        
-
-        
-        return duplicate        
-    
-    def decoder(self, i):
-        """
-        The decoder method specifies how a QuantumVariable turns the outcomes of measurements into human readable values. It recieves an integer ``i`` and returns a human readable value.
-        
-        This method is supposed to be overloaded when defining new :ref:`quantum types <QuantumTypes>`.
-        
-        
-        Parameters
-        ----------
-        i : int
-            Integer representing the outcome of a measurement of the qubits of this QuantumVariable.
 
-        Returns
-        -------
-        
-            A human readable value. Has to be hashable.
+        We create a QuantumSession with the QASM simulator as default backend and
+        register a QuantumFloat in it:
+
+        >>> from qiskit import Aer
+        >>> qasm_sim = Aer.get_backend("qasm_simulator")
+        >>> from qrisp.interface import VirtualQiskitBackend
+        >>> vrtl_qasm_sim = VirtualQiskitBackend(qasm_sim)
+        >>> from qrisp import QuantumSession, QuantumFloat
+        >>> qs = QuantumSession(vrtl_qasm_sim)
+        >>> qf = QuantumFloat(4, qs = qs)
+
 
-        Examples
-        --------
-        
-        We create a QuantumFloat and inspect it's decoder:
-        
-        >>> from qrisp import QuantumFloat
-        >>> qf = QuantumFloat(3, -1, signed = False)
-        >>> print(qf.decoder(1))
-        0.5
-        
-        This implies that if the 3 qubits of this QuantumFloat are measured in state 001, this outcome corresponds to the value 0.5.
-        """
-        
-        from qrisp.misc import bin_rep
-        return bin_rep(i, self.size)[::-1]
-    
-    
-    def encoder(self, value):
         """
-        The encoder reverses the decoder, it turns human readable values into integers.
-        
-        If not overloaded, the encoder will perform a linear search on decoder inputs to match the given value.
 
-        Parameters
-        ----------
-        label : 
-            A human readable value.
+        if isinstance(backend, int):
+            raise Exception
 
-        Raises
-        ------
-        Exception
-            Unknown input value.
+        super().__init__()
 
-        Returns
-        -------
-        i : int
-            The integer encoding the given value.
+        self.backend = backend
 
-        Examples
-        --------
+        # Set up list of quantum variables appearing in this session
 
-        We create a QuantumChar and inspect it's encoder:
-        
-        >>> from qrisp import QuantumChar
-        >>> q_ch = QuantumChar()
-        >>> print(q_ch.encoder("f"))
-        5
-        
-        This implies that if the 5 qubits of this QuantumChar are measured to ``5 = 00101``, the out come will be displayed as f.
-        
-        """
-        for i in range(2**self.size):
-            if self.decoder(i) == value:
-                return i
-        
-        raise Exception("Value " + str(value) + " not supported by encoder.")
-        
+        self.qv_list = []
+        self.deleted_qv_list = []
 
-    def encode(self, value):
-        """
-        The encode method allows to quickly bring a QuantumVariable in a desired computational basis state.
-        
-        A shorthand for this method is given by the ``[:]`` operator.
-        
-        Note that the qubits to initialize have to be fresh (ie. no operations performed on them).
-        
-        Parameters
-        ----------
-        value : 
-            A value supported by the encoder.
+        # Set up environment stack
+        # This list will be filled, once we enter an environment
+        self.env_stack = []
 
-        Returns
-        -------
-        None.
+        # This list will be filled with variables which are marked for uncomputation
+        # Variables will be marked once there is no longer any reference to them apart
+        # from the one in qv_list. This is for instance the case with local variables
+        # inside a function after the function finished
+        self.uncomp_stack = []
 
-        Examples
-        --------
-        
-        We create two quantum floats and encode the value 2.5. For one of them, we perform an x gate onto the corresponding qubits, resulting in an error.
-        
-        >>> from qrisp import QuantumFloat, x
-        >>> qf_0 = QuantumFloat(3, -1, signed = False)
-        >>> qf_1 = QuantumFloat(3, -1, signed = False)
-        >>> x(qf_0)
-        >>> qf_0.encode(2.5)
-        Exception: Tried to initialize qubits which are not fresh anymore.
-        >>> qf_1[:] = 2.5
-        >>> print(qf_1)
-        {2.5: 1.0}
-        
-        """
-        
-        from qrisp.misc import int_encoder, check_if_fresh
-        
-        if not check_if_fresh(self.reg, self.qs):
-            raise Exception("Tried to initialize qubits which are not fresh anymore.")
-        
-        
-        int_encoder(self, self.encoder(value))
-        
-        
+        self.qs_tracker.append(weakref.ref(self))
 
-    def init_state(self, state_dic):
-        """
-        The ``init_state`` method allows the initialization of arbitrary quantum states. It recieves a dictionary of the type 
-        
-        **{value : complex number}**
-        
-        and initializes the **normalized** state. Amplitudes not specified are assumed to be zero.
-    
-        Note that the state initialization algorithm requires it's qubits to be in state $\ket{0}$.
-        
-        A shorthand for this method is the ``[:]`` operator, when handed the corresponding dictionary
-        
-        Parameters
-        ----------
-        state_dic : dict
-            Dictionary describing the wave function to be initialized.
-        
-        Raises
-        ------
-        Exception
-            Tried to initialize qubits which are not fresh anymore.
-        
-        Examples
-        --------
-        
-        We create a QuantumFloat and encode the state 
-        
-        .. math::
-            
-            \ket{\psi} = \\sqrt{\\frac{1}{3}} \ket{0.5} + i\\sqrt{\\frac{2}{3}} \ket{2}
-        
-        >>> from qrisp import QuantumFloat
-        >>> qf = QuantumFloat(3, -1)
-        
-        We can now use either
-        
-        >>> qf.init_state({0.5: (1/3)**0.5, 2.0 : 1j*(2/3)**0.5})
-        
-        or:
-        
-        >>> qf[:] = {0.5: (1/3)**0.5, 2.0 : 1j*(2/3)**0.5}
-        
-        To acquire the expected result        
-                
-        >>> print(qf)
-        {2.0: 0.6667, 0.5: 0.3333}
-        
-        """
-        
-        from qrisp.misc import check_if_fresh
-        if not check_if_fresh(self.reg, self.qs):
-            raise Exception("Tried to initialize qubits which are not fresh anymore.")
-        
-        
-        from qrisp import init_state
-        
-        target_array = np.zeros(2**self.size, dtype = np.complex128)
-        
-        for key in state_dic.keys():
-            target_array[self.encoder(key)] = state_dic[key]
-        
-        
-        target_array = target_array/np.vdot(target_array, target_array)**0.5
-        
-        init_state(self, target_array)
-
-    def append(self, operation):
-        self.qs.append(operation, self)
-    
-    def extend(self, amount, position = -1):
+        # This list will contain the QuantumSessions which have been merged into this
+        # session. It needs to be tracked in order to also update the shadow sessions
+        # when this session is merged into another session.
+        self.shadow_sessions = []
+
+    def register_qv(self, qv):
         """
-        This method is used to add more qubits to the QuantumVariable. Using the position keyword it is possible to specify the position where the qubits should be added. By default, the qubits are added at the end.
+        Method to register QuantumVariables
 
         Parameters
         ----------
-        amount : int
-            The amount of qubits to add.
-        position : int, optional
-            The position of where to add the qubits. By default, qubits are added at the end.
-            st of qubits which are to be added to the QuantumVariable. The default is None.
+        qv : QuantumVariable
+            QuantumVariable to register.
 
         Raises
         ------
-        Exception
-            Missmatch between proposed qubits and amount integer.
+        RuntimeError
+            Name of qv is already used in this QuantumSession.
 
         Returns
         -------
         None.
 
-        Examples
-        --------
-        
-        We create a QuantumVariable and extend it with some extra qubits.
-            
-        >>> from qrisp import QuantumVariable
-        >>> qv = QuantumVariable(3)
-        >>> print(qv.reg)
-        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2)]
-        >>> qv.extend(3)
-        >>> print(qv.reg)
-        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2), Qubit(qv.6), Qubit(qv.6), Qubit(qv.6)]        
-
         """
-        
-        if position == -1:
-            position = self.size
-        
-        insertion_qubits = self.qs.request_qubits(amount)
-        
-        for i in range(amount):
-            insertion_qubits[i].identifier = self.name + "." + str(self.size)
-            self.reg.insert(position + i, insertion_qubits[i])
-            self.size += 1
-    
-    def reduce(self, qubits, verify = False):
-        """
-        Reduces the qubit count of the QuantumVariable by removing a specified set of qubits.
+        if qv.name in [temp_qv.name for temp_qv in self.qv_list + self.deleted_qv_list]:
+            raise RuntimeError(
+                "Variable name " + str(qv.name) + " already exists in quantum session"
+            )
+
+        # Determine amount of required qubits
+        req_qubits = qv.size
+
+        # Hand qubits to quantum variable
+        qv.reg = self.request_qubits(req_qubits, name=qv.name)
+
+        # Register in the list of active quantum variable
+        self.qv_list.append(qv)
+
+    def get_qv(self, key):
+        for qv in self.qv_list:
+            if qv.name == key:
+                return qv()
+        raise Exception("Could not find QuantumVariable " + str(key))
 
-        Parameters
-        ----------
-        qubits : list
-            The qubits to remove from the QuantumVariable.
-        
-        verify : bool
-            Boolean value which indicates wether Qrisp should verify that the reduced qubits are in the $\ket{0}$ state.
+    def __str__(self):
+        temp_data = list(self.data)
+        self.data = []
+        i = 0
 
-        Raises
-        ------
-        Exception
-            Qubits not present in QuantumVariable.
-            
-        Exception
-            Verification that the given qubits are in $\ket{0}$ state failed.
+        from qrisp import QuantumEnvironment
 
-        Examples
-        --------
-        
-        We create a QuantumVariable with 5 qubits and remove the first 2
-        
-        >>> from qrisp import QuantumVariable
-        >>> qv = QuantumVariable(5)
-        >>> print(qv.reg)
-        [Qubit(qv.0), Qubit(qv.1), Qubit(qv.2), Qubit(qv.3), Qubit(qv.4)]
-        >>> qv.reduce(qv[:2])
-        >>> print(qv.reg)
-        [Qubit(qv.2), Qubit(qv.3), Qubit(qv.4)]
+        while temp_data:
+            instr = temp_data.pop(i)
+            if isinstance(instr, QuantumEnvironment):
+                instr.compile()
+            else:
+                self.append(instr)
 
-        """
-        
-        
-        try:
-            len(qubits)
-        except TypeError:
-            qubits = [qubits]
-        
-        if not set(qubits).issubset(self.reg):
-            raise Exception("Tried to reduce QuantumVariable by invalid qubits")
-
-
-        #Find Qubits to be cleared        
-        for i in range(len(qubits)):
-            for j in range(self.size):
-                if self.reg[j] == qubits[i]:
-                    self.reg[j].identifier = "qb_" + str(self.qs.qubit_index_counter[0])
-                    self.qs.qubit_index_counter += 1
-                    self.reg.pop(j)
-                    break
-        
-        self.qs.clear_qubits(qubits, verify)
-        #Adjust variable size
-        self.size -= len(qubits)        
-    
-    
-    def get_measurement(self, plot = False, backend = None, shots = 10000, compile = True, compilation_kwargs = {}, subs_dic = {}, circuit_preprocessor = None, filename = None):
-        r"""
-        Method for quick access to the measurement results of the state of the variable. This method returns a dictionary of the type {value : p} where p indicates the probability with which that value is measured.
-        
+        res = "QuantumCircuit:\n---------------\n"
 
-        Parameters
-        ----------
-        plot : Bool, optional
-            Plots the measurement results as a historgram. The default is False.
-        backend : BackendClient, optional
-            The backend on which to evaluate the quantum circuit. The default can be specified in the file default_backend.py.
-        shots : integer, optional
-            The amount of shots to evaluate the circuit. The default is 10000.
-        compile : bool, optional
-            Boolean indicating if the .compile method of the underlying QuantumSession should be called before. The default is True.
-        compilation_kwargs  : dict, optional
-            Keyword arguments for the compile method. For more details check :meth:`QuantumSession.compile <qrisp.QuantumSession.compile>`. The default is ``{}``.
-        subs_dic : dict, optional
-            A dictionary of Sympy symbols and floats to specify parameters in the case of a circuit with unspecified, :ref:`abstract parameters<QuantumCircuit>`. The default is {}.
-        circuit_preprocessor : Python function, optional
-            A function which recieves a QuantumCircuit and returns one, which is applied after compilation and parameter substitution. The default is None.
-        filename : string, optional
-            The location of where to save a generated plot. The default is None.
+        qc_str = QuantumCircuit.__str__(self)
+
+        # Remove blank line
+        lines = qc_str.split("\n")
+        if len(set(lines[0])) == 1:
+            lines.pop(0)
+        # if len(set(lines[-1])) == 1:
+        # lines.pop(-1)
+
+        for line in lines:
+            res += line + "\n"
+
+        if len(self.env_stack):
+            res += "QuantumEnvironment Stack:\n-------------------------\n"
+            for i in range(len(self.env_stack)):
+                env = self.env_stack[i]
+                res += (
+                    "Level " + str(i) + ": " + str(type(env)).split(".")[-1][:-2] + "\n"
+                )
+            res += "\n"
+
+        res += "Live QuantumVariables:\n----------------------"
+
+        qv_name_list = []
+        for qv in self.qv_list:
+            qv_name_list.append(str(type(qv)).split(".")[-1][:-2] + " " + qv.name)
+
+        for qv_name in qv_name_list:
+            res += "\n" + qv_name
+
+        return res
+
+    def get_depth_dic(self):
+        return get_depth_dic(self)
+
+    def add_qubit(self, qubit=None):
+        qb = super().add_qubit(qubit)
+        qb.qs = weakref.ref(self)
+        qb.perm_lock = False
+        qb.lock = False
+        return qb
+
+    def __call__(self):
+        return self
+
+    def add_clbit(self, clbit=None):
+        cb = super().add_clbit(clbit)
+        cb.qs = weakref.ref(self)
+        return cb
+
+    def request_qubits(self, request_amount, name=None):
+        # Create qubits and add to circuit
+        return_qubits = []
+
+        for i in range(request_amount):
+            if name is None:
+                qb = self.add_qubit()
+            else:
+                qb = self.add_qubit(Qubit(name + "." + str(i)))
+
+            return_qubits.append(self.qubits[-1])
+
+        for qb in return_qubits:
+            self.append(QubitAlloc(), qb)
+
+        return return_qubits
+
+    def clear_qubits(self, qubits, verify=False):
+        # Apply initialization operation
+        # The following is uncommented because the QASM simulator speed drastically
+        # drops when having non unitary operations
+        # Uncomment, when executing on real backends
+        if not len(self.env_stack):
+            pass
+            # self.reset(qubits)
+
+        if verify:
+            verification_qc = self.copy()
+            for qb in qubits:
+                verification_qc.measure(qb)
+
+            from qrisp.simulator import run
+
+            res = run(verification_qc, 1000, insert_reset=False)
+            for key in res.keys():
+                if key[: len(qubits)] != len(qubits) * "0":
+                    raise Exception("Tried to delete qubits not in |0> state")
+
+        if not set(qubits).issubset(set(self.qubits)):
+            raise Exception(
+                "Tried to free up qubits not registered in this quantum session"
+            )
+
+        for qb in qubits:
+            self.append(QubitDealloc(), qb)
+
+    # Procedure to free up space for quantum variables not used anymore
+    def delete_qv(self, qv, verify=False):
+        # Check if quantum variable appears in this session
+        if qv.name not in [qv.name for qv in self.qv_list]:
+            raise Exception(
+                "Tried to remove a non existent quantum variable from quantum session"
+            )
+
+        self.clear_qubits(qv.reg, verify)
+
+        # Remove quantum variable from list
+        for i in range(len(self.qv_list)):
+            temp_qv = self.qv_list[i]
+
+            if temp_qv.name == qv.name:
+                self.qv_list.pop(i)
+                break
+
+        self.deleted_qv_list.append(qv)
+
+    def cnot_count(self):
+        """
+        Method to determine the amount of CNOT gates used in this QuantumSession.
 
         Raises
         ------
         Exception
-            If the containing QuantumSession is in a quantum environment, it is not possible to execute measurements.
+            Tried to compute the CNOT count with open environments.
 
         Returns
         -------
-        dict
-            A dictionary of values and their corresponding measurement probabilities.
+        int
+            The amount of CNOT gates.
 
-        Examples
-        --------
-        
-        We create an integer :ref:`QuantumFloat`, encode the value 1 and bring the qubit with significance 2 in superposition. We utilize the Qiskit transpiler by transpiling into the gate set $\{\text{CX}, \text{U}\}$
-        
-        >>> from qrisp import QuantumFloat, h
-        >>> qf = QuantumFloat(3,-1)
-        >>> qf[:] = 1
-        >>> h(qf[2])
-        >>> mes_results = qf.get_measurement(transpilation_kwargs = {"basis_gates" : ["cx", "u"]})
-        >>> print(mes_results)
-        {1.0: 0.5, 3.0: 0.5}
         """
-        
-        if backend == None:
-            if self.qs.backend == None:
-                from qrisp.default_backend import def_backend
-                backend = def_backend
-            else:
-                backend = self.qs.backend
-            
-            
-        if len(self.qs.env_stack) != 0:
-            raise Exception("Tried to get measurement within open environment")
-        
-        if self.is_deleted():
-            raise Exception("Tried to get measurement from deleted QuantumVariable")
-        
-        if self.size == 0:
-            return {"" : 1.0}
-        
-
-        #Bind parameters
-        if subs_dic:
-            qc = self.qs.bind_parameters(subs_dic)
-            
-        else:
-            if compile:
-                qc = qompiler(self.qs, intended_measurements = self.reg, **compilation_kwargs)
-            else:
-                qc = self.qs.copy()
-                
-        #Copy circuit in over to prevent modification
-        from qrisp.quantum_network import QuantumNetworkClient
-        
-        if isinstance(backend, QuantumNetworkClient):
-            self.qs.data = []
-            shots = 1
-                
-        #Execute user specified circuit_preprocessor
-        if circuit_preprocessor != None:
-            qc = circuit_preprocessor(qc)
-
-        qc = qc.transpile()
-        
-        from qrisp.misc import get_measurement_from_qc
-        
-        counts = get_measurement_from_qc(qc, self.reg, backend, shots)
-            
-        #Insert outcome labels (if available and hashable)
-        try:
-            new_counts_dic = {}
-            
-            sorted_keys = list(counts.keys())
-            sorted_keys.sort()
-            
-            for key in sorted_keys:
-                new_counts_dic[self.decoder(key)] = counts[key]
-            
-            counts = new_counts_dic
-            
-            #Sort keys
-            sorted_key_list = list(counts.keys())
-            sorted_key_list.sort(key = lambda x : -counts[x])
-            counts = {key : counts[key] for key in sorted_key_list}
 
-            
-        except TypeError:
-            counts_tuple_list = []
-            
-            for key in counts.keys():
-                counts_tuple_list.append((key, counts[key]))
-            
-            counts = counts_tuple_list
-        
-            counts.sorted(key = lambda x : x[1])
-        
-            
-        if plot:
-            outcome_labels = []
-            for i in range(2**self.size):
-                
-                temp = self.decoder(i)
-                try:
-                    hash(temp)
-                except TypeError:
-                    raise Exception("Outcome value " + str(self.decoder(i)) + " is not hashable")
-                    
-                outcome_labels.append(temp)
+        if len(self.env_stack) != 0:
+            raise Exception("Tried to count CNOT gates with open if environments")
+        from qrisp.misc import cnot_count
 
-            
-            
-            if outcome_labels[0] == int(self.size)*"0":
-                outcome_labels = list(range(2**self.size))
-            plot_histogram(outcome_labels, counts, filename)
-            plt.show()
-        
-        
-        #Return dictionary of measurement results
-        return counts
-    
-    def most_likely(self, **kwargs):
+        return cnot_count(self)
+
+    def get_local_qvs(self):
+        import sys
+
+        local_qvs = []
+        for qv in object.__getattribute__(self, "qv_list"):
+            if sys.getrefcount(qv) == 3:
+                local_qvs.append(qv)
+
+        return local_qvs
+
+        # self.uncomp_stack = []
+
+    def logic_synth(self, input_qubits, output_qubits, tt, method="best", inv=False):
+        if len(input_qubits) != tt.bit_amount:
+            raise Exception("Given truth table has unfitting amount of input variables")
+
+        if len(output_qubits) != tt.shape[1]:
+            raise Exception("Given truth table has unfitting amount of output columns")
+
+        self.append(
+            tt.gate_synth(method=method, inv=False), input_qubits + output_qubits
+        )
+
+    def depth(self):
         """
-        Performs a measurement and returns the most likely outcome.
+        Method to calculate the circuit depth of this QuantumSession
+
+        Returns
+        -------
+        int
+            The circuit depth.
 
-        Parameters
-        ----------
-        **kwargs : Keyword arguments for the get_measurement call.
-        
-        Examples
-        --------
-        
-        >>> from qrisp import QuantumFloat, ry
-        >>> import numpy as np
-        >>> qf = QuantumFloat(3)
-        >>> ry(np.pi*9/8, qf[0])
-        >>> print(qf)
-        {1: 0.9619, 0: 0.0381}
-        >>> qf.most_likely()
-        1
-    
         """
-        
-        return list(self.get_measurement())[0]
-    
-    def __getitem__(self, key):
-        return self.reg[key]
-    
-    def __str__(self):
-        return str(self.get_measurement())
-    
-    def __repr__(self):
-        return "<" + str(type(self)).split(".")[-1][:-2] + " '" + self.name + "'>"
-        return str(type(self)).split(".")[-1][:-2] + "(name = " + self.name + ")"
-        return str(self)
-    
-    def __len__(self):
-        return self.size
-    
-    #Overload equality operator to use python syntax for if environments? Not sure if the possible user confusion is worth it
-    def __eq__(self, other):
-        
-        from qrisp.environments import q_eq
-        return q_eq(self, other)
-        
-    def __hash__(self):
-        return id(self)
+        depth_dic = self.get_depth_dic()
+        return max(depth_dic.values())
 
-    def __setitem__(self, key, value):
-        if key != slice(None, None, None):
-            raise Exception("Tried to encode value into QuantumVariable using non-trivial slicing.")
-        
-        if isinstance(type(value), type(None)):
-            return
-        
-        if isinstance(value, dict):
-            self.init_state(value)
-            return
-        
-        if isinstance(value, QuantumVariable):
-            self.init_from(value)
+    def __eq__(self, other):
+        if other is None:
+            return False
+        return id(self().data) == id(other().data)
+
+    def append(self, operation_or_instruction, qubits=[], clbits=[]):
+        # Check the type of the instruction/operation
+        from qrisp.circuit import Instruction, Operation
+
+        if issubclass(operation_or_instruction.__class__, Instruction):
+            instruction = operation_or_instruction
+            self.append(instruction.op, instruction.qubits, instruction.clbits)
             return
-        
-        self.encode(value)
-        
 
-        
-    def app_phase_function(self, phi):
-        """
-        Applies a previously specified phase function to each computational basis state of the QuantumVariable using Gray-Synthesis.
-        
-        For a given phase function $\phi(x)$ and a QuantumVariable in state $\ket{\psi} = \sum_{x \in \\text{Labels}} a_x \ket{x}$  this method acts as:
-            
-        .. math::
-        
-            U_{\phi} \sum_{x \in \\text{Labels}} a_x \ket{x} =  \sum_{x \in \\text{Labels}} \\text{exp}(i\phi(x)) a_x \ket{x}
+        elif issubclass(operation_or_instruction.__class__, Operation):
+            operation = operation_or_instruction
 
+        else:
+            raise Exception(
+                "Tried to append object type "
+                + str(type(operation_or_instruction))
+                + " which is neither Instruction nor Operation"
+            )
+
+        # Convert arguments (possibly integers) to list
+        # The logic here is that the list structure gets preserved ie.
+        # [[0, 1] ,2] ==> [[qubit_0, qubit_1], qubit_2]
+        # unless the input is a single qubit/integer.
+        # In this case we have
+        # qubit_0 ==> [qubit_0]
+
+        from qrisp.circuit.quantum_circuit import convert_to_cb_list, convert_to_qb_list
+
+        qubits = convert_to_qb_list(qubits, circuit=self)
+        clbits = convert_to_cb_list(clbits, circuit=self)
+
+        def check_alloc(input, res=None):
+            if isinstance(input, list):
+                for item in input:
+                    check_alloc(item)
+            else:
+                if not input.allocated:
+                    raise Exception(
+                        f"Tried to perform operation {operation.name} on"
+                        f"unallocated qubit {input}"
+                    )
+
+        if operation.name not in ["qb_alloc", "barrier"]:
+            check_alloc(qubits)
+
+        elif operation.name == "qb_alloc":
+            qubits[0].allocated = True
+
+        # We now need to merge the sessions and treat their differing environment
+        # levels. The idea here is that if a quantum session A is not identical to the
+        # environment session B, there have been no gates applied within that
+        # environment so far (otherwise merging would have occured). Thus, all data of A
+        # belongs into the original_data attribute of the environment with the highest
+        # level environment, where the environment quantum session isn't identical to A.
+
+        flattened_qubits = []
+        for item in qubits:
+            if isinstance(item, Qubit):
+                flattened_qubits.append(item)
+            else:
+                flattened_qubits.extend(item)
+
+        flattened_clbits = []
+        for item in clbits:
+            if isinstance(item, Clbit):
+                flattened_qubits.append(item)
+            else:
+                flattened_qubits.extend(item)
+
+        # Find the list of all quantum sessions that need to be treated
+        qs_list = (
+            [qb.qs() for qb in flattened_qubits]
+            + [cb.qs() for cb in flattened_clbits]
+            + [self]
+        )
+
+        # We now iterate through every quantum session and insert its data into the
+        # correct original_data attribute
+        # for qs in qs_list:
+
+        #     #We need to find the environment where the env_qs quantum session is not merged into qs.
+        #     #This implies that the instructions of this session have been appended in this environment's parent.
+        #     #Therefore all the data needs to go into the original_data attribute of this environment.
+        #     for env in qs.env_stack:
+        #         if not env.env_qs == qs:
+        #             env.original_data.extend(qs.data)
+        #             qs.data = []
+        #             merge([qs, env.env_qs])
+
+        # We merge qs_list again since no merge happened incase there were no
+        # environments.
+        multi_session_merge(qs_list)
+
+        super().append(operation, qubits, clbits)
 
+        if operation.name == "qb_dealloc":
+            qubits[0].allocated = False
+
+    def __getitem__(self, key):
+        for qv in self.qv_list:
+            if qv.name == key:
+                return qv
+        raise Exception(f"Could not find QuantumVariable {key}")
+
+    # Instead of just resetting the list, we have to use this method.
+    # This is because merging two quantum session works essentially by handing them
+    # a pointer to the same data list (which contains the merged circuits)
+    # If we clear the data list by setting it to an empty list, any session
+    # that has been merged with self.qs doesnt point to the same data list anymore.
+    # This method tackles this problem by keeping the pointer to the list alive,
+    # but removing every single element
+    def clear_data(self):
+        self.data.clear()
+
+    def statevector(self, return_type="sympy", plot=False, decimals=None):
+        r"""
+        Returns a representation of the statevector. Three options are available:
+
+        * ``sympy`` returns a `Sympy quantum state
+          <https://docs.sympy.org/latest/modules/physics/quantum/state.html>`_,
+          which is great for visualization and symbolic investigation. The tensor factors
+          are in the order of the creation of the QuantumVariables (or equivalently: as
+          they appear, when listed in ``print(self)``).
+
+        * ``latex`` returns the latex code for the Sympy quantum state.
+
+        * ``function`` returns a statevector function, such that the amplitudes can be
+          investigated by calling this function on a dictionary of this QuantumSession's
+          QuantumVariables.
+
+        If you need to retrieve the statevector as a numpy array, please use the
+        corresponding
+        :meth:`QuantumCircuit method <qrisp.QuantumCircuit.statevector_array>`.
 
         Parameters
         ----------
-        phi : Python function
-            A Python function which turns the labels of the QuantumVariable into floats.
+        return_type : str, optional
+            String indicating how the statevector should be returned. Available are
+            ``sympy``, ``array`` and ``function``. The default is ``sympy``.
+        plot : bool, optional
+            If the return type is set to ``array``, this boolean will trigger a plot of
+            the statevector. The default is ``False``.
+        decimals : int, optional
+            The decimals to round in the statevector. The default is 5 for return type
+            ``sympy`` and infinite otherwise.
+
+        Returns
+        -------
+        sympy.Expression or LaTeX string or function
+            An object representing the statevector.
 
         Examples
         --------
-        
-        We create a QuantumFloat and encode the k-th basis state of the Fourier basis. Finally we will apply an inverse Fourier transformation to measure k in the computational basis.
-        
-        >>> import numpy as np
-        >>> from qrisp import QuantumFloat, h, QFT
-        >>> n = 5
-        >>> qf = QuantumFloat(n, signed = False)
-        >>> h(qf)
-        
-        After this, qf is in the state
-        
+
+        We create some QuantumFloats and encode values in them:
+
+        >>> from qrisp import QuantumFloat
+        >>> qf_0 = QuantumFloat(3,-1)
+        >>> qf_1 = QuantumFloat(3,-1)
+        >>> qf_0[:] = 2
+        >>> qf_1[:] = {0.5 : 1, 3.5: -1j}
+
+        This encoded the state
+
         .. math::
             
-            \\ket{\\text{qf}} = \\frac{1}{\sqrt{2^n}} \sum_{x = 0}^{2^n} \ket{x}
-        
-        We specify phi
-        
-        >>> k = 4
-        >>> def phi(x):
-        >>>     return 2*np.pi*x*k/2**n
-        
-        And apply phi as a phase function
-        
-        >>> qf.app_phase_function(phi)
-        
-        qf is now in the state
-        
+            \ket{\psi} = \ket{\text{qf_0}} \ket{\text{qf_1}}
+            = \frac{1}{\sqrt{2}}  \ket{2} (\ket{0.5} - i \ket{3.5})
+
+        Now we add ``qf_0`` and ``qf_1``:
+
+        >>> qf_res = qf_0 + qf_1
+
+        This gives us the state
+
         .. math::
-            
-            \\ket{\\text{qf}} = \\frac{1}{\sqrt{2^n}} \sum_{x = 0}^{2^n} \\text{exp}\\left( \\frac{2\pi ikx}{2^n}\\right) \ket{x}
-        
-        
-        Finally we apply the inverse Fourier transformation and measure:
-        
-        >>> QFT(qf, inv = True)
-        >>> print(qf)
-        {4: 1.0}
-        
 
-        """        
+            \ket{\phi} = \frac{1}{\sqrt{2}}(\ket{2}\ket{0.5}\ket{2 + 0.5} -
+            i \ket{2} \ket{3.5}\ket{2 + 3.5})
+
+
+
+        We retrieve the statevector as a Sympy expression:
+
+        >>> sv = qf_0.qs.statevector()
+        >>> print(sv)
+        sqrt(2)*(|2.0>*|0.5>*|2.5> - I*|2.0>*|3.5>*|5.5>)/4
+
+        If you have Sympy's `pretty printing
+        <https://docs.sympy.org/latest/tutorials/intro-tutorial/printing.html>`_ enabled
+        in your IPython console, it will even give you a nice Latex rendering:
+
+        >>> sv
+
+        .. image:: ./statevector_print.png
+            :width: 300
+            :alt: Statevector print
+            :align: left
+
+        |
+        |
+
+        This feature also works with symbolic parameters:
+
+        >>> from qrisp import QuantumVariable, ry, h, p
+        >>> from sympy import Symbol
+        >>> qv = QuantumVariable(1)
+        >>> ry(Symbol("omega"), qv)
+        >>> h(qv)
+        >>> p(-Symbol("phi"), qv)
+        >>> qv.qs.statevector()
+
+        .. image:: ./symbolic_statevector_print.png
+            :width: 350
+            :alt: Statevector print
+            :align: left
+
+        |
+        |
+
+        .. note::
+
+            Statevector simulation with symbolic parameters is significantly more
+            demanding than simulation with numeric parameters.
+
+        To retrieve the above expressions as latex code, we use
+        ``return_type = "latex"``
+
+        >>> print(qf_0.qs.statevector(return_type = "latex"))
+        '\frac{\sqrt{2} \left({\left|2.0\right\rangle }
+        {\left|0.5\right\rangle } {\left|2.5\right\rangle }
+        - i {\left|2.0\right\rangle } {\left|3.5\right\rangle }
+        {\left|5.5\right\rangle }\right)}{2}'
+
+
+        We can also retrieve the statevector as a Python function:
+
+        >>> sv_function = qf_0.qs.statevector("function")
+
+        Specify the label constellations:
+
+        >>> label_constellation_a = {qf_0 : 2, qf_1 : 0.5, qf_res : 2+0.5}
+        >>> label_constellation_b = {qf_0 : 2, qf_1 : 3.5, qf_res : 2+3.5}
+        >>> label_constellation_c = {qf_0 : 2, qf_1 : 3.5, qf_res : 4}
+
+        And evaluate the function:
+
+        >>> sv_function(label_constellation_a)
+        (0.7071048-1.3411045e-07j)
+
+        This is the expected amplitude up to floating point errors.
+
+        To get a quicker understanding, we can tell the statevector function to round
+        the amplitudes using the ``round`` keyword.
+
+        >>> sv_function(label_constellation_b, round = 6)
+        (-0-0.707105j)
+
+        Finally, the last amplitude is 0 since the state of ``qf_res`` is not the sum of
+        ``qf_0`` and ``qf_1``.
+
+        >>> sv_function(label_constellation_c, round = 6)
+        0j
+
 
-            
-        from qrisp.misc import app_phase_function
-        
-        app_phase_function([self], phi)
-        
-    def uncompute(self, do_it = True, recompute = False):
         """
-        Method for automatic uncomputation. Uses a generalized form of `this algorithm <https://dl.acm.org/doi/10.1145/3453483.3454040>`_.
-        
-        For more information check the :ref:`uncomputation documentation<uncomputation>`.
+
+        from qrisp import get_statevector_function, get_sympy_state
+
+        if return_type == "array":
+            from qrisp.simulator import statevector_sim
+
+            # Simulate the statevector
+            statevector_array = statevector_sim(self.compile())
+            # statevector_array = statevector_sim(self)
+
+            # Execute simulation
+
+            # Plot results if required
+            if plot:
+                import matplotlib.pyplot as plt
+
+                plt.plot(np.real(statevector_array), "o", label="Re(psi)")
+                plt.plot(np.imag(statevector_array), "o", label="Im(psi)")
+                plt.grid()
+                plt.legend()
+                plt.show()
+            if decimals is None:
+                return statevector_array
+            else:
+                return np.round(statevector_array, decimals)
+
+        elif return_type == "sympy":
+            if decimals is None:
+                decimals = 6
+            return get_sympy_state(self, decimals)
+
+        elif return_type == "latex":
+            from sympy import latex
+
+            return latex(self.statevector(return_type="sympy", decimals=decimals))
+
+        elif return_type == "function":
+            if decimals is None:
+                decimals = 15
+
+            return get_statevector_function(self, decimals)
+
+        else:
+            raise Exception(f"Don't know return type {return_type}")
+
+    def compile(
+        self,
+        workspace=0,
+        intended_measurements=[],
+        cancel_qfts=True,
+        disable_uncomputation=True,
+    ):
+        r"""
+        Method to compile the QuantumSession into a :ref:`QuantumCircuit`. The compiler
+        dynamically allocates the qubits of the QuantumSession on qubits that might have
+        been used by priorly deleted :ref:`QuantumVariables <QuantumVariable>`.
+
+        Using the ``workspace`` keyword, we can grant the compiler a number of extra
+        qubits to use in order to reduce the circuit depth.
+
+        Furthermore, the compiler recompiles any :meth:`mcx <qrisp.mcx>` instruction
+        with ``method = auto`` using a dynamically generated mcx implementation that
+        makes use of as much of the currently available clean and dirty ancillae.
+        This feature will never allocate additional qubits on its own. If required,
+        it can be supplied with additional space using the ``workspace`` keyword.
+
+        The .compile method is called by default, when executing the
+        :meth:`get_measurement <qrisp.QuantumVariable.get_measurement>` method of
+        :ref:`QuantumVariable`. This method also allows specification of compilation
+        option through the ``compilation_kwargs`` argument.
+
+
 
         Parameters
         ----------
-        do_it : bool, optional
-            If set to False, this variable will be appended to the uncomputation stack of it's QuantumSession and uncomputed once an uncompute call with ``do_it = True`` is performed. The default is True.
-        recompute : bool, optional
-            If set to True, this QuantumVariable will be uncomputed but temporarily recomputed, if it is required for the uncomputation of another QuantumVariable. For more information check :ref:`recomputation <recomputation>`. The default is False.
+        workspace : int, optional
+            The amount of workspace qubits to be granted. The default is 0.
+        intended_measurements : list[Qubit], optional
+            A list of :ref:`Qubits <Qubit>` that are supposed to be measured. The
+            compiler will remove any instructions that are not directly neccessary to
+            perform the measurements. Note that the resulting :ref:`QuantumCircuit`
+            contains no measurements, such that the user can still specify a classical
+            bit for the measurement. The default ist [].
+        cancel_qfts : bool, optional
+            If set to True, any :meth:`QFT <qrisp.QFT>` instruction that is executed on
+            a set of qubits that have just been allocated (ie. the $\ket{0}$ state) will
+            be replaced by a set of H gates. The same goes for QFT instructions executed
+            directly before deallocation. The default is ``True``.
+        disable_uncomputation : bool, optional
+            Experimental feature the allows fully automized uncomputation. If set to
+            ``False`` any :ref:`QuantumVariable` that went out of scope will be
+            uncomputed by the compiler. The default is ``True``.
+
+        Returns
+        -------
+        QuantumCircuit
+            The compiled QuantumCircuit.
 
         Examples
         --------
-        
-        We create two QuantumVariables, apply some gates and perform automatic uncomputation
-        
-        >>> from qrisp import QuantumVariable, x, cx, h, p, mcx
-        >>> a = QuantumVariable(3)
-        >>> b = QuantumVariable(2)
-        >>> mcx(a, b[0])
-        >>> h(a[:2])
-        >>> x(b[0])
-        >>> cx(b[0], b[1])
-        >>> p(0.5, b[1])
-        >>> print(a.qs)
+
+        **Workspace**
+
+        We calculate a product of 2 :ref:`QuantumFloats <QuantumFloat>` using the
+        :meth:`sbp_mult <qrisp.sbp_mult>` function which heavily profits from more
+        workspace.
+
+        >>> from qrisp import QuantumFloat, sbp_mult
+        >>> qf_0 = QuantumFloat(5)
+        >>> qf_0[:] = 3
+        >>> qf_1 = QuantumFloat(5)
+        >>> qf_1[:] = 5
+
+        Calculate product:
+
+        >>> qf_res = sbp_mult(qf_0, qf_1)
+        >>> qf_res.qs.num_qubits()
+        45
+
+        Compile circuit with no workspace
+
+        >>> qc_0 = qf_res.qs.compile(0)
+        >>> qc_0.num_qubits()
+        21
+        >>> qc_0.depth()
+        497
+
+        Compile circuit with 4 workspace qubits
+
+        >>> qc_1 = qf_res.qs.compile(4)
+        >>> qc_1.num_qubits()
+        25
+        >>> qc_1.depth()
+        258
+
+        **mcx recompilation**
+
+        To demonstrate the recompilation feature, we create two
+        :ref:`QuantumVariables <QuantumVariable>`.
+
+        >>> from qrisp import QuantumVariable, mcx, cx
+        >>> ctrl = QuantumVariable(4)
+        >>> target = QuantumVariable(1)
+        >>> mcx(ctrl, target)
+        >>> print(ctrl.qs)
         QuantumCircuit:
         ---------------
-                  ┌───┐               
-        a.0: ──■──┤ H ├───────────────
-               │  ├───┤               
-        a.1: ──■──┤ H ├───────────────
-               │  └───┘               
-        a.2: ──■──────────────────────
-             ┌─┴─┐┌───┐               
-        b.0: ┤ X ├┤ X ├──■────────────
-             └───┘└───┘┌─┴─┐┌────────┐
-        b.1: ──────────┤ X ├┤ P(0.5) ├
-                       └───┘└────────┘
+          ctrl.0: ──■──
+                    │
+          ctrl.1: ──■──
+                    │
+          ctrl.2: ──■──
+                    │
+          ctrl.3: ──■──
+                  ┌─┴─┐
+        target.0: ┤ X ├
+                  └───┘
         Live QuantumVariables:
         ----------------------
-        QuantumVariable a
-        QuantumVariable b
-        
-        >>> b.uncompute()
-        >>> print(b.qs)
+        QuantumVariable ctrl
+        QuantumVariable target
+
+        We can now call the ``.compile`` method
+
+        >>> compiled_qc = ctrl.qs.compile()
+        >>> compiled_qc.depth()
+        50
+        >>> print(compiled_qc)
+            ctrl.0: ──■──
+                      │
+            ctrl.1: ──■──
+                      │
+            ctrl.2: ──■──
+                      │
+            ctrl.3: ──■──
+                    ┌─┴─┐
+          target.0: ┤ X ├
+                    └───┘
+
+        We see no change here, because there was no free space to execute a more optimal
+        mcx implementation. We can grant additional space using the ``workspace``
+        argument:
+
+        >>> compiled_qc = ctrl.qs.compile(workspace = 2)
+        >>> compiled_qc.depth()
+        22
+        >>> print(compiled_qc)
+                     ┌────────┐               ┌────────┐
+             ctrl.0: ┤0       ├───────────────┤0       ├──────────
+                     │        │               │        │
+             ctrl.1: ┤1       ├───────────────┤1       ├──────────
+                     │        │┌────────┐     │        │┌────────┐
+             ctrl.2: ┤        ├┤0       ├─────┤        ├┤0       ├
+                     │  pt2cx ││        │     │  pt2cx ││        │
+             ctrl.3: ┤        ├┤1       ├─────┤        ├┤1       ├
+                     │        ││        │┌───┐│        ││        │
+           target.0: ┤        ├┤  pt2cx ├┤ X ├┤        ├┤  pt2cx ├
+                     │        ││        │└─┬─┘│        ││        │
+        workspace_0: ┤2       ├┤        ├──■──┤2       ├┤        ├
+                     └────────┘│        │  │  └────────┘│        │
+        workspace_1: ──────────┤2       ├──■────────────┤2       ├
+                               └────────┘               └────────┘
+
+        Granting extra qubits to use this feature is however not usually necessary. The
+        compiler automatically detects and reuses qubit resources available at the
+        corresponding stage of the compilation.
+        To demonstrate this feature, we allocate a third QuantumVariable:
+
+        >>> qv = QuantumVariable(2)
+        >>> cx(target[0], qv)
+        >>> print(ctrl.qs.compile())
+                  ┌────────┐               ┌────────┐
+          ctrl.0: ┤0       ├───────────────┤0       ├────────────────────
+                  │        │               │        │
+          ctrl.1: ┤1       ├───────────────┤1       ├────────────────────
+                  │        │┌────────┐     │        │┌────────┐
+          ctrl.2: ┤        ├┤0       ├─────┤        ├┤0       ├──────────
+                  │  pt2cx ││        │     │  pt2cx ││        │
+          ctrl.3: ┤        ├┤1       ├─────┤        ├┤1       ├──────────
+                  │        ││        │┌───┐│        ││        │
+        target.0: ┤        ├┤  pt2cx ├┤ X ├┤        ├┤  pt2cx ├──■────■──
+                  │        ││        │└─┬─┘│        ││        │┌─┴─┐  │
+            qv.0: ┤2       ├┤        ├──■──┤2       ├┤        ├┤ X ├──┼──
+                  └────────┘│        │  │  └────────┘│        │└───┘┌─┴─┐
+            qv.1: ──────────┤2       ├──■────────────┤2       ├─────┤ X ├
+                            └────────┘               └────────┘     └───┘
+
+        We see how the qubits that will later hold ``qv`` are used to efficiently
+        compile the mcx gate.
+
+        In situations of no free clean ancilla qubits, the Qrisp compiler even makes use
+        of dirty ancillae. To demonstrate, we again create three QuantumVariables
+        but this time we execute a :meth:`cx<qrisp.cx>`-gate before executing the
+        :meth:`mcx<qrisp.mcx>`-gate. This way ``qv`` has to be allocated before the
+        ``mcx`` gate.
+
+        >>> ctrl = QuantumVariable(4)
+        >>> target = QuantumVariable(1)
+        >>> qv = QuantumVariable(2)
+        >>> cx(target[0], qv)
+        >>> mcx(ctrl, target)
+        >>> print(ctrl.qs.compile())
+          ctrl.0: ────────────────────────────────────■──────────────────────────»
+                                 ┌─────────────────┐  │  ┌─────────────────┐     »
+          ctrl.1: ───────────────┤1                ├──┼──┤1                ├─────»
+                                 │                 │  │  │                 │     »
+          ctrl.2: ───────────────┤2                ├──┼──┤2                ├─────»
+                                 │                 │  │  │                 │     »
+          ctrl.3: ────────────■──┤                 ├──┼──┤                 ├──■──»
+                            ┌─┴─┐│  reduced_maslov │  │  │  reduced_maslov │┌─┴─┐»
+        target.0: ──■────■──┤ X ├┤                 ├──┼──┤                 ├┤ X ├»
+                  ┌─┴─┐  │  └─┬─┘│                 │┌─┴─┐│                 │└─┬─┘»
+            qv.0: ┤ X ├──┼────┼──┤0                ├┤ X ├┤0                ├──┼──»
+                  └───┘┌─┴─┐  │  │                 │└───┘│                 │  │  »
+            qv.1: ─────┤ X ├──■──┤3                ├─────┤3                ├──■──»
+                       └───┘     └─────────────────┘     └─────────────────┘     »
+        «
+        «  ctrl.0: ─────────────────────■─────────────────────
+        «          ┌─────────────────┐  │  ┌─────────────────┐
+        «  ctrl.1: ┤1                ├──┼──┤1                ├
+        «          │                 │  │  │                 │
+        «  ctrl.2: ┤2                ├──┼──┤2                ├
+        «          │                 │  │  │                 │
+        «  ctrl.3: ┤                 ├──┼──┤                 ├
+        «          │  reduced_maslov │  │  │  reduced_maslov │
+        «target.0: ┤                 ├──┼──┤                 ├
+        «          │                 │┌─┴─┐│                 │
+        «    qv.0: ┤0                ├┤ X ├┤0                ├
+        «          │                 │└───┘│                 │
+        «    qv.1: ┤3                ├─────┤3                ├
+        «          └─────────────────┘     └─────────────────┘
+
+        We see how the qubits of ``qv`` are utilized as dirty ancilla qubits in order
+        to facilitate a more efficient ``mcx`` implementation compared to no ancillae
+        at all.
+
+        **Fully automized uncomputation**
+
+        This feature is as of right now experimental. To demonstrate, we create a test
+        function, creating a local :ref:`QuantumBool` ::
+
+            from qrisp import QuantumBool, mcx
+
+            def triple_AND(a, b, c):
+
+                local = QuantumBool()
+                result = QuantumBool()
+
+                mcx([a,b], local)
+
+                mcx([c, local], result)
+
+                return result
+
+
+        >>> a = QuantumBool()
+        >>> b = QuantumBool()
+        >>> c = QuantumBool()
+        >>> res = triple_AND(a,b,c)
+        >>> print(res.qs)
         QuantumCircuit:
         ---------------
-             ┌────────┐                              ┌────────┐┌───┐
-        a.0: ┤0       ├──────────────────────────────┤0       ├┤ H ├
-             │        │                              │        │├───┤
-        a.1: ┤1       ├──────────────────────────────┤1       ├┤ H ├
-             │  pt3cx │                              │  pt3cx │└───┘
-        a.2: ┤2       ├──────────────────────────────┤2       ├─────
-             │        │┌───┐                    ┌───┐│        │     
-        b.0: ┤3       ├┤ X ├──■──────────────■──┤ X ├┤3       ├─────
-             └────────┘└───┘┌─┴─┐┌────────┐┌─┴─┐└───┘└────────┘     
-        b.1: ───────────────┤ X ├┤ P(0.5) ├┤ X ├────────────────────
-                            └───┘└────────┘└───┘                    
+             a.0: ──■───────
+                    │
+             b.0: ──■───────
+                    │
+             c.0: ──┼────■──
+                  ┌─┴─┐  │
+         local.0: ┤ X ├──■──
+                  └───┘┌─┴─┐
+        result.0: ─────┤ X ├
+                       └───┘
         Live QuantumVariables:
         ----------------------
-        QuantumVariable a
+        QuantumBool a
+        QuantumBool b
+        QuantumBool c
+        QuantumBool local
+        QuantumBool result
+
+        We now compile with the corresponding keyword argument:
+
+        >>> print(a.qs.compile(disable_uncomputation = False))
+                     ┌────────┐     ┌────────┐
+                a.0: ┤0       ├─────┤0       ├
+                     │        │     │        │
+                b.0: ┤1       ├─────┤1       ├
+                     │        │     │        │
+                c.0: ┤  pt2cx ├──■──┤  pt2cx ├
+                     │        │┌─┴─┐│        │
+           result.0: ┤        ├┤ X ├┤        ├
+                     │        │└─┬─┘│        │
+        workspace_0: ┤2       ├──■──┤2       ├
+                     └────────┘     └────────┘
+
+        We see that the ``local`` QuantumBool is no longer allocated but has been
+        uncomputed and it's qubits are available as workspace.
 
 
         """
-        
-        if self.is_deleted():
-            raise Exception("Tried to uncompute deleted QuantumVariable")
-        
-        
-        if do_it:
-            from qrisp.uncomputation import uncompute
-            uncompute(self.qs, self.qs.uncomp_stack + [self], recompute)
-            self.qs.uncomp_stack = []
-        else:
-            self.qs.uncomp_stack.append(self)
-        
-        
-        
-    def get_unique_name(self, name = None):
-        
-        if name is None:
-            from qrisp import QuantumBool, QuantumFloat, QuantumChar    
-            if isinstance(self, QuantumBool):
-                name = "qbl"
-            elif isinstance(self, QuantumFloat):
-                name = "qf"
-            elif isinstance(self, QuantumChar):
-                name = "qch"
-            else:
-                name = "qv"
-        
-        while True:
-            try:
-                naming_number = self.name_tracker[name]
-                self.name_tracker[name] += 1
-                name = name + "_" + str(naming_number)
-            except KeyError:
-                self.name_tracker[name] = 1
-                name = name + "_0"
-            
-            i = 0
-            while i < len(QuantumVariable.live_qvs):
-                qv = QuantumVariable.live_qvs[i]()
-                if qv is None:
-                    QuantumVariable.live_qvs.pop(i)
-                    continue
-                if qv.name == name:
-                    break
-                i += 1
-            else:
-                break
-            
-        return name
-        
-    def init_from(self, other):
-        """
-        Method to initiate a QuantumVariable based on the state of another. This method does NOT copy the state. Much rather it performs the operation
-        
-        
-        .. math::
-            
-            U_{\\text{init_from}} \\left( \sum_{x \\in \\text{labels}} a_x \ket{x} \\right)  \ket{0} = \sum_{x \\in \\text{labels}} a_x \ket{x} \ket{x}
-        
-        
-        This is different from a state copying operation: 
-        
-        .. math::
-            
-            U_{\\text{copy}} \\left( \sum_{x \\in \\text{labels}} a_x \ket{x} \\right)  \ket{0} = \\left( \\sum_{x \\in \\text{labels}} a_x \ket{x} \\right) \\left( \\sum_{x \\in \\text{labels}} a_x \ket{x} \\right)
-            
-        
-        A shorthand for initiating this way is the ``[:]`` operator.
-        
+        from qrisp.core.compilation import qompiler
+
+        return qompiler(
+            self,
+            workspace,
+            disable_uncomputation=disable_uncomputation,
+            intended_measurements=intended_measurements,
+            cancel_qfts=cancel_qfts,
+        )
 
-        Parameters
-        ----------
-        other : QuantumVariable
-            The QuantumVariable from which to initiate.
+    def __del__(self):
+        i = 0
+        while i < len(self.qs_tracker):
+            if self.qs_tracker[i]() is None or id(self) == id(self.qs_tracker[i]()):
+                self.qs_tracker.pop(i)
+                continue
+            i += 1
 
-        Raises
-        ------
-        Exception
-            Tried to initialize qubits which are not fresh anymore.
-        
-        Examples
-        --------
-        
-        We create a QuantumFloat, and bring it into superposition. 
-        
-        >>> from qrisp import QuantumFloat, h, multi_measurement
-        >>> qf_a = QuantumFloat(8)
-        >>> qf_a[:] = 6
-        >>> h(qf_a[0])
-        >>> print(qf_a)
-        {6: 0.5, 7: 0.5}
-        
-        We now duplicate and initiate the duplicate
-        
-        >>> qf_b = qf_a.duplicate()
-        >>> print(qf_b)
-        {0: 1.0}
-        >>> qf_b.init_from(qf_a)
-        >>> print(multi_measurement([qf_a, qf_b]))
-        {(6, 6): 0.5, (7, 7): 0.5}
-        
-        The slicing operator achieves the same:
-            
-        >>> qf_c = qf_a.duplicate()
-        >>> qf_c[:] = qf_b
-        >>> print(multi_measurement([qf_a, qf_b, qf_c]))
-        {(6, 6, 6): 0.5, (7, 7, 7): 0.5}
-        
-        
-        
-        """
-        
-        if not type(self) == type(other):
-            raise Exception("Tried to initialize " + str(type(self)) + " from " + str(type(other)))
-        
-        from qrisp.misc import check_if_fresh
-        
-        if not check_if_fresh(self.reg, self.qs):
-            raise Exception("Tried to initialize qubits which are not fresh anymore")
-        
-        self.qs.cx(other.reg, self.reg)
-    
-    @classmethod
-    def custom(self, label_list, decoder = None, qs = None, name = None):
-        """
-        Creates a QuantumVariable with customized outcome labels.
-        
-        Note that this is a class method, implying there is no need to create another QuantumVariable first to call this method.
+    def __hash__(self):
+        return id(self.data)
 
-        Parameters
-        ----------
-        label_list : list
-            A list of outcome labels.
-        decoder : function, optional
-            The decoder function. If given none, the labels will be encoded according to their placement in the ``label_list``.
-        qs : QuantumSession, optional
-            The :ref:`QuantumSession` in which to register the customized QuantumVariable. If given none, the QuantumVariable will be registered in a new QuantumSession.
-        name : string, optional
-            The name of the QuantumVariable. If given none, a suited name will be generated.
+    # The .data attribute is used to identify QuantumSessions with each other even
+    # though they are different object. If the .data attribute is set to a new list,
+    # this identification is no longer possible because the two different
+    # QuantumSessions no longer share the same data list. We overload setattr such that
+    # setting a new list results in keeping the old one but with new content.
+    def __setattr__(self, name, value):
+        if name in ["data"]:
+            attr = self.__dict__[name]
+            attr.clear()
+            attr.extend(value)
+        else:
+            QuantumCircuit.__setattr__(self, name, value)
 
-        Returns
-        -------
-        CustomQuantumVariable
-            A QuantumVariable with the desired outcome labels.
+    @classmethod
+    def get_active_quantum_sessions(self):
+        # Remove potential duplicates
+        qs_list = list(
+            set([qs() for qs in QuantumSession.qs_tracker if not qs() is None])
+        )
 
-        Examples
-        --------
-        
-        We create a QuantumVariable with some examples values as outcome labels and bring it into uniform superposition.
-        
-        >>> from qrisp import QuantumVariable, h
-        >>> qv = QuantumVariable.custom(["lorem", "ipsum", "dolor", "sit", 42, (1,2,3)])
-        >>> h(qv)
-        >>> print(qv)
-        {'lorem': 0.125, 'ipsum': 0.125, 'dolor': 0.125, 'sit': 0.125, 42: 0.125, (1, 2, 3): 0.125, 'undefined_label_6': 0.125, 'undefined_label_7': 0.125}
+        self.qs_tracker = [weakref.ref(qs) for qs in qs_list]
 
-        """
-        from qrisp.misc import custom_qv
-        return custom_qv(label_list, decoder = decoder, qs = qs, name = name)
-        
-
-
-def plot_histogram(outcome_labels, counts, filename = None):
-    
-    res_list = []
-    
-    for k in range(len(outcome_labels)):
-        try:
-            res_list.append(counts[outcome_labels[k]])
-        except KeyError:
-            res_list.append(0)
-    
-    plt.bar(outcome_labels, res_list, width = 1/len(outcome_labels))
-    plt.grid()
-    plt.ylabel("Measurement probability")
-    plt.xlabel("QuantumVariable value")
-    
-    if filename:
-        plt.savefig(filename, dpi = 400, bbox_inches = "tight")
-    else:
-        plt.show()
+        return qs_list
```

### Comparing `qrisp-0.0.15/src/qrisp/core/session_merging_tools.py` & `qrisp-0.0.16/src/qrisp/core/session_merging_tools.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,329 +8,330 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 import weakref
 
+# This module contains the necessary tools to merge QuantumSessions
 
-#This module contains the necessary tools to merge QuantumSessions
-
-#Due to the interplay with QuantumEnvironments and the behavior
-#that QuantumEnvironments automatically detect QuantumSessions that operated
-#within them there is quite a bit of complexity involved here.
-
-#The idea to merge two session qs_0 and qs_1 is to first add the appropriate 
-#amount of qubits/clbits to qs_0, append all the instructions and 
-#fix the other attributes Then we let all the attributes of qs_1 point 
-#to the corresponding attributes of qs_0 such that any change on one quantum session
-#also appears in the other quantum session
-
-#Therefore two QuantumSessions are declared as identical (or merged) if their attributes
-#(like .data, .qubits) point to the same lists as the other one. 
-#The == operator for QuantumSessions checks if the .data attribute points to the same list
-
-#If a merge is requested, the first step is to "engage" the QuantumSessions
-#in the environment stack. By default QuantumEnvironments create their own QuantumSession
-#and "engaging" here means that if merge is called on a QuantumSession within an environment,
-#this QuantumSession will be merged with all the QuantumSessions of the environment stack.
+# Due to the interplay with QuantumEnvironments and the behavior
+# that QuantumEnvironments automatically detect QuantumSessions that operated
+# within them there is quite a bit of complexity involved here.
+
+# The idea to merge two session qs_0 and qs_1 is to first add the appropriate
+# amount of qubits/clbits to qs_0, append all the instructions and
+# fix the other attributes Then we let all the attributes of qs_1 point
+# to the corresponding attributes of qs_0 such that any change on one quantum session
+# also appears in the other quantum session
+
+# Therefore, two QuantumSessions are declared as identical (or merged) if their
+# attributes (like .data, .qubits) point to the same lists as the other one.
+# The == operator for QuantumSessions checks if the .data attribute points to the same
+# list.
+
+
+# If a merge is requested, the first step is to "engage" the QuantumSessions in the
+# environment stack. By default, QuantumEnvironments create their own QuantumSession
+# and "engaging" here means that if merge is called on a QuantumSession within an
+# environment, this QuantumSession will be merged with all the QuantumSessions of the
+# environment stack.
 def merge_sessions(qs_0, qs_1):
-    
-    #We now iterate through every QuantumEnvironment and insert it's data into the correct original_data attribute
+    # We now iterate through every QuantumEnvironment and insert its data into the
+    # correct original_data attribute
     for qs in [qs_0, qs_1]:
-        
-        #We need to find the environment where the env_qs quantum session is not merged into qs.
-        #This implies that the instructions of qs have been appended in this environment's parent.
-        #Therefore all the data needs to go into the original_data attribute of this environment.
+        # We need to find the environment where the env_qs quantum session is not merged
+        # into qs. This implies that the instructions of qs have been appended in this
+        # environment's parent. Therefore, all the data needs to go into the
+        # original_data attribute of this environment.
         for env in qs.env_stack:
             if not env.env_qs == qs:
                 env.original_data.extend(qs.data)
                 qs.data = []
                 merge_sessions_inner(qs, env.env_qs)
 
     merge_sessions_inner(qs_0, qs_1)
-    
-    
 
-def merge_sessions_inner(qs_0, qs_1, merge_env_stack_ = True):
+
+def merge_sessions_inner(qs_0, qs_1, merge_env_stack_=True):
     if qs_0 == qs_1:
         return
-    
+
     from qrisp.quantum_network import QuantumNetworkSession
-    
-    
+
     if isinstance(qs_0, QuantumNetworkSession):
-        
-        if not qs_0.backend is qs_1.backend:
+        if qs_0.backend is not qs_1.backend:
             if isinstance(qs_1, QuantumNetworkSession):
-                raise Exception("Tried to merge two QuantumNetworkSessions containing differing clients")
-            
-            if not qs_1.backend is None:
-                raise Exception("Tried to merge a QuantumNetworkSession with a QuantumSession with a non-trivial backend")
-            
+                raise Exception(
+                    "Tried to merge two QuantumNetworkSessions containing "
+                    "differing clients"
+                )
+
+            if qs_1.backend is not None:
+                raise Exception(
+                    "Tried to merge a QuantumNetworkSession with a "
+                    "QuantumSession with a non-trivial backend"
+                )
+
         qs_1.backend = qs_0.backend
         qs_1.inbox = qs_0.inbox
         qs_1.__class__ = qs_0.__class__
-    
+
     if isinstance(qs_1, QuantumNetworkSession):
-        
-        if not qs_1.backend is qs_0.backend:
-            
+        if qs_1.backend is not qs_0.backend:
             if isinstance(qs_0, QuantumNetworkSession):
-                raise Exception("Tried to merge two QuantumNetworkSessions containing differing clients")
-            
-            if not qs_0.backend is None:
-                raise Exception("Tried to merge a QuantumNetworkSession with a QuantumSession with a non-trivial backend")
-            
+                raise Exception(
+                    "Tried to merge two QuantumNetworkSessions containing "
+                    "differing clients"
+                )
+
+            if qs_0.backend is not None:
+                raise Exception(
+                    "Tried to merge a QuantumNetworkSession with a "
+                    "QuantumSession with a non-trivial backend"
+                )
+
         qs_0.backend = qs_1.backend
         qs_0.inbox = qs_1.inbox
         qs_0.__class__ = qs_1.__class__
-    
-    
-    
-    #The problem we face here is the following:
-    #If two sessions a, b are merged and b is merged with another session c
-    #at a later point, the attributes of b are updated by that merge, 
-    #but the attributes of a are not. To solve this problem, we declare one of the merge
-    #participants the "parent" of the merge. The parent has an attribute called "shadow_sessions"
-    #that contain the sessions that the parent has been merged with. 
-    #The attribute updates are then performed on all shadow sessions.
-    
-    #To make sure we only operate on parent sessions, we check the parent attribute
+
+    # The problem we face here is the following:
+    # If two sessions a, b are merged and b is merged with another session c at a later
+    # point, the attributes of b are updated by that merge, but the attributes of a are
+    # not. To solve this problem, we declare one of the merge participants the "parent"
+    # of the merge. The parent has an attribute called "shadow_sessions" that contain
+    # the sessions that the parent has been merged with. The attribute updates are then
+    # performed on all shadow sessions.
+
+    # To make sure we only operate on parent sessions, we check the parent attribute
     while hasattr(qs_0, "parent"):
         qs_0 = qs_0.parent
-    
-    
+
     while hasattr(qs_1, "parent"):
         qs_1 = qs_1.parent
-    
+
     resolve_naming_collisions(qs_0, qs_1)
-    
-    intersecting_qubits = set([qb.identifier for qb in qs_0.qubits]).intersection([qb.identifier for qb in qs_1.qubits])
-    
+
+    intersecting_qubits = set([qb.identifier for qb in qs_0.qubits]).intersection(
+        [qb.identifier for qb in qs_1.qubits]
+    )
+
     if len(intersecting_qubits):
-        raise Exception(f"Tried to merge two QuantumSessions containing identically named qubits {intersecting_qubits}")
-    
+        raise Exception(
+            f"Tried to merge two QuantumSessions containing identically named "
+            f"qubits {intersecting_qubits}"
+        )
+
     if len(qs_0.env_stack) < len(qs_1.env_stack):
         qs_0, qs_1 = qs_1, qs_0
-        
-        
+
     if merge_env_stack_:
         merge_env_stack(qs_0, qs_1)
-    
+
         if qs_0 == qs_1:
             return
-    
-    #The qs_tracker list should only contain one Session instance per equivalence class.
-    #Ie. If two sessions are merged only one of them should appear in the the qs_tracker
+
+    # The qs_tracker list should only contain one Session instance per equivalence
+    # class, i.e. if two sessions are merged only one of them should appear in the
+    # qs_tracker
     i = 0
     while i < len(qs_0.qs_tracker):
         if qs_0.qs_tracker[i]() is None:
             qs_0.qs_tracker.pop(i)
         elif qs_0.qs_tracker[i]() == qs_1:
             qs_0.qs_tracker.pop(i)
         else:
-            i+= 1
+            i += 1
 
-    #Each environment contains a list of QuantumSessions that when it was entered.
-    #This list determines if a QuantumSession is engaged into an QuantumEnvironment, if merge
-    #is called from inside the QuantumEnvironment.
-    #We only want to have one of the two QuantumSessions that are merged in this list, which is  
-    #resolved by the identify_sessions_in_environment
+    # Each environment contains a list of QuantumSessions that when it was entered.
+    # This list determines if a QuantumSession is engaged into an QuantumEnvironment, if
+    # merge is called from inside the QuantumEnvironment. We only want to have one of
+    # the two QuantumSessions that are merged in this list, which is resolved by the
+    # identify_sessions_in_environment
     for i in range(len(qs_1.env_stack)):
-        identify_sessions_in_environment(qs_1.env_stack[-i-1], qs_0, qs_1)
-    
-    
-    if not qs_0.backend is None and not qs_1.backend is None:
+        identify_sessions_in_environment(qs_1.env_stack[-i - 1], qs_0, qs_1)
+
+    if qs_0.backend is not None and qs_1.backend is not None:
         if id(qs_0.backend) != id(qs_1.backend):
-            raise Exception("Tried to merge QuantumSessions with differing, non-trivial default backends.")
-    
+            raise Exception(
+                "Tried to merge QuantumSessions with differing, "
+                "non-trivial default backends."
+            )
+
     if qs_0.backend is None:
         qs_0.backend = qs_1.backend
 
     if set(qs_0.clbits).intersection(qs_1.clbits):
         raise Exception("Tried to merge sessions with common classical bits")
-    
-    for qb in qs_1.qubits: qb.qs = weakref.ref(qs_0)
-    for cb in qs_1.clbits: cb.qs = weakref.ref(qs_0)
-    
+
+    for qb in qs_1.qubits:
+        qb.qs = weakref.ref(qs_0)
+    for cb in qs_1.clbits:
+        cb.qs = weakref.ref(qs_0)
+
     qs_0.qubits.extend(qs_1.qubits)
     qs_0.clbits.extend(qs_1.clbits)
-    
+
     qs_0.data.extend(qs_1.data)
-    
-    object.__setattr__(qs_1, "data", qs_0.data)    
-    
-    #Update qv_list
+
+    object.__setattr__(qs_1, "data", qs_0.data)
+
+    # Update qv_list
     while len(qs_1.qv_list):
-        
         qv = qs_1.qv_list.pop()
-        #Patch quantum session attribute
+        # Patch quantum session attribute
         qv.qs = qs_0
-        
+
         qs_0.qv_list.append(qv)
-    
-    
+
     qs_0.deleted_qv_list.extend(qs_1.deleted_qv_list)
-    
+
     reorder_quantum_variables(qs_0)
-    
-    #Add variables to the uncomputation stack
+
+    # Add variables to the uncomputation stack
     qs_0.uncomp_stack.extend(qs_1.uncomp_stack)
-    
+
     qs_0.shadow_sessions.extend(qs_1.shadow_sessions + [weakref.ref(qs_1)])
-    
+
     i = 0
     while i < len(qs_0.shadow_sessions):
         qs = qs_0.shadow_sessions[i]()
         if qs is None:
             qs_0.shadow_sessions.pop(i)
             continue
-        
+
         qs.parent = qs_0
-        
+
         # Update all the attributes
         for var in qs_0.__dict__.keys():
-        
             qs.__dict__[var] = qs_0.__dict__[var]
-            
+
         i += 1
-            
-            
+
 
 def resolve_naming_collisions(qs_0, qs_1):
-    
     qs_names_0 = [qv.name for qv in qs_0.qv_list + qs_0.deleted_qv_list]
     qs_names_1 = [qv.name for qv in qs_1.qv_list + qs_1.deleted_qv_list]
-    
+
     intersecting_qv_names = set(qs_names_0).intersection(qs_names_1)
 
     if len(intersecting_qv_names):
-        
         for qv_name in intersecting_qv_names:
-            
-            
             qv_0_index = qs_names_0.index(qv_name)
-            
+
             qv_0 = (qs_0.qv_list + qs_0.deleted_qv_list)[qv_0_index]
-            
+
             qv_1_index = qs_names_1.index(qv_name)
             qv_1 = (qs_1.qv_list + qs_1.deleted_qv_list)[qv_1_index]
-        
+
             if qv_1.user_given_name:
-                
                 if qv_0.user_given_name:
-                    raise Exception("Tried to merge QuantumSession containing "
-                                    f"identically named QuantumVariables {qv_1.name}")
-                
+                    raise Exception(
+                        "Tried to merge QuantumSession containing "
+                        f"identically named QuantumVariables {qv_1.name}"
+                    )
+
                 qv_0, qv_1 = qv_1, qv_0
-                
-            else: 
+
+            else:
                 if qv_0.creation_time > qv_1.creation_time:
                     if not qv_1.user_given_name:
                         qv_0, qv_1 = qv_1, qv_0
-        
-        
+
             proposed_new_name = qv_1.name + "_1"
             k = 1
-            
+
             while proposed_new_name in qs_names_0 + qs_names_1:
                 k += 1
                 proposed_new_name = qv_1.name + "_" + str(k)
-            
+
             qv_1.name = proposed_new_name
-            
-            
+
             for k in range(len(qv_1.reg)):
                 qv_1.reg[k].identifier = qv_1.name + "." + str(k)
 
 
 def merge_env_stack(qs_0, qs_1):
-    
-    #We need to find the environment where the env_qs quantum session is not merged into qs.
-    #This implies that the instructions of this session have been appended in this environment's parent.
-    #Therefore all the data needs to go into the original_data attribute of this environment.
+    # We need to find the environment where the env_qs quantum session is not merged
+    # into qs. This implies that the instructions of this session have been appended in
+    # this environment's parent. Therefore, all the data needs to go into the
+    # original_data attribute of this environment.
     for env in qs_0.env_stack:
-        
         if env.env_qs == qs_0 and not env.env_qs == qs_1:
             if env in qs_1.env_stack:
                 env.original_data.extend(qs_1.data)
                 qs_1.data = []
-            
+
         if env.env_qs == qs_1 and not env.env_qs == qs_0:
             for env_ in qs_0.env_stack:
                 if not env_.env_qs == qs_0:
-                    
                     env_.original_data.extend(qs_0.data)
                     qs_0.data = []
                     merge_sessions_inner(qs_0, env_.env_qs, False)
                 if env.env_qs == env_.env_qs:
                     break
 
-def reorder_quantum_variables(qs):
 
+def reorder_quantum_variables(qs):
     overall_qv_list = qs.qv_list + qs.deleted_qv_list
-    
-    qs.qv_list.sort(key = lambda x : x.creation_time)
-    
-    overall_qv_list.sort(key = lambda x : x.creation_time)
-    
+
+    qs.qv_list.sort(key=lambda x: x.creation_time)
+
+    overall_qv_list.sort(key=lambda x: x.creation_time)
+
     sorted_qubit_list = []
     for qv in overall_qv_list:
         sorted_qubit_list += qv.reg
-        
+
     sorted_qubit_list.extend(list(set(qs.qubits) - set(sorted_qubit_list)))
-    
+
     qs.qubits = sorted_qubit_list
 
 
 def identify_sessions_in_environment(env, qs_0, qs_1):
-    
     i = 0
     while i < len(env.active_qs_list):
         if env.active_qs_list[i] == qs_1:
             env.active_qs_list.pop(i)
             continue
         i += 1
-    
 
 
 def multi_session_merge(input_list):
-    
     session_list = input_list
-    session_list.sort(key = lambda x : -len(x.data))
-    
+    session_list.sort(key=lambda x: -len(x.data))
+
     if not len(session_list):
         from qrisp.core import QuantumSession
+
         return QuantumSession()
-    
-    
+
     for i in range(1, len(session_list)):
         merge_sessions(session_list[0], session_list[i])
-    
+
     return session_list[0]
 
+
 def recursive_qs_search(input):
-        
     if isinstance(input, str):
         return []
-    
+
     from qrisp.core import QuantumSession
-    
+
     if hasattr(input, "__iter__"):
         iterable = True
-        
-    #This case would in principle allow for also searching objects
-    #this however requires a considerable chunk of resources
+
+    # This case would in principle allow for also searching objects
+    # this however requires a considerable chunk of resources
     elif hasattr(input, "__dict__") and not isinstance(input, QuantumSession):
         iterable = False
         # input = input.__dict__
     else:
         iterable = False
-    
+
     result = []
     if iterable:
         if isinstance(input, dict):
             for key in input.keys():
                 result += recursive_qs_search(key)
                 result += recursive_qs_search(input[key])
         else:
@@ -341,39 +342,37 @@
             result = [input]
         else:
             try:
                 if isinstance(input(), QuantumSession):
                     result = [input()]
             except TypeError:
                 pass
-            
+
             try:
                 if isinstance(input.qs(), QuantumSession):
                     result = [input.qs()]
             except AttributeError:
                 pass
-            
-            
 
     return result
 
+
 def recursive_qv_search(input):
-        
     if isinstance(input, str):
         return []
     from qrisp.core import QuantumVariable
-    
+
     if hasattr(input, "__iter__"):
         iterable = True
     elif hasattr(input, "__dict__") and not isinstance(input, QuantumVariable):
         iterable = False
         # input = input.__dict__
     else:
         iterable = False
-        
+
     result = []
     if iterable:
         if isinstance(input, dict):
             for key in input.keys():
                 result += recursive_qv_search(key)
                 result += recursive_qv_search(input[key])
         else:
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/GMS_environment.py` & `qrisp-0.0.16/src/qrisp/environments/GMS_environment.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,37 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
-from qrisp.misc.GMS_tools import GXX_converter
-
 from qrisp.environments.quantum_environments import QuantumEnvironment
+from qrisp.misc.GMS_tools import GXX_converter
 
 
 # Environments that allows quick and easy access to the GMS_converter
 # To use it make sure every gate that happens inside is either phase or cphase
 class GMSEnvironment(QuantumEnvironment):
     """
-    This environment provides a convenient interface for constructing quantum algorithms using the Ion-trap native GMS gates. GMS gates allow entangling more than 2 qubits in a single step and can therefore boost performance in many situations. For more information on GMS gates consult https://arxiv.org/abs/quant-ph/9810040 .
-    The techniques for converting the circuits presented to this environment are mostly based on https://ieeexplore.ieee.org/document/9815035 .
+    This environment provides a convenient interface for constructing quantum algorithms
+    using the Ion-trap native GMS gates. GMS gates allow entangling more than 2 qubits
+    in a single step and can therefore boost performance in many situations. For more
+    information on GMS gates consult https://arxiv.org/abs/quant-ph/9810040 . The
+    techniques for converting the circuits presented to this environment are mostly
+    based on https://ieeexplore.ieee.org/document/9815035 .
 
-    This environment allows to code blocks of phase-only gates as we are used to but compiles these blocks to GMS gates.
+    This environment allows to code blocks of phase-only gates as we are used to but
+    compiles these blocks to GMS gates.
 
     Examples
     --------
 
 
     We create a function performing the quantum Fourier-transform using GMS gates: ::
 
@@ -95,15 +98,16 @@
     «      │                     │└───┘│  GXX converted gate │┌───┐ │
     «qf.4: ┤2                    ├─────┤1                    ├┤ H ├─X─
     «      └─────────────────────┘     └─────────────────────┘└───┘
     Live QuantumVariables:
     ----------------------
     QuantumFloat qf
 
-    Now we check that the GMS version indeed performs the same operation as the CNOT version by performing the inverse of the CNOT version.
+    Now we check that the GMS version indeed performs the same operation as the CNOT
+    version by performing the inverse of the CNOT version.
 
     >>> with invert(): QFT(qf, use_gms = False)
     >>> print(qf)
     {13: 1.0}
 
     """
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/__init__.py` & `qrisp-0.0.16/src/qrisp/environments/__init__.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
 from qrisp.environments.quantum_environments import *
 from qrisp.environments.quantum_conditionals import *
 from qrisp.environments.quantum_inversion import *
 from qrisp.environments.control_environment import *
 from qrisp.environments.gate_wrap_environment import *
 from qrisp.environments.temp_var_environment import *
 from qrisp.environments.GMS_environment import *
+
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/control_environment.py` & `qrisp-0.0.16/src/qrisp/environments/control_environment.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,19 +7,19 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.environments import QuantumEnvironment
-from qrisp.core.library import mcx, x, p, rz
+from qrisp.circuit.qubit import Qubit
+from qrisp.core.library import mcx, p, rz, x
 from qrisp.core.session_merging_tools import merge
+from qrisp.environments import QuantumEnvironment
 from qrisp.misc import perm_lock, perm_unlock
-from qrisp.circuit.qubit import Qubit
 
 
 class ControlEnvironment(QuantumEnvironment):
     """
     This class behaves similarly to ConditionEnvironment but instead of a function
     calculating a truth value, we supply a list of qubits.
     The environment's content is then controlled on these qubits.
@@ -90,15 +90,19 @@
         QuantumEnvironment.__enter__(self)
 
         merge(self.env_qs, self.arg_qs)
 
         return self.condition_truth_value
 
     def __exit__(self, exception_type, exception_value, traceback):
-        from qrisp.environments import ControlEnvironment, InversionEnvironment, ConditionEnvironment
+        from qrisp.environments import (
+            ConditionEnvironment,
+            ControlEnvironment,
+            InversionEnvironment,
+        )
 
         self.parent_cond_env = None
 
         QuantumEnvironment.__exit__(self, exception_type, exception_value, traceback)
 
         # Determine the parent environment
         for env in self.env_qs.env_stack[::-1]:
@@ -140,20 +144,19 @@
                 if len(ctrl_qubits) == 1:
                     from qrisp.misc import retarget_instructions
 
                     self.qbool = QuantumBool(name="ctrl env*")
                     retarget_instructions(
                         self.env_data, [self.condition_truth_value], [self.qbool[0]]
                     )
-                    
+
                     if isinstance(self.env_qs.data[-1], QuantumEnvironment):
                         env = self.env_qs.data.pop(-1)
                         env.compile()
 
-                    
                     self.condition_truth_value = self.qbool[0]
 
                 ctrl_qubits.append(self.parent_cond_env.condition_truth_value)
 
                 if self.ctrl_state != -1:
                     self.ctrl_state += 2 ** (len(ctrl_qubits) - 1)
 
@@ -206,15 +209,15 @@
                         env.condition_truth_value for env in self.sub_condition_envs
                     ]
                     continue
 
                 if (
                     instruction.op.name in ["qb_alloc", "qb_dealloc"]
                     and instruction.qubits[0] != self.condition_truth_value
-                )   or instruction.op.name == "barrier":
+                ) or instruction.op.name == "barrier":
                     self.env_qs.append(instruction)
                     continue
 
                 if set(instruction.qubits).intersection(subcondition_truth_values):
                     self.env_qs.append(instruction)
                     continue
 
@@ -264,9 +267,8 @@
 
         if self.parent_cond_env is not None:
             self.parent_cond_env.sub_condition_envs.extend(
                 self.sub_condition_envs + [self]
             )
 
 
-
 control = ControlEnvironment
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/gate_wrap_environment.py` & `qrisp-0.0.16/src/qrisp/environments/gate_wrap_environment.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,24 +7,25 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.environments import QuantumEnvironment
 from qrisp.circuit import QuantumCircuit
+from qrisp.environments import QuantumEnvironment
 
 
 class GateWrapEnvironment(QuantumEnvironment):
     """
     This environment allows to hide complexity in the circuit visualisation.
-    Operations appended inside this environment are bundled into a single :ref:`Instruction` object.
+    Operations appended inside this environment are bundled into a single
+    :ref:`Instruction` object.
 
-    The functionality of this :ref:`QuantumEnvironment` can also be used with the 
+    The functionality of this :ref:`QuantumEnvironment` can also be used with the
     :meth:`gate_wrap <qrisp.gate_wrap>` decorator.
 
     After compiling, the wrapped instruction can be retrieved using the
     ``.instruction`` attribute.
 
     Parameters
     ----------
@@ -72,15 +73,16 @@
     >>> print(instruction.op.definition)
            ┌───┐
     qb_41: ┤ X ├
            ├───┤
     qb_42: ┤ Y ├
            └───┘
 
-    Using the :meth:`gate_wrap <qrisp.gate_wrap>` decorator we can quickly gate wrap functions: ::
+    Using the :meth:`gate_wrap <qrisp.gate_wrap>` decorator we can quickly gate wrap
+    functions: ::
 
         from qrisp import gate_wrap
 
         @gate_wrap
         def example_function(qv):
             x(qv[0])
             y(qv[1])
@@ -112,19 +114,19 @@
         self.manual_allocation_management = True
 
     def compile(self):
         temp_data_list = list(self.env_qs.data)
 
         self.env_qs.data = []
         super().compile()
-        
+
         compiled_qc = self.env_qs.clearcopy()
-        
+
         compiled_qc.data = list(self.env_qs.data)
-        
+
         self.env_qs.clear_data()
         self.env_qs.data.extend(temp_data_list)
 
         if len(compiled_qc.data) == 0:
             self.instruction = None
             return None
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/quantum_conditionals.py` & `qrisp-0.0.16/src/qrisp/environments/quantum_conditionals.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,26 +6,26 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
+from qrisp.core.library import mcx, p, rz, x, z
+from qrisp.core.quantum_variable import QuantumVariable
+from qrisp.core.session_merging_tools import merge
 from qrisp.environments.quantum_environments import QuantumEnvironment
 from qrisp.environments.quantum_inversion import invert
 from qrisp.misc import (
+    find_calling_line,
     perm_lock,
     perm_unlock,
-    unlock,
     redirect_qfunction,
-    find_calling_line,
+    unlock,
 )
-from qrisp.core.library import x, rz, p, z, mcx
-from qrisp.core.quantum_variable import QuantumVariable
-from qrisp.core.session_merging_tools import merge
 
 
 def quantum_condition(function):
     def q_env_generator(*args, **kwargs):
         return ConditionEnvironment(function, args, kwargs=kwargs)
 
     return q_env_generator
@@ -58,34 +58,36 @@
         with q_ch == "a":
             qf += 2
 
 
     >>> print(multi_measurement([q_ch,qf]))
     {('a', 2): 0.5, ('b', 0): 0.5}
 
-    In this code snippet, we first bring the :ref:`QuantumChar` ``q_ch`` into the superposition
+    In this code snippet, we first bring the :ref:`QuantumChar` ``q_ch`` into the
+    superposition
 
     .. math::
 
         \ket{\text{q_ch}} = \frac{1}{\sqrt{2}} \left( \ket{\text{"a"}}
         + \ket{\text{"b"}} \right)
 
     After that, we enter the ConditionEnvironment, which controls the operations
     on the condition that ``q_ch`` is in state $\ket{a}$. Finally, we simultaneously
-    measure both :ref:`QuantumVariables <QuantumVariable>`. We see that the incrementation 
-    of ``qf`` only occured on the branch, where ``q_ch`` is equal to the character ``"a"``.
-    The resulting quantum state is:
+    measure both :ref:`QuantumVariables <QuantumVariable>`. We see that the
+    incrementation of ``qf`` only occured on the branch, where ``q_ch`` is equal to the
+    character ``"a"``. The resulting quantum state is:
 
     .. math::
 
         \ket{\psi} = \frac{1}{\sqrt{2}} \left( \ket{\text{"a"}}\ket{2}
         + \ket{\text{"b"}}\ket{0} \right)
 
     It is furthermore possible to invert the condition truth value or apply phases.
-    For this we acquire the :ref:`QuantumBool` containing the truth value using the *as* statement ::
+    For this we acquire the :ref:`QuantumBool` containing the truth value using the *as*
+    statement ::
 
         from qrisp import x, p
         import numpy as np
 
         with q_ch == "a" as cond_bool:
             qf += 2
             cond_bool.flip()
@@ -118,27 +120,28 @@
     We will now demonstrate how a ConditionEnvironment, that evaluates the equality of
     two :ref:`QuantumVariables <QuantumVariable>` can be constructed: ::
 
         from qrisp import QuantumBool, QuantumVariable, x, cx, mcx
 
         def quantum_eq(qv_0, qv_1):
 
-            
+
 
             if qv_0.size != qv_1.size:
-                raise Exception("Tried to evaluate equality condition for QuantumVariables of differing size")
+                raise Exception("Tried to evaluate equality condition for
+                QuantumVariables of differing size")
 
             temp_qv = QuantumVariable(qv_0.size)
 
             cx(qv_0, temp_qv)
             cx(qv_1, temp_qv)
             x(temp_qv)
 
             res = QuantumBool()
-            
+
             mcx(temp_qv, res)
 
             return res
 
     In this function, we create a temporary variable where we apply CX gates controlled
     on the inputs onto. The qubits where ``qv_0`` and ``qv_1`` agree, will then be in
     state $\ket{0}$. After this, we apply regular X gates onto ``temp_qv`` such that
@@ -152,52 +155,52 @@
     >>> q_ch_0 = QuantumChar()
     >>> q_ch_1 = QuantumChar()
     >>> res_bool = quantum_eq(q_ch_0, q_ch_1)
     >>> print(q_ch_0.qs)
     QuantumCircuit:
     ---------------
      q_ch_0.0: ──■─────────────────────────────────────────────────────────
-                 │                                                         
+                 │
      q_ch_0.1: ──┼────■────────────────────────────────────────────────────
-                 │    │                                                    
+                 │    │
      q_ch_0.2: ──┼────┼────■───────────────────────────────────────────────
-                 │    │    │                                               
+                 │    │    │
      q_ch_0.3: ──┼────┼────┼────■──────────────────────────────────────────
-                 │    │    │    │                                          
+                 │    │    │    │
      q_ch_0.4: ──┼────┼────┼────┼────■─────────────────────────────────────
-                 │    │    │    │    │                                     
+                 │    │    │    │    │
      q_ch_1.0: ──┼────┼────┼────┼────┼────■────────────────────────────────
-                 │    │    │    │    │    │                                
+                 │    │    │    │    │    │
      q_ch_1.1: ──┼────┼────┼────┼────┼────┼────■───────────────────────────
-                 │    │    │    │    │    │    │                           
+                 │    │    │    │    │    │    │
      q_ch_1.2: ──┼────┼────┼────┼────┼────┼────┼────■──────────────────────
-                 │    │    │    │    │    │    │    │                      
+                 │    │    │    │    │    │    │    │
      q_ch_1.3: ──┼────┼────┼────┼────┼────┼────┼────┼────■─────────────────
-                 │    │    │    │    │    │    │    │    │                 
+                 │    │    │    │    │    │    │    │    │
      q_ch_1.4: ──┼────┼────┼────┼────┼────┼────┼────┼────┼────■────────────
-               ┌─┴─┐  │    │    │    │  ┌─┴─┐  │    │    │    │  ┌───┐     
+               ┌─┴─┐  │    │    │    │  ┌─┴─┐  │    │    │    │  ┌───┐
     temp_qv.0: ┤ X ├──┼────┼────┼────┼──┤ X ├──┼────┼────┼────┼──┤ X ├──■──
-               └───┘┌─┴─┐  │    │    │  └───┘┌─┴─┐  │    │    │  ├───┤  │  
+               └───┘┌─┴─┐  │    │    │  └───┘┌─┴─┐  │    │    │  ├───┤  │
     temp_qv.1: ─────┤ X ├──┼────┼────┼───────┤ X ├──┼────┼────┼──┤ X ├──■──
-                    └───┘┌─┴─┐  │    │       └───┘┌─┴─┐  │    │  ├───┤  │  
+                    └───┘┌─┴─┐  │    │       └───┘┌─┴─┐  │    │  ├───┤  │
     temp_qv.2: ──────────┤ X ├──┼────┼────────────┤ X ├──┼────┼──┤ X ├──■──
-                         └───┘┌─┴─┐  │            └───┘┌─┴─┐  │  ├───┤  │  
+                         └───┘┌─┴─┐  │            └───┘┌─┴─┐  │  ├───┤  │
     temp_qv.3: ───────────────┤ X ├──┼─────────────────┤ X ├──┼──┤ X ├──■──
-                              └───┘┌─┴─┐               └───┘┌─┴─┐├───┤  │  
+                              └───┘┌─┴─┐               └───┘┌─┴─┐├───┤  │
     temp_qv.4: ────────────────────┤ X ├────────────────────┤ X ├┤ X ├──■──
                                    └───┘                    └───┘└───┘┌─┴─┐
         res.0: ───────────────────────────────────────────────────────┤ X ├
                                                                       └───┘
     Live QuantumVariables:
     ----------------------
     QuantumChar q_ch_0
     QuantumChar q_ch_1
     QuantumVariable temp_qv
     QuantumBool res
-    
+
     We can now construct the conditional environment from this function ::
 
         from qrisp import ConditionEnvironment, multi_measurement, h
 
         #Create some sample arguments on which to evaluate the condition
 
         q_bool_0 = QuantumBool()
@@ -209,15 +212,16 @@
         with ConditionEnvironment(cond_eval_function = quantum_eq,
                                   args = [q_bool_0, q_bool_1]):
             q_bool_2.flip()
 
     >>> print(multi_measurement([q_bool_0, q_bool_1, q_bool_2]))
     {(False, False, True): 0.5, (True, False, False): 0.5}
 
-    This agrees with our expectation, that ``q_bool_2`` is only ``True`` if the other two agree.
+    This agrees with our expectation, that ``q_bool_2`` is only ``True`` if the other
+    two agree.
 
     **The quantum_condition decorator**
 
     Creating quantum conditions like this seems a bit unwieldy.
     For a more convenient solution, we provide the ``quantum_condition`` decorator.
     This decorator can be applied to a function returning a :ref:`QuantumBool`,
     which is then returning the corresponding ConditionEnvironment instead.
@@ -267,31 +271,31 @@
         h(n[0])
 
         n_results = n.get_measurement()
 
         for i in qRange(n):
             qf += i
 
-    
+
     >>> print(qf)
     {10: 0.5, 15: 0.5}
 
     This script calculates the sum of all integers up to a certain threshold.
-    The threshold (n) is a :ref:`QuantumFloat` in superposition, implying the result of the sum
-    is also in a superposition. The expected results can be quickly determined
+    The threshold (n) is a :ref:`QuantumFloat` in superposition, implying the result of
+    the sum is also in a superposition. The expected results can be quickly determined
     by using Gauß's formula:
 
     .. math::
 
         \sum_{i = 0}^n i = \frac{n(n+1)}{2}
 
 
     >>> print("Excpected outcomes:", [n*(n+1)/2 for n in n_results.keys()])
     Excpected outcomes: [10.0, 15.0]
-    
+
     """
 
     # Constructor of the class
 
     def __init__(self, cond_eval_function, args, kwargs={}):
         # The function which evaluates the condition - should return a QuantumBool
         self.cond_eval_function = cond_eval_function
@@ -337,17 +341,16 @@
                 self.parent_cond_env = env
                 break
             if not isinstance(env, (QuantumEnvironment, InversionEnvironment)):
                 break
 
     # Compile method
     def compile(self):
-        from qrisp.qtypes.quantum_bool import QuantumBool
-
         from qrisp.environments import ControlEnvironment
+        from qrisp.qtypes.quantum_bool import QuantumBool
 
         # Create the quantum variable where the condition truth value should be saved
         # Incase we have a parent environment we create two qubits because
         # we use the second qubit to compute the toffoli of this one and the parent
         # environments truth value in order to not have the environment operations
         # controlled on two qubits
 
@@ -387,20 +390,19 @@
             else:
                 # Without any parent environment we can simply synhesize the
                 # truth value of the quantum condition into it's qubit
 
                 redirect_qfunction(self.cond_eval_function)(
                     *self.args, target=self.qbool, **self.kwargs
                 )
-                
+
                 if isinstance(self.env_qs.data[-1], QuantumEnvironment):
                     env = self.env_qs.data.pop(-1)
                     env.compile()
-                
-                
+
                 cond_eval_bool = self.qbool
 
             from qrisp import recursive_qv_search
 
             perm_lock(recursive_qv_search(self.args))
 
             unlock(self.condition_truth_value)
@@ -483,15 +485,14 @@
                 )
                 # Append instruction
                 self.env_qs.append(instruction)
 
             unlock(self.condition_truth_value)
             perm_unlock(self.condition_truth_value)
             if inversion_tracker == -1:
-                
                 x(self.condition_truth_value)
 
             perm_unlock(recursive_qv_search(self.args))
 
             # Uncompute truth values
 
             # If we had a parent environment, we first uncompute the
@@ -500,15 +501,15 @@
             if self.parent_cond_env is not None:
                 self.parent_cond_env.sub_condition_envs.extend(
                     self.sub_condition_envs + [self]
                 )
                 mcx(toffoli_qb_list, self.qbool, method="gray_pt_inv")
                 self.qbool.delete()
 
-            # We now uncompute this environments truth value
+            # We now uncompute the environments' truth value
 
             # For this we can use the uncompute method, which will however not
             # recompute any intermediate values, therefore blocking alot of qubits
             # during execution. Especially in nested environments this can quickly
             # become a problem, because the blocked ancillae can not be reused
             # for further condition evaluations.
 
@@ -527,19 +528,19 @@
 
             if recompute:
                 with invert():
                     redirected_qfunction = redirect_qfunction(self.cond_eval_function)
                     redirected_qfunction(
                         *self.args, target=cond_eval_bool, **self.kwargs
                     )
-                
+
                 if isinstance(self.env_qs.data[-1], QuantumEnvironment):
                     env = self.env_qs.data.pop(-1)
                     env.compile()
-                
+
                 cond_eval_bool.delete()
 
 
 # This decorator allows to have conditional evaluations to return condition environments
 # when called after a "with" statement but QuantumBools otherwise.
 
 # from qrisp import QuantumFloat
@@ -581,16 +582,17 @@
             return uncomputed_function(*args, **kwargs)
 
     return new_cond_eval_function
 
 
 @adaptive_condition
 def q_eq(input_0, input_1):
-    from qrisp.qtypes.quantum_bool import QuantumBool
     from qrisp import cx
+    from qrisp.qtypes.quantum_bool import QuantumBool
+
     res = QuantumBool(name="eq_cond*")
 
     if isinstance(input_1, QuantumVariable):
         if input_0.size != input_1.size:
             raise Exception(
                 "Tried to evaluate equality conditional"
                 "for QuantumVariables of differing size"
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/quantum_environments.py` & `qrisp-0.0.16/src/qrisp/environments/quantum_environments.py`

 * *Files 12% similar despite different names*

```diff
@@ -43,24 +43,24 @@
 
 # 3. At environment exit, every quantum session, that operated inside this environment
 # is merged together.
 
 # 4. Apart from the (de)allocation gates, all the collected data is stored inside
 # the .env_data attribute
 
-from qrisp.core.quantum_session import QuantumSession
 from qrisp.circuit import QubitAlloc, QubitDealloc
+from qrisp.core.quantum_session import QuantumSession
 
 
 class QuantumEnvironment:
     """
-    
+
     QuantumEnvironments are blocks of code, that undergo some user-specified compilation
-    process. They can be entered using the ``with`` statement 
-    
+    process. They can be entered using the ``with`` statement
+
     ::
 
        from qrisp import QuantumEnvironment, QuantumVariable, x
 
        qv = QuantumVariable(5)
 
        with QuantumEnvironment():
@@ -82,105 +82,108 @@
     qv.3: ┤ X ├
           ├───┤
     qv.4: ┤ X ├
           └───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable qv
-    
+
     More advanced environments allow for a large variety of features and can significantly
-    simplify code development and maintainance. 
-    
+    simplify code development and maintainance.
+
     The most important built-in QuantumEnvironments are:
-    
-    * :ref:`ConditionEnvironment`    
-    
+
+    * :ref:`ConditionEnvironment`
+
     * :ref:`ControlEnvironment`
-    
+
     * :ref:`InversionEnvironment`
-    
+
     * :ref:`GateWrapEnvironment`
-    
-    Due to sophisticated condition evaluation of nested :ref:`conditionenvironment` and :ref:`controlenvironment`,
-    using QuantumEnvironments even can bring an increase in performance,
-    compared to the `control method <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.control.html>`_
+
+    Due to sophisticated condition evaluation of nested :ref:`conditionenvironment` and
+    :ref:`controlenvironment`, using QuantumEnvironments even can bring an increase in
+    performance, compared to the `control method
+    <https://qiskit.org/documentation/stubs/qiskit.circuit.QuantumCircuit.control.html>`_
     which is commonly implemented by QuantumCircuit-based approaches.
-    
+
     **Uncomputation within QuantumEnvironments**
-    
-    Uncomputation via the :meth:`uncompute <qrisp.QuantumVariable.uncompute>` method is possible 
-    only if the :ref:`QuantumVariable` has been created within the same or a sub-environment:
-        
+
+    Uncomputation via the :meth:`uncompute <qrisp.QuantumVariable.uncompute>` method is
+    possible only if the :ref:`QuantumVariable` has been created within the same or a
+    sub-environment:
+
     ::
-        
+
         from qrisp import QuantumVariable, QuantumEnvironment, cx
-        
+
         a = QuantumVariable(1)
-        
+
         with QuantumEnvironment():
-            
+
             b = QuantumVariable(1)
-            
-            cx(a,b)            
-            
+
+            cx(a,b)
+
             with QuantumEnvironment():
-                
+
                 c = QuantumVariable(1)
-                
+
                 cx(b,c)
-                
+
             c.uncompute() # works because c was created in a sub environment
             b.uncompute() # works because b was created in the same environment
-            # a.uncompute() # doesn't work because a was created outside this environment
-    
-    
+            # a.uncompute() # doesn't work because a was created outside this
+            environment.
+
+
     >>> print(a.qs)
     QuantumCircuit:
     ---------------
     a.0: ──■──────────────■──
          ┌─┴─┐          ┌─┴─┐
     b.0: ┤ X ├──■────■──┤ X ├
          └───┘┌─┴─┐┌─┴─┐└───┘
     c.0: ─────┤ X ├┤ X ├─────
-              └───┘└───┘     
+              └───┘└───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable a
-            
+
     **Visualisation within QuantumEnvironments**
-    
-    Calling ``print`` on a :ref:`QuantumSession` inside a QuantumEnvironment will display
-    only the instructions, that have been performed within this environment. ::
-        
+
+    Calling ``print`` on a :ref:`QuantumSession` inside a QuantumEnvironment will
+    display only the instructions, that have been performed within this environment. ::
+
         from qrisp import x, y, z
         a = QuantumVariable(3)
-        
+
         x(a[0])
-        
+
         with QuantumEnvironment():
-            
+
             y(a[1])
-            
+
             with QuantumEnvironment():
-                
+
                 z(a[2])
-                
+
                 print(a.qs)
-                
+
             print(a.qs)
-            
+
         print(a.qs)
-        
+
     Executing this snippet yields
-    
+
     >>>
     QuantumCircuit:
     ---------------
     a.0: ─────
-    <BLANKLINE>              
+    <BLANKLINE>
     a.1: ─────
          ┌───┐
     a.2: ┤ Z ├
          └───┘
     QuantumEnvironment Stack:
     -------------------------
     Level 0: QuantumEnvironment
@@ -212,40 +215,45 @@
     a.1: ┤ Y ├
          ├───┤
     a.2: ┤ Z ├
          └───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable a
-    
-    
+
+
     .. warning::
-    
-        Calling ``print`` within a QuantumEnvironment causes all sub environments to be compiled.
-        While this doesn't change the semantics of the resulting circuit, especially
-        nested :ref:`Condition <conditionenvironment>`- and :ref:`ControlEnvironments <controlenvironment>` lose a lot of efficiency if compiled prematurely.
-        Therefore, ``print``-calls within QuantumEnvironments are usefull for debugging purposes 
-        but should be removed, if efficiency is a concern.
-    
-    
+
+        Calling ``print`` within a QuantumEnvironment causes all sub environments to be
+        compiled. While this doesn't change the semantics of the resulting circuit,
+        especially nested :ref:`Condition <conditionenvironment>`- and
+        :ref:`ControlEnvironments <controlenvironment>` lose a lot of efficiency if
+        compiled prematurely. Therefore, ``print``-calls within QuantumEnvironments are
+        usefull for debugging purposes but should be removed, if efficiency is a
+        concern.
+
+
     **Creating custom QuantumEnvironments**
 
     More interesting QuantumEnvironments can be created by inheriting and modifying
     the compile method. In the following code snippet, we will demonstrate how to
     set up a QuantumEnvironment, that skips every second instruction. We do this
     by inheriting from the QuantumEnvironment class. This will provide us with
     the necessary attributes for writing the compile method:
 
-    #. ``.env_data``, which is the list of instructions, that have been appended in this environment. Note that child environments append themselves in this list upon exiting.
-    
-    #. ``.env_qs`` which is a QuantumSession, where all QuantumVariables, that operated inside this environment, are registered.
-
-    The compile method is then called once all environments of ``.env_qs`` have been exited.
-    Note that this doesn't neccessarily imply that all QuantumEnvironments have been
-    left. For more information about the interplay between QuantumSessions and
+    #. ``.env_data``, which is the list of instructions, that have been appended in this
+    environment. Note that child environments append themselves in this list upon
+    exiting.
+
+    #. ``.env_qs`` which is a QuantumSession, where all QuantumVariables, that operated
+    inside this environment, are registered.
+
+    The compile method is then called once all environments of ``.env_qs`` have been
+    exited. Note that this doesn't neccessarily imply that all QuantumEnvironments have
+    been left. For more information about the interplay between QuantumSessions and
     QuantumEnvironments check the :ref:`session merging <SessionMerging>` documentation.
 
     ::
 
        class ExampleEnvironment(QuantumEnvironment):
 
           def compile(self):
@@ -295,24 +303,24 @@
     qv.4: ─────
           ┌───┐
     qv.5: ┤ H ├
           └───┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable qv
-    
+
     """
 
     deepest_environment = [None]
 
     # The methods to start the dumping process for this environment
     # The dumping basically consists of copying the original data into a temporary
     # container (here the list .original_data) and then clearing the data of
     # the quantum session. Once the dumping ends the data which has been appended
-    # in the meantime is appended to the environments data list .env_data and
+    # in the meantime is appended to the environments' data list .env_data and
     # the original circuit data is reinstated
     def start_dumping(self):
         qs = self.env_qs
 
         # Temporarily store the qs circuit data
         self.original_data += qs.data
 
@@ -421,9 +429,7 @@
             # If the instruction is an environment, compile the environment
             if issubclass(instruction.__class__, QuantumEnvironment):
                 instruction.compile()
 
             else:
                 # Append instruction
                 self.env_qs.append(instruction)
-                
-
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/quantum_inversion.py` & `qrisp-0.0.16/src/qrisp/environments/quantum_inversion.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,37 +7,37 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-
-from qrisp.environments.quantum_environments import QuantumEnvironment
 from qrisp.circuit import QubitAlloc, QubitDealloc
+from qrisp.environments.quantum_environments import QuantumEnvironment
 
 
 # Environment inheritor where the environment content is appended as the inverse
 class InversionEnvironment(QuantumEnvironment):
     """
-    This QuantumEnvironment can be used to invert (ie. "dagger") a block of operations.
+    This QuantumEnvironment can be used to invert (i.e. "dagger") a block of operations.
 
     An alias for this is ``invert``.
 
     Examples
     --------
 
-    We increment a :ref:`QuantumFloat` and afterwards revert using the InversionEnvironment: ::
+    We increment a :ref:`QuantumFloat` and afterwards revert using the
+    InversionEnvironment: ::
 
         from qrisp import QuantumFloat, invert
-        
+
         qf = QuantumFloat(4)
-        
+
         qf += 3
-        
+
         with invert():
             qf += 3
 
 
     >>> print(qf)
     {0: 1.0}
     >>> print(qf.qs)
@@ -84,16 +84,16 @@
     >>> print(multi_measurement([qf, q_bool]))
     {(0, True): 0.125, (1, True): 0.125, (2, True): 0.125, (3, True): 0.125,
     (4, False): 0.125, (5, False): 0.125, (6, False): 0.125, (7, False): 0.125}
 
     .. note::
         In many cases, this way of manually uncomputing only works if the uncomputed
         function (in this case ``q_mult``) allows specifying the target variable.
-        Using the :meth:`redirect_qfunction <qrisp.redirect_qfunction>` decorator, you can turn any quantum function into
-        it's target specifiable version.
+        Using the :meth:`redirect_qfunction <qrisp.redirect_qfunction>` decorator, you
+        can turn any quantum function into it's target specifiable version.
 
     """
 
     def __enter__(self):
         self.manual_allocation_management = True
 
         QuantumEnvironment.__enter__(self)
```

### Comparing `qrisp-0.0.15/src/qrisp/environments/temp_var_environment.py` & `qrisp-0.0.16/src/qrisp/environments/temp_var_environment.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -7,19 +7,19 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.environments.quantum_inversion import invert
-from qrisp.environments.quantum_environments import QuantumEnvironment
+from qrisp.core.quantum_variable import QuantumVariable
 from qrisp.core.session_merging_tools import merge
+from qrisp.environments.quantum_environments import QuantumEnvironment
+from qrisp.environments.quantum_inversion import invert
 from qrisp.misc import lock, unlock
-from qrisp.core.quantum_variable import QuantumVariable
 
 
 def temp_qv(function):
     def q_env_generator(*args, **kwargs):
         return ConjugationEnvironment(function, args, kwargs=kwargs)
 
     return q_env_generator
```

### Comparing `qrisp-0.0.15/src/qrisp/grover/grover_tools.py` & `qrisp-0.0.16/src/qrisp/grover/grover_tools.py`

 * *Files 9% similar despite different names*

```diff
@@ -8,32 +8,32 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 import numpy as np
-from qrisp import gate_wrap, h, x, gphase, mcz, mcp, QuantumVariable, QuantumArray
+from qrisp import QuantumArray, QuantumVariable, gate_wrap, gphase, h, mcp, mcz, x, merge, recursive_qs_search
 
 
 # Applies the grover diffuser onto the (list of) quantum variable input_object
-def diffuser(input_object, phase = np.pi):
+def diffuser(input_object, phase=np.pi):
     """
     Applies the Grover diffuser onto (multiple) QuantumVariables.
 
     Parameters
     ----------
     input_object : QuantumVariable or list[QuantumVariable]
         The (list of) QuantumVariables to apply the Grover diffuser on.
-        
+
     Examples
     --------
-    
+
     We apply the Grover diffuser onto several QuantumChars:
-        
+
     >>> from qrisp import QuantumChar
     >>> from qrisp.grover import diffuser
     >>> q_ch_list = [QuantumChar(), QuantumChar(), QuantumChar()]
     >>> diffuser(q_ch_list)
     >>> print(q_ch_list[0].qs)
               ┌────────────┐
     q_ch_0.0: ┤0           ├
@@ -67,277 +67,331 @@
     q_ch_2.4: ┤14          ├
               └────────────┘
     """
 
     if isinstance(input_object, QuantumArray):
         input_object = [qv for qv in input_object.flatten()]
 
-
     if isinstance(input_object, list):
         [h(qv) for qv in input_object]
-        tag_state({qv : "0"*qv.size for qv in input_object}, binary_values = True, phase = phase)
+        tag_state(
+            {qv: "0" * qv.size for qv in input_object}, binary_values=True, phase=phase
+        )
         [h(qv) for qv in input_object]
         gphase(np.pi, input_object[0][0])
     else:
         h(input_object)
-        tag_state({input_object : input_object.size*"0"}, binary_values = True, phase = phase)
+        tag_state(
+            {input_object: input_object.size * "0"}, binary_values=True, phase=phase
+        )
         h(input_object)
         gphase(np.pi, input_object[0])
-        
-    return input_object
 
+    return input_object
 
 
-def tag_state(tag_specificator, binary_values = False, phase = np.pi):
+def tag_state(tag_specificator, binary_values=False, phase=np.pi):
     """
-    Applies a phase tag to (multiple) QuantumVariables. The tagged state is specified in the dictionary ``tag_specificator``.
-    This dictionary should contain the QuantumVariables as keys and the labels of the states which should be tagged as values.
+    Applies a phase tag to (multiple) QuantumVariables. The tagged state is specified in
+    the dictionary ``tag_specificator``. This dictionary should contain the
+    QuantumVariables as keys and the labels of the states which should be tagged as
+    values.
+
 
-    
     Parameters
     ----------
     tag_specificator : dict
         A dictionary specifying which state should be tagged.
     binary_values : bool, optional
-        If set to True, the values in the tag_specificator dict have to be bitstrings instead of labels. The default is False.
+        If set to True, the values in the tag_specificator dict have to be bitstrings
+        instead of labels. The default is False.
     phase : float or sympy.Symbol, optional
-        Specify the phase shift the tag should perform. The default is pi, ie. a multi-controlled Z gate.
+        Specify the phase shift the tag should perform. The default is pi, i.e. a
+        multi-controlled Z gate.
+
 
-    
     Examples
     --------
-    
+
     We construct an oracle that tags the states -3 and 2 on two QuantumFloats ::
-    
+
         from qrisp.grover import tag_state
-    
+
         def test_oracle(qf_list):
-            
+
             tag_dic = {qf_list[0] : -3, qf_list[1] : 2}
-            
+
             tag_state(tag_dic)
-        
+
     """
 
     qv_list = list(tag_specificator.keys())
-    
-    
+
     states = [tag_specificator[qv] for qv in qv_list]
-    
-    if not len(states):
-        states = ["1"*qv.size for qv in qv_list]
 
+    if not len(states):
+        states = ["1" * qv.size for qv in qv_list]
 
     # The phase tag will be executed by a multicontrolled z-gate
     # Even though the multicontrolled z-gate has no prefered qubit,
     # in qiskit we have to give one "base" qubit and the other qubits are
     # the control qubits. For the control qubits we can easily specify the required
-    # control state, however for the base qubit its not that easy.
+    # control state, however for the base qubit it's not that easy.
     # If our base qubit should be in state 0 we therefore have to apply an x gate
     # on it, execute the controlled z gate and then apply another x gate
 
     # Apply x gate (if neccessary)
 
     bit_string = ""
     from qrisp.misc import bin_rep
-    
-    
+
     for i in range(len(qv_list)):
         if binary_values:
             bit_string += states[i][::-1]
         else:
             bit_string += bin_rep(qv_list[i].encoder(states[i]), qv_list[i].size)[::-1]
 
-
     qubit_list = sum([list(qv.reg) for qv in qv_list], [])
     state = bit_string
 
     if state[-1] == "0":
         x(qubit_list[-1])
 
     # The control state is the state we are looking for without the base qubit
     ctrl_state = state[:-1]
     if phase == np.pi:
-        mcz(qubit_list, ctrl_state = ctrl_state + "1")
+        mcz(qubit_list, ctrl_state=ctrl_state + "1")
     else:
-        mcp(phase, qubit_list, ctrl_state = ctrl_state + "1")
-    
+        mcp(phase, qubit_list, ctrl_state=ctrl_state + "1")
+
     # Apply the final x gate
     if state[-1] == "0":
         x(qubit_list[-1])
-                
-        
 
 
-def grovers_alg(qv_list, oracle_function, kwargs= {}, iterations = 0, winner_state_amount = None, exact = False):
+def grovers_alg(
+    qv_list,
+    oracle_function,
+    kwargs={},
+    iterations=0,
+    winner_state_amount=None,
+    exact=False,
+):
     r"""
     Applies Grover's algorithm to a given oracle (in the form of a Python function).
 
     Parameters
     ----------
     qv_list : QuantumVariable or list[QuantumVariable]
         A (list of) QuantumVariables on which to execute Grover's algorithm.
     oracle_function : function
         A Python function tagging the winner states.
     kwargs : dict, optional
         A dictionary containing keyword arguments for the oracle. The default is {}.
     iterations : int, optional
-        The amount of Grover iterations to perfrom. 
+        The amount of Grover iterations to perfrom.
     winner_state_amount : int, optional
-        If not given the amount of iterations, the established formula will be used based on the amount of winner states. The default is 1.
+        If not given the amount of iterations, the established formula will be used
+        based on the amount of winner states. The default is 1.
     exact : bool, optional
-        If set to True, the `exact version <https://arxiv.org/pdf/quant-ph/0106071.pdf>`_ of Grover's algorithm will be evaluated. For this, the correct ``winner_state_amount`` has to be supplied and the oracle has to support the keyword argument ``phase`` which specifies how much the winner states are phaseshifted (in standard Grover this would be $\pi$).
+        If set to True, the `exact version <https://arxiv.org/pdf/quant-ph/0106071.pdf>`
+        of Grover's algorithm will be evaluated. For this, the correct
+        ``winner_state_amount`` has to be supplied and the oracle has to support the
+        keyword argument ``phase`` which specifies how much the winner states are
+        phaseshifted (in standard Grover this would be $\pi$).
+        
+    Raises
+    ------
+    
+    Exception
+        Applied oracle introducing new QuantumVariables without uncomputing/deleting
 
     Examples
     --------
-    
-    We construct an oracle that tags the states -3 and 2 on two QuantumFloats and apply Grover's algorithm to it. ::
-        
+
+    We construct an oracle that tags the states -3 and 2 on two QuantumFloats and apply
+    Grover's algorithm to it. ::
+
         from qrisp import QuantumFloat
-        
+
         #Create list of QuantumFloats
         qf_list = [QuantumFloat(2, signed = True), QuantumFloat(2, signed = True)]
-        
+
         from qrisp.grover import tag_state, grovers_alg
-        
+
         def test_oracle(qf_list):
-        
+
             tag_dic = {qf_list[0] : -3, qf_list[1] : 2}
             tag_state(tag_dic)
-        
-        grovers_alg(qf_list, test_oracle)        
-        
+
+        grovers_alg(qf_list, test_oracle)
+
     >>> from qrisp.misc import multi_measurement
     >>> print(multi_measurement(qf_list))
-    {(-3, 2): 0.9966, (0, 0): 0.0001, (0, 1): 0.0001, (0, 2): 0.0001, (0, 3): 0.0001, (0, -4): 0.0001, (0, -3): 0.0001, (0, -2): 0.0001, (0, -1): 0.0001, (1, 0): 0.0001, (1, 1): 0.0001, (1, 2): 0.0001, (1, 3): 0.0001, (1, -4): 0.0001, (1, -3): 0.0001, (1, -2): 0.0001, (1, -1): 0.0001, (2, 0): 0.0001, (2, 1): 0.0001, (2, 2): 0.0001, (2, 3): 0.0001, (2, -4): 0.0001, (2, -3): 0.0001, (2, -2): 0.0001, (2, -1): 0.0001, (3, 0): 0.0001, (3, 1): 0.0001, (3, 2): 0.0001, (3, 3): 0.0001, (3, -4): 0.0001, (3, -3): 0.0001, (3, -2): 0.0001, (3, -1): 0.0001, (-4, 0): 0.0001, (-4, 1): 0.0001, (-4, 2): 0.0001, (-4, 3): 0.0001, (-4, -4): 0.0001, (-4, -3): 0.0001, (-4, -2): 0.0001, (-4, -1): 0.0001, (-3, 0): 0.0001, (-3, 1): 0.0001, (-3, 3): 0.0001, (-3, -4): 0.0001, (-3, -3): 0.0001, (-3, -2): 0.0001, (-3, -1): 0.0001, (-2, 0): 0.0001, (-2, 1): 0.0001, (-2, 2): 0.0001, (-2, 3): 0.0001, (-2, -4): 0.0001, (-2, -3): 0.0001, (-2, -2): 0.0001, (-2, -1): 0.0001, (-1, 0): 0.0001, (-1, 1): 0.0001, (-1, 2): 0.0001, (-1, 3): 0.0001, (-1, -4): 0.0001, (-1, -3): 0.0001, (-1, -2): 0.0001, (-1, -1): 0.0001}
-    
+    {(-3, 2): 0.9966, (0, 0): 0.0001, (0, 1): 0.0001, (0, 2): 0.0001, (0, 3): 0.0001,
+    (0, -4): 0.0001, (0, -3): 0.0001, (0, -2): 0.0001, (0, -1): 0.0001, (1, 0): 0.0001,
+    (1, 1): 0.0001, (1, 2): 0.0001, (1, 3): 0.0001, (1, -4): 0.0001, (1, -3): 0.0001,
+    (1, -2): 0.0001, (1, -1): 0.0001, (2, 0): 0.0001, (2, 1): 0.0001, (2, 2): 0.0001,
+    (2, 3): 0.0001, (2, -4): 0.0001, (2, -3): 0.0001, (2, -2): 0.0001, (2, -1): 0.0001,
+    (3, 0): 0.0001, (3, 1): 0.0001, (3, 2): 0.0001, (3, 3): 0.0001, (3, -4): 0.0001,
+    (3, -3): 0.0001, (3, -2): 0.0001, (3, -1): 0.0001, (-4, 0): 0.0001, (-4, 1): 0.0001,
+     (-4, 2): 0.0001, (-4, 3): 0.0001, (-4, -4): 0.0001, (-4, -3): 0.0001,
+     (-4, -2): 0.0001, (-4, -1): 0.0001, (-3, 0): 0.0001, (-3, 1): 0.0001,
+     (-3, 3): 0.0001, (-3, -4): 0.0001, (-3, -3): 0.0001, (-3, -2): 0.0001,
+     (-3, -1): 0.0001, (-2, 0): 0.0001, (-2, 1): 0.0001, (-2, 2): 0.0001,
+     (-2, 3): 0.0001, (-2, -4): 0.0001, (-2, -3): 0.0001, (-2, -2): 0.0001,
+     (-2, -1): 0.0001, (-1, 0): 0.0001, (-1, 1): 0.0001, (-1, 2): 0.0001,
+     (-1, 3): 0.0001, (-1, -4): 0.0001, (-1, -3): 0.0001, (-1, -2): 0.0001,
+     (-1, -1): 0.0001}
+
     **Exact Grovers Algorithm**
-    
-    In the next example, we will showcase the ``exact`` functionality. For this we create an oracle, which tags all the states of a QuantumVariable, that contain 3 ones and 2 zeros. 
-    
+
+    In the next example, we will showcase the ``exact`` functionality. For this we
+    create an oracle, which tags all the states of a QuantumVariable, that contain 3
+    ones and 2 zeros.
+
     To count the amount of ones we use quantum phase estimation on the operator
-    
+
     .. math::
-        
-        U = \text{exp}\left(\frac{i 2 \pi}{2^k} \sum_{i = 0}^{n-1} ( 1 - \sigma_{z}^i )\right)
-    
-    
+
+        U = \text{exp}\left(\frac{i 2 \pi}{2^k}
+        \sum_{i = 0}^{n-1} ( 1 - \sigma_{z}^i )\right)
+
+
     ::
-    
+
         from qrisp import QPE, p, QuantumVariable, lifted
         from qrisp.grover import grovers_alg, tag_state
         import numpy as np
-    
+
         def U(qv, prec = None, iter = 1):
             for i in range(qv.size):
                 p(iter*2*np.pi/2**prec, qv[i])
-        
+
         @lifted
         def count_ones(qv):
             prec = int(np.ceil(np.log2(qv.size+1)))
             res = QPE(qv, U, precision = prec, iter_spec = True, kwargs = {"prec" : prec})
             return res<<prec
 
 
     Quick test:
-        
+
     >>> qv = QuantumVariable(5)
     >>> qv[:] = {"11000" : 1, "11010" : 1, "11110" : 1}
     >>> count_qf = count_ones(qv)
     >>> count_qf.qs.statevector()
     sqrt(3)*(|11000>*|2> + |11010>*|3> + |11110>*|4>)/3
-    
+
     We now define the oracle ::
 
         def counting_oracle(qv, phase = np.pi, k = 1):
-            
+
             count_qf = count_ones(qv)
-            
+
             tag_state({count_qf : k}, phase = phase)
-            
+
             count_qf.uncompute()
-    
+
     And evaluate Grover's algorithm ::
-    
+
         n = 5
         k = 3
         qv = QuantumVariable(n)
-        
+
         import math
-        
-        grovers_alg(qv, counting_oracle, exact = True, winner_state_amount = math.comb(n,k), kwargs = {"k" : k})
-    
-    
+
+        grovers_alg(qv, counting_oracle, exact = True, winner_state_amount = math.comb(n,k), kwargs = {"k" : k})  # noqa
+
+
     >>> print(qv)
-    {'11100': 0.1, 
-     '11010': 0.1, 
-     '10110': 0.1, 
-     '01110': 0.1, 
-     '11001': 0.1, 
-     '10101': 0.1, 
-     '01101': 0.1, 
-     '10011': 0.1, 
-     '01011': 0.1, 
+    {'11100': 0.1,
+     '11010': 0.1,
+     '10110': 0.1,
+     '01110': 0.1,
+     '11001': 0.1,
+     '10101': 0.1,
+     '01101': 0.1,
+     '10011': 0.1,
+     '01011': 0.1,
      '00111': 0.1}
-    
-    We see that contrary to regular Grover's algorithm, the states which have not been tagged by the oracle have 0 percent measurement probability.
-    
+
+    We see that contrary to regular Grover's algorithm, the states which have not been
+    tagged by the oracle have 0 percent measurement probability.
+
     """
-    
+
     if exact and winner_state_amount is None:
-        raise Exception("Tried to call exact Grover's algorithm without specifying winner_state_amount")
+        raise Exception(
+            "Tried to call exact Grover's algorithm without specifying "
+            "winner_state_amount"
+        )
     elif winner_state_amount is None:
         winner_state_amount = 1
 
-
-    
-
     if isinstance(qv_list, list):
-        N = 2**sum([qv.size for qv in qv_list])
+        N = 2 ** sum([qv.size for qv in qv_list])
     elif isinstance(qv_list, QuantumArray):
-        N = 2**sum([qv.size for qv in qv_list.flatten()])
+        N = 2 ** sum([qv.size for qv in qv_list.flatten()])
     elif isinstance(qv_list, QuantumVariable):
         N = 2**qv_list.size
 
     if exact:
-        #Implementation for phase calculation for exact grovers alg as in https://arxiv.org/pdf/quant-ph/0106071.pdf
+        # Implementation for phase calculation for exact grovers alg as in
+        # https://arxiv.org/pdf/quant-ph/0106071.pdf
         iterations = 1
-        tmp = np.sin(np.pi/(4*(iterations-1)+6))*(N/winner_state_amount)**0.5
-        
+        tmp = (
+            np.sin(np.pi / (4 * (iterations - 1) + 6))
+            * (N / winner_state_amount) ** 0.5
+        )
+
         while tmp > 1:
-            iterations += 1            
-            tmp = np.sin(np.pi/(4*(iterations-1)+6))*(N/winner_state_amount)**0.5
-            
-        phi = 2*np.arcsin(np.sin(np.pi/(4*(iterations-1)+6))*(N/winner_state_amount)**0.5)
+            iterations += 1
+            tmp = (
+                np.sin(np.pi / (4 * (iterations - 1) + 6))
+                * (N / winner_state_amount) ** 0.5
+            )
+
+        phi = 2 * np.arcsin(
+            np.sin(np.pi / (4 * (iterations - 1) + 6))
+            * (N / winner_state_amount) ** 0.5
+        )
 
-    else:    
-        
+    else:
         if iterations == 0:
-
-            iterations = np.pi/4*np.sqrt(N/winner_state_amount)
+            iterations = np.pi / 4 * np.sqrt(N / winner_state_amount)
             iterations = int(np.round(iterations))
 
-    for qv in qv_list: h(qv)
+    for qv in qv_list:
+        h(qv)
+
+    merge(qv_list)
+    qs = recursive_qs_search(qv_list)[0]
     
+    qv_amount = len(qs.qv_list)
+
     for i in range(iterations):
         if exact:
-            oracle_function(qv_list, phase = phi, **kwargs)
-            diffuser(qv_list, phase = phi)
+            oracle_function(qv_list, phase=phi, **kwargs)
+            diffuser(qv_list, phase=phi)
         else:
             oracle_function(qv_list, **kwargs)
             diffuser(qv_list)
+            
+        if qv_amount != len(qs.qv_list):
+            raise Exception("Applied oracle introducing new QuantumVariables without uncomputing/deleting")
+
 
-#Workaround to keep the docstring but still gatewrap
+# Workaround to keep the docstring but still gatewrap
 
 temp = diffuser.__doc__
 
-diffuser = gate_wrap(permeability = [], is_qfree = False)(diffuser)
+diffuser = gate_wrap(permeability=[], is_qfree=False)(diffuser)
 
 diffuser.__doc__ = temp
 
 
 temp = tag_state.__doc__
 
-tag_state = gate_wrap(permeability = "args", is_qfree = True)(tag_state)
+tag_state = gate_wrap(permeability="args", is_qfree=True)(tag_state)
 
 tag_state.__doc__ = temp
-
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/backends.py` & `qrisp-0.0.16/src/qrisp/interface/backends.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,93 +14,99 @@
 from qrisp.interface import BackendClient
 
 
 class VirtualBackend(BackendClient):
     """
     This class provides a virtual backend for circuit execution.
     Virtual means that the server is running on the same machine as a separate
-    Python thread. This structure allows setting up convenient wrappers for foreign/modified circuit dispatching code.
-    
+    Python thread. This structure allows setting up convenient wrappers for foreign/
+    modified circuit dispatching code.
+
     Circuits can be run using ``virtual_backend_instance.run(qc)``.
     The function that should be used to run a circuit can be specified during
     construction using the ``run_func`` parameter.
-    
-    
+
+
     Parameters
     ----------
     run_func : function
-        A function that recieves a QuantumCircuit, an integer specifiying the amount of shots and a token in the form of a string. It returns the counts as a dictionary of bitstrings.
+        A function that recieves a QuantumCircuit, an integer specifiying the amount of
+        shots and a token in the form of a string. It returns the counts as a dictionary
+        of bitstrings.
     name : str, optional
         A name for the virtual backend. The default is None.
     port : int, optional
         The port on which to listen. The default is None.
     ping_func : TYPE, optional
         A function which returns a BackendStatus object. The default is None.
 
-    
+
     Examples
     --------
-    
-    
-    We set up a VirtualBackend, which prints the received QuantumCircuit and returns the results of the QASM simulator. ::
-    
+
+
+    We set up a VirtualBackend, which prints the received QuantumCircuit and returns the
+    results of the QASM simulator. ::
+
         from qrisp.interface import convert_to_qiskit
-        
+
         def run_func(qc, shots, token = ""):
-            
+
             qiskit_qc = convert_to_qiskit(qc)
-            
+
             print(qiskit_qc)
-            
+
             from qiskit import Aer
             qiskit_backend = Aer.get_backend('qasm_simulator')
-            
+
             #Run Circuit on the Qiskit backend
             return qiskit_backend.run(qiskit_qc, shots = shots).result().get_counts()
-    
+
 
     >>> from qrisp.interface import VirtualBackend
     >>> example_backend = VirtualBackend(run_func)
     >>> from qrisp import QuantumFloat
     >>> qf = QuantumFloat(3)
     >>> qf[:] = 4
     >>> qf.get_measurement(backend = example_backend)
-                 ┌─┐      
+                 ┌─┐
     qf.0:   ─────┤M├──────
-                 └╥┘┌─┐   
+                 └╥┘┌─┐
     qf.1:   ──────╫─┤M├───
             ┌───┐ ║ └╥┘┌─┐
     qf.2:   ┤ X ├─╫──╫─┤M├
             └───┘ ║  ║ └╥┘
     cb_0: 1/══════╩══╬══╬═
-                  0  ║  ║ 
+                  0  ║  ║
     cb_1: 1/═════════╩══╬═
-                     0  ║ 
+                     0  ║
     cb_2: 1/════════════╩═
     {4: 1.0}
-    
-    """
 
-    def __init__(self, run_func, name = None, port = None, ping_func = None):
+    """
 
-        if name == None:
+    def __init__(self, run_func, name=None, port=None, ping_func=None):
+        if name is None:
             name = "virtual_quantum_backend"
         else:
             name = "virtual_quantum_backend_" + name
 
         from qrisp.interface import BackendServer
+
         # Create BackendServer
-        self.backend_server = BackendServer(run_func, "::1", port = port, name = name, ping_func = ping_func)
+        self.backend_server = BackendServer(
+            run_func, "::1", port=port, name=name, ping_func=ping_func
+        )
         # Run the server (runs in the background)
         self.backend_server.start()
         # Connect client
 
         super().__init__(socket_ip="::1", port=port)
 
-    def run(self, qc, shots, token = ""):
+    def run(self, qc, shots, token=""):
         """
         Executes the function run_func specified at object creation.
 
         Parameters
         ----------
         qc : QuantumCircuit
             The QuantumCircuit to run.
@@ -110,130 +116,135 @@
         Returns
         -------
         res : dict
             A dictionary containing the measurement results.
 
         """
         return super().run(qc, shots, token)
-    
+
     def ping(self):
         """
         Executes the function ping_func specified at object creation.
 
 
         Returns
         -------
         res : BackendStatus object
 
         """
         return super().ping()
-        
-    
 
 
 class VirtualQiskitBackend(VirtualBackend):
     """
     This class instantiates a VirtualBackend using a Qiskit backend.
     This allows easy access to Qiskit backends through the qrisp interface.
-    
-    
+
+
     Parameters
     ----------
     backend : Qiskit backend object, optional
-        A Qiskit backend object, which runs QuantumCircuits. The default is Aer.get_backend('qasm_simulator').
+        A Qiskit backend object, which runs QuantumCircuits. The default is
+        Aer.get_backend('qasm_simulator').
     port : int, optional
         The port to listen. The default is 8079.
 
     Examples
     --------
-    
+
     We evaluate a QuantumFloat multiplication on the QASM-simulator.
-    
+
     >>> from qrisp import QuantumFloat
     >>> from qrisp.interface import VirtualQiskitBackend
     >>> from qiskit import Aer
     >>> example_backend = VirtualQiskitBackend(backend = Aer.get_backend('qasm_simulator'))
     >>> qf = QuantumFloat(4)
     >>> qf[:] = 3
     >>> res = qf*qf
     >>> res.get_measurement(backend = example_backend)
     {9: 1.0}
-    
-    
+
+
     """
-    from qiskit import Aer
 
-    def __init__(self, backend = None, port=8079):
+    from qiskit import Aer
 
+    def __init__(self, backend=None, port=8079):
         if backend is None:
             from qiskit import Aer
-            backend = Aer.get_backend('qasm_simulator')
+
+            backend = Aer.get_backend("qasm_simulator")
+
         # Create the run method
         def run(qc, shots, token):
-
             # Convert to qiskit
             from qrisp.interface.circuit_converter import convert_circuit
 
-            qiskit_qc = convert_circuit(qc, "qiskit", transpile = True)
+            qiskit_qc = convert_circuit(qc, "qiskit", transpile=True)
 
             from qiskit import transpile
-            
-            qiskit_qc = transpile(qiskit_qc, backend = backend)
+
+            qiskit_qc = transpile(qiskit_qc, backend=backend)
             # Run Circuit on the Qiskit backend
-            qiskit_result = backend.run(qiskit_qc, shots = shots).result().get_counts()
+            qiskit_result = backend.run(qiskit_qc, shots=shots).result().get_counts()
             # Remove the spaces in the qiskit result keys
             result_dic = {}
             import re
+
             for key in qiskit_result.keys():
                 counts_string = re.sub(r"\W", "", key)
                 result_dic[counts_string] = qiskit_result[key]
 
             return result_dic
 
-
         # Create the ping method
         def ping():
-
             # Collect information about backend to create BackendStatus object
 
             config = backend.configuration()
 
             # Information about Qubits and their conznectivity
-            from qrisp.interface import PortableQubit, ConnectivityEdge
+            from qrisp.interface import ConnectivityEdge, PortableQubit
 
             qubit_list = []
             for i in range(config.n_qubits):
                 qubit_list.append(PortableQubit(str(i)))
 
             connectivity_map = []
 
             if config.coupling_map:
                 for edge in config.coupling_map:
-                    connectivity_map.append(ConnectivityEdge(qubit_list[edge[0]], qubit_list[edge[1]]))
+                    connectivity_map.append(
+                        ConnectivityEdge(qubit_list[edge[0]], qubit_list[edge[1]])
+                    )
 
             # Information about elementary gates
             from qrisp.circuit.standard_operations import op_list
- 
+
             # TO-DO fix elementary ops
             for gate_name in config.basis_gates:
                 for op in op_list:
                     if op().name == gate_name:
                         pass
                         # elementary_ops.append(op())
 
             elementary_ops = []
             from qrisp.interface import BackendStatus
 
             # Create BackendStatus object
-            backend_status = BackendStatus(name=config.backend_name, qubit_list=qubit_list,
-                                           elementary_ops=elementary_ops, connectivity_map=connectivity_map,
-                                           online=True)
+            backend_status = BackendStatus(
+                name=config.backend_name,
+                qubit_list=qubit_list,
+                elementary_ops=elementary_ops,
+                connectivity_map=connectivity_map,
+                online=True,
+            )
 
             return backend_status
 
         # Call VirtualBackend constructor
         if isinstance(backend.name, str):
             name = backend.name
         else:
             name = backend.name()
-        
+
         super().__init__(run, name=name, ping_func=ping, port=port)
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/circuit_converter.py` & `qrisp-0.0.16/src/qrisp/interface/circuit_converter.py`

 * *Files 23% similar despite different names*

```diff
@@ -8,250 +8,275 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 from qrisp.misc import bin_rep
+from qrisp.circuit.standard_operations import op_list
 
-def convert_circuit(qc, target_api = "thrift", transpile = True):
 
-    
+def convert_circuit(qc, target_api="thrift", transpile=True):
     if transpile or target_api == "open_api":
         from qrisp.circuit import transpile
+
         qc = transpile(qc)
-    
 
     if target_api == "thrift":
-        from qrisp.interface.thrift_interface.interface_types import PortableQuantumCircuit, PortableQubit, PortableClbit, PortableOperation, PortableInstruction
+        from qrisp.interface.thrift_interface.interface_types import (
+            PortableClbit,
+            PortableInstruction,
+            PortableOperation,
+            PortableQuantumCircuit,
+            PortableQubit,
+        )
     elif target_api == "open_api":
-        from qrisp.interface.openapi_interface.interface_types import PortableQuantumCircuit, PortableQubit, PortableClbit, PortableOperation, PortableInstruction
+        from qrisp.interface.openapi_interface.interface_types import (
+            PortableClbit,
+            PortableInstruction,
+            PortableOperation,
+            PortableQuantumCircuit,
+            PortableQubit,
+        )
     elif target_api == "qrisp":
         return convert_to_qrisp(qc)
     elif target_api == "qiskit":
         return convert_to_qiskit(qc, transpile)
-    
 
-    
-    
-    circuit_qubits = [PortableQubit(identifier = qb.identifier) for qb in qc.qubits]    
-    circuit_clbits = [PortableClbit(identifier = cb.identifier) for cb in qc.clbits]    
-    
-    
-    
-    res_qc = PortableQuantumCircuit(qubits = circuit_qubits, clbits = circuit_clbits, data = [])
-    
+    circuit_qubits = [PortableQubit(identifier=qb.identifier) for qb in qc.qubits]
+    circuit_clbits = [PortableClbit(identifier=cb.identifier) for cb in qc.clbits]
+
+    res_qc = PortableQuantumCircuit(
+        qubits=circuit_qubits, clbits=circuit_clbits, data=[]
+    )
+
     for i in range(len(qc.data)):
         instr = qc.data[i]
         if instr.op.name in ["qb_alloc", "qb_dealloc"]:
             # continue
             pass
-        
-        
+
         params = []
         for j in range(len(instr.op.params)):
             value = float(instr.op.params[j])
             params.append(value)
-        
-        
-        if instr.op.definition != None:
-            definition = convert_circuit(instr.op.definition, target_api, transpile = False)
-            op = PortableOperation(name = instr.op.name, num_qubits = instr.op.num_qubits, num_clbits = instr.op.num_clbits, params = params, definition = definition)
+
+        if instr.op.definition is not None:
+            definition = convert_circuit(
+                instr.op.definition, target_api, transpile=False
+            )
+            op = PortableOperation(
+                name=instr.op.name,
+                num_qubits=instr.op.num_qubits,
+                num_clbits=instr.op.num_clbits,
+                params=params,
+                definition=definition,
+            )
         else:
-            op = PortableOperation(name = instr.op.name, num_qubits = instr.op.num_qubits, num_clbits = instr.op.num_clbits, params = params)
-            
-        qubits = [PortableQubit(identifier = qb.identifier) for qb in instr.qubits]
-        clbits = [PortableClbit(identifier = cb.identifier) for cb in instr.clbits]
-        
-        res_qc.data.append(PortableInstruction(op = op, qubits = qubits, clbits = clbits))
-    
+            op = PortableOperation(
+                name=instr.op.name,
+                num_qubits=instr.op.num_qubits,
+                num_clbits=instr.op.num_clbits,
+                params=params,
+            )
+
+        qubits = [PortableQubit(identifier=qb.identifier) for qb in instr.qubits]
+        clbits = [PortableClbit(identifier=cb.identifier) for cb in instr.clbits]
+
+        res_qc.data.append(PortableInstruction(op=op, qubits=qubits, clbits=clbits))
+
     return res_qc
-    
+
 
 def convert_to_qrisp(qc):
-    from qrisp.circuit import QuantumCircuit, Qubit, Clbit, Operation, Instruction, op_list, fast_append
-    
-    op_dict = {op().name : op for op in op_list}
-    
+    from qrisp.circuit import (
+        Clbit,
+        Instruction,
+        Operation,
+        QuantumCircuit,
+        Qubit,
+        fast_append,
+        op_list,
+    )
+
+    op_dict = {op().name: op for op in op_list}
+
     res_qc = QuantumCircuit()
-    
-    
-    #This dic gives the qiskit qubits/clbits when presented with their identifier
+
+    # This dic gives the qiskit qubits/clbits when presented with their identifier
     bit_dic = {}
-    
-    #Add Qubits
+
+    # Add Qubits
     for i in range(len(qc.qubits)):
         res_qc.add_qubit(Qubit(qc.qubits[i].identifier))
         bit_dic[qc.qubits[i].identifier] = res_qc.qubits[-1]
-        
-    #Add Clbits
+
+    # Add Clbits
     for i in range(len(qc.clbits)):
         res_qc.add_clbit(Clbit(qc.clbits[i].identifier))
         bit_dic[qc.clbits[i].identifier] = res_qc.clbits[-1]
-    
-    
+
     with fast_append():
         for i in range(len(qc.data)):
             instr = qc.data[i]
-            #Prepare qubits
+            # Prepare qubits
             qubit_list = [bit_dic[qubit.identifier] for qubit in instr.qubits]
             clbit_list = [bit_dic[clbit.identifier] for clbit in instr.clbits]
-    
+
             if not instr.op.definition is None:
-                op = convert_to_qrisp(instr.op.definition).to_op()        
+                op = convert_to_qrisp(instr.op.definition).to_op()
             elif instr.op.name in op_dict.keys():
                 op = op_dict[instr.op.name](*instr.op.params)
             elif instr.op.name[5:] in op_dict.keys():
                 if instr.op.name[:5] == "c_if_":
                     op = op_dict[instr.op.name[5:]](*instr.op.params).c_if()
             elif instr.op.name[-3:] == "_dg" and instr.op.name[:-3] in op_dict.keys():
                 op = op_dict[instr.op.name[:-3]](*instr.op.params).inverse()
             else:
-                raise Exception("Don't know how to convert operation " + str(instr.op.name) + " to qrisp")
-            
-            
+                raise Exception(
+                    "Don't know how to convert operation "
+                    + str(instr.op.name)
+                    + " to qrisp"
+                )
+
             res_qc.data.append(Instruction(op, qubit_list, clbit_list))
-        
+
     return res_qc
-    
-#Function to convert qrisp quantum circuits to Qiskit quantum circuits
-def convert_to_qiskit(qc, transpile = False):
-    
-    from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
-        
-    
+
+
+# Function to convert qrisp quantum circuits to Qiskit quantum circuits
+def convert_to_qiskit(qc, transpile=False):
+    from qiskit import ClassicalRegister, QuantumCircuit, QuantumRegister
+
     if transpile:
         from qrisp.circuit.transpiler import transpile
-            
+
         qc = transpile(qc)
-    
-    #Create circuit
+
+    # Create circuit
 
     qiskit_qc = QuantumCircuit()
 
-    
-    #This dic gives the qiskit qubits/clbits when presented with their identifier
+    # This dic gives the qiskit qubits/clbits when presented with their identifier
     bit_dic = {}
-    
-    
-    #Add Qubits
+
+    # Add Qubits
     for i in range(len(qc.qubits)):
-        qiskit_qc.add_register(QuantumRegister(1, name = qc.qubits[i].identifier))
-        
+        qiskit_qc.add_register(QuantumRegister(1, name=qc.qubits[i].identifier))
+
         bit_dic[qc.qubits[i].identifier] = qiskit_qc.qubits[-1]
-        
-    #Add Clbits
+
+    # Add Clbits
     for i in range(len(qc.clbits)):
-        qiskit_qc.add_register(ClassicalRegister(1, name = qc.clbits[i].identifier))
-        
+        qiskit_qc.add_register(ClassicalRegister(1, name=qc.clbits[i].identifier))
+
         bit_dic[qc.clbits[i].identifier] = qiskit_qc.clbits[-1]
-    
 
-    #Add Instructions
-    from qiskit.circuit import Instruction, ControlledGate, Barrier, Gate
+    # Add Instructions
     import qiskit.circuit.library.standard_gates as qsk_gates
-    
+    from qiskit.circuit import Barrier, ControlledGate, Gate, Instruction
     from qiskit.circuit.measure import Measure
-    
+
     from qrisp.circuit import ControlledOperation
+
     for i in range(len(qc.data)):
         op = qc.data[i].op
-        
+
         params = list(op.params)
-        
-        #Prepare qiskit qubits
+
+        # Prepare qiskit qubits
         qubit_list = [bit_dic[qubit.identifier] for qubit in qc.data[i].qubits]
         clbit_list = [bit_dic[clbit.identifier] for clbit in qc.data[i].clbits]
-        
+
         if hasattr(op, "global_phase"):
             qiskit_qc.global_phase += op.global_phase
-        
+
         if op.name in ["qb_alloc", "qb_dealloc"]:
             continue
             temp = QuantumCircuit(1)
             qiskit_ins = temp.to_gate()
             qiskit_ins.name = op.name
-            
-        
+
         elif op.name == "gphase":
             temp_qc = QuantumCircuit(1)
             qiskit_ins = temp_qc.to_gate()
             qiskit_ins.name = "gphase"
-        
+
         elif op.name == "cx":
             if hasattr(op, "ctrl_state"):
-                qiskit_ins = qsk_gates.XGate().control(ctrl_state = op.ctrl_state)
+                qiskit_ins = qsk_gates.XGate().control(ctrl_state=op.ctrl_state)
             else:
                 qiskit_ins = qsk_gates.XGate().control()
         elif op.name == "cz":
             if hasattr(op, "ctrl_state"):
-                qiskit_ins = qsk_gates.ZGate().control(ctrl_state = op.ctrl_state)
+                qiskit_ins = qsk_gates.ZGate().control(ctrl_state=op.ctrl_state)
             else:
                 qiskit_ins = qsk_gates.ZGate().control()
         elif op.name == "cy":
             if hasattr(op, "ctrl_state"):
-                qiskit_ins = qsk_gates.YGate().control(ctrl_state = op.ctrl_state)
+                qiskit_ins = qsk_gates.YGate().control(ctrl_state=op.ctrl_state)
             else:
                 qiskit_ins = qsk_gates.YGate().control()
-        
+
         elif issubclass(op.__class__, ControlledOperation):
-            
-            
             base_name = op.base_operation.name
-            
+
             if len(base_name) == 1:
                 base_name = base_name.upper()
-            
+
             if op.base_operation.definition:
-                
                 qiskit_definition = convert_to_qiskit(op.base_operation.definition)
                 base_gate = qiskit_definition.to_gate()
                 base_gate.name = op.base_operation.name
-                qiskit_ins = base_gate.control(len(op.controls), ctrl_state = op.ctrl_state[::-1])
-                
+                qiskit_ins = base_gate.control(
+                    len(op.controls), ctrl_state=op.ctrl_state[::-1]
+                )
+
             else:
-                
                 base_gate = create_qiskit_instruction(op.base_operation, params)
-                qiskit_ins = base_gate.control(len(op.controls), ctrl_state = op.ctrl_state[::-1])
-            
-            
+                qiskit_ins = base_gate.control(
+                    len(op.controls), ctrl_state=op.ctrl_state[::-1]
+                )
+
         else:
             qiskit_ins = create_qiskit_instruction(op, params)
-            
-        #Append to qiskit circuit
+
+        # Append to qiskit circuit
         qiskit_qc.append(qiskit_ins, qubit_list, clbit_list)
-    
-    
-    #Return result
+
+    # Return result
     return qiskit_qc
 
-def create_qiskit_instruction(op, params = []):
 
+def create_qiskit_instruction(op, params=[]):
     import qiskit.circuit.library.standard_gates as qsk_gates
-    from qiskit.circuit.measure import Measure
     from qiskit.circuit import Barrier
+    from qiskit.circuit.measure import Measure
 
     if op.name == "rxx":
         qiskit_ins = qsk_gates.RXXGate(*params)
+    elif op.name == "rzz":
+        qiskit_ins = qsk_gates.RZZGate(*params)
+    elif op.name == "ryy":
+        qiskit_ins = qsk_gates.RYYGate(*params)
     
     elif op.name == "measure":
         qiskit_ins = Measure()
-    
+
     elif op.name == "swap":
         qiskit_ins = qsk_gates.SwapGate()
-    
+
     elif op.definition:
-        
         qiskit_definition = convert_to_qiskit(op.definition)
         if len(op.definition.clbits):
             qiskit_ins = qiskit_definition.to_instruction()
         else:
             qiskit_ins = qiskit_definition.to_gate()
         qiskit_ins.name = op.name
-    
+
     elif op.name == "cp":
         qiskit_ins = qsk_gates.CPGate(params[0])
     elif op.name == "x":
         qiskit_ins = qsk_gates.XGate()
     elif op.name == "y":
         qiskit_ins = qsk_gates.YGate()
     elif op.name == "z":
@@ -283,86 +308,91 @@
         qiskit_ins = qsk_gates.U3Gate(*params)
     elif op.name == "id":
         qiskit_ins = qsk_gates.IGate()
     elif op.name == "barrier":
         qiskit_ins = Barrier(op.num_qubits)
     else:
         raise Exception("Could not convert operation " + str(op.name) + " to Qiskit")
-        
+
     return qiskit_ins
 
 
-from qrisp.circuit.standard_operations import op_list
-op_dic = {op().name : op for op in op_list}
+op_dic = {op().name: op for op in op_list}
 op_dic["u"] = op_dic["u3"]
 
+
 def convert_from_qiskit(qiskit_qc):
-    
     from qiskit import transpile
     from qiskit.circuit import ControlledGate
-    from qrisp import QuantumCircuit, Qubit, Clbit, op_list, ControlledOperation
-    
+
+    from qrisp import Clbit, ControlledOperation, QuantumCircuit, Qubit, op_list
+
     qc = QuantumCircuit()
-    
+
     for i in range(qiskit_qc.num_qubits):
         q_reg = qiskit_qc.qubits[i]._register
-        
+
         qubit_name = q_reg.name
         if q_reg.size > 1:
             qubit_name += "." + str(q_reg._bits.index(qiskit_qc.qubits[i]))
-        
+
         qc.add_qubit(Qubit(qubit_name))
-    
+
     for i in range(qiskit_qc.num_clbits):
-        
         cl_reg = qiskit_qc.clbits[i]._register
-        
+
         clbit_name = cl_reg.name
         if cl_reg.size > 1:
             clbit_name += "." + str(cl_reg._bits.index(qiskit_qc.clbits[i]))
-        
+
         qc.add_clbit(Clbit(clbit_name))
-    
-    
-    qb_dic = {qiskit_qc.qubits[i] : qc.qubits[i] for i in range(qiskit_qc.num_qubits)}
-    cb_dic = {qiskit_qc.clbits[i] : qc.clbits[i] for i in range(qiskit_qc.num_clbits)}
-    
+
+    qb_dic = {qiskit_qc.qubits[i]: qc.qubits[i] for i in range(qiskit_qc.num_qubits)}
+    cb_dic = {qiskit_qc.clbits[i]: qc.clbits[i] for i in range(qiskit_qc.num_clbits)}
+
     for i in range(len(qiskit_qc.data)):
-        
         qiskit_op = qiskit_qc.data[i][0]
-        
+
         if isinstance(qiskit_op, ControlledGate):
             controlled_gate = True
             qiskit_op = qiskit_op.base_gate
         else:
             controlled_gate = False
-        
-        
+
         params = list(qiskit_op.params)
         for j in range(len(qiskit_op.params)):
-            if not isinstance(qiskit_op.params[j], float):                
+            if not isinstance(qiskit_op.params[j], float):
                 params[j] = float(qiskit_op.params[j])
 
-    
         try:
             op = op_dic[qiskit_op.name](*params)
         except KeyError:
-            try:    
+            try:
                 op = op_dic[qiskit_op.name.lower()](*params)
             except KeyError:
-                if not qiskit_op.definition is None:
-                    op = convert_from_qiskit(qiskit_op.definition).to_gate(name = qiskit_op.name)
+                if qiskit_op.definition is not None:
+                    op = convert_from_qiskit(qiskit_op.definition).to_gate(
+                        name=qiskit_op.name
+                    )
                 else:
-                    raise Exception("Could not convert Qiskit operation " + str(qiskit_op.name) + " to Qrisp")
-                
+                    raise Exception(
+                        "Could not convert Qiskit operation "
+                        + str(qiskit_op.name)
+                        + " to Qrisp"
+                    )
 
         if controlled_gate:
             qiskit_op = qiskit_qc.data[i][0]
-            op = ControlledOperation(base_operation = op, num_ctrl_qubits = qiskit_op.num_ctrl_qubits, ctrl_state = bin_rep(qiskit_op.ctrl_state, qiskit_op.num_ctrl_qubits)[::-1])
-        
-        
+            op = ControlledOperation(
+                base_operation=op,
+                num_ctrl_qubits=qiskit_op.num_ctrl_qubits,
+                ctrl_state=bin_rep(qiskit_op.ctrl_state, qiskit_op.num_ctrl_qubits)[
+                    ::-1
+                ],
+            )
+
         qubits = [qb_dic[qb] for qb in qiskit_qc.data[i][1]]
         clbits = [cb_dic[cb] for cb in qiskit_qc.data[i][2]]
-        
+
         qc.append(op, qubits, clbits)
-    
-    return qc
+
+    return qc
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/openapi_interface/__init__.py` & `qrisp-0.0.16/src/qrisp/interface/openapi_interface/__init__.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,28 +1,28 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 path = str(__file__)[:-11]
 client_path = path + "/codegen/client"
 server_path = path + "/codegen/server"
 
 import sys
+
 sys.path.insert(0, client_path)
 sys.path.insert(0, server_path)
 
 from qrisp.interface.openapi_interface.backend_client import BackendClient
 from qrisp.interface.openapi_interface.backend_server import BackendServer
 from qrisp.interface.openapi_interface.interface_types import *
 
-
 sys.path.pop(0)
 sys.path.pop(0)
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/openapi_interface/backend_client.py` & `qrisp-0.0.16/src/qrisp/interface/openapi_interface/backend_client.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,42 +1,45 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
-
-from qrisp.interface.openapi_interface.codegen.client.openapi_client.api.default_api import DefaultApi
-from qrisp.interface.openapi_interface.codegen.client.openapi_client.models import InlineObject
-from qrisp.interface.openapi_interface.codegen.client.openapi_client import Configuration, ApiClient
-
 from qrisp.interface.circuit_converter import convert_circuit
+from qrisp.interface.openapi_interface.codegen.client.openapi_client import (
+    ApiClient,
+    Configuration,
+)
+from qrisp.interface.openapi_interface.codegen.client.openapi_client.api.default_api \
+    import DefaultApi
+from qrisp.interface.openapi_interface.codegen.client.openapi_client.models import (
+    InlineObject,
+)
 
 
 class BackendClient(DefaultApi):
-    
     def __init__(self, socket_ip, port):
-        
         if socket_ip.find(":") != -1:
             socket_ip = "[" + socket_ip + "]"
-        
-        if port == None:
+
+        if port is None:
             port = 8080
-        
-        #TO-DO Allow API token/Secure connections ... check Configuration class definition
-        config = Configuration(host = "http://" + socket_ip + ":" + str(port))
-        client = ApiClient(configuration = config)
-        
+
+        # TO-DO Allow API token/Secure connections ...
+        # check Configuration class definition
+        config = Configuration(host="http://" + socket_ip + ":" + str(port))
+        client = ApiClient(configuration=config)
+
         super().__init__(client)
-    
-    
-    def run(self, qc, shots, token = ""):
-        request_object = InlineObject(qc  = convert_circuit(qc, "open_api"), shots = shots, token = token)
-        return super().run(inline_object = request_object)
+
+    def run(self, qc, shots, token=""):
+        request_object = InlineObject(
+            qc=convert_circuit(qc, "open_api"), shots=shots, token=token
+        )
+        return super().run(inline_object=request_object)
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/openapi_interface/backend_server.py` & `qrisp-0.0.16/src/qrisp/interface/openapi_interface/backend_server.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,32 +1,32 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
-import threading
 import os
+import threading
 
 import connexion
 import six
-
-import qrisp.interface.openapi_interface.codegen.server.openapi_server as openapi_server
+from connexion.apps.flask_app import FlaskJSONEncoder
+from openapi_server.models.backend_status import BackendStatus
 from openapi_server.models.base_model_ import Model
 from openapi_server.models.inline_object import InlineObject  # noqa: E501
-from openapi_server.models.backend_status import BackendStatus
 
-from connexion.apps.flask_app import FlaskJSONEncoder
+import qrisp.interface.openapi_interface.codegen.server.openapi_server as openapi_server
+
 
 class JSONEncoder(FlaskJSONEncoder):
     include_nulls = False
 
     def default(self, o):
         if isinstance(o, Model):
             dikt = {}
@@ -36,88 +36,93 @@
                     continue
                 attr = o.attribute_map[attr]
                 dikt[attr] = value
             return dikt
         return FlaskJSONEncoder.default(self, o)
 
 
-#Returns the hosts ip
+# Returns the hosts ip
 def get_ip():
     import socket
+
     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
     s.settimeout(0)
     try:
         # doesn't even have to be reachable
-        s.connect(('10.255.255.255', 1))
+        s.connect(("10.255.255.255", 1))
         IP = s.getsockname()[0]
     except Exception:
-        IP = '127.0.0.1'
+        IP = "127.0.0.1"
     finally:
         s.close()
     return IP
 
 
-
-#This class describes a Backend Server
+# This class describes a Backend Server
 class BackendServer:
-    
-    
-    #For the constructor we specify an function that runs the circuit, a socket ip adress, a port and the.
-    #Note that the name is supposed to be unique, that is if this python instance already
-    #runs a threat with that name, no new server is started
-    def __init__(self, run_func, socket_ip_address = None, port = None, name = "generic_quantum_backend_server", ping_func = None, online_status = True):
-        
-        self.app = connexion.App(__name__, specification_dir='./codegen/server/openapi_server/openapi/')
+    # For the constructor we specify a function that runs the circuit, a socket ip
+    # adress, a port and the name.
+    # Note that the name is supposed to be unique, that is if this python instance
+    # already runs a threat with that name, no new server is started
+    def __init__(
+        self,
+        run_func,
+        socket_ip_address=None,
+        port=None,
+        name="generic_quantum_backend_server",
+        ping_func=None,
+        online_status=True,
+    ):
+        self.app = connexion.App(
+            __name__, specification_dir="./codegen/server/openapi_server/openapi/"
+        )
         self.app.app.json_encoder = JSONEncoder
 
-
         @self.app.route("/run", methods=["POST"])
         def run():
             inline_object = InlineObject.from_dict(connexion.request.get_json())
             qc = inline_object.qc
             shots = inline_object.shots
             token = inline_object.token
-            
+
             return run_func(qc, shots, token)
-        
-        if ping_func != None:
+
+        if ping_func is not None:
+
             @self.app.route("/ping", methods=["GET"])
             def ping():
                 res = ping_func()
                 res.online = pass_online_status_bool_by_reference()
                 return res.to_dict()
-        
-            
+
         self.online_status = online_status
-        pass_online_status_bool_by_reference = lambda : self.online_status
-        
+        pass_online_status_bool_by_reference = lambda: self.online_status
+
         self.name = name
-        
-        if port == None:
+
+        if port is None:
             port = 8080
-        
-        if socket_ip_address == None:
+
+        if socket_ip_address is None:
             socket_ip_address = get_ip()
-            
+
         self.socket_ip_address = socket_ip_address
         self.port = port
-    
-    #Starts the server
+
+    # Starts the server
     def start(self):
-        
-        
-        #self.app.run(port=self.port)
-        
-        #import logging
-        #log = logging.getLogger('werkzeug')
-        #log.setLevel(logging.ERROR)
-        #Create thread
+        # self.app.run(port=self.port)
+
+        # import logging
+        # log = logging.getLogger('werkzeug')
+        # log.setLevel(logging.ERROR)
+        # Create thread
         from waitress import serve
-        
+
         def wrapper():
-            serve(self.app, host = self.socket_ip_address, port = self.port)
-            
-        thr = threading.Thread(target = wrapper)
+            serve(self.app, host=self.socket_ip_address, port=self.port)
+
+        thr = threading.Thread(target=wrapper)
         thr.setDaemon(True)
-        
-        #Start the thread
+
+        # Start the thread
         thr.start()
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/backend_client.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/backend_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -16,103 +16,100 @@
 from qrisp.interface.circuit_converter import convert_circuit
 from qrisp.interface.thrift_interface.codegen import BackendService
 
 
 class BackendClient(BackendService.Client):
     """
     This object allows connecting to Qrisp backend servers.
-    
+
     Parameters
     ----------
     socket_ip : string
         The IP address of the socket of the target server.
     port : int
         The port on which the server is listening.
 
-    
+
     Examples
     --------
 
     We assume that the example from BackendServer has been executed in the same console.
-    
+
     >>> from qrisp.interface import BackendClient
     >>> example_backend = BackendClient(socket_ip = "127.0.0.1", port = 8080)
     >>> from qrisp import QuantumCircuit
     >>> qc = QuantumCircuit(2)
     >>> qc.h(0)
     >>> qc.cx(0,1)
     >>> qc.measure(qc.qubits)
     >>> example_backend.run(qc, shots = 1000, token = "lorem ipsum")
     lorem ipsum
     {'0 0': 464, '1 1': 536}
-        
 
-    
-    """
 
-    def __init__(self, socket_ip, port = None):
 
-        from thrift.transport import TSocket, TTransport
+    """
+
+    def __init__(self, socket_ip, port=None):
         from thrift.protocol import TBinaryProtocol
+        from thrift.transport import TSocket, TTransport
 
-        if port == None:
+        if port is None:
             port = 9090
         # Create the transport for the User Interface to the server
         self.transport = TSocket.TSocket(socket_ip, port)
         # Buffering is critical. Raw sockets are very slow
         self.transport = TTransport.TBufferedTransport(self.transport)
         # Wrap in a protocol
         protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
-        
+
         self.socket_ip = socket_ip
 
         # Create a client to use the protocol encoder
         # client = BackendService.Client(protocol)
 
         super().__init__(protocol)
 
         # Connect!
         self.transport.open()
 
     # Destructor closes the transport
     def __del__(self):
         self.transport.close()
 
-    def run(self, qc, shots, token = ""):
+    def run(self, qc, shots, token=""):
         """
         Executes the ``run_func`` of the server.
 
         Parameters
         ----------
         qc : QuantumCircuit
             The QuantumCircuit to execute.
         shots : int
             The amount of shots.
         token : str, optional
-            A token which can be used for backend execution parameter specification. The default is "".
+            A token which can be used for backend execution parameter specification.
+            The default is "".
 
         Returns
         -------
         dict
-            A dictionary representing the counts where the keys are bitstrings and the values are integers.
+            A dictionary representing the counts where the keys are bitstrings and the
+            values are integers.
 
         """
-        
 
-        converted_circuit = convert_circuit(qc, "thrift", transpile = False)
-        
-        
+        converted_circuit = convert_circuit(qc, "thrift", transpile=False)
+
         return super().run(converted_circuit, shots, token)
-    
+
     def ping(self):
         """
         Executes the ``ping_func`` on the server.
-        
+
         Returns
         -------
         BackendStatus object
             An object which contains general information about the backend.
         """
-        
-        return super().ping()
-
 
+        return super().ping()
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/backend_server.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/backend_server.py`

 * *Files 12% similar despite different names*

```diff
@@ -9,169 +9,187 @@
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 import threading
 
-from thrift.transport import TSocket
-from thrift.transport import TTransport
 from thrift.protocol import TBinaryProtocol
-from qrisp.interface.thrift_interface.stoppable_thrift_server import StoppableThriftServer
+from thrift.transport import TSocket, TTransport
+
+from qrisp.interface.thrift_interface.stoppable_thrift_server import (
+    StoppableThriftServer,
+)
+from qrisp.interface.thrift_interface.codegen import BackendService
 
 
 # Returns the hosts ip
 def get_ip():
     import socket
+
     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
     s.settimeout(0)
     try:
         # doesn't even have to be reachable
-        s.connect(('10.255.255.255', 1))
+        s.connect(("10.255.255.255", 1))
         IP = s.getsockname()[0]
     except Exception:
-        IP = '127.0.0.1'
+        IP = "127.0.0.1"
     finally:
         s.close()
     return IP
 
 
-from qrisp.interface.thrift_interface.codegen import BackendService
-
-
 # This class describes a Backend Server
 class BackendServer:
     """
-    This class allows convienent setup of a server respecting the Qrisp interface.
-    
+    This class allows convenient setup of a server respecting the Qrisp interface.
+
     Parameters
     ----------
     run_func : function
-        A function that recieves a QuantumCircuit, an integer specifiying the amount of shots and a token in the form of a string. It returns the counts as a dictionary of bitstrings.
+        A function that receives a QuantumCircuit, an integer specifying the amount of
+        shots and a token in the form of a string. It returns the counts as a dictionary
+        of bitstrings.
     socket_ip_address : str, optional
-        The IP adress of where the listening socket should be opened. By default, the IP address of the hosting machine will be used.
+        The IP address of where the listening socket should be opened. By default, the
+        IP address of the hosting machine will be used.
     port : int, optional
-        The port on which to listen for requests. By default 9090 will be used.
+        The port on which to listen for requests. By default, 9090 will be used.
     name : str, optional
         A name for the server. The default is "generic_quantum_backend_server".
     ping_func : function, optional
         A function returning a BackendStatus object. The default is None.
     online_status : bool, optional
-        A bool specifying wether the server should be able to handle requests directly after startup. The default is True.
+        A bool specifying whether the server should be able to handle requests directly
+        after startup. The default is True.
+
 
-    
     Examples
     --------
-    
-    We create a server listening on the localhost IP address using a run function which prints the token and queries the QASM-simulator. ::
 
-        
-        
+    We create a server listening on the localhost IP address using a run function which
+    prints the token and queries the QASM-simulator. ::
+
+
+
         def run_func(qc, shots, token):
-            
+
             #Convert to qiskit
             from qrisp.interface.circuit_converter import convert_circuit
             qiskit_qc = convert_circuit(qc, "qiskit")
-            
+
             print(token)
-            
+
             from qiskit import Aer
             qiskit_backend = Aer.get_backend('qasm_simulator')
-            
+
             #Run Circuit on the Qiskit backend
             return qiskit_backend.run(qiskit_qc, shots = shots).result().get_counts()
 
         from qrisp.interface import BackendServer
         example_server = BackendServer(run_func, socket_ip_address = "127.0.0.1", port = 8080)
         example_server.start()
 
-    
+
     """
 
-    def __init__(self, run_func, socket_ip_address=None, port=None, transport=None,
-                 name="generic_quantum_backend_server", ping_func=None, online_status=True):
-    
-        if socket_ip_address == None:
+    def __init__(
+        self,
+        run_func,
+        socket_ip_address=None,
+        port=None,
+        transport=None,
+        name="generic_quantum_backend_server",
+        ping_func=None,
+        online_status=True,
+    ):
+        if socket_ip_address is None:
             socket_ip_address = get_ip()
 
         self.transport = transport
 
         self.socket_ip_address = socket_ip_address
 
         self.online_status = online_status
 
         self.run_func = run_func
 
-        if ping_func == None:
+        if ping_func is None:
+
             def ping_func():
                 from qrisp.interface import BackendStatus
+
                 return BackendStatus(name=name)
 
         self.ping_func = ping_func
 
         self.name = name
 
         self.port = port
 
     # Starts the server
     def start(self):
         """
         Starts the server.
         """
 
-        if self.port == None:
+        if self.port is None:
             self.port = 9090
 
         self.thread_name = self.name + ":" + str(self.port)
 
         # Create the BackendServiceHandler class
         ping_func = self.ping_func
         run_func = self.run_func
         pass_online_status_bool_by_reference = lambda: self.online_status
 
         class BackendServiceHandler:
-
             def run(self, qc, shots, token):
                 return run_func(qc, shots, token)
 
             def ping(self):
                 status = ping_func()
                 status.online = pass_online_status_bool_by_reference()
                 return status
 
         # Create server
         handler = BackendServiceHandler()
         processor = BackendService.Processor(handler)
         tfactory = TTransport.TBufferedTransportFactory()
 
-        if self.transport == None:
-            self.transport = TSocket.TServerSocket(host=self.socket_ip_address, port=self.port)
+        if self.transport is None:
+            self.transport = TSocket.TServerSocket(
+                host=self.socket_ip_address, port=self.port
+            )
 
         pfactory = TBinaryProtocol.TBinaryProtocolFactory()
 
         # server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)
         # self.server = TServer.TThreadedServer(processor, self.transport, tfactory, pfactory, daemon = True)
 
         # self.server = TNonblockingServer.TNonblockingServer(processor, self.transport, tfactory, pfactory)
-        self.server = StoppableThriftServer(processor, self.transport, tfactory, pfactory, daemon=True)
+        self.server = StoppableThriftServer(
+            processor, self.transport, tfactory, pfactory, daemon=True
+        )
 
         # Create thread
         self.thr = threading.Thread(target=self.server.serve, name=self.thread_name)
         self.thr.setDaemon(True)
 
         # Start the thread
         self.thr.start()
-        
+
         while True:
             if self.server.is_running:
                 break
 
     def stop(self):
         """
         Stops the server.
         """
         if hasattr(self, "server"):
             self.server.stop()
             self.thr.join()
 
     def __del__(self):
-        self.stop()
+        self.stop()
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/BackendService.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/BackendService.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,23 +14,31 @@
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+import logging
+import sys
+
 from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TProcessor,
+    TType,
+)
+from thrift.transport import TTransport
 from thrift.TRecursive import fix_spec
 
-import sys
-import logging
 from .ttypes import *
-from thrift.Thrift import TProcessor
-from thrift.transport import TTransport
+
 all_structs = []
 
 
 class Iface(object):
     def run(self, qc, shots, token):
         """
         Parameters:
@@ -60,15 +68,15 @@
          - token
 
         """
         self.send_run(qc, shots, token)
         return self.recv_run()
 
     def send_run(self, qc, shots, token):
-        self._oprot.writeMessageBegin('run', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("run", TMessageType.CALL, self._seqid)
         args = run_args()
         args.qc = qc
         args.shots = shots
         args.token = token
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
@@ -82,22 +90,24 @@
             iprot.readMessageEnd()
             raise x
         result = run_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT, "run failed: unknown result"
+        )
 
     def ping(self):
         self.send_ping()
         return self.recv_ping()
 
     def send_ping(self):
-        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("ping", TMessageType.CALL, self._seqid)
         args = ping_args()
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_ping(self):
         iprot = self._iprot
@@ -108,15 +118,17 @@
             iprot.readMessageEnd()
             raise x
         result = ping_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "ping failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT, "ping failed: unknown result"
+        )
 
 
 class Processor(Iface, TProcessor):
     def __init__(self, handler):
         self._handler = handler
         self._processMap = {}
         self._processMap["run"] = Processor.process_run
@@ -129,15 +141,17 @@
     def process(self, iprot, oprot):
         (name, type, seqid) = iprot.readMessageBegin()
         if self._on_message_begin:
             self._on_message_begin(name, type, seqid)
         if name not in self._processMap:
             iprot.skip(TType.STRUCT)
             iprot.readMessageEnd()
-            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
+            x = TApplicationException(
+                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
+            )
             oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
             x.write(oprot)
             oprot.writeMessageEnd()
             oprot.trans.flush()
             return
         else:
             self._processMap[name](self, seqid, iprot, oprot)
@@ -150,21 +164,23 @@
         result = run_result()
         try:
             result.success = self._handler.run(args.qc, args.shots, args.token)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("run", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_ping(self, seqid, iprot, oprot):
         args = ping_args()
@@ -173,46 +189,57 @@
         result = ping_result()
         try:
             result.success = self._handler.ping()
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("ping", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
+
 # HELPER FUNCTIONS AND STRUCTURES
 
 
 class run_args(object):
     """
     Attributes:
      - qc
      - shots
      - token
 
     """
 
-
-    def __init__(self, qc=None, shots=None, token=None,):
+    def __init__(
+        self,
+        qc=None,
+        shots=None,
+        token=None,
+    ):
         self.qc = qc
         self.shots = shots
         self.token = token
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -225,191 +252,249 @@
             elif fid == 2:
                 if ftype == TType.I32:
                     self.shots = iprot.readI32()
                 else:
                     iprot.skip(ftype)
             elif fid == 3:
                 if ftype == TType.STRING:
-                    self.token = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.token = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('run_args')
+        oprot.writeStructBegin("run_args")
         if self.qc is not None:
-            oprot.writeFieldBegin('qc', TType.STRUCT, 1)
+            oprot.writeFieldBegin("qc", TType.STRUCT, 1)
             self.qc.write(oprot)
             oprot.writeFieldEnd()
         if self.shots is not None:
-            oprot.writeFieldBegin('shots', TType.I32, 2)
+            oprot.writeFieldBegin("shots", TType.I32, 2)
             oprot.writeI32(self.shots)
             oprot.writeFieldEnd()
         if self.token is not None:
-            oprot.writeFieldBegin('token', TType.STRING, 3)
-            oprot.writeString(self.token.encode('utf-8') if sys.version_info[0] == 2 else self.token)
+            oprot.writeFieldBegin("token", TType.STRING, 3)
+            oprot.writeString(
+                self.token.encode("utf-8") if sys.version_info[0] == 2 else self.token
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(run_args)
 run_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRUCT, 'qc', [QuantumCircuit, None], None, ),  # 1
-    (2, TType.I32, 'shots', None, None, ),  # 2
-    (3, TType.STRING, 'token', 'UTF8', None, ),  # 3
+    (
+        1,
+        TType.STRUCT,
+        "qc",
+        [QuantumCircuit, None],
+        None,
+    ),  # 1
+    (
+        2,
+        TType.I32,
+        "shots",
+        None,
+        None,
+    ),  # 2
+    (
+        3,
+        TType.STRING,
+        "token",
+        "UTF8",
+        None,
+    ),  # 3
 )
 
 
 class run_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 0:
                 if ftype == TType.MAP:
                     self.success = {}
                     (_ktype64, _vtype65, _size63) = iprot.readMapBegin()
                     for _i67 in range(_size63):
-                        _key68 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                        _key68 = (
+                            iprot.readString().decode("utf-8", errors="replace")
+                            if sys.version_info[0] == 2
+                            else iprot.readString()
+                        )
                         _val69 = iprot.readI32()
                         self.success[_key68] = _val69
                     iprot.readMapEnd()
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('run_result')
+        oprot.writeStructBegin("run_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeFieldBegin("success", TType.MAP, 0)
             oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
             for kiter70, viter71 in self.success.items():
-                oprot.writeString(kiter70.encode('utf-8') if sys.version_info[0] == 2 else kiter70)
+                oprot.writeString(
+                    kiter70.encode("utf-8") if sys.version_info[0] == 2 else kiter70
+                )
                 oprot.writeI32(viter71)
             oprot.writeMapEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(run_result)
 run_result.thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+    (
+        0,
+        TType.MAP,
+        "success",
+        (TType.STRING, "UTF8", TType.I32, None, False),
+        None,
+    ),  # 0
 )
 
 
 class ping_args(object):
-
-
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('ping_args')
+        oprot.writeStructBegin("ping_args")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(ping_args)
-ping_args.thrift_spec = (
-)
+ping_args.thrift_spec = ()
 
 
 class ping_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -422,36 +507,45 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('ping_result')
+        oprot.writeStructBegin("ping_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            oprot.writeFieldBegin("success", TType.STRUCT, 0)
             self.success.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(ping_result)
 ping_result.thrift_spec = (
-    (0, TType.STRUCT, 'success', [BackendStatus, None], None, ),  # 0
+    (
+        0,
+        TType.STRUCT,
+        "success",
+        [BackendStatus, None],
+        None,
+    ),  # 0
 )
 fix_spec(all_structs)
 del all_structs
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/constants.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/constants.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 #
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+import sys
+
 from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TType,
+)
 from thrift.TRecursive import fix_spec
 
-import sys
 from .ttypes import *
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/codegen/ttypes.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/codegen/ttypes.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,73 +14,94 @@
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
-from thrift.protocol.TProtocol import TProtocolException
-from thrift.TRecursive import fix_spec
-
 import sys
 
+from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TType,
+)
 from thrift.transport import TTransport
+from thrift.TRecursive import fix_spec
+
 all_structs = []
 
 
 class Qubit(object):
     """
     Attributes:
      - identifier
 
     """
 
-
-    def __init__(self, identifier=None,):
+    def __init__(
+        self,
+        identifier=None,
+    ):
         self.identifier = identifier
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.identifier = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Qubit')
+        oprot.writeStructBegin("Qubit")
         if self.identifier is not None:
-            oprot.writeFieldBegin('identifier', TType.STRING, 1)
-            oprot.writeString(self.identifier.encode('utf-8') if sys.version_info[0] == 2 else self.identifier)
+            oprot.writeFieldBegin("identifier", TType.STRING, 1)
+            oprot.writeString(
+                self.identifier.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.identifier
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -88,56 +109,71 @@
 class Clbit(object):
     """
     Attributes:
      - identifier
 
     """
 
-
-    def __init__(self, identifier=None,):
+    def __init__(
+        self,
+        identifier=None,
+    ):
         self.identifier = identifier
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.identifier = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Clbit')
+        oprot.writeStructBegin("Clbit")
         if self.identifier is not None:
-            oprot.writeFieldBegin('identifier', TType.STRING, 1)
-            oprot.writeString(self.identifier.encode('utf-8') if sys.version_info[0] == 2 else self.identifier)
+            oprot.writeFieldBegin("identifier", TType.STRING, 1)
+            oprot.writeString(
+                self.identifier.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.identifier
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -149,34 +185,48 @@
      - num_qubits
      - num_clbits
      - params
      - definition
 
     """
 
-
-    def __init__(self, name=None, num_qubits=None, num_clbits=None, params=None, definition=None,):
+    def __init__(
+        self,
+        name=None,
+        num_qubits=None,
+        num_clbits=None,
+        params=None,
+        definition=None,
+    ):
         self.name = name
         self.num_qubits = num_qubits
         self.num_clbits = num_clbits
         self.params = params
         self.definition = definition
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.I32:
                     self.num_qubits = iprot.readI32()
                 else:
                     iprot.skip(ftype)
@@ -204,50 +254,53 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Operation')
+        oprot.writeStructBegin("Operation")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         if self.num_qubits is not None:
-            oprot.writeFieldBegin('num_qubits', TType.I32, 2)
+            oprot.writeFieldBegin("num_qubits", TType.I32, 2)
             oprot.writeI32(self.num_qubits)
             oprot.writeFieldEnd()
         if self.num_clbits is not None:
-            oprot.writeFieldBegin('num_clbits', TType.I32, 3)
+            oprot.writeFieldBegin("num_clbits", TType.I32, 3)
             oprot.writeI32(self.num_clbits)
             oprot.writeFieldEnd()
         if self.params is not None:
-            oprot.writeFieldBegin('params', TType.LIST, 4)
+            oprot.writeFieldBegin("params", TType.LIST, 4)
             oprot.writeListBegin(TType.DOUBLE, len(self.params))
             for iter6 in self.params:
                 oprot.writeDouble(iter6)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.definition is not None:
-            oprot.writeFieldBegin('definition', TType.STRUCT, 5)
+            oprot.writeFieldBegin("definition", TType.STRUCT, 5)
             self.definition.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -257,22 +310,30 @@
     Attributes:
      - op
      - qubits
      - clbits
 
     """
 
-
-    def __init__(self, op=None, qubits=None, clbits=None,):
+    def __init__(
+        self,
+        op=None,
+        qubits=None,
+        clbits=None,
+    ):
         self.op = op
         self.qubits = qubits
         self.clbits = clbits
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -307,45 +368,46 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Instruction')
+        oprot.writeStructBegin("Instruction")
         if self.op is not None:
-            oprot.writeFieldBegin('op', TType.STRUCT, 1)
+            oprot.writeFieldBegin("op", TType.STRUCT, 1)
             self.op.write(oprot)
             oprot.writeFieldEnd()
         if self.qubits is not None:
-            oprot.writeFieldBegin('qubits', TType.LIST, 2)
+            oprot.writeFieldBegin("qubits", TType.LIST, 2)
             oprot.writeListBegin(TType.STRUCT, len(self.qubits))
             for iter19 in self.qubits:
                 iter19.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.clbits is not None:
-            oprot.writeFieldBegin('clbits', TType.LIST, 3)
+            oprot.writeFieldBegin("clbits", TType.LIST, 3)
             oprot.writeListBegin(TType.STRUCT, len(self.clbits))
             for iter20 in self.clbits:
                 iter20.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -356,23 +418,32 @@
      - qubits
      - clbits
      - data
      - init
 
     """
 
-
-    def __init__(self, qubits=None, clbits=None, data=None, init=True,):
+    def __init__(
+        self,
+        qubits=None,
+        clbits=None,
+        data=None,
+        init=True,
+    ):
         self.qubits = qubits
         self.clbits = clbits
         self.data = data
         self.init = init
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -417,52 +488,53 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('QuantumCircuit')
+        oprot.writeStructBegin("QuantumCircuit")
         if self.qubits is not None:
-            oprot.writeFieldBegin('qubits', TType.LIST, 1)
+            oprot.writeFieldBegin("qubits", TType.LIST, 1)
             oprot.writeListBegin(TType.STRUCT, len(self.qubits))
             for iter39 in self.qubits:
                 iter39.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.clbits is not None:
-            oprot.writeFieldBegin('clbits', TType.LIST, 2)
+            oprot.writeFieldBegin("clbits", TType.LIST, 2)
             oprot.writeListBegin(TType.STRUCT, len(self.clbits))
             for iter40 in self.clbits:
                 iter40.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.data is not None:
-            oprot.writeFieldBegin('data', TType.LIST, 3)
+            oprot.writeFieldBegin("data", TType.LIST, 3)
             oprot.writeListBegin(TType.STRUCT, len(self.data))
             for iter41 in self.data:
                 iter41.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.init is not None:
-            oprot.writeFieldBegin('init', TType.BOOL, 4)
+            oprot.writeFieldBegin("init", TType.BOOL, 4)
             oprot.writeBool(self.init)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -471,21 +543,28 @@
     """
     Attributes:
      - qb1
      - qb2
 
     """
 
-
-    def __init__(self, qb1=None, qb2=None,):
+    def __init__(
+        self,
+        qb1=None,
+        qb2=None,
+    ):
         self.qb1 = qb1
         self.qb2 = qb2
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -504,35 +583,36 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('ConnectivityEdge')
+        oprot.writeStructBegin("ConnectivityEdge")
         if self.qb1 is not None:
-            oprot.writeFieldBegin('qb1', TType.STRUCT, 1)
+            oprot.writeFieldBegin("qb1", TType.STRUCT, 1)
             self.qb1.write(oprot)
             oprot.writeFieldEnd()
         if self.qb2 is not None:
-            oprot.writeFieldBegin('qb2', TType.STRUCT, 2)
+            oprot.writeFieldBegin("qb2", TType.STRUCT, 2)
             self.qb2.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -544,34 +624,48 @@
      - online
      - qubit_list
      - elementary_ops
      - connectivity_map
 
     """
 
-
-    def __init__(self, name=None, online=None, qubit_list=None, elementary_ops=None, connectivity_map=None,):
+    def __init__(
+        self,
+        name=None,
+        online=None,
+        qubit_list=None,
+        elementary_ops=None,
+        connectivity_map=None,
+    ):
         self.name = name
         self.online = online
         self.qubit_list = qubit_list
         self.elementary_ops = elementary_ops
         self.connectivity_map = connectivity_map
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.BOOL:
                     self.online = iprot.readBool()
                 else:
                     iprot.skip(ftype)
@@ -611,106 +705,237 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('BackendStatus')
+        oprot.writeStructBegin("BackendStatus")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         if self.online is not None:
-            oprot.writeFieldBegin('online', TType.BOOL, 2)
+            oprot.writeFieldBegin("online", TType.BOOL, 2)
             oprot.writeBool(self.online)
             oprot.writeFieldEnd()
         if self.qubit_list is not None:
-            oprot.writeFieldBegin('qubit_list', TType.LIST, 3)
+            oprot.writeFieldBegin("qubit_list", TType.LIST, 3)
             oprot.writeListBegin(TType.STRUCT, len(self.qubit_list))
             for iter60 in self.qubit_list:
                 iter60.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.elementary_ops is not None:
-            oprot.writeFieldBegin('elementary_ops', TType.LIST, 4)
+            oprot.writeFieldBegin("elementary_ops", TType.LIST, 4)
             oprot.writeListBegin(TType.STRUCT, len(self.elementary_ops))
             for iter61 in self.elementary_ops:
                 iter61.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.connectivity_map is not None:
-            oprot.writeFieldBegin('connectivity_map', TType.LIST, 5)
+            oprot.writeFieldBegin("connectivity_map", TType.LIST, 5)
             oprot.writeListBegin(TType.STRUCT, len(self.connectivity_map))
             for iter62 in self.connectivity_map:
                 iter62.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(Qubit)
 Qubit.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'identifier', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "identifier",
+        "UTF8",
+        None,
+    ),  # 1
 )
 all_structs.append(Clbit)
 Clbit.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'identifier', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "identifier",
+        "UTF8",
+        None,
+    ),  # 1
 )
 all_structs.append(Operation)
 Operation.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
-    (2, TType.I32, 'num_qubits', None, None, ),  # 2
-    (3, TType.I32, 'num_clbits', None, None, ),  # 3
-    (4, TType.LIST, 'params', (TType.DOUBLE, None, False), None, ),  # 4
-    (5, TType.STRUCT, 'definition', [QuantumCircuit, None], None, ),  # 5
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
+    (
+        2,
+        TType.I32,
+        "num_qubits",
+        None,
+        None,
+    ),  # 2
+    (
+        3,
+        TType.I32,
+        "num_clbits",
+        None,
+        None,
+    ),  # 3
+    (
+        4,
+        TType.LIST,
+        "params",
+        (TType.DOUBLE, None, False),
+        None,
+    ),  # 4
+    (
+        5,
+        TType.STRUCT,
+        "definition",
+        [QuantumCircuit, None],
+        None,
+    ),  # 5
 )
 all_structs.append(Instruction)
 Instruction.thrift_spec = (
     None,  # 0
-    (1, TType.STRUCT, 'op', [Operation, None], None, ),  # 1
-    (2, TType.LIST, 'qubits', (TType.STRUCT, [Qubit, None], False), None, ),  # 2
-    (3, TType.LIST, 'clbits', (TType.STRUCT, [Clbit, None], False), None, ),  # 3
+    (
+        1,
+        TType.STRUCT,
+        "op",
+        [Operation, None],
+        None,
+    ),  # 1
+    (
+        2,
+        TType.LIST,
+        "qubits",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 2
+    (
+        3,
+        TType.LIST,
+        "clbits",
+        (TType.STRUCT, [Clbit, None], False),
+        None,
+    ),  # 3
 )
 all_structs.append(QuantumCircuit)
 QuantumCircuit.thrift_spec = (
     None,  # 0
-    (1, TType.LIST, 'qubits', (TType.STRUCT, [Qubit, None], False), None, ),  # 1
-    (2, TType.LIST, 'clbits', (TType.STRUCT, [Clbit, None], False), None, ),  # 2
-    (3, TType.LIST, 'data', (TType.STRUCT, [Instruction, None], False), None, ),  # 3
-    (4, TType.BOOL, 'init', None, True, ),  # 4
+    (
+        1,
+        TType.LIST,
+        "qubits",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 1
+    (
+        2,
+        TType.LIST,
+        "clbits",
+        (TType.STRUCT, [Clbit, None], False),
+        None,
+    ),  # 2
+    (
+        3,
+        TType.LIST,
+        "data",
+        (TType.STRUCT, [Instruction, None], False),
+        None,
+    ),  # 3
+    (
+        4,
+        TType.BOOL,
+        "init",
+        None,
+        True,
+    ),  # 4
 )
 all_structs.append(ConnectivityEdge)
 ConnectivityEdge.thrift_spec = (
     None,  # 0
-    (1, TType.STRUCT, 'qb1', [Qubit, None], None, ),  # 1
-    (2, TType.STRUCT, 'qb2', [Qubit, None], None, ),  # 2
+    (
+        1,
+        TType.STRUCT,
+        "qb1",
+        [Qubit, None],
+        None,
+    ),  # 1
+    (
+        2,
+        TType.STRUCT,
+        "qb2",
+        [Qubit, None],
+        None,
+    ),  # 2
 )
 all_structs.append(BackendStatus)
 BackendStatus.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
-    (2, TType.BOOL, 'online', None, None, ),  # 2
-    (3, TType.LIST, 'qubit_list', (TType.STRUCT, [Qubit, None], False), None, ),  # 3
-    (4, TType.LIST, 'elementary_ops', (TType.STRUCT, [Operation, None], False), None, ),  # 4
-    (5, TType.LIST, 'connectivity_map', (TType.STRUCT, [ConnectivityEdge, None], False), None, ),  # 5
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
+    (
+        2,
+        TType.BOOL,
+        "online",
+        None,
+        None,
+    ),  # 2
+    (
+        3,
+        TType.LIST,
+        "qubit_list",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 3
+    (
+        4,
+        TType.LIST,
+        "elementary_ops",
+        (TType.STRUCT, [Operation, None], False),
+        None,
+    ),  # 4
+    (
+        5,
+        TType.LIST,
+        "connectivity_map",
+        (TType.STRUCT, [ConnectivityEdge, None], False),
+        None,
+    ),  # 5
 )
 fix_spec(all_structs)
 del all_structs
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/interface_types.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/interface_types.py`

 * *Files 16% similar despite different names*

```diff
@@ -7,13 +7,20 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.interface.thrift_interface.codegen.ttypes import Qubit as PortableQubit
-from qrisp.interface.thrift_interface.codegen.ttypes import QuantumCircuit as PortableQuantumCircuit
-from qrisp.interface.thrift_interface.codegen.ttypes import Operation as PortableOperation
-from qrisp.interface.thrift_interface.codegen.ttypes import Instruction as PortableInstruction
+from qrisp.interface.thrift_interface.codegen.ttypes import BackendStatus
 from qrisp.interface.thrift_interface.codegen.ttypes import Clbit as PortableClbit
-from qrisp.interface.thrift_interface.codegen.ttypes import ConnectivityEdge, BackendStatus
+from qrisp.interface.thrift_interface.codegen.ttypes import ConnectivityEdge
+from qrisp.interface.thrift_interface.codegen.ttypes import (
+    Instruction as PortableInstruction,
+)
+from qrisp.interface.thrift_interface.codegen.ttypes import (
+    Operation as PortableOperation,
+)
+from qrisp.interface.thrift_interface.codegen.ttypes import (
+    QuantumCircuit as PortableQuantumCircuit,
+)
+from qrisp.interface.thrift_interface.codegen.ttypes import Qubit as PortableQubit
```

### Comparing `qrisp-0.0.15/src/qrisp/interface/thrift_interface/stoppable_thrift_server.py` & `qrisp-0.0.16/src/qrisp/interface/thrift_interface/stoppable_thrift_server.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,58 +1,55 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
+
+import logging
 import threading
+
 from thrift.server import TServer
 
-import logging
+
 class StoppableThriftServer(TServer.TThreadedServer):
-    
     def __init__(*args, **kwargs):
         args[0].is_running = False
         TServer.TThreadedServer.__init__(*args, **kwargs)
-        
-        
+
     def serve(self):
-        
         self.serverTransport.listen()
-        
+
         self.stop_flag = False
         thread_list = []
         while True:
             if self.stop_flag:
-                for t in thread_list: t.join()
+                for t in thread_list:
+                    t.join()
                 break
             try:
                 self.is_running = True
                 client = self.serverTransport.accept()
                 t = threading.Thread(target=self.handle, args=(client,))
                 t.setDaemon(self.daemon)
                 t.start()
                 thread_list.append(t)
             except OSError:
                 pass
             except KeyboardInterrupt:
                 raise
             except Exception as x:
                 logging.exception(x)
-                
-            
 
     def stop(self):
         self.stop_flag = True
         try:
             self.serverTransport.handle.shutdown(2)
         except OSError:
             pass
         self.serverTransport.handle.close()
-
```

### Comparing `qrisp-0.0.15/src/qrisp/iterators/qrange.py` & `qrisp-0.0.16/src/qrisp/iterators/qrange.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,125 +1,114 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
-#TO-DO implement all the concepts discussed in https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3?rq=1
+# TO-DO implement all the concepts discussed in
+# https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3?rq=1
 
-from qrisp.environments.quantum_conditionals import ConditionEnvironment, quantum_condition
-from qrisp.logic_synthesis.truth_tables import TruthTable
-from qrisp import x, cx, control, perm_lock, perm_unlock
+from qrisp import control, cx, perm_lock, perm_unlock, x
 from qrisp.core import QuantumVariable
+from qrisp.environments.quantum_conditionals import (
+    ConditionEnvironment,
+    quantum_condition,
+)
+from qrisp.logic_synthesis.truth_tables import TruthTable
+
 
 class QuantumIterator:
-    
-    def __init__(self, quantum_condition, init_index = None):
-        
+    def __init__(self, quantum_condition, init_index=None):
         self.quantum_condition = quantum_condition
-        
-        
+
     def __iter__(self):
-    	
         self.quantum_condition.start_dumping()
-        
+
         return self
-    
+
     def __next__(self):
-        
-        raise Exception("__next__ method for abstract quantum iterator class not defined")
-        
-        
-        
-        
-class qRange:
-    
-    def __init__(self, max_index_qf, create_index_qf = False):
+        raise Exception(
+            "__next__ method for abstract quantum iterator class not defined"
+        )
 
+
+class qRange:
+    def __init__(self, max_index_qf, create_index_qf=False):
         from qrisp.qtypes.quantum_float import QuantumFloat
+
         if not isinstance(max_index_qf, QuantumFloat):
             raise Exception("Can only create quantum iterators from quantum variables")
 
-        
         if max_index_qf.exponent != 0:
-            raise Exception("qRange can only be intialized with integer quantum indices")
-        
+            raise Exception(
+                "qRange can only be intialized with integer quantum indices"
+            )
+
         self.create_index_qf = create_index_qf
         self.max_index_qf = max_index_qf
-        
-        
+
     def __iter__(self):
-        
         if self.create_index_qf:
-            self.index_qf = self.max_index_qf.duplicate(qs = self.max_index_qf.qs, name = "index_qf")
+            self.index_qf = self.max_index_qf.duplicate(
+                qs=self.max_index_qf.qs, name="index_qf"
+            )
             self.index_qf.init_from(self.max_index_qf)
-                
+
         else:
             self.index_qf = self.max_index_qf
-            
+
         if not self.index_qf.signed:
-            self.index_qf.extend(1, position = -1)
-        
-        
+            self.index_qf.extend(1, position=-1)
+
         x(self.index_qf)
-        
+
         self.quantum_condition_env = control(self.index_qf[-1])
-        
+
         self.c_index = -1
-        
+
         perm_lock(self.index_qf)
-        
+
         return self
-        
+
     def __next__(self):
-        
         perm_unlock(self.index_qf)
         self.c_index += 1
-        
+
         if self.c_index != 0:
-            
-            
             self.quantum_condition_env.__exit__(None, None, None)
-            
 
-            if self.c_index >= 2**(self.index_qf.size-1):
-                    
+            if self.c_index >= 2 ** (self.index_qf.size - 1):
                 if self.create_index_qf:
-                    
                     x(self.index_qf)
                     self.index_qf += self.c_index - 1
-                    
+
                     if not self.max_index_qf.signed:
                         cx(self.max_index_qf, self.index_qf[:-1])
                     else:
                         cx(self.max_index_qf, self.index_qf)
                     self.index_qf.delete()
                 else:
-                    
                     x(self.index_qf)
                     self.index_qf += self.c_index - 1
-                    
+
                     self.index_qf.reduce(self.index_qf[-1])
-                
+
                 perm_unlock(self.index_qf)
                 raise StopIteration
-        
+
             self.index_qf += 1
         # @quantum_condition
         # def neg_condition(sign_qubit):
         #     return sign_qubit
-            
+
         # self.quantum_condition_env = neg_condition(self.index_qf[-1])
-        
-        
+
         self.quantum_condition_env.__enter__()
         perm_lock(self.index_qf)
         return int(self.c_index)
-
```

### Comparing `qrisp-0.0.15/src/qrisp/logic_synthesis/gray_synthesis.py` & `qrisp-0.0.16/src/qrisp/logic_synthesis/gray_synthesis.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,550 +7,548 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 import numpy as np
-from qrisp.misc import int_as_array, int_encoder, array_as_int, gate_wrap
-import sympy as sp
+from qrisp.misc import array_as_int, gate_wrap, int_as_array
+from qrisp.circuit.quantum_circuit import QuantumCircuit
 
 use_gray_code = False
 try:
     from ffht import fht as fwht
-    fwht(np.array([0,1,0,1]))
-    #print("FALCONN fwht import successfull")
+
+    fwht(np.array([0, 1, 0, 1]))
+    # print("FALCONN fwht import successfull")
 except:
-    #print("FALCONN fwht import failed")
-    
+    # print("FALCONN fwht import failed")
+
     def fwht(a):
         """In-place Fast Walsh–Hadamard Transform of array a."""
         h = 1
         while h < len(a):
             for i in range(0, len(a), h * 2):
                 for j in range(i, i + h):
                     x = a[j]
                     y = a[j + h]
                     a[j] = x + y
                     a[j + h] = x - y
             h *= 2
-    
-
 
 
+def hamming_d(i, j, bit):
+    return sum((int_as_array(i, bit) + int_as_array(j, bit)) % 2)
 
-def hamming_d(i,j, bit):
-    return sum((int_as_array(i, bit) + int_as_array(j, bit))%2)
 
-#Solution of the Hamming TSP
-#Based on having two salesmen who always visit the place which is closest to them
-#and which are reunified at the end of their travel
-#The solution is now the path of the first one + the reversed path of the second
+# Solution of the Hamming TSP
+# Based on having two salesmen who always visit the place which is closest to them
+# and which are reunified at the end of their travel
+# The solution is now the path of the first one + the reversed path of the second
 def hamming_tsp(location_list, bit_amount):
-    if use_gray_code or len(location_list) == 2**(bit_amount-1) + 1:
-        
-        return gray_code(max(bit_amount-1,1))
-    
-    
-    #print(location_list)
+    if use_gray_code or len(location_list) == 2 ** (bit_amount - 1) + 1:
+        return gray_code(max(bit_amount - 1, 1))
+
+    # print(location_list)
     if len(location_list) == 1:
         return list(location_list)
-    
+
     if len(location_list) == 2:
         temp = list(location_list)
         temp.sort()
-        #print([temp[1]] + hamming_movement(temp[1], temp[0], bit_amount))
-        return [temp[1]]+ hamming_movement(temp[1], temp[0], bit_amount)
-        
-    
-    #Copy list in order not to change the input
+        # print([temp[1]] + hamming_movement(temp[1], temp[0], bit_amount))
+        return [temp[1]] + hamming_movement(temp[1], temp[0], bit_amount)
+
+    # Copy list in order not to change the input
     location_list = list(location_list)
-    
-    #Create log-lists for the salesman pathes
+
+    # Create log-lists for the salesman pathes
     salesman_1 = [min(location_list)]
     location_list.pop(np.argmin(location_list))
-    
+
     salesman_2 = [min(location_list)]
     location_list.pop(np.argmin(location_list))
-    
-    
-    
-    
-    #Keep track of some stats
+
+    # Keep track of some stats
     empty_steps = 0
-    
-    while(len(location_list)):
-        
-        #Move first salesman
-        
-        
-        #Find closest location
+
+    while len(location_list):
+        # Move first salesman
+
+        # Find closest location
         best_distance = np.inf
         for i in range(len(location_list)):
-            trial_distance = hamming_d(salesman_1[-1], location_list[i], bit_amount)#*len(location_list)
-            #trial_distance += hamming_d(salesman_1[-1], salesman_2[-1], n)/len(location_list)
-            
+            trial_distance = hamming_d(
+                salesman_1[-1], location_list[i], bit_amount
+            )  # *len(location_list)
+            # trial_distance += hamming_d(salesman_1[-1],
+            # salesman_2[-1], n)/len(location_list)
+
             if trial_distance < best_distance:
                 best_distance = trial_distance
                 best_candidate_index = i
-        
-        #Count steps which do not visit a relevant parity operator
-        empty_steps += hamming_d(salesman_1[-1], location_list[best_candidate_index], bit_amount)-1
-        
-        #Remove target location from the location list
+
+        # Count steps which do not visit a relevant parity operator
+        empty_steps += (
+            hamming_d(salesman_1[-1], location_list[best_candidate_index], bit_amount)
+            - 1
+        )
+
+        # Remove target location from the location list
         target_location = location_list.pop(best_candidate_index)
-        
-        #Move salesman
+
+        # Move salesman
         salesman_1 += hamming_movement(salesman_1[-1], target_location, bit_amount)
-        
-        #End procedure if the location list is empty now
+
+        # End procedure if the location list is empty now
         if len(location_list) == 0:
             break
-        
-        
-        #Move second salesman (same steps as first salesman)
-        
+
+        # Move second salesman (same steps as first salesman)
+
         best_distance = np.inf
         for i in range(len(location_list)):
-            trial_distance = hamming_d(salesman_2[-1], location_list[i], bit_amount)#*len(location_list)
-            #trial_distance += hamming_d(salesman_1[-1], location_list[i], n)#/len(location_list)
-            
+            trial_distance = hamming_d(
+                salesman_2[-1], location_list[i], bit_amount
+            )  # *len(location_list)
+            # trial_distance += hamming_d(salesman_1[-1],
+            # location_list[i], n)#/len(location_list)
+
             if trial_distance < best_distance:
                 best_distance = trial_distance
                 best_candidate_index = i
-                
-        empty_steps += hamming_d(salesman_2[-1], location_list[best_candidate_index], bit_amount)-1
+
+        empty_steps += (
+            hamming_d(salesman_2[-1], location_list[best_candidate_index], bit_amount)
+            - 1
+        )
         target_location = location_list.pop(best_candidate_index)
-        
-        
+
         salesman_2 += hamming_movement(salesman_2[-1], target_location, bit_amount)
-    
-    
-    #Unify salesmen
+
+    # Unify salesmen
     salesman_1 += hamming_movement(salesman_1[-1], salesman_2[-1], bit_amount)
-    
+
     salesman_2.pop(-1)
-    
-    #Construct solution (first salesman + second salesman reversed)
+
+    # Construct solution (first salesman + second salesman reversed)
     solution = salesman_1 + salesman_2[::-1]
-    
-    #print("Reunion cost:")
-    #print(hamming_d(salesman_1[-1], salesman_2[-1], n))
-    #empty_steps += hamming_d(salesman_1[-1], salesman_2[-1], n) - 1
-    #print("Percentage of empty steps")
-    #print(empty_steps/parity_amount*100)
-    #print(solution)
-    
-    
-    if 2**max(bit_amount-1,1) < len(solution):
-        return gray_code(max(bit_amount-1,1))
-    
-    
+
+    # print("Reunion cost:")
+    # print(hamming_d(salesman_1[-1], salesman_2[-1], n))
+    # empty_steps += hamming_d(salesman_1[-1], salesman_2[-1], n) - 1
+    # print("Percentage of empty steps")
+    # print(empty_steps/parity_amount*100)
+    # print(solution)
+
+    if 2 ** max(bit_amount - 1, 1) < len(solution):
+        return gray_code(max(bit_amount - 1, 1))
+
     return solution
 
+
 def hamming_movement(init, target, bit_amount):
     salesman = [init]
     distance = hamming_d(init, target, bit_amount)
     while distance:
-        distance_array = (int_as_array(salesman[-1], bit_amount) + int_as_array(target, bit_amount))%2
+        distance_array = (
+            int_as_array(salesman[-1], bit_amount) + int_as_array(target, bit_amount)
+        ) % 2
         movement_index = np.argmax(distance_array)
         movement_array = np.zeros(distance_array.shape)
         movement_array[movement_index] = 1
-        
-        salesman.append(array_as_int((int_as_array(salesman[-1],bit_amount) + movement_array)%2))
+
+        salesman.append(
+            array_as_int((int_as_array(salesman[-1], bit_amount) + movement_array) % 2)
+        )
         distance = hamming_d(salesman[-1], target, bit_amount)
-    #print((init, target))
-    #print(salesman[1:])    
+    # print((init, target))
+    # print(salesman[1:])
     return salesman[1:]
 
 
-
-#Solves the hamming tsp problem ie. finds a path which visits each
-#corner of the n-D unit cube exactly once and ends up in the origin again
+# Solves the hamming tsp problem i.e. finds a path which visits each
+# corner of the n-D unit cube exactly once and ends up in the origin again
 def gray_code(n):
-    #The key observation is that we can solve the problem for the n-D cube
-    #if we solve it for the (n-1)-D cube such that the path starts at bin(0) and ends in bin(2**(n-2)).
-    #We then concantenate this solution in the "lower half" of the n-D cube
-    #with the reversed solution in the upper half applied
-    
-    #This concantenation will again give a solution which starts at 0 and ends in bin(2**((n+1)-2))
-    #We thus have a recursion
-    
-    #Example for the 3D cube:
-    #A possible solution for the 2D cube is [0,1,3,2]
-    
-    #The reversal is [2,3,1,0] which is [6,7,5,4] on the upper half
-    #Concantenating gives [0,1,3,2,6,7,5,4] ie. a solution which starts in 0
-    #and ends in 2**(3-1) = 4
-    
+    # The key observation is that we can solve the problem for the n-D cube, if we solve
+    # it for the (n-1)-D cube such that the path starts at bin(0) and ends in
+    # bin(2**(n-2)). We then concantenate this solution in the "lower half" of the n-D
+    # cube with the reversed solution in the upper half applied
+
+    # This concantenation will again give a solution which starts at 0 and ends in
+    # bin(2**((n+1)-2)). We thus have a recursion
+
+    # Example for the 3D cube:
+    # A possible solution for the 2D cube is [0,1,3,2]
+
+    # The reversal is [2,3,1,0] which is [6,7,5,4] on the upper half
+    # Concantenating gives [0,1,3,2,6,7,5,4] ie. a solution which starts in 0
+    # and ends in 2**(3-1) = 4
+
     if n < 1:
         return []
     result_list = []
-    
-    
+
     if n == 1:
-        return [1,0]
-    
-    temp_list = gray_code(n-1)
-    
-    result_list += [2**(n-1) + k for k in temp_list[::-1]]
+        return [1, 0]
+
+    temp_list = gray_code(n - 1)
+
+    result_list += [2 ** (n - 1) + k for k in temp_list[::-1]]
     result_list += temp_list
 
     return result_list
 
-#This function calculates the phases to put after each parity operator
-#A given state will recieve then recieve the phase phi_i if it is true under
-#the parity operator i. As each state is true on a unique combination of parity operators
-#each state will recieve a unique phase. The total phase of any state is the sum of all the 
-#parity operators it is True on. If we now want to get a certain constellation of total phases
-#This gives us a system of linear equations, where the matrix is given by the parity matrix
-
-#Target_phases is a list of phases , where the i-th entry describes the phase the i-state should pick up
-#Note that the phases should be given as numbers between 0 and 2 where 2 describes a phase of 2pi
-#This helps reducing the amount of float errors
+
+# This function calculates the phases to put after each parity operator.
+# A given state will recieve then recieve the phase phi_i if it is true under the parity
+# operator i. As each state is true on a unique combination of parity operators each
+# state will recieve a unique phase. The total phase of any state is the sum of all the
+# parity operators it is True on. If we now want to get a certain constellation of total
+# phases. This gives us a system of linear equations, where the matrix is given by the
+# parity matrix
+
+
+# Target_phases is a list of phases , where the i-th entry describes the phase the
+# i-state should pick up. Note that the phases should be given as numbers between 0 and
+# 2 where 2 describes a phase of 2pi. This helps to reduce the amount of float errors.
 def gen_phase_shifts(target_phases):
-    
-    
     try:
-        temp = np.array(target_phases, dtype = np.longdouble)/(len(target_phases)/2)
+        temp = np.array(target_phases, dtype=np.longdouble) / (len(target_phases) / 2)
     except TypeError:
-        temp = [x/(len(target_phases)/2) for x in target_phases]
-    
-    #Transform
+        temp = [x / (len(target_phases) / 2) for x in target_phases]
+
+    # Transform
     fwht(temp)
-    
+
     spectrum = temp
-    
-    return spectrum
 
+    return spectrum
 
 
-#Solves the hamming tsp and turns it into a sequence of CNOT gates,
-#all acting on the same qubit
-#Returns a list of tuples indicating CNOT gates and the sequence of
-#parity operators traversed
+# Solves the hamming tsp and turns it into a sequence of CNOT gates,
+# all acting on the same qubit
+# Returns a list of tuples indicating CNOT gates and the sequence of
+# parity operators traversed
 def single_qb_traversal(locations, bit_amount):
-    
-    
-    #Solve Hamming TSP to get traversal sequence
+    # Solve Hamming TSP to get traversal sequence
     tr_seq = hamming_tsp(locations, bit_amount)
-    
-    #Make sure 0 appears last
+
+    # Make sure 0 appears last
     if tr_seq[-1] != 0:
         tr_seq = tr_seq + [0]
-    
+
     if tr_seq[0] != 0:
         tr_seq = [0] + tr_seq
-    
-    #Turn into binaries
+
+    # Turn into binaries
     tr_seq_bin = [int_as_array(x, bit_amount) for x in tr_seq]
-    
-    
-    
-    #Sequence of control bits.
-    #The first control bit is the operation bit
-    #This indicates later in the synthesis function, that
-    #the unmodified parity operator has been loaded into the operation bit
-    control_seq = [bit_amount-1]
-    
-    
-    #Now successively calculate Hamming distance vector
-    #and determine the non-zero coordinate
+
+    # Sequence of control bits.
+    # The first control bit is the operation bit
+    # This indicates later in the synthesis function, that
+    # the unmodified parity operator has been loaded into the operation bit
+    control_seq = [bit_amount - 1]
+
+    # Now successively calculate Hamming distance vector
+    # and determine the non-zero coordinate
     temp = tr_seq[0]
     for i in range(1, len(tr_seq)):
-        temp = (tr_seq_bin[i-1] + tr_seq_bin[i])%2
+        temp = (tr_seq_bin[i - 1] + tr_seq_bin[i]) % 2
         temp = temp[::-1]
-        
+
         control_seq.append(np.argmax(temp))
-    
+
     return control_seq, tr_seq
 
 
-#Similar to single_qb_traversal but this function also allows traversal
-#of Parity operators in more than one qubit
-#Returns a list of tuples indicating the applied CNOT gates
-#and a list of integers indicating the sequence of traversed parity operators
+# Similar to single_qb_traversal but this function also allows traversal
+# of Parity operators in more than one qubit
+# Returns a list of tuples indicating the applied CNOT gates
+# and a list of integers indicating the sequence of traversed parity operators
 def multi_qb_traversal(locations, bit_amount):
-    
-    #Copy locations list (in oder to prevent modification)
-    
+    # Copy locations list (in oder to prevent modification)
+
     locations = list(locations)
-    
-    #Sort list
+
+    # Sort list
     locations.sort()
     locations = locations[::-1]
-    
-    #Sort into a dictionary, where the keys are the operation qubits
-    #and the values are list of parity operators that have to be traversed
-    #on this qubit.
-    single_qb_traversal_locations = {len(bin(x))-3: [] for x in locations}
-    
+
+    # Sort into a dictionary, where the keys are the operation qubits
+    # and the values are list of parity operators that have to be traversed
+    # on this qubit.
+    single_qb_traversal_locations = {len(bin(x)) - 3: [] for x in locations}
+
     for x in locations:
-        single_qb_traversal_locations[len(bin(x))-3].append(x)
-    
-    
-    #Set up lists to be filled
+        single_qb_traversal_locations[len(bin(x)) - 3].append(x)
+
+    # Set up lists to be filled
     cnot_seq = []
     p_op_seq = []
-    
-    
-    #Iterate through the qubits which are operated on
+
+    # Iterate through the qubits which are operated on
     for operation_bit in single_qb_traversal_locations.keys():
-        
-        #Convert the traversal locations into single qubit traversal routes
-        #(for instance 4,5,7, is the traversal 0,1,3 on the qubit with significance 4)
+        # Convert the traversal locations into single qubit traversal routes
+        # (for instance 4,5,7, is the traversal 0,1,3 on the qubit with significance 4)
         if operation_bit != 0:
-            single_qb_locations = [x%2**(operation_bit) for x in single_qb_traversal_locations[operation_bit]]
+            single_qb_locations = [
+                x % 2 ** (operation_bit)
+                for x in single_qb_traversal_locations[operation_bit]
+            ]
         else:
             single_qb_locations = single_qb_traversal_locations[operation_bit]
-        
-        #Find single qubit traversal routes
-        control_seq, p_op_temp = single_qb_traversal([0] + single_qb_locations, operation_bit+1)
-        
-        #Append to CNOT list
-        cnot_seq += [(x,operation_bit) for x in control_seq]
-        
-        
-        #Append to traversed parity operator list
+
+        # Find single qubit traversal routes
+        control_seq, p_op_temp = single_qb_traversal(
+            [0] + single_qb_locations, operation_bit + 1
+        )
+
+        # Append to CNOT list
+        cnot_seq += [(x, operation_bit) for x in control_seq]
+
+        # Append to traversed parity operator list
         if operation_bit != 0:
-            p_op_seq += [x + 2**(operation_bit) for x in p_op_temp]
+            p_op_seq += [x + 2 ** (operation_bit) for x in p_op_temp]
         else:
             p_op_seq += p_op_temp
-    
-    return cnot_seq, p_op_seq
 
+    return cnot_seq, p_op_seq
 
-from qrisp.circuit.quantum_circuit import QuantumCircuit
 
 compiled_gates = {}
 compiled_pt_gates = {}
 
-def gray_synth_gate(target_phases, phase_tolerant = False):
-    
+
+def gray_synth_gate(target_phases, phase_tolerant=False):
     target_phases_id = str(list(target_phases))
-    
+
     if not phase_tolerant:
         if target_phases_id in compiled_gates:
             temp = compiled_gates[target_phases_id]
             return temp
     else:
         if target_phases_id in compiled_pt_gates:
             temp = compiled_pt_gates[target_phases_id]
             return temp
 
     bit_amount = int(np.log2(len(target_phases)))
-    
+
     qc = QuantumCircuit(bit_amount)
-    
-    #Generate phase shifts
+
+    # Generate phase shifts
     phase_shifts = gen_phase_shifts(target_phases)
-    
-    #Set global phase to 0
+
+    # Set global phase to 0
     phase_shifts[0] = 0
-    
-    
-    #Find out about non-zero parity operators that need to be traversed
+
+    # Find out about non-zero parity operators that need to be traversed
     locations = []
     for i in range(len(phase_shifts)):
         try:
-            if abs(phase_shifts[i]) < 1E-16:
+            if abs(phase_shifts[i]) < 1e-16:
                 continue
         except TypeError:
             pass
-        
+
         locations.append(i)
-    
-        
-    #Generate CNOT list
+
+    # Generate CNOT list
     cnot_list, p_op_seq = multi_qb_traversal(locations, bit_amount)
     qb_list = qc.qubits
-    
-    #Apply CNOT list and add phases
+
+    # Apply CNOT list and add phases
     for i in range(len(cnot_list)):
-            
-        
-        if (phase_tolerant == True and cnot_list[i][1] != bit_amount -1):
-            #If we are in the phase tolerant mode we dont need to apply a phase here
-            #because we are only interested in the phase DIFFERENCE of the 0 and 1 state of
-            #the output qubit. As these phase shifts dont act on the output qubit they do not change
-            #the phase difference and can therefore be ignored
+        if phase_tolerant is True and cnot_list[i][1] != bit_amount - 1:
+            # If we are in the phase tolerant mode we don't need to apply a phase here,
+            # because we are only interested in the phase DIFFERENCE of the 0 and 1
+            # state of the output qubit. As these phase shifts dont act on the output
+            # qubit they do not change the phase difference and can therefore be ignored
             break
-        
-        #Set some aliases to keep the code readable
+
+        # Set some aliases to keep the code readable
         operation_qubit = qb_list[cnot_list[i][1]]
         control_qubit = qb_list[cnot_list[i][0]]
-        
-        #Apply CNOT gate
+
+        # Apply CNOT gate
         if cnot_list[i][0] != cnot_list[i][1]:
             control_qubit = qb_list[cnot_list[i][0]]
             qc.cx(control_qubit, operation_qubit)
-        
-        
-        #Apply phase shifts
+
+        # Apply phase shifts
         if phase_shifts[p_op_seq[i]] == 0:
             continue
         qc.p(-phase_shifts[p_op_seq[i]], operation_qubit)
         phase_shifts[p_op_seq[i]] = 0
-    
-    
+
     from qrisp.core import reduce_depth
-    
+
     if len(qc.qubits) < 8:
         try:
             qc = reduce_depth(qc)
         except TypeError:
             pass
-    
+
     qc.qubits = qc.qubits[::-1]
-    
+
     res = qc.to_gate("gray_phase_gate")
     res.target_phases = target_phases
     res.phase_tolerant = phase_tolerant
-    
+
     if not phase_tolerant:
         compiled_gates[target_phases_id] = res
     else:
         compiled_pt_gates[target_phases_id] = res
-    
-    
-    res.permeability = {i : True for i in range(len(qc.qubits))}
+
+    res.permeability = {i: True for i in range(len(qc.qubits))}
     res.is_qfree = True
-    
+
     return res
-    
 
 
-#Function apply gray synthesis to quantum variable qv
+# Function apply gray synthesis to quantum variable qv
 
-#Target_phases is a list of phases , where the i-th entry describes the phase the i-state should pick up
-#Note that the phases should be given as numbers between 0 and 2 where 2 describes a phase of 2pi
-#This helps reducing the amount of float errors
-@gate_wrap(permeability = "full", is_qfree = True)
-def gray_phase_synth(qv, target_phases, phase_tolerant = False):
+
+# Target_phases is a list of phases , where the i-th entry describes the phase the
+# i-state should pick up. Note that the phases should be given as numbers between 0 and
+# 2 where 2 describes a phase of 2pi. This helps to reduce the amount of float errors.
+@gate_wrap(permeability="full", is_qfree=True)
+def gray_phase_synth(qv, target_phases, phase_tolerant=False):
     qv.qs.append(gray_synth_gate(target_phases, phase_tolerant), qv.reg)
-    
 
-#Similar function as the above but takes a QuantumCircuit and a qubit list as arguments instead
-def gray_phase_synth_qb_list(qc, qb_list, target_phases, phase_tolerant = False):
+
+# Similar function as the above but takes a QuantumCircuit and a qubit list as arguments
+# instead
+def gray_phase_synth_qb_list(qc, qb_list, target_phases, phase_tolerant=False):
     qc.append(gray_synth_gate(target_phases, phase_tolerant), qb_list)
 
-    
 
-    
-#Function to use gray synthesis for logic synthesis
-#The general idea is to apply gray synthesis to the input variable and the output variables
-#The output variable however is enclosed H gates which means that it will be |1> if we synthesized
-#the |-> state and |0> if we synthesized the |+> state
-#We choose the phases for the states which have a 0 in the output variable to be 0
-#and the phases for the states which have a 1 in the output variable according to wether
-#the truth table to be synthesized requires a 1 or a 0
-
-#An additional perk of this function is, that it support phase tolerant synthesis
-#This means that we are tolerant regarding the phase the out will have
-#ie. if the truth table for a given state says 1 and we activate the phase_tolerant option
-#we will get the state exp(i*phi)*|1> so a one but with a phase which might vary
-#for different input states. This tolerance regarding the phase allows us to skip half
-#of the synthesis procedure making it very cheap regarding the gate count
-
-#input_var is the quantum variable which contains the input
-#output_var is the quantum variable where the output should be synthesized
-#Note that output_var doesn't need to be of size one - the next parameter
-#qb_nr indicates on which qubit of output_var the synthesis should take place
-#Finally tt is the truth table to be synthesized
-@gate_wrap(is_qfree = True, permeability = [0])
-def gray_logic_synth_single_qb(input_var, output_var, qb_nr, tt, phase_tolerant = False):
+# Function to use gray synthesis for logic synthesis
+# The general idea is to apply gray synthesis to the input variable and the output
+# variables. The output variable however is enclosed H gates which means that it will be
+# |1> if we synthesized the |-> state and |0> if we synthesized the |+> state.
+# We choose the phases for the states which have a 0 in the output variable to be 0
+# and the phases for the states which have a 1 in the output variable according to
+# wether the truth table to be synthesized requires a 1 or a 0.
+
+# An additional perk of this function is, that it support phase tolerant synthesis
+# This means that we are tolerant regarding the phase the out will have, i.e. if the
+# truth table for a given state says 1 and we activate the phase_tolerant option
+# we will get the state exp(i*phi)*|1> so a one but with a phase which might vary
+# for different input states. This tolerance regarding the phase allows us to skip half
+# of the synthesis procedure making it very cheap regarding the gate count
+
+
+# input_var is the quantum variable which contains the input
+# output_var is the quantum variable where the output should be synthesized
+# Note that output_var doesn't need to be of size one - the next parameter
+# qb_nr indicates on which qubit of output_var the synthesis should take place
+# Finally tt is the truth table to be synthesized
+@gate_wrap(is_qfree=True, permeability=[0])
+def gray_logic_synth_single_qb(input_var, output_var, qb_nr, tt, phase_tolerant=False):
     if input_var.size != tt.bit_amount:
-        raise Exception("Input variable does not contain enough qubits to encode truth table")
-    
+        raise Exception(
+            "Input variable does not contain enough qubits to encode truth table"
+        )
+
     if tt.shape[1] != 1:
         raise Exception("This function can only encode single column truth tables")
-    
-    
-    #Generate target phases such that all the states with a 0 in the output qubit
-    #get phase 0 and the states with a 1 in the input qubit get a phases of pi
-    #if the truth table says 1 or a phase of 0 otherwise
-    target_phases = np.array(tt.shape[0]*[0] + list(tt.n_rep[:,0]))*np.pi
-    
-    #Apply h gate to the output qubit in order to get logic states from phases
+
+    # Generate target phases such that all the states with a 0 in the output qubit
+    # get phase 0 and the states with a 1 in the input qubit get a phases of pi
+    # if the truth table says 1 or a phase of 0 otherwise
+    target_phases = np.array(tt.shape[0] * [0] + list(tt.n_rep[:, 0])) * np.pi
+
+    # Apply h gate to the output qubit in order to get logic states from phases
     from qrisp import h
+
     h(output_var[qb_nr])
-    input_var.qs.append(gray_synth_gate(target_phases, phase_tolerant), (input_var.reg + [output_var[qb_nr]])[::-1])
+    input_var.qs.append(
+        gray_synth_gate(target_phases, phase_tolerant),
+        (input_var.reg + [output_var[qb_nr]])[::-1],
+    )
     h(output_var[qb_nr])
     return
-    
-    
 
 
-#This function uses it's single qubit version iteratively to synthesize
-#truth tables with more than one column
-@gate_wrap(is_qfree = True, permeability = [0])
-def gray_logic_synth(input_var, output_var, tt, phase_tolerant = False, lin_solve = False):
-    
-    
-    
+# This function uses it's single qubit version iteratively to synthesize
+# truth tables with more than one column
+@gate_wrap(is_qfree=True, permeability=[0])
+def gray_logic_synth(input_var, output_var, tt, phase_tolerant=False, lin_solve=False):
     if len(input_var) != tt.bit_amount:
-        raise Exception("Input variable does not contain enough qubits to encode truth table")
-    
+        raise Exception(
+            "Input variable does not contain enough qubits to encode truth table"
+        )
+
     if len(output_var) != tt.shape[1]:
-        raise Exception("output variable does not contain enough qubits to encode truth table")
-    
+        raise Exception(
+            "output variable does not contain enough qubits to encode truth table"
+        )
+
     input_var_dupl = input_var.duplicate()
-    output_var_dupl = output_var.duplicate(qs = input_var_dupl.qs)
-    
-    #Iterate throgh all the truth table columns and synthesize each one separately
-    
+    output_var_dupl = output_var.duplicate(qs=input_var_dupl.qs)
+
+    # Iterate throgh all the truth table columns and synthesize each one separately
+
     residual_phases = np.zeros(tt.shape[0])
-    
+
     for i in range(tt.shape[1]):
-        gray_logic_synth_single_qb(input_var_dupl, output_var_dupl, i, tt.sub_table(i), phase_tolerant = True)
+        gray_logic_synth_single_qb(
+            input_var_dupl, output_var_dupl, i, tt.sub_table(i), phase_tolerant=True
+        )
 
-        temp = (tt.sub_table(i).n_rep - 1/2)*np.pi/2
+        temp = (tt.sub_table(i).n_rep - 1 / 2) * np.pi / 2
         temp = temp.transpose()[0]
-        
+
         residual_phases += temp
-    
+
     from qrisp.core import reduce_depth
-    
+
     qc = input_var_dupl.qs.transpile()
-    
+
     if len(qc.qubits) < 10 and input_var.size != 1:
         qc = reduce_depth(qc)
-    
+
     input_var_dupl.qs.data = []
-    
+
     if not phase_tolerant:
         input_var_dupl.reg = input_var_dupl.reg[::-1]
-        
+
         gray_phase_synth(input_var_dupl, residual_phases)
-        
+
         input_var_dupl.reg = input_var_dupl.reg[::-1]
-    
+
     qc.data.extend(input_var_dupl.qs.data)
-    
+
     input_var.qs.append(qc.to_gate(), input_var.reg + output_var.reg)
-    
-#This function uses it's single qubit version iteratively to synthesize
-#truth tables with more than one column
+
+
+# This function uses it's single qubit version iteratively to synthesize
+# truth tables with more than one column
 @gate_wrap
-def gray_logic_synth_qb_list(input_qb_list, output_qb, qs, tt, phase_tolerant = False, inverse = False, gate_name = None):
-    
+def gray_logic_synth_qb_list(
+    input_qb_list,
+    output_qb,
+    qs,
+    tt,
+    phase_tolerant=False,
+    inverse=False,
+    gate_name=None,
+):
     from qrisp import QuantumSession, QuantumVariable
+
     qs_temp = QuantumSession()
-    
+
     input_var = QuantumVariable(len(input_qb_list), qs_temp)
     output_var = QuantumVariable(1, qs_temp)
-    
+
     gray_logic_synth(input_var, output_var, tt, phase_tolerant)
-    
-    
+
     temp_gate = qs_temp.to_gate()
-    
-    if gate_name != None:
+
+    if gate_name is not None:
         temp_gate.name = gate_name
-        
+
     if inverse:
         qs.append(temp_gate.inverse(), input_qb_list + [output_qb])
     else:
         qs.append(temp_gate, input_qb_list + [output_qb])
-        
-
-
```

### Comparing `qrisp-0.0.15/src/qrisp/logic_synthesis/pprm_synthesis.py` & `qrisp-0.0.16/src/qrisp/logic_synthesis/pprm_synthesis.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,73 +1,73 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 import sympy as sp
 from qrisp.logic_synthesis.truth_tables import TruthTable, synth_poly
-import math as math
 
 
-
-def pprm_synth(input_var, output_var, tt, qb_nr, phase_tolerant = False):
-    from qrisp.arithmetic.poly_tools import symbol_to_qbit, monomial_to_list, expr_to_list
+def pprm_synth(input_var, output_var, tt, qb_nr, phase_tolerant=False):
     from qrisp import mcx
+    from qrisp.arithmetic.poly_tools import (
+        expr_to_list,
+    )
+
     qs = input_var.qs
     output_qubit = output_var.reg[qb_nr]
-    expr = synth_poly(tt, column = qb_nr)
-    #print(expr)
+    expr = synth_poly(tt, column=qb_nr)
+    # print(expr)
     args = expr_to_list(expr)
     args_len = [len(i) for i in args]
-    
+
     for element in range(len(args_len)):
-        
         if args_len[element] > 1:
             from sympy.core.numbers import One
+
             if isinstance(args[element][0], One):
                 args[element].pop(0)
-            
-            #input_qubits = [(-int(symb.name[1:])-1)%input_var.size for symb in args[element]]
+
+            # input_qubits = [(-int(symb.name[1:])-1)%input_var.size for symb in args[element]]  # noqa
             input_qubits = [int(symb.name[1:]) for symb in args[element]]
             input_qubits = [input_var.reg[i] for i in input_qubits]
-            
-            product = 1 
+
+            product = 1
             for i in range(len(args[element])):
                 product = product * (args[element][i])
-            
 
             mul_tt = TruthTable(product)
-            
+
             if len(product.args) == 0:
                 if isinstance(product, sp.Symbol):
                     qs.cx(input_qubits[0], output_qubit)
                 else:
                     qs.x(output_qubit)
             else:
-                
                 if phase_tolerant:
-                    qs.append(mul_tt.gate_synth(method = "gray_pt"),input_qubits+[output_qubit])
+                    qs.append(
+                        mul_tt.gate_synth(method="gray_pt"),
+                        input_qubits + [output_qubit],
+                    )
                 else:
-                    mcx(input_qubits, output_qubit, method = "gray")
-                    # qs.append(mul_tt.gate_synth(method = "gray"),input_qubits+[output_qubit])
-        else: 
-            if isinstance(args[element][0],sp.core.symbol.Symbol):
-                arg_qubit = (-int(args[element][0].name[1:])-1)%input_var.size
-                
+                    mcx(input_qubits, output_qubit, method="gray")
+                    # qs.append(mul_tt.gate_synth(method = "gray"),input_qubits+[output_qubit])  # noqa
+        else:
+            if isinstance(args[element][0], sp.core.symbol.Symbol):
+                arg_qubit = (-int(args[element][0].name[1:]) - 1) % input_var.size
+
                 arg_qubit = input_var.reg[arg_qubit]
-                qs.cx(arg_qubit,output_qubit)
-            if isinstance(args[element][0],sp.core.numbers.One):
+                qs.cx(arg_qubit, output_qubit)
+            if isinstance(args[element][0], sp.core.numbers.One):
                 qs.x(output_qubit)
-   
 
-def pprm(input_var, output_var, tt, phase_tolerant = False):
-     for column in range(tt.shape[1]):
+
+def pprm(input_var, output_var, tt, phase_tolerant=False):
+    for column in range(tt.shape[1]):
         pprm_synth(input_var, output_var, tt, column, phase_tolerant)
-
```

### Comparing `qrisp-0.0.15/src/qrisp/logic_synthesis/truth_tables.py` & `qrisp-0.0.16/src/qrisp/logic_synthesis/truth_tables.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,293 +1,308 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
-import numpy as np
 
-from qrisp.misc import int_as_array, array_as_int
+import numpy as np
 import sympy as sp
-#from qiskit import *
+
+from qrisp.misc import int_as_array
+from qrisp.circuit import Operation
+#from qrisp import int_encoder, get_ordered_symbol_list
 
 
-#Class to describe truth tables
-#Can be intialized with a list of bitstrings, or a numpy array with 1 and 0s or a sympy expression
+# from qiskit import *
+
+
+# Class to describe truth tables
+# Can be intialized with a list of bitstrings, or a numpy array with 1 and 0s or a
+# sympy expression
 class TruthTable:
     def __init__(self, init_object):
-        
-        #This handles the case that the initializing object is a sympy expression
-        #the variables will be sorted alphabetically regarding their name
+        # This handles the case that the initializing object is a sympy expression
+        # the variables will be sorted alphabetically regarding their name
         if isinstance(init_object, sp.Expr):
-            
-            
             expr = init_object
-            
+
             init_str = ""
-            
+
             self.expr = expr
-            from qrisp.arithmetic.poly_tools import get_ordered_symbol_list            
-            #Retrieve a list of symbols in a given expression
-            #Reverse to get the correct endian convention for qiskit
+            from qrisp.arithmetic.poly_tools import get_ordered_symbol_list
+
+            # Retrieve a list of symbols in a given expression
+            # Reverse to get the correct endian convention for qiskit
             symbol_list = get_ordered_symbol_list(expr)[::-1]
-            
-            #Replace the variables in the expression with 1s and 0s and add them to the intialization string
+
+            # Replace the variables in the expression with 1s and 0s and add them to the
+            # intialization string
             from sympy import lambdify
+
             expr_func = lambdify([symbol_list], expr, "numpy")
-            
-            for i in range(2**len(symbol_list)):
+
+            for i in range(2 ** len(symbol_list)):
                 if len(symbol_list):
                     symbol_const = int_as_array(i, len(symbol_list))
                 else:
                     symbol_const = []
-                
-                res = expr_func(symbol_const)%2
-                if not set({int(res)}) <= set([0,1]):
+
+                res = expr_func(symbol_const) % 2
+                if not set({int(res)}) <= set([0, 1]):
                     raise Exception("Sympy expression returned non-boolean value")
-                
+
                 init_str += str(int(res))
-            #this new object will now contain the string list which will be further prosecuted in this function
+            # this new object will now contain the string list which will be further
+            # prosecuted in this function
             init_object = [init_str]
-        
-        #This handles the case that the truth table is instantiated as a list of strings
+
+        # This handles the case that the truth table is instantiated as a list of
+        # strings
         if isinstance(init_object, list):
-            
-            
-            #Check if the list contains only bit strings of the same length
+            # Check if the list contains only bit strings of the same length
             for i in range(1, len(init_object)):
                 if len(init_object[0]) != len(init_object[i]):
-                    raise Exception("Tried to initialize truth table with varying lengths")
-            
-            #Save string list into object structure
+                    raise Exception(
+                        "Tried to initialize truth table with varying lengths"
+                    )
+
+            # Save string list into object structure
             self.str_l = init_object
-            
-            #Generate numpy array representation
+
+            # Generate numpy array representation
             self.n_rep = [[int(c) for c in singular_tt] for singular_tt in init_object]
             self.n_rep = np.array(self.n_rep).transpose()
-        
-        
-        #This handles the case that the truth table is instantiated as a numpy array
+
+        # This handles the case that the truth table is instantiated as a numpy array
         if isinstance(init_object, np.ndarray):
-            
-            #Save array into object structure
+            # Save array into object structure
             self.n_rep = init_object
-            
-            #Generate list of bitstrings
-            self.str_l = ["".join([str(int(init_object[i,j])) for i in range(init_object.shape[0])]) for j in range(init_object.shape[1])]
-            
-        
-        #Check some conditions
-        if not (set(self.n_rep.flatten()) <= set([0,1])):
+
+            # Generate list of bitstrings
+            self.str_l = [
+                "".join(
+                    [str(int(init_object[i, j])) for i in range(init_object.shape[0])]
+                )
+                for j in range(init_object.shape[1])
+            ]
+
+        # Check some conditions
+        if not (set(self.n_rep.flatten()) <= set([0, 1])):
             raise Exception("Tried to initialize truth table with a non boolean values")
-            
-        
-        #Set shortcuts to some prevalent parameters of the truth table
-        self.shape = self.n_rep.shape    
-        
-        
+
+        # Set shortcuts to some prevalent parameters of the truth table
+        self.shape = self.n_rep.shape
+
         if not (int(np.log2(self.shape[0])) == np.log2(self.shape[0])):
-            raise Exception("Tried to initialize truth table with a boolean function with a length which is not an integer power of 2")
-        
-        
-        
+            raise Exception(
+                "Tried to initialize truth table with a boolean function with a "
+                "length which is not an integer power of 2"
+            )
+
         self.bit_amount = int(np.log2(self.shape[0]))
-        
-    #Returns the "left side" of the truth table, ie. the variable values (starting with 00..00, 00..01, 00..10,...)
+
+    # Returns the "left side" of the truth table, ie. the variable values
+    # (starting with 00..00, 00..01, 00..10,...)
     def variable_array(self):
-        variable_table_array = [int_as_array(i, int(np.log2(self.shape[0]))) for i in range(self.shape[0])]
+        variable_table_array = [
+            int_as_array(i, int(np.log2(self.shape[0]))) for i in range(self.shape[0])
+        ]
         variable_table_array = np.array(variable_table_array)
-            
+
         return TruthTable(variable_table_array)
-    
-    
-    #Returns the cofactors of the truth table
-    #If the truth table describes a boolean function f(x0,x1,x2...)
-    #Then the cofactors for index 2 is f(x0,x1,0,...) and f(x0,x1,1,...)
+
+    # Returns the cofactors of the truth table
+    # If the truth table describes a boolean function f(x0,x1,x2...)
+    # Then the cofactors for index 2 is f(x0,x1,0,...) and f(x0,x1,1,...)
     def cofactors(self, i):
-        
-        #Set up lists for the values of the cofactor tables
-        cofactor_tables = [[],[]]
-        
-        #Iterate over all value constellations and put them either 
-        #into the "first" or the "second" cofactor
+        # Set up lists for the values of the cofactor tables
+        cofactor_tables = [[], []]
+
+        # Iterate over all value constellations and put them either
+        # into the "first" or the "second" cofactor
         for k in range(self.shape[0]):
             if int_as_array(k, self.bit_amount)[i]:
-                cofactor_tables[1].append(self.n_rep[k,:])
+                cofactor_tables[1].append(self.n_rep[k, :])
             else:
-                cofactor_tables[0].append(self.n_rep[k,:])
-        
-        return [TruthTable(np.array(cofactor_tables[0])), TruthTable(np.array(cofactor_tables[1]))]
-    
-    #Returns a single column as a truth tables
+                cofactor_tables[0].append(self.n_rep[k, :])
+
+        return [
+            TruthTable(np.array(cofactor_tables[0])),
+            TruthTable(np.array(cofactor_tables[1])),
+        ]
+
+    # Returns a single column as a truth tables
     def sub_table(self, i):
-        return TruthTable(np.array([self.n_rep[:,i]]).transpose())
-    
-    #Method to print truth tables
+        return TruthTable(np.array([self.n_rep[:, i]]).transpose())
+
+    # Method to print truth tables
     def __str__(self):
         return str(np.array(self.n_rep))
-    
-    #Swaps to columns of the truth table
+
+    # Swaps to columns of the truth table
     def swap_col(self, i, j):
         temp_array = np.array(self.n_rep)
         temp_col = self.n_rep[:, i]
         temp_array[:, i] = temp_array[:, j]
         temp_array[:, j] = temp_col
         return TruthTable(temp_array)
-    
-    #Calculates the complexity of the truth table (more to that in the definition of "D")
-    def calc_complexity(self, as_array = False):
+
+    # Calculates the complexity of the truth table (more to that in the definition
+    # of "D")
+    def calc_complexity(self, as_array=False):
         if as_array:
-            return np.array([D(self.n_rep[:,i]) for i in range(len(self.str_l))])
-        
+            return np.array([D(self.n_rep[:, i]) for i in range(len(self.str_l))])
+
         c = 0
-        
+
         for i in range(len(self.str_l)):
-            c += D(self.n_rep[:,i])
-         
+            c += D(self.n_rep[:, i])
+
         return -c
-    
-            
-    
-    #Synthesizes a ciruict which represents the truth table
-    def q_synth(self, input_var, output_var, method = "gray"):
+
+    # Synthesizes a ciruict which represents the truth table
+    def q_synth(self, input_var, output_var, method="gray"):
         if output_var.size != self.shape[1]:
-            raise Exception("Given output variable doesn't include the required amount of qubits")
-        
+            raise Exception(
+                "Given output variable doesn't include the required amount of qubits"
+            )
+
         if len(input_var) != self.bit_amount:
-            raise Exception("Given input variable doesn't include the required amount of qubits")
-            
-        #Use gray synthesis to synthesize truth table        
+            raise Exception(
+                "Given input variable doesn't include the required amount of qubits"
+            )
+
+        # Use gray synthesis to synthesize truth table
         if method == "gray":
             from qrisp.logic_synthesis.gray_synthesis import gray_logic_synth
-                
-            gray_logic_synth(input_var, output_var, self, phase_tolerant = False)
-        
-            
-        #Use phase tolerant gray synthesis to synthesize truth table
+
+            gray_logic_synth(input_var, output_var, self, phase_tolerant=False)
+
+        # Use phase tolerant gray synthesis to synthesize truth table
         elif method == "gray_pt":
             from qrisp.logic_synthesis.gray_synthesis import gray_logic_synth
-            
-            gray_logic_synth(input_var, output_var, self, phase_tolerant = True)
-        
+
+            gray_logic_synth(input_var, output_var, self, phase_tolerant=True)
+
         elif method == "gray_pt_inv":
-            from qrisp.misc import quantum_invert
             from qrisp.logic_synthesis.gray_synthesis import gray_logic_synth
-            
-            quantum_invert(gray_logic_synth, [input_var, output_var, self, True], input_var.qs)
-            
+            from qrisp.misc import quantum_invert
+
+            quantum_invert(
+                gray_logic_synth, [input_var, output_var, self, True], input_var.qs
+            )
+
         elif method == "pprm_pt":
             from qrisp.logic_synthesis.pprm_synthesis import pprm
-            
-            pprm(input_var, output_var, self, phase_tolerant = True)
-        
+
+            pprm(input_var, output_var, self, phase_tolerant=True)
+
         elif method == "pprm":
             from qrisp.logic_synthesis.pprm_synthesis import pprm
-            
-            pprm(input_var, output_var, self, phase_tolerant = False)
-            
+
+            pprm(input_var, output_var, self, phase_tolerant=False)
+
         elif method == "best":
-            input_var.qs.append(self.gate_synth(), list(input_var.reg) + list(output_var.reg))
-        
+            input_var.qs.append(
+                self.gate_synth(), list(input_var.reg) + list(output_var.reg)
+            )
+
         else:
             raise Exception("Given synthesis method unknown")
-        
-        
-        #Append the truth table to the generated operation, so that it can be
-        #resynthesized phase tolerantly during uncomputation
+
+        # Append the truth table to the generated operation, so that it can be
+        # resynthesized phase tolerantly during uncomputation
         # input_var.qs.data[-1].op.tt = self
         # input_var.qs.data[-1].op.logic_synth_method = method
-        
-        input_var.qs.data[-1].op = LogicSynthGate(input_var.qs.data[-1].op, self, phase_tolerant = method)
-  
-            
-    def gate_synth(self, method = "best", inv = False):
-        
+
+        input_var.qs.data[-1].op = LogicSynthGate(
+            input_var.qs.data[-1].op, self, phase_tolerant=method
+        )
+
+    def gate_synth(self, method="best", inv=False):
         from qrisp.core import QuantumSession, QuantumVariable
-        
-            
+
         if method == "best":
-            
             qs_list = []
-            methods = ["gray_pt","td", "td_pk", "pprm_pt"]
-            
+            methods = ["gray_pt", "td", "td_pk", "pprm_pt"]
+
             if self.bit_amount != 1:
-                methods = ["gray_pt","pprm_pt"]
+                methods = ["gray_pt", "pprm_pt"]
             else:
                 methods = ["pprm_pt"]
-            
-            
-            
-            
+
             for m in methods:
-                qs = QuantumSession()    
+                qs = QuantumSession()
                 input_var = QuantumVariable(self.bit_amount, qs)
                 output_var = QuantumVariable(self.shape[1], qs)
-                
-                self.q_synth(input_var, output_var, method = m)
-                
+
+                self.q_synth(input_var, output_var, method=m)
+
                 qs_list.append(qs)
-            
+
             cnot_list = [qs_list[i].cnot_count() for i in range(len(methods))]
-            
+
             qs = qs_list[cnot_list.index(min(cnot_list))]
-            
-        else:         
+
+        else:
             qs = QuantumSession()
-            
+
             input_var = QuantumVariable(self.bit_amount, qs)
             output_var = QuantumVariable(self.shape[1], qs)
-        
-            self.q_synth(input_var, output_var, method = method)
-            
+
+            self.q_synth(input_var, output_var, method=method)
+
         if not inv:
             return qs.to_gate()
         else:
             return qs.to_gate().inverse()
-    
+
     def __or__(self, other):
         if self.shape != other.shape:
             raise Exception("Tried to or two truth tables of different shape")
-            
+
         new_tt = np.zeros(self.shape)
         for i in range(self.shape[0]):
             for j in range(self.shape[1]):
-                new_tt[i,j] = (self.n_rep[i,j] or other.n_rep[i,j])
-                
+                new_tt[i, j] = self.n_rep[i, j] or other.n_rep[i, j]
+
         return TruthTable(new_tt)
-        
-            
-        
+
+
 T_bib = {}
-#Implementation of the truth table complexity measure described in Miller, D. M., “Spectral and Two-Place Decomposition Techniques in Reversible Logic,” Proc. Midwest Symposium on Circuits and Systems, on CD-ROM, August 2
+
+
+# Implementation of the truth table complexity measure described in Miller, D. M.,
+# “Spectral and Two-Place Decomposition Techniques in Reversible Logic,”
+# Proc. Midwest Symposium on Circuits and Systems, on CD-ROM, August 2
 def T(n):
     global T_bib
-    
+
     if n in T_bib.keys():
         return T_bib[n]
-    
+
     if n == 0:
         return np.array([[1]])
-    
+
     result = np.zeros((2**n, 2**n))
-    
-    temp = T(n-1)
-    
-    result[:2**(n-1),:2**(n-1)] = temp
-    result[2**(n-1):,:2**(n-1)] = temp
-    result[:2**(n-1),2**(n-1):] = temp
-    result[2**(n-1):,2**(n-1):] = -temp
-    
+
+    temp = T(n - 1)
+
+    result[: 2 ** (n - 1), : 2 ** (n - 1)] = temp
+    result[2 ** (n - 1) :, : 2 ** (n - 1)] = temp
+    result[: 2 ** (n - 1), 2 ** (n - 1) :] = temp
+    result[2 ** (n - 1) :, 2 ** (n - 1) :] = -temp
+
     T_bib[n] = result
     return result
 
 
 def fwht(a):
     """In-place Fast Walsh–Hadamard Transform of array a."""
     h = 1
@@ -296,147 +311,154 @@
             for j in range(i, i + h):
                 x = a[j]
                 y = a[j + h]
                 a[j] = x + y
                 a[j + h] = x - y
         h *= 2
 
+
 def rw_spectrum(f):
-    
     if isinstance(f, str):
         f = [int(c) for c in f]
         f = np.array(f)
-    
+
     a = f.copy()
     fwht(a)
     return a
-    
+
     size = len(f)
-    
+
     if np.log2(size) != int(np.log2(size)):
-        raise Exception("The given function does not have the length to properly represent a truth table")
-    
-        
+        raise Exception(
+            "The given function does not have the length to properly represent "
+            "a truth table"
+        )
+
     n = int(np.log2(size))
-    
-    
+
     return np.dot(T(n), f)
 
+
 def C(f):
     size = len(f)
-    
+
     if np.log2(size) != int(np.log2(size)):
-        raise Exception("The given function does not have the length to properly represent a truth table")
-        
+        raise Exception(
+            "The given function does not have the length to properly represent "
+            "a truth table"
+        )
+
     n = int(np.log2(size))
-    
+
     rw_spec = rw_spectrum(f)
     sum_ = 0
     for i in range(size):
-        sum_ += sum(int_as_array(i, n))*rw_spec[i]**2
-    
-    sum_ = sum_/2**(n-2)
-    
-    return 1/2*(n*size - sum_)
+        sum_ += sum(int_as_array(i, n)) * rw_spec[i] ** 2
+
+    sum_ = sum_ / 2 ** (n - 2)
+
+    return 1 / 2 * (n * size - sum_)
+
 
 def NZ(f):
     R = rw_spectrum(f)
-    
+
     sum_ = 0
     for i in R:
         if i == 0:
             sum_ += 1
     return sum_
 
 
 def D(f):
     size = len(f)
     if np.log2(size) != int(np.log2(size)):
-        raise Exception("The given function does not have the length to properly represent a truth table")
-        
+        raise Exception(
+            "The given function does not have the length to properly represent "
+            "a truth table"
+        )
+
     n = int(np.log2(size))
-    
-    
-    return int(n*2**(n-3)*NZ(f) + C(f))
 
+    return int(n * 2 ** (n - 3) * NZ(f) + C(f))
 
-def synth_poly(truth_table, column = 0, coeff = None):
-    
-    if coeff == None:
-        coeff = sp.symbols("".join([" x" + str(i) for i in range(truth_table.bit_amount)]))
+
+def synth_poly(truth_table, column=0, coeff=None):
+    if coeff is None:
+        coeff = sp.symbols(
+            "".join([" x" + str(i) for i in range(truth_table.bit_amount)])
+        )
         if truth_table.bit_amount == 1:
             coeff = [coeff]
 
-
     try:
         expr = truth_table.expr
         symbols = get_ordered_symbol_list(expr)
-        coeff_temp = sp.symbols("".join([" abcdefghijkllmn" + str(i) for i in range(truth_table.bit_amount)]))
-        subs_dic = {symbols[i]:coeff_temp[i] for i in range(len(coeff))}
+        coeff_temp = sp.symbols(
+            "".join(
+                [" abcdefghijkllmn" + str(i) for i in range(truth_table.bit_amount)]
+            )
+        )
+        subs_dic = {symbols[i]: coeff_temp[i] for i in range(len(coeff))}
         expr = expr.subs(subs_dic)
-        subs_dic = {coeff_temp[i]:coeff[i] for i in range(len(coeff))}
+        subs_dic = {coeff_temp[i]: coeff[i] for i in range(len(coeff))}
         expr = expr.subs(subs_dic).expand()
-        #print(subs_dic)
-        #print(sp.Poly(expr.subs(subs_dic).expand(), domain = sp.GF(2)))
-        return sp.Poly(expr.subs(subs_dic).expand(), domain = sp.GF(2)).expr
+        # print(subs_dic)
+        # print(sp.Poly(expr.subs(subs_dic).expand(), domain = sp.GF(2)))
+        return sp.Poly(expr.subs(subs_dic).expand(), domain=sp.GF(2)).expr
     except:
         pass
 
-    
     poly = sp.sympify(0)
     for i in range(truth_table.shape[0]):
-        if truth_table.n_rep[i,column]:
+        if truth_table.n_rep[i, column]:
             temp = sp.sympify(1)
             array = int_as_array(i, truth_table.bit_amount)
             for j in range(len(array)):
                 if array[j]:
-                    temp *= coeff[-j-1]
+                    temp *= coeff[-j - 1]
                 else:
-                    temp *= coeff[-j-1]+1
+                    temp *= coeff[-j - 1] + 1
             poly += temp
-    
+
     if poly == 0:
         return poly
-    return sp.Poly(poly.expand(), domain = sp.GF(2)).expr
-    #return filter_pow(sp.Poly(poly.expand(), domain = sp.GF(2)).expr)
-    
-    
-from qrisp.circuit import Operation
+    return sp.Poly(poly.expand(), domain=sp.GF(2)).expr
+    # return filter_pow(sp.Poly(poly.expand(), domain = sp.GF(2)).expr)
+
+
 class LogicSynthGate(Operation):
-    
-    def __init__(self, init_op, tt, phase_tolerant = False):
-        
+    def __init__(self, init_op, tt, phase_tolerant=False):
         self.tt = tt
-        
+
         self.logic_synth_method = phase_tolerant
-        
+
         for var in init_op.__dict__.keys():
             if var != "inverse":
                 self.__dict__[var] = init_op.__dict__[var]
-                
+
     def inverse(self):
         return LogicSynthGate(Operation.inverse(self), self.tt, self.logic_synth_method)
-    
-    
-def check_synthesis(tt, gate, log_output = False):
+
+
+def check_synthesis(tt, gate, log_output=False):
     synth_correct = True
-    from qrisp.core import QuantumVariable, QuantumSession
-    
+    from qrisp.core import QuantumSession, QuantumVariable
+
     for i in range(tt.shape[0]):
         qs = QuantumSession()
         input_var = QuantumVariable(tt.bit_amount, qs)
-        output_var = QuantumVariable(gate.num_qubits-tt.bit_amount, qs)
+        output_var = QuantumVariable(gate.num_qubits - tt.bit_amount, qs)
         int_encoder(input_var, i)
         qs.append(gate, range(gate.num_qubits))
-        
-        
+
         tt_value = "".join([str(x) for x in tt.n_rep[i]])
         synth_res = list(output_var.get_measurement().keys())[0]
-        
+
         if log_output:
             print("TruthTable:", tt_value)
             print("Synthesis:", synth_res)
             print("---")
-            
+
         synth_correct = synth_correct and tt_value == synth_res
-    
-    return synth_correct
+
+    return synth_correct
```

### Comparing `qrisp-0.0.15/src/qrisp/misc/GMS_tools.py` & `qrisp-0.0.16/src/qrisp/misc/GMS_tools.py`

 * *Files 13% similar despite different names*

```diff
@@ -12,397 +12,427 @@
 
 
 import numpy as np
 from qrisp.circuit import Operation
 
 
 class GXX_wrapper(Operation):
-    
     def __init__(self, n, chi):
-        
         if n == 1:
             pass
-            #raise Exception("Tried to create 1D GXX-gate")
+            # raise Exception("Tried to create 1D GXX-gate")
         flattened_chi = sum(chi, [])
-        
-        super().__init__(name = "GXX", num_qubits = n, params = flattened_chi)
-        
+
+        super().__init__(name="GXX", num_qubits=n, params=flattened_chi)
+
         self.chi = chi
         self.n = n
         from qrisp.circuit import QuantumCircuit
+
         qc = QuantumCircuit(n)
-        
+
         for i in range(len(chi)):
             for j in range(len(chi[i])):
                 if chi[i][j] == 0 or i == j:
                     continue
-                qc.rxx(chi[i][j]/2, i, j)
-        
+                qc.rxx(chi[i][j] / 2, i, j)
+
         self.definition = qc
-        
+
     def inverse(self):
         chi_inv = [[-x for x in y] for y in self.chi]
         return GXX_wrapper(self.n, chi_inv)
-    
 
-# Mimics a circuit which performs n cphase gates, where each cp interacts with the last qubit
+
+# Mimics a circuit which performs n cphase gates, where each cp interacts with the last
+# qubit.
 # example
 # q2874_0: ─■─────────────────────────────────────────────────────────────
-#           │                                                             
+#           │
 # q2874_1: ─┼────────■────────────────────────────────────────────────────
-#           │        │                                                    
+#           │        │
 # q2874_2: ─┼────────┼────────■───────────────────────────────────────────
-#           │        │        │                                           
+#           │        │        │
 # q2874_3: ─┼────────┼────────┼────────■──────────────────────────────────
-#           │        │        │        │                                  
+#           │        │        │        │
 # q2874_4: ─┼────────┼────────┼────────┼────────■─────────────────────────
-#           │        │        │        │        │                         
+#           │        │        │        │        │
 # q2874_5: ─┼────────┼────────┼────────┼────────┼────────■────────────────
-#           │        │        │        │        │        │                
+#           │        │        │        │        │        │
 # q2874_6: ─┼────────┼────────┼────────┼────────┼────────┼────────■───────
-#           │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2) 
+#           │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)  │P(π/2)
 # q2874_7: ─■────────■────────■────────■────────■────────■────────■───────
 # Using only one GMS gate or two uniform GMS gates
-def gms_multi_cp_gate_mono_phase(n, theta, use_uniform = True, phase_tolerant = False, basis = 'GXX'):
-    
-    from qrisp import QuantumSession, QuantumVariable, h, cp, p
+def gms_multi_cp_gate_mono_phase(
+    n, theta, use_uniform=True, phase_tolerant=False, basis="GXX"
+):
+    from qrisp import QuantumSession, QuantumVariable, cp, h, p
+
     qs = QuantumSession()
-    qv = QuantumVariable(n+1, qs)
-    if basis == 'GXX':
+    qv = QuantumVariable(n + 1, qs)
+    if basis == "GXX":
         if use_uniform:
-            gms_1 = GXX_wrapper((n+1), (n+1)*[(n+1)*[-theta/2]])
-            gms_2 = GXX_wrapper(n, n*[n*[theta/2]])
+            gms_1 = GXX_wrapper((n + 1), (n + 1) * [(n + 1) * [-theta / 2]])
+            gms_2 = GXX_wrapper(n, n * [n * [theta / 2]])
         else:
-            #gms = GXX_wrapper(n, (n+1)*[n*[0] + [-theta/2]])
+            # gms = GXX_wrapper(n, (n+1)*[n*[0] + [-theta/2]])
             for i in range(n):
                 cp(theta, qv[i], qv[n])
                 # qs.cp(theta, i, n)
             return GXX_converter(qs).to_gate()
 
         if not phase_tolerant:
             for i in range(n):
-                p(theta/2, qv[i])
+                p(theta / 2, qv[i])
                 # qs.p(theta/2, qv.reg[i])
 
-        p(theta/2*n, qv[-1])
+        p(theta / 2 * n, qv[-1])
         # qs.p(theta/2*n, qv.reg[-1])
 
         h(qv)
 
         qs.append(gms_1, qv.reg)
         if not phase_tolerant:
             qs.append(gms_2, qv.reg[:-1])
 
         h(qv)
 
-
-    elif basis == 'GZZ':
+    elif basis == "GZZ":
         if use_uniform:
-            gms_1 = GZZ_wrapper((n+1), (n+1)*[(n+1)*[-theta/2]])
-            gms_2 = GZZ_wrapper(n, n*[n*[theta/2]])
+            gms_1 = GZZ_wrapper((n + 1), (n + 1) * [(n + 1) * [-theta / 2]])
+            gms_2 = GZZ_wrapper(n, n * [n * [theta / 2]])
         else:
-            #gms = GXX_wrapper(n, (n+1)*[n*[0] + [-theta/2]])
+            # gms = GXX_wrapper(n, (n+1)*[n*[0] + [-theta/2]])
             for i in range(n):
                 cp(theta, qv[i], qv[n])
                 # qs.cp(theta, i, n)
             return GZZ_converter(qs).to_gate()
 
         if not phase_tolerant:
             for i in range(n):
-                p(theta/2, qv[i])
+                p(theta / 2, qv[i])
                 # qs.p(theta/2, qv.reg[i])
 
-        p(theta/2*n, qv[-1])
+        p(theta / 2 * n, qv[-1])
         # qs.p(theta/2*n, qv.reg[-1])
 
         qs.append(gms_1, qv.reg)
         if not phase_tolerant:
             qs.append(gms_2, qv.reg[:-1])
 
     else:
-        raise 'Basis choice must be GXX or GZZ'
+        raise "Basis choice must be GXX or GZZ"
 
-    return qs.to_gate(name = "gms_mono_phase_cp")
+    return qs.to_gate(name="gms_mono_phase_cp")
 
 
 # qb_0: ──■─────────────────
-#         │                 
+#         │
 # qb_1: ──┼────■────────────
-#         │    │            
+#         │    │
 # qb_2: ──┼────┼────■───────
-#         │    │    │       
+#         │    │    │
 # qb_3: ──┼────┼────┼────■──
 #       ┌─┴─┐┌─┴─┐┌─┴─┐┌─┴─┐
 # qb_4: ┤ X ├┤ X ├┤ X ├┤ X ├
 #       └───┘└───┘└───┘└───┘
-def gms_multi_cx_fan_in(n, use_uniform = True, phase_tolerant = False, basis = 'GXX'):
-    
+def gms_multi_cx_fan_in(n, use_uniform=True, phase_tolerant=False, basis="GXX"):
     from qrisp import QuantumSession, QuantumVariable, h
+
     qs = QuantumSession()
-    qv = QuantumVariable(n+1, qs)
-    
-    
+    qv = QuantumVariable(n + 1, qs)
+
     h(qv[-1])
-    
-    qs.append(gms_multi_cp_gate_mono_phase(n, np.pi, use_uniform = use_uniform, phase_tolerant = phase_tolerant, basis = basis), qv.reg)
-    
+
+    qs.append(
+        gms_multi_cp_gate_mono_phase(
+            n,
+            np.pi,
+            use_uniform=use_uniform,
+            phase_tolerant=phase_tolerant,
+            basis=basis,
+        ),
+        qv.reg,
+    )
+
     h(qv[-1])
-    
-    #result = qs.to_gate(name = "gms_multi_cx_fan_in")
-    #result.name = "gms_multi_cx_fan_in"
-    
-    return qs.to_gate(name = "gms_multi_cx_fan_in")
+
+    # result = qs.to_gate(name = "gms_multi_cx_fan_in")
+    # result.name = "gms_multi_cx_fan_in"
+
+    return qs.to_gate(name="gms_multi_cx_fan_in")
 
 
 # qubit_0: ──■────■────■────■──
-#          ┌─┴─┐  │    │    │  
+#          ┌─┴─┐  │    │    │
 # qubit_1: ┤ x ├──┼────┼────┼──
-#          └───┘┌─┴─┐  │    │  
+#          └───┘┌─┴─┐  │    │
 # qubit_2: ─────┤ x ├──┼────┼──
-#               └───┘┌─┴─┐  │  
+#               └───┘┌─┴─┐  │
 # qubit_3: ──────────┤ x ├──┼──
 #                    └───┘┌─┴─┐
 # qubit_4: ───────────────┤ x ├
 #                         └───┘
-def gms_multi_cx_fan_out(n, use_uniform = True, phase_tolerant = False, basis = 'GXX'):
-    
+def gms_multi_cx_fan_out(n, use_uniform=True, phase_tolerant=False, basis="GXX"):
     from qrisp import QuantumSession, QuantumVariable, h
+
     qs = QuantumSession()
-    qv = QuantumVariable(n+1, qs)
-    
+    qv = QuantumVariable(n + 1, qs)
+
     for i in range(n):
         h(qv[i])
-    
-    qs.append(gms_multi_cp_gate_mono_phase(n, np.pi, use_uniform = use_uniform, phase_tolerant = phase_tolerant, basis = basis), qv.reg)
-    
+
+    qs.append(
+        gms_multi_cp_gate_mono_phase(
+            n,
+            np.pi,
+            use_uniform=use_uniform,
+            phase_tolerant=phase_tolerant,
+            basis=basis,
+        ),
+        qv.reg,
+    )
+
     for i in range(n):
         h(qv[i])
-    
-    
+
     result = qs.to_gate()
     result.name = "gms_multi_cx_fan_out"
-    
+
     return result
 
 
-#This functions takes a circuit which only consists of phase and cphase gates
-#and turns it into a GXX gate + some one-qubit gates
-#The basic idea is that a cphase gate acts as
-#CP |ab> = exp(i theta/2 (1 - (-1)^(ab))) |ab>
-#We rewrite (-1)^(ab) = -1/2*((-1)^(a+b) - ((-1)^a + (-1)^b) - 1)
-#The term (-1)^(a+b) can now be executed by a Moelmer-Soerensen:
-#exp(i theta/2 Z_a (x) Z_b)
-#The terms (-1)^a and (-1)^b are executed by single qubit phase gates
-#The remaining -1 is an irrelevant global phase
+# This functions takes a circuit which only consists of phase and cphase gates
+# and turns it into a GXX gate + some one-qubit gates
+# The basic idea is that a cphase gate acts as
+# CP |ab> = exp(i theta/2 (1 - (-1)^(ab))) |ab>
+# We rewrite (-1)^(ab) = -1/2*((-1)^(a+b) - ((-1)^a + (-1)^b) - 1)
+# The term (-1)^(a+b) can now be executed by a Moelmer-Soerensen:
+# exp(i theta/2 Z_a (x) Z_b)
+# The terms (-1)^a and (-1)^b are executed by single qubit phase gates
+# The remaining -1 is an irrelevant global phase
+
 
 def GXX_converter(qs):
-    
-    
     from qrisp import QuantumSession, QuantumVariable
-    
-    
+
     # Check if the given Circuit is valid
-    global_phase = np.array([0.])
+    global_phase = np.array([0.0])
     for i in range(len(qs.data)):
-        if not qs.data[i].op.name in ["p", "cp", "id", "cz", "rz", "qb_alloc", "qb_dealloc"]:
+        if not qs.data[i].op.name in [
+            "p",
+            "cp",
+            "id",
+            "cz",
+            "rz",
+            "qb_alloc",
+            "qb_dealloc",
+        ]:
             raise Exception(qs.data[i].op.name + " is neither Phase nor CPhase gate")
-        
+
         if not qs.data[i].op.name in ["cp", "cz", "qb_alloc", "qb_dealloc"]:
             global_phase += qs.data[i].op.global_phase
-        
-        
-        # Subtract a 1/4 of the phase in case we are dealing with a cp gate (for more elaboration, check eq. 99 of https://arxiv.org/abs/2112.10537)
+
+        # Subtract a 1/4 of the phase in case we are dealing with a cp gate (for more
+        # elaboration, check eq. 99 of https://arxiv.org/abs/2112.10537)
         if qs.data[i].op.name == "cp":
-            global_phase -= qs.data[i].op.params[0]/4
-            
+            global_phase -= qs.data[i].op.params[0] / 4
+
         elif qs.data[i].op.name == "cz":
-            global_phase -= np.pi/4
+            global_phase -= np.pi / 4
 
     # Create qubit index dictionary
-    qubit_index_dic = {qs.qubits[i] : i for i in range(len(qs.qubits))}
+    qubit_index_dic = {qs.qubits[i]: i for i in range(len(qs.qubits))}
 
     # Create phase matrix
-    # The (i,j) entry of this matrix contains the phase that is applied onto the qubit pair (i,j)
-    # the indices with i == j represent single qubit rz gates
+    # The (i,j) entry of this matrix contains the phase that is applied onto the
+    # qubit pair (i,j), the indices with i == j represent single qubit rz gates
     n = len(qs.qubits)
-    phase_matrix = np.zeros((n,n))
-    
+    phase_matrix = np.zeros((n, n))
+
     # Go through all data entries of the circuit
     for i in range(len(qs.data)):
-
         # Set instruction alias
         ins = qs.data[i]
-        
+
         if ins.op.name in ["id", "qb_alloc", "qb_dealloc"]:
             continue
-        
+
         # If sinlge qubit gate => Collect phase
         if len(ins.qubits) == 1:
             index = qubit_index_dic[ins.qubits[0]]
 
             phase_matrix[index, index] += ins.op.params[0]
             continue
-        
-        
-        #Get indices
+
+        # Get indices
         index_0 = qubit_index_dic[ins.qubits[0]]
         index_1 = qubit_index_dic[ins.qubits[1]]
-        
-        #Swap indices if neccessary such that the phase matrix is an upper triangle matrix
+
+        # Swap indices if neccessary such that the phase matrix is an upper triangle
+        # matrix
         if index_0 >= index_1:
             temp = int(index_0)
             index_0 = index_1
             index_1 = temp
-        
-        
-        #Collect phase
+
+        # Collect phase
         if ins.op.name == "cz":
             phase_matrix[index_0, index_1] += np.pi
         else:
             phase_matrix[index_0, index_1] += ins.op.params[0]
-    
-    
-    #Create Quantum Session
+
+    # Create Quantum Session
     qc_res = qs.clearcopy()
-    
-    
+
     if global_phase[0] != 0:
         qc_res.gphase(global_phase[0], 0)
-        
-    
-    #Calculate the row-sum and the column sum of the phase matrix
-    #to determine which single qubit phase has to be applied
-    #This is because every entry with the same row / column represents a phase gate
-    #where the qubit in question participated
+
+    # Calculate the row-sum and the column sum of the phase matrix
+    # to determine which single qubit phase has to be applied
+    # This is because every entry with the same row / column represents a phase gate
+    # where the qubit in question participated
     for i in range(n):
-        qc_res.p((sum(phase_matrix[i,:]) + sum(phase_matrix[:,i]))/2, i)
-        phase_matrix[i,i] = 0
-    
-    
-    #Prepary Chi list for GXX gate
-    chi_list = [[-phase_matrix[j,i] for i in range(n)] for j in range(n)]
-    
-    #Apply GXX Gate
+        qc_res.p((sum(phase_matrix[i, :]) + sum(phase_matrix[:, i])) / 2, i)
+        phase_matrix[i, i] = 0
+
+    # Prepary Chi list for GXX gate
+    chi_list = [[-phase_matrix[j, i] for i in range(n)] for j in range(n)]
+
+    # Apply GXX Gate
     qc_res.h(qc_res.qubits)
     qc_res.append(GXX_wrapper(n, chi_list), range(n))
     qc_res.h(qc_res.qubits)
-    
-    return qc_res
-
 
+    return qc_res
 
 
-#Similar to gms_multi_cp_gate_mono_phase but also allows more than one phase
-#ie. converts circuits of the type 
+# Similar to gms_multi_cp_gate_mono_phase but also allows more than one phase
+# ie. converts circuits of the type
 # q54264_0: ─■─────────────────────────────────────────
-#            │                                         
+#            │
 # q54264_1: ─┼─────────■───────────────────────────────
-#            │         │                               
+#            │         │
 # q54264_2: ─┼─────────┼──────────■────────────────────
-#            │         │          │                    
+#            │         │          │
 # q54264_3: ─┼─────────┼──────────┼──────────■─────────
-#            │P(-π/5)  │P(-2π/5)  │P(-3π/5)  │P(-4π/5) 
+#            │P(-π/5)  │P(-2π/5)  │P(-3π/5)  │P(-4π/5)
 # q54264_4: ─■─────────■──────────■──────────■─────────
-#The advantage over the GXX_converter is the use_uniform mode, which makes
-#sure only uniform GMS gates are used
-def gms_multi_cp_gate(n, phases, use_uniform = True, basis = 'GXX'):
-    
+# The advantage over the GXX_converter is the use_uniform mode, which makes
+# sure only uniform GMS gates are used
+def gms_multi_cp_gate(n, phases, use_uniform=True, basis="GXX"):
     from qrisp import QuantumSession, QuantumVariable, p
-    
+
     qs = QuantumSession()
-    
-    qv = QuantumVariable(n+1, qs)
-    
-    
+
+    qv = QuantumVariable(n + 1, qs)
+
     for i in range(n):
-        p(phases[i]/2, qv[i])
+        p(phases[i] / 2, qv[i])
         # qs.p(phases[i]/2, i)
-    
-    p(sum(phases)/2, qv[n])
+
+    p(sum(phases) / 2, qv[n])
     # qs.p(sum(phases)/2, n)
-    
-    qs.append(gms_multi_cx_fan_out(n, use_uniform = use_uniform, phase_tolerant = False, basis = basis), qv.reg)
-    
+
+    qs.append(
+        gms_multi_cx_fan_out(
+            n, use_uniform=use_uniform, phase_tolerant=False, basis=basis
+        ),
+        qv.reg,
+    )
+
     for i in range(n):
-        qs.p(-phases[i]/2, i)
-    
-    qs.append(gms_multi_cx_fan_out(n, use_uniform = use_uniform, phase_tolerant = False, basis = basis).inverse(), qv.reg)
-    
+        qs.p(-phases[i] / 2, i)
+
+    qs.append(
+        gms_multi_cx_fan_out(
+            n, use_uniform=use_uniform, phase_tolerant=False, basis=basis
+        ).inverse(),
+        qv.reg,
+    )
+
     result = qs.to_gate()
-    
+
     result.name = "gms_multi_cp_gate"
-    
+
     return result
 
 
 class GZZ_wrapper(Operation):
-
     def __init__(self, n, chi):
-
         if n == 1:
             pass
             # raise Exception("Tried to create 1D GZZ-gate")
         flattened_chi = sum(chi, [])
 
         super().__init__(name="GZZ", num_qubits=n, params=flattened_chi)
 
         self.chi = chi
         self.n = n
         from qrisp.circuit import QuantumCircuit
+
         qc = QuantumCircuit(n)
 
         for i in range(len(chi)):
             for j in range(len(chi[i])):
                 if chi[i][j] == 0 or i == j:
                     continue
                 qc.rzz(chi[i][j] / 2, i, j)
-        
+
         self.definition = qc
 
 
-#This functions takes a circuit which only consists of phase and cphase gates
-#and turns it into a GZZ gate + some one-qubit gates
-#The basic idea is that a cphase gate acts as
-#CP |ab> = exp(i theta/2 (1 - (-1)^(ab))) |ab>
-#We rewrite (-1)^(ab) = -1/2*((-1)^(a+b) - ((-1)^a + (-1)^b) - 1)
-#The term (-1)^(a+b) can now be executed by a Moelmer-Soerensen:
-#exp(i theta/2 Z_a (x) Z_b)
-#The terms (-1)^a and (-1)^b are executed by single qubit phase gates
-#The remaining -1 is an irrelevant global phase
+# This functions takes a circuit which only consists of phase and cphase gates
+# and turns it into a GZZ gate + some one-qubit gates
+# The basic idea is that a cphase gate acts as
+# CP |ab> = exp(i theta/2 (1 - (-1)^(ab))) |ab>
+# We rewrite (-1)^(ab) = -1/2*((-1)^(a+b) - ((-1)^a + (-1)^b) - 1)
+# The term (-1)^(a+b) can now be executed by a Moelmer-Soerensen:
+# exp(i theta/2 Z_a (x) Z_b)
+# The terms (-1)^a and (-1)^b are executed by single qubit phase gates
+# The remaining -1 is an irrelevant global phase
 def GZZ_converter(qs):
     from qrisp import QuantumSession, QuantumVariable
 
     # Check if the given Circuit is valid
-    global_phase = np.array([0.])
+    global_phase = np.array([0.0])
     for i in range(len(qs.data)):
-        if not qs.data[i].op.name in ["p", "cp", "id", "cz", "rz", "qb_alloc", "qb_dealloc"]:
+        if not qs.data[i].op.name in [
+            "p",
+            "cp",
+            "id",
+            "cz",
+            "rz",
+            "qb_alloc",
+            "qb_dealloc",
+        ]:
             raise Exception(qs.data[i].op.name + " is neither Phase nor CPhase gate")
-        
+
         if not qs.data[i].op.name in ["cp", "cz", "qb_alloc", "qb_dealloc"]:
             global_phase += qs.data[i].op.global_phase
 
-        # Subtract a 1/4 of the phase in case we are dealing with a cp gate (for more elaboration, check eq. 99 of https://arxiv.org/abs/2112.10537)
+        # Subtract a 1/4 of the phase in case we are dealing with a cp gate (for more
+        # elaboration, check eq. 99 of https://arxiv.org/abs/2112.10537)
         if qs.data[i].op.name == "cp":
-            global_phase -= qs.data[i].op.params[0]/4
-            
+            global_phase -= qs.data[i].op.params[0] / 4
+
         elif qs.data[i].op.name == "cz":
-            global_phase -= np.pi/4
+            global_phase -= np.pi / 4
 
     # Create qubit index dictionary
     qubit_index_dic = {qs.qubits[i]: i for i in range(len(qs.qubits))}
 
     # Create phase matrix
-    # The (i,j) entry of this matrix contains the phase that is applied onto the qubit pair (i,j)
-    # the indices with i == j represent single qubit rz gates
+    # The (i,j) entry of this matrix contains the phase that is applied onto the
+    # qubit pair (i,j), the indices with i == j represent single qubit rz gates
     n = len(qs.qubits)
     phase_matrix = np.zeros((n, n))
 
     # Go through all data entries of the circuit
     for i in range(len(qs.data)):
-
         # Set instruction alias
         ins = qs.data[i]
 
         if ins.op.name in ["id", "qb_alloc", "qb_dealloc"]:
             continue
 
         # If sinlge qubit gate => Collect phase
@@ -412,40 +442,41 @@
             phase_matrix[index, index] += ins.op.params[0]
             continue
 
         # Get indices
         index_0 = qubit_index_dic[ins.qubits[0]]
         index_1 = qubit_index_dic[ins.qubits[1]]
 
-        # Swap indices if neccessary such that the phase matrix is an upper triangle matrix
+        # Swap indices if neccessary such that the phase matrix is an upper triangle
+        # matrix
         if index_0 >= index_1:
             temp = int(index_0)
             index_0 = index_1
             index_1 = temp
 
         # Collect phase
         if ins.op.name == "cz":
             phase_matrix[index_0, index_1] += np.pi
         else:
             phase_matrix[index_0, index_1] += ins.op.params[0]
 
     # Create Quantum Session
     qc_res = qs.clearcopy()
-    
+
     if global_phase[0] != 0:
         qc_res.gphase(global_phase[0], 0)
-        
+
     # Calculate the row-sum and the column sum of the phase matrix
     # to determine which single qubit phase has to be applied
     # This is because every entry with the same row / column represents a phase gate
     # where the qubit in question participated
     for i in range(n):
         qc_res.p((sum(phase_matrix[i, :]) + sum(phase_matrix[:, i])) / 2, i)
         phase_matrix[i, i] = 0
 
     # Prepary Chi list for GZZ gate
     chi_list = [[-phase_matrix[j, i] for i in range(n)] for j in range(n)]
 
     # Apply GZZ Gate
     qc_res.append(GZZ_wrapper(n, chi_list), range(n))
 
-    return qc_res
+    return qc_res
```

### Comparing `qrisp-0.0.15/src/qrisp/misc/depth_reduction.py` & `qrisp-0.0.16/src/qrisp/misc/depth_reduction.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,137 +1,142 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-
-#Modification to Kahns algorithm to reduce the depth of general circuits by applying
-#trivial and non-trivial commutation relations based on the dag representation of unqomp
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+
+# Modification to Kahns algorithm to reduce the depth of general circuits by applying
+# trivial and non-trivial commutation relations based on the dag representation of
+# unqomp.
 
 import networkx as nx
 import numpy as np
 from numba import njit
 
 from qrisp.uncomputation.unqomp import dag_from_qc
 
+
 def qb_set_to_int(qubits, qc):
     res = 0
     for qb in qubits:
-        res |= 1<<qc.qubits.index(qb)
+        res |= 1 << qc.qubits.index(qb)
     return res
 
 
-#Kahns Algorithm based on https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
+# Kahns Algorithm based on
+# https://www.geeksforgeeks.org/topological-sorting-indegree-based-solution/
+
 
 def depth_sensitive_topological_sort(indices, indptr, int_qc, num_qubits):
-      
     # Create a vector to store indegrees of all
     # vertices. Initialize all indegrees as 0.
-    n = len(indptr)-1
-    in_degree = np.zeros(n, dtype = np.int32)
-    
-    depths = np.zeros(num_qubits, dtype = np.int32)
+    n = len(indptr) - 1
+    in_degree = np.zeros(n, dtype=np.int32)
+
+    depths = np.zeros(num_qubits, dtype=np.int32)
     # Traverse adjacency lists to fill indegrees of
     # vertices.  This step takes O(V + E) time
 
-     
     for i in range(n):
-         for j in indices[indptr[i]:indptr[i+1]]:
-             in_degree[j] += 1
- 
+        for j in indices[indptr[i] : indptr[i + 1]]:
+            in_degree[j] += 1
+
     # Create a queue and enqueue all vertices with
     # indegree 0
     queue = []
 
     for i in range(n):
         if in_degree[i] == 0:
             queue.append(i)
- 
-    
+
     # Initialize count of visited vertices
     cnt = 0
- 
+
     # Create a vector to store result (A topological
     # ordering of the vertices)
-    top_order = np.zeros(n, dtype = np.int32)
- 
+    top_order = np.zeros(n, dtype=np.int32)
+
     # One by one dequeue vertices from queue and enqueue
     # adjacents if indegree of adjacent becomes 0
-     
+
     while queue:
- 
-         #The depth sensitive part is now to deque the node with the least depth
+        # The depth sensitive part is now to deque the node with the least depth
         node_costs = np.zeros(len(queue))
-        
+
         for i in range(len(queue)):
             node = queue[i]
-            
+
             qubits = int_qc[node]
-            
+
             depth_sum = 0
             for j in range(num_qubits):
-                if qubits & 1<<j:
+                if qubits & 1 << j:
                     depth_sum += depths[j]
-            
+
             node_costs[i] = depth_sum
 
         u = queue.pop(np.argmin(node_costs))
-        
+
         top_order[cnt] = u
- 
-        #Update depths array
+
+        # Update depths array
         max_depth = 0
-        
+
         for i in range(num_qubits):
-            if int_qc[u] & 1<<i:
+            if int_qc[u] & 1 << i:
                 if depths[i] > max_depth:
                     max_depth = depths[i]
-        
+
         for i in range(num_qubits):
-            if int_qc[u] & 1<<i:
+            if int_qc[u] & 1 << i:
                 depths[i] = max_depth + 1
 
-    
-        #Update in degree array
-        for i in indices[indptr[u]:indptr[u+1]]:
+        # Update in degree array
+        for i in indices[indptr[u] : indptr[u + 1]]:
             in_degree[i] -= 1
             if in_degree[i] == 0:
                 queue.append(i)
-        
+
         cnt += 1
-         
+
     return top_order
-        
 
-depth_sensitive_topological_sort_jitted = njit(cache = True)(depth_sensitive_topological_sort)
 
-def reduce_depth(qc):
+depth_sensitive_topological_sort_jitted = njit(cache=True)(
+    depth_sensitive_topological_sort
+)
+
 
+def reduce_depth(qc):
     if len(qc.data) <= 1:
         return qc.copy()
-    
-    dag = dag_from_qc(qc, remove_init_nodes = True)
-    
-    sprs_mat = nx.to_scipy_sparse_array(dag, format = "csr")
-    
+
+    dag = dag_from_qc(qc, remove_init_nodes=True)
+
+    sprs_mat = nx.to_scipy_sparse_array(dag, format="csr")
+
     node_list = list(dag.nodes())
     qubit_ints = [qb_set_to_int(n.instr.qubits, qc) for n in node_list]
-    
+
     try:
-        qubit_ints = np.array(qubit_ints, dtype = np.int64)
-        res = depth_sensitive_topological_sort_jitted(sprs_mat.indices, sprs_mat.indptr, qubit_ints, num_qubits = qc.num_qubits())
+        qubit_ints = np.array(qubit_ints, dtype=np.int64)
+        res = depth_sensitive_topological_sort_jitted(
+            sprs_mat.indices, sprs_mat.indptr, qubit_ints, num_qubits=qc.num_qubits()
+        )
     except OverflowError:
-        res = depth_sensitive_topological_sort(sprs_mat.indices, sprs_mat.indptr, qubit_ints, num_qubits = qc.num_qubits())
-    
+        res = depth_sensitive_topological_sort(
+            sprs_mat.indices, sprs_mat.indptr, qubit_ints, num_qubits=qc.num_qubits()
+        )
+
     qc_new = qc.clearcopy()
-    
+
     for i in range(len(res)):
         qc_new.append(node_list[res[i]].instr)
-        
+
     return qc_new
```

### Comparing `qrisp-0.0.15/src/qrisp/misc/utility.py` & `qrisp-0.0.16/src/qrisp/misc/utility.py`

 * *Files 7% similar despite different names*

```diff
@@ -12,86 +12,89 @@
 
 
 import traceback
 
 import numpy as np
 import sympy
 
+
 def bin_rep(n, bits):
-    
     if n < 0:
         raise Exception("Only positive numbers are supported")
-    
+
     if n >= 2**bits:
-        raise Exception(str(n) + " can't be represented as a " + str(bits) + " bit number")
-    
+        raise Exception(
+            str(n) + " can't be represented as a " + str(bits) + " bit number"
+        )
+
     zero_string = "".join(["0" for k in range(bits)])
     return (zero_string + bin(n)[2:])[-bits:]
 
+
 def int_encoder(qv, encoding_number):
-    if encoding_number > 2**len(qv) - 1:
+    if encoding_number > 2 ** len(qv) - 1:
         raise Exception("Not enough qubits to encode integer " + str(encoding_number))
-    
+
     binary_rep = bin_rep(encoding_number, len(qv))[::-1]
     from qrisp import x
+
     for i in range(len(binary_rep)):
         if int(binary_rep[i]):
-            
             x(qv[i])
 
-#Calculates the binary expression of a given integer and returns it as an array of length bits
+
+# Calculates the binary expression of a given integer and returns it as an array of
+# length bits
 def int_as_array(k, bit):
     bin_str = bin_rep(k, bit)
     return np.array([int(c) for c in bin_str])
 
+
 def array_as_int(array):
     result = 0
     for k in range(len(array)):
         if array[::-1][k]:
-            result += 2**(k)
-        
+            result += 2 ** (k)
+
     return result
 
-#Decomposes the circuit qc until no more decompositions are possible and then counts the cnot operations
+
+# Decomposes the circuit qc until no more decompositions are possible and then counts
+# the cnot operations
 def cnot_count(qc):
-    
     qc = qc.transpile()
-    
+
     gate_count_dic = qc.count_ops()
-    
+
     try:
         return gate_count_dic["cx"]
     except KeyError:
         return 0
 
 
-
 def is_inv(x, bit):
-        
-    #return (math.gcd(int(np.round(x, 3)),2**bit) == 1)
-    
-    #The only divisors 2**bit has is powers of 2
-    #ie. if tha factorization of x doesn't contain any powers of 2 it is invertible
-    #in other words: x is invertible if it is uneven
-    return bool(int(x)%2)
+    # return (math.gcd(int(np.round(x, 3)),2**bit) == 1)
+
+    # The only divisors 2**bit has is powers of 2
+    # ie. if tha factorization of x doesn't contain any powers of 2 it is invertible
+    # in other words: x is invertible if it is uneven
+    return bool(int(x) % 2)
 
 
-def get_depth_dic(qc, transpile_qc = True):
-    
+def get_depth_dic(qc, transpile_qc=True):
     if len(qc.qubits) == 0:
         return {}
-    
-    
+
     if transpile_qc:
         qc = qc.transpile()
-    
+
     # Assign each bit in the circuit a unique integer
     # to index into op_stack.
     bit_indices = {bit: idx for idx, bit in enumerate(qc.qubits + qc.clbits)}
-    
+
     # If no bits, return 0
     if not bit_indices:
         return 0
 
     # A list that holds the height of each qubit
     # and classical bit.
     op_stack = [0] * len(bit_indices)
@@ -102,100 +105,114 @@
     # qubit or cbit that are connected by a virtual
     # line so that they all stacked at the same depth.
     # Conditional gates act on all cbits in the register
     # they are conditioned on.
     # We treat barriers or snapshots different as
     # They are transpiler and simulator directives.
     # The max stack height is the circuit depth.
-    
 
     for instr in qc.data:
-        
         if instr.op.name in ["qb_alloc", "qb_dealloc"]:
             continue
         qargs = instr.qubits
         cargs = instr.clbits
-        
+
         levels = []
         reg_ints = []
         # If count then add one to stack heights
         count = True
-        
+
         for ind, reg in enumerate(qargs + cargs):
             # Add to the stacks of the qubits and
             # cbits used in the gate.
             reg_ints.append(bit_indices[reg])
             if count:
                 levels.append(op_stack[reg_ints[ind]] + 1)
             else:
                 levels.append(op_stack[reg_ints[ind]])
-    
+
         max_level = max(levels)
         for ind in reg_ints:
             op_stack[ind] = max_level
-    
+
     return {qc.qubits[i]: op_stack[i] for i in range(len(qc.qubits))}
 
 
-def gate_wrap(*args, permeability = None, is_qfree = None, name = None, verify = False):
+def gate_wrap(*args, permeability=None, is_qfree=None, name=None, verify=False):
     """
-    Decorator to bundle up the quantum instructions of a function into a single gate object.
-    Bundled gate objects can help debugging as it allows for a more clear QuantumCircuit visualisation. 
-    
-    Furthermore bundling up functions is relevant for Qrisps uncomputation algorithm. 
-    When bundling up for uncomputation, this decorator provides the means to annotate the gate objects with information about its permeability and qfree-ness. For further information about these concepts check the :ref:`uncomputation documentation<uncomputation>`. Specifying this information allows to skip the computationally costly automatic determination at runtime.
-    
-    Note that the specified information is not checked for correctness as this would defy the purpose.
-    
-    A shorthand for ``gate_wrap(permeability = "args", is_qfree = True)`` is the :meth:`lifted <qrisp.lifted>` decorator.
-    
-    
+    Decorator to bundle up the quantum instructions of a function into a single gate
+    object. Bundled gate objects can help debugging as it allows for a more clear
+    QuantumCircuit visualisation.
+
+    Furthermore, bundling up functions is relevant for Qrisps uncomputation algorithm.
+    When bundling up for uncomputation, this decorator provides the means to annotate
+    the gate objects with information about its permeability and qfree-ness. For further
+    information about these concepts check the
+    :ref:`uncomputation documentation<uncomputation>`. Specifying this information
+    allows to skip the computationally costly automatic determination at runtime.
+
+    Note that the specified information is not checked for correctness as this would
+    defy the purpose.
+
+    A shorthand for ``gate_wrap(permeability = "args", is_qfree = True)`` is the
+    :meth:`lifted <qrisp.lifted>` decorator.
+
+
     .. warning::
-        
-        Using ``gate_wrap`` without specifying permeability and ``qfree``-ness on functions processing a lot of qubits,
-        can causes long compile times, since the unitaries of these gates have to be determined numerically.
-    
+
+        Using ``gate_wrap`` without specifying permeability and ``qfree``-ness on
+        functions processing a lot of qubits, can causes long compile times, since the
+        unitaries of these gates have to be determined numerically.
+
     .. warning::
-        
-        Incorrect information about permeability and ``qfree``-ness can yield incorrect compilation results. If you are unsure, use the ``verify`` keyword on a small scale first.
-    
-    
+
+        Incorrect information about permeability and ``qfree``-ness can yield incorrect
+        compilation results. If you are unsure, use the ``verify`` keyword on a small
+        scale first.
+
+
     Parameters
     ----------
 
     permeability : string or list, optional
-        Specify the permeability behavior of the function. When given "args", it is assumed that the gate is permeable only on the qubits of the arguments. When given "full", it is assumed that the gate is permeable on every qubit it acts on (ie. also the result). When given a list of integers it is assumed, that the gate is permeable on the qubits of the arguments corresponding to the integers. The default is None.
+        Specify the permeability behavior of the function. When given "args", it is
+        assumed that the gate is permeable only on the qubits of the arguments. When
+        given "full", it is assumed that the gate is permeable on every qubit it acts on
+        (i.e. also the result). When given a list of integers it is assumed, that the
+        gate is permeable on the qubits of the arguments corresponding to the integers.
+        The default is None.
     is_qfree : bool, optional
         Specify the qfree-ness of the function. The default is None.
     name : string, optional
         String which will be used for naming the gate object. The default is None.
     verify : bool, optional
-        If set to ``True``, the specified information about permeability and ``qfree``-ness will be checked numerically. The default is ``False``.
+        If set to ``True``, the specified information about permeability and
+        ``qfree``-ness will be checked numerically. The default is ``False``.
 
     Examples
     --------
 
     We create a simple function wrapping up multiple gates: ::
-        
-        
+
+
         from qrisp import QuantumVariable, cx, x, h, z, gate_wrap
-        
+
         @gate_wrap
         def example_function(a, b):
-            
+
             cx(a,b)
             x(a)
             cx(b,a)
             h(b)
-        
+
         a = QuantumVariable(3)
         b = QuantumVariable(3)
-        
+
         example_function(a, b)
-        
+
     >>> print(a.qs)
     QuantumCircuit:
     ---------------
          ┌───────────────────┐
     b.0: ┤0                  ├
          │                   │
     b.1: ┤1                  ├
@@ -209,63 +226,64 @@
     a.2: ┤5                  ├
          └───────────────────┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable a
     QuantumVariable b
     >>> print(a.qs.transpile())
-         ┌───┐                    ┌───┐          
+         ┌───┐                    ┌───┐
     b.0: ┤ X ├─────────────────■──┤ H ├──────────
-         └─┬─┘┌───┐            │  └───┘┌───┐     
+         └─┬─┘┌───┐            │  └───┘┌───┐
     b.1: ──┼──┤ X ├────────────┼────■──┤ H ├─────
            │  └─┬─┘┌───┐       │    │  └───┘┌───┐
     b.2: ──┼────┼──┤ X ├───────┼────┼────■──┤ H ├
            │    │  └─┬─┘┌───┐┌─┴─┐  │    │  └───┘
     a.0: ──■────┼────┼──┤ X ├┤ X ├──┼────┼───────
-                │    │  ├───┤└───┘┌─┴─┐  │       
+                │    │  ├───┤└───┘┌─┴─┐  │
     a.1: ───────■────┼──┤ X ├─────┤ X ├──┼───────
-                     │  ├───┤     └───┘┌─┴─┐     
+                     │  ├───┤     └───┘┌─┴─┐
     a.2: ────────────■──┤ X ├──────────┤ X ├─────
-                        └───┘          └───┘     
+                        └───┘          └───┘
+
 
+    In the next example, we create a function that performs no quantum gates and specify
+    that it is qfree and permeable on the second argument but not on the first. ::
 
-    In the next example, we create a function that performs no quantum gates and specify that it is qfree and permeable on the second argument but not on the first. ::
-        
         from qrisp import QuantumCircuit
-        
+
         @gate_wrap(permeability = [1], is_qfree = True)
         def example_function(arg_0, arg_1):
-            
+
             res = QuantumVariable(1)
 
             #Append an identity gate
             res.qs.append(QuantumCircuit(3).to_gate(), [arg_0, arg_1, res])
-            
+
             return res
-        
+
         qv_0 = QuantumVariable(1)
         qv_1 = QuantumVariable(1)
-        
+
         res = example_function(qv_0, qv_1)
-        
+
     >>> print(qv_0.qs)
     QuantumCircuit:
     ---------------
             ┌───────────────────┐
     qv_0.0: ┤0                  ├
             │                   │
     qv_1.0: ┤1 example_function ├
             │                   │
      res.0: ┤2                  ├
             └───────────────────┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable qv_0
     QuantumVariable qv_1
-    QuantumVariable res     
+    QuantumVariable res
     >>> qv_1.uncompute()
     >>> print(qv_0.qs)
     QuantumCircuit:
     ---------------
             ┌───────────────────┐
     qv_0.0: ┤0                  ├
             │                   │
@@ -274,167 +292,170 @@
      res.0: ┤2                  ├
             └───────────────────┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable qv_0
     QuantumVariable res
 
-    Since ``arg_1`` is marked as permeable, there are no further gates required for uncomputation.
-    The situation is different for the other two QuantumVariables, where the qubits are not marked as permeable.
-    
+    Since ``arg_1`` is marked as permeable, there are no further gates required for
+    uncomputation. The situation is different for the other two QuantumVariables, where
+    #the qubits are not marked as permeable.
+
     >>> qv_0.uncompute(do_it = False)
     >>> res.uncompute()
     >>> print(qv_0.qs)
     QuantumCircuit:
     ---------------
             ┌───────────────────┐┌──────────────────────┐
     qv_0.0: ┤0                  ├┤0                     ├
             │                   ││                      │
     qv_1.0: ┤1 example_function ├┤1 example_function_dg ├
             │                   ││                      │
      res.0: ┤2                  ├┤2                     ├
             └───────────────────┘└──────────────────────┘
     Live QuantumVariables:
-    ----------------------    
+    ----------------------
     """
-    
-    
+
     if len(args):
         return gate_wrap_inner(args[0])
-    
+
     else:
-        
+
         def gate_wrap_helper(function):
-            return gate_wrap_inner(function, permeability = permeability, is_qfree = is_qfree, name = name, verify = verify)
-        
+            return gate_wrap_inner(
+                function,
+                permeability=permeability,
+                is_qfree=is_qfree,
+                name=name,
+                verify=verify,
+            )
+
         return gate_wrap_helper
 
 
-def gate_wrap_inner(function, permeability = None, is_qfree = None, name = None, verify = False):
-    
-    
-    def wrapped_function(*args, permeability = permeability, is_qfree = is_qfree, verify = verify, **kwargs):
-        
-        
+def gate_wrap_inner(
+    function, permeability=None, is_qfree=None, name=None, verify=False
+):
+    def wrapped_function(
+        *args, permeability=permeability, is_qfree=is_qfree, verify=verify, **kwargs
+    ):
         wrapped_function.__name__ = function.__name__
-        from qrisp.core import recursive_qs_search, recursive_qv_search
-        from qrisp.environments import GateWrapEnvironment 
         from qrisp.circuit import Qubit
-        
+        from qrisp.core import recursive_qs_search, recursive_qv_search
+        from qrisp.environments import GateWrapEnvironment
+
         qs_list = recursive_qs_search([args, kwargs])
 
         if len(qs_list) == 0:
-            raise Exception("Could not find QuantumSession object in function arguments during gate-wrapping")
-        
-        
-        
+            raise Exception(
+                "Could not find QuantumSession object in function arguments during "
+                "gate-wrapping"
+            )
+
         qs = qs_list[0]
-        
+
         initial_qubits = set(qs.qubits)
-        
+
         if name is None:
-            gwe = GateWrapEnvironment(name = function.__name__)
+            gwe = GateWrapEnvironment(name=function.__name__)
         else:
-            gwe = GateWrapEnvironment(name = name)
-        
+            gwe = GateWrapEnvironment(name=name)
+
         with gwe:
-            
             result = function(*args, **kwargs)
-        
+
         try:
             qs.data.remove(gwe)
-                
+
             gwe.compile()
-                
-                    
+
         except ValueError:
             pass
-            
+
         if gwe.instruction is None:
             return result
-        
+
         created_qubits = set(qs_list[0].qubits) - initial_qubits
-        
+
         ancillas = []
-        
+
         for qb in created_qubits:
-            if qb.allocated == False:
+            if qb.allocated is False:
                 ancillas.append(qb)
-        
-        if not is_qfree is None:
+
+        if is_qfree is not None:
             if verify and is_qfree:
-                
                 from qrisp.uncomputation import is_qfree as is_qfree_function
-                
+
                 if not is_qfree_function(gwe.instruction.op):
-                    raise Exception(f"Verification of qfree-ness for function {function.__name__} failed")
-            
+                    raise Exception(
+                        f"Verification of qfree-ness for function {function.__name__} "
+                        f"failed"
+                    )
+
             gwe.instruction.op.is_qfree = is_qfree
-        
-        if not permeability is None:
-            permeability_dict = {}    
+
+        if permeability is not None:
+            permeability_dict = {}
             arg_qubits = []
-            
-            
+
             if isinstance(permeability, list):
                 args = [args[i] for i in permeability]
                 permeability = "args"
-                
-            
+
             for arg in args:
                 if isinstance(arg, list):
                     for item in arg:
                         if isinstance(item, Qubit):
                             arg_qubits.append(item)
                 for arg_qv in recursive_qv_search([arg]):
                     arg_qubits += arg_qv.reg
-            
+
             for i in range(len(gwe.instruction.qubits)):
-                
                 qb = gwe.instruction.qubits[i]
-                
+
                 if qb in arg_qubits:
-                    
                     if permeability in ["args", "full"]:
                         permeability_dict[i] = True
                     else:
-                        raise Exception("Don't know permeability option " + permeability)
+                        raise Exception(
+                            "Don't know permeability option " + permeability
+                        )
                 else:
                     if permeability == "full":
                         permeability_dict[i] = True
                     else:
                         permeability_dict[i] = False
-        
-            
+
             for i in range(len(gwe.instruction.qubits)):
-                
                 qb = gwe.instruction.qubits[i]
-                
+
                 if qb in ancillas:
-                    #Even though ancilla qubits are permeable, we want to be able
-                    #to use the gate_wrap decorator as an interface to perform recomputation.
-                    #If we would mark them as permeable, Unqomp won't wrap the uncomputed
-                    #gate in alloc/dealloc gates but instead wrap both the computation gate and the recomputation
-                    #in alloc/dealloc gates
-                    
-                    #To undestand this behavior better consider the following example
-                    
-                        # from qrisp import QuantumFloat
-                        # a = QuantumFloat(2)
-                        # qf_res = a * a
-                        # qf_res.uncompute()
-                        # print(qf_res.qs)
-                    
-                    #If we mark the ancilla qubits as permeable, this gives
-                    
+                    # Even though ancilla qubits are permeable, we want to be able to
+                    # use the gate_wrap decorator as an interface to perform
+                    # recomputation. If we mark them as permeable, Unqomp won't  wrap
+                    # the uncomputed gate in alloc/dealloc gates but instead wrap both
+                    # the computation gate and the recomputation in alloc/dealloc gates
+
+                    # To undestand this behavior better consider the following example
+
+                    # from qrisp import QuantumFloat
+                    # a = QuantumFloat(2)
+                    # qf_res = a * a
+                    # qf_res.uncompute()
+                    # print(qf_res.qs)
+
+                    # If we mark the ancilla qubits as permeable, this gives
+
                     # QuantumCircuit:
                     # ---------------
-                    #              ┌──────────┐┌──────────┐┌─────────────┐              
+                    #              ┌──────────┐┌──────────┐┌─────────────┐
                     #         a.0: ┤ qb_alloc ├┤0         ├┤0            ├──────────────
-                    #              ├──────────┤│          ││             │              
+                    #              ├──────────┤│          ││             │
                     #         a.1: ┤ qb_alloc ├┤1         ├┤1            ├──────────────
                     #              ├──────────┤│          ││             │┌────────────┐
                     #    return.0: ┤ qb_alloc ├┤2         ├┤2            ├┤ qb_dealloc ├
                     #              ├──────────┤│          ││             │├────────────┤
                     #    return.1: ┤ qb_alloc ├┤3 __mul__ ├┤3 __mul___dg ├┤ qb_dealloc ├
                     #              ├──────────┤│          ││             │├────────────┤
                     #    return.2: ┤ qb_alloc ├┤4         ├┤4            ├┤ qb_dealloc ├
@@ -442,18 +463,17 @@
                     #    return.3: ┤ qb_alloc ├┤5         ├┤5            ├┤ qb_dealloc ├
                     #              ├──────────┤│          ││             │├────────────┤
                     # sbp_anc_0.0: ┤ qb_alloc ├┤6         ├┤6            ├┤ qb_dealloc ├
                     #              └──────────┘└──────────┘└─────────────┘└────────────┘
                     # Live QuantumVariables:
                     # ----------------------
                     # QuantumFloat a
-                    
-                    
+
                     # If we set them to non-permeable, we get instead
-                    
+
                     # QuantumCircuit:
                     # ---------------
                     #              ┌──────────┐┌──────────┐                          ┌─────────────┐»
                     #         a.0: ┤ qb_alloc ├┤0         ├──────────────────────────┤0            ├»
                     #              ├──────────┤│          │                          │             │»
                     #         a.1: ┤ qb_alloc ├┤1         ├──────────────────────────┤1            ├»
                     #              ├──────────┤│          │                          │             │»
@@ -463,17 +483,17 @@
                     #              ├──────────┤│          │                          │             │»
                     #    return.2: ┤ qb_alloc ├┤4         ├──────────────────────────┤4            ├»
                     #              ├──────────┤│          │                          │             │»
                     #    return.3: ┤ qb_alloc ├┤5         ├──────────────────────────┤5            ├»
                     #              ├──────────┤│          │┌────────────┐┌──────────┐│             │»
                     # sbp_anc_0.0: ┤ qb_alloc ├┤6         ├┤ qb_dealloc ├┤ qb_alloc ├┤6            ├»
                     #              └──────────┘└──────────┘└────────────┘└──────────┘└─────────────┘»
-                    # «                           
+                    # «
                     # «        a.0: ──────────────
-                    # «                           
+                    # «
                     # «        a.1: ──────────────
                     # «             ┌────────────┐
                     # «   return.0: ┤ qb_dealloc ├
                     # «             ├────────────┤
                     # «   return.1: ┤ qb_dealloc ├
                     # «             ├────────────┤
                     # «   return.2: ┤ qb_dealloc ├
@@ -481,705 +501,735 @@
                     # «   return.3: ┤ qb_dealloc ├
                     # «             ├────────────┤
                     # «sbp_anc_0.0: ┤ qb_dealloc ├
                     # «             └────────────┘
                     # Live QuantumVariables:
                     # ----------------------
                     # QuantumFloat a
-                    
-                    #In both cases, sbp_anc is recomputed, but in the second case, the reallocation allows the compiler
-                    #to use the free qubit elsewhere and afterwards pick a potentially different qubit for the recomputation
-                    
+
+                    # In both cases, sbp_anc is recomputed, but in the second case, the
+                    # reallocation allows the compiler to use the free qubit elsewhere
+                    # and afterwards pick a potentially different qubit for the
+                    # recomputation.
+
                     permeability_dict[i] = False
-                
+
                 for i in range(len(gwe.instruction.qubits)):
-                    
                     if permeability_dict[i] is None:
                         permeability_dict[i] = False
-                
+
                 if verify:
                     from qrisp.uncomputation import is_permeable
+
                     permeable_qubit_indices = []
-                    
+
                     for i in range(gwe.instruction.op.num_qubits):
                         if permeability_dict[i]:
                             permeable_qubit_indices.append(i)
-                            
+
                     if not is_permeable(gwe.instruction.op, permeable_qubit_indices):
-                        raise Exception(f"Verification of permeability for function {function.__name__} failed")
-        
-                
+                        raise Exception(
+                            f"Verification of permeability for function "
+                            f"{function.__name__} failed"
+                        )
+
                 gwe.instruction.op.permeability = permeability_dict
-        
+
         return result
-        
-    
-    
+
     return wrapped_function
 
 
-#Function to measure multiple quantum variables at once to assess their entanglement
-def multi_measurement(qv_list, shots = 10000, backend = None):
+# Function to measure multiple quantum variables at once to assess their entanglement
+def multi_measurement(qv_list, shots=10000, backend=None):
     """
-    This functions facilitates the measurement of multiple QuantumVariables at the same time. This can be used if the entanglement structure between several QuantumVariables is of interest.
+    This functions facilitates the measurement of multiple QuantumVariables at the same
+    time. This can be used if the entanglement structure between several
+    QuantumVariables is of interest.
 
     Parameters
     ----------
     qv_list : list[QuantumVariable]
         A list of QuantumVariables.
     shots : int, optional
         The amount of shots to perform. The default is 10000.
     backend : BackendClient, optional
-        The backend to evaluate the compiled QuantumCircuit on. By default, the backend from default_backend.py will be used.
+        The backend to evaluate the compiled QuantumCircuit on. By default, the backend
+        from default_backend.py will be used.
 
     Raises
     ------
     Exception
         Tried to perform measurement with open environments.
 
     Returns
     -------
     counts_list : list
-        A list of tuples. The first element of each tuple is a tuple again and contains the labels of the QuantumVariables. The second element is a float and indicates the probability of measurement.
+        A list of tuples. The first element of each tuple is a tuple again and contains
+        the labels of the QuantumVariables. The second element is a float and indicates
+        the probability of measurement.
 
     Examples
     --------
-    
+
     We entangle three QuantumFloats via addition and perform a multi-measurement:
-        
+
     >>> from qrisp import QuantumFloat, h, multi_measurement
     >>> qf_0 = QuantumFloat(4)
     >>> qf_1 = QuantumFloat(4)
     >>> qf_0[:] = 3
     >>> qf_1[:] = 2
     >>> h(qf_1[0])
     >>> qf_sum = qf_0 + qf_1
     >>> multi_measurement([qf_0, qf_1, qf_sum])
-    {(3, 2, 5): 0.5, (3, 3, 6): 0.5}  
-    
+    {(3, 2, 5): 0.5, (3, 3, 6): 0.5}
+
     """
-    
-    
-    if backend == None:
-        if qv_list[0].qs.backend == None:
+
+    if backend is None:
+        if qv_list[0].qs.backend is None:
             from qrisp.default_backend import def_backend
+
             backend = def_backend
         else:
             backend = qv_list[0].qs.backend
-        
+
     if len(qv_list[0].qs.env_stack) != 0:
         raise Exception("Tried to perform measurement with open environments")
-    
+
     from qrisp import merge
+
     merge(qv_list)
-    
-    from qrisp.core.compilation import qompiler
-    #Copy circuit in order to prevent modification
+
+    # Copy circuit in order to prevent modification
     from qrisp import QuantumArray, QuantumVariable, recursive_qv_search
-    
+    from qrisp.core.compilation import qompiler
+
     temp = recursive_qv_search(qv_list)
-    
-    compiled_qc = qompiler(qv_list[0].qs, intended_measurements = sum([qv.reg for qv in temp], []))
+
+    compiled_qc = qompiler(
+        qv_list[0].qs, intended_measurements=sum([qv.reg for qv in temp], [])
+    )
     # compiled_qc = qv_list[0].qs.copy()
-    #Add classical registers for the measurement results to be stored in
+    # Add classical registers for the measurement results to be stored in
     cl_reg_list = []
-    
-    
+
     for var in qv_list[::-1]:
         cl_reg = []
-        
+
         if isinstance(var, QuantumArray):
             qubits = sum([qv.reg for qv in var.flatten()[::-1]], [])
         elif isinstance(var, QuantumVariable):
             qubits = var.reg
         else:
             raise Exception(f"Found type {type(var)} in measurement list")
-        
+
         for i in range(len(qubits)):
             cl_reg.append(compiled_qc.add_clbit())
-            
+
         cl_reg_list.append(cl_reg)
-        
-        #Add measurement instruction
+
+        # Add measurement instruction
         compiled_qc.measure(qubits, cl_reg)
-    
-    
-    #counts = execute(qs_temp, backend, basis_gates = basis_gates, noise_model = noise_model, shots = shots).result().get_counts()
+
+    # counts = execute(qs_temp, backend, basis_gates = basis_gates,
+    # noise_model = noise_model, shots = shots).result().get_counts()
     counts = backend.run(compiled_qc, shots)
-    counts = {k : counts[k] for k in sorted(counts)}
-    
-    #Convert the labeling bistrings of counts into list of labels
+    counts = {k: counts[k] for k in sorted(counts)}
+
+    # Convert the labeling bistrings of counts into list of labels
     new_counts = {}
     for i in range(len(counts)):
-        
-        #Retrieve the separated strings of each measurement variable
-        
+        # Retrieve the separated strings of each measurement variable
+
         counts_strings = []
         counts_bitstring = list(counts.keys())[i]
-        
+
         bitstring_adress = 0
         for j in range(len(cl_reg_list)):
             cl_reg = cl_reg_list[::-1][j]
-            counts_strings.append(counts_bitstring[bitstring_adress:bitstring_adress + len(cl_reg)][::-1])
+            counts_strings.append(
+                counts_bitstring[bitstring_adress : bitstring_adress + len(cl_reg)][
+                    ::-1
+                ]
+            )
             bitstring_adress += len(cl_reg)
-        
-        
-        #Convert to integers and insert outcome labels
+
+        # Convert to integers and insert outcome labels
         counts_values = []
         for j in range(len(counts_strings)):
-            
             outcome_int = int(counts_strings[j][::-1], 2)
             try:
                 label = qv_list[j].decoder(outcome_int)
                 if isinstance(label, np.ndarray):
                     from qrisp import OutcomeArray
+
                     label = OutcomeArray(label)
                 counts_values.append(label)
             except AttributeError:
                 counts_values.append(outcome_int)
-        
-        
-        
-        #Create array
+
+        # Create array
         array_state = tuple(counts_values)
         try:
-            new_counts[array_state] = counts[list(counts.keys())[i]]/shots
+            new_counts[array_state] = counts[list(counts.keys())[i]] / shots
         except TypeError:
-            raise Exception("Tried to create measurement outcome dic for QuantumVariable with unhashable labels")
-        #Append to the counts list
+            raise Exception(
+                "Tried to create measurement outcome dic for QuantumVariable "
+                "with unhashable labels"
+            )
+        # Append to the counts list
         # counts_list.append((array_state, counts[list(counts.keys())[i]]/shots))
-    
-    #Sort counts_list such the most probable values come first
+
+    # Sort counts_list such the most probable values come first
     new_counts = dict(sorted(new_counts.items(), key=lambda item: -item[1]))
-    
-    return new_counts
 
+    return new_counts
 
 
-#Function to apply a phase function of signature phase_function(x,y,z..) -> float
-#which specifies the phase for each constellation of outcome labels of the quantum variables in qv_list
-def app_phase_function(qv_list, phase_function, t = 1, **kwargs):
-    
-    #Prepare the list of index tuples
-    #For this we first create a list of outcome indices of each qv first
+# Function to apply a phase function of signature phase_function(x,y,z..) -> float
+# which specifies the phase for each constellation of outcome labels of the quantum
+# variables in qv_list.
+def app_phase_function(qv_list, phase_function, t=1, **kwargs):
+    # Prepare the list of index tuples
+    # For this we first create a list of outcome indices of each qv first
     index_lists = [list(range(2**qv.size)) for qv in qv_list]
-    
-    
-    #We now calculate the direct product in order to obtain every possible combination
+
+    # We now calculate the direct product in order to obtain every possible combination
     from itertools import product
+
     product_index_list = list(product(*index_lists))
-    
-    #The next step is to iterate over every combination in order to determine the phases
+
+    # The next step is to iterate over every combination in order to determine the
+    # phases.
     phases = []
     for i in range(len(product_index_list)):
-        #Calculate the outcome labels of the current constellation of indices
-        labels = [qv_list[j].decoder(product_index_list[i][j]) for j in range(len(qv_list))]
-        
-        #Calculate the phase
-        phases.append(phase_function(*labels, **kwargs)*t)
-    
-    #Synthesize phase        
+        # Calculate the outcome labels of the current constellation of indices
+        labels = [
+            qv_list[j].decoder(product_index_list[i][j]) for j in range(len(qv_list))
+        ]
+
+        # Calculate the phase
+        phases.append(phase_function(*labels, **kwargs) * t)
+
+    # Synthesize phase
     from qrisp.logic_synthesis import gray_phase_synth_qb_list
-    gray_phase_synth_qb_list(qv_list[0].qs, sum([qv.reg[::-1] for qv in qv_list], []), phases)
+
+    gray_phase_synth_qb_list(
+        qv_list[0].qs, sum([qv.reg[::-1] for qv in qv_list], []), phases
+    )
 
 
 def as_hamiltonian(hamiltonian):
     r"""
-    Decorator that recieves a regular Python function (returning a float) and returns a function of QuantumVariables, applying phases based on the function's output.
-        
+    Decorator that recieves a regular Python function (returning a float) and returns a
+    function of QuantumVariables, applying phases based on the function's output.
+
     Parameters
     ----------
     hamiltonian : function
         A function of arbitrary (non-quantum) variables returning a float.
 
     Returns
     -------
     hamiltonian_application : function
-        A function of QuantumVariables, which applies the phase dictated by the hamiltonian to the corresponding states.
-    
+        A function of QuantumVariables, which applies the phase dictated by the
+        hamiltonian to the corresponding states.
+
     Examples
     --------
-    
-        
-    In this example we will demonstrate how a phase function with multiple arguments can be synthesized.
-    For this we will create a phase function which encodes the fourier transform of different integers on the QuantumFloat x
-    conditioned on the value of a QuantumChar ch.
-    We will then apply the inverse Fourier transform to x and measure the results.
+
+
+    In this example we will demonstrate how a phase function with multiple arguments can
+    be synthesized. For this we will create a phase function which encodes the fourier
+    transform of different integers on the QuantumFloat x conditioned on the value of a
+    QuantumChar ch. We will then apply the inverse Fourier transform to x and measure
+    the results.
     ::
-        
+
         import numpy as np
         from qrisp import QuantumChar, QuantumFloat, QFT, h
         #Create Variables
         x_size = 3
         x = QuantumFloat(x_size, 0, signed = False)
-        
+
         ch = QuantumChar()
-        
-        #Bring x into uniform superposition so the phase function application yields 
-        #a fourier transformed computation basis state
+
+        # Bring x into uniform superposition so the phase function application yields
+        # a fourier transformed computation basis state
         h(x)
-        
-        
+
+
         #Bring ch into partial superposition (here |a> + |b> + |c> + |d>)
         h(ch[0])
         h(ch[1])
-        
+
         from qrisp import multi_measurement, as_hamiltonian
-        
+
         #In order to define the hamiltonian, we use regular Python syntax
         #The decorator "as_hamiltonian" turns it into a function 
         #that takes Quantum Variables as arguments. The decorator will add the 
         #keyword argument t to the function which mimics the t in exp(i*H*t)
-        
-        
+
+
         @as_hamiltonian
         def apply_multi_var_hamiltonian(ch, x):
             if ch == "a":
                 k = 2
             elif ch == "b":
                 k = 7
             elif ch == "c":
                 k = 3
             else:
                 k = 4
-            
+
             #Return phase value
             #This is the phase distribution of the Fourier-transform
             #of the computational basis state |k>
             return k*x * 2*np.pi/2**x_size
-        
-        
+
+
         #Apply Hamiltonian
         apply_multi_var_hamiltonian(ch,x, t = 1)
-        
-        
+
+
         #Apply inverse Fourier transform
         QFT(x, inv = True)
-        
-        
+
+
     Acquire measurement results
-    
+
     >>> multi_measurement([ch, x])
     {('a', 2): 0.25, ('b', 7): 0.25, ('c', 3): 0.25, ('d', 4): 0.25}
-    
-    We see that the measurement results correspond to what we specified in the Hamiltonian.
-    
+
+    We see that the measurement results correspond to what we specified in the
+    Hamiltonian.
+
     In Bra-Ket notation, before applying the Hamiltonian, we are in the state
-    
+
     .. math::
-        
-        \ket{\psi} = \frac{1}{\sqrt{4}}(\ket{a} + \ket{b} + \ket{c} + \ket{d}) \left( \frac{1}{\sqrt{8}} \sum_{x = 0}^8 \ket{x} \right)
-    
+
+        \ket{\psi} = \frac{1}{\sqrt{4}}(\ket{a} + \ket{b} + \ket{c} + \ket{d})
+        \left( \frac{1}{\sqrt{8}} \sum_{x = 0}^8 \ket{x} \right)
+
     We then apply the Hamiltonian:
-    
+
     .. math::
-        
-        \text{exp}(i\text{H(ch, x)})\ket{\psi} = \frac{1}{\sqrt{32}} ( &\ket{a} \sum_{x = 0}^{2^3-1} \text{exp}(2x \frac{2 \pi i}{2^3}) \ket{x} \\
-                                                                     +&\ket{b} \sum_{x = 0}^{2^3-1} \text{exp}(7x \frac{2 \pi i}{2^3}) \ket{x} \\
-                                                                    +&\ket{c} \sum_{x = 0}^{2^3-1} \text{exp}(3x \frac{2 \pi i}{2^3}) \ket{x} \\
-                                                                    +&\ket{d} \sum_{x = 0}^{2^3-1} \text{exp}(4x \frac{2 \pi i}{2^3}) \ket{x})
-    
-    For each branch, the QuantumFloat tensor-factor is in a Fourier-transformed computational basis state. Thus, if we apply the inverse QFT, we receive:
-        
+
+        \text{exp}(i\text{H(ch, x)})\ket{\psi} = \frac{1}{\sqrt{32}}
+        ( &\ket{a} \sum_{x = 0}^{2^3-1} \text{exp}(2x \frac{2 \pi i}{2^3}) \ket{x} \\
+        +&\ket{b} \sum_{x = 0}^{2^3-1} \text{exp}(7x \frac{2 \pi i}{2^3}) \ket{x} \\
+        +&\ket{c} \sum_{x = 0}^{2^3-1} \text{exp}(3x \frac{2 \pi i}{2^3}) \ket{x} \\
+        +&\ket{d} \sum_{x = 0}^{2^3-1} \text{exp}(4x \frac{2 \pi i}{2^3}) \ket{x})
+
+    For each branch, the QuantumFloat tensor-factor is in a Fourier-transformed
+    computational basis state. Thus, if we apply the inverse QFT, we receive:
+
     .. math::
-        
+
         &\text{QFT}^{-1}\text{exp}(i\text{H(ch, x)})\ket{\psi} \\
-            = & \frac{1}{\sqrt{4}} (\ket{a} \ket{2} + \ket{b} \ket{7} +\ket{c} \ket{3} + \ket{d} \ket{4})
-                                                                    
+            = & \frac{1}{\sqrt{4}} (\ket{a} \ket{2} + \ket{b} \ket{7} +\ket{c} \ket{3}
+            + \ket{d} \ket{4})
+
     """
-    
-    
-    def hamiltonian_application(*args, t = 1, **kwargs):
-        gate_wrap(app_phase_function)(args, hamiltonian, t = t, **kwargs)
+
+    def hamiltonian_application(*args, t=1, **kwargs):
+        gate_wrap(app_phase_function)(args, hamiltonian, t=t, **kwargs)
         # app_phase_function(args, hamiltonian, t = t, **kwargs)
-    
+
     return hamiltonian_application
 
-def perm_lock(qubits, message = ""):
+
+def perm_lock(qubits, message=""):
     """
-    Locks a list of qubits such that only permeable gates can be executed on these qubits. This means that an error will be raised if the user attempts to perform any operation involving these qubits if the operation does not commute with the Z-operator of this qubit. For more information, what a permeable gate is, check the  :ref:`uncomputation documentation <uncomputation>`. 
-    
-    This can be helpfull as it forbids all operations that change that computational basis state of this qubit but still allow controling on this qubit or applying phase gates.
+    Locks a list of qubits such that only permeable gates can be executed on these
+    qubits. This means that an error will be raised if the user attempts to perform any
+    operation involving these qubits if the operation does not commute with the
+    Z-operator of this qubit. For more information, what a permeable gate is, check the
+    :ref:`uncomputation documentation <uncomputation>`.
+
+    This can be helpfull as it forbids all operations that change that computational
+    basis state of this qubit but still allow controling on this qubit or applying
+    phase gates.
 
     Using the keywoard message it is possible to extend the displayed error message.
 
     The effect of this function can be reversed using perm_unlock.
 
     Parameters
     ----------
     qubits : list[Qubit] or QuantumVariable
         The qubits to phase-tolerantly lock.
     message : str, optional
         The message why these qubits are locked.
 
     Examples
     --------
-    
-    We create a QuantumChar, perm-lock it's Qubits and attempt to initialize. 
-    
+
+    We create a QuantumChar, perm-lock it's Qubits and attempt to initialize.
+
     >>> from qrisp import QuantumChar, perm_lock, cx, p
     >>> q_ch_0 = QuantumChar()
     >>> perm_lock(q_ch_0)
     >>> q_ch_0[:] = "g"
     Exception: Tried to perform non-permeable operations on perm_locked qubits
-    
+
     We now create a second QuantumChar and perform a CNOT gate
-    
+
     >>> q_ch_1 = QuantumChar()
     >>> cx(q_ch_0[3], q_ch_1[2])
-    
+
     Phase-gates are possible, too
-    
+
     >>> p(0.1, q_ch_0)
-    
+
     """
     from qrisp.circuit.quantum_circuit import convert_to_qb_list
-    
+
     for qb in convert_to_qb_list(qubits):
         if isinstance(qb, list):
             for item in qb:
                 perm_lock(item)
-                
+
             continue
         qb.perm_lock = True
         qb.perm_lock_message = message
-        
+
+
 def perm_unlock(qubits):
     """
     Reverses the effect of "perm_lock".
 
     Parameters
     ----------
     qubits : list[Qubit] or QuantumVariable
         The qubits to phase-tolerantly unlock.
 
     Examples
     --------
-    
-    We create a QuantumChar, perm-lock it's Qubits and attempt to initialize. 
-    
+
+    We create a QuantumChar, perm-lock it's Qubits and attempt to initialize.
+
     >>> from qrisp import QuantumChar, perm_lock, perm_unlock
     >>> q_ch = QuantumChar()
     >>> perm_lock(q_ch, message = "Qubits are perm-locked due to testing purposes")
     >>> q_ch[:] = "g"
     Exception: Qubits are perm-locked due to testing purposes
-    
+
     >>> perm_unlock(q_ch)
     >>> q_ch[:] = "g"
     >>> print(q_ch)
     {'g': 1.0}
-    
+
     """
     from qrisp.circuit.quantum_circuit import convert_to_qb_list
-    
+
     for qb in convert_to_qb_list(qubits):
         if isinstance(qb, list):
             for item in qb:
                 perm_unlock(item)
             continue
         qb.perm_lock = False
         if hasattr(qb, "perm_lock_message"):
             del qb.perm_lock_message
-        
-def lock(qubits, message = ""):
+
+
+def lock(qubits, message=""):
     """
-    Locks a list of qubits, implying an error will be raised if the user tries to perform any operation involving these qubits. 
+    Locks a list of qubits, implying an error will be raised if the user tries to
+    perform any operation involving these qubits.
     Using the keywoard message it is possible to extend the displayed error message.
-    
+
     This can be reversed by calling unlock.
 
     Parameters
     ----------
     qubits : list[Qubit] or QuantumVariable
         The list of Qubits to lock.
     message : str, optional
         The message why these qubits are locked.
 
     Examples
     --------
-    
+
     We create a QuantumChar, lock it's Qubits and attempt to initialize.
-    
+
     >>> from qrisp import QuantumChar, lock
     >>> q_ch = QuantumChar()
     >>> lock(q_ch, message = "Qubits are locked due to testing purposes")
     >>> q_ch[:] = "g"
     Exception: Qubits are locked due to testing purposes
-    
+
     """
     from qrisp.circuit.quantum_circuit import convert_to_qb_list
-    
+
     for qb in convert_to_qb_list(qubits):
         if isinstance(qb, list):
             for item in qb:
                 lock(item)
             continue
-        
+
         qb.lock = True
         qb.lock_message = message
-        
+
+
 def unlock(qubits):
     """
     Reverses the effect of "lock".
 
     Parameters
     ----------
     qubits : list[Qubit] or QuantumVariable
         The list of Qubits to lock.
-    
+
     Examples
     --------
-    
+
     We create a QuantumChar, lock it's Qubits and attempt to initialize.
-    
+
     >>> from qrisp import QuantumChar, lock, unlock
     >>> q_ch = QuantumChar()
     >>> lock(q_ch)
     >>> q_ch[:] = "g"
     Exception: Tried to perform operations on locked qubits
-    
-    We now unlock and try again 
-    
+
+    We now unlock and try again
+
     >>> unlock(q_ch)
     >>> q_ch[:] = "g"
     >>> print(q_ch)
     {'g': 1.0}
 
     """
     from qrisp.circuit.quantum_circuit import convert_to_qb_list
-    
+
     for qb in convert_to_qb_list(qubits):
         if isinstance(qb, list):
             for item in qb:
                 unlock(item)
             continue
         qb.lock = False
         if hasattr(qb, "lock_message"):
             del qb.lock_message
-    
-        
+
 
 def benchmark_function(function):
-    
-    def benchmarked_function(*args, sort_stats = "tottime", stat_amount = 20, **kwargs):
-        
+    def benchmarked_function(*args, sort_stats="tottime", stat_amount=20, **kwargs):
         def slow_function():
             function(*args, **kwargs)
-    
+
         import cProfile
         import pstats
+
         profile = cProfile.Profile()
-    
+
         profile.runcall(slow_function)
-    
+
         ps = pstats.Stats(profile)
         ps.strip_dirs()
-        ps.sort_stats(sort_stats) 
+        ps.sort_stats(sort_stats)
         ps.print_stats(stat_amount)
-    
+
     return benchmarked_function
 
 
-def custom_qv(labels, decoder = None, qs = None, name = None):
-    
+def custom_qv(labels, decoder=None, qs=None, name=None):
     if not isinstance(labels, list):
-        raise Exception("Tried to create custom QuantumVariable without providing a list type")
-    
+        raise Exception(
+            "Tried to create custom QuantumVariable without providing a list type"
+        )
+
     if len(labels) == 0:
-        raise Exception("Tried to create custom QuantumVariable without providing labels")
+        raise Exception(
+            "Tried to create custom QuantumVariable without providing labels"
+        )
     elif len(labels) == 1:
         n = 1
     else:
         n = int(np.ceil(np.log2(len(labels))))
-    
+
     from qrisp import QuantumVariable
-    
+
     class CustomQuantumVariable(QuantumVariable):
-        
-        def __init__(self, qs = None, name = None):
-            
-            super().__init__(n, qs = qs, name = name)
-        
+        def __init__(self, qs=None, name=None):
+            super().__init__(n, qs=qs, name=name)
+
         def decoder(self, x):
-            
-            
-            
-            if decoder == None:
+            if decoder is None:
                 if x < len(labels):
                     return labels[x]
                 else:
                     return "undefined_label_" + str(x)
-                
+
             return decoder(x)
-        
-    return CustomQuantumVariable(qs = qs, name = name)
+
+    return CustomQuantumVariable(qs=qs, name=name)
 
 
 def init_state(qv, target_array):
-    from qiskit.circuit.library.data_preparation.state_preparation import StatePreparation
-    from qiskit import transpile
-    
+    from qiskit.circuit.library.data_preparation.state_preparation import (
+        StatePreparation,
+    )
+
     qiskit_qc = StatePreparation(target_array).definition
     from qrisp import QuantumCircuit
-    
+
     init_qc = QuantumCircuit.from_qiskit(qiskit_qc)
-    
-    #Find global phase correction
+
+    # Find global phase correction
     from qrisp.simulator import statevector_sim
-    
+
     init_qc.qubits.reverse()
     sim_array = statevector_sim(init_qc)
     init_qc.qubits.reverse()
-    
-    from numpy.linalg import norm
-    
-    
+
     arg_max = np.argmax(np.abs(sim_array))
-    
-    gphase_dif = (np.angle(target_array[arg_max]/sim_array[arg_max]))%(2*np.pi)
-    
+
+    gphase_dif = (np.angle(target_array[arg_max] / sim_array[arg_max])) % (2 * np.pi)
+
     init_qc.gphase(gphase_dif, 0)
-    
+
     init_gate = init_qc.to_gate()
-    
+
     init_gate.name = "state_init"
-    
+
     qv.qs.append(init_gate, qv)
-    
-    
 
-def get_statevector_function(qs, decimals = None):
+
+def get_statevector_function(qs, decimals=None):
     if len(qs.qv_list) == 0:
-        return lambda x : 0
+        return lambda x: 0
     else:
-        
         from qrisp.simulator import statevector_sim
-        
-        
+
         compiled_qc = qs.compile()
         sv_array = statevector_sim(compiled_qc)
-        
-        if not decimals is None:
+
+        if decimals is not None:
             sv_array = np.round(sv_array, decimals)
-            
-        def statevector(label_constellation, round = None):
-            
-            
+
+        def statevector(label_constellation, round=None):
             from qrisp import bin_rep
-            
+
             qs = list(label_constellation.keys())[0].qs
-            
+
             if len(label_constellation) != len(qs.qv_list):
-                missing_variables = set([qv().name for qv in qs.qv_list]) - set([qv.name for qv in label_constellation.keys()])
-                raise Exception("Tried to invoke statevector debugger without specifying an outcome label for each QuantumVariable registered in QuantumSession. Missing variables are: " + str(missing_variables))
-            
-            bitstring = len(compiled_qc.qubits)*["0"]
-            
+                missing_variables = set([qv().name for qv in qs.qv_list]) - set(
+                    [qv.name for qv in label_constellation.keys()]
+                )
+                raise Exception(
+                    "Tried to invoke statevector debugger without specifying an "
+                    "outcome label for each QuantumVariable registered in "
+                    "QuantumSession. Missing variables are: "
+                    + str(missing_variables)
+                )
+
+            bitstring = len(compiled_qc.qubits) * ["0"]
+
             for qf in label_constellation.keys():
                 label_int = qf.encoder(label_constellation[qf])
                 bin_label_int = bin_rep(label_int, qf.size)[::-1]
-                
+
                 for i in range(qf.size):
                     qubit_pos = compiled_qc.qubits.index(qf[i])
                     bitstring[qubit_pos] = bin_label_int[i]
-            
+
             bitstring = "".join(bitstring)
-            state_index = int(bitstring, base = 2)
-            
-            if round == None:
+            state_index = int(bitstring, base=2)
+
+            if round is None:
                 return sv_array[state_index]
             else:
                 return np.around(sv_array[state_index], round)
-        
+
         return statevector
-    
 
 
 def check_if_fresh(qubits, qs):
     qc = qs.transpile()
-    
+
     reversed_data = qc.data[::-1]
     for qb in qubits:
         for instr in reversed_data:
             if qb in instr.qubits:
                 if instr.op.name == "qb_alloc":
                     break
                 else:
                     return False
-    
+
     return True
 
-    
 
-def get_measurement_from_qc(qc, qubits, backend, shots = 10000):
-    
-    #Add classical registers for the measurement results to be stored in
+def get_measurement_from_qc(qc, qubits, backend, shots=10000):
+    # Add classical registers for the measurement results to be stored in
     cl = []
     for i in range(len(qubits)):
         cl.append(qc.add_clbit())
-    
-    #Add measurement instruction
+
+    # Add measurement instruction
     for i in range(len(qubits)):
         qc.measure(qubits[i], cl[i])
-    
-    #Execute circuit
+
+    # Execute circuit
     counts = backend.run(qc, shots)
-    
-    #Remove other measurements outcomes from counts dic
+
+    # Remove other measurements outcomes from counts dic
     new_counts_dic = {}
     for key in counts.keys():
-        #Remove possible whitespaces
+        # Remove possible whitespaces
         new_key = key.replace(" ", "")
-        #Remove other measurements
-        new_key = new_key[-len(cl):]
-        
-        new_key = int(new_key, base = 2)
+        # Remove other measurements
+        new_key = new_key[-len(cl) :]
+
+        new_key = int(new_key, base=2)
         try:
             new_counts_dic[new_key] += counts[key]
         except KeyError:
             new_counts_dic[new_key] = counts[key]
-    
-    
+
     counts = new_counts_dic
-    #Plot result (if needed)
-    
-    #Normalize counts
+    # Plot result (if needed)
+
+    # Normalize counts
     for key in counts.keys():
-        counts[key] = counts[key]/shots
-    
-    return counts
+        counts[key] = counts[key] / shots
 
+    return counts
 
 
-def find_calling_line(level = 0):
-    stack = traceback.extract_stack(limit = level+3)
-    return str(traceback.format_list(stack)[1].split('\n')[1].strip())  # prints "a = fct1()"
+def find_calling_line(level=0):
+    stack = traceback.extract_stack(limit=level + 3)
+    return str(
+        traceback.format_list(stack)[1].split("\n")[1].strip()
+    )  # prints "a = fct1()"
 
 
 def retarget_instructions(data, source_qubits, target_qubits):
     from qrisp import QuantumEnvironment
-    
+
     for i in range(len(data)):
-        
         instr = data[i]
-        
+
         if isinstance(instr, QuantumEnvironment):
             retarget_instructions(instr.original_data, source_qubits, target_qubits)
             retarget_instructions(instr.env_data, source_qubits, target_qubits)
             continue
-        
+
         for j in range(len(instr.qubits)):
             if instr.qubits[j] in source_qubits:
                 instr.qubits[j] = target_qubits[source_qubits.index(instr.qubits[j])]
 
 
 def redirect_qfunction(function_to_redirect):
     """
-    Decorator to turn a function returning a QuantumVariable into an in-place function. This can be helpful for manual uncomputation if we have a function returning some QuantumVariable but we want the result to operate on some other variable, which is supposed to be uncomputed.
-    
+    Decorator to turn a function returning a QuantumVariable into an in-place function.
+    This can be helpful for manual uncomputation if we have a function returning some
+    QuantumVariable, but we want the result to operate on some other variable, which is
+    supposed to be uncomputed.
+
     Parameters
     ----------
     function_to_redirect : function
         A function returning a QuantumVariable.
 
     Raises
     ------
@@ -1187,256 +1237,290 @@
         Given function did not return a QuantumVariable
     Exception
         Tried to redirect quantum function into QuantumVariable of differing size
 
     Returns
     -------
     redirected_function : function
-        A function which performs the same operation as the input but now has the keyword argument target. Every instruction that would have been executed on the input functions result is executed on the QuantumVariable specified by target instead.
-        
-    
+        A function which performs the same operation as the input but now has the
+        keyword argument target. Every instruction that would have been executed on the
+        input functions result is executed on the QuantumVariable specified by target
+        instead.
+
+
     Examples
     --------
-    
-    We create a function that determins the AND value of it's inputs and redirect it onto another QuantumBool. ::
-        
+
+    We create a function that determins the AND value of its inputs and redirect it
+    onto another QuantumBool. ::
+
         from qrisp import QuantumBool, mcx, redirect_qfunction
-        
-        #This function has only two arguments and returns it's result
+
+        #This function has only two arguments and returns its result
         def AND(a, b):
-            
+
             res = QuantumBool()
-            
+
             mcx([a,b], res)
-            
+
             return res
-        
+
         a = QuantumBool(name = "a")
         b = QuantumBool(name = "b")
         c = QuantumBool(name = "c")
-        
+
         #This function has two arguments and the keyword argument target
         redirected_AND = redirect_qfunction(AND)
-        
+
         redirected_AND(a, b, target = c)
-        
-        
+
+
     >>> print(a.qs)
     QuantumCircuit:
     ---------------
     b.0: ──■──
-           │  
+           │
     a.0: ──■──
          ┌─┴─┐
     c.0: ┤ X ├
          └───┘
     Live QuantumVariables:
     ----------------------
     QuantumBool b
     QuantumBool a
     QuantumBool c
-        
-        
+
+
 
     """
-    from qrisp import QuantumEnvironment, merge, QuantumVariable
-    
-    def redirected_qfunction(*args, target = None, **kwargs):
-        
-        
+    from qrisp import QuantumEnvironment, QuantumVariable
+
+    def redirected_qfunction(*args, target=None, **kwargs):
         env = QuantumEnvironment()
         env.manual_allocation_management = True
-        
+
         with env:
             res = function_to_redirect(*args, **kwargs)
-            
+
             if not isinstance(res, QuantumVariable):
                 raise Exception("Given function did not return a QuantumVariable")
-            
-            
+
             target = list(target)
-            
-            
+
             if len(res) != len(target):
-                raise Exception("Tried to redirect quantum function into QuantumVariable of differing size")
-                
+                raise Exception(
+                    "Tried to redirect quantum function into QuantumVariable of "
+                    "differing size"
+                )
+
             i = 0
             res_is_new = False
             while i < len(env.env_qs.data):
-                
                 instr = env.env_qs.data[i]
                 if isinstance(instr, QuantumEnvironment):
                     pass
                 elif instr.op.name == "qb_alloc" and instr.qubits[0] in list(res):
                     env.env_qs.data.pop(i)
                     res_is_new = True
                     continue
-                
+
                 i += 1
-            
+
             retarget_instructions(env.env_qs.data, list(res), target)
-        
+
         if res_is_new:
-            #Remove all traces of res
+            # Remove all traces of res
             res.delete()
 
             for i in range(res.size):
                 res.qs.qubits.remove(res[i])
                 res.qs.data.pop(-1)
-            
+
             for i in range(len(res.qs.deleted_qv_list)):
                 qv = res.qs.deleted_qv_list[i]
                 if qv.name == res.name:
                     res.qs.deleted_qv_list.pop(i)
                     break
-                
+
         return target
-    
+
     redirected_qfunction.__name__ = function_to_redirect.__name__
-    
+
     return redirected_qfunction
 
 
 def get_sympy_state(qs, decimals):
-    
+    from sympy import (
+        I,
+        Rational,
+        Symbol,
+        cancel,
+        cos,
+        count_ops,
+        exp,
+        factor,
+        nsimplify,
+        pi,
+        simplify,
+        sin,
+    )
     from sympy.physics.quantum import Ket, OrthogonalKet
-    from sympy import nsimplify, simplify, pi, count_ops, exp, I, cancel, factor, simplify, cos, Rational, Symbol, sin
 
     from qrisp.simulator import statevector_sim
-    
+
     qv_list = list(qs.qv_list)
-    
+
     labels = []
     for qv in qv_list:
         labels.append([qv.decoder(i) for i in range(2**qv.size)])
-        
+
     compiled_qc = qs.compile()
-    
+
     sv_array = statevector_sim(compiled_qc)
-    
+
     if not sv_array.dtype == np.dtype("O"):
-        angles = np.angle(sv_array)%(2*np.pi)/(np.pi)
-        
-        if not decimals is None:
+        angles = np.angle(sv_array) % (2 * np.pi) / (np.pi)
+
+        if decimals is not None:
             sv_array = np.round(sv_array, decimals)
             angles = np.round(angles, decimals)
-    
+
         nz_indices = np.nonzero(sv_array)[0]
         nnz = len(nz_indices)
-    
+
     else:
         import sympy as sp
-        
+
         nz_indices = []
-        
+
         for i in range(len(sv_array)):
-            
             entry = simplify(sv_array[i])
-            
+
             for a in sp.preorder_traversal(entry):
                 if isinstance(a, sp.Float):
                     entry = entry.subs(a, round(a, decimals))
-            
+
             sv_array[i] = entry
-            
+
             if not sv_array[i] == 0:
                 nz_indices.append(i)
-            
+
         nnz = len(nz_indices)
-    
+
     res = 0
     for ind in list(nz_indices):
         amplitude = sv_array[ind]
-        
+
         if not sv_array.dtype == np.dtype("O"):
-            
             abs_amp = trigify_amp(amplitude, decimals, nnz)
-            
-            #For some reason there is a sympy error, when the angle is equal to 1        
+
+            # For some reason there is a sympy error, when the angle is equal to 1
             if angles[ind] == 1:
                 phase = 1
             else:
-                phase = nsimplify(angles[ind], tolerance = 10**(decimals-1))
-            
+                phase = nsimplify(angles[ind], tolerance=10 ** (decimals - 1))
+
             if count_ops(phase) > 5:
                 phase = angles[ind]
-            
-            ket_expr = exp(I*phase*pi)*abs_amp*nnz**0.5
-            
+
+            ket_expr = exp(I * phase * pi) * abs_amp * nnz**0.5
+
         else:
-            
             process_stack = [amplitude]
             while process_stack:
-                
                 a = process_stack.pop(0)
-                if isinstance(a, (sympy.core.add.Add, sympy.core.mul.Mul)) and len(a.free_symbols) != 0:
+                if (
+                    isinstance(a, (sympy.core.add.Add, sympy.core.mul.Mul))
+                    and len(a.free_symbols) != 0
+                ):
                     process_stack.extend(a.args)
-                
+
                 elif len(a.free_symbols) == 0:
-                    
                     sub_float = np.round(complex(a.evalf()), decimals)
-                    
+
                     if np.abs(sub_float - 1) < 10**-decimals:
                         abs_amp = 1
                         continue
                     elif np.abs(sub_float) < 10**-decimals:
                         entry = entry.subs(a, 0)
                         continue
                     elif np.abs(sub_float) > 1:
                         continue
                     else:
                         abs_amp = trigify_amp(sub_float, decimals, nnz)
-                    
-                    if np.angle(complex(a.evalf()))/np.pi == 1:
+
+                    if np.angle(complex(a.evalf())) / np.pi == 1:
                         phase = -1
                     else:
-                        phase = sp.exp(sp.I*nsimplify(np.angle(complex(a.evalf()))/np.pi, tolerance = 10**(decimals-1))*Symbol("pi"))
-                    
-                    
-                    expr = abs_amp*phase
-                    
+                        phase = sp.exp(
+                            sp.I
+                            * nsimplify(
+                                np.angle(complex(a.evalf())) / np.pi,
+                                tolerance=10 ** (decimals - 1),
+                            )
+                            * Symbol("pi")
+                        )
+
+                    expr = abs_amp * phase
+
                     amplitude = amplitude.subs(a, expr)
-            
+
             amplitude = amplitude.subs(1j, sp.I)
-            
-            ket_expr = sp.trigsimp(amplitude)*nnz**0.5
 
-            
+            ket_expr = sp.trigsimp(amplitude) * nnz**0.5
+
         int_string = bin_rep(ind, len(compiled_qc.qubits))
-        
+
         labels = []
         for qv in qv_list:
             bit_string = ""
             for qb in qv.reg:
                 bit_string += int_string[compiled_qc.qubits.index(qb)]
-            
+
             label = qv.decoder(int(bit_string[::-1], 2))
             ket_expr *= OrthogonalKet(str(label))
-            
+
         res += ket_expr
 
+    res = cancel(nsimplify(1 / nnz**0.5) * res)
 
-    res = cancel(nsimplify(1/nnz**0.5) * res)
-    
     if isinstance(res, sympy.core.mul.Mul):
         temp = 1
         for arg in res.args[:-1]:
-            temp *= nsimplify(arg.subs({Symbol("pi") : pi}))
-        
+            temp *= nsimplify(arg.subs({Symbol("pi"): pi}))
+
         res = temp * res.args[-1]
-    
-    res = res.subs({Symbol("pi") : pi})
+
+    res = res.subs({Symbol("pi"): pi})
     return res
-            
+
 
 def trigify_amp(amplitude, decimals, nnz):
-    from sympy import nsimplify, simplify, pi, count_ops, exp, I, cancel, factor, simplify, cos, Rational, Symbol, sin, latex
-    
-    cos_expr = nsimplify(np.arccos(np.abs(amplitude))/np.pi, tolerance = 10**-(decimals-1))
-    sin_expr = nsimplify(np.arcsin(np.abs(amplitude))/np.pi, tolerance = 10**-(decimals-1))
+    from sympy import (
+        I,
+        Rational,
+        Symbol,
+        cancel,
+        cos,
+        count_ops,
+        exp,
+        factor,
+        latex,
+        nsimplify,
+        pi,
+        simplify,
+        sin,
+    )
+
+    cos_expr = nsimplify(
+        np.arccos(np.abs(amplitude)) / np.pi, tolerance=10 ** -(decimals - 1)
+    )
+    sin_expr = nsimplify(
+        np.arcsin(np.abs(amplitude)) / np.pi, tolerance=10 ** -(decimals - 1)
+    )
 
     # if count_ops(sin_expr) > count_ops(cos_expr):
     if len(latex(sin_expr)) > len(latex(cos_expr)):
         expr = "cos"
         temp = cos_expr
     # elif count_ops(sin_expr) < count_ops(cos_expr):
     elif len(latex(sin_expr)) < len(latex(cos_expr)):
@@ -1446,139 +1530,168 @@
         if sin_expr.evalf() > cos_expr.evalf():
             expr = "cos"
             temp = cos_expr
         else:
             expr = "sin"
             temp = sin_expr
     else:
-        temp = nsimplify(np.abs(amplitude)*nnz**0.5, tolerance = 10**-(decimals-1))/nnz**0.5
-    
+        temp = (
+            nsimplify(np.abs(amplitude) * nnz**0.5, tolerance=10 ** -(decimals - 1))
+            / nnz**0.5
+        )
+
     # if count_ops(temp) > 4:
     if len(latex(temp)) > 20:
-        temp = nsimplify(np.abs(amplitude)*nnz**0.5, tolerance = 10**-(decimals-1))/nnz**0.5
+        temp = (
+            nsimplify(np.abs(amplitude) * nnz**0.5, tolerance=10 ** -(decimals - 1))
+            / nnz**0.5
+        )
         if len(latex(temp)) > 20:
             abs = np.abs(amplitude)
-            
+
         else:
             abs = temp
-    
+
     else:
         if expr == "cos":
-            abs = cos(cos_expr*Symbol("pi"))
+            abs = cos(cos_expr * Symbol("pi"))
         else:
-            abs = sin(sin_expr*Symbol("pi"))
-    
+            abs = sin(sin_expr * Symbol("pi"))
+
     return abs
 
 
 def render_qc(qc):
     latex_str = qc.to_latex()
-    import tempfile
     import os.path
     import subprocess
+    import tempfile
+
     from IPython.display import Image, display
-    
+
     with tempfile.TemporaryDirectory(prefix="texinpy_") as tmpdir:
         path = os.path.join(tmpdir, "document.tex")
-        with open(path, 'w') as fp:
+        with open(path, "w") as fp:
             fp.write(latex_str)
         subprocess.run(["lualatex", path], cwd=tmpdir)
-        subprocess.run(["pdftocairo", "-singlefile", "-transp", "-r", "100", "-png", "document.pdf", "document"], cwd=tmpdir)
+        subprocess.run(
+            [
+                "pdftocairo",
+                "-singlefile",
+                "-transp",
+                "-r",
+                "100",
+                "-png",
+                "document.pdf",
+                "document",
+            ],
+            cwd=tmpdir,
+        )
 
         im = Image(filename=os.path.join(tmpdir, "document.png"))
         display(im)
 
-def lifted(*args, verify = False):
+
+def lifted(*args, verify=False):
     """
     Shorthand for ``gate_wrap(permability = "args", is_qfree = True)``.
-    
-    A lifted function is ``qfree`` and permeable on it's inputs. The results of lifted functions can be automatically uncomputed even if they contain functions that could not be uncomputed on their own.
-    
-    You can find more information about these concepts :ref:`here <Uncomputation>` or `here <https://silq.ethz.ch/overview#/overview/3_uncomputation>`_. Note that the concept of permeability in Qrisp is a more general version of Silq's ``const``.
-    
+
+    A lifted function is ``qfree`` and permeable on its inputs. The results of lifted
+    functions can be automatically uncomputed even if they contain functions that could
+    not be uncomputed on their own.
+
+    You can find more information about these concepts :ref:`here <Uncomputation>` or
+    `here <https://silq.ethz.ch/overview#/overview/3_uncomputation>`_. Note that the
+    concept of permeability in Qrisp is a more general version of Silq's ``const``.
+
     .. warning::
-        
-        Incorrect information about permeability and ``qfree``-ness can yield incorrect compilation results. If you are unsure, use the ``verify`` keyword on a small scale first.
+
+        Incorrect information about permeability and ``qfree``-ness can yield incorrect
+        compilation results. If you are unsure, use the ``verify`` keyword on a small
+        scale first.
 
 
     Parameters
     ----------
-    
+
     verify : bool, optional
-        If set to ``True``, the specified information about permeability and ``qfree``-ness will be checked numerically. The default is ``False``.
+        If set to ``True``, the specified information about permeability and
+        ``qfree``-ness will be checked numerically. The default is ``False``.
 
     Examples
     --------
-    
-    We create a function performing the `Margolus gate <https://arxiv.org/abs/quant-ph/0312225>`_. As it contains ``ry`` rotations, there are non-``qfree`` steps involved.
-    Putting on the ``lifted`` decorator however marks the function as ``qfree`` as a whole.
-    
+
+    We create a function performing the `Margolus gate
+    <https://arxiv.org/abs/quant-ph/0312225>`_. As it contains ``ry`` rotations,
+    there are non-``qfree`` steps involved. Putting on the ``lifted`` decorator however
+    marks the function as ``qfree`` as a whole.
+
     ::
-        
+
         from qrisp import QuantumVariable, cx, ry, lifted
         from numpy import pi
-        
+
         @lifted(verify = True)
         def margolus(control):
-            
+
             res = QuantumVariable(1)
             ry(pi/4, res)
             cx(control[1], res)
             ry(-pi/4, res)
             cx(control[0], res)
             ry(pi/4, res)
             cx(control[1], res)
             ry(-pi/4, res)
-            
+
             return res
-        
-        
+
+
         control = QuantumVariable(2)
         res = margolus(control)
-        
+
     >>> print(res.qs)
     QuantumCircuit:
     ---------------
                ┌───────────┐
     control.0: ┤0          ├
                │           │
     control.1: ┤1 margolus ├
                │           │
         res.0: ┤2          ├
                └───────────┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable control
     QuantumVariable res
-    
+
     >>> res.uncompute()
     >>> print(res.qs)
     QuantumCircuit:
     ---------------
                ┌───────────┐┌──────────────┐
     control.0: ┤0          ├┤0             ├
                │           ││              │
     control.1: ┤1 margolus ├┤1 margolus_dg ├
                │           ││              │
         res.0: ┤2          ├┤2             ├
                └───────────┘└──────────────┘
     Live QuantumVariables:
     ----------------------
     QuantumVariable control
-    
-    Note that we set the ``verify`` keyword to ``True`` in this example. In more complex functions, involving many qubits this feature should only be used for bug-fixing on a small scale, since the verification can be time consuming.
+
+    Note that we set the ``verify`` keyword to ``True`` in this example. In more complex
+    functions, involving many qubits this feature should only be used for bug-fixing on
+    a small scale, since the verification can be time-consuming.
 
     """
-    
+
     if len(args) == 0:
-        
+
         def lifted_helper(function):
-            
-            return gate_wrap(permeability = "args", is_qfree = True, verify = verify)(function)
-        
+            return gate_wrap(permeability="args", is_qfree=True, verify=verify)(
+                function
+            )
+
         return lifted_helper
-    
+
     else:
-        return gate_wrap(permeability = "args", is_qfree = True)(args[0])
-        
-            
-    
+        return gate_wrap(permeability="args", is_qfree=True)(args[0])
```

### Comparing `qrisp-0.0.15/src/qrisp/qtypes/quantum_bool.py` & `qrisp-0.0.16/src/qrisp/qtypes/quantum_bool.py`

 * *Files 26% similar despite different names*

```diff
@@ -7,178 +7,181 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
+import sys
+
 from qrisp.core.quantum_variable import QuantumVariable
 from qrisp.environments import control
-import sys
+
+
 class QuantumBool(QuantumVariable):
     """
     QuantumBools are the quantum type, which represents boolean truth values.
     They are the return type of comparison operators like the equality ``==``.
-    
-    Apart from their behavior as a QuantumVariable, they can also be treated like :ref:`ControlEnvironments <ControlEnvironment>`.
-    
+
+    Apart from their behavior as a QuantumVariable, they can also be treated like
+    :ref:`ControlEnvironments <ControlEnvironment>`.
+
     .. note:
-        QuantumBools that are evaluated directly after a ``with`` statement are uncomputed automatically upon leaving the ControlEnvironment.
-        
+        QuantumBools that are evaluated directly after a ``with`` statement are
+        uncomputed automatically upon leaving the ControlEnvironment.
+
     Examples
     --------
-    
+
     We create a QuantumBool and set it to uniform superposition
-    
+
     >>> from qrisp import QuantumBool, h
     >>> q_bool_0 = QuantumBool()
     >>> h(q_bool_0)
     >>> print(q_bool_0)
     {False: 0.5, True: 0.5}
-    
+
     We create a second QuantumBool and evaluate some logical functions
-    
+
     >>> q_bool_1 = QuantumBool()
     >>> print(q_bool_1 | q_bool_0)
     {False: 0.5, True: 0.5}
     >>> print(q_bool_1 & q_bool_0)
     {False: 1.0}
-    
+
     QuantumBools are the results of comparisons:
-    
+
     >>> from qrisp import QuantumFloat, QuantumChar
     >>> q_ch = QuantumChar()
     >>> q_ch[:] = {"g" : 1, "l" : -1}
     >>> q_bool_2 = (q_ch == "g")
     >>> q_bool_2.qs.statevector()
-    sqrt(2)*(|g>*|True> - |l>*|False>)/2    
-    
+    sqrt(2)*(|g>*|True> - |l>*|False>)/2
+
     For :ref:`QuantumFloats <QuantumFloat>`, numeric comparison is also possible:
-    
-    
+
+
     >>> qf = QuantumFloat(4)
     >>> h(qf[3])
     >>> print(qf)
     {0: 0.5, 8: 0.5}
     >>> q_bool_3 = (qf >=  4)
     >>> print(q_bool_3)
     {False: 0.5, True: 0.5}
-    
-    To use a QuantumBool as a :ref:`ControlEnvironment`, we simply put it in a ``with`` statement:
-        
+
+    To use a QuantumBool as a :ref:`ControlEnvironment`, we simply put it in a ``with``
+    statement:
+
     ::
-        
+
         with q_bool_3:
             qf += 2
-    
+
     >>> print(qf)
     {0: 0.5, 10: 0.5}
-    
-    QuantumBools that are created directly after a ``with`` statement are uncomputed automatically:
-    
+
+    QuantumBools that are created directly after a ``with`` statement are uncomputed
+    automatically:
+
     ::
-        
+
         with qf == 10:
             q_bool_3.flip()
-            
+
     >>> print(qf.qs)
     QuantumCircuit:
     ---------------
-                       ┌────────────┐     ┌───────────┐               
+                       ┌────────────┐     ┌───────────┐
             qf.0: ─────┤0           ├─────┤0          ├──o─────────o──
-                       │            │     │           │  │         │  
+                       │            │     │           │  │         │
             qf.1: ─────┤1           ├─────┤1          ├──■─────────■──
-                       │            │     │  __iadd__ │  │         │  
+                       │            │     │  __iadd__ │  │         │
             qf.2: ─────┤2           ├─────┤2          ├──o─────────o──
-                  ┌───┐│  less_than │     │           │  │         │  
+                  ┌───┐│  less_than │     │           │  │         │
             qf.3: ┤ H ├┤3           ├─────┤3          ├──■─────────■──
-                  └───┘│            │┌───┐└─────┬─────┘  │  ┌───┐  │  
+                  └───┘│            │┌───┐└─────┬─────┘  │  ┌───┐  │
         lt_qbl.0: ─────┤4           ├┤ X ├──────■────────┼──┤ X ├──┼──
-                       │            │└───┘               │  └─┬─┘  │  
+                       │            │└───┘               │  └─┬─┘  │
     lt_ancilla.0: ─────┤5           ├────────────────────┼────┼────┼──
                        └────────────┘                  ┌─┴─┐  │  ┌─┴─┐
       cond_env.0: ─────────────────────────────────────┤ X ├──■──┤ X ├
                                                        └───┘     └───┘
     Live QuantumVariables:
     ----------------------
     QuantumFloat qf
     QuantumBool lt_qbl
-        
-    Note that there is only a single QuantumBool listed in the "Live QuantumVariables" section, 
-    because the QuantumBool of the comparison ``qf == 10`` (called ``cond_env``) has been uncomputed.
+
+    Note that there is only a single QuantumBool listed in the "Live QuantumVariables"
+    section, because the QuantumBool of the comparison
+    ``qf == 10`` (called ``cond_env``) has been uncomputed.
 
     """
-    
 
-    def __init__(self, qs = None, name = None):
+    def __init__(self, qs=None, name=None):
+        QuantumVariable.__init__(self, 1, qs=qs, name=name)
 
-        QuantumVariable.__init__(self, 1, qs = qs, name = name)
-        
         self.qfloat_comparison = False
-        
+
     def decoder(self, integer):
         return bool(integer)
-    
+
     def __and__(self, other):
         from qrisp import mcx
-        
+
         and_qbl = QuantumBool()
-        
+
         mcx(self.reg + other.reg, and_qbl.reg)
-        
+
         return and_qbl
 
     def __or__(self, other):
         from qrisp import mcx, x
-        
+
         or_qbl = QuantumBool()
 
         x(self)
         x(other)
-        
+
         mcx(self.reg + other.reg, or_qbl.reg)
-        
+
         x(self)
         x(other)
-        
+
         x(or_qbl)
-        
+
         return or_qbl
-    
+
     def __xor__(self, other):
-        
         from qrisp import cx
-        
+
         xor_qbl = QuantumBool()
-        
+
         cx(self, xor_qbl)
         cx(other, xor_qbl)
-        
+
         return xor_qbl
-    
+
     def flip(self):
         """
         Flips the QuantumBool's value.
 
         """
-        
+
         from qrisp import x
-        
+
         x(self)
         return self
-    
+
     def __enter__(self):
-        
         self.env = control(self)
         self.env.__enter__()
 
     def __exit__(self, a, b, c):
-        
         ref_count = sys.getrefcount(self)
-        
-        #If the refcount is 5, this means that the QuantumBool has been
-        #created in a "with" statement and can therefore no longer be reached
-        #after exiting. We therefore uncompute
-        
+
+        # If the refcount is 5, this means that the QuantumBool has been
+        # created in a "with" statement and can therefore no longer be reached
+        # after exiting. We therefore uncompute
+
         self.env.__exit__(a, b, c)
         if ref_count == 5:
             self.uncompute()
```

### Comparing `qrisp-0.0.15/src/qrisp/qtypes/quantum_char.py` & `qrisp-0.0.16/src/qrisp/qtypes/quantum_char.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,56 +1,55 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 from qrisp.core import QuantumVariable
 
+
 class QuantumChar(QuantumVariable):
     r"""
-    A QuantumVariable which represents characters. By default, the QuantumChar is initialized in NISQ mode, meaning that instead of 256 characters it can only hold 32, saving almost 40% in qubit cost.
-    
+    A QuantumVariable which represents characters. By default, the QuantumChar is
+    initialized in NISQ mode, meaning that instead of 256 characters it can only hold
+    32, saving almost 40% in qubit cost.
+
     >>> from qrisp import QuantumChar
     >>> q_ch = QuantumChar(nisq_char = True)
 
     The chars which can be represented in ``nisq mode`` are
-    
+
     +---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+
     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
     +---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+
     | a | b | c | d | e | f | g | h | i | j | k  | l  | m  | n  | o  | p  | q  |
     +---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----+----+
-    
+
     +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
     | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 |
     +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
     | r  | s  | t  | u  | v  | w  | x  | y  | z  |    | .  | !  | ?  | :  | ,  |
     +----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-    
+
     If ``nisq_mode`` is set to False, the encoder uses the Python-inbuild chr function.
     """
-    
-    
+
     def decoder(self, i):
-        
         if self.nisq_char:
             return "abcdefghijklmnopqrstuvwxyz .!?:,"[i]
         else:
             return chr(i)
 
-    def __init__(self, qs = None, name = None, nisq_char = True):
+    def __init__(self, qs=None, name=None, nisq_char=True):
         self.nisq_char = nisq_char
 
         if nisq_char:
-            super().__init__(5, qs = qs, name = name)
+            super().__init__(5, qs=qs, name=name)
         else:
-            super().__init__(8, qs = qs, name = name)
-
-            
+            super().__init__(8, qs=qs, name=name)
```

### Comparing `qrisp-0.0.15/src/qrisp/qtypes/quantum_float.py` & `qrisp-0.0.16/src/qrisp/qtypes/quantum_float.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,636 +7,667 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from qrisp.core import QuantumVariable
 import numpy as np
 import sympy as sp
+
+from qrisp.arithmetic import (
+    eq,
+    geq,
+    gt,
+    inpl_mult,
+    leq,
+    lt,
+    neq,
+    polynomial_encoder,
+    q_mult,
+    sbp_add,
+)
+from qrisp.core import QuantumVariable
 from qrisp.misc import gate_wrap
-from qrisp.arithmetic import polynomial_encoder, lt, gt, leq, geq, eq, neq, inpl_mult, sbp_add, q_mult
+
 
 def signed_int_iso(x, n):
-    if int(x) < -2**n or int(x) >= 2**n:
+    if int(x) < -(2**n) or int(x) >= 2**n:
         raise Exception("Applying signed integer isomorphism resulted in overflow")
-    
+
     if x >= 0:
-        return x%2**n
+        return x % 2**n
     else:
-        return -abs(x)%2**(n+1)
+        return -abs(x) % 2 ** (n + 1)
+
 
 def signed_int_iso_inv(y, n):
-    y = y%2**(n+1)
+    y = y % 2 ** (n + 1)
     if y < 2**n:
         return y
     else:
-        return -2**(n+1) + y
+        return -(2 ** (n + 1)) + y
 
 
-#Truncates a polynomial of the form p(x) = 2**k_0*x*i_0 + 2**k_1*x**i_1 ...
-#where every summand where the power of the coefficients does not lie in the interval
-#trunc bounds is removed
+# Truncates a polynomial of the form p(x) = 2**k_0*x*i_0 + 2**k_1*x**i_1 ...
+# where every summand where the power of the coefficients does not lie in the interval
+# trunc bounds is removed
 def trunc_poly(poly, trunc_bounds):
-    
-    #Convert to sympy polynomial
+    # Convert to sympy polynomial
     poly = sp.poly(poly)
 
-    #Clip upper bound
-    poly = poly.trunc(2.**(trunc_bounds[1]))
-    
-    #Clip lower bound
-    poly = poly/2.**trunc_bounds[0]
+    # Clip upper bound
+    poly = poly.trunc(2.0 ** (trunc_bounds[1]))
+
+    # Clip lower bound
+    poly = poly / 2.0 ** trunc_bounds[0]
     poly = poly - sp.poly(poly).trunc(1)
-    poly = poly*2.**trunc_bounds[0]
-    
-    return poly.expr.expand()    
+    poly = poly * 2.0 ** trunc_bounds[0]
 
+    return poly.expr.expand()
 
 
 class QuantumFloat(QuantumVariable):
     r"""
-    This subclass of :ref:`QuantumVariable` can represent floating point numbers (signed and unsigned) up to an arbitrary precision.
-    
-    The technical details of the employed arithmetic can be found in this `article <https://ieeexplore.ieee.org/document/9815035>`_. 
-    
+    This subclass of :ref:`QuantumVariable` can represent floating point numbers
+    (signed and unsigned) up to an arbitrary precision.
+
+    The technical details of the employed arithmetic can be found in this
+    `article <https://ieeexplore.ieee.org/document/9815035>`_.
+
     To create a QuantumFloat we call the constructor:
-    
+
     >>> from qrisp import QuantumFloat
     >>> a = QuantumFloat(3, -1, signed = False)
-    
-    Here, the 3 indicates the amount of mantissa qubits and the -1 indicates the exponent.
-    
+
+    Here, the 3 indicates the amount of mantissa qubits and the -1 indicates the
+    exponent.
+
     For unsigned QuantumFloats, the decoder function is given by
-    
+
     .. math::
-        
+
         f_{k}(i) = i2^{k}
-    
+
     Where $k$ is the exponent.
-    
+
     We can check which values can be represented:
-    
+
     >>> for i in range(2**a.size): print(a.decoder(i))
     0.0
     0.5
     1.0
     1.5
     2.0
     2.5
     3.0
     3.5
-    
-    We see $2^3 = 8$ values, because we have 3 mantissa qubits. The exponent is -1, implying the precision is $0.5 = 2^{-1}$.
-    
+
+    We see $2^3 = 8$ values, because we have 3 mantissa qubits. The exponent is -1,
+    implying the precision is $0.5 = 2^{-1}$.
+
     For signed QuantumFloats, the decoder function is
-    
+
     .. math::
-        
-        f_{k}^{n}(i) = \begin{cases} i2^{k} & \text{if } i < 2^n \\ (i - 2^{n+1})2^k & \text{else} \end{cases}
-    
+
+        f_{k}^{n}(i) = \begin{cases} i2^{k} & \text{if } i < 2^n \\ (i - 2^{n+1})2^k &
+        \text{else} \end{cases}
+
     Where $k$ is again, the exponent and $n$ is the mantissa size.
-    
-    
+
+
     Another example:
-    
+
     >>> b = QuantumFloat(2, -2, signed = True)
     >>> for i in range(2**b.size): print(b.decoder(i))
     0.0
     0.25
     0.5
     0.75
     -1.0
     -0.75
     -0.5
     -0.25
-    
-    Here, we have $2^2 = 4$ values and their signed equivalents. Their precision is $0.25 = 2^{-2}$.
-    
-    
+
+    Here, we have $2^2 = 4$ values and their signed equivalents. Their precision is
+    $0.25 = 2^{-2}$.
+
+
     **Arithmetic**
-    
-    Many operations known from classical arithmetic work for QuantumFloats in infix notation.
-    
+
+    Many operations known from classical arithmetic work for QuantumFloats in infix
+    notation.
+
     Addition:
-    
+
     >>> a[:] = 1.5
     >>> b[:] = 0.25
     >>> c = a + b
     >>> print(c)
     {1.75: 1.0}
-    
+
     Subtraction:
-    
+
     >>> d = a - c
     >>> print(d)
     {-0.25: 1.0}
-    
+
     Multiplication:
-    
+
     >>> e = d * b
     >>> print(e)
     {-0.0625: 1.0}
-    
+
     And even division:
-        
+
     >>> a = QuantumFloat(3)
     >>> b = QuantumFloat(3)
     >>> a[:] = 7
     >>> b[:] = 2
     >>> c = a/b
     >>> print(c)
     {3.5: 1.0}
-    
+
     Floor division:
-        
+
     >>> d = a//b
     >>> print(d)
     {3.0: 1.0}
-    
+
     Inversion:
-    
+
     >>> a = QuantumFloat(3, -1)
     >>> a[:] = 3.5
     >>> b= a**-1
     >>> print(b)
     {0.25: 1.0}
-    
-    Note that the latter is only an approximate result. This is because in many cases, the results of division can not be stored in a finite amount of qubits, forcing us to approximate.
-    To get a better approximation we can use the :meth:`q_div <qrisp.q_div>` and :meth:`qf_inversion <qrisp.qf_inversion>` functions and specify the precision:
-    
+
+    Note that the latter is only an approximate result. This is because in many cases,
+    the results of division can not be stored in a finite amount of qubits, forcing us
+    to approximate.
+    To get a better approximation we can use the :meth:`q_div <qrisp.q_div>` and
+    :meth:`qf_inversion <qrisp.qf_inversion>` functions and specify the precision:
+
     >>> from qrisp import q_div, qf_inversion
     >>> a = QuantumFloat(3)
     >>> a[:] = 1
     >>> b = QuantumFloat(3)
     >>> b[:] = 7
     >>> c = q_div(a, b, prec = 6)
     >>> print(c)
     {0.140625: 1.0}
-    
+
     Comparing with the classical result (0.1428571428):
-    
+
     >>> 1/7 - 0.140625
     0.002232142857142849
-    
+
     We see that the result is inside the expected precision of $2^{-6} =  0.015625$.
-    
-    
+
+
     **In-place Operations**
-    
-    Further supported operations are inplace addition, subtraction (with both classical and quantum values):
-        
+
+    Further supported operations are inplace addition, subtraction (with both classical
+    and quantum values):
+
     >>> a = QuantumFloat(4, signed = True)
     >>> a[:] = 4
     >>> b = QuantumFloat(4)
     >>> b[:] = 3
     >>> a += b
     >>> print(a)
     {7: 1.0}
     >>> a -= 2
     >>> print(a)
     {5: 1.0}
-    
+
     .. warning::
-        Additions that would result in overflow, raise no errors. Instead the additions are performed `modular <https://en.wikipedia.org/wiki/Modular_arithmetic>`_.
-        
+        Additions that would result in overflow, raise no errors. Instead, the additions
+        are performed `modular <https://en.wikipedia.org/wiki/Modular_arithmetic>`_.
+
         >>> c = QuantumFloat(3)
         >>> c += 9
         >>> print(c)
         {1: 1.0}
-    
+
     For inplace multiplications, only classical integers are allowed:
-    
+
     >>> a *= -3
     >>> print(a)
     {-15: 1.0}
-    
+
     .. note::
-        In-place multiplications can change the mantissa size to prevent overflow errors. If you want to prevent this behavior, look into :meth:`inpl_mult <qrisp.inpl_mult>`.
-        
+        In-place multiplications can change the mantissa size to prevent overflow
+        errors. If you want to prevent this behavior, look into
+        :meth:`inpl_mult <qrisp.inpl_mult>`.
+
         >>> a.size
         7
-    
+
     **Bitshifts**
-    
-    Bitshifts can be executed for free (ie. not requiring any quantum gates). We can either use the :meth:`exp_shift <qrisp.QuantumFloat.exp_shift>` method or use the infix operators. Note that the bitshifts work in-place.
-    
-    
+
+    Bitshifts can be executed for free (i.e. not requiring any quantum gates). We can
+    either use the :meth:`exp_shift <qrisp.QuantumFloat.exp_shift>` method or use the
+    infix operators. Note that the bitshifts work in-place.
+
+
     >>> a.exp_shift(3)
     >>> print(a)
     {-120: 1.0}
     >>> a >> 5
     >>> print(a)
     {-3.75: 1.0}
-    
+
     **Comparisons**
-    
-    QuantumFloats can be compared to Python floats using the established operators. The return values are :ref:`QuantumBools <QuantumBool>`:
-        
+
+    QuantumFloats can be compared to Python floats using the established operators. The
+    return values are :ref:`QuantumBools <QuantumBool>`:
+
     >>> from qrisp import h
     >>> a = QuantumFloat(4)
     >>> h(a[2])
     >>> print(a)
     {0: 0.5, 4: 0.5}
     >>> comparison_qbl_0 = (a < 4 )
     >>> print(comparison_qbl_0)
     {False: 0.5, True: 0.5}
 
     Comparison to other QuantumFloats also works:
-        
+
     >>> b = QuantumFloat(3)
     >>> b[:] = 4
     >>> comparison_qbl_1 = (a == b)
     >>> comparison_qbl_1.qs.statevector()
     sqrt(2)*(|0>*|True>*|4>*|False> + |4>*|False>*|4>*|True>)/2
-    
-    The first tensor factor containing a boolean value is corresponding to ``comparison_qbl_0`` and the second one is ``comparison_qbl_1``.
-    
+
+    The first tensor factor containing a boolean value is corresponding to
+    ``comparison_qbl_0`` and the second one is ``comparison_qbl_1``.
+
     """
-    
-    
-    def __init__(self, msize, exponent = 0, qs = None, name = None, signed = False):
-        
-        #Boolean to indicate if the float is signed
+
+    def __init__(self, msize, exponent=0, qs=None, name=None, signed=False):
+        # Boolean to indicate if the float is signed
         self.signed = signed
-        
-        #Exponent
+
+        # Exponent
         self.exponent = exponent
-        
-        #Size of the mantissa
+
+        # Size of the mantissa
         self.msize = msize
-        
-        #Array that consists of (log2(min), log2(max)) where min and max are the minimal and maximal values
-        #of the absolutes that the QuantumFloat can represent
+
+        # Array that consists of (log2(min), log2(max)) where min and max are the
+        # minimal and maximal values of the absolutes that the QuantumFloat can
+        # represent.
         self.mshape = np.array([exponent, exponent + msize])
-        
-        #Initialize QuantumVariable
+
+        # Initialize QuantumVariable
         if signed:
-            super().__init__(msize + 1, qs, name = name)
+            super().__init__(msize + 1, qs, name=name)
         else:
-            super().__init__(msize, qs, name = name)
-            
-        
-    
-        
-        
-    #Define outcome_labels
+            super().__init__(msize, qs, name=name)
+
+    # Define outcome_labels
     def decoder(self, i):
         if self.signed:
-            
-            res = signed_int_iso_inv(i, self.size-1)*2.**self.exponent
+            res = signed_int_iso_inv(i, self.size - 1) * 2.0**self.exponent
         else:
-            res =  i*2**self.exponent
-            
+            res = i * 2**self.exponent
+
         if self.exponent >= 0:
             return int(res)
         else:
             return res
-        
+
     # def encoder(self, i):
     #     if self.signed:
     #         res = int(signed_int_iso(i/2**self.exponent, self.size-1))
     #     else:
     #         res =  int(i/2**self.exponent)
-            
+
     #     return res
-        
-    def sb_poly(self, m = 0):
+
+    def sb_poly(self, m=0):
         """
-        Returns the semi-boolean polynomial of this `QuantumFloat` where `m` specifies the image extension parameter.
-        
-        For the technical details we refer to: https://ieeexplore.ieee.org/document/9815035
-        
+        Returns the semi-boolean polynomial of this `QuantumFloat` where `m` specifies
+        the image extension parameter.
+
+        For the technical details we refer to:
+        https://ieeexplore.ieee.org/document/9815035
+
 
         Parameters
         ----------
         m : int, optional
             Image extension parameter. The default is 0.
 
         Returns
         -------
         Sympy expression
             The semi-boolean polynomial of this QuantumFloat.
-            
+
         Examples
         --------
-        
+
         >>> from qrisp import QuantumFloat
         >>> x = QuantumFloat(3, -1, signed = True, name = "x")
         >>> print(x.sb_poly(5))
         0.5*x_0 + 1.0*x_1 + 2.0*x_2 + 28.0*x_3
-        
+
         """
-        
+
         if m == 0:
             m = self.size
-        
+
         symbols = [sp.symbols(self.name + "_" + str(i)) for i in range(self.size)]
-        
-        poly = sum([2.**(i)*symbols[i] for i in range(self.size)])
-        
-        
+
+        poly = sum([2.0 ** (i) * symbols[i] for i in range(self.size)])
+
         if self.signed:
-                poly += (2.**(m+1) - 2.**(self.size))*symbols[-1]
-        
-        return 2**self.exponent*poly
-    
-    
-    def encode(self, encoding_number, rounding = False):
-        
-        
+            poly += (2.0 ** (m + 1) - 2.0 ** (self.size)) * symbols[-1]
+
+        return 2**self.exponent * poly
+
+    def encode(self, encoding_number, rounding=False):
         if rounding:
-            #Round value to closest fitting number    
+            # Round value to closest fitting number
             outcome_labels = [self.decoder(i) for i in range(2**self.size)]
-            encoding_number = outcome_labels[np.argmin(np.abs(encoding_number-np.array(outcome_labels)))]
-    
+            encoding_number = outcome_labels[
+                np.argmin(np.abs(encoding_number - np.array(outcome_labels)))
+            ]
+
         super().encode(encoding_number)
-        
-    @gate_wrap(permeability = "args", is_qfree = True)
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __mul__(self, other):
-        
         if isinstance(other, QuantumFloat):
-                return q_mult(self, other)
+            return q_mult(self, other)
         elif isinstance(other, int):
-            
             bit_shift = 0
-            while not other%2:
-                other = other>>1
-                bit_shift += 1                
-            
+            while not other % 2:
+                other = other >> 1
+                bit_shift += 1
+
             if self.signed or other < 0:
-                output_qf = QuantumFloat(self.msize + int(np.ceil(np.log2(abs(other)))),
-                                         self.exponent, 
-                                         signed = True)
+                output_qf = QuantumFloat(
+                    self.msize + int(np.ceil(np.log2(abs(other)))),
+                    self.exponent,
+                    signed=True,
+                )
             else:
-                output_qf = QuantumFloat(self.msize + int(np.ceil(np.log2(abs(other)))), 
-                                         self.exponent, 
-                                         signed = False)
-            
-            polynomial_encoder([self], output_qf, other*sp.Symbol("x"))
-            
-            output_qf<<bit_shift
-            
+                output_qf = QuantumFloat(
+                    self.msize + int(np.ceil(np.log2(abs(other)))),
+                    self.exponent,
+                    signed=False,
+                )
+
+            polynomial_encoder([self], output_qf, other * sp.Symbol("x"))
+
+            output_qf << bit_shift
+
             return output_qf
         else:
-            raise Exception("QuantumFloat multiplication for type " + str(type(other)) + ""
-                            " not implemented (available are QuantumFloat and int)")
-    
-    @gate_wrap(permeability = "args", is_qfree = True)
+            raise Exception(
+                "QuantumFloat multiplication for type " + str(type(other)) + ""
+                " not implemented (available are QuantumFloat and int)"
+            )
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __add__(self, other):
         if isinstance(other, QuantumFloat):
             return sbp_add(self, other)
         elif isinstance(other, (int, float)):
-            res = self.duplicate(init = True)
+            res = self.duplicate(init=True)
             res += other
-            return res            
+            return res
         else:
-            raise Exception("Addition with type " + str(type(other)) + " not implemented")
-    
-    @gate_wrap(permeability = "args", is_qfree = True)
+            raise Exception(
+                "Addition with type " + str(type(other)) + " not implemented"
+            )
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __sub__(self, other):
         from qrisp.arithmetic import sbp_sub
+
         if isinstance(other, QuantumFloat):
-            
             return sbp_sub(self, other)
         elif isinstance(other, (int, float)):
-            
-            res = self.duplicate(init = True)
+            res = self.duplicate(init=True)
             res -= other
             return res
         else:
-            raise Exception("Subtraction with type " + str(type(other)) + " not implemented")
-            
+            raise Exception(
+                "Subtraction with type " + str(type(other)) + " not implemented"
+            )
+
     __radd__ = __add__
     __rmul__ = __mul__
-    
-    @gate_wrap(permeability = "args", is_qfree = True)
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __rsub__(self, other):
-        from qrisp.arithmetic import sbp_sub
         from qrisp import x
+        from qrisp.arithmetic import sbp_sub
+
         if isinstance(other, QuantumFloat):
             return sbp_sub(other, self)
         elif isinstance(other, (int, float)):
-            
-            res = self.duplicate(init = True)
+            res = self.duplicate(init=True)
             if not res.signed:
                 res.add_sign()
             x(res)
             res -= other - 2**res.exponent
             return res
         else:
-            raise Exception("Subtraction with type " + str(type(other)) + " not implemented")
-        
-    @gate_wrap(permeability = "args", is_qfree = True)
+            raise Exception(
+                "Subtraction with type " + str(type(other)) + " not implemented"
+            )
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __truediv__(self, other):
         from qrisp.arithmetic import q_div
-        
+
         return q_div(self, other)
-    
-    @gate_wrap(permeability = "args", is_qfree = True)
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __floordiv__(self, other):
-        
         if self.signed or other.signed:
             raise Exception("Floor division not implemented for signed QuantumFloats")
-        
+
         if self.exponent < 0 or other.exponent < 0:
-            raise Exception("Tried to perform floor division on non-integer QuantumFloats")
+            raise Exception(
+                "Tried to perform floor division on non-integer QuantumFloats"
+            )
         from qrisp.arithmetic import q_div
-        
-        return q_div(self, other, prec = 0)
-    
-    @gate_wrap(permeability = "args", is_qfree = True)
+
+        return q_div(self, other, prec=0)
+
+    @gate_wrap(permeability="args", is_qfree=True)
     def __pow__(self, power):
-        
         if power != -1:
             raise Exception("Currently the only supported power is -1")
-        
+
         from qrisp.arithmetic import qf_inversion
-        
+
         return qf_inversion(self)
-    
-    @gate_wrap(permeability = [1], is_qfree = True)
+
+    @gate_wrap(permeability=[1], is_qfree=True)
     def __iadd__(self, other):
-        
         if isinstance(other, QuantumFloat):
             input_qf_list = [other]
             poly = sp.symbols("x")
-            
+
             polynomial_encoder(input_qf_list, self, poly)
-            
-        
+
         elif isinstance(other, (int, float)):
             # self.incr(other)
-            
-            if not int(other/2**self.exponent) == other/2**self.exponent:
-                raise Exception("Tried to perform in-place addition with invalid number. QuantumFloat precision too low.")
-            
+
+            if not int(other / 2**self.exponent) == other / 2**self.exponent:
+                raise Exception(
+                    "Tried to perform in-place addition with invalid number. "
+                    "QuantumFloat precision too low."
+                )
+
             input_qf_list = []
             poly = sp.sympify(other)
-            
+
             polynomial_encoder(input_qf_list, self, poly)
 
         else:
-            raise Exception("In-place addition for type " + str(type(other)) + " not implemented")
-        
+            raise Exception(
+                "In-place addition for type " + str(type(other)) + " not implemented"
+            )
+
         return self
-    
-    @gate_wrap(permeability = [1], is_qfree = True)
+
+    @gate_wrap(permeability=[1], is_qfree=True)
     def __isub__(self, other):
-        
         if isinstance(other, QuantumFloat):
             input_qf_list = [other]
             poly = -sp.symbols("x")
-        
+
             polynomial_encoder(input_qf_list, self, poly)
-            
+
         elif isinstance(other, (int, float)):
-            
-            if not int(other/2**self.exponent) == other/2**self.exponent:
-                raise Exception("Tried to perform in-place subtraction with invalid number. QuantumFloat precision too low.")
-            
+            if not int(other / 2**self.exponent) == other / 2**self.exponent:
+                raise Exception(
+                    "Tried to perform in-place subtraction with invalid number. "
+                    "QuantumFloat precision too low."
+                )
+
             input_qf_list = []
             poly = -sp.sympify(other)
-        
+
             polynomial_encoder(input_qf_list, self, poly)
-            
+
         else:
-            raise Exception("In-place substraction for type " + str(type(other)) + " not implemented")
-        
+            raise Exception(
+                "In-place substraction for type "
+                + str(type(other))
+                + " not implemented"
+            )
+
         return self
-            
-    
-    @gate_wrap(permeability=[], is_qfree = True)
+
+    @gate_wrap(permeability=[], is_qfree=True)
     def __imul__(self, other):
-        
         inpl_mult(self, other)
-        
+
         return self
-        
+
     def __rshift__(self, k):
         self.exp_shift(-k)
         return self
-    
+
     def __lshift__(self, k):
         self.exp_shift(k)
         return self
-    
+
     def __lt__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return lt(self, other)
-        
+
     def __gt__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return gt(self, other)
-        
 
     def __le__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return leq(self, other)
 
     def __ge__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return geq(self, other)
-        
+
     def __eq__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return eq(self, other)
 
     def __ne__(self, other):
-        
         if not isinstance(other, (QuantumFloat, int, float)):
             raise Exception(f"Comparison with type {type(other)} not implemented")
-        
+
         return neq(self, other)
-        
+
     def exp_shift(self, shift):
-        
         if not isinstance(shift, int):
             raise Exception("Tried to shift QuantumFloat exponent by non-integer value")
-        
+
         self.exponent += shift
         self.mshape = self.mshape + shift
-        
-    def reduce(self, qubits, verify = False):
+
+    def reduce(self, qubits, verify=False):
         QuantumVariable.reduce(self, qubits, verify)
-        
-        
+
         try:
             self.mshape[1] -= len(qubits)
             self.msize -= len(qubits)
         except TypeError:
             self.mshape[1] -= 1
             self.msize -= 1
-            
-        
-            
-    def extend(self, amount, position = -1):
-        QuantumVariable.extend(self, amount, position = position)
-        
+
+    def extend(self, amount, position=-1):
+        QuantumVariable.extend(self, amount, position=position)
+
         self.mshape[1] += amount
         self.msize += amount
-    
+
     def add_sign(self):
         """
         Turns an unsigned QuantumFloat into its signed version.
 
         Raises
         ------
         Exception
             Tried to add sign to signed QuantumFloat.
 
         Examples
         --------
-        
+
         >>> from qrisp import QuantumFloat
         >>> qf = QuantumFloat(4)
         >>> qf.signed
         False
         >>> qf.add_sign()
         >>> qf.signed
         True
 
         """
-        
+
         if self.signed:
-            raise Exception("Tried to add sign to signed QuantumFloat")
-        
-        self.extend(1, self.size-1)
+            raise Exception(r'Tried to add sign to signed QuantumFloat')
+
+        self.extend(1, self.size - 1)
         self.mshape[1] -= 1
         self.msize -= 1
         self.signed = True
-        
+
     def sign(self):
-        """
-        Returns the sign qubit. 
-        
-        This qubit is in state $\ket{1}$ if the QuantumFloat holds a negative value and in state $\ket{0}$ otherwise.
-        
-        For more information about the encoding of negative numbers check our `paper <https://ieeexplore.ieee.org/document/9815035>`_.
-        
+        r"""
+        Returns the sign qubit.
+
+        This qubit is in state $\ket{1}$ if the QuantumFloat holds a negative value and
+        in state $\ket{0}$ otherwise.
+
+        For more information about the encoding of negative numbers check the
+        `publication <https://ieeexplore.ieee.org/document/9815035>`_.
+
         .. warning::
-            
-            Performing an X gate on this qubit does not flip the sign! Use inplace multiplication instead
-            
+
+            Performing an X gate on this qubit does not flip the sign! Use inplace
+            multiplication instead.
+
             >>> from qrisp import QuantumFloat
             >>> qf = QuantumFloat(3, signed = True)
             >>> qf[:] = 3
             >>> qf *= -1
             >>> print(qf)
             {-3: 1.0}
 
@@ -645,48 +676,56 @@
         Exception
             Tried to retrieve sign qubit of unsigned QuantumFloat.
 
         Returns
         -------
         Qubit
             The qubit holding the sign.
-            
+
         Examples
         --------
-        
-        We create a QuantumFloat, initiate a state that has probability 2/3 of being negative and entangle a QuantumBool with the sign qubit.
-        
+
+        We create a QuantumFloat, initiate a state that has probability 2/3 of being
+        negative and entangle a QuantumBool with the sign qubit.
+
         >>> from qrisp import QuantumFloat, QuantumBool, cx
         >>> qf = QuantumFloat(4, signed = True)
         >>> n_amp = 1/3**0.5
         >>> qf[:] = {-1 : n_amp, -2 : n_amp, 1 : n_amp}
         >>> qbl = QuantumBool()
         >>> cx(qf.sign(), qbl)
         >>> print(qbl)
         {True: 0.6667, False: 0.3333}
 
         """
         if not self.signed:
             raise Exception("Tried to retrieve sign qubit of unsigned QuantumFloat")
-            
+
         return self[-1]
-    
-    
-    def init_from(self, other, ignore_rounding_errors = False, ignore_overflow_errors = False):
-        copy_qf(self, other, ignore_rounding_errors = ignore_rounding_errors, ignore_overflow_errors= ignore_overflow_errors)
-    
-    def incr(self, x = None):
+
+    def init_from(
+        self, other, ignore_rounding_errors=False, ignore_overflow_errors=False
+    ):
+        copy_qf(
+            self,
+            other,
+            ignore_rounding_errors=ignore_rounding_errors,
+            ignore_overflow_errors=ignore_overflow_errors,
+        )
+
+    def incr(self, x=None):
         from qrisp.arithmetic.incrementation import increment
-        if x == None:
+
+        if x is None:
             x = 2**self.exponent
         increment(self, x)
 
     def __hash__(self):
         return id(self)
-    
+
     def significant(self, k):
         """
         Returns the qubit with significance $k$.
 
         Parameters
         ----------
         k : int
@@ -697,196 +736,216 @@
         Exception
             Tried to retrieve invalid significant from QuantumFloat
 
         Returns
         -------
         Qubit
             The Qubit with significance $k$.
-            
+
         Examples
         --------
-        
+
         We create a QuantumFloat and flip a qubit of specified significance.
-        
+
         >>> from qrisp import QuantumFloat, x
         >>> qf = QuantumFloat(6, -3)
         >>> x(qf.significant(-2))
         >>> print(qf)
         {0.25: 1.0}
-        
+
         The qubit with significance $-2$ corresponds to the value $0.25 = 2^{-2}$.
-        
+
         >>> x(qf.significant(2))
         {4.25: 1.0}
-        
+
         The qubit with significance $2$ corresponds to the value $4 = 2^{2}$.
 
         """
-        
+
         sig_list = list(range(self.mshape[0], self.mshape[1]))
-        
-        if not k in sig_list:
-            raise Exception(f"Tried to retrieve invalid significant {k} from QuantumFloat with mantissa shape {self.mshape}")
-        
+
+        if k not in sig_list:
+            raise Exception(
+                f"Tried to retrieve invalid significant {k} "
+                f"from QuantumFloat with mantissa shape {self.mshape}"
+            )
+
         return self[sig_list.index(k)]
-        
-   
+
     def truncate(self, x):
         """
-        Receives a regular float and returns the float that is closest to the input but can still be encoded.
+        Receives a regular float and returns the float that is closest to the input but
+        can still be encoded.
 
         Parameters
         ----------
         x : float
             A float that is supposed to be truncated.
 
         Returns
         -------
         float
             The truncated float.
-            
+
         Examples
         --------
-        
-        We create a QuantumFloat and round a value to fit the encoder and subsequently initiate:
-        
+
+        We create a QuantumFloat and round a value to fit the encoder and subsequently
+        initiate:
+
         >>> from qrisp import QuantumFloat
         >>> qf = QuantumFloat(4, -1)
         >>> value = 0.5102341
         >>> qf[:] = value
         Exception: Value 0.5102341 not supported by encoder.
         >>> rounded_value = qf.truncate(value)
         >>> rounded_value
         0.5
         >>> qf[:] = rounded_value
         >>> print(qf)
         {0.5: 1.0}
 
         """
         decoder_values = np.array([self.decoder(i) for i in range(2**self.size)])
-        
+
         return decoder_values[np.argmin(np.abs(decoder_values - x))]
-        
+
+
 def create_output_qf(operands, op):
-    
     if isinstance(op, sp.core.expr.Expr):
         from qrisp.arithmetic.poly_tools import expr_to_list
-        
+
         expr_list = expr_to_list(op)
-        
-        
+
         for i in range(len(expr_list)):
             if not isinstance(expr_list[i][0], sp.Symbol):
                 expr_list[i].pop(0)
-                
-        
-        operands.sort(key = lambda x : x.name)
-        
-        
+
+        operands.sort(key=lambda x: x.name)
+
         def prod(iter):
             iter = list(iter)
             a = iter[0]
             for i in range(1, len(iter)):
                 a *= iter[i]
-                
+
             return a
-        
-        from sympy import Symbol, Abs, Poly
-        
+
+        from sympy import Abs, Poly, Symbol
+
         poly = Poly(op)
-        monom_list = [a*prod(x**k for x, k in zip(poly.gens, mon)) for a, mon in zip(poly.coeffs(), poly.monoms())]
-        
-        max_value_dic = {Symbol(qf.name) : 2.**qf.mshape[1] for qf in operands}
-        min_value_dic = {Symbol(qf.name) : 2.**qf.mshape[0] for qf in operands}
-                
-        
-        
+        monom_list = [
+            a * prod(x**k for x, k in zip(poly.gens, mon))
+            for a, mon in zip(poly.coeffs(), poly.monoms())
+        ]
+
+        max_value_dic = {Symbol(qf.name): 2.0 ** qf.mshape[1] for qf in operands}
+        min_value_dic = {Symbol(qf.name): 2.0 ** qf.mshape[0] for qf in operands}
+
         abs_poly = sum([Abs(monom) for monom in monom_list], 0)
-        
-        min_poly_value = min([float(Abs(monom).subs(min_value_dic)) for monom in monom_list])
-        
+
+        min_poly_value = min(
+            [float(Abs(monom).subs(min_value_dic)) for monom in monom_list]
+        )
+
         max_poly_value = float(abs_poly.subs(max_value_dic))
-        
-        
+
         min_sig = int(np.floor(np.log2(min_poly_value)))
         max_sig = int(np.ceil(np.log2(max_poly_value)))
-        
-        
-        msize  = max_sig - min_sig
+
+        msize = max_sig - min_sig
         exponent = min_sig
-        
-        
+
         signed = bool(sum([int(operand.signed) for operand in operands]))
-        
-        return QuantumFloat(msize, exponent = exponent, signed = signed)
-    
 
-    
+        return QuantumFloat(msize, exponent=exponent, signed=signed)
+
     if op == "add":
         signed = operands[0].signed or operands[1].signed
         exponent = min(operands[0].exponent, operands[1].exponent)
-        
 
-        max_sig = int(np.ceil(np.log2(int(2**operands[0].mshape[1] + 2**operands[1].mshape[1]))))
+        max_sig = int(
+            np.ceil(
+                np.log2(int(2 ** operands[0].mshape[1] + 2 ** operands[1].mshape[1]))
+            )
+        )
         msize = max_sig - exponent + 1
-        return QuantumFloat(msize, exponent, operands[0].qs, signed = signed, name = "add_res*")
-    
+        return QuantumFloat(
+            msize, exponent, operands[0].qs, signed=signed, name="add_res*"
+        )
+
     if op == "mul":
         signed = operands[0].signed or operands[1].signed
-        
-        if operands[0].reg == operands[1].reg and (operands[0].signed and operands[1].signed):
+
+        if operands[0].reg == operands[1].reg and (
+            operands[0].signed and operands[1].signed
+        ):
             signed = False
-        
-        return QuantumFloat(operands[0].msize + operands[1].msize + operands[0].signed*operands[1].signed, operands[0].exponent + operands[1].exponent, operands[0].qs, signed = signed, name = "mul_res*")
-    
+
+        return QuantumFloat(
+            operands[0].msize
+            + operands[1].msize
+            + operands[0].signed * operands[1].signed,
+            operands[0].exponent + operands[1].exponent,
+            operands[0].qs,
+            signed=signed,
+            name="mul_res*",
+        )
+
     if op == "sub":
         exponent = min(operands[0].exponent, operands[1].exponent)
-        max_sig = int(np.ceil(np.log2(int(2**operands[0].mshape[1] + 2**operands[1].mshape[1]))))
+        max_sig = int(
+            np.ceil(
+                np.log2(int(2 ** operands[0].mshape[1] + 2 ** operands[1].mshape[1]))
+            )
+        )
         msize = max_sig - exponent + 1
-        
-        return QuantumFloat(msize, exponent, operands[0].qs, signed = True, name = "sub_res*")
-    
+
+        return QuantumFloat(
+            msize, exponent, operands[0].qs, signed=True, name="sub_res*"
+        )
 
 
-#Initiates the value of qf2 into qf1 where qf1 has to hold the value 0
-def copy_qf(qf1, qf2, ignore_overflow_errors = False, ignore_rounding_errors = False):
-    
-    #Lists that translate Qubit index => Significance
+# Initiates the value of qf2 into qf1 where qf1 has to hold the value 0
+def copy_qf(qf1, qf2, ignore_overflow_errors=False, ignore_rounding_errors=False):
+    # Lists that translate Qubit index => Significance
     qf1_sign_list = [qf1.exponent + i for i in range(qf1.size)]
     qf2_sign_list = [qf2.exponent + i for i in range(qf2.size)]
-    
-    
-    #Check overflow/underflow
+
+    # Check overflow/underflow
     if max(qf1_sign_list) < max(qf2_sign_list) and not ignore_overflow_errors:
-        raise Exception("Copy operation would result in overflow (use ignore_overflow_errors = True)")
-        
+        raise Exception(
+            "Copy operation would result in overflow "
+            "(use ignore_overflow_errors = True)"
+        )
+
     if min(qf1_sign_list) > min(qf2_sign_list) and not ignore_rounding_errors:
-        raise Exception("Copy operation would result in rounding (use ignore_rounding_errors = True)")
-    
+        raise Exception(
+            "Copy operation would result in rounding "
+            "(use ignore_rounding_errors = True)"
+        )
+
     qs = qf1.qs
-    
+
     if qf2.signed:
         if not qf1.signed:
             raise Exception("Tried to copy signed into unsigend float")
-        
-        #Remove last entry from significance list (last qubit is the sign qubit)
+
+        # Remove last entry from significance list (last qubit is the sign qubit)
         qf2_sign_list.pop(-1)
         qf1_sign_list.pop(-1)
-        
-        
-    
+
     for i in range(len(qf1_sign_list)):
-        
-        #If we are in a realm where both floats have overlapping significance => CNOT into each other
+        # If we are in a realm where both floats have overlapping significance
+        # => CNOT into each other
         if qf1_sign_list[i] in qf2_sign_list:
             qf2_index = qf2_sign_list.index(qf1_sign_list[i])
             qs.cx(qf2[qf2_index], qf1[i])
             continue
-        
-        #Otherwise copy the sign bit into the bits of higher significance than qf2
+
+        # Otherwise copy the sign bit into the bits of higher significance than qf2
         if qf1_sign_list[i] > max(qf2_sign_list) and qf2.signed:
             qs.cx(qf2[-1], qf1[i])
-    
-    #Copy the sign bit
+
+    # Copy the sign bit
     if qf2.signed:
         qs.cx(qf2[-1], qf1[-1])
-
```

### Comparing `qrisp-0.0.15/src/qrisp/qtypes/quantum_string.py` & `qrisp-0.0.16/src/qrisp/qtypes/quantum_string.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,153 +1,148 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-
-from qrisp.qtypes.quantum_char import QuantumChar
-from qrisp.core.quantum_array import QuantumArray
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
 import numpy as np
 
-nisq_init_quantum_char = QuantumChar(name = "nisq_q_char")
-init_quantum_char = QuantumChar(nisq_char = False, name = "q_char")
+from qrisp.core.quantum_array import QuantumArray
+from qrisp.qtypes.quantum_char import QuantumChar
+
+nisq_init_quantum_char = QuantumChar(name="nisq_q_char")
+init_quantum_char = QuantumChar(nisq_char=False, name="q_char")
+
 
 class QuantumString(QuantumArray):
     """
-    The QuantumString is the quantum equivalent of a string. It is implemented as a :ref:`QuantumArray` of :ref:`QuantumChars <QuantumChar>`.
-    
+    The QuantumString is the quantum equivalent of a string. It is implemented as a
+    :ref:`QuantumArray` of :ref:`QuantumChars <QuantumChar>`.
+
     >>> from qrisp import QuantumString
     >>> q_str = QuantumString(size = len("hello world"))
     >>> q_str[:] = "hello world"
-    >>> print(q_str)    
+    >>> print(q_str)
     {'hello world': 1.0}
-    
+
     It is also possible to have a QuantumString containing non-nisq chars
-    
+
     >>> q_str_nn = QuantumString(size = len("hello world"), nisq_char = False)
     >>> q_str_nn[:] = "hello world"
-    >>> print(q_str_nn)    
+    >>> print(q_str_nn)
     {'hello world': 1.0}
-    
+
     This requires however considerably more qubits
-    
+
     >>> print(len(q_str.qs.qubits))
     55
     >>> print(len(q_str_nn.qs.qubits))
     88
-    
-    Similar to it's parent class, the size of a QuantumString does not have to be specified at creation
-    
+
+    Similar to its parent class, the size of a QuantumString does not have to be
+    specified at creation
+
     >>> q_str = QuantumString()
     >>> q_str[:] = "hello world"
     >>> print(q_str)
     {'hello world': 1.0}
-    
+
     **Concatenation**
-    
+
     QuantumStrings provide a number of methods to concatenate:
-        
+
     >>> q_str_0 = QuantumString()
     >>> q_str_1 = QuantumString()
     >>> q_str_2 = QuantumString()
     >>> q_str_0[:] = "hello"
     >>> q_str_1 += " "
     >>> q_str_2[:] = "world"
     >>> q_str_3 = q_str_1 + q_str_2
     >>> q_str_0 += q_str_3
     >>> print(q_str_0)
     {'hello world': 1.0}
-    
-    Note that these QuantumStrings share memory - ie. if we modify a QuantumChar in one of them, this will potentially affect the others:
-        
+
+    Note that these QuantumStrings share memory - i.e. if we modify a QuantumChar in one
+    of them, this will potentially affect the others:
+
     >>> from qrisp import h
     >>> h(q_str_2[0][0])
     >>> print(q_str_0)
     {'hello world': 0.5, 'hello xorld': 0.5}
-    
+
     """
-    
-    def __new__(subtype, size = 0, qs = None, nisq_char = True):
-        
+
+    def __new__(subtype, size=0, qs=None, nisq_char=True):
         if nisq_char:
-            return QuantumArray.__new__(subtype, nisq_init_quantum_char, size,  qs = qs)
+            return QuantumArray.__new__(subtype, nisq_init_quantum_char, size, qs=qs)
         else:
-            return QuantumArray.__new__(subtype, init_quantum_char, size,  qs = qs)
+            return QuantumArray.__new__(subtype, init_quantum_char, size, qs=qs)
 
     def get_measurement(self, **kwargs):
         mes_result = QuantumArray.get_measurement(self, **kwargs)
-        
+
         return_dic = {}
-        
-        for (k,v) in mes_result.items():
+
+        for k, v in mes_result.items():
             return_dic["".join(list(k))] = v
-        
+
         return return_dic
-    
-    
+
     def __add__(self, other):
         return np.concatenate((self, other)).view(QuantumString)
-    
+
     def decoder(self, code_int):
-        
         res_array = QuantumArray.decoder(self, code_int)
         res_str = ""
-        
+
         for i in range(len(res_array)):
             res_str += res_array[i]
-            
+
         return res_str
-    
+
     def encoder(self, encoding_str):
-        
-        encoding_array = np.zeros(len(encoding_str), dtype = "object")
-        
+        encoding_array = np.zeros(len(encoding_str), dtype="object")
+
         for i in range(len(encoding_array)):
             encoding_array[i] = encoding_str[i]
-        
+
         return QuantumArray.encoder(self, encoding_array)
-    
+
     def __setitem__(self, key, value):
         if isinstance(key, int):
             QuantumArray.__setitem__(self, key, value)
             return
-        
+
         QuantumArray.__setitem__(self, key, [ch for ch in value])
-    
-    
+
     def __iadd__(self, other):
-        
         from qrisp import merge
-        
+
         if isinstance(other, QuantumString):
-            self.resize((len(self) + len(other),), refcheck = False)
+            self.resize((len(self) + len(other),), refcheck=False)
             merge(self.qs, other.qs)
             for i in range(len(other)):
                 np.ndarray.__setitem__(self, i + len(self) - len(other), other[i])
-                
-                
+
         elif isinstance(other, str):
             if self.shape_specified:
-                self.resize((len(self) + len(other),), refcheck = False)
+                self.resize((len(self) + len(other),), refcheck=False)
             else:
                 self.set_shape(len(other))
             for i in range(len(other)):
-                np.ndarray.__setitem__(self, i + len(self) - len(other), self.qtype.duplicate(qs = self.qs))
+                np.ndarray.__setitem__(
+                    self, i + len(self) - len(other), self.qtype.duplicate(qs=self.qs)
+                )
                 self[i + len(self) - len(other)] = other[i]
-                
-        
+
         elif isinstance(other, QuantumChar):
-            self.resize((len(self) + 1, ), refcheck = False)
+            self.resize((len(self) + 1,), refcheck=False)
             np.ndarray.__setitem__(self, len(self) - 1, other)
-            
-            
+
         return self
-
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/__init__.py` & `qrisp-0.0.16/src/qrisp/quantum_network/__init__.py`

 * *Ordering differences only*

 * *Files 7% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
-from qrisp.quantum_network.qn_server import *
 from qrisp.quantum_network.qn_client import *
+from qrisp.quantum_network.qn_server import *
 from qrisp.quantum_network.qn_simulator_server import *
 from qrisp.quantum_network.quantum_network_session import *
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/QuantumNetworkService.py` & `qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/QuantumNetworkService.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,36 +1,44 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 #
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+import logging
+import sys
+
 from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TProcessor,
+    TType,
+)
+from thrift.transport import TTransport
 from thrift.TRecursive import fix_spec
 
-import sys
-import logging
 from .ttypes import *
-from thrift.Thrift import TProcessor
-from thrift.transport import TTransport
+
 all_structs = []
 
 
 class Iface(object):
     def register_client(self, name):
         """
         Parameters:
@@ -103,15 +111,15 @@
          - name
 
         """
         self.send_register_client(name)
         self.recv_register_client()
 
     def send_register_client(self, name):
-        self._oprot.writeMessageBegin('register_client', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("register_client", TMessageType.CALL, self._seqid)
         args = register_client_args()
         args.name = name
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_register_client(self):
@@ -133,15 +141,15 @@
          - name
 
         """
         self.send_get_clear_qc(name)
         return self.recv_get_clear_qc()
 
     def send_get_clear_qc(self, name):
-        self._oprot.writeMessageBegin('get_clear_qc', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("get_clear_qc", TMessageType.CALL, self._seqid)
         args = get_clear_qc_args()
         args.name = name
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_get_clear_qc(self):
@@ -153,28 +161,30 @@
             iprot.readMessageEnd()
             raise x
         result = get_clear_qc_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_clear_qc failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT, "get_clear_qc failed: unknown result"
+        )
 
     def request_qubits(self, amount, name):
         """
         Parameters:
          - amount
          - name
 
         """
         self.send_request_qubits(amount, name)
         return self.recv_request_qubits()
 
     def send_request_qubits(self, amount, name):
-        self._oprot.writeMessageBegin('request_qubits', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("request_qubits", TMessageType.CALL, self._seqid)
         args = request_qubits_args()
         args.amount = amount
         args.name = name
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
@@ -187,29 +197,32 @@
             iprot.readMessageEnd()
             raise x
         result = request_qubits_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "request_qubits failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT,
+            "request_qubits failed: unknown result",
+        )
 
     def send_qubits(self, sender, recipient, msg):
         """
         Parameters:
          - sender
          - recipient
          - msg
 
         """
         self.send_send_qubits(sender, recipient, msg)
         self.recv_send_qubits()
 
     def send_send_qubits(self, sender, recipient, msg):
-        self._oprot.writeMessageBegin('send_qubits', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("send_qubits", TMessageType.CALL, self._seqid)
         args = send_qubits_args()
         args.sender = sender
         args.recipient = recipient
         args.msg = msg
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
@@ -234,15 +247,15 @@
          - name
 
         """
         self.send_run(qc, name)
         return self.recv_run()
 
     def send_run(self, qc, name):
-        self._oprot.writeMessageBegin('run', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("run", TMessageType.CALL, self._seqid)
         args = run_args()
         args.qc = qc
         args.name = name
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
@@ -255,27 +268,29 @@
             iprot.readMessageEnd()
             raise x
         result = run_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "run failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT, "run failed: unknown result"
+        )
 
     def inbox(self, name):
         """
         Parameters:
          - name
 
         """
         self.send_inbox(name)
         return self.recv_inbox()
 
     def send_inbox(self, name):
-        self._oprot.writeMessageBegin('inbox', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("inbox", TMessageType.CALL, self._seqid)
         args = inbox_args()
         args.name = name
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_inbox(self):
@@ -287,22 +302,24 @@
             iprot.readMessageEnd()
             raise x
         result = inbox_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "inbox failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT, "inbox failed: unknown result"
+        )
 
     def get_overall_qc(self):
         self.send_get_overall_qc()
         return self.recv_get_overall_qc()
 
     def send_get_overall_qc(self):
-        self._oprot.writeMessageBegin('get_overall_qc', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin("get_overall_qc", TMessageType.CALL, self._seqid)
         args = get_overall_qc_args()
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_get_overall_qc(self):
         iprot = self._iprot
@@ -313,22 +330,27 @@
             iprot.readMessageEnd()
             raise x
         result = get_overall_qc_result()
         result.read(iprot)
         iprot.readMessageEnd()
         if result.success is not None:
             return result.success
-        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_overall_qc failed: unknown result")
+        raise TApplicationException(
+            TApplicationException.MISSING_RESULT,
+            "get_overall_qc failed: unknown result",
+        )
 
     def reset_network_state(self):
         self.send_reset_network_state()
         self.recv_reset_network_state()
 
     def send_reset_network_state(self):
-        self._oprot.writeMessageBegin('reset_network_state', TMessageType.CALL, self._seqid)
+        self._oprot.writeMessageBegin(
+            "reset_network_state", TMessageType.CALL, self._seqid
+        )
         args = reset_network_state_args()
         args.write(self._oprot)
         self._oprot.writeMessageEnd()
         self._oprot.trans.flush()
 
     def recv_reset_network_state(self):
         iprot = self._iprot
@@ -364,15 +386,17 @@
     def process(self, iprot, oprot):
         (name, type, seqid) = iprot.readMessageBegin()
         if self._on_message_begin:
             self._on_message_begin(name, type, seqid)
         if name not in self._processMap:
             iprot.skip(TType.STRUCT)
             iprot.readMessageEnd()
-            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
+            x = TApplicationException(
+                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
+            )
             oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
             x.write(oprot)
             oprot.writeMessageEnd()
             oprot.trans.flush()
             return
         else:
             self._processMap[name](self, seqid, iprot, oprot)
@@ -385,21 +409,23 @@
         result = register_client_result()
         try:
             self._handler.register_client(args.name)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("register_client", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_get_clear_qc(self, seqid, iprot, oprot):
         args = get_clear_qc_args()
@@ -408,21 +434,23 @@
         result = get_clear_qc_result()
         try:
             result.success = self._handler.get_clear_qc(args.name)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("get_clear_qc", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_request_qubits(self, seqid, iprot, oprot):
         args = request_qubits_args()
@@ -431,21 +459,23 @@
         result = request_qubits_result()
         try:
             result.success = self._handler.request_qubits(args.amount, args.name)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("request_qubits", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_send_qubits(self, seqid, iprot, oprot):
         args = send_qubits_args()
@@ -454,21 +484,23 @@
         result = send_qubits_result()
         try:
             self._handler.send_qubits(args.sender, args.recipient, args.msg)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("send_qubits", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_run(self, seqid, iprot, oprot):
         args = run_args()
@@ -477,21 +509,23 @@
         result = run_result()
         try:
             result.success = self._handler.run(args.qc, args.name)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("run", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_inbox(self, seqid, iprot, oprot):
         args = inbox_args()
@@ -500,21 +534,23 @@
         result = inbox_result()
         try:
             result.success = self._handler.inbox(args.name)
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("inbox", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_get_overall_qc(self, seqid, iprot, oprot):
         args = get_overall_qc_args()
@@ -523,21 +559,23 @@
         result = get_overall_qc_result()
         try:
             result.success = self._handler.get_overall_qc()
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("get_overall_qc", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
     def process_reset_network_state(self, seqid, iprot, oprot):
         args = reset_network_state_args()
@@ -546,209 +584,264 @@
         result = reset_network_state_result()
         try:
             self._handler.reset_network_state()
             msg_type = TMessageType.REPLY
         except TTransport.TTransportException:
             raise
         except TApplicationException as ex:
-            logging.exception('TApplication exception in handler')
+            logging.exception("TApplication exception in handler")
             msg_type = TMessageType.EXCEPTION
             result = ex
         except Exception:
-            logging.exception('Unexpected exception in handler')
+            logging.exception("Unexpected exception in handler")
             msg_type = TMessageType.EXCEPTION
-            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
+            result = TApplicationException(
+                TApplicationException.INTERNAL_ERROR, "Internal error"
+            )
         oprot.writeMessageBegin("reset_network_state", msg_type, seqid)
         result.write(oprot)
         oprot.writeMessageEnd()
         oprot.trans.flush()
 
+
 # HELPER FUNCTIONS AND STRUCTURES
 
 
 class register_client_args(object):
     """
     Attributes:
      - name
 
     """
 
-
-    def __init__(self, name=None,):
+    def __init__(
+        self,
+        name=None,
+    ):
         self.name = name
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('register_client_args')
+        oprot.writeStructBegin("register_client_args")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(register_client_args)
 register_client_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
 )
 
 
 class register_client_result(object):
-
-
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('register_client_result')
+        oprot.writeStructBegin("register_client_result")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(register_client_result)
-register_client_result.thrift_spec = (
-)
+register_client_result.thrift_spec = ()
 
 
 class get_clear_qc_args(object):
     """
     Attributes:
      - name
 
     """
 
-
-    def __init__(self, name=None,):
+    def __init__(
+        self,
+        name=None,
+    ):
         self.name = name
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('get_clear_qc_args')
+        oprot.writeStructBegin("get_clear_qc_args")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(get_clear_qc_args)
 get_clear_qc_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
 )
 
 
 class get_clear_qc_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -761,130 +854,173 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('get_clear_qc_result')
+        oprot.writeStructBegin("get_clear_qc_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            oprot.writeFieldBegin("success", TType.STRUCT, 0)
             self.success.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(get_clear_qc_result)
 get_clear_qc_result.thrift_spec = (
-    (0, TType.STRUCT, 'success', [QuantumCircuit, None], None, ),  # 0
+    (
+        0,
+        TType.STRUCT,
+        "success",
+        [QuantumCircuit, None],
+        None,
+    ),  # 0
 )
 
 
 class request_qubits_args(object):
     """
     Attributes:
      - amount
      - name
 
     """
 
-
-    def __init__(self, amount=None, name=None,):
+    def __init__(
+        self,
+        amount=None,
+        name=None,
+    ):
         self.amount = amount
         self.name = name
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.I32:
                     self.amount = iprot.readI32()
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('request_qubits_args')
+        oprot.writeStructBegin("request_qubits_args")
         if self.amount is not None:
-            oprot.writeFieldBegin('amount', TType.I32, 1)
+            oprot.writeFieldBegin("amount", TType.I32, 1)
             oprot.writeI32(self.amount)
             oprot.writeFieldEnd()
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 2)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 2)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(request_qubits_args)
 request_qubits_args.thrift_spec = (
     None,  # 0
-    (1, TType.I32, 'amount', None, None, ),  # 1
-    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
+    (
+        1,
+        TType.I32,
+        "amount",
+        None,
+        None,
+    ),  # 1
+    (
+        2,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 2
 )
 
 
 class request_qubits_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -902,78 +1038,103 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('request_qubits_result')
+        oprot.writeStructBegin("request_qubits_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeFieldBegin("success", TType.LIST, 0)
             oprot.writeListBegin(TType.STRUCT, len(self.success))
             for iter55 in self.success:
                 iter55.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(request_qubits_result)
 request_qubits_result.thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT, [Qubit, None], False), None, ),  # 0
+    (
+        0,
+        TType.LIST,
+        "success",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 0
 )
 
 
 class send_qubits_args(object):
     """
     Attributes:
      - sender
      - recipient
      - msg
 
     """
 
-
-    def __init__(self, sender=None, recipient=None, msg=None,):
+    def __init__(
+        self,
+        sender=None,
+        recipient=None,
+        msg=None,
+    ):
         self.sender = sender
         self.recipient = recipient
         self.msg = msg
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.sender = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.sender = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.STRING:
-                    self.recipient = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.recipient = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             elif fid == 3:
                 if ftype == TType.STRUCT:
                     self.msg = Message()
                     self.msg.read(iprot)
                 else:
@@ -981,112 +1142,150 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('send_qubits_args')
+        oprot.writeStructBegin("send_qubits_args")
         if self.sender is not None:
-            oprot.writeFieldBegin('sender', TType.STRING, 1)
-            oprot.writeString(self.sender.encode('utf-8') if sys.version_info[0] == 2 else self.sender)
+            oprot.writeFieldBegin("sender", TType.STRING, 1)
+            oprot.writeString(
+                self.sender.encode("utf-8") if sys.version_info[0] == 2 else self.sender
+            )
             oprot.writeFieldEnd()
         if self.recipient is not None:
-            oprot.writeFieldBegin('recipient', TType.STRING, 2)
-            oprot.writeString(self.recipient.encode('utf-8') if sys.version_info[0] == 2 else self.recipient)
+            oprot.writeFieldBegin("recipient", TType.STRING, 2)
+            oprot.writeString(
+                self.recipient.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.recipient
+            )
             oprot.writeFieldEnd()
         if self.msg is not None:
-            oprot.writeFieldBegin('msg', TType.STRUCT, 3)
+            oprot.writeFieldBegin("msg", TType.STRUCT, 3)
             self.msg.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(send_qubits_args)
 send_qubits_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'sender', 'UTF8', None, ),  # 1
-    (2, TType.STRING, 'recipient', 'UTF8', None, ),  # 2
-    (3, TType.STRUCT, 'msg', [Message, None], None, ),  # 3
+    (
+        1,
+        TType.STRING,
+        "sender",
+        "UTF8",
+        None,
+    ),  # 1
+    (
+        2,
+        TType.STRING,
+        "recipient",
+        "UTF8",
+        None,
+    ),  # 2
+    (
+        3,
+        TType.STRUCT,
+        "msg",
+        [Message, None],
+        None,
+    ),  # 3
 )
 
 
 class send_qubits_result(object):
-
-
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('send_qubits_result')
+        oprot.writeStructBegin("send_qubits_result")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(send_qubits_result)
-send_qubits_result.thrift_spec = (
-)
+send_qubits_result.thrift_spec = ()
 
 
 class run_args(object):
     """
     Attributes:
      - qc
      - name
 
     """
 
-
-    def __init__(self, qc=None, name=None,):
+    def __init__(
+        self,
+        qc=None,
+        name=None,
+    ):
         self.qc = qc
         self.name = name
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -1094,205 +1293,274 @@
                 if ftype == TType.STRUCT:
                     self.qc = QuantumCircuit()
                     self.qc.read(iprot)
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('run_args')
+        oprot.writeStructBegin("run_args")
         if self.qc is not None:
-            oprot.writeFieldBegin('qc', TType.STRUCT, 1)
+            oprot.writeFieldBegin("qc", TType.STRUCT, 1)
             self.qc.write(oprot)
             oprot.writeFieldEnd()
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 2)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 2)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(run_args)
 run_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRUCT, 'qc', [QuantumCircuit, None], None, ),  # 1
-    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
+    (
+        1,
+        TType.STRUCT,
+        "qc",
+        [QuantumCircuit, None],
+        None,
+    ),  # 1
+    (
+        2,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 2
 )
 
 
 class run_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 0:
                 if ftype == TType.MAP:
                     self.success = {}
                     (_ktype57, _vtype58, _size56) = iprot.readMapBegin()
                     for _i60 in range(_size56):
-                        _key61 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                        _key61 = (
+                            iprot.readString().decode("utf-8", errors="replace")
+                            if sys.version_info[0] == 2
+                            else iprot.readString()
+                        )
                         _val62 = iprot.readI32()
                         self.success[_key61] = _val62
                     iprot.readMapEnd()
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('run_result')
+        oprot.writeStructBegin("run_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.MAP, 0)
+            oprot.writeFieldBegin("success", TType.MAP, 0)
             oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
             for kiter63, viter64 in self.success.items():
-                oprot.writeString(kiter63.encode('utf-8') if sys.version_info[0] == 2 else kiter63)
+                oprot.writeString(
+                    kiter63.encode("utf-8") if sys.version_info[0] == 2 else kiter63
+                )
                 oprot.writeI32(viter64)
             oprot.writeMapEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(run_result)
 run_result.thrift_spec = (
-    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
+    (
+        0,
+        TType.MAP,
+        "success",
+        (TType.STRING, "UTF8", TType.I32, None, False),
+        None,
+    ),  # 0
 )
 
 
 class inbox_args(object):
     """
     Attributes:
      - name
 
     """
 
-
-    def __init__(self, name=None,):
+    def __init__(
+        self,
+        name=None,
+    ):
         self.name = name
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('inbox_args')
+        oprot.writeStructBegin("inbox_args")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(inbox_args)
 inbox_args.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
 )
 
 
 class inbox_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -1310,102 +1578,121 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('inbox_result')
+        oprot.writeStructBegin("inbox_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeFieldBegin("success", TType.LIST, 0)
             oprot.writeListBegin(TType.STRUCT, len(self.success))
             for iter71 in self.success:
                 iter71.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(inbox_result)
 inbox_result.thrift_spec = (
-    (0, TType.LIST, 'success', (TType.STRUCT, [Message, None], False), None, ),  # 0
+    (
+        0,
+        TType.LIST,
+        "success",
+        (TType.STRUCT, [Message, None], False),
+        None,
+    ),  # 0
 )
 
 
 class get_overall_qc_args(object):
-
-
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('get_overall_qc_args')
+        oprot.writeStructBegin("get_overall_qc_args")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(get_overall_qc_args)
-get_overall_qc_args.thrift_spec = (
-)
+get_overall_qc_args.thrift_spec = ()
 
 
 class get_overall_qc_result(object):
     """
     Attributes:
      - success
 
     """
 
-
-    def __init__(self, success=None,):
+    def __init__(
+        self,
+        success=None,
+    ):
         self.success = success
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -1418,122 +1705,139 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('get_overall_qc_result')
+        oprot.writeStructBegin("get_overall_qc_result")
         if self.success is not None:
-            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            oprot.writeFieldBegin("success", TType.STRUCT, 0)
             self.success.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(get_overall_qc_result)
 get_overall_qc_result.thrift_spec = (
-    (0, TType.STRUCT, 'success', [QuantumCircuit, None], None, ),  # 0
+    (
+        0,
+        TType.STRUCT,
+        "success",
+        [QuantumCircuit, None],
+        None,
+    ),  # 0
 )
 
 
 class reset_network_state_args(object):
-
-
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('reset_network_state_args')
+        oprot.writeStructBegin("reset_network_state_args")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
-all_structs.append(reset_network_state_args)
-reset_network_state_args.thrift_spec = (
-)
 
 
-class reset_network_state_result(object):
+all_structs.append(reset_network_state_args)
+reset_network_state_args.thrift_spec = ()
 
 
+class reset_network_state_result(object):
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('reset_network_state_result')
+        oprot.writeStructBegin("reset_network_state_result")
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(reset_network_state_result)
-reset_network_state_result.thrift_spec = (
-)
+reset_network_state_result.thrift_spec = ()
 fix_spec(all_structs)
 del all_structs
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/constants.py` & `qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/constants.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,26 +1,33 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 #
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
+import sys
+
 from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TType,
+)
 from thrift.TRecursive import fix_spec
 
-import sys
 from .ttypes import *
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/interface/codegen/ttypes.py` & `qrisp-0.0.16/src/qrisp/quantum_network/interface/codegen/ttypes.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,86 +1,107 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 #
 # Autogenerated by Thrift Compiler (0.15.0)
 #
 # DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 #
 #  options string: py
 #
 
-from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
-from thrift.protocol.TProtocol import TProtocolException
-from thrift.TRecursive import fix_spec
-
 import sys
 
+from thrift.protocol.TProtocol import TProtocolException
+from thrift.Thrift import (
+    TApplicationException,
+    TException,
+    TFrozenDict,
+    TMessageType,
+    TType,
+)
 from thrift.transport import TTransport
+from thrift.TRecursive import fix_spec
+
 all_structs = []
 
 
 class Qubit(object):
     """
     Attributes:
      - identifier
 
     """
 
-
-    def __init__(self, identifier=None,):
+    def __init__(
+        self,
+        identifier=None,
+    ):
         self.identifier = identifier
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.identifier = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Qubit')
+        oprot.writeStructBegin("Qubit")
         if self.identifier is not None:
-            oprot.writeFieldBegin('identifier', TType.STRING, 1)
-            oprot.writeString(self.identifier.encode('utf-8') if sys.version_info[0] == 2 else self.identifier)
+            oprot.writeFieldBegin("identifier", TType.STRING, 1)
+            oprot.writeString(
+                self.identifier.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.identifier
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -88,56 +109,71 @@
 class Clbit(object):
     """
     Attributes:
      - identifier
 
     """
 
-
-    def __init__(self, identifier=None,):
+    def __init__(
+        self,
+        identifier=None,
+    ):
         self.identifier = identifier
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.identifier = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.identifier = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Clbit')
+        oprot.writeStructBegin("Clbit")
         if self.identifier is not None:
-            oprot.writeFieldBegin('identifier', TType.STRING, 1)
-            oprot.writeString(self.identifier.encode('utf-8') if sys.version_info[0] == 2 else self.identifier)
+            oprot.writeFieldBegin("identifier", TType.STRING, 1)
+            oprot.writeString(
+                self.identifier.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.identifier
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -149,34 +185,48 @@
      - num_qubits
      - num_clbits
      - params
      - definition
 
     """
 
-
-    def __init__(self, name=None, num_qubits=None, num_clbits=None, params=None, definition=None,):
+    def __init__(
+        self,
+        name=None,
+        num_qubits=None,
+        num_clbits=None,
+        params=None,
+        definition=None,
+    ):
         self.name = name
         self.num_qubits = num_qubits
         self.num_clbits = num_clbits
         self.params = params
         self.definition = definition
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
             if fid == 1:
                 if ftype == TType.STRING:
-                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.name = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.I32:
                     self.num_qubits = iprot.readI32()
                 else:
                     iprot.skip(ftype)
@@ -204,50 +254,53 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Operation')
+        oprot.writeStructBegin("Operation")
         if self.name is not None:
-            oprot.writeFieldBegin('name', TType.STRING, 1)
-            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
+            oprot.writeFieldBegin("name", TType.STRING, 1)
+            oprot.writeString(
+                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
+            )
             oprot.writeFieldEnd()
         if self.num_qubits is not None:
-            oprot.writeFieldBegin('num_qubits', TType.I32, 2)
+            oprot.writeFieldBegin("num_qubits", TType.I32, 2)
             oprot.writeI32(self.num_qubits)
             oprot.writeFieldEnd()
         if self.num_clbits is not None:
-            oprot.writeFieldBegin('num_clbits', TType.I32, 3)
+            oprot.writeFieldBegin("num_clbits", TType.I32, 3)
             oprot.writeI32(self.num_clbits)
             oprot.writeFieldEnd()
         if self.params is not None:
-            oprot.writeFieldBegin('params', TType.LIST, 4)
+            oprot.writeFieldBegin("params", TType.LIST, 4)
             oprot.writeListBegin(TType.DOUBLE, len(self.params))
             for iter6 in self.params:
                 oprot.writeDouble(iter6)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.definition is not None:
-            oprot.writeFieldBegin('definition', TType.STRUCT, 5)
+            oprot.writeFieldBegin("definition", TType.STRUCT, 5)
             self.definition.write(oprot)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -257,22 +310,30 @@
     Attributes:
      - op
      - qubits
      - clbits
 
     """
 
-
-    def __init__(self, op=None, qubits=None, clbits=None,):
+    def __init__(
+        self,
+        op=None,
+        qubits=None,
+        clbits=None,
+    ):
         self.op = op
         self.qubits = qubits
         self.clbits = clbits
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -307,45 +368,46 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Instruction')
+        oprot.writeStructBegin("Instruction")
         if self.op is not None:
-            oprot.writeFieldBegin('op', TType.STRUCT, 1)
+            oprot.writeFieldBegin("op", TType.STRUCT, 1)
             self.op.write(oprot)
             oprot.writeFieldEnd()
         if self.qubits is not None:
-            oprot.writeFieldBegin('qubits', TType.LIST, 2)
+            oprot.writeFieldBegin("qubits", TType.LIST, 2)
             oprot.writeListBegin(TType.STRUCT, len(self.qubits))
             for iter19 in self.qubits:
                 iter19.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.clbits is not None:
-            oprot.writeFieldBegin('clbits', TType.LIST, 3)
+            oprot.writeFieldBegin("clbits", TType.LIST, 3)
             oprot.writeListBegin(TType.STRUCT, len(self.clbits))
             for iter20 in self.clbits:
                 iter20.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -356,23 +418,32 @@
      - qubits
      - clbits
      - data
      - init
 
     """
 
-
-    def __init__(self, qubits=None, clbits=None, data=None, init=True,):
+    def __init__(
+        self,
+        qubits=None,
+        clbits=None,
+        data=None,
+        init=True,
+    ):
         self.qubits = qubits
         self.clbits = clbits
         self.data = data
         self.init = init
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -417,52 +488,53 @@
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('QuantumCircuit')
+        oprot.writeStructBegin("QuantumCircuit")
         if self.qubits is not None:
-            oprot.writeFieldBegin('qubits', TType.LIST, 1)
+            oprot.writeFieldBegin("qubits", TType.LIST, 1)
             oprot.writeListBegin(TType.STRUCT, len(self.qubits))
             for iter39 in self.qubits:
                 iter39.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.clbits is not None:
-            oprot.writeFieldBegin('clbits', TType.LIST, 2)
+            oprot.writeFieldBegin("clbits", TType.LIST, 2)
             oprot.writeListBegin(TType.STRUCT, len(self.clbits))
             for iter40 in self.clbits:
                 iter40.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.data is not None:
-            oprot.writeFieldBegin('data', TType.LIST, 3)
+            oprot.writeFieldBegin("data", TType.LIST, 3)
             oprot.writeListBegin(TType.STRUCT, len(self.data))
             for iter41 in self.data:
                 iter41.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.init is not None:
-            oprot.writeFieldBegin('init', TType.BOOL, 4)
+            oprot.writeFieldBegin("init", TType.BOOL, 4)
             oprot.writeBool(self.init)
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
 
@@ -471,21 +543,28 @@
     """
     Attributes:
      - qubits
      - annotation
 
     """
 
-
-    def __init__(self, qubits=None, annotation=None,):
+    def __init__(
+        self,
+        qubits=None,
+        annotation=None,
+    ):
         self.qubits = qubits
         self.annotation = annotation
 
     def read(self, iprot):
-        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
+        if (
+            iprot._fast_decode is not None
+            and isinstance(iprot.trans, TTransport.CReadableTransport)
+            and self.thrift_spec is not None
+        ):
             iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
             return
         iprot.readStructBegin()
         while True:
             (fname, ftype, fid) = iprot.readFieldBegin()
             if ftype == TType.STOP:
                 break
@@ -498,89 +577,196 @@
                         _elem47.read(iprot)
                         self.qubits.append(_elem47)
                     iprot.readListEnd()
                 else:
                     iprot.skip(ftype)
             elif fid == 2:
                 if ftype == TType.STRING:
-                    self.annotation = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
+                    self.annotation = (
+                        iprot.readString().decode("utf-8", errors="replace")
+                        if sys.version_info[0] == 2
+                        else iprot.readString()
+                    )
                 else:
                     iprot.skip(ftype)
             else:
                 iprot.skip(ftype)
             iprot.readFieldEnd()
         iprot.readStructEnd()
 
     def write(self, oprot):
         if oprot._fast_encode is not None and self.thrift_spec is not None:
-            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
+            oprot.trans.write(
+                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
+            )
             return
-        oprot.writeStructBegin('Message')
+        oprot.writeStructBegin("Message")
         if self.qubits is not None:
-            oprot.writeFieldBegin('qubits', TType.LIST, 1)
+            oprot.writeFieldBegin("qubits", TType.LIST, 1)
             oprot.writeListBegin(TType.STRUCT, len(self.qubits))
             for iter48 in self.qubits:
                 iter48.write(oprot)
             oprot.writeListEnd()
             oprot.writeFieldEnd()
         if self.annotation is not None:
-            oprot.writeFieldBegin('annotation', TType.STRING, 2)
-            oprot.writeString(self.annotation.encode('utf-8') if sys.version_info[0] == 2 else self.annotation)
+            oprot.writeFieldBegin("annotation", TType.STRING, 2)
+            oprot.writeString(
+                self.annotation.encode("utf-8")
+                if sys.version_info[0] == 2
+                else self.annotation
+            )
             oprot.writeFieldEnd()
         oprot.writeFieldStop()
         oprot.writeStructEnd()
 
     def validate(self):
         return
 
     def __repr__(self):
-        L = ['%s=%r' % (key, value)
-             for key, value in self.__dict__.items()]
-        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
+        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))
 
     def __eq__(self, other):
         return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
 
     def __ne__(self, other):
         return not (self == other)
+
+
 all_structs.append(Qubit)
 Qubit.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'identifier', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "identifier",
+        "UTF8",
+        None,
+    ),  # 1
 )
 all_structs.append(Clbit)
 Clbit.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'identifier', 'UTF8', None, ),  # 1
+    (
+        1,
+        TType.STRING,
+        "identifier",
+        "UTF8",
+        None,
+    ),  # 1
 )
 all_structs.append(Operation)
 Operation.thrift_spec = (
     None,  # 0
-    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
-    (2, TType.I32, 'num_qubits', None, None, ),  # 2
-    (3, TType.I32, 'num_clbits', None, None, ),  # 3
-    (4, TType.LIST, 'params', (TType.DOUBLE, None, False), None, ),  # 4
-    (5, TType.STRUCT, 'definition', [QuantumCircuit, None], None, ),  # 5
+    (
+        1,
+        TType.STRING,
+        "name",
+        "UTF8",
+        None,
+    ),  # 1
+    (
+        2,
+        TType.I32,
+        "num_qubits",
+        None,
+        None,
+    ),  # 2
+    (
+        3,
+        TType.I32,
+        "num_clbits",
+        None,
+        None,
+    ),  # 3
+    (
+        4,
+        TType.LIST,
+        "params",
+        (TType.DOUBLE, None, False),
+        None,
+    ),  # 4
+    (
+        5,
+        TType.STRUCT,
+        "definition",
+        [QuantumCircuit, None],
+        None,
+    ),  # 5
 )
 all_structs.append(Instruction)
 Instruction.thrift_spec = (
     None,  # 0
-    (1, TType.STRUCT, 'op', [Operation, None], None, ),  # 1
-    (2, TType.LIST, 'qubits', (TType.STRUCT, [Qubit, None], False), None, ),  # 2
-    (3, TType.LIST, 'clbits', (TType.STRUCT, [Clbit, None], False), None, ),  # 3
+    (
+        1,
+        TType.STRUCT,
+        "op",
+        [Operation, None],
+        None,
+    ),  # 1
+    (
+        2,
+        TType.LIST,
+        "qubits",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 2
+    (
+        3,
+        TType.LIST,
+        "clbits",
+        (TType.STRUCT, [Clbit, None], False),
+        None,
+    ),  # 3
 )
 all_structs.append(QuantumCircuit)
 QuantumCircuit.thrift_spec = (
     None,  # 0
-    (1, TType.LIST, 'qubits', (TType.STRUCT, [Qubit, None], False), None, ),  # 1
-    (2, TType.LIST, 'clbits', (TType.STRUCT, [Clbit, None], False), None, ),  # 2
-    (3, TType.LIST, 'data', (TType.STRUCT, [Instruction, None], False), None, ),  # 3
-    (4, TType.BOOL, 'init', None, True, ),  # 4
+    (
+        1,
+        TType.LIST,
+        "qubits",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 1
+    (
+        2,
+        TType.LIST,
+        "clbits",
+        (TType.STRUCT, [Clbit, None], False),
+        None,
+    ),  # 2
+    (
+        3,
+        TType.LIST,
+        "data",
+        (TType.STRUCT, [Instruction, None], False),
+        None,
+    ),  # 3
+    (
+        4,
+        TType.BOOL,
+        "init",
+        None,
+        True,
+    ),  # 4
 )
 all_structs.append(Message)
 Message.thrift_spec = (
     None,  # 0
-    (1, TType.LIST, 'qubits', (TType.STRUCT, [Qubit, None], False), None, ),  # 1
-    (2, TType.STRING, 'annotation', 'UTF8', None, ),  # 2
+    (
+        1,
+        TType.LIST,
+        "qubits",
+        (TType.STRUCT, [Qubit, None], False),
+        None,
+    ),  # 1
+    (
+        2,
+        TType.STRING,
+        "annotation",
+        "UTF8",
+        None,
+    ),  # 2
 )
 fix_spec(all_structs)
 del all_structs
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/interface_connection_example.py` & `qrisp-0.0.16/src/qrisp/quantum_network/interface_connection_example.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,57 +1,54 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 from qrisp.quantum_network.qn_server import QuantumNetworkServer
+from qrisp.quantum_network.quantum_network_session import QuantumNetworkSession
+from qrisp import QuantumFloat, QuantumVariable, h, x
+from qrisp import QuantumBool, QuantumChar
 
-test = QuantumNetworkServer(socket_ip_address = "127.0.0.1", background = True)
+test = QuantumNetworkServer(socket_ip_address="127.0.0.1", background=True)
 test.start()
 
 
-from qrisp.quantum_network.quantum_network_session import QuantumNetworkSession
-
-charlie = QuantumNetworkSession(socket_ip = "127.0.0.1", port = 7070, name = "charlie")
-bob = QuantumNetworkSession(socket_ip = "127.0.0.1", port = 7070, name = "bob")
-
-from qrisp import QuantumVariable, x, h, QuantumFloat
+charlie = QuantumNetworkSession(socket_ip="127.0.0.1", port=7070, name="charlie")
+bob = QuantumNetworkSession(socket_ip="127.0.0.1", port=7070, name="bob")
 
 print("Server creation done")
-qf_1 = QuantumFloat(3, qs = bob)
-qf_2 = QuantumFloat(3, qs = bob)
+qf_1 = QuantumFloat(3, qs=bob)
+qf_2 = QuantumFloat(3, qs=bob)
 
 qf_1[:] = 2
 qf_2[:] = 3
 
-qf_3 = qf_2*qf_1
+qf_3 = qf_2 * qf_1
 
 qf_3 += 3
 
 print("Compilation done")
 
 bob.send_qv(qf_3, "charlie")
 
 
 print("Communication done")
 
 inbox = charlie.update()
 
 print(inbox[0])
 
-from qrisp import QuantumChar, QuantumBool
-
 
 q_ch = QuantumBool()
 q_ch[:] = False
 
 bob.send_qv(q_ch, "charlie")
 
 inbox = charlie.update()
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/qn_client.py` & `qrisp-0.0.16/src/qrisp/quantum_network/qn_client.py`

 * *Files 8% similar despite different names*

```diff
@@ -7,262 +7,279 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
+from qrisp import Qubit
+from qrisp.interface import PortableQubit
 from qrisp.interface.circuit_converter import convert_circuit
 from qrisp.quantum_network.interface.codegen import QuantumNetworkService
 from qrisp.quantum_network.interface.codegen.ttypes import Message
-from qrisp.interface import PortableQubit
-from qrisp import Qubit
+
 
 class QuantumNetworkClient(QuantumNetworkService.Client):
     """
-    This class allows to connect to Qrisp quantum networks.
-    
+    This class allows connecting to Qrisp quantum networks.
+
     Parameters
     ----------
     name : str
-        A nickname such as "Alice" or "Bob", which is used to direct the communication of other users to you.
+        A nickname such as "Alice" or "Bob", which is used to direct the communication
+        of other users to you.
     socket_ip : str
         The IP adress of the QuantumNetworkServer.
     port : int, optional
         The port of the QuantumNetworkServer. The default is 7070.
-        
+
     Examples
     --------
-    
-    We create a QuantumNetworkServer listening on the localhost IP-address an connect the client.
-    
+
+    We create a QuantumNetworkServer listening on the localhost IP-address and connect
+    the client.
+
     >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
     >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
     >>> local_server.start()
     >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
-    
-    
+
+
     """
-    
-    
-    def __init__(self, name, socket_ip, port = None):
-        
-        from thrift.transport import TSocket, TTransport
+
+    def __init__(self, name, socket_ip, port=None):
         from thrift.protocol import TBinaryProtocol
-        
-        if port == None:
+        from thrift.transport import TSocket, TTransport
+
+        if port is None:
             port = 7070
-        #Create the transport for the User Interface to the server
+        # Create the transport for the User Interface to the server
         self.transport = TSocket.TSocket(socket_ip, port)
         # Buffering is critical. Raw sockets are very slow
         self.transport = TTransport.TBufferedTransport(self.transport)
         # Wrap in a protocol
         protocol = TBinaryProtocol.TBinaryProtocol(self.transport)
-        self.socket_ip = socket_ip        
+        self.socket_ip = socket_ip
         # Create a client to use the protocol encoder
-                        
+
         super().__init__(protocol)
-        
+
         # Connect!
         self.transport.open()
-        
-        
+
         self.name = name
         self.register_client(name)
-    
-    #Destructor closes the transport
+
+    # Destructor closes the transport
     def __del__(self):
-    
         self.transport.close()
-        
-    def run(self, qc, shots = None):
+
+    def run(self, qc, shots=None):
         r"""
-        Runs a QuantumCircuit on the client's backend. Note that QuantumNetwork simulations do not support multiple shots, as the quantum state of the network is stored and updated everytime a client sends a query. Multiple shots could yield differing measurement outcomes, which implies an ambiguous quantum state of the network. Nevertheless the results are returned in the form of a dictionary in order to comply with the quantum circuit execution backend interface.
-        
-        Note that it is possible to submit QuantumCircuits which contain qubits, that have not been requested previously. In this case, the qubits names are internally extended by the string "@client_name"  (if they aren't extended in this way already). This is to allow multiple clients to submit circuits with matching qubit names.
+        Runs a QuantumCircuit on the client's backend. Note that QuantumNetwork
+        simulations do not support multiple shots, as the quantum state of the network
+        is stored and updated everytime a client sends a query. Multiple shots could
+        yield differing measurement outcomes, which implies an ambiguous quantum state
+        of the network. Nevertheless, the results are returned in the form of a
+        dictionary in order to comply with the quantum circuit execution backend
+        interface.
+
+        Note that it is possible to submit QuantumCircuits which contain qubits, that
+        have not been requested previously. In this case, the qubits names are
+        internally extended by the string "@client_name"  (if they aren't extended in
+        this way already). This is to allow multiple clients to submit circuits with
+        matching qubit names.
 
         Parameters
         ----------
         qc : QuantumCircuit
             The QuantumCircuit to run.
 
         Returns
         -------
         res : dict
-            A dictionary containing a single key/value pair where the key represents the measurement outcome.
-            
-        
+            A dictionary containing a single key/value pair where the key represents the
+            measurement outcome.
+
+
         Examples
         --------
-        
-        We create a local QuantumNetworkServer, connect a client and run a QuantumCircuit
-        
+
+        We create a local QuantumNetworkServer, connect a client and run a
+        QuantumCircuit.
+
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
         >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
         >>> local_server.start()
         >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
         >>> from qrisp import QuantumCircuit
         >>> qc = QuantumCircuit(2)
         >>> qc.h(0)
         >>> qc.cx(0,1)
         >>> qc.measure([0,1])
         >>> client.run(qc)
         {'11': 1}
-        
+
         We perform another shot
-        
+
         >>> client.run(qc)
         {'01': 1}
 
         After applying the first run command, the quantum state is
 
-        .. math::        
+        .. math::
             \ket{\psi} = \ket{1}\ket{1}
-        
+
         Applying the Hadamard yields
-        
-        .. math::        
+
+        .. math::
             \text{H}_0 \ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})\ket{1}
-        
+
         The CX yields
-        
-        .. math::        
-            \text{CX}_{01} \text{H}_0 \ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0}\ket{1} - \ket{1}\ket{0})
-        
+
+        .. math::
+            \text{CX}_{01} \text{H}_0 \ket{\psi} =
+            \frac{1}{\sqrt{2}}(\ket{0}\ket{1} - \ket{1}\ket{0})
+
         Finally, the measurement collapsed the state into the first summand.
-        
+
         """
         converted_circuit = convert_circuit(qc, "thrift")
-        
+
         res = super().run(converted_circuit, self.name)
-        
+
         return res
-    
 
-        
         qc = super().get_clear_qc(self.name)
-        
+
         return convert_circuit(qc, "qrisp")
 
     def send_qubits(self, recipient, qubits, annotation):
         """
         Sends the specified qubits to another participant of the network.
 
         Parameters
         ----------
         recipient : str
             The recipients name.
         qubits : list[Qubit]
             The list of qubits to send.
         annotation : str
-            A string containing an arbitrary message that is available for the reciepient.
+            A string containing an arbitrary message that is available for the
+            reciepient.
+
 
-        
         Examples
         --------
-        
-        We create a QuantumNetworkServer, connect two clients and distribute a bell pair another client.
-        
+
+        We create a QuantumNetworkServer, connect two clients and distribute a bell pair
+        another client.
+
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
         >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
         >>> local_server.start()
         >>> alice_client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
         >>> bob_client = QuantumNetworkClient(name = "bob", socket_ip = "127.0.0.1")
-        
+
         Now we create the bell pair:
-        
+
         >>> from qrisp import QuantumCircuit
         >>> qc = QuantumCircuit(2)
         >>> qc.h(0)
         >>> qc.cx(0,1)
         >>> alice_client.run(qc)
         {'': 1}
-        
+
         Send one of the qubits to Bob:
-            
+
         >>> alice_client.send_qubits("bob", [qc.qubits[0]], annotation = "Happy birthday!")
-        
+
         Now Bob can measure
-        
+
         >>> messages = bob_client.inbox()
         >>> received_qubits, annotation = messages[0]
         >>> qc = bob_client.get_clear_qc()
         >>> qc.measure(received_qubits)
         >>> bob_client.run(qc)
         {'1': 1}
-        
-        After Bob's measurement, we expect Alice's measurement to yield the same due to `spukhafter Fernwirkung <https://en.wikipedia.org/wiki/Quantum_entanglement#History>`_:
-            
+
+        After Bob's measurement, we expect Alice's measurement to yield the same due to
+        `spukhafter Fernwirkung
+        <https://en.wikipedia.org/wiki/Quantum_entanglement#History>`_:
+
         >>> qc = alice_client.get_clear_qc()
         >>> qc.measure(qc.qubits)
         >>> alice_client.run(qc)
         {'1': 1}
-        
+
 
 
         """
-        
+
         msg = Message([PortableQubit(qb.identifier) for qb in qubits], annotation)
-        
+
         super().send_qubits(self.name, recipient, msg)
 
-    
     def request_qubits(self, amount):
         """
         Creates the specified amount of qubits for the client's backend.
 
         Parameters
         ----------
         amount : int
             The amount of qubits to create.
 
         Returns
         -------
         list[Qubit]
             The qubits created.
-            
+
         Examples
         --------
 
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
         >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
         >>> local_server.start()
-        >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")            
+        >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
         >>> qb_list = client.request_qubits(4)
-        >>> print(qb_list)        
+        >>> print(qb_list)
         [Qubit(qb_0@alice), Qubit(qb_1@alice), Qubit(qb_2@alice), Qubit(qb_3@alice)]
-        
+
         """
-        
+
         qb_list = super().request_qubits(amount, self.name)
-        
+
         return [Qubit(qb.identifier) for qb in qb_list]
 
     def get_clear_qc(self):
         """
-        Returns a QuantumCircuit containing all the qubits that belong to the client at the moment.
-        
-        Note that the qubit names of the run QuantumCircuit are internally extended by the string "@client_name"  (if they aren't extended in this way already). This is to allow multiple clients to submit circuits with matching qubit names.
-        
-        Note that 
+        Returns a QuantumCircuit containing all the qubits that belong to the client at
+        the moment.
+
+        Note that the qubit names of the run QuantumCircuit are internally extended by
+        the string "@client_name"  (if they aren't extended in this way already). This
+        is to allow multiple clients to submit circuits with matching qubit names.
+
+        Note that
 
         Returns
         -------
         QuantumCircuit
             An empty QuantumCircuit containing the qubits, this client may operate on.
-            
+
         Examples
         --------
-        
-        We set up a quantum network, run some QuantumCircuits and retrieve the clear QuantumCircuit:
+
+        We set up a quantum network, run some QuantumCircuits and retrieve the clear
+        QuantumCircuit:
 
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
         >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
         >>> local_server.start()
-        >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")            
+        >>> client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
         >>> from qrisp import QuantumCircuit
         >>> qc_0 = QuantumCircuit(1)
         >>> qc_0.x(0)
         >>> print(qc_0)
               ┌───┐
         qb_8: ┤ X ├
               └───┘
@@ -272,98 +289,104 @@
         >>> print(qc_1)
                 ┌───┐
          qb_26: ┤ H ├
                 └───┘
         >>> client.run(qc_1)
         >>> print(client.get_clear_qc().qubits)
         [Qubit(qb_58@alice), Qubit(qb_77@alice)]
-        
+
         """
         qc = super().get_clear_qc(self.name)
-        
-        return convert_circuit(qc, "qrisp")
 
+        return convert_circuit(qc, "qrisp")
 
     def get_overall_qc(self):
         """
-        Retrieves the QuantumCircuit of all operations that happened in the network so far.
+        Retrieves the QuantumCircuit of all operations that happened in the network so
+        far.
 
         Returns
         -------
         QuantumCircuit
-            The QuantumCircuit containing all operations that happened in this QuantumNetwork.
+            The QuantumCircuit containing all operations that happened in this
+            QuantumNetwork.
 
         Examples
         --------
-        
-        We assume that the commands of the example of the :meth:`send_qubits <qrisp.quantum_network.QuantumNetworkClient.send_qubits>` method have been executed.
-        
+
+        We assume that the commands of the example of the
+        :meth:`send_qubits <qrisp.quantum_network.QuantumNetworkClient.send_qubits>`
+        method have been executed.
+
         >>> print(alice_client.get_overall_qc())
-                      ░ ┌───┐      ░ ┌─┐ ░    
+                      ░ ┌───┐      ░ ┌─┐ ░
         qb_34@alice: ─░─┤ H ├──■───░─┤M├─░────
                       ░ └───┘┌─┴─┐ ░ └╥┘ ░ ┌─┐
         qb_35@alice: ─░──────┤ X ├─░──╫──░─┤M├
                       ░      └───┘ ░  ║  ░ └╥┘
            cb_bob_0: ═════════════════╩═════╬═
-                                            ║ 
+                                            ║
          cb_alice_0: ═══════════════════════╩═
-                                              
-                                    
+
+
         """
-        
-        
+
         qc = super().get_overall_qc()
-        
+
         return convert_circuit(qc, "qrisp")
-    
+
     def inbox(self):
         """
         Returns a list of tuples containing the received qubits and their annotations.
 
         Returns
         -------
         res_list : list[tuple[list[Qubit], str]]
-            A list of tuples containing the send qubits and the annotations.
-        
-        
+            A list of tuples containing the sent qubits and the annotations.
+
+
         Examples
         --------
-        
+
         We send a qubit from one client to another and inspect the inbox
-        
+
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkClient
         >>> local_server = QuantumNetworkServer("127.0.0.1", background = True)
         >>> local_server.start()
         >>> alice_client = QuantumNetworkClient(name = "alice", socket_ip = "127.0.0.1")
         >>> bob_client = QuantumNetworkClient(name = "bob", socket_ip = "127.0.0.1")
-        
+
         Prepare the qubit which will be sent to bob:
-        
+
         >>> from qrisp import QuantumCircuit
         >>> qc = QuantumCircuit(1)
         >>> qc.h(0)
         >>> alice_client.run(qc)
         {'': 1}
-        
+
         Send the qubit to Bob:
-            
+
         >>> alice_client.send_qubits("bob", [qc.qubits[0]], annotation = "Merry christmas!")
-        
+
         Now Bob can check his inbox
-        
+
         >>> messages = bob_client.inbox()
         >>> received_qubits, annotation = messages[0]
         >>> print(received_qubits)
         [Qubit(qb_20@alice)]
         >>> print(annotation)
         Merry christmas!
 
         """
-        
+
         inbox_list = super().inbox(self.name)
-        
+
         res_list = []
-        
+
         for i in range(len(inbox_list)):
-            
-            res_list.append(([Qubit(qb.identifier) for qb in inbox_list[i].qubits], inbox_list[i].annotation))
-        return res_list           
+            res_list.append(
+                (
+                    [Qubit(qb.identifier) for qb in inbox_list[i].qubits],
+                    inbox_list[i].annotation,
+                )
+            )
+        return res_list
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/qn_server.py` & `qrisp-0.0.16/src/qrisp/quantum_network/qn_server.py`

 * *Files 18% similar despite different names*

```diff
@@ -9,179 +9,180 @@
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 import threading
 
-from thrift.transport import TSocket
-from thrift.transport import TTransport
 from thrift.protocol import TBinaryProtocol
-from thrift.server import TServer, TNonblockingServer 
-from qrisp.interface.thrift_interface.stoppable_thrift_server import StoppableThriftServer
-
-from qrisp.quantum_network.interface.codegen.ttypes import Message
+from thrift.server import TNonblockingServer, TServer
+from thrift.transport import TSocket, TTransport
 
+from qrisp import Qubit
+from qrisp.interface import PortableQubit
 from qrisp.interface.circuit_converter import convert_circuit
-
+from qrisp.interface.thrift_interface.stoppable_thrift_server import (
+    StoppableThriftServer,
+)
+from qrisp.quantum_network.interface.codegen.ttypes import Message
 from qrisp.quantum_network.qn_simulator_server import QuantumNetwork
+from qrisp.quantum_network.interface.codegen import QuantumNetworkService
 
-from qrisp.interface import PortableQubit
-from qrisp import Qubit
 
 # Returns the hosts ip
 def get_ip():
     import socket
+
     s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
     s.settimeout(0)
     try:
         # doesn't even have to be reachable
-        s.connect(('10.255.255.255', 1))
+        s.connect(("10.255.255.255", 1))
         IP = s.getsockname()[0]
     except Exception:
-        IP = '127.0.0.1'
+        IP = "127.0.0.1"
     finally:
         s.close()
     return IP
 
 
-
 class QuantumNetworkHandler(QuantumNetwork):
-    
     def run(self, qc, name):
         converted_circuit = convert_circuit(qc, "qrisp")
         return super().run(converted_circuit, name)
 
     def get_clear_qc(self, name):
-        
         qc = super().get_clear_qc(name)
-        
+
         return convert_circuit(qc, "thrift")
-    
-    
+
     def request_qubits(self, amount, name):
-        
         qb_list = super().request_qubits(amount, name)
-        
-        return [PortableQubit(qb.identifier) for qb in qb_list]
 
+        return [PortableQubit(qb.identifier) for qb in qb_list]
 
     def send_qubits(self, sender, recipient, msg):
-        
-        super().send_qubits(sender, recipient, [Qubit(qb.identifier) for qb in msg.qubits], msg.annotation)
-
+        super().send_qubits(
+            sender,
+            recipient,
+            [Qubit(qb.identifier) for qb in msg.qubits],
+            msg.annotation,
+        )
 
     def get_overall_qc(self):
-        
         qc = super().get_overall_qc()
-        
+
         return convert_circuit(qc, "thrift")
-    
+
     def inbox(self, name):
-        
         inbox_list = super().inbox(name)
-        
+
         res_list = []
-        
+
         for i in range(len(inbox_list)):
-            
-            res_list.append(Message([PortableQubit(qb.identifier) for qb in inbox_list[i][0]], inbox_list[i][1]))
+            res_list.append(
+                Message(
+                    [PortableQubit(qb.identifier) for qb in inbox_list[i][0]],
+                    inbox_list[i][1],
+                )
+            )
 
         return res_list
 
-from qrisp.quantum_network.interface.codegen import QuantumNetworkService
- 
+
 class QuantumNetworkServer:
     """
-    This class sets up a server to coordinate the QuantumNetwork. All the simulations are performed in this instance, so the machine running it should preferably have abundant computational resources.
-    
+    This class sets up a server to coordinate the QuantumNetwork. All the simulations
+    are performed in this instance, so the machine running it should preferably have
+    abundant computational resources.
+
     Parameters
     ----------
     socket_ip : str, optional
-        The IP address of the network socket. By default, the IP adress of the executing machine is used.
+        The IP address of the network socket. By default, the IP adress of the executing
+        machine is used.
     port : int, optional
         The port to listen for requests. The default is 7070.
     background : bool, optional
-        If set to True, the server will run in the background as a separate thread. The default is False.
-    
+        If set to True, the server will run in the background as a separate thread.
+        The default is False.
+
     Examples
     --------
-    
+
     We create a server listening to the localhost IP address:
-    
+
     >>> from qrisp.quantum_network import QuantumNetworkServer
     >>> example_server = QuantumNetworkServer(socket_ip = "127.0.0.1")
     >>> example_server.start()
-    
+
     """
-    
-    def __init__(self, socket_ip = None, port = None, background = False):
-        
-        if socket_ip == None:
+
+    def __init__(self, socket_ip=None, port=None, background=False):
+        if socket_ip is None:
             socket_ip = get_ip()
-        
+
         self.socket_ip = socket_ip
-        
+
         self.background = background
         self.port = port
-        
-        
-    #Starts the server
+
+    # Starts the server
     def start(self):
         """
         Starts the server.
 
         Returns
         -------
         None.
 
         """
-        
-        
-        if self.port == None:
+
+        if self.port is None:
             self.port = 7070
-        
-        
+
         self.thread_name = "qn" + ":" + str(self.port)
-        
+
         self.handler = QuantumNetworkHandler()
-        
-        
+
         processor = QuantumNetworkService.Processor(self.handler)
         tfactory = TTransport.TBufferedTransportFactory()
 
-        self.transport = TSocket.TServerSocket(host=self.socket_ip, port=self.port)    
-            
+        self.transport = TSocket.TServerSocket(host=self.socket_ip, port=self.port)
+
         pfactory = TBinaryProtocol.TBinaryProtocolFactory()
-        
-        #server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)
-        # self.server = TServer.TThreadedServer(processor, self.transport, tfactory, pfactory, daemon = True)
-        self.server = StoppableThriftServer(processor, self.transport, tfactory, pfactory, daemon = True)
-        
-        # self.server = TNonblockingServer.TNonblockingServer(processor, self.transport, tfactory, pfactory)
-        
-        if self.background:        
-            #Create thread
-            self.thr = threading.Thread(target = self.server.serve, name = self.thread_name)
+
+        # server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)
+        # self.server = TServer.TThreadedServer(processor, self.transport, tfactory,
+        # pfactory, daemon = True)
+        self.server = StoppableThriftServer(
+            processor, self.transport, tfactory, pfactory, daemon=True
+        )
+
+        # self.server = TNonblockingServer.TNonblockingServer(processor, self.transport,
+        # tfactory, pfactory)
+
+        if self.background:
+            # Create thread
+            self.thr = threading.Thread(target=self.server.serve, name=self.thread_name)
             self.thr.setDaemon(True)
-            
-            #Start the thread
+
+            # Start the thread
             self.thr.start()
         else:
             self.server.serve()
-        
-    
+
     def stop(self):
         """
         Stops the server.
 
         Returns
         -------
         None.
 
         """
         if hasattr(self, "server"):
             self.server.stop()
-    
+
     def __del__(self):
         self.handler.reset_network_state()
-        self.stop()
+        self.stop()
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/qn_simulator_server.py` & `qrisp-0.0.16/src/qrisp/quantum_network/qn_simulator_server.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,189 +1,173 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
 
 
-from qrisp.simulator import ImpureQuantumState, run, QuantumState, single_shot_sim        
-from qrisp import Qubit, Clbit, QuantumCircuit
+from qrisp import Clbit, QuantumCircuit, Qubit
+from qrisp.simulator import ImpureQuantumState, QuantumState, run, single_shot_sim
+
 
 class QuantumNetwork:
-    
     def __init__(self):
-        
         self.qs = QuantumState(0)
         self.qubit_map = {}
         self.overall_circuit = QuantumCircuit()
         self.client_measurement_counter = {}
         self.inbox_dict = {}
         self.qubit_creation_counter = {}
-        
+
     def register_client(self, name):
         if name in list(self.client_measurement_counter.keys()):
             raise Exception("Tried to register an existing client.")
-            
+
         self.client_measurement_counter[name] = 0
         self.inbox_dict[name] = []
         self.qubit_creation_counter[name] = 0
-    
+
     def send_qubits(self, sender, recipient, qubits, annotation):
-        
         keys = list(self.qubit_map.keys())
         ids = keys
-        
+
         qubits = convert_qubit_names(qubits, sender)
-        
+
         for qb in qubits:
-            
             if qb.identifier in ids:
                 index = ids.index(qb.identifier)
-            
+
                 if sender != self.qubit_map[keys[index]]:
                     raise Exception("Tried to send qubit not belonging to sender.")
             else:
                 self.add_qubit(qb, sender)
-                
+
             self.qubit_map[qb.identifier] = recipient
-            
+
         self.inbox_dict[recipient].append((qubits, annotation))
-        
 
     def get_clear_qc(self, name):
-        
         qc = QuantumCircuit()
-        
+
         for key in self.qubit_map.keys():
             if self.qubit_map[key] == name:
                 qc.add_qubit(Qubit(key))
-        
+
         return qc
-    
+
     def request_qubits(self, amount, owner):
-        
-        res_list = []        
+        res_list = []
         for i in range(amount):
-            new_qb = Qubit("qb_" + str(self.qubit_creation_counter[owner]) + "@" + owner)
+            new_qb = Qubit(
+                "qb_" + str(self.qubit_creation_counter[owner]) + "@" + owner
+            )
             self.add_qubit(new_qb, owner)
             res_list.append(new_qb)
-        
+
         return res_list
-            
+
     def add_qubit(self, qubit, owner):
-        
-        if not owner in self.client_measurement_counter.keys():
+        if owner not in self.client_measurement_counter.keys():
             raise Exception("Tried to request qubits for non registered client")
-        
+
         qubit = convert_qubit_names([qubit], owner)[0]
-        
+
         if qubit in self.qubit_map.keys():
             raise Exception("Tried to create already existing qubit")
-        
+
         self.qubit_map[qubit.identifier] = owner
         self.qubit_creation_counter[owner] += 1
         self.overall_circuit.add_qubit(qubit)
         self.qs.add_qubit()
-        
+
         return [qubit]
-    
-        
-                
+
     def run(self, qc, name):
-        
         keys = list(self.qubit_map.keys())
         ids = keys
-        
+
         qc = convert_qc_qubit_names(qc, name)
-        
+
         for qb in qc.qubits:
-            
             if qb.identifier in ids:
                 index = ids.index(qb.identifier)
-                
+
                 if self.qubit_map[keys[index]] != name:
                     raise Exception("Tried to operate one foreign qubits")
-            
+
             else:
                 self.add_qubit(qb, name)
-                
-            
-        
+
         temp_qc = self.overall_circuit.clearcopy()
         temp_qc.clbits = []
-        
+
         translation_dic = {}
-        
+
         for clbit in qc.clbits:
-            overall_qc_clbit = Clbit("cb" + "_" + name + "_" + str(self.client_measurement_counter[name]))
+            overall_qc_clbit = Clbit(
+                "cb" + "_" + name + "_" + str(self.client_measurement_counter[name])
+            )
             self.client_measurement_counter[name] += 1
-            
+
             self.overall_circuit.add_clbit(overall_qc_clbit)
             temp_qc.add_clbit(clbit)
-            
+
             translation_dic[clbit] = overall_qc_clbit
-        
+
         translation_dic.update({qb: qb for qb in qc.qubits})
-        
-        
+
         temp_qc.extend(qc)
-        
-        
+
         res, self.qs = single_shot_sim(temp_qc, self.qs)
-        
-        
+
         self.overall_circuit.barrier()
         self.overall_circuit.extend(qc, translation_dic)
-            
+
         return {res: 1}
-    
+
     def get_overall_qc(self):
         return self.overall_circuit.copy()
-    
+
     def inbox(self, name):
         return self.inbox_dict[name]
-    
+
     def reset_network_state(self):
-        
         self.qs = QuantumState(0)
         self.qubit_map = {}
         self.overall_circuit = QuantumCircuit()
         self.client_measurement_counter = {}
         self.inbox = {}
-        
+
+
 def convert_qc_qubit_names(qc, name):
-    
     res_qc = qc.clearcopy()
-    
+
     res_qc.qubits = convert_qubit_names(qc.qubits, name)
-    
-    transl_dic = {qc.qubits[i].identifier : res_qc.qubits[i] for i in range(len(qc.qubits))}
-    
+
+    transl_dic = {
+        qc.qubits[i].identifier: res_qc.qubits[i] for i in range(len(qc.qubits))
+    }
+
     for instr in qc.data:
-        res_qc.append(instr.op, [transl_dic[qb.identifier] for qb in instr.qubits], instr.clbits)
-    
+        res_qc.append(
+            instr.op, [transl_dic[qb.identifier] for qb in instr.qubits], instr.clbits
+        )
+
     return res_qc
 
+
 def convert_qubit_names(qubits, name):
-    
     res = []
     for i in range(len(qubits)):
         qb = qubits[i]
         if len(qb.identifier.split("@")) == 1:
-            res.append(Qubit(qb.identifier + "@" + name ))
+            res.append(Qubit(qb.identifier + "@" + name))
         else:
             res.append(Qubit(qb.identifier))
-    
-    return res
-    
-    
 
-    
-    
-    
+    return res
```

### Comparing `qrisp-0.0.15/src/qrisp/quantum_network/quantum_network_session.py` & `qrisp-0.0.16/src/qrisp/quantum_network/quantum_network_session.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,190 +6,183 @@
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
-from qrisp.circuit import QuantumCircuit, transpile, QubitAlloc, QubitDealloc
-from qrisp import QuantumSession, QuantumFloat, QuantumChar, QuantumBool, merge
-from qrisp.quantum_network import QuantumNetworkClient
 import numpy as np
 
+from qrisp import QuantumBool, QuantumChar, QuantumFloat, QuantumSession, merge
+from qrisp.circuit import QuantumCircuit, QubitAlloc, QubitDealloc, transpile
+from qrisp.quantum_network import QuantumNetworkClient
+
+
 class QuantumNetworkSession(QuantumSession):
     """
-    This class allows to use Qrisps high-level programming interface to interact with QuantumNetworks. As an inheritor of the QuantumSession class, we can create QuantumVariables with it which can then be sent to other participators of the QuantumNetwork.
-
-    Note that get_measurement calls are also realized by the single-shot simulator. For more information on this check the documentation of the run method of the QuantumNetworkClient class.
+    This class allows using Qrisps high-level programming interface to interact with
+    QuantumNetworks. As an inheritor of the QuantumSession class, we can create
+    QuantumVariables with it which can then be sent to other participators of the
+    QuantumNetwork.
+
+    Note that get_measurement calls are also realized by the single-shot simulator. For
+    more information on this check the documentation of the run method of the
+    QuantumNetworkClient class.
 
     Parameters
     ----------
     name : str
-        A nickname such as "Alice" or "Bob", which is used to direct the communication of other users to you.
+        A nickname such as "Alice" or "Bob", which is used to direct the communication
+        of other users to you.
     socket_ip : str
         The IP of the QuantumNetworkServer to connect to.
     port : int
         The port of the QuantumNetworkServer to connect to. The default is 7070.
 
     Examples
     --------
-    
+
     We create a QuantumNetworkServer and connect a QuantumNetworkSession to it.
-    
+
     >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkSession
     >>> example_server = QuantumNetworkServer(socket_ip = "127.0.0.1", background = True)
     >>> example_server.start()
     >>> alice_session = QuantumNetworkSession(socket_ip = "127.0.0.1", port = 7070, name = "alice")
-    
+
     Now we can create QuantumVariables as we are used to
-    
+
     >>> from qrisp import QuantumFloat
     >>> qf = QuantumFloat(4, 5, qs = alice_session)
 
-    
+
     """
-    
-    def __init__(self, name, socket_ip, port = None):
-        
-        qn_client = QuantumNetworkClient(name = name, socket_ip = socket_ip, port = port)
+
+    def __init__(self, name, socket_ip, port=None):
+        qn_client = QuantumNetworkClient(name=name, socket_ip=socket_ip, port=port)
         self.inbox = []
-    
-        super().__init__(backend = qn_client)
-        
-    
-    
+
+        super().__init__(backend=qn_client)
+
     def send_qv(self, qv, recipient):
         """
         Sends a :ref:`QuantumVariable` to another participant of the network.
 
         Parameters
         ----------
         qv : QuantumVariable
             The QuantumVariable to send.
         recipient : str
             The name of the recipient.
 
         Examples
         --------
-        
+
         We create a QuantumNetworkServer and connect a QuantumNetworkSession to it.
-        
+
         >>> from qrisp.quantum_network import QuantumNetworkServer, QuantumNetworkSession
         >>> example_server = QuantumNetworkServer(socket_ip = "127.0.0.1", background = True)
         >>> example_server.start()
         >>> alice_session = QuantumNetworkSession(socket_ip = "127.0.0.1", port = 7070, name = "alice")
         >>> bob_session = QuantumNetworkSession(socket_ip = "127.0.0.1", port = 7070, name = "bob")
-        
+
         We create a :ref:`QuantumFloat` and perform some arithmetic
-        
+
         >>> from qrisp import QuantumFloat
         >>> qf = QuantumFloat(4, qs = alice_session)
         >>> qf += 3
         >>> alice_session.send_qv(qf, "bob")
-        
+
 
         """
-        
+
         if not qv.qs == self:
             merge(self, qv.qs)
-        
-        
+
         self.backend.run(self)
-        
-        
-        
+
         qv_qubits = list(qv.reg)
-        
-        
+
         type_information = {}
-        
 
-        
         if isinstance(qv, QuantumFloat):
             type_information["qtype"] = "qf"
             type_information["msize"] = str(qv.msize)
             type_information["exponent"] = str(qv.exponent)
             type_information["signed"] = str(int(qv.signed))
         elif isinstance(qv, QuantumChar):
             type_information["qtype"] = "qc"
             type_information["nisq_char"] = str(int(qv.nisq_char))
         elif isinstance(qv, QuantumBool):
             type_information["qtype"] = "qb"
-            
-        
+
         self.backend.send_qubits(recipient, qv_qubits, str(type_information))
-        
+
         qv.delete()
-        
+
         for i in range(len(qv_qubits)):
             self.qubits.remove(qv_qubits[i])
-        
+
         self.data = []
-        
+
     def update(self):
         """
-        This updates the inbox attribute and returns the received QuantumVariables. 
+        This updates the inbox attribute and returns the received QuantumVariables.
 
         Returns
         -------
         received_qvs : list[QuantumVariable]
             The QuantumVariables which have been received since the last update.
 
         Examples
         --------
-        
-        We assume that the commands from the example of the :meth:`send_qv <qrisp.quantum_network.QuantumNetworkSession.send_qv>` method have been executed.
-        
+
+        We assume that the commands from the example of the
+        :meth:`send_qv <qrisp.quantum_network.QuantumNetworkSession.send_qv>` method
+        have been executed.
+
         >>> inbox = bob_session.update()
         >>> print(inbox[0])
         {3.0: 1.0}
 
         """
-        
+
         from qrisp import QuantumVariable
-        
+
         self.backend.run(self)
-        
+
         updated_inbox = self.backend.inbox()
-        
+
         received_qvs = []
         starting_index = int(len(self.inbox))
         from ast import literal_eval
-        
+
         for i in range(starting_index, len(updated_inbox)):
-            
             for qb in updated_inbox[i][0]:
                 self.add_qubit(qb)
-            
+
             try:
                 type_information = literal_eval(updated_inbox[i][1])
             except:
                 type_information = {}
-            
-                
-            
-            new_qv = QuantumVariable(0, qs = self)
-            
-            new_qv.extend(len(updated_inbox[i][0]), proposal = updated_inbox[i][0])
-            
+
+            new_qv = QuantumVariable(0, qs=self)
+
+            new_qv.extend(len(updated_inbox[i][0]), proposal=updated_inbox[i][0])
+
             if len(type_information):
                 if type_information["qtype"] == "qf":
-                    
                     new_qv.__class__ = QuantumFloat
                     new_qv.msize = int(type_information["msize"])
                     new_qv.exponent = int(type_information["exponent"])
                     new_qv.signed = bool(int(type_information["signed"]))
-                    
+
                 if type_information["qtype"] == "qc":
                     new_qv.__class__ = QuantumChar
                     new_qv.nisq_char = bool(int(type_information["nisq_char"]))
-                    
+
                 elif type_information["qtype"] == "qb":
                     new_qv.__class__ = QuantumBool
-                
-                    
-            
-            
+
             received_qvs.append(new_qv)
-            
+
         self.inbox += received_qvs
-        return received_qvs
+        return received_qvs
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/__init__.py` & `qrisp-0.0.16/src/qrisp/simulator/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,19 +1,24 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-from qrisp.simulator.bi_arrays import DenseBiArray, SparseBiArray, DummyBiArray, tensordot, BiArray
-from qrisp.simulator.unitary_management import *
-from qrisp.simulator.simulator import *
-from qrisp.simulator.quantum_state import QuantumState, TensorFactor
-from qrisp.simulator.impure_quantum_state import ImpureQuantumState
-from qrisp.simulator.circuit_reordering import *
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+from qrisp.simulator.bi_arrays import (
+    BiArray,
+    DenseBiArray,
+    DummyBiArray,
+    SparseBiArray,
+    tensordot,
+)
+from qrisp.simulator.circuit_reordering import *
+from qrisp.simulator.impure_quantum_state import ImpureQuantumState
+from qrisp.simulator.quantum_state import QuantumState, TensorFactor
+from qrisp.simulator.simulator import *
+from qrisp.simulator.unitary_management import *
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/circuit_preprocessing.py` & `qrisp-0.0.16/src/qrisp/simulator/circuit_preprocessing.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,715 +1,713 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-
-from qrisp.circuit import transpile, QuantumCircuit, Instruction
-import numpy as np
-import threading
-
-memory_bandwidth_penalty = 2
-
-#This class is supposed to describe a group of instructions
-#The idea behind the grouping is that grouping instructions together allows
-#to precalculate their unitary. This saves alot of time because applying
-#a medium size unitary on a large statevector is more efficient than applying
-#many small unitaries. This estimation is elaborated in the calc_gain method.
-class GroupedInstruction:
-    
-    #The constructor takes a list of instruction (for instance from a quantum circuit)
-    #and a list of indices, which describe which instruction to include in the group
-    #Using the qubits argument, is possible to provide a list of qubits, where the instruction are
-    #acting on. Otherwise the (rather slow) .merge method is used
-    def __init__(self, int_qc, indices, qubits = None):
-        
-        
-        self.gate_signature_list = []
-        
-        if qubits == None:
-            qubit_set = 0
-            
-            for i in range(len(indices)):
-                qubit_set |= int_qc.data[indices[i]]
-            
-            qubit_set = int_to_qb_set(int(qubit_set), int_qc.source)
-        else:
-            qubit_set = set(qubits)
-        
-        self.qubits = list(qubit_set)
-        
-        self.instr_list = int_qc.source.data
-        
-        self.indices = indices
-        
-        #We now calculate the gain by estimating how many floating point operations are performed
-        #for the grouped circuit vs the non-grouped circuit
-        
-        #Consider a statevector s of size 2**n and k small unitaries U_i of shape (2**l, 2**l)
-        #Applying one of the unitaries to the large statevector can be under stood as a block matrix application
-        #(U_i, 0, 0, 0)
-        #(0, U_i, 0, 0)
-        #(0, 0, U_i, 0)
-        #(0, 0, 0, U_i)
-        #ie. 2**(n-l) applications of a (2**l, 2**l) matrix.
-        #Counting the floating point operations we have 2**(n-l)*(2**l)**2 = 2**(n+l) for a single matrix multiplication
-        #Therefore accounting for all k unitaries, we have FLOPS = k*2**(n+l)
-        #If we now group the k unitaries into a medium sized unitary of shape (2**L, 2**L)
-        #we therefore get a FLOP count of FLOPS = 2**(n+L)
-        #Note that this assumes that calculating the medium sized unitary can be calculated for free.
-        #As it turns out, for the scales where the pythonic slowdown of this algorithm does not
-        #decrease the speed, this assumption is largely valid. (Check the calc_circuit_unitary function of unitary_management.py)
-        
-        
-        #Since both FLOP counts scale with 2**n, we simply calculate k*2**l 
-        #(or better the SUM instead of just taking the product) and 2**L
-        
-        self.gain = 0
-        for i in range(len(indices)):
-            self.gain += (1<<self.instr_list[indices[i]].op.num_qubits)# + memory_bandwidth_penalty
-        
-        self.gain = self.gain - 2**len(self.qubits)*0.45
-    
-    def get_instruction(self):
-        #Create the QuantumCircuit which describes this group of instructions
-                
-        #Else create a quantum circuit from the given qubits
-        temp_qc = QuantumCircuit()
-        temp_qc.qubits = self.qubits
-            
-        for i in range(len(self.indices)):
-            for cb in self.instr_list[self.indices[i]].clbits:
-                try:
-                    temp_qc.add_clbit(cb)
-                except:
-                    pass
-            
-            temp_qc.data.append(self.instr_list[self.indices[i]])
-        #Create instruction
-        self.instruction = Instruction(temp_qc.to_op(), temp_qc.qubits, temp_qc.clbits)
-        
-        return self.instruction
-
-
-#The idea is now to iterate through different groupings and find the one with the most gain.
-def group_qc(qc):
-    
-    #This parameter describes how deep the search for good groupings should go
-    max_recursion_depth = optimal_grouping_recursion_parameter(len(qc.qubits)) + 12
-    
-    
-    #Set up list of grouped instructions
-    grouped_instr_list = []
-    
-    #We now succesively remove gates from the front of the circuit that either
-    #have been determined as group or can't be grouped (because they are non-unitary)
-    
-    
-    int_qc = IntegerCircuit(qc)
-    while qc.data:
-        
-        #If the instruction is non unitary, remove
-        #if qc.data[0].op.name in ["measure", "reset", "disentangle"] or (qc.data[0].op.name == "pt_permutation" and qc.data[0].op.num_qubits > 7):
-        if int_qc.data[0] < 0:
-            grouped_instr_list.append(int_qc.source.data.pop(0))
-            int_qc.data.pop(0)
-            continue
-        
-        #Find the best grouping        
-        group = find_group(int_qc, max_recursion_depth)
-        
-        
-        #Append the grouped instruction to the result list
-        # grouped_instr_list.append(group.instruction)
-        grouped_instr_list.append(group.get_instruction())
-        
-        
-        #Delete the instructions from the circuit
-        delete_multiple_element(int_qc.source.data, group.indices)
-        delete_multiple_element(int_qc.data, group.indices)
-        
-        
-        
-    
-    #Creat resulting circuit
-    grouped_qc = qc.clearcopy()
-    for i in range(len(grouped_instr_list)):
-        grouped_qc.data.append(grouped_instr_list[i])
-        
-    return grouped_qc
-
-
-
-#This function determines a set of grouping options and chooses the best option
-def find_group(int_qc, max_recursion_depth):
-    
-    try:
-        int_qc.data = np.array(int_qc.data, dtype = np.int64)
-    except OverflowError:
-        pass
-    grouping_options = find_grouping_options(int_qc, [], max_recursion_depth)
-    
-    int_qc.data = list(int_qc.data)
-    # print(len(grouping_options))
-    return_index = np.argmax([gi.gain for gi in grouping_options])
-    
-    if grouping_options[return_index].gain > 0:
-        return grouping_options[return_index]
-    
-    return GroupedInstruction(int_qc, [0])
-
-
-
-#The groupings are determined by choosing a set of qubits and then trying which instructions
-#can be executed on these qubits without "leaving" this set of qubits.
-def find_grouping_options(int_qc, traversed_qb_sets, max_recursion_depth, qubits = None, established_indices = []):
-    
-    #If no set of qubit is proposed, we search for the instructions that could
-    #be executed now (ie. in a QuantumCircuit they would be on the left end)
-    #and search for groups starting with these instructions
-    
-    if qubits is None:
-        qubits = int_qc.data[0]
-        established_indices = [0]    
-        
-    
-    #Log that this qubit constellation has been traversed
-    #traversed_qb_sets.append(sum([hash(qb) for qb in qubits]))
-    traversed_qb_sets.append(qubits)
-    
-    #Get the indices of the instructions that can be executed without leaving the given set of qubits
-    #Additionally this function returns the list expansion_options:
-    #This list contains qubits that could be included in the group
-    # instruction_indices, expansion_options = get_circuit_block(int_qc.source.data, int_to_qb_set(qubits, int_qc.source), list(established_indices))
-    
-    
-    instruction_indices, expansion_options = get_circuit_block_(int_qc, qubits, np.array(established_indices))
-    
-    #Create the list of grouping options
-    # options = [GroupedInstruction(qc.source.data, instruction_indices,  qubits)]
-    options = [GroupedInstruction(int_qc, instruction_indices, int_to_qb_set(qubits, int_qc.source))]
-    
-    #Check some conditions that determine if no further recursion should be performed    
-    if len(expansion_options) == 0 or max_recursion_depth == 0 or len(int_to_qb_set(qubits, int_qc.source)) >= 7:
-        return options
-    
-    
-    #Now, include the proposed expansion options
-    for i in range(len(expansion_options)):
-        
-        #Calculate the hash of the proposed set of qubits
-        #proposed_set = sum([hash(qb) for qb in qubits + [expansion_options[i]]])
-        proposed_set = qubits | qb_set_to_int([expansion_options[i]], int_qc.source)
-        # proposed_set = qubits.union(BinaryQubitSet([expansion_options[i]], qc.source))
-        
-        #If this set has not been checked yet, add to the options
-        if not proposed_set in traversed_qb_sets:
-            #options += find_grouping_options(qc_data, traversed_qb_sets, max_recursion_depth - 1, qubits = qubits + [expansion_options[i]], established_indices = list(instruction_indices))
-            options += find_grouping_options(int_qc, traversed_qb_sets, max_recursion_depth - 1, qubits = proposed_set, established_indices = (instruction_indices))
-            
-    return options
-
-
-
-
-#This function returns the indices of the instructions of a circuit,
-#where the returned can be executed by only "staying inside" a given set of qubits
-def get_circuit_block(qc_data, qubits, established_indices = []):
-    
-    #Copy set in order to prevent modification
-    qubits = set(qubits)
-    
-    #Set up set of expansion options
-    expansion_options = set([])
-    
-    #Set up result list
-    instruction_indices = []
-    
-    #Now iterate through all the given instructions
-    for i in range(len(qc_data)):
-        
-        if len(qubits) == 0:
-            break
-        
-        #If the instruction has been identified as part of the group
-        #in a previous recursion, skip the checking and add to the list
-        #of instructions
-        if len(established_indices):
-            if established_indices[0] == i:
-                instruction_indices.append(established_indices.pop(0))
-                continue
-        
-        #Set some aliases
-        instr = qc_data[i]
-        instr_qubits = set(instr.qubits)
-        
-        #Determine the intersection between the qubits of the instruction
-        #and the qubits of the group
-        intersection = instr_qubits.intersection(qubits)
-        
-        #If the intersection is empty, this instruction is not part of the group
-        #and no further action needs to be taken
-        if not intersection:
-            continue
-        
-        #If the instruction is non-unitary, no further instruction
-        #on this qubit can be part of the group
-        if instr.op.name in ["measure", "reset", "disentangle"]:
-            qubits = qubits - instr_qubits
-            continue
-        
-        #If the instruction qubits are part of the group qubits,
-        #add the instruction to the group
-        if instr_qubits.issubset(qubits):
-            instruction_indices.append(i)
-            
-        #Otherwise, the instruction happens partly on the group qubits,
-        #partly outside. Therefore we need to remove the qubits
-        #that interact with the outside.
-        #Nevertheless, we add the "outside" qubits to the set of expansion options
-        else:
-            qubits = qubits - intersection
-            expansion_options = expansion_options.union(instr_qubits - intersection)
-            
-        
-    #Return result
-    return instruction_indices, list(expansion_options)
-
-
-#Empirically determined parameters that seem to work best
-def optimal_grouping_recursion_parameter(qubit_amount):
-    if qubit_amount <= 16:
-        return 2
-    elif 16 < qubit_amount <= 20:
-        return 3
-    elif 20 < qubit_amount <= 24:
-        return 4
-    elif 24 < qubit_amount <= 28:
-        return 6
-    elif 28 < qubit_amount <= 32:
-        return 7
-    elif 32 < qubit_amount < 35:
-        return 8
-    else:
-        return 9
-
-
-#This function inserts disentangling operations into the circuit, if suited
-#Consider the following circuit
-#             ┌───┐                         
-# qubit_3362: ┤ H ├──■──────────────────────
-#             └───┘┌─┴─┐┌───┐               
-# qubit_3363: ─────┤ x ├┤ H ├──■────────────
-#                  └───┘└───┘┌─┴─┐┌────────┐
-# qubit_3364: ───────────────┤ x ├┤ P(0.3) ├
-#                            └───┘└────────┘
-#If we dont the gates after the first CNOT with U,
-#the resulting state is
-# 2**-0.5*(|0>U|0> + |1>U|1>)
-#Since we are not interested in the wave-function but in the resulting
-#probabilities, it is now safe to evaluate both summands of the wave function
-#separately, ie. evaluate |0>U|0> and |1>U|1> and multiply the resulting,
-#probabilities with 2**-0.5.
-#This is possible because there is not going to be any interaction between the to states
-# (TO-DO better proof required)
-#Therefore the workflow for performing the disentangling is
-#1. Identify position to insert disentangler (here: directly behind the first CNOT)
-#2. Perform measurement (to acquire classical probabilities)
-#3. Continue the simulation on the two decoherent states
-
-#Simulating both states separately has two advantages
-#1. If one of the branches has probability zero, this will show up in the measurement
-#   and we dont have to continue the simulation of this branch
-#2. Simulating two states that don't interact is easier to parallelize
-
-#As it turns out, it is even possible to disentangle this circuit right
-#after the first H gate on qubit zero
-
-
-#              ┌───┐     ┌────────┐                    
-# qubit_10119: ┤ H ├──■──┤ P(0.2) ├─────────────────■──
-#              └───┘┌─┴─┐└─┬───┬──┘                 │  
-# qubit_10120: ─────┤ x ├──┤ H ├─────■──────────────┼──
-#                   └───┘  └───┘   ┌─┴─┐┌────────┐┌─┴─┐
-# qubit_10121: ────────────────────┤ x ├┤ P(0.3) ├┤ x ├
-#                                  └───┘└────────┘└───┘
-
-
-#This is because all the gates after the H-gate are permeable on this qubit
-#(for an elaboration on permeability check the uncomputation module)
-#Roughly said, a gate U which is permeable on the first qubit behaves like this
-# U|0>|a> = exp(i*phi_0) |0> U_0 |a>
-# U|1>|b> = exp(i*phi_1) |0> U_1 |b>
-
-
-def insert_disentangling(qc):
-    #This function checks for permeability on a given qubit
-    from qrisp.uncomputation import is_permeable
-    
-    from qrisp import Instruction, Operation
-    
-    #Create disentangling operation
-    disentangler = Operation("disentangle", num_qubits = 1)
-    disentangler.permeability = {0 : False}
-    
-    #After all the operations have been performed on a qubit,
-    #it can be reset without changing the statistics
-    for i in range(len(qc.qubits)):
-        qc.reset(qc.qubits[i])
-        # qc.append(disentangler, [qc.qubits[i]])
-    
-    # return qc
-    
-    #We now insert the disentanglers at every position which
-    #is only separated by permeable operations to the final operation
-    #of that qubit
-    reversed_data = list(qc.data)[::-1]
-    
-    disentangling_counter = 0
-    i = 0
-    while i< len(reversed_data):
-        
-        if not reversed_data[i].op.name in ["measure", "reset"]:
-            i += 1
-            continue
-        
-        
-        qubit = reversed_data[i].qubits[0]
-        j = int(i)
-        
-        while j < len(reversed_data):
-            instr = reversed_data[j]
-            if qubit in instr.qubits:
-                
-                if instr.op.name in ["measure", "reset", "disentangle"]:
-                    j += 1
-                    continue
-                
-                #Find qubit index
-                qubit_index = instr.qubits.index(qubit)
-                
-                if is_permeable(instr.op, [qubit_index]):
-                    #If so, insert disentangler before this instruction
-                    reversed_data.insert(j+1, Instruction(disentangler, [qubit]))
-                    disentangling_counter += 1
-                    j += 1
-                    
-                
-                else:
-                    break
-            j += 1
-        
-        i += 1
-    
-    # #For every qubit, we traverse the circuit from the back,
-    # #until we find an operation which is not permeable on that qubit
-    # for i in range(len(qc.qubits)):
-        
-    #     #Set qubit alias
-    #     qb = qc.qubits[i]
-    #     j = -1
-    #     while j < len(reversed_data)-1:
-    #         j += 1
-            
-    #         #Set alias for instruction that is to be checked
-    #         instr = reversed_data[j]
-            
-    #         #If the instruction is a reset, measurement or disentangling,
-    #         #it performs the same operation as a disentangler, therefore
-    #         #we can safely insert further disentanlger before it
-    #         if instr.op.name in ["measure", "reset", "disentangle"]:
-    #             continue
-            
-    #         #If the instruction acts on the qubit in question,
-    #         #check if the instruction is permeable on this qubit
-    #         if qb in instr.qubits:
-                
-    #             #Find qubit index
-    #             qubit_index = instr.qubits.index(qb)
-                
-    #             #Check for permeability
-    #             if is_permeable(instr.op, [qubit_index]):
-                    
-    #                 #If so, insert disentangler before this instruction
-    #                 reversed_data.insert(j+1, Instruction(disentangler, [qb]))
-    #                 disentangling_counter += 1
-    #             #Otherwise, we can no longer insert disentanglers
-    #             else:
-    #                 break
-                
-    #Create output quantum circuit
-    new_qc = qc.clearcopy()
-    new_qc.data = reversed_data[::-1]
-    
-    return new_qc
-
-#Simple function to count the amount of measurements in a circuit,
-#this is helpfull, because we don't need to continue the simulation,
-#once all measurements have been performed
-def count_measurements_and_treat_alloc(qc, insert_reset = True):
-    counter = 0
-    i = 0
-    
-    while i < len(qc.data):
-        instr = qc.data[i]
-        
-        if instr.op.name == "barrier":
-            qc.data.pop(i)
-            continue
-        
-        if instr.op.name == "measure":
-            counter += 1
-        elif instr.op.name == "qb_alloc":
-            pass
-            qc.data.pop(i)
-            continue
-        elif instr.op.name == "qb_dealloc":
-            if insert_reset:
-                instr.op.name = "reset"
-            else:
-                qc.data.pop(i)
-                continue
-            
-        
-        i += 1
-    return counter
-
-
-
-
-def delete_multiple_element(list_object, indices):
-    indices = sorted(indices, reverse=True)
-    for idx in indices:
-        if idx < len(list_object):
-            list_object.pop(idx)
-            
-            
-
-def qb_set_to_int(qubits, qc):
-    res = 0
-    for qb in qubits:
-        res |= 1<<qc.qubits.index(qb)
-    return res
-
-
-def qc_to_int_list(qc):
-    res_list = []
-    for instr in qc.data:
-        res_list.append(qb_set_to_int(instr.qubits, qc))
-        if instr.op.name in ["measure", "reset", "disentangle"] or (instr.op.name.find("c_if") != -1):
-            res_list[-1] *= -1
-        
-    return res_list
-
-
-#Copy set in order to prevent modification
-#qubits = set(qubits)
-def get_circuit_block_(int_qc, qubits, established_indices = []):
-    
-    #qubits = qb_set_to_int(qubits, qc.source)
-    n = int_qc.n
-
-    #If the qubits int is to large to fit into np.int64, we use the non jitted version
-    if isinstance(int_qc.data, np.ndarray):
-        instruction_indices, expansion_options = binary_get_circuit_block_jitted(int_qc.data, qubits, n, established_indices)
-    else:
-        instruction_indices, expansion_options = binary_get_circuit_block(int_qc.data, qubits, n, np.array(established_indices, dtype = np.int64))
-    
-    return instruction_indices, int_to_qb_set(expansion_options, int_qc.source)
-    #return instruction_indices, expansion_options.to_qubit_list()
-    
-from numba import njit
-
-
-@njit
-def binary_get_circuit_block_jitted(int_qc_list, qubits, n, established_indices):
-    
-    
-    #Set up set of expansion options
-    expansion_options = 0
-    
-    #Set up result list
-    instruction_indices = []
-    ee_counter = 0
-    #Now iterate through all the given instructions
-    for i in range(len(int_qc_list)):
-        
-        if qubits == 0:
-            break
-        
-        #If the instruction has been identified as part of the group
-        #in a previous recursion, skip the checking and add to the list
-        #of instructions
-        if ee_counter < len(established_indices):
-            if established_indices[ee_counter] == i:
-                ee_counter += 1
-                instruction_indices.append(i)
-                continue
-        
-        #Set some aliases
-        instr_qubits = int_qc_list[i]
-        #instr = qc.data[i]
-        #instr_qubits = set(instr.qubits)
-        
-        #Determine the intersection between the qubits of the instruction
-        #and the qubits of the group
-        # intersection = instr_qubits.intersection(qubits)
-        intersection = qubits & instr_qubits
-        
-        #If the intersection is empty, this instruction is not part of the group
-        #and no further action needs to be taken
-        if not intersection:
-            continue
-        
-        #If the instruction is non-unitary, no further instruction
-        #on this qubit can be part of the group
-        if instr_qubits < 0:
-            qubits = qubits & (((1<<n)-1)^instr_qubits)
-            #qubits = qubits - instr_qubits
-            continue
-        
-        #If the instruction qubits are part of the group qubits,
-        #add the instruction to the group
-        if not bool((((1<<n)-1)^qubits) & instr_qubits):
-        #if instr_qubits.issubset(qubits):
-            instruction_indices.append(i)
-            
-        #Otherwise, the instruction happens partly on the group qubits,
-        #partly outside. Therefore we need to remove the qubits
-        #that interact with the outside.
-        #Nevertheless, we add the "outside" qubits to the set of expansion options
-        else:
-            qubits = qubits & (((1<<n)-1)^intersection)
-            # qubits = qubits - intersection
-            expansion_options = expansion_options | (instr_qubits & (((1<<n)-1)^intersection))
-            # expansion_options = expansion_options.union(instr_qubits - intersection)
-            
-        
-    #Return result
-    return instruction_indices, expansion_options
-
-def binary_get_circuit_block(int_qc_list, qubits, n, established_indices):
-    
-    
-    #Set up set of expansion options
-    expansion_options = 0
-    
-    #Set up result list
-    instruction_indices = []
-    ee_counter = 0
-    #Now iterate through all the given instructions
-    for i in range(len(int_qc_list)):
-        
-        if qubits == 0:
-            break
-        
-        #If the instruction has been identified as part of the group
-        #in a previous recursion, skip the checking and add to the list
-        #of instructions
-        if ee_counter < len(established_indices):
-            if established_indices[ee_counter] == i:
-                ee_counter += 1
-                instruction_indices.append(i)
-                continue
-        
-        #Set some aliases
-        instr_qubits = int_qc_list[i]
-        #instr = qc.data[i]
-        #instr_qubits = set(instr.qubits)
-        
-        #Determine the intersection between the qubits of the instruction
-        #and the qubits of the group
-        # intersection = instr_qubits.intersection(qubits)
-        intersection = qubits & instr_qubits
-        
-        #If the intersection is empty, this instruction is not part of the group
-        #and no further action needs to be taken
-        if not intersection:
-            continue
-        
-        #If the instruction is non-unitary, no further instruction
-        #on this qubit can be part of the group
-        if instr_qubits < 0:
-            qubits = qubits & (((1<<n)-1)^instr_qubits)
-            #qubits = qubits - instr_qubits
-            continue
-        
-        #If the instruction qubits are part of the group qubits,
-        #add the instruction to the group
-        if not bool((((1<<n)-1)^qubits) & instr_qubits):
-        #if instr_qubits.issubset(qubits):
-            instruction_indices.append(i)
-            
-        #Otherwise, the instruction happens partly on the group qubits,
-        #partly outside. Therefore we need to remove the qubits
-        #that interact with the outside.
-        #Nevertheless, we add the "outside" qubits to the set of expansion options
-        else:
-            qubits = qubits & (((1<<n)-1)^intersection)
-            # qubits = qubits - intersection
-            expansion_options = expansion_options | (instr_qubits & (((1<<n)-1)^intersection))
-            # expansion_options = expansion_options.union(instr_qubits - intersection)
-            
-        
-    #Return result
-    return instruction_indices, expansion_options
-
-
-
-def int_to_qb_set(integer, qc):
-    res = []
-    for i in range(len(qc.qubits)):
-        if int(integer) & (1<<i):
-            res.append(qc.qubits[i])
-    
-    return res
-
-class IntegerCircuit:
-    
-    def __init__(self, qc):
-        
-        self.source = qc
-        self.data = qc_to_int_list(qc)
-        self.n = len(qc.qubits)
-
-
-def average_group_size(qc):
-    average_group_size = 0
-    
-    for i in range(len(qc.data)):
-        if qc.data[i].op.definition:
-            average_group_size += len(qc.data[i].op.definition.data)
-        else:
-            average_group_size += 1
-    
-    return average_group_size/len(qc.data)
-    
-
-#Wrapping function for all preproccessing operations
-def circuit_preprocessor(qc):
-    #from qrisp.simulator.permutation_identification import group_pt_permutations
-    from qrisp.simulator import reorder_circuit
-    
-    if len(qc.data) == 0:
-        return qc.copy()
-
-    #TO-DO find reliable classifiaction when automatic disentangling works best
-    if len(qc.qubits) < 26:
-        qc = group_qc(qc)
-    elif len(qc.qubits) < 34:
-        qc = group_qc(qc)
-        qc = insert_disentangling(qc)
-    else:
-        qc = insert_disentangling(qc)
-        qc = group_qc(qc)
-
-    return reorder_circuit(qc, ["measure", "reset", "disentangle"])
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+
+import threading
+
+import numpy as np
+from numba import njit
+
+from qrisp.circuit import Instruction, QuantumCircuit, transpile
+
+memory_bandwidth_penalty = 2
+
+
+# This class is supposed to describe a group of instructions
+# The idea behind the grouping is that grouping instructions together allows
+# to precalculate their unitary. This saves alot of time because applying
+# a medium size unitary on a large statevector is more efficient than applying
+# many small unitaries. This estimation is elaborated in the calc_gain method.
+class GroupedInstruction:
+    # The constructor takes a list of instruction (for instance from a quantum circuit)
+    # and a list of indices, which describe which instruction to include in the group
+    # Using the qubits argument, is possible to provide a list of qubits, where the
+    # instruction are acting on. Otherwise, the (rather slow) .merge method is used
+    def __init__(self, int_qc, indices, qubits=None):
+        self.gate_signature_list = []
+
+        if qubits == None:
+            qubit_set = 0
+
+            for i in range(len(indices)):
+                qubit_set |= int_qc.data[indices[i]]
+
+            qubit_set = int_to_qb_set(int(qubit_set), int_qc.source)
+        else:
+            qubit_set = set(qubits)
+
+        self.qubits = list(qubit_set)
+
+        self.instr_list = int_qc.source.data
+
+        self.indices = indices
+
+        # We now calculate the gain by estimating how many floating point operations are
+        # performed for the grouped circuit vs the non-grouped circuit
+
+        # Consider a statevector s of size 2**n and k small unitaries U_i of shape
+        # (2**l, 2**l). Applying one of the unitaries to the large statevector can be
+        # understood as a block matrix application
+        # (U_i, 0, 0, 0)
+        # (0, U_i, 0, 0)
+        # (0, 0, U_i, 0)
+        # (0, 0, 0, U_i)
+        # i.e. 2**(n-l) applications of a (2**l, 2**l) matrix.
+
+        # Counting the floating point operations we have 2**(n-l)*(2**l)**2 = 2**(n+l)
+        # for a single matrix multiplication. Therefore, accounting for all k unitaries,
+        # we have FLOPS = k*2**(n+l). If we now group the k unitaries into a medium
+        # sized unitary of shape (2**L, 2**L) we therefore get a FLOP count of
+        # FLOPS = 2**(n+L). Note that this assumes that calculating the medium-sized
+        # unitary can be calculated for free. As it turns out, for the scales where the
+        # pythonic slowdown of this algorithm does not decrease the speed, this
+        # assumption is largely valid. (Check the calc_circuit_unitary function of
+        # unitary_management.py)
+
+        # Since both FLOP counts scale with 2**n, we simply calculate k*2**l
+        # (or better the SUM instead of just taking the product) and 2**L
+
+        self.gain = 0
+        for i in range(len(indices)):
+            self.gain += (
+                1 << self.instr_list[indices[i]].op.num_qubits
+            )  # + memory_bandwidth_penalty
+
+        self.gain = self.gain - 2 ** len(self.qubits) * 0.45
+
+    def get_instruction(self):
+        # Create the QuantumCircuit which describes this group of instructions
+
+        # Else create a quantum circuit from the given qubits
+        temp_qc = QuantumCircuit()
+        temp_qc.qubits = self.qubits
+
+        for i in range(len(self.indices)):
+            for cb in self.instr_list[self.indices[i]].clbits:
+                try:
+                    temp_qc.add_clbit(cb)
+                except:
+                    pass
+
+            temp_qc.data.append(self.instr_list[self.indices[i]])
+        # Create instruction
+        self.instruction = Instruction(temp_qc.to_op(), temp_qc.qubits, temp_qc.clbits)
+
+        return self.instruction
+
+
+# The idea is now to iterate through different groupings and find the one with the most
+# gain.
+def group_qc(qc):
+    # This parameter describes how deep the search for good groupings should go
+    max_recursion_depth = optimal_grouping_recursion_parameter(len(qc.qubits)) + 12
+
+    # Set up list of grouped instructions
+    grouped_instr_list = []
+
+    # We now succesively remove gates from the front of the circuit that either
+    # have been determined as group or can't be grouped (because they are non-unitary)
+
+    int_qc = IntegerCircuit(qc)
+    while qc.data:
+        # If the instruction is non unitary, remove
+        # if qc.data[0].op.name in ["measure", "reset", "disentangle"] or
+        # (qc.data[0].op.name == "pt_permutation" and qc.data[0].op.num_qubits > 7):
+        if int_qc.data[0] < 0:
+            grouped_instr_list.append(int_qc.source.data.pop(0))
+            int_qc.data.pop(0)
+            continue
+
+        # Find the best grouping
+        group = find_group(int_qc, max_recursion_depth)
+
+        # Append the grouped instruction to the result list
+        # grouped_instr_list.append(group.instruction)
+        grouped_instr_list.append(group.get_instruction())
+
+        # Delete the instructions from the circuit
+        delete_multiple_element(int_qc.source.data, group.indices)
+        delete_multiple_element(int_qc.data, group.indices)
+
+    # Creat resulting circuit
+    grouped_qc = qc.clearcopy()
+    for i in range(len(grouped_instr_list)):
+        grouped_qc.data.append(grouped_instr_list[i])
+
+    return grouped_qc
+
+
+# This function determines a set of grouping options and chooses the best option
+def find_group(int_qc, max_recursion_depth):
+    try:
+        int_qc.data = np.array(int_qc.data, dtype=np.int64)
+    except OverflowError:
+        pass
+    grouping_options = find_grouping_options(int_qc, [], max_recursion_depth)
+
+    int_qc.data = list(int_qc.data)
+    # print(len(grouping_options))
+    return_index = np.argmax([gi.gain for gi in grouping_options])
+
+    if grouping_options[return_index].gain > 0:
+        return grouping_options[return_index]
+
+    return GroupedInstruction(int_qc, [0])
+
+
+# The groupings are determined by choosing a set of qubits and then trying which
+# instructions can be executed on these qubits without "leaving" this set of qubits.
+def find_grouping_options(
+    int_qc, traversed_qb_sets, max_recursion_depth, qubits=None, established_indices=[]
+):
+    # If no set of qubit is proposed, we search for the instructions that could
+    # be executed now (ie. in a QuantumCircuit they would be on the left end)
+    # and search for groups starting with these instructions
+
+    if qubits is None:
+        qubits = int_qc.data[0]
+        established_indices = [0]
+
+    # Log that this qubit constellation has been traversed
+    # traversed_qb_sets.append(sum([hash(qb) for qb in qubits]))
+    traversed_qb_sets.append(qubits)
+
+    # Get the indices of the instructions that can be executed without leaving the given
+    # set of qubits. Additionally, this function returns the list expansion_options:
+    # This list contains qubits that could be included in the group
+    # instruction_indices, expansion_options = get_circuit_block(int_qc.source.data,
+    # int_to_qb_set(qubits, int_qc.source), list(established_indices))
+
+    instruction_indices, expansion_options = get_circuit_block_(
+        int_qc, qubits, np.array(established_indices)
+    )
+
+    # Create the list of grouping options
+    # options = [GroupedInstruction(qc.source.data, instruction_indices,  qubits)]
+    options = [
+        GroupedInstruction(
+            int_qc, instruction_indices, int_to_qb_set(qubits, int_qc.source)
+        )
+    ]
+
+    # Check some conditions that determine if no further recursion should be performed
+    if (
+        len(expansion_options) == 0
+        or max_recursion_depth == 0
+        or len(int_to_qb_set(qubits, int_qc.source)) >= 7
+    ):
+        return options
+
+    # Now, include the proposed expansion options
+    for i in range(len(expansion_options)):
+        # Calculate the hash of the proposed set of qubits
+        # proposed_set = sum([hash(qb) for qb in qubits + [expansion_options[i]]])
+        proposed_set = qubits | qb_set_to_int([expansion_options[i]], int_qc.source)
+        # proposed_set = qubits.union(BinaryQubitSet([expansion_options[i]], qc.source))
+
+        # If this set has not been checked yet, add to the options
+        if not proposed_set in traversed_qb_sets:
+            # options += find_grouping_options(qc_data, traversed_qb_sets,
+            # max_recursion_depth - 1, qubits = qubits + [expansion_options[i]],
+            # established_indices = list(instruction_indices))
+            options += find_grouping_options(
+                int_qc,
+                traversed_qb_sets,
+                max_recursion_depth - 1,
+                qubits=proposed_set,
+                established_indices=(instruction_indices),
+            )
+
+    return options
+
+
+# This function returns the indices of the instructions of a circuit,
+# where the returned can be executed by only "staying inside" a given set of qubits
+def get_circuit_block(qc_data, qubits, established_indices=[]):
+    # Copy set in order to prevent modification
+    qubits = set(qubits)
+
+    # Set up set of expansion options
+    expansion_options = set([])
+
+    # Set up result list
+    instruction_indices = []
+
+    # Now iterate through all the given instructions
+    for i in range(len(qc_data)):
+        if len(qubits) == 0:
+            break
+
+        # If the instruction has been identified as part of the group
+        # in a previous recursion, skip the checking and add to the list
+        # of instructions
+        if len(established_indices):
+            if established_indices[0] == i:
+                instruction_indices.append(established_indices.pop(0))
+                continue
+
+        # Set some aliases
+        instr = qc_data[i]
+        instr_qubits = set(instr.qubits)
+
+        # Determine the intersection between the qubits of the instruction
+        # and the qubits of the group
+        intersection = instr_qubits.intersection(qubits)
+
+        # If the intersection is empty, this instruction is not part of the group
+        # and no further action needs to be taken
+        if not intersection:
+            continue
+
+        # If the instruction is non-unitary, no further instruction
+        # on this qubit can be part of the group
+        if instr.op.name in ["measure", "reset", "disentangle"]:
+            qubits = qubits - instr_qubits
+            continue
+
+        # If the instruction qubits are part of the group qubits,
+        # add the instruction to the group
+        if instr_qubits.issubset(qubits):
+            instruction_indices.append(i)
+
+        # Otherwise, the instruction happens partly on the group qubits,
+        # partly outside. Therefore, we need to remove the qubits
+        # that interact with the outside.
+        # Nevertheless, we add the "outside" qubits to the set of expansion options
+        else:
+            qubits = qubits - intersection
+            expansion_options = expansion_options.union(instr_qubits - intersection)
+
+    # Return result
+    return instruction_indices, list(expansion_options)
+
+
+# Empirically determined parameters that seem to work best
+def optimal_grouping_recursion_parameter(qubit_amount):
+    if qubit_amount <= 16:
+        return 2
+    elif 16 < qubit_amount <= 20:
+        return 3
+    elif 20 < qubit_amount <= 24:
+        return 4
+    elif 24 < qubit_amount <= 28:
+        return 6
+    elif 28 < qubit_amount <= 32:
+        return 7
+    elif 32 < qubit_amount < 35:
+        return 8
+    else:
+        return 9
+
+
+# This function inserts disentangling operations into the circuit, if suited
+# Consider the following circuit
+#             ┌───┐
+# qubit_3362: ┤ H ├──■──────────────────────
+#             └───┘┌─┴─┐┌───┐
+# qubit_3363: ─────┤ x ├┤ H ├──■────────────
+#                  └───┘└───┘┌─┴─┐┌────────┐
+# qubit_3364: ───────────────┤ x ├┤ P(0.3) ├
+#                            └───┘└────────┘
+# If we don't the gates after the first CNOT with U,
+# the resulting state is
+# 2**-0.5*(|0>U|0> + |1>U|1>)
+# Since we are not interested in the wave-function but in the resulting
+# probabilities, it is now safe to evaluate both summands of the wave function
+# separately, ie. evaluate |0>U|0> and |1>U|1> and multiply the resulting,
+# probabilities with 2**-0.5.
+# This is possible because there is not going to be any interaction between the to
+# states.
+# (TO-DO better proof required)
+# Therefore the workflow for performing the disentangling is
+# 1. Identify position to insert disentangler (here: directly behind the first CNOT)
+# 2. Perform measurement (to acquire classical probabilities)
+# 3. Continue the simulation on the two decoherent states
+
+# Simulating both states separately has two advantages
+# 1. If one of the branches has probability zero, this will show up in the measurement
+#   and we don't have to continue the simulation of this branch
+# 2. Simulating two states that don't interact is easier to parallelize
+
+# As it turns out, it is even possible to disentangle this circuit right
+# after the first H gate on qubit zero
+
+
+#              ┌───┐     ┌────────┐
+# qubit_10119: ┤ H ├──■──┤ P(0.2) ├─────────────────■──
+#              └───┘┌─┴─┐└─┬───┬──┘                 │
+# qubit_10120: ─────┤ x ├──┤ H ├─────■──────────────┼──
+#                   └───┘  └───┘   ┌─┴─┐┌────────┐┌─┴─┐
+# qubit_10121: ────────────────────┤ x ├┤ P(0.3) ├┤ x ├
+#                                  └───┘└────────┘└───┘
+
+
+# This is because all the gates after the H-gate are permeable on this qubit
+# (for an elaboration on permeability check the uncomputation module)
+# Roughly said, a gate U which is permeable on the first qubit behaves like this
+# U|0>|a> = exp(i*phi_0) |0> U_0 |a>
+# U|1>|b> = exp(i*phi_1) |0> U_1 |b>
+
+
+def insert_disentangling(qc):
+    # This function checks for permeability on a given qubit
+    from qrisp import Instruction, Operation
+    from qrisp.uncomputation import is_permeable
+
+    # Create disentangling operation
+    disentangler = Operation("disentangle", num_qubits=1)
+    disentangler.permeability = {0: False}
+
+    # After all the operations have been performed on a qubit,
+    # it can be reset without changing the statistics
+    for i in range(len(qc.qubits)):
+        qc.reset(qc.qubits[i])
+        # qc.append(disentangler, [qc.qubits[i]])
+
+    # return qc
+
+    # We now insert the disentanglers at every position which
+    # is only separated by permeable operations to the final operation
+    # of that qubit
+    reversed_data = list(qc.data)[::-1]
+
+    disentangling_counter = 0
+    i = 0
+    while i < len(reversed_data):
+        if not reversed_data[i].op.name in ["measure", "reset"]:
+            i += 1
+            continue
+
+        qubit = reversed_data[i].qubits[0]
+        j = int(i)
+
+        while j < len(reversed_data):
+            instr = reversed_data[j]
+            if qubit in instr.qubits:
+                if instr.op.name in ["measure", "reset", "disentangle"]:
+                    j += 1
+                    continue
+
+                # Find qubit index
+                qubit_index = instr.qubits.index(qubit)
+
+                if is_permeable(instr.op, [qubit_index]):
+                    # If so, insert disentangler before this instruction
+                    reversed_data.insert(j + 1, Instruction(disentangler, [qubit]))
+                    disentangling_counter += 1
+                    j += 1
+
+                else:
+                    break
+            j += 1
+
+        i += 1
+
+    # #For every qubit, we traverse the circuit from the back,
+    # #until we find an operation which is not permeable on that qubit
+    # for i in range(len(qc.qubits)):
+
+    #     #Set qubit alias
+    #     qb = qc.qubits[i]
+    #     j = -1
+    #     while j < len(reversed_data)-1:
+    #         j += 1
+
+    #         #Set alias for instruction that is to be checked
+    #         instr = reversed_data[j]
+
+    #         #If the instruction is a reset, measurement or disentangling,
+    #         #it performs the same operation as a disentangler, therefore
+    #         #we can safely insert further disentanlger before it
+    #         if instr.op.name in ["measure", "reset", "disentangle"]:
+    #             continue
+
+    #         #If the instruction acts on the qubit in question,
+    #         #check if the instruction is permeable on this qubit
+    #         if qb in instr.qubits:
+
+    #             #Find qubit index
+    #             qubit_index = instr.qubits.index(qb)
+
+    #             #Check for permeability
+    #             if is_permeable(instr.op, [qubit_index]):
+
+    #                 #If so, insert disentangler before this instruction
+    #                 reversed_data.insert(j+1, Instruction(disentangler, [qb]))
+    #                 disentangling_counter += 1
+    #             #Otherwise, we can no longer insert disentanglers
+    #             else:
+    #                 break
+
+    # Create output quantum circuit
+    new_qc = qc.clearcopy()
+    new_qc.data = reversed_data[::-1]
+
+    return new_qc
+
+
+# Simple function to count the amount of measurements in a circuit,
+# this is helpfull, because we don't need to continue the simulation,
+# once all measurements have been performed
+def count_measurements_and_treat_alloc(qc, insert_reset=True):
+    counter = 0
+    i = 0
+
+    while i < len(qc.data):
+        instr = qc.data[i]
+
+        if instr.op.name == "barrier":
+            qc.data.pop(i)
+            continue
+
+        if instr.op.name == "measure":
+            counter += 1
+        elif instr.op.name == "qb_alloc":
+            pass
+            qc.data.pop(i)
+            continue
+        elif instr.op.name == "qb_dealloc":
+            if insert_reset:
+                instr.op.name = "reset"
+            else:
+                qc.data.pop(i)
+                continue
+
+        i += 1
+    return counter
+
+
+def delete_multiple_element(list_object, indices):
+    indices = sorted(indices, reverse=True)
+    for idx in indices:
+        if idx < len(list_object):
+            list_object.pop(idx)
+
+
+def qb_set_to_int(qubits, qc):
+    res = 0
+    for qb in qubits:
+        res |= 1 << qc.qubits.index(qb)
+    return res
+
+
+def qc_to_int_list(qc):
+    res_list = []
+    for instr in qc.data:
+        res_list.append(qb_set_to_int(instr.qubits, qc))
+        if instr.op.name in ["measure", "reset", "disentangle"] or (
+            instr.op.name.find("c_if") != -1
+        ):
+            res_list[-1] *= -1
+
+    return res_list
+
+
+# Copy set in order to prevent modification
+# qubits = set(qubits)
+def get_circuit_block_(int_qc, qubits, established_indices=[]):
+    # qubits = qb_set_to_int(qubits, qc.source)
+    n = int_qc.n
+
+    # If the qubits int is to large to fit into np.int64, we use the non jitted version
+    if isinstance(int_qc.data, np.ndarray):
+        instruction_indices, expansion_options = binary_get_circuit_block_jitted(
+            int_qc.data, qubits, n, established_indices
+        )
+    else:
+        instruction_indices, expansion_options = binary_get_circuit_block(
+            int_qc.data, qubits, n, np.array(established_indices, dtype=np.int64)
+        )
+
+    return instruction_indices, int_to_qb_set(expansion_options, int_qc.source)
+    # return instruction_indices, expansion_options.to_qubit_list()
+
+
+@njit
+def binary_get_circuit_block_jitted(int_qc_list, qubits, n, established_indices):
+    # Set up set of expansion options
+    expansion_options = 0
+
+    # Set up result list
+    instruction_indices = []
+    ee_counter = 0
+    # Now iterate through all the given instructions
+    for i in range(len(int_qc_list)):
+        if qubits == 0:
+            break
+
+        # If the instruction has been identified as part of the group
+        # in a previous recursion, skip the checking and add to the list
+        # of instructions
+        if ee_counter < len(established_indices):
+            if established_indices[ee_counter] == i:
+                ee_counter += 1
+                instruction_indices.append(i)
+                continue
+
+        # Set some aliases
+        instr_qubits = int_qc_list[i]
+        # instr = qc.data[i]
+        # instr_qubits = set(instr.qubits)
+
+        # Determine the intersection between the qubits of the instruction
+        # and the qubits of the group
+        # intersection = instr_qubits.intersection(qubits)
+        intersection = qubits & instr_qubits
+
+        # If the intersection is empty, this instruction is not part of the group
+        # and no further action needs to be taken
+        if not intersection:
+            continue
+
+        # If the instruction is non-unitary, no further instruction
+        # on this qubit can be part of the group
+        if instr_qubits < 0:
+            qubits = qubits & (((1 << n) - 1) ^ instr_qubits)
+            # qubits = qubits - instr_qubits
+            continue
+
+        # If the instruction qubits are part of the group qubits,
+        # add the instruction to the group
+        if not bool((((1 << n) - 1) ^ qubits) & instr_qubits):
+            # if instr_qubits.issubset(qubits):
+            instruction_indices.append(i)
+
+        # Otherwise, the instruction happens partly on the group qubits,
+        # partly outside. Therefore we need to remove the qubits
+        # that interact with the outside.
+        # Nevertheless, we add the "outside" qubits to the set of expansion options
+        else:
+            qubits = qubits & (((1 << n) - 1) ^ intersection)
+            # qubits = qubits - intersection
+            expansion_options = expansion_options | (
+                instr_qubits & (((1 << n) - 1) ^ intersection)
+            )
+            # expansion_options = expansion_options.union(instr_qubits - intersection)
+
+    # Return result
+    return instruction_indices, expansion_options
+
+
+def binary_get_circuit_block(int_qc_list, qubits, n, established_indices):
+    # Set up set of expansion options
+    expansion_options = 0
+
+    # Set up result list
+    instruction_indices = []
+    ee_counter = 0
+    # Now iterate through all the given instructions
+    for i in range(len(int_qc_list)):
+        if qubits == 0:
+            break
+
+        # If the instruction has been identified as part of the group
+        # in a previous recursion, skip the checking and add to the list
+        # of instructions
+        if ee_counter < len(established_indices):
+            if established_indices[ee_counter] == i:
+                ee_counter += 1
+                instruction_indices.append(i)
+                continue
+
+        # Set some aliases
+        instr_qubits = int_qc_list[i]
+        # instr = qc.data[i]
+        # instr_qubits = set(instr.qubits)
+
+        # Determine the intersection between the qubits of the instruction
+        # and the qubits of the group
+        # intersection = instr_qubits.intersection(qubits)
+        intersection = qubits & instr_qubits
+
+        # If the intersection is empty, this instruction is not part of the group
+        # and no further action needs to be taken
+        if not intersection:
+            continue
+
+        # If the instruction is non-unitary, no further instruction
+        # on this qubit can be part of the group
+        if instr_qubits < 0:
+            qubits = qubits & (((1 << n) - 1) ^ instr_qubits)
+            # qubits = qubits - instr_qubits
+            continue
+
+        # If the instruction qubits are part of the group qubits,
+        # add the instruction to the group
+        if not bool((((1 << n) - 1) ^ qubits) & instr_qubits):
+            # if instr_qubits.issubset(qubits):
+            instruction_indices.append(i)
+
+        # Otherwise, the instruction happens partly on the group qubits,
+        # partly outside. Therefore we need to remove the qubits
+        # that interact with the outside.
+        # Nevertheless, we add the "outside" qubits to the set of expansion options
+        else:
+            qubits = qubits & (((1 << n) - 1) ^ intersection)
+            # qubits = qubits - intersection
+            expansion_options = expansion_options | (
+                instr_qubits & (((1 << n) - 1) ^ intersection)
+            )
+            # expansion_options = expansion_options.union(instr_qubits - intersection)
+
+    # Return result
+    return instruction_indices, expansion_options
+
+
+def int_to_qb_set(integer, qc):
+    res = []
+    for i in range(len(qc.qubits)):
+        if int(integer) & (1 << i):
+            res.append(qc.qubits[i])
+
+    return res
+
+
+class IntegerCircuit:
+    def __init__(self, qc):
+        self.source = qc
+        self.data = qc_to_int_list(qc)
+        self.n = len(qc.qubits)
+
+
+def average_group_size(qc):
+    average_group_size = 0
+
+    for i in range(len(qc.data)):
+        if qc.data[i].op.definition:
+            average_group_size += len(qc.data[i].op.definition.data)
+        else:
+            average_group_size += 1
+
+    return average_group_size / len(qc.data)
+
+
+# Wrapping function for all preproccessing operations
+def circuit_preprocessor(qc):
+    # from qrisp.simulator.permutation_identification import group_pt_permutations
+    from qrisp.simulator import reorder_circuit
+
+    if len(qc.data) == 0:
+        return qc.copy()
+
+    # TO-DO find reliable classifiaction when automatic disentangling works best
+    if len(qc.qubits) < 26:
+        qc = group_qc(qc)
+    elif len(qc.qubits) < 34:
+        qc = group_qc(qc)
+        qc = insert_disentangling(qc)
+    else:
+        qc = insert_disentangling(qc)
+        qc = group_qc(qc)
+
+    return reorder_circuit(qc, ["measure", "reset", "disentangle"])
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/circuit_reordering.py` & `qrisp-0.0.16/src/qrisp/simulator/circuit_reordering.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,397 +1,386 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-#The functions in this file are supposed to reorder circuits in such a way,
-#that measurements, resets and disentanglers are performed as early as possible.
-#This is beneficial because the simulation of two decoherent states can be parallelized better
-#furthermore might the measurement of these imply that one of the states has vanishing probability
-#which means that this state does not require further simulation.
-
-#The idea to achieve the ordering is to convert the circuit into a directed acyclic graph (now called causal graph),
-#where two successive operations with overlapping qubits are represented with two nodes,
-#connected by a directed edge. The directed edge, however points into the opposite direction
-#of the sequential order of the operations. This way, if we want to evaluate
-#what gates are necessary in order to perform a measurement, disentangling or reset,
-#we simply have to look at the set of gates that is reachable from that specific node in the causal graph
-
-#Consider the following circuit
-#           ┌───┐        
-#  qubit_9: ┤ X ├──■─────
-#           ├───┤┌─┴─┐┌─┐
-# qubit_10: ┤ Y ├┤ x ├┤M├
-#           ├───┤└───┘└╥┘
-# qubit_11: ┤ H ├──────╫─
-#           └───┘      ║ 
-#  clbit_0: ═══════════╩═
-                      
-#In order to perform the measurement, we have to execute the x and the cx gate
-#The corresponding causal graph
-#(measure)-> (CX)->(X)
-#               L->(Y)
-#(H)
-#We see that CX, X and Y are reachable from the measurement
-#We now perform the perform a depth first traversal on the
-#subgraph of the nodes which are reachable from the measurement.
-
-#It is important to node that for a regular depth first traversal,
-#we are free to choose which child of a node to traverse next.
-#This is not the casehere, because this might disturb the topological
-#order, which would imply that we performed an illegitimat reordering
-#Therefore, in this depth first traversal, we always traverse the child
-#with the highest index in a topological order first.
-
-import networkx as nx
-import numpy as np
-
-def nx_get_causal_graph(qc, inverted = False, get_non_unitary_nodes = False, preferential_gates = []):
-    from qrisp.circuit import Operation, Instruction
-    
-    #Create graph object
-    G = nx.DiGraph()
-    
-    #This distionary contains the information, which node of the graph
-    #if the most up to date noce for a qubit
-    current_node_qubits = {}
-    
-    #List to collect the non-unitary nodes
-    non_unitary_nodes = []
-    
-    #Now we traverse the circuit instructions
-    for i in range(len(qc.data)):
-        
-        #Add new node to the graph
-        new_node = i
-        G.add_node(new_node)
-        
-        #Determine the set of nodes, which the new node will connect to
-        #ie. the nodes which are most up to date on the particular qubits
-        node_set = []
-        for qb in qc.data[i].qubits:
-            
-            #If there is a node which has been connected to this qubit before,
-            #append the node to the node set, that the new node will be connected to
-            try:
-                node_set.append(current_node_qubits[qb])
-            except KeyError:
-                pass
-            
-            #Update the dictionary
-            current_node_qubits[qb] = new_node
-            
-        #Make sure every node is listed only once
-        node_set = list(set(node_set))
-        
-        #Add the edges
-        if inverted:
-            for node in node_set:
-                G.add_edge(new_node, node)
-        else:
-            for node in node_set:
-                G.add_edge(node, new_node)
-        
-        #Log if the new node is non unitary
-        if qc.data[i].op.name in preferential_gates + ["final_op"]:
-            non_unitary_nodes.append(new_node)
-        
-        
-    #Return result
-    if get_non_unitary_nodes:
-        return G, non_unitary_nodes
-    
-    return G
-
-
-#Function to reorder a circuit as described above
-def nx_reorder_circuit(qc, preferential_gates = []):
-    
-    from qrisp.circuit import Operation, Instruction
-    
-    for i in range(len(qc.qubits)):
-        qc.append(Operation("final_op", num_qubits = 1), [qc.qubits[i]])
-    
-    #Acquire causal graph
-    G, non_unitary_nodes = nx_get_causal_graph(qc, inverted = True, get_non_unitary_nodes = True, preferential_gates = preferential_gates)
-    
-    from networkx import descendants, topological_sort, transitive_reduction
-    
-    #We now order the non-unitary nodes according to how many decendents they all have
-    #Measurements/Resets/Disentanglings with only a few descendants need only a few
-    #gates to be simulated until the measurement can be executed
-    node_costs = []
-    for i in range(len(non_unitary_nodes)):
-        if qc.data[hash(non_unitary_nodes[i])].op.name == "final_op":
-            node_costs.append((non_unitary_nodes[i], np.inf))
-        else:
-            node_costs.append((non_unitary_nodes[i], len(descendants(G, non_unitary_nodes[i]))))
-    
-    node_costs.sort(key = lambda x : x[1])
-    
-    #We now determine the topological dictionary of the nodes
-    #This dictionary assigns each node an integer, which indicates it's
-    #position in a topological ordering. The topological ordering of a graph
-    #has the feature that two nodes N1, N2 which stand in a causal relationship to each other
-    #(ie. N1 has to be executed after N2) also have increasing index in the topological
-    #ordering ie. 
-    #tp_dic[N1] > tp_dic[N2]
-    sorted_nodes = list(topological_sort(G))
-    tp_dic = {sorted_nodes[i] : i for i in range(len(sorted_nodes))}
-
-    #This function now performs depth first traversal of the given causal graph,
-    #starting at node. Each time a node is visited the callback function is called
-    
-    #The callback function that this will mainly be used with, is a logger,
-    #which notes in which order the nodes have been visited
-    
-    #As mentioned in the comment at the beginning of this file,
-    #a regular depth first traversal basically allows picking any child
-    #to traverse next. In our case, this can mess with the topological ordering
-    #Therefore we allways traverse the child with the highest topological index
-    
-    def topological_desc_traversal(G, node, tp_dic, callback):
-        
-        node_list = [x for x in nx.descendants(G, node)]
-        
-        node_list.sort(key = lambda x : -tp_dic[x])
-        
-        for n in node_list:
-            callback(n)
-            G.remove_node(n)
-            
-        callback(node)
-        G.remove_node(node)
-        return
-        
-    def topological_df_traversal(G, node, tp_dic, callback):
-        #Acquire list of children
-        node_list = [x for x in G.neighbors(node)]
-        
-        #Sort according to their topological index
-        node_list.sort(key = lambda x : -tp_dic[x])
-        
-        #Recursively traverse the children
-        while node_list:
-            topological_df_traversal(G, node_list[0], tp_dic, callback)
-            
-            #Since the traversed nodes are removed after each traversal,
-            #we need to to update the list of children, in case any of
-            #the nodes in node_list have been removed
-            node_list = [x for x in G.neighbors(node)]
-            node_list.sort(key = lambda x : -tp_dic[x])
-            
-        #Call the callback function
-        callback(node)
-        #Remove the node in order to prevent traversing it again
-        #this can happen because the causal graph is not necessarily a tree graph
-        G.remove_node(node)
-    
-    
-    
-    
-    #The circuits in this list will be the circuits whose
-    #execution is the absolute minimum in order to evaluate a certain non-unitary operation
-    new_qc_list = []
-    
-    #Now we succesively determine the minimal circuit required to execute
-    #for each non-unitary operation
-    while node_costs:
-        
-        #This node contains the non-unitary operation
-        evaluation_node = node_costs.pop(0)[0]
-        
-        #This list will contain the unitary operations that are necessary
-        #in order to perform the operation described by evaluation_node
-        evaluation_list = []
-        
-        #Create callback function
-        def callback(x):
-            evaluation_list.append(x)
-        
-        #Traverse causal graph
-        topological_desc_traversal(G, evaluation_node, tp_dic, callback)
-        # topological_df_traversal(G, evaluation_node, tp_dic, callback)
-        
-        
-        #Create circuit
-        new_qc = qc.clearcopy()    
-        #Append the corresponding instruction to the circuit
-        for node in evaluation_list:
-            instr = qc.data[hash(node)]
-            if not instr.op.name == "final_op":
-                new_qc.data.append(instr)
-                
-        new_qc_list.append(new_qc)
-        
-    
-    #Create result quantum circuit
-    new_qc = qc.clearcopy()
-    
-    #Concatenate the data of the newly created circuits
-    new_qc.data = sum([qc.data for qc in new_qc_list], [])
-    
-    
-    #Remove final_op operations
-    for i in range(len(qc.qubits)):
-        qc.data.pop(-1)
-    
-    #Return result    
-    return new_qc
-
-
-#Similar function as above but implemented for the C++ based
-#graph theory package networkit
-def nk_reorder_circuit(qc, preferential_gates = []):
-    
-    from qrisp.circuit import Operation, Instruction
-    
-    for i in range(len(qc.qubits)):
-        qc.append(Operation("final_op", num_qubits = 1), [qc.qubits[i]])
-        
-    import networkit as nk
-    G = nk.Graph(directed = True)
-    current_node_qubits = {qubit : "-" for qubit in qc.qubits}
-    non_unitary_nodes = []
-    measurement_counter = 0
-    for i in range(len(qc.data)):
-        new_node = G.addNode()
-        node_set = []
-        for qb in qc.data[i].qubits:
-            if current_node_qubits[qb] != "-":
-                node_set.append(current_node_qubits[qb])
-                
-            current_node_qubits[qb] = new_node
-        node_set = list(set(node_set))
-        
-        for node in node_set:
-            G.addEdge(i, node)
-            
-        if qc.data[i].op.name in preferential_gates + ["final_op"]:
-            non_unitary_nodes.append(new_node)
-            if qc.data[i].op.name == "measure":
-                measurement_counter += 1
-
-    
-    
-    from networkit.traversal import Traversal
-    
-    new_qc_list = []
-    
-    from networkit.graphtools import GraphTools
-    sorted_nodes = GraphTools.topologicalSort(G)
-
-    tp_dic = {sorted_nodes[i] : i for i in range(len(sorted_nodes))}
-
-
-    reach_alg = nk.reachability.ReachableNodes(G, exact = True)
-    
-    reach_alg.run()
-    node_costs = []
-    
-
-
-    
-    for i in range(len(non_unitary_nodes)):
-        if qc.data[hash(non_unitary_nodes[i])].op.name == "final_op":
-            node_costs.append((non_unitary_nodes[i], np.inf))
-        else:
-            node_costs.append((non_unitary_nodes[i], reach_alg.numberOfReachableNodes(non_unitary_nodes[i])))
-    
-    node_costs.sort(key = lambda x : x[1])
-    
-    def topological_desc_traversal(G, node, tp_dic, callback):
-        
-        node_list = []
-        
-        nk.traversal.Traversal.DFSfrom(G, node, node_list.append)
-        
-        node_list.sort(key = lambda x : -tp_dic[x])
-        
-        for n in node_list:
-            callback(n)
-            G.removeNode(node)
-        
-        # callback(node)
-        # G.removeNode(node)    
-        
-        return
-        
-        
-    
-    def topological_df_traversal(G, node, tp_dic, callback):
-        
-        node_list = [x for x in G.iterNeighbors(node)]
-        node_list.sort(key = lambda x : -tp_dic[x])
-        
-        while node_list:
-            topological_df_traversal(G, node_list[0], tp_dic, callback)
-            node_list = [x for x in G.iterNeighbors(node)]
-            node_list.sort(key = lambda x : -tp_dic[x])
-            
-        
-        callback(node)
-        G.removeNode(node)
-        
-    
-    while node_costs:
-            
-            
-        evaluation_node = node_costs.pop(0)[0]
-        
-        evaluation_list = []
-        
-        def callback(x, y = 0):
-            
-            if len(evaluation_list):
-                G.removeNode(evaluation_list[-1])
-            evaluation_list.append(x)
-            
-        
-        new_qc = qc.clearcopy()    
-        
-        
-        # topological_df_traversal(G, evaluation_node, tp_dic, callback)
-        topological_desc_traversal(G, evaluation_node, tp_dic, callback)
-            
-        for node in evaluation_list:
-            instr = qc.data[hash(node)]
-            if instr.op.name != "final_op":
-                new_qc.data.append(instr)
-    
-        new_qc_list.append(new_qc)
-    
-    for i in range(len(qc.qubits)):
-        qc.data.pop(-1)    
-    
-    new_qc = qc.clearcopy()
-    new_qc.data = sum([qc.data for qc in new_qc_list], [])
-    
-    return new_qc
-
-try:
-    import networkit
-    nk_available = True
-    
-except:
-    nk_available = False
-    # print("Install networkit for additional simulator performance. Resorting to networkx.")
-    
-
-
-def reorder_circuit(qc, preferential_gates = []):
-    if nk_available:
-        # return nk_reorder_circuit(qc, preferential_gates)
-    
-        return nx_reorder_circuit(qc, preferential_gates)
-    else:
-        return nx_reorder_circuit(qc, preferential_gates)
-    
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+# The functions in this file are supposed to reorder circuits in such a way,
+# that measurements, resets and disentanglers are performed as early as possible.
+# This is beneficial because the simulation of two decoherent states can be parallelized
+# better. Furthermore, might the measurement of these imply that one of the states has
+# vanishing probability, which means that this state does not require further
+# simulation.
+
+# The idea to achieve the ordering is to convert the circuit into a directed acyclic
+# graph (now called causal graph), where two successive operations with overlapping
+# qubits are represented with two nodes, connected by a directed edge. The directed
+# edge, however points into the opposite direction of the sequential order of the
+# operations. This way, if we want to evaluate what gates are necessary in order to
+# perform a measurement, disentangling or reset, we simply have to look at the set of
+# gates that is reachable from that specific node in the causal graph.
+
+# Consider the following circuit
+#           ┌───┐
+#  qubit_9: ┤ X ├──■─────
+#           ├───┤┌─┴─┐┌─┐
+# qubit_10: ┤ Y ├┤ x ├┤M├
+#           ├───┤└───┘└╥┘
+# qubit_11: ┤ H ├──────╫─
+#           └───┘      ║
+#  clbit_0: ═══════════╩═
+
+# In order to perform the measurement, we have to execute the x and the cx gate
+# The corresponding causal graph
+# (measure)-> (CX)->(X)
+#               L->(Y)
+# (H)
+# We see that CX, X and Y are reachable from the measurement
+# We now perform a depth first traversal on the subgraph of the nodes which are
+# reachable from the measurement.
+
+# It is important to node that for a regular depth first traversal,
+# we are free to choose which child of a node to traverse next.
+# This is not the casehere, because this might disturb the topological
+# order, which would imply that we performed an illegitimat reordering
+# Therefore, in this depth first traversal, we always traverse the child
+# with the highest index in a topological order first.
+
+import networkx as nx
+import numpy as np
+
+
+def nx_get_causal_graph(
+    qc, inverted=False, get_non_unitary_nodes=False, preferential_gates=[]
+):
+    from qrisp.circuit import Instruction, Operation
+
+    # Create graph object
+    G = nx.DiGraph()
+
+    # This distionary contains the information, which node of the graph
+    # if the most up to date noce for a qubit
+    current_node_qubits = {}
+
+    # List to collect the non-unitary nodes
+    non_unitary_nodes = []
+
+    # Now we traverse the circuit instructions
+    for i in range(len(qc.data)):
+        # Add new node to the graph
+        new_node = i
+        G.add_node(new_node)
+
+        # Determine the set of nodes, which the new node will connect to
+        # ie. the nodes which are most up to date on the particular qubits
+        node_set = []
+        for qb in qc.data[i].qubits:
+            # If there is a node which has been connected to this qubit before,
+            # append the node to the node set, that the new node will be connected to
+            try:
+                node_set.append(current_node_qubits[qb])
+            except KeyError:
+                pass
+
+            # Update the dictionary
+            current_node_qubits[qb] = new_node
+
+        # Make sure every node is listed only once
+        node_set = list(set(node_set))
+
+        # Add the edges
+        if inverted:
+            for node in node_set:
+                G.add_edge(new_node, node)
+        else:
+            for node in node_set:
+                G.add_edge(node, new_node)
+
+        # Log if the new node is non unitary
+        if qc.data[i].op.name in preferential_gates + ["final_op"]:
+            non_unitary_nodes.append(new_node)
+
+    # Return result
+    if get_non_unitary_nodes:
+        return G, non_unitary_nodes
+
+    return G
+
+
+# Function to reorder a circuit as described above
+def nx_reorder_circuit(qc, preferential_gates=[]):
+    from qrisp.circuit import Instruction, Operation
+
+    for i in range(len(qc.qubits)):
+        qc.append(Operation("final_op", num_qubits=1), [qc.qubits[i]])
+
+    # Acquire causal graph
+    G, non_unitary_nodes = nx_get_causal_graph(
+        qc,
+        inverted=True,
+        get_non_unitary_nodes=True,
+        preferential_gates=preferential_gates,
+    )
+
+    from networkx import descendants, topological_sort, transitive_reduction
+
+    # We now order the non-unitary nodes according to how many decendents they all have
+    # Measurements/Resets/Disentanglings with only a few descendants need only a few
+    # gates to be simulated until the measurement can be executed
+    node_costs = []
+    for i in range(len(non_unitary_nodes)):
+        if qc.data[hash(non_unitary_nodes[i])].op.name == "final_op":
+            node_costs.append((non_unitary_nodes[i], np.inf))
+        else:
+            node_costs.append(
+                (non_unitary_nodes[i], len(descendants(G, non_unitary_nodes[i])))
+            )
+
+    node_costs.sort(key=lambda x: x[1])
+
+    # We now determine the topological dictionary of the nodes.
+    # This dictionary assigns each node an integer, which indicates its position in a
+    # topological ordering. The topological ordering of a graph has the feature that two
+    # nodes N1, N2 which stand in a causal relationship to each other (i.e. N1 has to be
+    # executed after N2) also have increasing index in the topological ordering i.e.
+    # tp_dic[N1] > tp_dic[N2]
+    sorted_nodes = list(topological_sort(G))
+    tp_dic = {sorted_nodes[i]: i for i in range(len(sorted_nodes))}
+
+    # This function now performs depth first traversal of the given causal graph,
+    # starting at node. Each time a node is visited the callback function is called
+
+    # The callback function that this will mainly be used with, is a logger,
+    # which notes in which order the nodes have been visited
+
+    # As mentioned in the comment at the beginning of this file,
+    # a regular depth first traversal basically allows picking any child
+    # to traverse next. In our case, this can mess with the topological ordering
+    # Therefore we allways traverse the child with the highest topological index
+
+    def topological_desc_traversal(G, node, tp_dic, callback):
+        node_list = [x for x in nx.descendants(G, node)]
+
+        node_list.sort(key=lambda x: -tp_dic[x])
+
+        for n in node_list:
+            callback(n)
+            G.remove_node(n)
+
+        callback(node)
+        G.remove_node(node)
+        return
+
+    def topological_df_traversal(G, node, tp_dic, callback):
+        # Acquire list of children
+        node_list = [x for x in G.neighbors(node)]
+
+        # Sort according to their topological index
+        node_list.sort(key=lambda x: -tp_dic[x])
+
+        # Recursively traverse the children
+        while node_list:
+            topological_df_traversal(G, node_list[0], tp_dic, callback)
+
+            # Since the traversed nodes are removed after each traversal,
+            # we need to to update the list of children, in case any of
+            # the nodes in node_list have been removed
+            node_list = [x for x in G.neighbors(node)]
+            node_list.sort(key=lambda x: -tp_dic[x])
+
+        # Call the callback function
+        callback(node)
+        # Remove the node in order to prevent traversing it again
+        # this can happen because the causal graph is not necessarily a tree graph
+        G.remove_node(node)
+
+    # The circuits in this list will be the circuits whose execution is the absolute
+    # minimum in order to evaluate a certain non-unitary operation
+    new_qc_list = []
+
+    # Now we succesively determine the minimal circuit required to execute
+    # for each non-unitary operation
+    while node_costs:
+        # This node contains the non-unitary operation
+        evaluation_node = node_costs.pop(0)[0]
+
+        # This list will contain the unitary operations that are necessary
+        # in order to perform the operation described by evaluation_node
+        evaluation_list = []
+
+        # Create callback function
+        def callback(x):
+            evaluation_list.append(x)
+
+        # Traverse causal graph
+        topological_desc_traversal(G, evaluation_node, tp_dic, callback)
+        # topological_df_traversal(G, evaluation_node, tp_dic, callback)
+
+        # Create circuit
+        new_qc = qc.clearcopy()
+        # Append the corresponding instruction to the circuit
+        for node in evaluation_list:
+            instr = qc.data[hash(node)]
+            if not instr.op.name == "final_op":
+                new_qc.data.append(instr)
+
+        new_qc_list.append(new_qc)
+
+    # Create result quantum circuit
+    new_qc = qc.clearcopy()
+
+    # Concatenate the data of the newly created circuits
+    new_qc.data = sum([qc.data for qc in new_qc_list], [])
+
+    # Remove final_op operations
+    for i in range(len(qc.qubits)):
+        qc.data.pop(-1)
+
+    # Return result
+    return new_qc
+
+
+# Similar function as above but implemented for the C++ based
+# graph theory package networkit
+def nk_reorder_circuit(qc, preferential_gates=[]):
+    from qrisp.circuit import Instruction, Operation
+
+    for i in range(len(qc.qubits)):
+        qc.append(Operation("final_op", num_qubits=1), [qc.qubits[i]])
+
+    import networkit as nk
+
+    G = nk.Graph(directed=True)
+    current_node_qubits = {qubit: "-" for qubit in qc.qubits}
+    non_unitary_nodes = []
+    measurement_counter = 0
+    for i in range(len(qc.data)):
+        new_node = G.addNode()
+        node_set = []
+        for qb in qc.data[i].qubits:
+            if current_node_qubits[qb] != "-":
+                node_set.append(current_node_qubits[qb])
+
+            current_node_qubits[qb] = new_node
+        node_set = list(set(node_set))
+
+        for node in node_set:
+            G.addEdge(i, node)
+
+        if qc.data[i].op.name in preferential_gates + ["final_op"]:
+            non_unitary_nodes.append(new_node)
+            if qc.data[i].op.name == "measure":
+                measurement_counter += 1
+
+    from networkit.traversal import Traversal
+
+    new_qc_list = []
+
+    from networkit.graphtools import GraphTools
+
+    sorted_nodes = GraphTools.topologicalSort(G)
+
+    tp_dic = {sorted_nodes[i]: i for i in range(len(sorted_nodes))}
+
+    reach_alg = nk.reachability.ReachableNodes(G, exact=True)
+
+    reach_alg.run()
+    node_costs = []
+
+    for i in range(len(non_unitary_nodes)):
+        if qc.data[hash(non_unitary_nodes[i])].op.name == "final_op":
+            node_costs.append((non_unitary_nodes[i], np.inf))
+        else:
+            node_costs.append(
+                (
+                    non_unitary_nodes[i],
+                    reach_alg.numberOfReachableNodes(non_unitary_nodes[i]),
+                )
+            )
+
+    node_costs.sort(key=lambda x: x[1])
+
+    def topological_desc_traversal(G, node, tp_dic, callback):
+        node_list = []
+
+        nk.traversal.Traversal.DFSfrom(G, node, node_list.append)
+
+        node_list.sort(key=lambda x: -tp_dic[x])
+
+        for n in node_list:
+            callback(n)
+            G.removeNode(node)
+
+        # callback(node)
+        # G.removeNode(node)
+
+        return
+
+    def topological_df_traversal(G, node, tp_dic, callback):
+        node_list = [x for x in G.iterNeighbors(node)]
+        node_list.sort(key=lambda x: -tp_dic[x])
+
+        while node_list:
+            topological_df_traversal(G, node_list[0], tp_dic, callback)
+            node_list = [x for x in G.iterNeighbors(node)]
+            node_list.sort(key=lambda x: -tp_dic[x])
+
+        callback(node)
+        G.removeNode(node)
+
+    while node_costs:
+        evaluation_node = node_costs.pop(0)[0]
+
+        evaluation_list = []
+
+        def callback(x, y=0):
+            if len(evaluation_list):
+                G.removeNode(evaluation_list[-1])
+            evaluation_list.append(x)
+
+        new_qc = qc.clearcopy()
+
+        # topological_df_traversal(G, evaluation_node, tp_dic, callback)
+        topological_desc_traversal(G, evaluation_node, tp_dic, callback)
+
+        for node in evaluation_list:
+            instr = qc.data[hash(node)]
+            if instr.op.name != "final_op":
+                new_qc.data.append(instr)
+
+        new_qc_list.append(new_qc)
+
+    for i in range(len(qc.qubits)):
+        qc.data.pop(-1)
+
+    new_qc = qc.clearcopy()
+    new_qc.data = sum([qc.data for qc in new_qc_list], [])
+
+    return new_qc
+
+
+try:
+    import networkit
+
+    nk_available = True
+
+except:
+    nk_available = False
+    # print("Install networkit for additional simulator performance.
+    # Resorting to networkx.")
+
+
+def reorder_circuit(qc, preferential_gates=[]):
+    if nk_available:
+        # return nk_reorder_circuit(qc, preferential_gates)
+
+        return nx_reorder_circuit(qc, preferential_gates)
+    else:
+        return nx_reorder_circuit(qc, preferential_gates)
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/impure_quantum_state.py` & `qrisp-0.0.16/src/qrisp/simulator/impure_quantum_state.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,240 +1,213 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-import threading
-from qrisp.simulator.quantum_state import QuantumState
-
-import numpy as np
-thread_limit = 1
-
-#This class describes a set of decoherent quantum states
-class ImpureQuantumState:
-    
-    
-    #Initially we start we a single quantum state
-    def __init__(self, n, clbit_amount = 0):
-        self.states = [QuantumState(n)]
-        self.cl_prob = [1]
-        self.outcome_list = [np.zeros(clbit_amount, dtype = np.byte)]
-        self.collected_measurements = []
-        
-    
-    
-    def apply_operation(self, operation, qubits):
-        
-        #Perform operation application in parallel. This is possible because many
-        #functions in here release the GIL (such as numpy's np.dot)
-        if thread_limit > 1 and len(self.states) > 1:
-            
-            threads = []
-            
-            for i in range(len(self.states)):
-                mp_wrapper = lambda : self.states[i].apply_operation(operation, qubits)
-                
-                thr = threading.Thread(target = mp_wrapper)
-                
-                if len(threads) >= thread_limit:
-                    threads[0].join()
-                    threads.pop(0)
-                
-                thr.start()
-                threads.append(thr)
-                
-            
-            [thr.join() for thr in threads]
-            
-        else:
-            
-            for i in range(len(self.states)):
-                self.states[i].apply_operation(operation, qubits)
-            
-
-    def conditionally_apply_operation(self, operation, qubits, clbit):
-        
-        #Perform operation application in parallel. This is possible because many
-        #functions in here release the GIL (such as numpy's np.dot)
-        
-        if thread_limit > 1:
-            
-            threads = []
-            
-            for i in range(len(self.states)):
-                
-                if self.outcome_list[clbit] == "0":
-                    continue
-                
-                mp_wrapper = lambda : self.states[i].apply_operation(operation, qubits)
-                
-                if len(threads) >= thread_limit:
-                    threads[0].join()
-                    threads.pop(0)
-                
-                
-                thr = threading.Thread(target = mp_wrapper)
-                thr.start()
-                
-                threads.append(thr)
-            
-            [thr.join() for thr in threads]
-            
-        else:
-            
-            for i in range(len(self.states)):
-                if self.outcome_list[clbit] == "0":
-                    continue
-
-                
-                self.states[i].apply_operation(operation, qubits)
-
-        
-    #Perform reset operation
-    #We perform the reset operation by measuring but not tracking the measurement result
-    def reset(self, qubit_index, keep_outcome = False):
-        
-        if thread_limit > 1:
-            
-            threads = []
-            
-            for i in range(len(self.states)):
-                mp_wrapper = lambda : self.states[i].measure(qubit_index, keep_outcome)
-                thr = threading.Thread(target = mp_wrapper)
-                
-                if len(threads) > thread_limit:
-                    threads[0].join()
-                    threads.pop(0)
-                
-                
-                thr.start()
-                threads.append(thr)
-                
-            
-        else:
-            
-            for i in range(len(self.states)):
-                self.states[i].measure(qubit_index, keep_outcome)
-        
-        
-        #Generate new list of states and the corresponding classical propabilities + the outcome bitstrings
-        new_states = []
-        new_cl_prob = []
-        new_outcome_list = []
-        
-        for i in range(len(self.states)):
-            
-            #Wait for measurement threads to finish
-            if thread_limit > 1:
-                if len(threads):
-                    threads[0].join()
-                    threads.pop(0)
-
-            #Get measurement outcome
-            #p_0 represents the probability to measure a 0,
-            #state_0 represents the state after measuring a 0
-            p_0, state_0, p_1, state_1 = self.states[i].last_mes_outcome
-            #Log results
-            if p_0 != 0:
-                
-                #Add the new decoherent state to the list of states
-                new_states.append(state_0)
-                
-                #Update its classical probability
-                new_cl_prob.append(p_0*self.cl_prob[i])
-                
-                #The bitstring stays the same
-                new_outcome = self.outcome_list[i].copy()
-                new_outcome_list.append(new_outcome)
-                
-            #Perform the same thing for the outcome 1
-            if p_1 != 0:
-                new_states.append(state_1)
-                new_cl_prob.append(p_1*self.cl_prob[i])
-                new_outcome = self.outcome_list[i].copy()
-                new_outcome_list.append(new_outcome)
-        
-        
-        #Update attributes
-        self.states = new_states
-        self.cl_prob = new_cl_prob
-        self.outcome_list = new_outcome_list
-        
-        
-    #This functions performs measurements
-    #The logic behind it is rather similar to reset, but this time we log the measurement outcome
-    def measure(self, qubit_index, clbit_index):
-        
-        if thread_limit > 1:
-            
-            threads = []
-            
-            for i in range(len(self.states)):
-                mp_wrapper = lambda : self.states[i].measure(qubit_index)
-                thr = threading.Thread(target = mp_wrapper)
-                
-                if len(threads) > thread_limit:
-                    threads[0].join()
-                    threads.pop(0)
-                
-                
-                thr.start()
-                threads.append(thr)
-            
-        else:
-            
-            for i in range(len(self.states)):
-                self.states[i].measure(qubit_index, True)
-
-        
-        new_states = []
-        new_cl_prob = []
-        new_outcome_list = []
-        
-        for i in range(len(self.states)):
-            
-            #Wait for measurement threads to finish
-            if thread_limit > 1:
-                if len(threads):
-                    threads[0].join()
-                    threads.pop(0)
-            
-            p_0, state_0, p_1, state_1 = self.states[i].last_mes_outcome
-            
-            if p_0 != 0:
-                new_states.append(state_0)
-                new_cl_prob.append(p_0*self.cl_prob[i])
-                new_outcome = self.outcome_list[i].copy()
-                
-                #Here is the point, where we log the measurement outcome
-                new_outcome[clbit_index] = 0
-                new_outcome_list.append(new_outcome)
-            if p_1 != 0:
-                
-                
-                new_states.append(state_1)
-                new_cl_prob.append(p_1*self.cl_prob[i])
-                new_outcome = self.outcome_list[i].copy()
-                new_outcome[clbit_index] = 1
-                new_outcome_list.append(new_outcome)
-                
-        self.states = new_states
-        self.cl_prob = new_cl_prob
-        self.outcome_list = new_outcome_list
-    
-    
-    def add_qubit(self):
-        for state in self.states: state.add_qubit()
-        
-    def add_clbit(self):
-        
-        for i in range(len(self.outcome_list)):
-            self.outcome_list[i] = np.array([0] + list(self.outcome_list[i]), dtype = np.byte)
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+import threading
+
+import numpy as np
+
+from qrisp.simulator.quantum_state import QuantumState
+
+thread_limit = 1
+
+
+# This class describes a set of decoherent quantum states
+class ImpureQuantumState:
+    # Initially we start with a single quantum state
+    def __init__(self, n, clbit_amount=0):
+        self.states = [QuantumState(n)]
+        self.cl_prob = [1]
+        self.outcome_list = [np.zeros(clbit_amount, dtype=np.byte)]
+        self.collected_measurements = []
+
+    def apply_operation(self, operation, qubits):
+        # Perform operation application in parallel. This is possible because many
+        # functions in here release the GIL (such as numpy's np.dot)
+        if thread_limit > 1 and len(self.states) > 1:
+            threads = []
+
+            for i in range(len(self.states)):
+                mp_wrapper = lambda: self.states[i].apply_operation(operation, qubits)
+
+                thr = threading.Thread(target=mp_wrapper)
+
+                if len(threads) >= thread_limit:
+                    threads[0].join()
+                    threads.pop(0)
+
+                thr.start()
+                threads.append(thr)
+
+            [thr.join() for thr in threads]
+
+        else:
+            for i in range(len(self.states)):
+                self.states[i].apply_operation(operation, qubits)
+
+    def conditionally_apply_operation(self, operation, qubits, clbit):
+        # Perform operation application in parallel. This is possible because many
+        # functions in here release the GIL (such as numpy's np.dot)
+
+        if thread_limit > 1:
+            threads = []
+
+            for i in range(len(self.states)):
+                if self.outcome_list[clbit] == "0":
+                    continue
+
+                mp_wrapper = lambda: self.states[i].apply_operation(operation, qubits)
+
+                if len(threads) >= thread_limit:
+                    threads[0].join()
+                    threads.pop(0)
+
+                thr = threading.Thread(target=mp_wrapper)
+                thr.start()
+
+                threads.append(thr)
+
+            [thr.join() for thr in threads]
+
+        else:
+            for i in range(len(self.states)):
+                if self.outcome_list[clbit] == "0":
+                    continue
+
+                self.states[i].apply_operation(operation, qubits)
+
+    # Perform reset operation
+    # We perform the reset operation by measuring but not tracking the measurement
+    # result.
+    def reset(self, qubit_index, keep_outcome=False):
+        if thread_limit > 1:
+            threads = []
+
+            for i in range(len(self.states)):
+                mp_wrapper = lambda: self.states[i].measure(qubit_index, keep_outcome)
+                thr = threading.Thread(target=mp_wrapper)
+
+                if len(threads) > thread_limit:
+                    threads[0].join()
+                    threads.pop(0)
+
+                thr.start()
+                threads.append(thr)
+
+        else:
+            for i in range(len(self.states)):
+                self.states[i].measure(qubit_index, keep_outcome)
+
+        # Generate new list of states and the corresponding classical propabilities +
+        # the outcome bitstrings
+        new_states = []
+        new_cl_prob = []
+        new_outcome_list = []
+
+        for i in range(len(self.states)):
+            # Wait for measurement threads to finish
+            if thread_limit > 1:
+                if len(threads):
+                    threads[0].join()
+                    threads.pop(0)
+
+            # Get measurement outcome
+            # p_0 represents the probability to measure a 0,
+            # state_0 represents the state after measuring a 0
+            p_0, state_0, p_1, state_1 = self.states[i].last_mes_outcome
+            # Log results
+            if p_0 != 0:
+                # Add the new decoherent state to the list of states
+                new_states.append(state_0)
+
+                # Update its classical probability
+                new_cl_prob.append(p_0 * self.cl_prob[i])
+
+                # The bitstring stays the same
+                new_outcome = self.outcome_list[i].copy()
+                new_outcome_list.append(new_outcome)
+
+            # Perform the same thing for the outcome 1
+            if p_1 != 0:
+                new_states.append(state_1)
+                new_cl_prob.append(p_1 * self.cl_prob[i])
+                new_outcome = self.outcome_list[i].copy()
+                new_outcome_list.append(new_outcome)
+
+        # Update attributes
+        self.states = new_states
+        self.cl_prob = new_cl_prob
+        self.outcome_list = new_outcome_list
+
+    # This functions performs measurements
+    # The logic behind it is rather similar to reset, but this time we log the
+    # measurement outcome.
+    def measure(self, qubit_index, clbit_index):
+        if thread_limit > 1:
+            threads = []
+
+            for i in range(len(self.states)):
+                mp_wrapper = lambda: self.states[i].measure(qubit_index)
+                thr = threading.Thread(target=mp_wrapper)
+
+                if len(threads) > thread_limit:
+                    threads[0].join()
+                    threads.pop(0)
+
+                thr.start()
+                threads.append(thr)
+
+        else:
+            for i in range(len(self.states)):
+                self.states[i].measure(qubit_index, True)
+
+        new_states = []
+        new_cl_prob = []
+        new_outcome_list = []
+
+        for i in range(len(self.states)):
+            # Wait for measurement threads to finish
+            if thread_limit > 1:
+                if len(threads):
+                    threads[0].join()
+                    threads.pop(0)
+
+            p_0, state_0, p_1, state_1 = self.states[i].last_mes_outcome
+
+            if p_0 != 0:
+                new_states.append(state_0)
+                new_cl_prob.append(p_0 * self.cl_prob[i])
+                new_outcome = self.outcome_list[i].copy()
+
+                # Here is the point, where we log the measurement outcome
+                new_outcome[clbit_index] = 0
+                new_outcome_list.append(new_outcome)
+            if p_1 != 0:
+                new_states.append(state_1)
+                new_cl_prob.append(p_1 * self.cl_prob[i])
+                new_outcome = self.outcome_list[i].copy()
+                new_outcome[clbit_index] = 1
+                new_outcome_list.append(new_outcome)
+
+        self.states = new_states
+        self.cl_prob = new_cl_prob
+        self.outcome_list = new_outcome_list
+
+    def add_qubit(self):
+        for state in self.states:
+            state.add_qubit()
+
+    def add_clbit(self):
+        for i in range(len(self.outcome_list)):
+            self.outcome_list[i] = np.array(
+                [0] + list(self.outcome_list[i]), dtype=np.byte
+            )
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/quantum_state.py` & `qrisp-0.0.16/src/qrisp/simulator/quantum_state.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,142 +1,144 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-from qrisp.simulator.tensor_factor import TensorFactor, multi_entangle
-from qrisp.simulator.numerics_config import xp
-
-#This class describes a quantum state
-#This is achieved by another class, the TensorFactor.
-#Each qubit initially has its own tensor factor. When an entangling operation is executed,
-#the TensorFactors can be entangled. We then have the situation that two qubits are described by the same TensorFactor
-
-#This structure allows the simulation to perform entangling operations only when they are really needed
-#If a circuit consists of two blocks which are never entangled, after the simulation, the QuantumState
-#will consist of two TensorFactors
-class QuantumState:
-    
-    def __init__(self, n):
-        
-        #The index of the tensor factors refers to what qubit they are describing
-        self.tensor_factors = [TensorFactor([i]) for i in range(n)]
-        self.n = n
-    
-    #This functions applies a (unitary) operation onto the tensor factor
-    def apply_operation(self, operation, qubits):
-        #Determine the involved tensor factors and the involved qubits        
-        involved_factors = list(set(sum([[self.tensor_factors[qubits[i]]] for i in range(len(qubits))], [])))
-        involved_qubits = list(set(sum([tf.qubits for tf in involved_factors], [])))
-        
-        #Entangle all the factors involved in the operation
-        entangled_factor = multi_entangle(involved_factors)
-        
-        #Update the entangled factor on the involved qubits
-        for i in range(len(involved_qubits)):
-            self.tensor_factors[involved_qubits[i]] = entangled_factor
-        
-        #Get the unitary of the operation
-        unitary = operation.get_unitary()
-        # unitary = operation.get
-        
-        #Apply the matrix
-        entangled_factor.apply_matrix(unitary, qubits)
-    
-    #Method to retrieve the statevector in the form of an array of complex numbers
-    def eval(self):
-        
-        [factor.unravel() for factor in self.tensor_factors]
-        
-        #print(len(list(set(self.tensor_factors))))
-        
-        entangled_factor = multi_entangle(list(set(self.tensor_factors)))
-        
-        entangled_factor.unravel()
-        return entangled_factor
-    
-    #Copying method
-    def copy(self):
-        
-        factor_list = list(set(self.tensor_factors))
-        new_factor_list = [factor.copy() for factor in factor_list]
-        
-        res = QuantumState(self.n)
-        
-        for i in range(len(new_factor_list)):
-            factor_qubits = new_factor_list[i].qubits
-            for j in range(len(factor_qubits)):
-                res.tensor_factors[factor_qubits[j]] = new_factor_list[i]
-        
-        return res
-    
-    
-    #Method to perform a measurement on this quantum state
-    def measure(self, i, keep_res = True):
-        
-        #Determine the TensorFactor to be measured
-        tensor_factor = self.tensor_factors[i]
-        
-        #Perform measurement on this TensorFactor
-        #p_0 is the measurement probability of measuring p_0,
-        #outcome_tensor_f_0 is the TensorFactor that is left after a measurement with outcome 0 has been performed
-        #ie. if the state descibes |psi> = 2**-0.5 |0>|a> + 2**-0.5|1>|b>
-        #we have p_0 = 0.5 and outcome_tensor_f_0 = |a>
-        p_0, outcome_tensor_f_0, p_1, outcome_tensor_f_1 = tensor_factor.measure(i)
-        
-        
-        #This code block handles several cases that mainly serve to prevent simulation of QuantumStates with
-        #a probablity of 0 to be measured.
-        if p_0 != 0:
-            
-            #If both measurement results have non-zero probability, we copy self
-            #In case only one state has non-zero probability we can continue using self
-            if p_1 != 0:
-                outcome_state_0 = self.copy()
-            else:
-                outcome_state_0 = self
-            
-            #Update the tensor factors of the qubits that have been entangled to the measured qubit
-            outcome_qubits = outcome_tensor_f_0.qubits
-            for j in range(len(outcome_qubits)):
-                outcome_state_0.tensor_factors[outcome_qubits[j]] = outcome_tensor_f_0
-            
-            #Update the qubit that has been measured (now it's own tensor factor again)
-            outcome_state_0.tensor_factors[i] = TensorFactor([i])
-            
-        else:
-            outcome_state_0 = None
-        
-        #In case the probability to measure a 1 is non-zero, we can basically proceed as above
-        #but we need to set the measured qubit to the |1> state if this is required
-        if p_1 != 0:
-            outcome_state_1 = self
-            temp = outcome_tensor_f_1.qubits
-            for j in range(len(temp)):
-                outcome_state_1.tensor_factors[temp[j]] = outcome_tensor_f_1
-            
-            if keep_res:
-                #This set the measured qubit to the |1> state (described by the array [0,1] instead of [1,0] which descibes the |0> state)
-                outcome_state_1.tensor_factors[i] = TensorFactor([i], xp.array([0,1], dtype = xp.complex64))
-            else:
-                outcome_state_1.tensor_factors[i] = TensorFactor([i])
-        else:
-            outcome_state_1 = None
-        
-        #log measurement out come. Note that we cant return here, because this functions is called as a thread, implying it does not keep the returned result
-        self.last_mes_outcome = (p_0, outcome_state_0, p_1, outcome_state_1)
-        
-        return self.last_mes_outcome
-    
-    def add_qubit(self):
-        
-        self.tensor_factors.append(TensorFactor([self.n]))
-        self.n += 1
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+from qrisp.simulator.numerics_config import xp
+from qrisp.simulator.tensor_factor import TensorFactor, multi_entangle
+
+# This class describes a quantum state
+# This is achieved by another class, the TensorFactor.
+# Each qubit initially has its own tensor factor. When an entangling operation is
+# executed, the TensorFactors can be entangled. We then have the situation that two
+# qubits are described by the same TensorFactor
+
+
+# This structure allows the simulation to perform entangling operations only when they
+# are really needed. If a circuit consists of two blocks which are never entangled,
+# after the simulation, the QuantumState will consist of two TensorFactors.
+class QuantumState:
+    def __init__(self, n):
+        # The index of the tensor factors refers to what qubit they are describing
+        self.tensor_factors = [TensorFactor([i]) for i in range(n)]
+        self.n = n
+
+    # This functions applies a (unitary) operation onto the tensor factor
+    def apply_operation(self, operation, qubits):
+        # Determine the involved tensor factors and the involved qubits
+        involved_factors = list(
+            set(sum([[self.tensor_factors[qubits[i]]] for i in range(len(qubits))], []))
+        )
+        involved_qubits = list(set(sum([tf.qubits for tf in involved_factors], [])))
+
+        # Entangle all the factors involved in the operation
+        entangled_factor = multi_entangle(involved_factors)
+
+        # Update the entangled factor on the involved qubits
+        for i in range(len(involved_qubits)):
+            self.tensor_factors[involved_qubits[i]] = entangled_factor
+
+        # Get the unitary of the operation
+        unitary = operation.get_unitary()
+        # unitary = operation.get
+
+        # Apply the matrix
+        entangled_factor.apply_matrix(unitary, qubits)
+
+    # Method to retrieve the statevector in the form of an array of complex numbers
+    def eval(self):
+        [factor.unravel() for factor in self.tensor_factors]
+
+        # print(len(list(set(self.tensor_factors))))
+
+        entangled_factor = multi_entangle(list(set(self.tensor_factors)))
+
+        entangled_factor.unravel()
+        return entangled_factor
+
+    # Copying method
+    def copy(self):
+        factor_list = list(set(self.tensor_factors))
+        new_factor_list = [factor.copy() for factor in factor_list]
+
+        res = QuantumState(self.n)
+
+        for i in range(len(new_factor_list)):
+            factor_qubits = new_factor_list[i].qubits
+            for j in range(len(factor_qubits)):
+                res.tensor_factors[factor_qubits[j]] = new_factor_list[i]
+
+        return res
+
+    # Method to perform a measurement on this quantum state
+    def measure(self, i, keep_res=True):
+        # Determine the TensorFactor to be measured
+        tensor_factor = self.tensor_factors[i]
+
+        # Perform measurement on this TensorFactor
+        # p_0 is the measurement probability of measuring p_0,
+        # outcome_tensor_f_0 is the TensorFactor that is left after a measurement with
+        # outcome 0 has been performed, i.e. if the state descibes
+        # |psi> = 2**-0.5 |0>|a> + 2**-0.5|1>|b>
+        # we have p_0 = 0.5 and outcome_tensor_f_0 = |a>
+        p_0, outcome_tensor_f_0, p_1, outcome_tensor_f_1 = tensor_factor.measure(i)
+
+        # This code block handles several cases that mainly serve to prevent simulation
+        # of QuantumStates with a probablity of 0 to be measured.
+        if p_0 != 0:
+            # If both measurement results have non-zero probability, we copy self
+            # In case only one state has non-zero probability we can continue using self
+            if p_1 != 0:
+                outcome_state_0 = self.copy()
+            else:
+                outcome_state_0 = self
+
+            # Update the tensor factors of the qubits that have been entangled to the
+            # measured qubit
+            outcome_qubits = outcome_tensor_f_0.qubits
+            for j in range(len(outcome_qubits)):
+                outcome_state_0.tensor_factors[outcome_qubits[j]] = outcome_tensor_f_0
+
+            # Update the qubit that has been measured (now it's own tensor factor again)
+            outcome_state_0.tensor_factors[i] = TensorFactor([i])
+
+        else:
+            outcome_state_0 = None
+
+        # In case the probability to measure a 1 is non-zero, we can basically proceed
+        # as above, but we need to set the measured qubit to the |1> state if this is
+        # required
+        if p_1 != 0:
+            outcome_state_1 = self
+            temp = outcome_tensor_f_1.qubits
+            for j in range(len(temp)):
+                outcome_state_1.tensor_factors[temp[j]] = outcome_tensor_f_1
+
+            if keep_res:
+                # This set the measured qubit to the |1> state (described by the
+                # array [0,1] instead of [1,0] which descibes the |0> state)
+                outcome_state_1.tensor_factors[i] = TensorFactor(
+                    [i], xp.array([0, 1], dtype=xp.complex64)
+                )
+            else:
+                outcome_state_1.tensor_factors[i] = TensorFactor([i])
+        else:
+            outcome_state_1 = None
+
+        # log measurement outcome. Note that we can't return here, because this function
+        # is called as a thread, implying it does not keep the returned result
+        self.last_mes_outcome = (p_0, outcome_state_0, p_1, outcome_state_1)
+
+        return self.last_mes_outcome
+
+    def add_qubit(self):
+        self.tensor_factors.append(TensorFactor([self.n]))
+        self.n += 1
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/simulator.py` & `qrisp-0.0.16/src/qrisp/simulator/simulator.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,365 +1,362 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-import numpy as np   
-from qrisp.circuit import transpile, QuantumCircuit, Instruction, Operation, ControlledOperation, fast_append
-from qrisp.simulator.impure_quantum_state import ImpureQuantumState
-from qrisp.simulator.quantum_state import QuantumState
-from qrisp.simulator.circuit_preprocessing import circuit_preprocessor, count_measurements_and_treat_alloc, group_qc
-from qrisp.interface.circuit_converter import convert_circuit
-from tqdm import tqdm
-
-import threading
-
-
-
-#This dictionary contains the qrisp operations as values and their names as keys
-#This is advantageous because during the simulation, we dont want to synthesize them every time they are required
-# from qrisp.circuit import op_list
-# op_dict = {op().name : op for op in op_list}
-
-
-#This functions determines the quantum state after executing a quantum circuit
-#and afterwards extracts the probability of measuring certain bit strings
-def run(qc, shots, token = "", iqs = None, insert_reset = True):
-    
-    #This command enables fast appending. Fast appending means that the .append method of the QuantumCircuit
-    #class checks much less validity conditions and is also less tolerant regarding inputs.
-    
-    print(f"Simulating {len(qc.qubits)} qubits..", end = "\r")
-    
-    with fast_append():
-        
-        #We convert the circuit which is given with portable objects to a qrisp circuit
-        qc = convert_circuit(qc, "qrisp", transpile = True)
-        
-        
-        #Count the amount of measurements (we can stop the simulation after all measurements are performed)
-        measurement_amount = count_measurements_and_treat_alloc(qc, insert_reset = insert_reset)
-        
-        
-        #Apply circuit preprocessing more
-        qc = circuit_preprocessor(qc)
-        
-        
-        measurement_counter = 0
-        
-        for i in range(len(qc.data)):
-            if qc.data[i].op.name == "measure":
-                measurement_counter += 1
-            if measurement_counter == measurement_amount:
-                break
-            
-        qc.data = qc.data[:i+1]
-        
-        
-        if iqs == None:
-            #Create impure quantum state object. This object tracks multiple decoherent quantum states that can appear when applying a non-unitary operation
-            iqs = ImpureQuantumState(len(qc.qubits), clbit_amount = len(qc.clbits))
-        
-        #Counter to track how many measurements have been performed
-        measurement_counter = 0
-    
-        total_flops = 0
-        for i in range(len(qc.data)):
-            total_flops += 2**qc.data[i].op.num_qubits
-        
-        progress_bar = tqdm(
-                            total = total_flops,
-                            desc = f"Simulating {qc.num_qubits()} qubits..", 
-                            bar_format="{desc} |{bar}| [{percentage:3.0f}%]", 
-                            ncols = 85, 
-                            # ascii = " >#",
-                            leave = False,
-                            delay = 0.2,
-                            position = 0,
-                            smoothing = 1
-                            # colour = "green"
-                            )
-        
-        
-        #Main loop - this loop successively executes operations onto the impure quantum state object
-        for i in range(len(qc.data)):
-            
-            #Set alias for the instruction of this operation        
-            instr = qc.data[i]
-    
-            progress_bar.update(2**instr.op.num_qubits)
-    
-            
-            #Gather the indices of the qubits from the circuits (ie. integers instead of the identifier strings)
-            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
-            
-            
-            #Perform instructions
-            
-            if instr.op.name == "reset":
-                iqs.reset(qubit_indices[0])
-            
-            #Disentangling describes an operation, which mean that the superposition of two states can be safely
-            #treated as two decoherent states. This is advantageous because if might be possible that the amplitude of one
-            #state is 0, which means that we halfed the workload. Even if both states have non-zero amplitude, this still
-            #yields an improvement because computing two decoherent states is more easily parallelized than the combined
-            #coherent state
-            elif instr.op.name == "disentangle":
-                iqs.reset(qubit_indices[0], True)
-            
-            elif instr.op.name == "measure":
-                iqs.measure(qubit_indices[0], qc.clbits.index(instr.clbits[0]))
-                measurement_counter += 1
-            
-            elif instr.op.name[:4] == "c_if":
-                iqs.conditionally_apply_operation(instr.op, qubit_indices, qc.clbits.index(instr.clbits[-1]))
-            #If the operation is unitary, we apply this unitary on to the required qubit indices
-            else:
-                iqs.apply_operation(instr.op, qubit_indices)
-            
-    
-            #If all measurements have been performed, break
-            if measurement_counter == measurement_amount:
-                break
-        
-        progress_bar.close()
-        
-        LINE_UP = '\033[1A'
-        LINE_CLEAR = '\x1b[2K'
-        print(LINE_CLEAR, end= "\r")
-        # print(LINE_UP, end = "")
-        
-        
-        #Prepare result dictionary
-        #The iqs object contains the outcome bitstrings in the attribute .outcome_list and the probablities in .cl_prob
-        #In order to ensure qiskit compatibility, we reverse the bitstrings
-        res = {}
-        for i in range(len(iqs.cl_prob)):
-            
-            if iqs.cl_prob[i] == 0:
-                continue
-            
-            outcome_str = ""
-            for j in range(len(iqs.outcome_list[i])):
-                if iqs.outcome_list[i][j]:
-                    outcome_str += "1"
-                else:
-                    outcome_str += "0"
-            
-            try:
-                res[outcome_str[::-1]] += int(np.round(iqs.cl_prob[i]*shots))
-            except KeyError:
-                res[outcome_str[::-1]] = int(np.round(iqs.cl_prob[i]*shots))
-        
-        return res
-
-
-def statevector_sim(qc):
-    
-    #This command enables fast appending. Fast appending means that the .append method of the QuantumCircuit
-    #class checks much less validity conditions and is also less tolerant regarding inputs.
-    with fast_append():
-        #We convert the circuit which is given with portable objects to a qrisp circuit
-        
-        if not isinstance(qc, QuantumCircuit):
-            qc = convert_circuit(qc, "qrisp", transpile = True)
-            
-            
-        qc = qc.copy()
-        
-        #TO-DO fix qubit ordering
-        # qc.qubits = qc.qubits[::-1]
-        
-        #Count the amount of measurements (we can stop the simulation after all measurements are performed)
-        measurement_amount = count_measurements_and_treat_alloc(qc, insert_reset = False)
-        
-        if measurement_amount != 0:
-            raise Exception("Tried to determine the statevector of a circuit containing a measurement")
-        
-        #Apply circuit preprocessing more
-        qc = group_qc(qc)
-        
-        if len(qc.data) == 0:
-            res = np.zeros(2**len(qc.qubits), dtype = np.complex64)
-            res[0] = 1
-            return res
-        
-        qs = QuantumState(len(qc.qubits))
-        
-        
-        total_flops = 0
-        for i in range(len(qc.data)):
-            total_flops += 2**qc.data[i].op.num_qubits
-        
-        progress_bar = tqdm(
-                            total = total_flops,
-                            desc = f"Simulating {qc.num_qubits()} qubits..", 
-                            bar_format="{desc} |{bar}| [{percentage:3.0f}%]", 
-                            ncols = 85, 
-                            #ascii = " >#",
-                            leave = False,
-                            delay = 0.2,
-                            position = 0)
-        
-        
-        
-        
-        #Main loop - this loop successively executes operations onto the impure quantum state object
-        for i in range(len(qc.data)):
-            
-            #Set alias for the instruction of this operation        
-            instr = qc.data[i]
-                
-            
-            progress_bar.update(2**instr.op.num_qubits)
-            #Gather the indices of the qubits from the circuits (ie. integers instead of the identifier strings)
-            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
-            
-            #Perform instructions
-            qs.apply_operation(instr.op, qubit_indices)
-        
-        res = qs.eval().tensor_array.to_array()
-        
-        progress_bar.close()
-        
-        LINE_UP = '\033[1A'
-        LINE_CLEAR = '\x1b[2K'
-        print(LINE_CLEAR, end= "\r")
-        # print(LINE_UP, end = "")
-        
-        
-        
-        #Deactivate the fast append mode
-        QuantumCircuit.fast_append = False
-        
-        return res
-    
-
-
-def single_shot_sim(qc, quantum_state = None):
-    
-    
-    if len(qc.data) == 0:
-        return "", quantum_state
-    
-    #This command enables fast appending. Fast appending means that the .append method of the QuantumCircuit
-    #class checks much less validity conditions and is also less tolerant regarding inputs.
-    with fast_append():    
-    
-        
-        #We convert the circuit which is given with portable objects to a qrisp circuit
-        qc = convert_circuit(qc, "qrisp", transpile = True)
-        
-        
-        
-        
-        #Treat allocation gates (ie. remove them)
-        count_measurements_and_treat_alloc(qc, insert_reset = True)
-        
-        
-        
-        
-        from qrisp.simulator import reorder_circuit    
-        qc = group_qc(qc)
-        
-        
-        qc = reorder_circuit(qc, ["measure", "reset", "disentangle"])
-        
-        
-        if quantum_state == None:
-            #Create quantum state object.
-            quantum_state = QuantumState(len(qc.qubits))
-        
-        result_str = len(qc.clbits)*["0"]
-        
-        
-        import random
-        
-        
-        if len(qc.data):
-            #Wrapper to pre calculate the unitaries from the preprocessed circuit in parallel with the main thread    
-            def pre_calc_unitaries(op):
-                try:
-                    op.get_unitary()
-                except:
-                    pass
-            
-            # pre_calc_unitaries()
-            
-            pre_calc_thr = threading.Thread(target = pre_calc_unitaries, args = (qc.data[0].op,))
-            pre_calc_thr.start()
-            
-        
-        #Main loop - this loop successively executes operations onto the impure quantum state object
-        for i in range(len(qc.data)):
-            
-            
-            
-            pre_calc_thr.join()
-            
-            if i < len(qc.data) - 1:
-                
-                pre_calc_thr = threading.Thread(target = pre_calc_unitaries, args = (qc.data[i+1].op,))
-                pre_calc_thr.start()
-            
-            #Set alias for the instruction of this operation        
-            instr = qc.data[i]
-            
-            #Gather the indices of the qubits from the circuits (ie. integers instead of the identifier strings)
-            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
-            
-            
-            
-            # Perform instructions
-            if instr.op.name == "reset":
-                quantum_state.measure(qubit_indices[0])
-                
-                p_0, state_0, p_1, state_1 = quantum_state.last_mes_outcome
-                
-                rng = random.random()
-                
-                if rng < p_0:
-                    quantum_state = state_0
-                else:
-                    quantum_state = state_1
-                
-            
-            #Disentangling describes an operation, which mean that the superposition of two states can be safely
-            #treated as two decoherent states. This is advantageous because if might be possible that the amplitude of one
-            #state is 0, which means that we halfed the workload. Even if both states have non-zero amplitude, this still
-            #yields an improvement because computing two decoherent states is more easily parallelized than the combined
-            #coherent state
-            
-            elif instr.op.name == "measure":
-                
-                quantum_state.measure(qubit_indices[0])
-                
-                p_0, state_0, p_1, state_1 = quantum_state.last_mes_outcome
-                
-                
-                rng = random.random()
-                
-                if rng < p_0:
-                    quantum_state = state_0
-                else:
-                    quantum_state = state_1
-                    result_str[qc.clbits.index(instr.clbits[0])] = "1"
-                
-            
-            elif instr.op.name[:4] == "c_if":
-                
-                if result_str[qc.clbits.index(instr.clbits[0])] == "1":
-                    quantum_state.apply_operation(instr.op, qubit_indices)
-            #If the operation is unitary, we apply this unitary on to the required qubit indices
-            else:
-                quantum_state.apply_operation(instr.op, qubit_indices)
-                
-                
-        return "".join(result_str)[::-1], quantum_state
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+import threading
+
+# -*- coding: utf-8 -*-
+import numpy as np
+from tqdm import tqdm
+
+from qrisp.circuit import (
+    ControlledOperation,
+    Instruction,
+    Operation,
+    QuantumCircuit,
+    fast_append,
+    transpile,
+)
+from qrisp.interface.circuit_converter import convert_circuit
+from qrisp.simulator.circuit_preprocessing import (
+    circuit_preprocessor,
+    count_measurements_and_treat_alloc,
+    group_qc,
+)
+from qrisp.simulator.impure_quantum_state import ImpureQuantumState
+from qrisp.simulator.quantum_state import QuantumState
+
+# This dictionary contains the qrisp operations as values and their names as keys.
+# This is advantageous because during the simulation, we don't want to synthesize them
+# every time they are required
+# from qrisp.circuit import op_list
+# op_dict = {op().name : op for op in op_list}
+
+
+# This functions determines the quantum state after executing a quantum circuit
+# and afterwards extracts the probability of measuring certain bit strings
+def run(qc, shots, token="", iqs=None, insert_reset=True):
+    
+    progress_bar = tqdm(
+        desc=f"Simulating {len(qc.qubits)} qubits..",
+        bar_format="{desc} |{bar}| [{percentage:3.0f}%]",
+        ncols=85,
+        # ascii = " >#",
+        leave=False,
+        delay=0.2,
+        position=0,
+        smoothing=1
+        # colour = "green"
+    )
+    
+    progress_bar.display()
+
+    # This command enables fast appending. Fast appending means that the .append method
+    # of the QuantumCircuit class checks much less validity conditions and is also less
+    # tolerant regarding inputs.
+    with fast_append():
+        # We convert the circuit which is given with portable objects to a qrisp circuit
+        qc = convert_circuit(qc, "qrisp", transpile=True)
+
+        # Count the amount of measurements (we can stop the simulation after all
+        # measurements are performed)
+        measurement_amount = count_measurements_and_treat_alloc(
+            qc, insert_reset=insert_reset
+        )
+
+        # Apply circuit preprocessing more
+        qc = circuit_preprocessor(qc)
+
+        measurement_counter = 0
+
+        for i in range(len(qc.data)):
+            if qc.data[i].op.name == "measure":
+                measurement_counter += 1
+            if measurement_counter == measurement_amount:
+                break
+
+        qc.data = qc.data[: i + 1]
+
+        if iqs is None:
+            # Create impure quantum state object. This object tracks multiple decoherent
+            # quantum states that can appear when applying a non-unitary operation
+            iqs = ImpureQuantumState(len(qc.qubits), clbit_amount=len(qc.clbits))
+
+        # Counter to track how many measurements have been performed
+        measurement_counter = 0
+
+        total_flops = 0
+        for i in range(len(qc.data)):
+            total_flops += 2 ** qc.data[i].op.num_qubits
+
+        progress_bar.total = total_flops
+        # Main loop - this loop successively executes operations onto the impure
+        # quantum state object
+        for i in range(len(qc.data)):
+            # Set alias for the instruction of this operation
+            instr = qc.data[i]
+
+            progress_bar.update(2**instr.op.num_qubits)
+
+            # Gather the indices of the qubits from the circuits (i.e. integers instead
+            # of the identifier strings)
+            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
+
+            # Perform instructions
+
+            if instr.op.name == "reset":
+                iqs.reset(qubit_indices[0])
+
+            # Disentangling describes an operation, which mean that the superposition of
+            # two states can be safely treated as two decoherent states. This is
+            # advantageous because it might be possible that the amplitude of one
+            # state is 0, which means that we halfed the workload. Even if both states
+            # have non-zero amplitude, this still yields an improvement because
+            # computing two decoherent states is more easily parallelized than the
+            # combined coherent state
+            elif instr.op.name == "disentangle":
+                iqs.reset(qubit_indices[0], True)
+
+            elif instr.op.name == "measure":
+                iqs.measure(qubit_indices[0], qc.clbits.index(instr.clbits[0]))
+                measurement_counter += 1
+
+            elif instr.op.name[:4] == "c_if":
+                iqs.conditionally_apply_operation(
+                    instr.op, qubit_indices, qc.clbits.index(instr.clbits[-1])
+                )
+            # If the operation is unitary, we apply this unitary on to the required
+            # qubit indices
+            else:
+                iqs.apply_operation(instr.op, qubit_indices)
+
+            # If all measurements have been performed, break
+            if measurement_counter == measurement_amount:
+                break
+
+        progress_bar.close()
+
+        LINE_UP = "\033[1A"
+        LINE_CLEAR = "\x1b[2K"
+        print(LINE_CLEAR, end="\r")
+        # print(LINE_UP, end = "")
+
+        # Prepare result dictionary
+        # The iqs object contains the outcome bitstrings in the attribute .outcome_list
+        # and the probablities in .cl_prob. In order to ensure qiskit compatibility, we
+        # reverse the bitstrings
+        res = {}
+        for i in range(len(iqs.cl_prob)):
+            if iqs.cl_prob[i] == 0:
+                continue
+
+            outcome_str = ""
+            for j in range(len(iqs.outcome_list[i])):
+                if iqs.outcome_list[i][j]:
+                    outcome_str += "1"
+                else:
+                    outcome_str += "0"
+
+            try:
+                res[outcome_str[::-1]] += int(np.round(iqs.cl_prob[i] * shots))
+            except KeyError:
+                res[outcome_str[::-1]] = int(np.round(iqs.cl_prob[i] * shots))
+
+        return res
+
+
+def statevector_sim(qc):
+    
+    progress_bar = tqdm(
+        desc=f"Simulating {len(qc.qubits)} qubits..",
+        bar_format="{desc} |{bar}| [{percentage:3.0f}%]",
+        ncols=85,
+        # ascii = " >#",
+        leave=False,
+        delay=0.2,
+        position=0,
+        smoothing=1
+        # colour = "green"
+    )
+    
+    # This command enables fast appending. Fast appending means that the .append method
+    # of the QuantumCircuit class checks much less validity conditions and is also less
+    # tolerant regarding inputs.
+    with fast_append():
+        # We convert the circuit which is given with portable objects to a qrisp circuit
+
+        if not isinstance(qc, QuantumCircuit):
+            qc = convert_circuit(qc, "qrisp", transpile=True)
+
+        qc = qc.copy()
+
+        # TO-DO fix qubit ordering
+        # qc.qubits = qc.qubits[::-1]
+
+        # Count the amount of measurements (we can stop the simulation after all
+        # measurements are performed)
+        measurement_amount = count_measurements_and_treat_alloc(qc, insert_reset=False)
+
+        if measurement_amount != 0:
+            raise Exception(
+                "Tried to determine the statevector of a circuit containing a "
+                "measurement"
+            )
+
+        # Apply circuit preprocessing more
+        qc = group_qc(qc)
+
+        if len(qc.data) == 0:
+            res = np.zeros(2 ** len(qc.qubits), dtype=np.complex64)
+            res[0] = 1
+            return res
+
+        qs = QuantumState(len(qc.qubits))
+
+        total_flops = 0
+        for i in range(len(qc.data)):
+            total_flops += 2 ** qc.data[i].op.num_qubits
+
+        progress_bar.total = total_flops
+
+        # Main loop - this loop successively executes operations onto the impure
+        # quantum state object
+        for i in range(len(qc.data)):
+            # Set alias for the instruction of this operation
+            instr = qc.data[i]
+
+            progress_bar.update(2**instr.op.num_qubits)
+            # Gather the indices of the qubits from the circuits (i.e. integers instead
+            # of the identifier strings)
+            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
+
+            # Perform instructions
+            qs.apply_operation(instr.op, qubit_indices)
+
+        res = qs.eval().tensor_array.to_array()
+
+        progress_bar.close()
+
+        LINE_UP = "\033[1A"
+        LINE_CLEAR = "\x1b[2K"
+        print(LINE_CLEAR, end="\r")
+        # print(LINE_UP, end = "")
+
+        # Deactivate the fast append mode
+        QuantumCircuit.fast_append = False
+
+        return res
+
+
+def single_shot_sim(qc, quantum_state=None):
+    if len(qc.data) == 0:
+        return "", quantum_state
+
+    # This command enables fast appending. Fast appending means that the .append method
+    # of the QuantumCircuit class checks much less validity conditions and is also less
+    # tolerant regarding inputs.
+    with fast_append():
+        # We convert the circuit which is given with portable objects to a qrisp circuit
+        qc = convert_circuit(qc, "qrisp", transpile=True)
+
+        # Treat allocation gates (ie. remove them)
+        count_measurements_and_treat_alloc(qc, insert_reset=True)
+
+        from qrisp.simulator import reorder_circuit
+
+        qc = group_qc(qc)
+
+        qc = reorder_circuit(qc, ["measure", "reset", "disentangle"])
+
+        if quantum_state is None:
+            # Create quantum state object.
+            quantum_state = QuantumState(len(qc.qubits))
+
+        result_str = len(qc.clbits) * ["0"]
+
+        import random
+
+        if len(qc.data):
+            # Wrapper to pre-calculate the unitaries from the preprocessed circuit in
+            # parallel with the main thread
+            def pre_calc_unitaries(op):
+                try:
+                    op.get_unitary()
+                except:
+                    pass
+
+            # pre_calc_unitaries()
+
+            pre_calc_thr = threading.Thread(
+                target=pre_calc_unitaries, args=(qc.data[0].op,)
+            )
+            pre_calc_thr.start()
+
+        # Main loop - this loop successively executes operations onto the impure
+        # quantum state object
+        for i in range(len(qc.data)):
+            pre_calc_thr.join()
+
+            if i < len(qc.data) - 1:
+                pre_calc_thr = threading.Thread(
+                    target=pre_calc_unitaries, args=(qc.data[i + 1].op,)
+                )
+                pre_calc_thr.start()
+
+            # Set alias for the instruction of this operation
+            instr = qc.data[i]
+
+            # Gather the indices of the qubits from the circuits (i.e. integers instead
+            # of the identifier strings)
+            qubit_indices = [qc.qubits.index(qb) for qb in instr.qubits]
+
+            # Perform instructions
+            if instr.op.name == "reset":
+                quantum_state.measure(qubit_indices[0])
+
+                p_0, state_0, p_1, state_1 = quantum_state.last_mes_outcome
+
+                rng = random.random()
+
+                if rng < p_0:
+                    quantum_state = state_0
+                else:
+                    quantum_state = state_1
+
+            # Disentangling describes an operation, which mean that the superposition of
+            # two states can be safely treated as two decoherent states. This is
+            # advantageous because it might be possible that the amplitude of one state
+            # is 0, which means that we halfed the workload. Even if both states have
+            # non-zero amplitude, this still yields an improvement because computing two
+            # decoherent states is more easily parallelized than the combined coherent
+            # state.
+
+            elif instr.op.name == "measure":
+                quantum_state.measure(qubit_indices[0])
+
+                p_0, state_0, p_1, state_1 = quantum_state.last_mes_outcome
+
+                rng = random.random()
+
+                if rng < p_0:
+                    quantum_state = state_0
+                else:
+                    quantum_state = state_1
+                    result_str[qc.clbits.index(instr.clbits[0])] = "1"
+
+            elif instr.op.name[:4] == "c_if":
+                if result_str[qc.clbits.index(instr.clbits[0])] == "1":
+                    quantum_state.apply_operation(instr.op, qubit_indices)
+            # If the operation is unitary, we apply this unitary on to the required qubit
+            # indices
+            else:
+                quantum_state.apply_operation(instr.op, qubit_indices)
+
+        return "".join(result_str)[::-1], quantum_state
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/tensor_factor.py` & `qrisp-0.0.16/src/qrisp/simulator/tensor_factor.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,193 +1,195 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-from qrisp.simulator.numerics_config import xp, float_tresh
-from qrisp.simulator.bi_arrays import SparseBiArray, DenseBiArray, tensordot
-
-#tensordot = xp.tensordot
-
-#Class to describe TensorFactors
-
-class TensorFactor:
-    
-    def __init__(self, qubits, init_tensor_array = None):
-        
-        #This list contrains a list of integers, which describe the current permutation of qubit indices inside this TensorFactor
-        #ie. swapping two elements of this list is the same as applying a swap gate. Using this structure is advantageous
-        #because applying matrices on specific qubit indices requires alot of swapping
-        #Swapping the indices of an array is ressource costly because the array needs to be copied.
-        #As it turns out memory speed is a bottleneck.
-        self.qubits = qubits
-        
-        self.n = len(qubits)
-        
-        if init_tensor_array is None:
-            self.tensor_array = xp.zeros(2**self.n, dtype = xp.complex64)
-            self.tensor_array[0] = 1
-            
-        else:
-            self.tensor_array = init_tensor_array
-        
-        if isinstance(self.tensor_array, xp.ndarray):
-            self.tensor_array = SparseBiArray(self.tensor_array)
-        
-       
-    def copy(self):
-        return TensorFactor(list(self.qubits), self.tensor_array.copy())
-    
-    #Swaps two qubit indices
-    def swap(self, i, j):
-        
-        if i == j:
-            return
-        
-        self.qubits[i], self.qubits[j] = self.qubits[j], self.qubits[i]
-        
-        self.tensor_array = self.tensor_array.reshape(self.n*[2])
-        self.tensor_array = self.tensor_array.swapaxes(i, j)
-        self.tensor_array = self.tensor_array.reshape(2**self.n)
-    
-    
-    #Applies a matrix onto the given state
-    def apply_matrix(self, matrix, qubits):
-        
-        
-        #Remove the non-zero entries caused by floating point errors to get 
-        #the most out of the sparse matrix representation
-        import numpy as np
-        if matrix.size >= 2**6:
-            
-            if matrix.dtype == np.complex64:
-                matrix = matrix*(np.abs(matrix) > 1E-7)                
-            if matrix.dtype == np.complex128:
-                matrix = matrix*(np.abs(matrix) > 1E-15) 
-                
-        #Convert matrix to BiArray
-        matrix = DenseBiArray(matrix)
-        
-        #Swap the qubits which the matrix is supposed to be applied on to the front
-        for i in range(len(qubits)):
-            qubit_index = self.qubits.index(qubits[i])
-            self.swap(qubit_index, i)
-        
-        #Reshape tensor array such that the qubits form a single index
-        reshaped_tensor_array = self.tensor_array.reshape((matrix.shape[0], 2**self.n//matrix.shape[0]))
-        
-        #Apply matrix
-        self.tensor_array = tensordot(matrix, reshaped_tensor_array,  axes = (1,0), contract_sparsity_threshold = 0.05).reshape(2**self.n)
-        # print(type(self.tensor_array))
-    
-    #Entangles two TensorFactors.
-    def entangle(self, other):
-        
-        if self == other:
-            return self
-        if set(self.qubits).intersection(other.qubits):
-            raise Exception("Tried to entangle two tensor factors with overlapping qubits")
-        
-        #The tensordot function with axes = ((),()) performs a,b -> a (x) b, where (x) is the tensor product sign
-        init_array = tensordot(other.tensor_array, self.tensor_array, axes = ((), ()), contract_sparsity_threshold = 0.01).ravel()
-        
-        return TensorFactor(other.qubits + self.qubits, init_array)
-
-
-    #Perform measurement
-    def measure(self, i):
-        
-        #Swap the index that is supposed to be measured to the front
-        index = self.qubits.index(i)
-        self.swap(0, index)
-        
-        #Split the array - the lower half corresponds to the state with outcome 0, the upper half to 1        
-        lower_half, upper_half = self.tensor_array.split()        
-        
-        #Determine probabilities
-        p_0 = lower_half.squared_norm()
-        p_1 = upper_half.squared_norm()
-        
-        #p_1 = abs(p_0 - 1) #This doesn't work due to floating point errors accumulating in the normalization
-        
-        #Prepare the qubit list of the resulting TensorFactor
-        #After the measurement, the measured qubit is disentangled from the rest,
-        #so we can put it into it's own TensorFactor object
-        new_qubit_list = list(self.qubits)
-        new_qubit_list.pop(0)
-        
-        #This treats the case that both measurement probabilities are non-zero
-        if p_0 > float_tresh and p_1> float_tresh:
-            
-            #Normalize the new statevector arrays
-            normalization = 1/(p_0**0.5)
-            lower_half.data *= normalization
-            
-            #Create tensor factor corresponding to outcome 0
-            tensor_factor_0 = TensorFactor(new_qubit_list, lower_half)
-            
-            
-            #Perform the same operation for outcome 1
-            normalization = 1/(p_1**0.5)
-            upper_half.data *= normalization
-            
-            tensor_factor_1 = TensorFactor(list(new_qubit_list), upper_half)
-        
-        #This treats the cases that one of the outcomes has 0 probability
-        elif p_0 < float_tresh:
-            p_0 = 0
-            p_1 = 1
-            tensor_factor_0 = None
-            tensor_factor_1 = TensorFactor(new_qubit_list, upper_half)
-            
-        else:
-            p_0 = 1
-            p_1 = 0
-            tensor_factor_0 = TensorFactor(new_qubit_list, lower_half)
-            tensor_factor_1 = None
-        
-        return p_0, tensor_factor_0, p_1, tensor_factor_1
-    
-    def unravel(self):
-        
-        sorted_qubit_list = list(self.qubits)
-        sorted_qubit_list.sort()
-        for i in range(len(self.qubits)):
-            if sorted_qubit_list[i] == self.qubits[i]:
-                continue
-            self.swap(i, self.qubits.index(sorted_qubit_list[i]))
-
-
-
-#This functions allow entangling more than two TensorFactors
-#Since we are free to choose a contraction order, we pick one
-#that synergizes with the parallelization features of the BiArrays
-#ie. we entangle two factors, and put the entangled result at 
-#the back of a queue. The processing of the entangling is the hopefully
-#done once this factor is at the front of the queue.
-def multi_entangle(input_factor_list):
-    
-    #If there is only one factor, there is nothing to be done
-    if len(input_factor_list) == 1:
-        return input_factor_list[0]
-    
-    else:
-        #In the case of multiple factors, entangle the first two, and put the result at the back
-        
-        input_factor_list.sort(key = lambda x : len(x.qubits))
-        input_factor_list.append(input_factor_list[0].entangle(input_factor_list[1]))
-        
-        #Remove entangling factors from the queue
-        input_factor_list.pop(0)
-        input_factor_list.pop(0)
-        
-        #Recurse on remaining factors
-        return multi_entangle(input_factor_list)
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+from qrisp.simulator.bi_arrays import DenseBiArray, SparseBiArray, tensordot
+from qrisp.simulator.numerics_config import float_tresh, xp
+
+# tensordot = xp.tensordot
+
+# Class to describe TensorFactors
+
+
+class TensorFactor:
+    def __init__(self, qubits, init_tensor_array=None):
+        # This list contains a list of integers, which describe the current permutation
+        # of qubit indices inside this TensorFactor, i.e. swapping two elements of this
+        # list is the same as applying a swap gate. Using this structure is advantageous
+        # because applying matrices on specific qubit indices requires alot of swapping.
+        # Swapping the indices of an array is ressource costly because the array needs
+        # to be copied. As it turns out memory speed is a bottleneck.
+        self.qubits = qubits
+
+        self.n = len(qubits)
+
+        if init_tensor_array is None:
+            self.tensor_array = xp.zeros(2**self.n, dtype=xp.complex64)
+            self.tensor_array[0] = 1
+
+        else:
+            self.tensor_array = init_tensor_array
+
+        if isinstance(self.tensor_array, xp.ndarray):
+            self.tensor_array = SparseBiArray(self.tensor_array)
+
+    def copy(self):
+        return TensorFactor(list(self.qubits), self.tensor_array.copy())
+
+    # Swaps two qubit indices
+    def swap(self, i, j):
+        if i == j:
+            return
+
+        self.qubits[i], self.qubits[j] = self.qubits[j], self.qubits[i]
+
+        self.tensor_array = self.tensor_array.reshape(self.n * [2])
+        self.tensor_array = self.tensor_array.swapaxes(i, j)
+        self.tensor_array = self.tensor_array.reshape(2**self.n)
+
+    # Applies a matrix onto the given state
+    def apply_matrix(self, matrix, qubits):
+        # Remove the non-zero entries caused by floating point errors to get
+        # the most out of the sparse matrix representation
+        import numpy as np
+
+        if matrix.size >= 2**6:
+            if matrix.dtype == np.complex64:
+                matrix = matrix * (np.abs(matrix) > 1e-7)
+            if matrix.dtype == np.complex128:
+                matrix = matrix * (np.abs(matrix) > 1e-15)
+
+        # Convert matrix to BiArray
+        matrix = DenseBiArray(matrix)
+
+        # Swap the qubits which the matrix is supposed to be applied on to the front
+        for i in range(len(qubits)):
+            qubit_index = self.qubits.index(qubits[i])
+            self.swap(qubit_index, i)
+
+        # Reshape tensor array such that the qubits form a single index
+        reshaped_tensor_array = self.tensor_array.reshape(
+            (matrix.shape[0], 2**self.n // matrix.shape[0])
+        )
+
+        # Apply matrix
+        self.tensor_array = tensordot(
+            matrix, reshaped_tensor_array, axes=(1, 0), contract_sparsity_threshold=0.05
+        ).reshape(2**self.n)
+        # print(type(self.tensor_array))
+
+    # Entangles two TensorFactors.
+    def entangle(self, other):
+        if self == other:
+            return self
+        if set(self.qubits).intersection(other.qubits):
+            raise Exception(
+                "Tried to entangle two tensor factors with overlapping qubits"
+            )
+
+        # The tensordot function with axes = ((),()) performs a,b -> a (x) b, where
+        # (x) is the tensor product sign
+        init_array = tensordot(
+            other.tensor_array,
+            self.tensor_array,
+            axes=((), ()),
+            contract_sparsity_threshold=0.01,
+        ).ravel()
+
+        return TensorFactor(other.qubits + self.qubits, init_array)
+
+    # Perform measurement
+    def measure(self, i):
+        # Swap the index that is supposed to be measured to the front
+        index = self.qubits.index(i)
+        self.swap(0, index)
+
+        # Split the array - the lower half corresponds to the state with outcome 0,
+        # the upper half to 1
+        lower_half, upper_half = self.tensor_array.split()
+
+        # Determine probabilities
+        p_0 = lower_half.squared_norm()
+        p_1 = upper_half.squared_norm()
+
+        # p_1 = abs(p_0 - 1) #This doesn't work due to floating point errors
+        # accumulating in the normalization
+
+        # Prepare the qubit list of the resulting TensorFactor
+        # After the measurement, the measured qubit is disentangled from the rest,
+        # so we can put it into it's own TensorFactor object
+        new_qubit_list = list(self.qubits)
+        new_qubit_list.pop(0)
+
+        # This treats the case that both measurement probabilities are non-zero
+        if p_0 > float_tresh and p_1 > float_tresh:
+            # Normalize the new statevector arrays
+            normalization = 1 / (p_0**0.5)
+            lower_half.data *= normalization
+
+            # Create tensor factor corresponding to outcome 0
+            tensor_factor_0 = TensorFactor(new_qubit_list, lower_half)
+
+            # Perform the same operation for outcome 1
+            normalization = 1 / (p_1**0.5)
+            upper_half.data *= normalization
+
+            tensor_factor_1 = TensorFactor(list(new_qubit_list), upper_half)
+
+        # This treats the cases that one of the outcomes has 0 probability
+        elif p_0 < float_tresh:
+            p_0 = 0
+            p_1 = 1
+            tensor_factor_0 = None
+            tensor_factor_1 = TensorFactor(new_qubit_list, upper_half)
+
+        else:
+            p_0 = 1
+            p_1 = 0
+            tensor_factor_0 = TensorFactor(new_qubit_list, lower_half)
+            tensor_factor_1 = None
+
+        return p_0, tensor_factor_0, p_1, tensor_factor_1
+
+    def unravel(self):
+        sorted_qubit_list = list(self.qubits)
+        sorted_qubit_list.sort()
+        for i in range(len(self.qubits)):
+            if sorted_qubit_list[i] == self.qubits[i]:
+                continue
+            self.swap(i, self.qubits.index(sorted_qubit_list[i]))
+
+
+# This function allow entangling more than two TensorFactors.
+# Since we are free to choose a contraction order, we pick one
+# that synergizes with the parallelization features of the BiArrays,
+# i.e. we entangle two factors, and put the entangled result at
+# the back of a queue. The processing of the entangling is hopefully
+# done once this factor is at the front of the queue.
+def multi_entangle(input_factor_list):
+    # If there is only one factor, there is nothing to be done
+    if len(input_factor_list) == 1:
+        return input_factor_list[0]
+
+    else:
+        # In the case of multiple factors, entangle the first two, and put the result
+        # at the back
+
+        input_factor_list.sort(key=lambda x: len(x.qubits))
+        input_factor_list.append(input_factor_list[0].entangle(input_factor_list[1]))
+
+        # Remove entangling factors from the queue
+        input_factor_list.pop(0)
+        input_factor_list.pop(0)
+
+        # Recurse on remaining factors
+        return multi_entangle(input_factor_list)
```

### Comparing `qrisp-0.0.15/src/qrisp/simulator/unitary_management.py` & `qrisp-0.0.16/src/qrisp/simulator/unitary_management.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,359 +1,343 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# -*- coding: utf-8 -*-
-
-import numpy as np
-from qrisp.simulator.bi_arrays import SparseBiArray, DenseBiArray, BiArray, tensordot
-from numba import njit
-import sympy as sp
-
-id_matrix = np.eye(2, dtype = np.complex64)
-
-pauli_x = np.asarray([[0,1],[1,0]], dtype = np.complex64)
-pauli_y = np.asarray([[0,0],[0,0]]) +  1j*np.asarray([[0,-1],[1,0]])
-pauli_z = np.asarray([[1,0],[0,-1]], dtype = np.complex64)
-
-
-#Function which returns the unitary of a u3 gate
-def u3matrix(theta, phi, lam, global_phase):
-    
-    import numpy as module
-    res = module.zeros(shape = (2,2), dtype = module.complex64)
-    
-    from sympy.core.expr import Expr
-    
-    I = 1j
-    for par in [theta, phi, lam, global_phase]:
-        if isinstance(par, Expr):
-            res = module.zeros(shape = (2,2), dtype = "object")
-            import sympy as module
-            I = sp.I
-            break
-    
-    res[0,0] = module.cos(theta/2)
-    res[0,1] = -module.exp(I*lam)*module.sin(theta/2)
-    res[1,0] = module.exp(I*phi)*module.sin(theta/2)
-    res[1,1] = module.exp(I*(phi+lam))*module.cos(theta/2)
-    
-    return res*module.exp(I*global_phase)
-    
-    
-    
-    
-
-#Efficient function to generate the unitary of a controlled gate
-def controlled_unitary(controlled_gate):
-    
-    
-    m = controlled_gate.base_operation.num_qubits
-    try:
-        temp = controlled_gate.base_operation.unitary_array
-    except AttributeError:
-        temp = controlled_gate.base_operation.unitary_array = controlled_gate.base_operation.get_unitary()
-    
-    n = controlled_gate.num_qubits
-    res = np.eye(2**n, dtype = temp.dtype)
-    
-    
-    res[-2**m:,-2**m:] = temp
-    
-    controlled_gate.unitary = temp
-    
-    return res
-
-
-
-    
-
-#Calculates the unitary of a gate embeddded into a circuit of n qubits
-#For instance consider this circuit
-#Here we have gate = CXGate(), n = 4, destination_qubits = [2,3]
-# q80_0: ─────
-            
-# q80_1: ─────
-#        ┌───┐
-# q80_2: ┤ X ├
-#        └─┬─┘
-# q80_3: ──■──
-#This function then returns the overall unitary matrix in the form of either
-#a BiArray or a numpy array depending what is more efficient
-def calc_embedded_unitary(gate, n, destination_qubits):
-    
-    #First we generate the array corresponding to
-    # 1 (x) 1 (x) ... gate
-    #where 1 denotes the identity mapping on a qubit,
-    # (x) the tensor product,
-    # and gate the gate unitary
-
-    #In principle we could use the numpy function np.kron    
-    #tensor_array = np.kron(np.eye(2**(n-m)), gate.get_unitary())
-    
-    #However this performs alot of unnecessary multiplications
-    #since the structure of this matrix is simply the unitary
-    #of the gate on the diagonal 2**n/2**dim(gate) times repeated
-    if not gate.definition is None:
-        gate_array = __calc_circuit_unitary(gate.definition)
-        gate.unitary = gate_array
-    else:
-        gate_array = gate.get_unitary()
-    
-    #Numpy arrays are only fast on a low scale than BiArrays. Therefore we generate
-    #a Numpy Arrays
-    if n < 10 and not gate_array.dtype == np.dtype("O"):
-        tensor_array = generate_id_kron_jitted(gate_array, n)
-    else:
-        tensor_array = generate_id_kron(gate_array, n)
-    
-    #Reshape into an 2n-dimensional array where each axis represents an
-    #index of the tensor factors
-    tensor_array = tensor_array.reshape(n*[2,2])
-    
-    # #Generate the nec<essary swaps to put the destination qubits at the right place
-    swaps = generate_swaps(destination_qubits, n)
-    
-    
-    #Perform swaps
-    for swap in swaps:
-        tensor_array = swap_tensor_factors(tensor_array, *swap)
-    
-
-    #Shape back into the 2**n x 2**n matrix
-    tensor_array = tensor_array.reshape([1<<n, 1<<n])
-    
-    
-    if tensor_array.dtype == np.dtype("O") and n < 10:
-        tensor_array = tensor_array.to_array()
-    
-    
-    
-    return tensor_array
-
-
-#In order to generate the swaps we follow the strategy that 
-#each destination qubit can be guaranteed to be puth in the correct place
-#with a single swap. Therefore we iterate through the destination qubits and
-#successively put them in the right place
-def generate_swaps(destination_qubits, n):
-    
-    #This list represents the current state of the tensor
-    #The list element represents an identity tensor
-    tensor_state = (n - len(destination_qubits))*["id"] + list(destination_qubits)
-    swaps = []
-    
-    #Function to check if the tensor state reached its desired state
-    def check_if_reached(tensor_state):
-        for i in range(len(tensor_state)):
-            if tensor_state[i] != "id":
-                if tensor_state[i] != i:
-                    return False
-        return True
-
-    
-    #Repat until the tensor reached its final state
-    while not check_if_reached(tensor_state):
-        
-        #Iterate through the tensor state and find a qubit which is not
-        #in the correct position.
-        for i in range(len(tensor_state)):
-            if tensor_state[i] != "id":
-                
-                #If tensor_state[i] == i the qubit in question already has reached the final state
-                if tensor_state[i] != i:
-                    
-                    #Swap the list elements
-                    index = int(i)
-                    value = int(tensor_state[i])
-                    tensor_state[index], tensor_state[value] = tensor_state[value], tensor_state[index]
-                    
-                    #Log the swaps
-                    swaps.append((index, value))
-                    
-                    #Restart search for qubit in an incorrect position
-                    break
-
-    return list(swaps)
-
-
-
-
-#Swaps the axis of a kroneker product (tensor product of linear mappings)
-#ie. if we insert tensor = 1 (x) A (x) 1 (x) 1
-#and apply this function with i = 0, j = 1
-#we get A (x) 1 (x) 1 (x) 1
-def swap_tensor_factors(tensor, i, j):
-    n = len(tensor.shape)//2
-    
-    #Note that we have to swap two axes because we are 
-    #dealing with the kroneker product and not the tensor product
-    
-    tensor = tensor.swapaxes(i, j)
-    tensor = tensor.swapaxes(n+i,n + j)
-    
-    return tensor
-
-
-#In principle we could use the numpy function np.kron    
-#tensor_array = np.kron(np.eye(2**(n-m)), gate.get_unitary())
-
-#However this performs alot of unnecessary multiplications
-#since the structure of this matrix is simply the unitary
-#of the gate on the diagonal 2**n/2**dim(gate) times repeated
-def generate_id_kron(input_tensor, n):
-    
-    if isinstance(input_tensor, np.ndarray):
-        if input_tensor.dtype == np.dtype("O"):
-            input_tensor = DenseBiArray(input_tensor)
-        else:
-            input_tensor = SparseBiArray(input_tensor)
-            
-    k = int(np.log2(input_tensor.shape[0]))
-    
-    data = np.ones(2**(n-k))
-    
-    nz_indices = np.arange(2**(n-k)).astype(np.int64)
-    nz_indices = (nz_indices*2**(n-k) + nz_indices)
-    
-    id_tensor = SparseBiArray((nz_indices, data), shape = (2**(n-k), 2**(n-k)))  
-    
-    id_tensor.reshape((n-k)*[2,2])
-    input_tensor.reshape(k*[2,2])
-    
-    res = tensordot(id_tensor, input_tensor, ((),()))
-    
-    
-    for i in range(n-k):
-        for j in range(k):
-            res.swapaxes(2*n - 2*k -1 + j - i, 2*n - 2*k + j -i)
-    
-    
-    
-    
-    res.reshape([2**n, 2**n])
-    
-    return res
-    
-@njit(cache = True)
-def generate_id_kron_jitted(input_tensor, n):
-    
-    res = np.zeros((2**n, 2**n), dtype = input_tensor.dtype)
-    
-    m = int(input_tensor.shape[0])
-    for i in range(2**n//m):
-        res[i*m:(i+1)*m,i*m:(i+1)*m] = input_tensor
-        
-    return res
-
-
-#This functions calculates the unitary of a given circuit
-
-#The idea to make this more efficient is that not all matrix multiplication have to be perforned
-#in the 2**n dimensional basis
-
-#For instance in this circuit:
-
-#      ┌───┐     
-# q_0: ┤ X ├──■──
-#      └───┘┌─┴─┐
-# q_1: ─────┤ X ├
-#           └───┘
-# q_2: ──────────
-               
-# q_3: ──────────
-
-#We can calculate the unitary on the first two qubits on the 4 d basis
-#and then embedd this unitary into the 2**4 = 16d basis
-
-
-#In order to harness the effciency gain we use a divide and conquer strategy:
-#We merge the instruction of the circuit into pairs of elementary gates, calculate
-#this unitary and the again merge this unitary with the neighbouring pair of elementary gate
-#Applying this recursively the requires only a single 2**n d matrix multiplication
-
-def __calc_circuit_unitary(qc):
-
-    n = len(qc.qubits)
-
-    #If the circuit is empty, return the identity matrix    
-    if len(qc.data) == 0:
-        return np.eye(2**n)
-    
-    #If the circuit contains only a single insturction,
-    #calculate this instructions unitary and embedd it
-    if len(qc.data) == 1:
-        
-        instr_0 = qc.data[0]
-        unitary_0 = calc_embedded_unitary(qc.data[0].op, n, [qc.qubits.index(qb) for qb in instr_0.qubits])
-        
-        return unitary_0
-    
-    
-    #If the circuit is a pair of instructions and uses all qubits,
-    #we calculate their product by matrix multiplication
-    
-    #If the circuit contained unused qubits, the next "else" statement will turn
-    #this circuit into it's version without any idle qubits
-    #and this case is then called at a later recursion
-    elif len(qc.data) == 2 and len(qc.qubits) == len(set(qc.data[0].qubits).union(qc.data[1].qubits)):
-            
-        instr_0 = qc.data[0]    
-        instr_1 = qc.data[1]
-        
-        unitary_0 = calc_embedded_unitary(instr_0.op, n, [qc.qubits.index(qb) for qb in instr_0.qubits])
-        unitary_1 = calc_embedded_unitary(instr_1.op, n, [qc.qubits.index(qb) for qb in instr_1.qubits])
-        
-        res = tensordot(unitary_1, unitary_0, (1,0), contract_sparsity_threshold = 0.01)
-        
-    #This is the case where we generate the pairs of instructions
-    else:
-        
-        #Set up a new circuit where the merged instructions are appended
-        recursion_qc = qc.clearcopy()
-        
-        #Merge every pair of neighbouring instructions into one instruction
-        for i in range(0, len(qc.data), 2):
-            if i+1 < len(qc.data):
-                recursion_qc.append(qc.data[i].merge(qc.data[i+1]))
-            else:
-                recursion_qc.append(qc.data[i])
-        #The recursion circuit now has about half of the instructions of the original quantum circuit
-        #Therefore the recursion is finite
-        res = __calc_circuit_unitary(recursion_qc)
-    
-            
-    return res    
-
-from qrisp import fast_append
-#The result of __calc_circuit_unitary can either be a numpy array or a BiArray.
-#This is important in order for the recursion structure to work out
-#This function is a wrapper that converts to the desired output
-def calc_circuit_unitary(qc, res_type = "numpy"):
-    with fast_append():
-        res = __calc_circuit_unitary(qc)
-    
-    if res_type == "numpy":
-        
-        if isinstance(res, BiArray):
-            res = res.to_array()
-        
-        return res
-    
-    elif res_type == "bi_array":
-        
-        if isinstance(res, BiArray):
-            return res
-        
-        return DenseBiArray(res)
-        
-    
-    else:
-        raise Exception("Don't know result type " + res_type)
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# -*- coding: utf-8 -*-
+
+import numpy as np
+import sympy as sp
+from numba import njit
+
+from qrisp import fast_append
+from qrisp.simulator.bi_arrays import BiArray, DenseBiArray, SparseBiArray, tensordot
+
+id_matrix = np.eye(2, dtype=np.complex64)
+
+pauli_x = np.asarray([[0, 1], [1, 0]], dtype=np.complex64)
+pauli_y = np.asarray([[0, 0], [0, 0]]) + 1j * np.asarray([[0, -1], [1, 0]])
+pauli_z = np.asarray([[1, 0], [0, -1]], dtype=np.complex64)
+
+
+# Function which returns the unitary of a u3 gate
+def u3matrix(theta, phi, lam, global_phase):
+    import numpy as module
+
+    res = module.zeros(shape=(2, 2), dtype=module.complex64)
+
+    from sympy.core.expr import Expr
+
+    I = 1j
+    for par in [theta, phi, lam, global_phase]:
+        if isinstance(par, Expr):
+            res = module.zeros(shape=(2, 2), dtype="object")
+            import sympy as module
+
+            I = sp.I
+            break
+
+    res[0, 0] = module.cos(theta / 2)
+    res[0, 1] = -module.exp(I * lam) * module.sin(theta / 2)
+    res[1, 0] = module.exp(I * phi) * module.sin(theta / 2)
+    res[1, 1] = module.exp(I * (phi + lam)) * module.cos(theta / 2)
+
+    return res * module.exp(I * global_phase)
+
+
+# Efficient function to generate the unitary of a controlled gate
+def controlled_unitary(controlled_gate):
+    m = controlled_gate.base_operation.num_qubits
+    try:
+        temp = controlled_gate.base_operation.unitary_array
+    except AttributeError:
+        temp = (
+            controlled_gate.base_operation.unitary_array
+        ) = controlled_gate.base_operation.get_unitary()
+
+    n = controlled_gate.num_qubits
+    res = np.eye(2**n, dtype=temp.dtype)
+
+    res[-(2**m) :, -(2**m) :] = temp
+
+    controlled_gate.unitary = temp
+
+    return res
+
+
+# Calculates the unitary of a gate embeddded into a circuit of n qubits
+# For instance consider this circuit
+# Here we have gate = CXGate(), n = 4, destination_qubits = [2,3]
+# q80_0: ─────
+
+
+# q80_1: ─────
+#        ┌───┐
+# q80_2: ┤ X ├
+#        └─┬─┘
+# q80_3: ──■──
+# This function then returns the overall unitary matrix in the form of either
+# a BiArray or a numpy array depending what is more efficient
+def calc_embedded_unitary(gate, n, destination_qubits):
+    # First we generate the array corresponding to
+    # 1 (x) 1 (x) ... gate
+    # where 1 denotes the identity mapping on a qubit,
+    # (x) the tensor product,
+    # and gate the gate unitary
+
+    # In principle, we could use the numpy function np.kron
+    # tensor_array = np.kron(np.eye(2**(n-m)), gate.get_unitary())
+
+    # However, this performs alot of unnecessary multiplications since the structure of
+    # this matrix is simply the unitary of the gate on the diagonal 2**n/2**dim(gate)
+    # times repeated
+    if gate.definition is not None:
+        gate_array = __calc_circuit_unitary(gate.definition)
+        gate.unitary = gate_array
+    else:
+        gate_array = gate.get_unitary()
+
+    # Numpy arrays are only fast on a low scale than BiArrays. Therefore,  we generate
+    # a Numpy Arrays
+    if n < 10 and not gate_array.dtype == np.dtype("O"):
+        tensor_array = generate_id_kron_jitted(gate_array, n)
+    else:
+        tensor_array = generate_id_kron(gate_array, n)
+
+    # Reshape into an 2n-dimensional array where each axis represents an
+    # index of the tensor factors
+    tensor_array = tensor_array.reshape(n * [2, 2])
+
+    # #Generate the nec<essary swaps to put the destination qubits at the right place
+    swaps = generate_swaps(destination_qubits, n)
+
+    # Perform swaps
+    for swap in swaps:
+        tensor_array = swap_tensor_factors(tensor_array, *swap)
+
+    # Shape back into the 2**n x 2**n matrix
+    tensor_array = tensor_array.reshape([1 << n, 1 << n])
+
+    if tensor_array.dtype == np.dtype("O") and n < 10:
+        tensor_array = tensor_array.to_array()
+
+    return tensor_array
+
+
+# In order to generate the swaps we follow the strategy that
+# each destination qubit can be guaranteed to be puth in the correct place
+# with a single swap. Therefore, we iterate through the destination qubits and
+# successively put them in the right place
+def generate_swaps(destination_qubits, n):
+    # This list represents the current state of the tensor
+    # The list element represents an identity tensor
+    tensor_state = (n - len(destination_qubits)) * ["id"] + list(destination_qubits)
+    swaps = []
+
+    # Function to check if the tensor state reached its desired state
+    def check_if_reached(tensor_state):
+        for i in range(len(tensor_state)):
+            if tensor_state[i] != "id":
+                if tensor_state[i] != i:
+                    return False
+        return True
+
+    # Repat until the tensor reached its final state
+    while not check_if_reached(tensor_state):
+        # Iterate through the tensor state and find a qubit which is not
+        # in the correct position.
+        for i in range(len(tensor_state)):
+            if tensor_state[i] != "id":
+                # If tensor_state[i] == i the qubit in question already has reached the
+                # final state
+                if tensor_state[i] != i:
+                    # Swap the list elements
+                    index = int(i)
+                    value = int(tensor_state[i])
+                    tensor_state[index], tensor_state[value] = (
+                        tensor_state[value],
+                        tensor_state[index],
+                    )
+
+                    # Log the swaps
+                    swaps.append((index, value))
+
+                    # Restart search for qubit in an incorrect position
+                    break
+
+    return list(swaps)
+
+
+# Swaps the axis of a kroneker product (tensor product of linear mappings)
+# ie. if we insert tensor = 1 (x) A (x) 1 (x) 1
+# and apply this function with i = 0, j = 1
+# we get A (x) 1 (x) 1 (x) 1
+def swap_tensor_factors(tensor, i, j):
+    n = len(tensor.shape) // 2
+
+    # Note that we have to swap two axes because we are
+    # dealing with the kroneker product and not the tensor product
+
+    tensor = tensor.swapaxes(i, j)
+    tensor = tensor.swapaxes(n + i, n + j)
+
+    return tensor
+
+
+# In principle we could use the numpy function np.kron
+# tensor_array = np.kron(np.eye(2**(n-m)), gate.get_unitary())
+
+
+# However this performs alot of unnecessary multiplications
+# since the structure of this matrix is simply the unitary
+# of the gate on the diagonal 2**n/2**dim(gate) times repeated
+def generate_id_kron(input_tensor, n):
+    if isinstance(input_tensor, np.ndarray):
+        if input_tensor.dtype == np.dtype("O"):
+            input_tensor = DenseBiArray(input_tensor)
+        else:
+            input_tensor = SparseBiArray(input_tensor)
+
+    k = int(np.log2(input_tensor.shape[0]))
+
+    data = np.ones(2 ** (n - k))
+
+    nz_indices = np.arange(2 ** (n - k)).astype(np.int64)
+    nz_indices = nz_indices * 2 ** (n - k) + nz_indices
+
+    id_tensor = SparseBiArray((nz_indices, data), shape=(2 ** (n - k), 2 ** (n - k)))
+
+    id_tensor.reshape((n - k) * [2, 2])
+    input_tensor.reshape(k * [2, 2])
+
+    res = tensordot(id_tensor, input_tensor, ((), ()))
+
+    for i in range(n - k):
+        for j in range(k):
+            res.swapaxes(2 * n - 2 * k - 1 + j - i, 2 * n - 2 * k + j - i)
+
+    res.reshape([2**n, 2**n])
+
+    return res
+
+
+@njit(cache=True)
+def generate_id_kron_jitted(input_tensor, n):
+    res = np.zeros((2**n, 2**n), dtype=input_tensor.dtype)
+
+    m = int(input_tensor.shape[0])
+    for i in range(2**n // m):
+        res[i * m : (i + 1) * m, i * m : (i + 1) * m] = input_tensor
+
+    return res
+
+
+# This functions calculates the unitary of a given circuit
+
+# The idea to make this more efficient is that not all matrix multiplication have to be
+# perforned in the 2**n dimensional basis
+
+# For instance in this circuit:
+
+#      ┌───┐
+# q_0: ┤ X ├──■──
+#      └───┘┌─┴─┐
+# q_1: ─────┤ X ├
+#           └───┘
+# q_2: ──────────
+
+# q_3: ──────────
+
+# We can calculate the unitary on the first two qubits on the 4 d basis
+# and then embedd this unitary into the 2**4 = 16d basis
+
+
+# In order to harness the effciency gain we use a divide and conquer strategy:
+# We merge the instruction of the circuit into pairs of elementary gates, calculate
+# this unitary and the again merge this unitary with the neighbouring pair of elementary
+# gate. Applying this recursively requires only a single 2**n d matrix multiplication.
+
+
+def __calc_circuit_unitary(qc):
+    n = len(qc.qubits)
+
+    # If the circuit is empty, return the identity matrix
+    if len(qc.data) == 0:
+        return np.eye(2**n)
+
+    # If the circuit contains only a single insturction,
+    # calculate this instructions unitary and embedd it
+    if len(qc.data) == 1:
+        instr_0 = qc.data[0]
+        unitary_0 = calc_embedded_unitary(
+            qc.data[0].op, n, [qc.qubits.index(qb) for qb in instr_0.qubits]
+        )
+
+        return unitary_0
+
+    # If the circuit is a pair of instructions and uses all qubits,
+    # we calculate their product by matrix multiplication
+
+    # If the circuit contained unused qubits, the next "else" statement will turn
+    # this circuit into it's version without any idle qubits
+    # and this case is then called at a later recursion
+    elif len(qc.data) == 2 and len(qc.qubits) == len(
+        set(qc.data[0].qubits).union(qc.data[1].qubits)
+    ):
+        instr_0 = qc.data[0]
+        instr_1 = qc.data[1]
+
+        unitary_0 = calc_embedded_unitary(
+            instr_0.op, n, [qc.qubits.index(qb) for qb in instr_0.qubits]
+        )
+        unitary_1 = calc_embedded_unitary(
+            instr_1.op, n, [qc.qubits.index(qb) for qb in instr_1.qubits]
+        )
+
+        res = tensordot(unitary_1, unitary_0, (1, 0), contract_sparsity_threshold=0.01)
+
+    # This is the case where we generate the pairs of instructions
+    else:
+        # Set up a new circuit where the merged instructions are appended
+        recursion_qc = qc.clearcopy()
+
+        # Merge every pair of neighbouring instructions into one instruction
+        for i in range(0, len(qc.data), 2):
+            if i + 1 < len(qc.data):
+                recursion_qc.append(qc.data[i].merge(qc.data[i + 1]))
+            else:
+                recursion_qc.append(qc.data[i])
+        # The recursion circuit now has about half of the instructions of the original
+        # quantum circuit. Therefore, the recursion is finite
+        res = __calc_circuit_unitary(recursion_qc)
+
+    return res
+
+
+# The result of __calc_circuit_unitary can either be a numpy array or a BiArray.
+# This is important in order for the recursion structure to work out
+# This function is a wrapper that converts to the desired output
+def calc_circuit_unitary(qc, res_type="numpy"):
+    with fast_append():
+        res = __calc_circuit_unitary(qc)
+
+    if res_type == "numpy":
+        if isinstance(res, BiArray):
+            res = res.to_array()
+
+        return res
+
+    elif res_type == "bi_array":
+        if isinstance(res, BiArray):
+            return res
+
+        return DenseBiArray(res)
+
+    else:
+        raise Exception("Don't know result type " + res_type)
```

### Comparing `qrisp-0.0.15/src/qrisp/uncomputation/type_checker.py` & `qrisp-0.0.16/src/qrisp/uncomputation/type_checker.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,174 +8,167 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 import numpy as np
 
-#Checks if a gate is permeable on a set of qubits
-#Permeable means that the gate has the form
+# Checks if a gate is permeable on a set of qubits
+# Permeable means that the gate has the form
 # U = \sum_{x = 0}^{2^n} |x><x| U_x
-#where the braket expression represents the qubits
-#of the list "qubit_indices"
-#{U_x | x <= 2^n} is a set of operations on the remaining qubits
+# where the braket expression represents the qubits
+# of the list "qubit_indices"
+# {U_x | x <= 2^n} is a set of operations on the remaining qubits
 
-#Applying a gate which is permeable on a register R to a computational basis state in R
-#leaves the state of R invariant ie. if R is in state |x>
+# Applying a gate which is permeable on a register R to a computational basis state in R
+# leaves the state of R invariant i.e. if R is in state |x>
 # U |x>|y> = |x> U_x |y>
-#this property will for instance be used to make sure that uncomputations,
-#which are depending on the state of R indeed stil recieve the original state of R
-#when the uncomputation is performed. An error will be thrown if in the meantime,
-#there have been non-permeable operations on R
-
-#But what is the general strategy in determining this property?
-#To understand this, note that if we order the computational basis vectors,
-#such that all the qubits which are supposed to be checked for permeability are at the end
-
-#In this basis, the unitary is block diagonal, where the blocks on the diagonal are the U_x matrices
-#we check the block diagonality by first calculating the block matrices and then create a boolean 2^n x 2^n
-#matrix, where the entry is False if the corresponding block matrix is 0
+# this property will for instance be used to make sure that uncomputations,
+# which depend on the state of R indeed stil recieve the original state of R
+# when the uncomputation is performed. An error will be thrown if in the meantime,
+# there have been non-permeable operations on R
+
+# But what is the general strategy in determining this property?
+# To understand this, note that if we order the computational basis vectors,
+# such that all the qubits which are supposed to be checked for permeability are at the
+# end.
+
+# In this basis, the unitary is block diagonal, where the blocks on the diagonal are the
+# U_x matrices, we check the block diagonality by first calculating the block matrices
+# and then create a boolean 2^n x 2^n matrix, where the entry is False if the
+# corresponding block matrix is 0
 
-#We then check the diagonality of this matrix and return True if so
+
+# We then check the diagonality of this matrix and return True if so
 def is_permeable(gate, qubit_indices):
-    
     for i in qubit_indices:
-        if gate.permeability[i] == False:
+        if gate.permeability[i] is False:
             return False
         elif gate.permeability[i] is None:
             break
     else:
         return True
-    
-    from qrisp.circuit import PTControlledOperation
+
     from qrisp.simulator import calc_embedded_unitary
-    
+
     if gate.definition:
-        
         qc = gate.definition
         for instr in qc.data:
-            relevant_qubits = set([qc.qubits[k] for k in qubit_indices]).intersection(instr.qubits)
-            
+            relevant_qubits = set([qc.qubits[k] for k in qubit_indices]).intersection(
+                instr.qubits
+            )
+
             if not relevant_qubits:
                 continue
-            
+
             if instr.op.name == "measure":
                 return False
-            
+
             local_qubit_indices = [instr.qubits.index(qb) for qb in relevant_qubits]
-            
+
             if not is_permeable(instr.op, local_qubit_indices):
                 break
-        
+
         else:
             for i in qubit_indices:
                 gate.permeability[i] = True
-        
+
             return True
 
-    #Create qubit order
+    # Create qubit order
     qubit_order = []
     for i in range(gate.num_qubits):
-        if not i in qubit_indices:
+        if i not in qubit_indices:
             qubit_order.append(i)
-            
-    #The qubits which are to be checked come first
+
+    # The qubits which are to be checked come first
     qubit_order = qubit_indices + qubit_order
-    
-    #Invert permutation
+
+    # Invert permutation
     qubit_order = [qubit_order.index(i) for i in range(len(qubit_order))]
-    
-    #Calculate unitary
+
+    # Calculate unitary
     unitary = calc_embedded_unitary(gate, gate.num_qubits, qubit_order)
-    
+
     if not isinstance(unitary, np.ndarray):
         unitary = unitary.to_array()
-    
-    #Calculate boolean matrix
-    bbm = get_boolean_block_matrix(unitary, 2**(gate.num_qubits - len(qubit_indices)))
-    #Check non zero off diagonal elements
+
+    # Calculate boolean matrix
+    bbm = get_boolean_block_matrix(unitary, 2 ** (gate.num_qubits - len(qubit_indices)))
+    # Check non-zero off diagonal elements
     off_diagonal_non_zero_count = np.count_nonzero(bbm - np.diag(np.diagonal(bbm)))
-    #Return result
-    
-    
-    from numpy.linalg import norm
+    # Return result
+
     result = not bool(off_diagonal_non_zero_count)
-    
+
     if result:
         for i in qubit_indices:
             gate.permeability[i] = True
-    
-    
+
     return result
 
 
-#Tests if a gate is qfree where qfree is the property that is introduced in SILQ
-#meaning that an operation maps any computational basis state to a computational basis state
+# Tests if a gate is qfree where qfree is the property that is introduced in SILQ
+# meaning that an operation maps any computational basis state to a computational basis
+# state.
 def is_qfree(gate):
-    
-    
-    if not gate.is_qfree is None:
+    if gate.is_qfree is not None:
         return gate.is_qfree
-    
+
     if gate.definition:
-        
         for instr in gate.definition.data:
             if not is_qfree(instr.op):
                 break
         else:
             gate.is_qfree = True
             return True
-    
+
     unitary = np.around(gate.get_unitary(), 5)
-    #Check if the unitary has only one non-zero entry in each line
+    # Check if the unitary has only one non-zero entry in each line
     for i in range(unitary.shape[0]):
-        if np.count_nonzero(unitary[i,:]) != 1:
+        if np.count_nonzero(unitary[i, :]) != 1:
             gate.is_qfree = False
             return False
-        
+
     gate.is_qfree = True
     return True
 
 
-
-    
-#Splits the given matrix into blocks of size block_size
-#Returns an object array where each entry contains the corresponding block
+# Splits the given matrix into blocks of size block_size
+# Returns an object array where each entry contains the corresponding block
 def get_block_matrix(matrix, block_size):
-    
     matrix = np.array(matrix)
     if matrix.shape[0] != matrix.shape[1]:
         raise Exception("Tried to decompose non-square blockmatrix")
-        
-    if matrix.shape[0]%block_size:
+
+    if matrix.shape[0] % block_size:
         raise Exception("Matrix shape is no integer multiple of block size")
-        
-    
-    block_amount = int(matrix.shape[0]/block_size)
-    result = np.zeros((block_amount, block_amount), dtype = "object")
-    
+
+    block_amount = int(matrix.shape[0] / block_size)
+    result = np.zeros((block_amount, block_amount), dtype="object")
+
     for i in range(block_amount):
         for j in range(block_amount):
-            result[i,j] = matrix[i*block_size:(i+1)*block_size, j*block_size:(j+1)*block_size]
-    
+            result[i, j] = matrix[
+                i * block_size : (i + 1) * block_size,
+                j * block_size : (j + 1) * block_size,
+            ]
+
     return result
 
 
-#Recieves a matrix which is turned into a block matrix and then
-#returns a matrix of boolean entries where the entry is False, if
-#the corresponding block is the 0 matrix and True otherwise
+# Recieves a matrix which is turned into a block matrix and then
+# returns a matrix of boolean entries where the entry is False, if
+# the corresponding block is the 0 matrix and True otherwise
 def get_boolean_block_matrix(matrix, block_size):
-    
-    
     block_matrix = get_block_matrix(matrix, block_size)
-        
-    block_amount = int(matrix.shape[0]/block_size)
-    
+
+    block_amount = int(matrix.shape[0] / block_size)
+
     result = np.zeros((block_amount, block_amount))
-    
+
     for i in range(block_amount):
         for j in range(block_amount):
-            
-            if np.linalg.norm(block_matrix[i,j]) > 1E-4:
-                result[i,j] = 1
-    
-    return result
+            if np.linalg.norm(block_matrix[i, j]) > 1e-4:
+                result[i, j] = 1
+
+    return result
```

### Comparing `qrisp-0.0.15/src/qrisp/uncomputation/uncomputation.py` & `qrisp-0.0.16/src/qrisp/uncomputation/uncomputation.py`

 * *Files 15% similar despite different names*

```diff
@@ -9,138 +9,138 @@
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 import numpy as np
 
-def auto_uncompute(*args, recompute = False):
+
+def auto_uncompute(*args, recompute=False):
     if len(args):
         return auto_uncompute_inner(args[0])
     else:
-        
         if recompute:
             from qrisp import gate_wrap
+
             def auto_uncompute_helper(function):
                 return gate_wrap(auto_uncompute_inner(function))
+
             return auto_uncompute_helper
         else:
             return auto_uncompute_inner(args[0])
 
 
-#Decorator for auto uncomputed function
+# Decorator for auto uncomputed function
 def auto_uncompute_inner(function):
-    
-    #Create auto uncomputed function
+    # Create auto uncomputed function
     def auto_uncomputed_function(*args, **kwargs):
-        
-        from qrisp.core import multi_session_merge, recursive_qs_search, recursive_qv_search, QuantumVariable
-        
-        #Acquire quantum session
-        
+        from qrisp.core import (
+            QuantumVariable,
+            multi_session_merge,
+            recursive_qs_search,
+            recursive_qv_search,
+        )
+
+        # Acquire quantum session
+
         qs_list = recursive_qs_search([args, kwargs])
         multi_session_merge(qs_list)
-        
+
         if not len(qs_list):
             return function(*args, **kwargs)
-        
+
         qs = qs_list[0]
-        
-        #Determine quantum variables to uncompute
-        
+
+        # Determine quantum variables to uncompute
         initial_qvs = set([hash(qv()) for qv in QuantumVariable.live_qvs])
-        
-        #Execute function
+
+        # Execute function
         result = function(*args, **kwargs)
-        
+
         result_vars = set([hash(qv) for qv in recursive_qv_search(result)])
-        
+
         uncomp_vars = []
-        
+
         for qv in qs.qv_list:
-            
             if not hash(qv) in initial_qvs.union(result_vars):
-                
                 uncomp_vars.append(qv)
-        
+
         uncompute(qs, uncomp_vars)
-        
+
         return result
-    
+
     auto_uncomputed_function.__name__ = function.__name__ + "_auto_uncomputed"
-    
-    #Return result
+
+    # Return result
     return auto_uncomputed_function
 
-    
 
 verify = np.zeros(1)
 
-def uncompute(qs, uncomp_vars, recompute = False):
+
+def uncompute(qs, uncomp_vars, recompute=False):
     from qrisp import QuantumEnvironment
-    
+
     qubits_to_uncompute = sum([qv.reg for qv in uncomp_vars], [])
-    
+
     i = 0
     while i < len(qs.data):
         if isinstance(qs.data[i], QuantumEnvironment):
             env = qs.data.pop(i)
             env.compile()
             continue
         i += 1
-    
+
     alloc_gates_remaining = list(qubits_to_uncompute)
-    
+
     for i in range(len(qs.data)):
-        
         instr = qs.data[i]
         if isinstance(instr, QuantumEnvironment):
             continue
         if instr.op.name == "qb_alloc" and instr.qubits[0] in alloc_gates_remaining:
             alloc_gates_remaining.remove(instr.qubits[0])
-    
+
     if len(alloc_gates_remaining):
-        
         incorrectly_allocated_qvs = []
-        
+
         for qv in uncomp_vars:
             if set(alloc_gates_remaining).intersection(list(qv)):
                 incorrectly_allocated_qvs.append(qv)
-        
+
         incorrectly_allocated_qvs = [qv.name for qv in incorrectly_allocated_qvs]
-        raise Exception(f"Could not uncompute QuantumVariables {incorrectly_allocated_qvs} because they were not created within this QuantumEnvironment")
-            
-        
+        raise Exception(
+            f"Could not uncompute QuantumVariables {incorrectly_allocated_qvs} "
+            f"because they were not created within this QuantumEnvironment"
+        )
+
     qc_to_uncompute = qs.copy()
-    
+
     recompute_qubits = []
-    
+
     for qb in qc_to_uncompute.qubits:
         if hasattr(qb, "recompute"):
             recompute_qubits.append(qb)
-    
+
     from qrisp.uncomputation.unqomp import uncompute_qc
-    
+
     uncomputed_qc = uncompute_qc(qc_to_uncompute, qubits_to_uncompute, recompute_qubits)
-    
-    
+
     from qrisp import QuantumCircuit
-    
+
     qs.data = []
     QuantumCircuit.fast_append = True
-    
+
     qs.data = uncomputed_qc.data
-    
+
     for qv in uncomp_vars:
-        
         # if recompute:
-            # for qb in qv:
-                # qb.recompute = True
-        
-        qv.delete(verify = bool(verify), recompute = recompute)
-        
-        #The uncomputation algorithm already added deallocation gates
-        #Therefore we remove the deallocation gates
+        # for qb in qv:
+        # qb.recompute = True
+
+        qv.delete(verify=bool(verify), recompute=recompute)
+
+        # The uncomputation algorithm already added deallocation gates
+        # Therefore we remove the deallocation gates
         for i in range(len(qv)):
             qv.qs.data.pop(-1)
-            
-    QuantumCircuit.fast_append = False
+
+    QuantumCircuit.fast_append = False
```

### Comparing `qrisp-0.0.15/src/qrisp/uncomputation/unqomp.py` & `qrisp-0.0.16/src/qrisp/uncomputation/unqomp.py`

 * *Files 10% similar despite different names*

```diff
@@ -7,344 +7,358 @@
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
-from networkx import DiGraph
 import networkx as nx
-from qrisp.uncomputation.type_checker import is_permeable, is_qfree
-from qrisp.circuit import ControlledOperation, PTControlledOperation, QubitDealloc, QubitAlloc, Instruction, QuantumCircuit
+from networkx import DiGraph
+
+from qrisp.circuit import (
+    ControlledOperation,
+    PTControlledOperation,
+    QuantumCircuit,
+
+)
 from qrisp.logic_synthesis import LogicSynthGate
+from qrisp.uncomputation.type_checker import is_permeable, is_qfree
 
 
 class UnqompNode:
-    
-    def __init__(self, name, instr = None):
-        
+    def __init__(self, name, instr=None):
         self.name = name
         self.targets = []
         self.controls = []
         self.uncomputed_node = None
-        
+
         self.instr = instr
         self.hash = hash(self.name)
-    
+
     def __hash__(self):
         return self.hash
-    
+
     def __str__(self):
-        
         if self.instr is None:
             return self.name
         else:
             return str(self.name)
-    
+
     def __repr__(self):
-        
         return str(self)
 
 
 def qc_from_dag(dag):
-    
     res_qc = dag.original_qc.clearcopy()
-    
+
     QuantumCircuit.fast_append = True
-    
+
     for node in nx.topological_sort(dag):
         if node.instr:
             res_qc.append(node.instr)
 
     QuantumCircuit.fast_append = False
-    
+
     return res_qc
 
 
-def dag_from_qc(qc, remove_init_nodes = False):
-    
+def dag_from_qc(qc, remove_init_nodes=False):
     dag = DiGraph()
-    
+
     recent_node_dic = {}
     node_counter = {}
     init_nodes = {}
-    
-    
+
     for i in range(len(qc.qubits)):
-        
         node = UnqompNode("qubit_" + str(i) + "_0")
-        
+
         node.qubit = qc.qubits[i]
-        
+
         dag.add_node(node)
         recent_node_dic[qc.qubits[i]] = node
         node_counter[qc.qubits[i]] = 1
         init_nodes[qc.qubits[i]] = node
-    
-    
+
     dag.init_nodes = init_nodes
-    
+
     dealloc_nodes = []
-    
+
     for i in range(len(qc.data)):
-        
         instr = qc.data[i]
-        
+
         # if instr.op.name == "barrier":
-            # continue
-        
-        #node = UnqompNode(str(qc.qubits.index(instr.qubits[-1])) + "_" + str(node_counter[instr.qubits[-1]]), instr)
+        # continue
+
+        # node = UnqompNode(str(qc.qubits.index(instr.qubits[-1])) + "_"
+        #   + str(node_counter[instr.qubits[-1]]), instr)
         node = UnqompNode(str(node_counter[instr.qubits[-1]]), instr)
-        
+
         if instr.op.name == "qb_dealloc":
             dealloc_nodes.append(node)
-        
+
         dag.add_node(node)
         for j in range(len(instr.qubits)):
-            
             qb = instr.qubits[j]
-            
-            
+
             if is_permeable(instr.op, [j]):
                 edge_type = "control"
                 node.controls.append(qb)
             else:
                 edge_type = "target"
-            
-            if dag.has_edge(recent_node_dic[qb], node) and dag.get_edge_data(recent_node_dic[qb], node)["edge_type"] != "anti_dependency":
+
+            if (
+                dag.has_edge(recent_node_dic[qb], node)
+                and dag.get_edge_data(recent_node_dic[qb], node)["edge_type"]
+                != "anti_dependency"
+            ):
                 dag.get_edge_data(recent_node_dic[qb], node)["qubits"].append(qb)
             else:
-                dag.add_edge(recent_node_dic[qb], node, edge_type = edge_type, qubits = [qb])
-            
+                dag.add_edge(
+                    recent_node_dic[qb], node, edge_type=edge_type, qubits=[qb]
+                )
+
             successors = list(dag.successors(recent_node_dic[qb]))
             if len(successors) > 1:
                 if edge_type == "target":
                     for s in successors:
                         if s == node:
                             continue
                         elif not dag.has_edge(s, node):
-                            if dag.get_edge_data(recent_node_dic[qb], s)["edge_type"] == "control":
-                                dag.add_edge(s, node, edge_type = "anti_dependency")
-            
+                            if (
+                                dag.get_edge_data(recent_node_dic[qb], s)["edge_type"]
+                                == "control"
+                            ):
+                                dag.add_edge(s, node, edge_type="anti_dependency")
+
             if edge_type == "target":
                 recent_node_dic[qb] = node
                 node_counter[qb] += 1
                 node.targets.append(qb)
-                
-    
+
     dag.original_qc = qc
-    
+
     if remove_init_nodes:
-    #Remove init nodes
+        # Remove init nodes
         dag.remove_nodes_from(list(init_nodes.values()))
-    
-    return dag
 
+    return dag
 
 
-        
-def uncompute_node(dag, uncomp_node, uncomp_qbs, recompute_qubits = []):
+def uncompute_node(dag, uncomp_node, uncomp_qbs, recompute_qubits=[]):
     
+    try:
+        lin = list(nx.topological_sort(dag))
+    except nx.NetworkXUnfeasible:
+        raise Exception("Cyclic dependency detected in DAG during uncomputation")
     
-    lin = list(nx.topological_sort(dag))
     lin.reverse()
 
-
-
     a_star_n_list = []
-    
+
     uncomp_node_target_set = set(uncomp_node.targets)
-    
+
     for n in lin:
         if set(uncomp_node.targets).intersection(n.targets):
-            
             a_star_n_list.append(n)
             uncomp_node_target_set = uncomp_node_target_set - set(n.targets)
-            
+
             if not len(uncomp_node_target_set):
                 break
-            
-    
+
     if not is_qfree(uncomp_node.instr.op):
-        raise Exception(f"Tried to uncompute non-qfree gate {uncomp_node.instr}")
-    
-    ctrls = [n for n in dag.predecessors(uncomp_node) if dag.get_edge_data(n, uncomp_node)["edge_type"] == "control"]
-    
+        raise Exception(f"Tried to uncompute non-qfree instruction {uncomp_node.instr}")
+
+    ctrls = [
+        n
+        for n in dag.predecessors(uncomp_node)
+        if dag.get_edge_data(n, uncomp_node)["edge_type"] == "control"
+    ]
+
     for i in range(len(ctrls)):
         if not ctrls[i].uncomputed_node is None:
             ctrls[i] = ctrls[i].uncomputed_node
-    
-    
-    #Replace controlled operations by phase tolerant controlled operations
+
+    # Replace controlled operations by phase tolerant controlled operations
     if isinstance(uncomp_node.instr.op, ControlledOperation):
-        
         op = uncomp_node.instr.op
-        
+
         if op.method == "auto" and 1 < len(op.controls) < 5 or op.method == "gray":
-            uncomp_node.instr.op = PTControlledOperation(op.base_operation, num_ctrl_qubits = len(op.controls), ctrl_state = op.ctrl_state)
-            
-    
-    #Replace results of logic synthesis by phase tolerant logic synthesis
+            uncomp_node.instr.op = PTControlledOperation(
+                op.base_operation,
+                num_ctrl_qubits=len(op.controls),
+                ctrl_state=op.ctrl_state,
+            )
+
+    # Replace results of logic synthesis by phase tolerant logic synthesis
     if isinstance(uncomp_node.instr.op, LogicSynthGate):
         if uncomp_node.instr.op.logic_synth_method == "gray":
-            
             from qrisp import QuantumVariable
-            
+
             tt = uncomp_node.instr.op.tt
-            
+
             input_qv = QuantumVariable(tt.bit_amount)
-            output_qv = QuantumVariable(tt.shape[1], qs = input_qv.qs)
-            
-            tt.q_synth(input_qv, output_qv, method = "gray_pt")
-            
+            output_qv = QuantumVariable(tt.shape[1], qs=input_qv.qs)
+
+            tt.q_synth(input_qv, output_qv, method="gray_pt")
+
             temp = input_qv.qs.data[-1].op
             temp.name = uncomp_node.instr.op.name
-            
+
             uncomp_node.instr.op = temp
-    
+
     new_instr = uncomp_node.instr.inverse()
-    
+
     reversed_node = UnqompNode(uncomp_node.name + "_*", new_instr)
     reversed_node.controls = uncomp_node.controls
     reversed_node.targets = uncomp_node.targets
-    
+
     uncomp_node.uncomputed_node = reversed_node
-    
+
     dag.add_node(reversed_node)
-    
+
     for i in range(len(ctrls)):
         c = ctrls[i]
-        
+
         control_edge_qubits = dag.get_edge_data(c, uncomp_node)["qubits"]
-        
+
         if set(control_edge_qubits).intersection(recompute_qubits):
             for k in dag.successors(c):
-                if dag.get_edge_data(c, k)["edge_type"] == "target" and set(dag.get_edge_data(c, k)["qubits"]).intersection(control_edge_qubits):
+                if dag.get_edge_data(c, k)["edge_type"] == "target" and set(
+                    dag.get_edge_data(c, k)["qubits"]
+                ).intersection(control_edge_qubits):
                     if k.uncomputed_node is None:
                         return True
-                    
+
                     ctrls[i] = k.uncomputed_node
                     break
             else:
                 return True
-                
-        dag.add_edge(ctrls[i], reversed_node, edge_type = "control", qubits = control_edge_qubits)
-    
-    
+
+        dag.add_edge(
+            ctrls[i], reversed_node, edge_type="control", qubits=control_edge_qubits
+        )
+
     for a_star_n in a_star_n_list:
-        
-        dag.add_edge(a_star_n, reversed_node, edge_type = "target", qubits = list(set(uncomp_qbs).intersection(n.targets).intersection(new_instr.qubits)))
-        
+        dag.add_edge(
+            a_star_n,
+            reversed_node,
+            edge_type="target",
+            qubits=list(
+                set(uncomp_qbs).intersection(n.targets).intersection(new_instr.qubits)
+            ),
+        )
+
         for v in dag.successors(a_star_n):
-            
             if dag.get_edge_data(a_star_n, v)["edge_type"] == "control":
-                dag.add_edge(v, reversed_node, edge_type = "anti_dependency")
-    
-    
-                
+                dag.add_edge(v, reversed_node, edge_type="anti_dependency")
+
     for c in ctrls:
         for v in dag.successors(c):
             if dag.get_edge_data(c, v)["edge_type"] == "target":
-                
                 target_edge_qubits = dag.get_edge_data(c, v)["qubits"]
                 control_edge_qubits = dag.get_edge_data(c, uncomp_node)["qubits"]
-                
+
                 if set(target_edge_qubits).intersection(control_edge_qubits):
                     pass
-                    dag.add_edge(reversed_node, v, edge_type = "anti_dependency")
-                    
+                    dag.add_edge(reversed_node, v, edge_type="anti_dependency")
+
     return False
-                
 
-def uncompute_qc(qc, uncomp_qbs, recompute_qubits = []):
 
+def uncompute_qc(qc, uncomp_qbs, recompute_qubits=[]):
     qc_new = qc.copy()
     previous_instructions = []
     follow_up_instructions = []
-    
+
     while len(qc_new.data):
-        
         instr = qc_new.data[0]
         if set(uncomp_qbs + recompute_qubits).intersection(instr.qubits):
             break
         previous_instructions.append(qc_new.data.pop(0))
-    
+
     while len(qc_new.data):
-        
         instr = qc_new.data[-1]
         if set(uncomp_qbs + recompute_qubits).intersection(instr.qubits):
             break
         follow_up_instructions.append(qc_new.data.pop(-1))
-        
+
     follow_up_instructions = follow_up_instructions[::-1]
 
     dag = dag_from_qc(qc_new)
-    
+
     lin = list(nx.topological_sort(dag))
     lin.reverse()
-    
+
     for i in range(len(lin)):
-    # for node in lin:
-        
+        # for node in lin:
+
         node = lin[i]
-        
+
         if node.instr is None:
             continue
-        
+
         if not set(node.targets).intersection(uncomp_qbs):
             continue
 
-        if node.instr.op.name in ["barrier"]:#, "qb_alloc", "qb_dealloc"]:
+        if node.instr.op.name in ["barrier"]:  # , "qb_alloc", "qb_dealloc"]:
             continue
-        
-        #This function checks if there is more than one allocation gate in the upcoming
-        #chain of nodes. This prevents instructions which were created due to previous recomputations
-        #to be included in further recomputations
+
+        # This function checks if there is more than one allocation gate in
+        # the upcoming chain of nodes. This prevents instructions which were
+        # created due to previous recomputations to be included in further recomputations
         if detect_double_alloc(lin[i:], node.instr.qubits):
             continue
-        
+
         if set(node.targets).issubset(uncomp_qbs) and node.instr and node.targets:
             recompute = uncompute_node(dag, node, uncomp_qbs, recompute_qubits)
             if recompute:
-                
-                return uncompute_qc(qc, uncomp_qbs + list(set(node.controls).intersection(recompute_qubits)), recompute_qubits)
+                return uncompute_qc(
+                    qc,
+                    uncomp_qbs
+                    + list(set(node.controls).intersection(recompute_qubits)),
+                    recompute_qubits,
+                )
             continue
-        
-        
-        off_target_qubits = list(set(node.targets)-set(uncomp_qbs))
+
+        off_target_qubits = list(set(node.targets) - set(uncomp_qbs))
         if off_target_qubits:
             not_uncomputable_qubits = []
             for qb in off_target_qubits:
                 if qb.allocated:
                     not_uncomputable_qubits.append(qb)
-            
+
             if not_uncomputable_qubits:
-                raise Exception(f"Uncomputation failed because gate \"{node.instr.op.name}\" needs to be uncomputed but is also targeting qubits {not_uncomputable_qubits} which are not up for uncomputation")
+                raise Exception(
+                    f'Uncomputation failed because gate "{node.instr.op.name}" needs to be uncomputed '
+                    f'but is also targeting qubits {not_uncomputable_qubits} which are not up for uncomputation'
+                )
             else:
-                return uncompute_qc(qc, uncomp_qbs + off_target_qubits, recompute_qubits = recompute_qubits)
-    
-    
+                return uncompute_qc(
+                    qc,
+                    uncomp_qbs + off_target_qubits,
+                    recompute_qubits=recompute_qubits,
+                )
+
     try:
         uncomputed_qc = qc_from_dag(dag)
     except nx.NetworkXUnfeasible:
-        raise Exception("Cycle detected in DAG during uncomputation")
-    
-    
-    uncomputed_qc.data = previous_instructions + uncomputed_qc.data + follow_up_instructions
-    
+        raise Exception("Cyclic dependency detected in DAG during uncomputation")
+
+    uncomputed_qc.data = (
+        previous_instructions + uncomputed_qc.data + follow_up_instructions
+    )
+
     return uncomputed_qc
 
+
 def detect_double_alloc(lin, qubits):
-    
     qb_allocs = []
     for node in lin:
         if not node.instr:
             continue
         if node.instr.op.name == "qb_alloc" and node.instr.qubits[0] in qubits:
             if node.instr.qubits[0] in qb_allocs:
                 return True
             else:
                 qb_allocs.append(node.instr.qubits[0])
-                
-    return False
-
 
+    return False
```

### Comparing `qrisp-0.0.15/src/qrisp.egg-info/SOURCES.txt` & `qrisp-0.0.16/src/qrisp.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -20,15 +20,14 @@
 src/qrisp/arithmetic/ripple_division.py
 src/qrisp/arithmetic/ripple_mult.py
 src/qrisp/circuit/__init__.py
 src/qrisp/circuit/clbit.py
 src/qrisp/circuit/controlled_operations.py
 src/qrisp/circuit/instruction.py
 src/qrisp/circuit/library.py
-src/qrisp/circuit/multi_cx.py
 src/qrisp/circuit/operation.py
 src/qrisp/circuit/quantum_circuit.py
 src/qrisp/circuit/qubit.py
 src/qrisp/circuit/standard_operations.py
 src/qrisp/circuit/transpiler.py
 src/qrisp/circuit/transpiler_old.py
 src/qrisp/core/__init__.py
@@ -70,14 +69,15 @@
 src/qrisp/logic_synthesis/__init__.py
 src/qrisp/logic_synthesis/gray_synthesis.py
 src/qrisp/logic_synthesis/pprm_synthesis.py
 src/qrisp/logic_synthesis/truth_tables.py
 src/qrisp/misc/GMS_tools.py
 src/qrisp/misc/__init__.py
 src/qrisp/misc/depth_reduction.py
+src/qrisp/misc/multi_cx.py
 src/qrisp/misc/utility.py
 src/qrisp/qtypes/__init__.py
 src/qrisp/qtypes/quantum_bool.py
 src/qrisp/qtypes/quantum_char.py
 src/qrisp/qtypes/quantum_float.py
 src/qrisp/qtypes/quantum_string.py
 src/qrisp/quantum_network/__init__.py
```

### Comparing `qrisp-0.0.15/tests/test_GMS_environment_example.py` & `qrisp-0.0.16/tests/test_GMS_environment_example.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,53 +1,48 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 05.05.2022
-from qrisp import QuantumVariable, x, h, merge
-from qrisp.environments.GMS_environment import GMSEnvironment
-import numpy as np
-
-
-def test_GMS_environment_example():
-    qv1 = QuantumVariable(1)
-    qv2 = QuantumVariable(1)
-    
-    merge([qv1, qv2])
-    
-    
-    qs = qv1.qs
-    test = GMSEnvironment()
-    
-    
-    h(qv1)
-    x(qv2)
-    with test:
-        
-        qs.cp(np.pi/2, 0,1)
-        qs.p(np.pi/2, 0)
-        qs.p(np.pi/2, 1)
-        
-    
-    h(qv1)
-
-    ###################
-    from qrisp.arithmetic import QuantumFloat
-
-    
-    qf = QuantumFloat(3)
-
-    qf.encode(1)
-
-    from qrisp import QFT
-
-    QFT(qf, use_gms=True)
-
-    sv = qf.qs.statevector("array")
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 05.05.2022
+from qrisp import QuantumVariable, x, h, merge
+from qrisp.environments.GMS_environment import GMSEnvironment
+import numpy as np
+
+
+def test_GMS_environment_example():
+    qv1 = QuantumVariable(1)
+    qv2 = QuantumVariable(1)
+
+    merge([qv1, qv2])
+
+    qs = qv1.qs
+    test = GMSEnvironment()
+
+    h(qv1)
+    x(qv2)
+    with test:
+        qs.cp(np.pi / 2, 0, 1)
+        qs.p(np.pi / 2, 0)
+        qs.p(np.pi / 2, 1)
+
+    h(qv1)
+
+    ###################
+    from qrisp.arithmetic import QuantumFloat
+
+    qf = QuantumFloat(3)
+
+    qf.encode(1)
+
+    from qrisp import QFT
+
+    QFT(qf, use_gms=True)
+
+    sv = qf.qs.statevector("array")
```

### Comparing `qrisp-0.0.15/tests/test_GXX_converter_example.py` & `qrisp-0.0.16/tests/test_GXX_converter_example.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,26 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 # Created by ann81984 at 29.04.2022
 import numpy as np
 import random
 from qrisp import QuantumSession, QuantumVariable, p, cp
 from qrisp.misc.GMS_tools import GXX_converter
 
+
 def test_GMS_converter_example():
     n = 8
 
     qv = QuantumVariable(n)
 
     # Generate random phase-only circuit
     for i in range(n):
@@ -35,11 +36,13 @@
     # Apply converter
     qc = GXX_converter(qv.qs)
 
     print("Is equal:", qv.qs.compare_unitary(qc, precision=4))
 
     unitary = qc.get_unitary()
 
-    print("Is diagonal:", np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1E-3)
+    print(
+        "Is diagonal:", np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1e-3
+    )
     # print(np.round(np.angle(np.diagonal(qv.qs.get_unitary()))%(2*np.pi)/(2*np.pi), 3))
     assert qv.qs.compare_unitary(qc, precision=4)
-    assert np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1E-3
+    assert np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1e-3
```

### Comparing `qrisp-0.0.15/tests/test_GXX_gates_example.py` & `qrisp-0.0.16/tests/test_GXX_gates_example.py`

 * *Files 13% similar despite different names*

```diff
@@ -11,57 +11,77 @@
 """
 
 # Created by ann81984 at 05.05.2022
 import pytest
 import numpy as np
 
 from qrisp import QuantumSession, QuantumVariable
-from qrisp.misc.GMS_tools import gms_multi_cx_fan_out, gms_multi_cx_fan_in, gms_multi_cp_gate, gms_multi_cp_gate_mono_phase, GXX_wrapper
+from qrisp.misc.GMS_tools import (
+    gms_multi_cx_fan_out,
+    gms_multi_cx_fan_in,
+    gms_multi_cp_gate,
+    gms_multi_cp_gate_mono_phase,
+    GXX_wrapper,
+)
 from qrisp import x
 
+
 def test_GXX_gates_example():
     n = 5
     qs = QuantumSession()
     qv = QuantumVariable(n, qs)
 
     x(qv[-1])
-    qs.append(gms_multi_cx_fan_out(n - 1, use_uniform=True, phase_tolerant=False, basis = 'GXX'), qv.reg)
+    qs.append(
+        gms_multi_cx_fan_out(
+            n - 1, use_uniform=True, phase_tolerant=False, basis="GXX"
+        ),
+        qv.reg,
+    )
 
-    
     tmp = qv.get_measurement()
-    
-    print(tmp)
-    assert qv.get_measurement() == {'11111': 1.0}
-
 
+    print(tmp)
+    assert qv.get_measurement() == {"11111": 1.0}
 
     ###################
     n = 3
 
     theta = [np.pi / (i + 1) for i in range(n - 1)]
     qs_0 = QuantumSession()
     qv = QuantumVariable(n, qs_0)
     qs_0.append(gms_multi_cp_gate(n - 1, theta), qv.reg)
-    
+
     qs_1 = QuantumSession()
     qv = QuantumVariable(n, qs_1)
 
     for i in range(n - 1):
         qs_1.cp(theta[i], i, n - 1)
 
     unitary = qs_0.get_unitary()
     print(qs_0.get_unitary(decimals=4))
     tmparray = qs_0.get_unitary(decimals=4)
-    assert type(qs_0.get_unitary(decimals=4)).__module__ == 'numpy'
+    assert type(qs_0.get_unitary(decimals=4)).__module__ == "numpy"
     while i < len(tmparray):
-        assert all(tmparray[i]) in [1. + 0.j, -0. - 0.j, -0. + 0.j, 0. + 0.j, 1. - 0.j, 0. - 0.j, 0. + 1.j, -1. + 0.j,
-                                    -0. - 1.j]
+        assert all(tmparray[i]) in [
+            1.0 + 0.0j,
+            -0.0 - 0.0j,
+            -0.0 + 0.0j,
+            0.0 + 0.0j,
+            1.0 - 0.0j,
+            0.0 - 0.0j,
+            0.0 + 1.0j,
+            -1.0 + 0.0j,
+            -0.0 - 1.0j,
+        ]
         assert not bool(all(tmparray[i]) == 7153)
         i += 1
 
     print("Is equal:", qs_0.compare_unitary(qs_1))
     assert qs_0.compare_unitary(qs_1)
 
-    print("Is diagonal:", np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1E-3)
-    assert np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1E-3
+    print(
+        "Is diagonal:", np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1e-3
+    )
+    assert np.linalg.norm(unitary - np.diag(np.diagonal(unitary))) < 1e-3
 
     print(np.round(np.angle(np.diagonal(unitary)) % (2 * np.pi) / (np.pi), 3))
```

### Comparing `qrisp-0.0.15/tests/test_GZZ_gates_example.py` & `qrisp-0.0.16/tests/test_GZZ_gates_example.py`

 * *Files 19% similar despite different names*

```diff
@@ -11,41 +11,46 @@
 """
 
 # Created by ann81984 at 05.05.2022
 import pytest
 import numpy as np
 
 from qrisp import QuantumSession, QuantumVariable, QuantumCircuit
-from qrisp.misc.GMS_tools import gms_multi_cx_fan_out, gms_multi_cx_fan_in, gms_multi_cp_gate, \
-    gms_multi_cp_gate_mono_phase, GXX_wrapper, GZZ_converter
+from qrisp.misc.GMS_tools import (
+    gms_multi_cx_fan_out,
+    gms_multi_cx_fan_in,
+    gms_multi_cp_gate,
+    gms_multi_cp_gate_mono_phase,
+    GXX_wrapper,
+    GZZ_converter,
+)
 from qrisp import x
 
 
-
 def test_GZZ_gates_example():
     n = 5
     # M = np.array([[0,0,1,1,1,1,0,1,0], [0,1,0,0,1,0,1,1,1],[0,1,0,1,1,1,0,0,1],[1,0,0,0,1,1,0,0,0],[0,0,1,0,1,1,0,0,1],[1,1,1,0,1,1,1,1,1],[1,1,0,0,0,1,1,0,0],[0,1,1,0,1,1,0,0,0],[0,1,0,0,0,1,1,0,1]])
-    
+
     def generate_random_inv_matrix(n, bit):
         from qrisp.misc import is_inv
         import random
+
         found = False
-        
+
         while found == False:
-            matrix = np.zeros((n,n))
+            matrix = np.zeros((n, n))
             for i in range(n):
                 for j in range(n):
-                    matrix[i,j] = random.randint(0, 2**bit-1)
-            
-            det = np.round(np.linalg.det(matrix)%2**bit)
-            
+                    matrix[i, j] = random.randint(0, 2**bit - 1)
+
+            det = np.round(np.linalg.det(matrix) % 2**bit)
+
             found = is_inv(det, bit)
-            
-        return matrix
 
+        return matrix
 
     M = generate_random_inv_matrix(n, 1)
     n = M.shape[0]
     row_swaps = []
 
     def swap_rows(M, i, j):
         M[[i, j]] = M[[j, i]]
@@ -67,36 +72,41 @@
         fan_ins = [i]
         for j in range(n):
             if i != j and K[i, j]:
                 qc.cx(j, i)
                 fan_ins.append(j)
         if len(fan_ins) > 1:
             fan_ins.reverse()
-            qc_gms.append(gms_multi_cx_fan_in(len(fan_ins) - 1, use_uniform=False, phase_tolerant=False, basis='GZZ'),
-                          fan_ins)
+            qc_gms.append(
+                gms_multi_cx_fan_in(
+                    len(fan_ins) - 1,
+                    use_uniform=False,
+                    phase_tolerant=False,
+                    basis="GZZ",
+                ),
+                fan_ins,
+            )
 
         temp = K[i, :].copy()
         temp[i] = 0
         for j in range(i, n):
             if K[j, i]:
                 K[j, :] = (K[j, :] + temp) % 2
 
     assert qc.compare_unitary(qc_gms, precision=4) == True
 
 
 def test_GZZ_converter():
-
     qc = QuantumCircuit(7)
     qc.cz(qc.qubits[0], qc.qubits[1])
     qc.cz(qc.qubits[0], qc.qubits[3])
     qc.cz(qc.qubits[5], qc.qubits[4])
     qc.p(0.5, qc.qubits[2])
     qc.cp(0.25, qc.qubits[1], qc.qubits[6])
     qc.cz(qc.qubits[3], qc.qubits[1])
     qc.cz(qc.qubits[2], qc.qubits[6])
     qc.rz(0.5, qc.qubits[4])
     qc.cz(qc.qubits[3], qc.qubits[4])
 
     qc_zz = GZZ_converter(qc)
 
     assert qc.compare_unitary(qc_zz, 4) == True
-
```

### Comparing `qrisp-0.0.15/tests/test_array_entry_manipulation.py` & `qrisp-0.0.16/tests/test_array_entry_manipulation.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,31 +1,29 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 def array_entry_manipulation_test():
-    
     from qrisp import QuantumBool, QuantumArray, QuantumFloat, h, multi_measurement
-    
-    q_array = QuantumArray(QuantumBool(), (4,4))
-    index_0 = QuantumFloat(2, signed = False)
-    index_1 = QuantumFloat(2, signed = False)
-    
+
+    q_array = QuantumArray(QuantumBool(), (4, 4))
+    index_0 = QuantumFloat(2, signed=False)
+    index_1 = QuantumFloat(2, signed=False)
+
     index_0[:] = 2
     index_1[:] = 1
-    
+
     with q_array[(index_0, index_1)] as entry:
-        
         entry.flip()
-    
+
     res_array = q_array.most_likely()
-    
-    assert res_array[index_0.most_likely(), index_1.most_likely()]
+
+    assert res_array[index_0.most_likely(), index_1.most_likely()]
```

### Comparing `qrisp-0.0.15/tests/test_controlled_gates.py` & `qrisp-0.0.16/tests/test_controlled_gates.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 04.05.2022
-import pytest
-import time
-
-from qrisp.circuit import multi_controlled_circuit, RYGate, RZGate, RXGate, transpile, HGate, XGate, PGate
-from qrisp import QuantumSession, QuantumVariable, QuantumCircuit, transpile, x
-from qiskit.circuit.library import HGate
-
-# Check by printing circuit
-def test_controlled_gates():
-    
-    qc = QuantumCircuit(3)
-
-    simple_case = False
-
-    if simple_case:
-        qc.x(0)
-    else:
-        # qc.h(0)
-        # qc.cx(0,1)
-        qc.cp(2.4, 0, 1)
-
-
-    # print(qs)
-
-    controlled_qc = multi_controlled_circuit(qc, 1)
-    print(controlled_qc)
-
-
-
-    ###################
-    # Check by measuring circuit
-    qs_0 = QuantumSession()
-
-    qv = QuantumVariable(2, qs_0)
-
-    if simple_case:
-        qs_0.x(0)
-    else:
-        qs_0.h(0)
-        qs_0.cx(0, 1)
-        qs_0.cp(2.4, 0, 1)
-
-    operation = qs_0.to_op()
-
-    controlled_operation = operation.control(1)
-
-    control_qv = QuantumVariable(1)
-    qv = QuantumVariable(operation.num_qubits)
-
-    control_on = True
-    if control_on:
-        x(control_qv[0])
-
-    control_qv.qs.append(controlled_operation, control_qv.reg + qv.reg)
-
-    tmp = qv.get_measurement()
-    print(tmp)
-
-    assert 0.4 < tmp['11'] < 0.6 and 0.4 < tmp['00'] < 0.6
-    assert not (0.8 < tmp['11'] < 1 and 0.7 < tmp['00'] < 0.2)
-    assert isinstance(tmp, dict)
-    with pytest.raises(KeyError) as excinfo:
-        bool(tmp['23'] < 0.6)
-    assert '23' in str(excinfo.value)
-
-
-
-    ###################
-    start_time = time.time()
-    
-    n = 5
-    test_gate = XGate().control(n)
-    # test_gate = XGate().control(n)
-
-    qs = QuantumSession()
-
-    qv_ctrl = QuantumVariable(n, qs)
-    qv_target = QuantumVariable(1, qs)
-
-    x(qv_ctrl)
-
-    qs.append(test_gate, qs.qubits)
-
-    # Can be sped up to super-qiskit performance by enabling use_gray code
-    # in logic_synthesis/gray_synthesis.py (this costs cnot count however)
-    print("Took " + str(time.time() - start_time) + " s for gate synthesis")
-
-
-    print(qv_target.get_measurement())
-    tmp2 = qv_target.get_measurement()
-    assert isinstance(tmp2, dict)
-    assert tmp2['1'] == 1.0
-
-
-    qv_0 = QuantumVariable(2)
-    qv_1 = QuantumVariable(1)
-
-
-    qv_0[:] = "10"
-    qv_0.qs.append(XGate().control(2, ctrl_state = "10"), qv_0.reg + qv_1.reg)
-
-    assert qv_1.get_measurement() == {"1" : 1.0}
-    
-    qv_0 = QuantumVariable(4)
-    qv_1 = QuantumVariable(1)
-    
-    qv_0[:] = "0110"
-    qv_0.qs.append(XGate().control(2, ctrl_state = "10").control(2, ctrl_state = "01"), qv_0.reg + qv_1.reg)
-    
-    assert qv_1.get_measurement() == {"1" : 1.0}
-    
-    
-    
-    
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 04.05.2022
+import pytest
+import time
+
+from qrisp.circuit import (
+    multi_controlled_circuit,
+    RYGate,
+    RZGate,
+    RXGate,
+    transpile,
+    HGate,
+    XGate,
+    PGate,
+)
+from qrisp import QuantumSession, QuantumVariable, QuantumCircuit, transpile, x
+from qiskit.circuit.library import HGate
+
+
+# Check by printing circuit
+def test_controlled_gates():
+    qc = QuantumCircuit(3)
+
+    simple_case = False
+
+    if simple_case:
+        qc.x(0)
+    else:
+        # qc.h(0)
+        # qc.cx(0,1)
+        qc.cp(2.4, 0, 1)
+
+    # print(qs)
+
+    controlled_qc = multi_controlled_circuit(qc, 1)
+    print(controlled_qc)
+
+    ###################
+    # Check by measuring circuit
+    qs_0 = QuantumSession()
+
+    qv = QuantumVariable(2, qs_0)
+
+    if simple_case:
+        qs_0.x(0)
+    else:
+        qs_0.h(0)
+        qs_0.cx(0, 1)
+        qs_0.cp(2.4, 0, 1)
+
+    operation = qs_0.to_op()
+
+    controlled_operation = operation.control(1)
+
+    control_qv = QuantumVariable(1)
+    qv = QuantumVariable(operation.num_qubits)
+
+    control_on = True
+    if control_on:
+        x(control_qv[0])
+
+    control_qv.qs.append(controlled_operation, control_qv.reg + qv.reg)
+
+    tmp = qv.get_measurement()
+    print(tmp)
+
+    assert 0.4 < tmp["11"] < 0.6 and 0.4 < tmp["00"] < 0.6
+    assert not (0.8 < tmp["11"] < 1 and 0.7 < tmp["00"] < 0.2)
+    assert isinstance(tmp, dict)
+    with pytest.raises(KeyError) as excinfo:
+        bool(tmp["23"] < 0.6)
+    assert "23" in str(excinfo.value)
+
+    ###################
+    start_time = time.time()
+
+    n = 5
+    test_gate = XGate().control(n)
+    # test_gate = XGate().control(n)
+
+    qs = QuantumSession()
+
+    qv_ctrl = QuantumVariable(n, qs)
+    qv_target = QuantumVariable(1, qs)
+
+    x(qv_ctrl)
+
+    qs.append(test_gate, qs.qubits)
+
+    # Can be sped up to super-qiskit performance by enabling use_gray code
+    # in logic_synthesis/gray_synthesis.py (this costs cnot count however)
+    print("Took " + str(time.time() - start_time) + " s for gate synthesis")
+
+    print(qv_target.get_measurement())
+    tmp2 = qv_target.get_measurement()
+    assert isinstance(tmp2, dict)
+    assert tmp2["1"] == 1.0
+
+    qv_0 = QuantumVariable(2)
+    qv_1 = QuantumVariable(1)
+
+    qv_0[:] = "10"
+    qv_0.qs.append(XGate().control(2, ctrl_state="10"), qv_0.reg + qv_1.reg)
+
+    assert qv_1.get_measurement() == {"1": 1.0}
+
+    qv_0 = QuantumVariable(4)
+    qv_1 = QuantumVariable(1)
+
+    qv_0[:] = "0110"
+    qv_0.qs.append(
+        XGate().control(2, ctrl_state="10").control(2, ctrl_state="01"),
+        qv_0.reg + qv_1.reg,
+    )
+
+    assert qv_1.get_measurement() == {"1": 1.0}
```

### Comparing `qrisp-0.0.15/tests/test_diagonal_hamiltonian_application.py` & `qrisp-0.0.16/tests/test_diagonal_hamiltonian_application.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,125 +1,127 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 05.05.2022
-import numpy as np
-
-from qrisp import QuantumFloat, QuantumChar, QFT, multi_measurement, as_hamiltonian, h
-
-def test_diagonal_hamiltonian_application():
-    # Hamiltonian function
-    # This function should take an element from the outcome labels of qf and turns it into a phase
-    # In this case we are handling a QuantumFloat, so the input is a float
-    # Another case could be where we are handling a QuantumChar
-    # In this case the function should process a char
-    def hamiltonian(x):
-        return np.pi * np.sin(x ** 2 * np.pi * 2) * x
-        # If we were processing a QuantumChar, the hamiltonian could look like this:
-        # if x == "a":
-        #     return 0.5*np.pi
-        # elif x == "b":
-        #     return 0.25*np.pi
-        # else:
-        #     return np.pi
-
-    # Create quantum session
-    # qs = QuantumSession()
-
-    # Create quantum float
-    qf = QuantumFloat(5, -5)
-
-    # Bring qf in uniform superposition state in order to be able to see which phase has been applied to which state
-    h(qf)
-
-    # Apply hamiltonian
-    qf.app_phase_function(hamiltonian)
-
-    # Simulate phases
-    sv_ = qf.qs.statevector("function")
-    sv = lambda x : sv_({qf : x})
-    
-    def sv_phase(label):
-        return np.angle(sv(label)) - np.angle(sv(x[0])) + hamiltonian(x[0])
-    
-    # Prepare x array (for plotting)
-    x = np.array([qf.decoder(i) for i in range(2 ** qf.size)])
-    sv_phase_array = np.array([sv_phase(i) for i in x])
-    
-    # Correct global phase
-    # sv_phases += (-sv_phases[0] + hamiltonian(x[0]))
-    
-    
-    #Check if phases agree
-    from numpy.linalg import norm
-    # assert abs((sv_phase(i) - hamiltonian(i))%(2*np.pi)) < 1E-4
-    assert norm((sv_phase_array- hamiltonian(x))) < 1E-4
-    # Plot results
-    # import matplotlib.pyplot as plt
-    # plt.plot(x, hamiltonian(x) % (2 * np.pi), "o", label="Hamiltonian")
-    # plt.plot(x, sv_phase_array % (2 * np.pi), ".", label="Simulated phases")
-    #
-    # plt.ylabel("Phase [radian]")
-    # plt.xlabel("Quantum Float outcome labels")
-    # plt.grid()
-    # plt.legend()
-    # plt.show()
-
-
-
-    ###################
-    # In this example we will demonstrate how a phase function with multiple arguments can be synthesized
-    # For this we will create a phase function which encodes the fourier transform of different integers on the QuantumFloat x
-    # conditioned on the value of a QuantumChar c
-    # We will then apply the inverse Fourier transform to x and measure the results
-
-    x_size = 3
-
-    # Create Variables
-    x = QuantumFloat(x_size, 0, signed=False)
-    c = QuantumChar()
-
-    # Bring x into uniform superposition so the phase function application yields a fourier transformed computation basis state
-    h(x)
-
-    # Bring c into partial superposition (here |a> + |b> + |c> + |d>)
-    h(c[0])
-    h(c[1])
-
-
-
-    # In order to define the hamiltonian, we can use regular Python syntax
-    # The decorator "as_hamiltonian" turns it into a function that takes Quantum Variables as arguments
-    # The decorator will add the keyword argument t to the function which mimics the t in exp(i*H*t)
-    @as_hamiltonian
-    def apply_multi_var_hamiltonian(c, x):
-        if c == "a":
-            k = 2
-        elif c == "b":
-            k = 2
-        elif c == "c":
-            k = 3
-        else:
-            k = 4
-
-        # Return phase value
-        # This is the phase distribution of the Fourier-transform
-        # of the computational basis state |k>
-        return k * x * 2 * np.pi / 2 ** x_size
-
-    # Apply Hamiltonian
-    apply_multi_var_hamiltonian(c, x, t=1)
-
-    # Apply inverse Fourier transform
-    QFT(x, inv=True)
-
-    # Acquire measurement results
-    assert multi_measurement([c,x]) == {('a', 2): 0.25, ('b', 2): 0.25, ('c', 3): 0.25, ('d', 4): 0.25}
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 05.05.2022
+import numpy as np
+
+from qrisp import QuantumFloat, QuantumChar, QFT, multi_measurement, as_hamiltonian, h
+
+
+def test_diagonal_hamiltonian_application():
+    # Hamiltonian function
+    # This function should take an element from the outcome labels of qf and turns it into a phase
+    # In this case we are handling a QuantumFloat, so the input is a float
+    # Another case could be where we are handling a QuantumChar
+    # In this case the function should process a char
+    def hamiltonian(x):
+        return np.pi * np.sin(x**2 * np.pi * 2) * x
+        # If we were processing a QuantumChar, the hamiltonian could look like this:
+        # if x == "a":
+        #     return 0.5*np.pi
+        # elif x == "b":
+        #     return 0.25*np.pi
+        # else:
+        #     return np.pi
+
+    # Create quantum session
+    # qs = QuantumSession()
+
+    # Create quantum float
+    qf = QuantumFloat(5, -5)
+
+    # Bring qf in uniform superposition state in order to be able to see which phase has been applied to which state
+    h(qf)
+
+    # Apply hamiltonian
+    qf.app_phase_function(hamiltonian)
+
+    # Simulate phases
+    sv_ = qf.qs.statevector("function")
+    sv = lambda x: sv_({qf: x})
+
+    def sv_phase(label):
+        return np.angle(sv(label)) - np.angle(sv(x[0])) + hamiltonian(x[0])
+
+    # Prepare x array (for plotting)
+    x = np.array([qf.decoder(i) for i in range(2**qf.size)])
+    sv_phase_array = np.array([sv_phase(i) for i in x])
+
+    # Correct global phase
+    # sv_phases += (-sv_phases[0] + hamiltonian(x[0]))
+
+    # Check if phases agree
+    from numpy.linalg import norm
+
+    # assert abs((sv_phase(i) - hamiltonian(i))%(2*np.pi)) < 1E-4
+    assert norm((sv_phase_array - hamiltonian(x))) < 1e-4
+    # Plot results
+    # import matplotlib.pyplot as plt
+    # plt.plot(x, hamiltonian(x) % (2 * np.pi), "o", label="Hamiltonian")
+    # plt.plot(x, sv_phase_array % (2 * np.pi), ".", label="Simulated phases")
+    #
+    # plt.ylabel("Phase [radian]")
+    # plt.xlabel("Quantum Float outcome labels")
+    # plt.grid()
+    # plt.legend()
+    # plt.show()
+
+    ###################
+    # In this example we will demonstrate how a phase function with multiple arguments can be synthesized
+    # For this we will create a phase function which encodes the fourier transform of different integers on the QuantumFloat x
+    # conditioned on the value of a QuantumChar c
+    # We will then apply the inverse Fourier transform to x and measure the results
+
+    x_size = 3
+
+    # Create Variables
+    x = QuantumFloat(x_size, 0, signed=False)
+    c = QuantumChar()
+
+    # Bring x into uniform superposition so the phase function application yields a fourier transformed computation basis state
+    h(x)
+
+    # Bring c into partial superposition (here |a> + |b> + |c> + |d>)
+    h(c[0])
+    h(c[1])
+
+    # In order to define the hamiltonian, we can use regular Python syntax
+    # The decorator "as_hamiltonian" turns it into a function that takes Quantum Variables as arguments
+    # The decorator will add the keyword argument t to the function which mimics the t in exp(i*H*t)
+    @as_hamiltonian
+    def apply_multi_var_hamiltonian(c, x):
+        if c == "a":
+            k = 2
+        elif c == "b":
+            k = 2
+        elif c == "c":
+            k = 3
+        else:
+            k = 4
+
+        # Return phase value
+        # This is the phase distribution of the Fourier-transform
+        # of the computational basis state |k>
+        return k * x * 2 * np.pi / 2**x_size
+
+    # Apply Hamiltonian
+    apply_multi_var_hamiltonian(c, x, t=1)
+
+    # Apply inverse Fourier transform
+    QFT(x, inv=True)
+
+    # Acquire measurement results
+    assert multi_measurement([c, x]) == {
+        ("a", 2): 0.25,
+        ("b", 2): 0.25,
+        ("c", 3): 0.25,
+        ("d", 4): 0.25,
+    }
```

### Comparing `qrisp-0.0.15/tests/test_gray_synthesis_example.py` & `qrisp-0.0.16/tests/test_gray_synthesis_example.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,53 +1,56 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 27.04.2022
-import pytest
-
-from qrisp.logic_synthesis import TruthTable, gray_logic_synth
-from qrisp.misc import int_encoder
-from qrisp.core import QuantumVariable, QuantumSession
-
-@pytest.mark.parametrize("num", ["001", "011", "000", "100"])
-def test_gray_synthesis_example(num):
-    # split the input string into a list of characters
-    tmp = list(num)
-
-    # Create a testing truth table
-    tt = TruthTable(tmp)
-
-    # Create new quantum session
-    qs = QuantumSession()
-
-    # Create input variable
-    input_var = QuantumVariable(tt.bit_amount, qs)
-
-    # Encode index
-
-    int_encoder(input_var, 0)
-
-    # Create output variable
-    output_var = QuantumVariable(tt.shape[1], qs)
-
-    # Perform logic synthesis
-    gray_logic_synth(input_var, output_var, tt, phase_tolerant=False)
-
-    # Expected bitstring comes from tt in format array [0 0 1]
-    # create string for assert comparison
-    ttstr = ''.join([str(item) for item in tt.n_rep[0, :]])
-    mes_res = output_var.get_measurement()
-    
-    assert ttstr == str(list(mes_res.keys())[0])
-    assert ttstr in ['001', '011', '000', '100'] and str(list(mes_res.keys())[0]) in ['001', '011', '000', '100']
-
-
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 27.04.2022
+import pytest
+
+from qrisp.logic_synthesis import TruthTable, gray_logic_synth
+from qrisp.misc import int_encoder
+from qrisp.core import QuantumVariable, QuantumSession
+
+
+@pytest.mark.parametrize("num", ["001", "011", "000", "100"])
+def test_gray_synthesis_example(num):
+    # split the input string into a list of characters
+    tmp = list(num)
+
+    # Create a testing truth table
+    tt = TruthTable(tmp)
+
+    # Create new quantum session
+    qs = QuantumSession()
+
+    # Create input variable
+    input_var = QuantumVariable(tt.bit_amount, qs)
+
+    # Encode index
+
+    int_encoder(input_var, 0)
+
+    # Create output variable
+    output_var = QuantumVariable(tt.shape[1], qs)
+
+    # Perform logic synthesis
+    gray_logic_synth(input_var, output_var, tt, phase_tolerant=False)
+
+    # Expected bitstring comes from tt in format array [0 0 1]
+    # create string for assert comparison
+    ttstr = "".join([str(item) for item in tt.n_rep[0, :]])
+    mes_res = output_var.get_measurement()
+
+    assert ttstr == str(list(mes_res.keys())[0])
+    assert ttstr in ["001", "011", "000", "100"] and str(list(mes_res.keys())[0]) in [
+        "001",
+        "011",
+        "000",
+        "100",
+    ]
```

### Comparing `qrisp-0.0.15/tests/test_grovers_algorithm.py` & `qrisp-0.0.16/tests/test_grovers_algorithm.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,124 +1,137 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 06.05.2022
-import numpy as np
-
-from qrisp.misc import multi_measurement
-from qrisp.core import QuantumSession
-from qrisp.arithmetic import QuantumFloat, sbp_mult
-from qrisp.grover import tag_state, grovers_alg
-from qrisp.environments import invert
-from itertools import product
-from qrisp import p, QuantumVariable, h, mcx, QuantumBool
-
-def test_grovers_algorithm():
-    
-    qf1 = QuantumFloat(2)
-    qf2 = QuantumFloat(2)
-
-    # Put into list
-    qf_list = [qf1, qf2]
-
-    # Create test oracle (simply tags the states where qf1 = -3 and qf2 = 2)
-    def test_oracle(qf_list):
-        tag_dic = {qf_list[0]: 0, qf_list[1]: 1}
-        tag_state(tag_dic)
-
-    # Apply grovers algorithm
-    grovers_alg(qf_list, test_oracle)
-
-    print(qf_list[0].qs)
-    # Perform measurement
-    mes_res = multi_measurement(qf_list)
-    print(mes_res)
-
-    # check if it is dictionary
-    assert isinstance(mes_res, dict)
-
-    # check if the key value pairs are of the type tuple:float
-    # Example: (0, 1) :  0.9592
-    assert all(isinstance(item, tuple) for item in mes_res.keys()) and \
-           all((isinstance(item, float) and item < 1) for item in mes_res.values())
-
-    #Check measurement outcome
-    assert list(mes_res.keys())[0] == (0,1)
-
-    # check if the first tuple in the tuple contains expected values. Style example of the whole tuple: ((0, 1), 0.9592)
-    assert all((item in [ele for ele in product(range(0, 4), repeat=2)]) for item in mes_res.keys())
-
-    ###################
-    # Create quantum floats
-    qf1 = QuantumFloat(2, -1, signed = True)
-    qf2 = QuantumFloat(2, -1, signed = True)
-
-    # Put into list
-    qf_list = [qf1, qf2]
-
-    # Create test oracle (tags the states where the multiplication results in -0.25)
-    def equation_oracle(qf_list):
-        # Set aliases
-        factor_0 = qf_list[0]
-        factor_1 = qf_list[1]
-
-        # Calculate ancilla value
-        ancilla = factor_0 * factor_1
-        
-        # Tag state
-        tag_dic = {ancilla: -0.25}
-        tag_state(tag_dic)
-
-        # Uncompute ancilla
-        with invert():
-            sbp_mult(factor_0, factor_1, ancilla)
-
-        ancilla.delete()
-
-    # Execute grovers algorithm
-    grovers_alg(qf_list, equation_oracle, winner_state_amount=2)
-
-    # Perform measurement
-    
-    mes_res = multi_measurement(qf_list)
-    print(mes_res)
-    
-
-    # check if it is a list of dictionary
-    assert isinstance(mes_res, dict)
-
-    # check if the key value pairs are of the type tuple:float
-    # Example: (0, 1) :  0.9592
-    assert all(isinstance(item, tuple) for item in mes_res.keys()) and \
-           all((isinstance(item, float) and item < 1) for item in mes_res.values())
-
-    
-    assert list(mes_res.keys())[0] == (0.5, -0.5)
-    assert list(mes_res.keys())[1] == (-0.5, 0.5)
-    
-    # check if the first tuple in the tuple contains expected values. Style example of the whole tuple: ((0, 1), 0.9592)
-    assert all((item in [ele for ele in product([0.0, -0.5, 0.5, -1.0, 1.0, -1.5, 1.5, -2.0, 2.0], repeat=2)]) for item in mes_res.keys())
-
-    #Test exact Grovers alg
-
-    def oracle(qv, phase = np.pi):
-        
-        temp_qbl = QuantumBool()
-        mcx(qv[1:], temp_qbl)
-        
-        p(phase, temp_qbl)
-        
-        temp_qbl.uncompute()
-
-    qv = QuantumVariable(6)
-    grovers_alg(qv, oracle, exact = True, winner_state_amount = 2)
-
-    assert qv.get_measurement() == {'011111': 0.5, '111111': 0.5}
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 06.05.2022
+import numpy as np
+
+from qrisp.misc import multi_measurement
+from qrisp.core import QuantumSession
+from qrisp.arithmetic import QuantumFloat, sbp_mult
+from qrisp.grover import tag_state, grovers_alg
+from qrisp.environments import invert
+from itertools import product
+from qrisp import p, QuantumVariable, h, mcx, QuantumBool
+
+
+def test_grovers_algorithm():
+    qf1 = QuantumFloat(2)
+    qf2 = QuantumFloat(2)
+
+    # Put into list
+    qf_list = [qf1, qf2]
+
+    # Create test oracle (simply tags the states where qf1 = -3 and qf2 = 2)
+    def test_oracle(qf_list):
+        tag_dic = {qf_list[0]: 0, qf_list[1]: 1}
+        tag_state(tag_dic)
+
+    # Apply grovers algorithm
+    grovers_alg(qf_list, test_oracle)
+
+    print(qf_list[0].qs)
+    # Perform measurement
+    mes_res = multi_measurement(qf_list)
+    print(mes_res)
+
+    # check if it is dictionary
+    assert isinstance(mes_res, dict)
+
+    # check if the key value pairs are of the type tuple:float
+    # Example: (0, 1) :  0.9592
+    assert all(isinstance(item, tuple) for item in mes_res.keys()) and all(
+        (isinstance(item, float) and item < 1) for item in mes_res.values()
+    )
+
+    # Check measurement outcome
+    assert list(mes_res.keys())[0] == (0, 1)
+
+    # check if the first tuple in the tuple contains expected values. Style example of the whole tuple: ((0, 1), 0.9592)
+    assert all(
+        (item in [ele for ele in product(range(0, 4), repeat=2)])
+        for item in mes_res.keys()
+    )
+
+    ###################
+    # Create quantum floats
+    qf1 = QuantumFloat(2, -1, signed=True)
+    qf2 = QuantumFloat(2, -1, signed=True)
+
+    # Put into list
+    qf_list = [qf1, qf2]
+
+    # Create test oracle (tags the states where the multiplication results in -0.25)
+    def equation_oracle(qf_list):
+        # Set aliases
+        factor_0 = qf_list[0]
+        factor_1 = qf_list[1]
+
+        # Calculate ancilla value
+        ancilla = factor_0 * factor_1
+
+        # Tag state
+        tag_dic = {ancilla: -0.25}
+        tag_state(tag_dic)
+
+        # Uncompute ancilla
+        with invert():
+            sbp_mult(factor_0, factor_1, ancilla)
+
+        ancilla.delete()
+
+    # Execute grovers algorithm
+    grovers_alg(qf_list, equation_oracle, winner_state_amount=2)
+
+    # Perform measurement
+
+    mes_res = multi_measurement(qf_list)
+    print(mes_res)
+
+    # check if it is a list of dictionary
+    assert isinstance(mes_res, dict)
+
+    # check if the key value pairs are of the type tuple:float
+    # Example: (0, 1) :  0.9592
+    assert all(isinstance(item, tuple) for item in mes_res.keys()) and all(
+        (isinstance(item, float) and item < 1) for item in mes_res.values()
+    )
+
+    assert list(mes_res.keys())[0] == (0.5, -0.5)
+    assert list(mes_res.keys())[1] == (-0.5, 0.5)
+
+    # check if the first tuple in the tuple contains expected values. Style example of the whole tuple: ((0, 1), 0.9592)
+    assert all(
+        (
+            item
+            in [
+                ele
+                for ele in product(
+                    [0.0, -0.5, 0.5, -1.0, 1.0, -1.5, 1.5, -2.0, 2.0], repeat=2
+                )
+            ]
+        )
+        for item in mes_res.keys()
+    )
+
+    # Test exact Grovers alg
+
+    def oracle(qv, phase=np.pi):
+        temp_qbl = QuantumBool()
+        mcx(qv[1:], temp_qbl)
+
+        p(phase, temp_qbl)
+
+        temp_qbl.uncompute()
+
+    qv = QuantumVariable(6)
+    grovers_alg(qv, oracle, exact=True, winner_state_amount=2)
+
+    assert qv.get_measurement() == {"011111": 0.5, "111111": 0.5}
```

### Comparing `qrisp-0.0.15/tests/test_hello_world.py` & `qrisp-0.0.16/tests/test_hello_world.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 06.05.2022
-# import pytest
-
-from qrisp import QuantumString
-
-def test_hello_world():
-    q_str = QuantumString(size = len("hello world"))
-    q_str.encode("hello world")
-
-    assert list(q_str.get_measurement().keys())[0] == "hello world"
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 06.05.2022
+# import pytest
+
+from qrisp import QuantumString
+
+
+def test_hello_world():
+    q_str = QuantumString(size=len("hello world"))
+    q_str.encode("hello world")
+
+    assert list(q_str.get_measurement().keys())[0] == "hello world"
```

### Comparing `qrisp-0.0.15/tests/test_inpl_matrix_multiplication_example.py` & `qrisp-0.0.16/tests/test_inpl_matrix_multiplication_example.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,64 +1,63 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 22.07.2022
-from qrisp import QuantumSession, QuantumArray
-from qrisp.arithmetic import QuantumFloat, inplace_matrix_app
-import numpy as np
-
-def test_inpl_matrix_multiplication_example():
-    def generate_random_inv_matrix(n, bit):
-        from qrisp.misc import is_inv
-        import random
-        found = False
-
-        while found == False:
-            matrix = np.zeros((n, n))
-            for i in range(n):
-                for j in range(n):
-                    matrix[i, j] = random.randint(0, 2 ** bit - 1)
-
-            det = np.round(np.linalg.det(matrix) % 2 ** bit)
-
-            found = is_inv(det, bit)
-
-        return matrix
-
-    bit = 5
-    n = 3
-    qs = QuantumSession()
-
-    qtype = QuantumFloat(bit, 0, qs=qs, signed=False)
-    vector = QuantumArray(qtype, n)
-
-    x_values = np.array([0, 2, 1])
-
-    vector.encode(x_values)
-
-    matrix = generate_random_inv_matrix(n, bit)
-
-    inplace_matrix_app(vector, matrix)
-
-    print("Matrix multiplication result:")
-    
-    
-    expected_res = ((np.dot(matrix, x_values)) % (2 ** bit)).astype(int).transpose()
-    
-    print(expected_res)
-    
-    mes_res = vector.get_measurement()
-    print("Circuit result:")
-    print(mes_res)
-    
-    assert list(mes_res.keys())[0] == expected_res
-    
-    
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 22.07.2022
+from qrisp import QuantumSession, QuantumArray
+from qrisp.arithmetic import QuantumFloat, inplace_matrix_app
+import numpy as np
+
+
+def test_inpl_matrix_multiplication_example():
+    def generate_random_inv_matrix(n, bit):
+        from qrisp.misc import is_inv
+        import random
+
+        found = False
+
+        while found == False:
+            matrix = np.zeros((n, n))
+            for i in range(n):
+                for j in range(n):
+                    matrix[i, j] = random.randint(0, 2**bit - 1)
+
+            det = np.round(np.linalg.det(matrix) % 2**bit)
+
+            found = is_inv(det, bit)
+
+        return matrix
+
+    bit = 5
+    n = 3
+    qs = QuantumSession()
+
+    qtype = QuantumFloat(bit, 0, qs=qs, signed=False)
+    vector = QuantumArray(qtype, n)
+
+    x_values = np.array([0, 2, 1])
+
+    vector.encode(x_values)
+
+    matrix = generate_random_inv_matrix(n, bit)
+
+    inplace_matrix_app(vector, matrix)
+
+    print("Matrix multiplication result:")
+
+    expected_res = ((np.dot(matrix, x_values)) % (2**bit)).astype(int).transpose()
+
+    print(expected_res)
+
+    mes_res = vector.get_measurement()
+    print("Circuit result:")
+    print(mes_res)
+
+    assert list(mes_res.keys())[0] == expected_res
```

### Comparing `qrisp-0.0.15/tests/test_loops.py` & `qrisp-0.0.16/tests/test_loops.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-
-from qrisp.arithmetic import QuantumFloat
-from qrisp.iterators.qrange import qRange
-from qrisp import h, merge
-
-def test_loop():
-    from qrisp import QuantumFloat, qRange, h
-    # Create some QuantumFloats
-    n = QuantumFloat(3)
-    qf = QuantumFloat(5)
-    # Initialize the value 4
-    n[:] = 4
-
-
-    # Apply H-gate to 0-th qubit
-    h(n[0])
-    
-    assert n.get_measurement() == {4.0: 0.5, 5.0: 0.5}
-
-    # Perform successive addition of increasing numbers
-    for i in qRange(n):
-        qf += i
-
-    assert qf.get_measurement() == {10.0: 0.5, 15.0: 0.5}
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+
+from qrisp.arithmetic import QuantumFloat
+from qrisp.iterators.qrange import qRange
+from qrisp import h, merge
+
+
+def test_loop():
+    from qrisp import QuantumFloat, qRange, h
+
+    # Create some QuantumFloats
+    n = QuantumFloat(3)
+    qf = QuantumFloat(5)
+    # Initialize the value 4
+    n[:] = 4
+
+    # Apply H-gate to 0-th qubit
+    h(n[0])
+
+    assert n.get_measurement() == {4.0: 0.5, 5.0: 0.5}
+
+    # Perform successive addition of increasing numbers
+    for i in qRange(n):
+        qf += i
+
+    assert qf.get_measurement() == {10.0: 0.5, 15.0: 0.5}
```

### Comparing `qrisp-0.0.15/tests/test_mcx.py` & `qrisp-0.0.16/tests/test_mcx.py`

 * *Files 15% similar despite different names*

```diff
@@ -8,61 +8,66 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 def test_mcx():
-    
     from qrisp import h, mcx, QuantumVariable, multi_measurement, bin_rep
     import numpy as np
-    def test_mcx_inner(n, ctrl_state, method, test_phase = True, num_ancilla = 0):
-    
+
+    def test_mcx_inner(n, ctrl_state, method, test_phase=True, num_ancilla=0):
         ctrl = QuantumVariable(n)
-        
+
         target = QuantumVariable(1)
-        
+
         h(ctrl)
-        
+
         if method in ["hybrid", "balauca_dirty"]:
-            mcx(ctrl, target, method = method, ctrl_state = ctrl_state, num_ancilla = num_ancilla)
+            mcx(
+                ctrl,
+                target,
+                method=method,
+                ctrl_state=ctrl_state,
+                num_ancilla=num_ancilla,
+            )
         else:
-            mcx(ctrl, target, method = method, ctrl_state = ctrl_state)
+            mcx(ctrl, target, method=method, ctrl_state=ctrl_state)
         mes_res = multi_measurement([ctrl, target])
         statevector = ctrl.qs.statevector("array")
-        
-        #Test correct flipping behavior
+
+        # Test correct flipping behavior
         for i in range(2**n):
             ctrl_var = bin_rep(i, n)
             if ctrl_var != ctrl_state:
                 assert (ctrl_var, "0") in mes_res
             else:
                 assert (ctrl_var, "1") in mes_res
-        
+
         if not test_phase:
             return
-        
-        angles = np.angle(statevector[np.abs(statevector) > 1/2**(n/2+1)])
-        
-        #Test correct phase behavior
+
+        angles = np.angle(statevector[np.abs(statevector) > 1 / 2 ** (n / 2 + 1)])
+
+        # Test correct phase behavior
         assert np.sum(np.abs(angles)) < 0.1
-        
+
     for n in range(1, 8):
         print("n: ", n)
-        for ctrl_state in [n*"1", n*"0", bin_rep(int(np.random.randint(0, 2**n-1)), n)]:
+        for ctrl_state in [
+            n * "1",
+            n * "0",
+            bin_rep(int(np.random.randint(0, 2**n - 1)), n),
+        ]:
             print("Ctrl state: ", ctrl_state)
             for method in ["gray", "gray_pt", "maslov", "balauca", "yong"]:
                 print(method)
-                
+
                 if method == "maslov" and n > 4:
                     continue
-            
-                test_mcx_inner(n, ctrl_state, method, test_phase = (method != "gray_pt"))
-                
+
+                test_mcx_inner(n, ctrl_state, method, test_phase=(method != "gray_pt"))
+
             for method in ["hybrid", "balauca_dirty"]:
                 for num_ancilla in range(8):
                     print("Ancilla count: ", num_ancilla)
-                    test_mcx_inner(n, ctrl_state, method, num_ancilla = num_ancilla)
-                
-            
-    
-
+                    test_mcx_inner(n, ctrl_state, method, num_ancilla=num_ancilla)
```

### Comparing `qrisp-0.0.15/tests/test_measurement_reduction.py` & `qrisp-0.0.16/tests/test_measurement_reduction.py`

 * *Files 24% similar despite different names*

```diff
@@ -9,16 +9,16 @@
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 from qrisp import QuantumFloat, h
 
+
 def test_measurement_reduction():
-    
     qf = QuantumFloat(4)
     h(qf)
     qbls = []
     for i in range(100):
         qbls.append(qf == 2)
 
-    assert qbls[50].get_measurement() == {False: 0.9375, True: 0.0625}
+    assert qbls[50].get_measurement() == {False: 0.9375, True: 0.0625}
```

### Comparing `qrisp-0.0.15/tests/test_outcome_array.py` & `qrisp-0.0.16/tests/test_outcome_array.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
 
 def outome_array_hashing_test():
     from qrisp import OutcomeArray
     import numpy as np
-    
+
     test = OutcomeArray(np.eye(3))
-    
-    test_dic = {test : 1}
-    
+
+    test_dic = {test: 1}
+
     test_dic[str(np.eye(3))]
-    
+
     assert str(np.eye(3)) == str(test)
```

### Comparing `qrisp-0.0.15/tests/test_qiskit_backend_client.py` & `qrisp-0.0.16/tests/test_qiskit_backend_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,77 +1,72 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 23.05.2022
-import numpy as np
-
-from qrisp.core import QuantumSession
-from qrisp.interface.backends import VirtualBackend
-from qrisp.interface.backends import VirtualQiskitBackend
-from qiskit import Aer
-
-def test_qiskit_backend_client():
-    
-    #TO-DO prevent this test from crashing regardless of functionality
-    return
-    # Create QuantumSession
-    qs = QuantumSession()
-
-    qs.add_qubit()
-    qs.add_qubit()
-    qs.add_clbit()
-
-    qs.h(0)
-
-    qs.rz(np.pi / 2, 0)
-
-    qs.x(0)
-    qs.cx(0, 1)
-    qs.measure(1, 0)
-
-    qs.append(qs.to_op("composed_op"), qs.qubits, qs.clbits)
-
-    qs.append(qs.to_op("multi_composed_op"), qs.qubits, qs.clbits)
-
-    print(qs)
-
-
-
-    ###################
-
-    # Create VirtualBackend
-    def sample_run_func(qc, shots):
-        print("Executing Circuit")
-        return {"0": shots}
-
-
-    test_virtual_backend = VirtualBackend(sample_run_func)
-
-    print(test_virtual_backend.run(qs, 100))
-    assert str(test_virtual_backend.run(qs, 100)) == "{'0': 100}"
-    assert test_virtual_backend.run(qs, 100)['0'] == 100
-
-
-
-    ###################
-
-    # Create Qiskit Backend
-    test_qiskit_backend = VirtualQiskitBackend(Aer.get_backend("qasm_simulator"))
-    
-    
-    from qrisp import QuantumCircuit
-    qc = QuantumCircuit(4,1)
-    qc.x(0)
-    qc.measure(0,0)
-    
-    print(test_qiskit_backend.run(qc, 2000))
-    # status = test_qiskit_backend.ping()
-    assert str(test_qiskit_backend.run(qc, 2000)) == "{'1': 2000}"
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 23.05.2022
+import numpy as np
+
+from qrisp.core import QuantumSession
+from qrisp.interface.backends import VirtualBackend
+from qrisp.interface.backends import VirtualQiskitBackend
+from qiskit import Aer
+
+
+def test_qiskit_backend_client():
+    # TO-DO prevent this test from crashing regardless of functionality
+    return
+    # Create QuantumSession
+    qs = QuantumSession()
+
+    qs.add_qubit()
+    qs.add_qubit()
+    qs.add_clbit()
+
+    qs.h(0)
+
+    qs.rz(np.pi / 2, 0)
+
+    qs.x(0)
+    qs.cx(0, 1)
+    qs.measure(1, 0)
+
+    qs.append(qs.to_op("composed_op"), qs.qubits, qs.clbits)
+
+    qs.append(qs.to_op("multi_composed_op"), qs.qubits, qs.clbits)
+
+    print(qs)
+
+    ###################
+
+    # Create VirtualBackend
+    def sample_run_func(qc, shots):
+        print("Executing Circuit")
+        return {"0": shots}
+
+    test_virtual_backend = VirtualBackend(sample_run_func)
+
+    print(test_virtual_backend.run(qs, 100))
+    assert str(test_virtual_backend.run(qs, 100)) == "{'0': 100}"
+    assert test_virtual_backend.run(qs, 100)["0"] == 100
+
+    ###################
+
+    # Create Qiskit Backend
+    test_qiskit_backend = VirtualQiskitBackend(Aer.get_backend("qasm_simulator"))
+
+    from qrisp import QuantumCircuit
+
+    qc = QuantumCircuit(4, 1)
+    qc.x(0)
+    qc.measure(0, 0)
+
+    print(test_qiskit_backend.run(qc, 2000))
+    # status = test_qiskit_backend.ping()
+    assert str(test_qiskit_backend.run(qc, 2000)) == "{'1': 2000}"
```

### Comparing `qrisp-0.0.15/tests/test_qompiler.py` & `qrisp-0.0.16/tests/test_qompiler.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,31 +1,31 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 06.05.2022
-# import pytest
-
-
-def test_qompiler():
-    from qrisp import QuantumSession, QuantumVariable, x, cx
-
-    qs = QuantumSession()
-
-    qv_list = [QuantumVariable(1, qs = qs) for i in range(10)]
-
-    for i in range(9):
-        x(qv_list[i])
-        x(qv_list[i])
-        qv_list[i].delete()
-
-    x(qv_list[-1])
-    qc = qs.compile()
-    assert len(qc.qubits) == 1
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 06.05.2022
+# import pytest
+
+
+def test_qompiler():
+    from qrisp import QuantumSession, QuantumVariable, x, cx
+
+    qs = QuantumSession()
+
+    qv_list = [QuantumVariable(1, qs=qs) for i in range(10)]
+
+    for i in range(9):
+        x(qv_list[i])
+        x(qv_list[i])
+        qv_list[i].delete()
+
+    x(qv_list[-1])
+    qc = qs.compile()
+    assert len(qc.qubits) == 1
```

### Comparing `qrisp-0.0.15/tests/test_quantum_arithmetic.py` & `qrisp-0.0.16/tests/test_quantum_arithmetic.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,91 +8,87 @@
 *
 * SPDX-License-Identifier: EPL-2.0
 **********************************************************************/
 """
 
 
 def test_quantum_arithmetic():
-    
     import numpy as np
     from qrisp import h, multi_measurement, q_div, QuantumFloat
+
     def test_arithmetic_helper(qf_0, qf_1, operation):
-        
         qf_0 = qf_0.duplicate()
         qf_1 = qf_1.duplicate()
-        
-        h(qf_0)        
+
+        h(qf_0)
         h(qf_1)
-        
+
         if operation == "add":
             qf_res = qf_0 + qf_1
         elif operation == "sub":
             qf_res = qf_0 - qf_1
         elif operation == "mul":
             qf_res = qf_0 * qf_1
         elif operation == "div":
-            qf_res = q_div(qf_0, qf_1, prec = 3)
+            qf_res = q_div(qf_0, qf_1, prec=3)
 
         mes_res = multi_measurement([qf_0, qf_1, qf_res])
-        
-        for (a, b, c) in mes_res.keys():
-            
+
+        for a, b, c in mes_res.keys():
             if operation == "add":
                 assert a + b == c
             elif operation == "sub":
                 assert a - b == c
             elif operation == "mul":
                 assert a * b == c
             elif operation == "div":
                 if b == 0:
                     continue
-                assert abs(a / b - c) < 2**(-3)
+                assert abs(a / b - c) < 2 ** (-3)
 
         statevector = qf_res.qs.statevector("array")
-        angles = np.angle(statevector[np.abs(statevector) > 1/2**((qf_0.size + qf_1.size)/2+1)])
-        
-        #Test correct phase behavior
+        angles = np.angle(
+            statevector[
+                np.abs(statevector) > 1 / 2 ** ((qf_0.size + qf_1.size) / 2 + 1)
+            ]
+        )
+
+        # Test correct phase behavior
         assert np.sum(np.abs(angles)) < 0.1
-        
-    a = QuantumFloat(3, -1, signed = True)
-    b = QuantumFloat(5, 1, signed = False)
+
+    a = QuantumFloat(3, -1, signed=True)
+    b = QuantumFloat(5, 1, signed=False)
 
     for operation in ["add", "sub", "mul", "div"]:
         print(operation)
         test_arithmetic_helper(a, b, operation)
 
-    a = QuantumFloat(3, 1, signed = True)
-    b = QuantumFloat(3, 0, signed = True)
+    a = QuantumFloat(3, 1, signed=True)
+    b = QuantumFloat(3, 0, signed=True)
 
     for operation in ["add", "sub", "mul", "div"]:
         test_arithmetic_helper(a, b, operation)
 
-    #Test tensordot
+    # Test tensordot
     from qrisp import QuantumFloat, QuantumArray, tensordot, OutcomeArray
-    qf = QuantumFloat(3,0, signed = False)
-    q_tensor_0 = QuantumArray(qf, shape = (4,4))
+
+    qf = QuantumFloat(3, 0, signed=False)
+    q_tensor_0 = QuantumArray(qf, shape=(4, 4))
     q_tensor_0[:] = np.eye(4)
     q_tensor_0 = q_tensor_0.reshape(2, 2, 2, 2)
-    q_tensor_1 = QuantumArray(qf, shape = (2,2))
-    q_tensor_1[:] = [[0,1],[1,0]]
+    q_tensor_1 = QuantumArray(qf, shape=(2, 2))
+    q_tensor_1[:] = [[0, 1], [1, 0]]
     res = tensordot(q_tensor_0, q_tensor_1, (-1, 0))
-    
-    assert res.get_measurement() == {OutcomeArray([[[[0, 1],
-                    [0, 0]],
-
-                   [[1, 0],
-                    [0, 0]]],
-
-
-                  [[[0, 0],
-                    [0, 1]],
-
-                   [[0, 0],
-                    [1, 0]]]]): 1.0}
-    
-    #Test inplace multiplication
-    b = QuantumFloat(5, signed = True)
+
+    assert res.get_measurement() == {
+        OutcomeArray(
+            [[[[0, 1], [0, 0]], [[1, 0], [0, 0]]], [[[0, 0], [0, 1]], [[0, 0], [1, 0]]]]
+        ): 1.0
+    }
+
+    # Test inplace multiplication
+    b = QuantumFloat(5, signed=True)
     b[:] = 3
     h(b[0])
     h(b[-1])
     b *= -4
-    assert b.get_measurement() == {116: 0.25, 120: 0.25, -12: 0.25, -8: 0.25}
+    assert b.get_measurement() == {116: 0.25, 120: 0.25, -12: 0.25, -8: 0.25}
```

### Comparing `qrisp-0.0.15/tests/test_quantum_dictionary.py` & `qrisp-0.0.16/tests/test_quantum_dictionary.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,95 +1,98 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 28.06.2022
-from qrisp import QuantumDictionary, QuantumFloat, custom_qv,  h, multi_measurement, QuantumVariable
-#This example demonstrates the use of a QuantumDictionary with flexible types
-
-def test_quantum_dictionary():
-    #Create a QuantumDictionary
-    test_qd = QuantumDictionary()
-
-    #Fill in some entries (works precisely like normal Python dictionaries)
-    test_qd["hello"] = "hallo"
-    test_qd["world"] = "welt"
-
-    #Create Key QuantumVariable (the constructor takes a
-    #list of values, which the QuantumVariable is supposed to represent)
-    key_qv = custom_qv(["hello", "world"])
-
-    #Bring into superposition
-    h(key_qv)
-
-    print(key_qv)
-    assert str(key_qv) == "{'hello': 0.5, 'world': 0.5}"
-    #Yields {'hello': 0.5, 'world': 0.5}
-
-    #Use QuantumDictionary to "dereference" the values into a new QuantumVariable
-    value_qv = test_qd[key_qv]
-
-    #Evaluate values
-    print(value_qv)
-    assert str(value_qv) == "{'hallo': 0.5, 'welt': 0.5}"
-    #Yields {'hallo': 0.5, 'welt': 0.5}
-
-
-    #Now we demonstrate how a QuantumDictionary with a specified type can be created
-    #The return values from dereferencing this QuantumDictionary are now of the type QuantumFloat(4, -1)
-    float_qd = QuantumDictionary(return_type = QuantumFloat(4,-1))
-
-    #Encode some values (performed as with usual Python dictionaries)
-    float_qd.update({"hallo" : 1.5, "welt" : 0.5})
-
-    #Dereference
-    value_qf = float_qd[value_qv]
-
-    #Results are indeed QuantumFloat
-    print(type(value_qf))
-    assert type(value_qf).__name__ == 'QuantumFloat'
-
-    #Usual arithmetic is possible
-    value_qf += 2.5
-
-    #Evaluate results
-    assert value_qf.get_measurement() == {3.0: 0.5, 4.0: 0.5}
-    #Yields {4.0: 0.5, 3.0: 0.5}
-    
-    
-    test_qd[(1,2)] = 73
-    test_qd[(0,2)] = 37
-    qf1 = QuantumFloat(1)
-    qf2 = QuantumFloat(2)
-    h(qf1)
-    qf2[:] = 2
-    res = test_qd[(qf1, qf2)]
-    assert multi_measurement([qf1, qf2, res]) == {(0, 2, 37): 0.5, (1, 2, 73): 0.5}
-    
-    
-    qtype = QuantumFloat(4, -2, signed = True)
-
-    float_qd = QuantumDictionary(return_type = qtype)
-
-    float_qd["hello"] = 0.5
-    float_qd["world"] = -1
-    key_qv = QuantumVariable.custom([1, 42, "hello", "world"])
-    key_qv[:] = {"hello" : 1, "world" : 1}
-
-
-    qf = qtype.duplicate()
-    float_qd.load(key_qv, qf)
-
-    qf2 = qtype.duplicate()
-    float_qd.load(key_qv, qf2, synth_method = "pprm")
-    
-    assert qf2.get_measurement() == {0.5: 0.5, -1.0: 0.5}
-    
-    
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 28.06.2022
+from qrisp import (
+    QuantumDictionary,
+    QuantumFloat,
+    custom_qv,
+    h,
+    multi_measurement,
+    QuantumVariable,
+)
+
+# This example demonstrates the use of a QuantumDictionary with flexible types
+
+
+def test_quantum_dictionary():
+    # Create a QuantumDictionary
+    test_qd = QuantumDictionary()
+
+    # Fill in some entries (works precisely like normal Python dictionaries)
+    test_qd["hello"] = "hallo"
+    test_qd["world"] = "welt"
+
+    # Create Key QuantumVariable (the constructor takes a
+    # list of values, which the QuantumVariable is supposed to represent)
+    key_qv = custom_qv(["hello", "world"])
+
+    # Bring into superposition
+    h(key_qv)
+
+    print(key_qv)
+    assert str(key_qv) == "{'hello': 0.5, 'world': 0.5}"
+    # Yields {'hello': 0.5, 'world': 0.5}
+
+    # Use QuantumDictionary to "dereference" the values into a new QuantumVariable
+    value_qv = test_qd[key_qv]
+
+    # Evaluate values
+    print(value_qv)
+    assert str(value_qv) == "{'hallo': 0.5, 'welt': 0.5}"
+    # Yields {'hallo': 0.5, 'welt': 0.5}
+
+    # Now we demonstrate how a QuantumDictionary with a specified type can be created
+    # The return values from dereferencing this QuantumDictionary are now of the type QuantumFloat(4, -1)
+    float_qd = QuantumDictionary(return_type=QuantumFloat(4, -1))
+
+    # Encode some values (performed as with usual Python dictionaries)
+    float_qd.update({"hallo": 1.5, "welt": 0.5})
+
+    # Dereference
+    value_qf = float_qd[value_qv]
+
+    # Results are indeed QuantumFloat
+    print(type(value_qf))
+    assert type(value_qf).__name__ == "QuantumFloat"
+
+    # Usual arithmetic is possible
+    value_qf += 2.5
+
+    # Evaluate results
+    assert value_qf.get_measurement() == {3.0: 0.5, 4.0: 0.5}
+    # Yields {4.0: 0.5, 3.0: 0.5}
+
+    test_qd[(1, 2)] = 73
+    test_qd[(0, 2)] = 37
+    qf1 = QuantumFloat(1)
+    qf2 = QuantumFloat(2)
+    h(qf1)
+    qf2[:] = 2
+    res = test_qd[(qf1, qf2)]
+    assert multi_measurement([qf1, qf2, res]) == {(0, 2, 37): 0.5, (1, 2, 73): 0.5}
+
+    qtype = QuantumFloat(4, -2, signed=True)
+
+    float_qd = QuantumDictionary(return_type=qtype)
+
+    float_qd["hello"] = 0.5
+    float_qd["world"] = -1
+    key_qv = QuantumVariable.custom([1, 42, "hello", "world"])
+    key_qv[:] = {"hello": 1, "world": 1}
+
+    qf = qtype.duplicate()
+    float_qd.load(key_qv, qf)
+
+    qf2 = qtype.duplicate()
+    float_qd.load(key_qv, qf2, synth_method="pprm")
+
+    assert qf2.get_measurement() == {0.5: 0.5, -1.0: 0.5}
```

### Comparing `qrisp-0.0.15/tests/test_quantum_division.py` & `qrisp-0.0.16/tests/test_quantum_division.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,34 +1,35 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 06.05.2022
-from qrisp.arithmetic import QuantumFloat, q_divmod
-from qrisp.misc import multi_measurement
-
-def test_quantum_divison():
-    numerator = QuantumFloat(3, -2, signed = True)
-    divisor = QuantumFloat(3, -2, signed = True)
-
-    n = 4/8
-    d = -5/4
-    numerator.encode(n)
-    divisor.encode(d)
-
-    prec = 4
-    quotient, remainder = q_divmod(numerator, divisor, prec = prec, adder = "thapliyal")
-
-    q, r = list(multi_measurement([quotient, remainder]))[0]
-
-    print("Q: ", q)
-    print("delta_Q: ", abs(q-n/d))
-    print("R: ", r)
-    assert q == -0.375 and r == 0.03125 and abs(q-n/d) < 2**-prec
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 06.05.2022
+from qrisp.arithmetic import QuantumFloat, q_divmod
+from qrisp.misc import multi_measurement
+
+
+def test_quantum_divison():
+    numerator = QuantumFloat(3, -2, signed=True)
+    divisor = QuantumFloat(3, -2, signed=True)
+
+    n = 4 / 8
+    d = -5 / 4
+    numerator.encode(n)
+    divisor.encode(d)
+
+    prec = 4
+    quotient, remainder = q_divmod(numerator, divisor, prec=prec, adder="thapliyal")
+
+    q, r = list(multi_measurement([quotient, remainder]))[0]
+
+    print("Q: ", q)
+    print("delta_Q: ", abs(q - n / d))
+    print("R: ", r)
+    assert q == -0.375 and r == 0.03125 and abs(q - n / d) < 2**-prec
```

### Comparing `qrisp-0.0.15/tests/test_quantum_teleportation.py` & `qrisp-0.0.16/tests/test_quantum_teleportation.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,173 +1,168 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 22.07.2022
-from qrisp.quantum_network import QuantumNetwork
-import random
-import numpy as np
-import time
-
-
-
-def test_quantum_teleportation():
-    # In this example we will demonstrate Qrisps quantum network simulator
-    # by performing a teleportation
-
-    # Create a Server - this server will keep track of the participants
-    # and simulate the state of the network
-    qn = QuantumNetwork()
-
-    # Register clients
-    qn.register_client("alice")
-    qn.register_client("bob")
-
-
-    # Create Bell-Pair function
-    def share_bell_pair(qn, recipient_0, recipient_1):
-
-        client_name = "bell_pair_distributor_" + str(random.randint(0, int(1E6)))
-        qn.register_client(client_name)
-
-        qn.request_qubits(2, client_name)
-
-        telamon_qc = qn.get_clear_qc(client_name)
-
-        telamon_qc.h(0)
-        telamon_qc.cx(0, 1)
-
-        qn.run(telamon_qc, client_name)
-
-        qn.send_qubits(client_name, recipient_0, [telamon_qc.qubits[0]], "")
-        qn.send_qubits(client_name, recipient_1, [telamon_qc.qubits[1]], "")
-
-        return telamon_qc.qubits[0], telamon_qc.qubits[1]
-
-
-    def teleport_qubit(qn, alice, bob, teleported_qubit):
-        # Share Bell-Pair
-        bell_pair_0, bell_pair_1 = share_bell_pair(qn, alice, bob)
-
-        # Get the updated circuit for alice (now contains one half of the bell-pair)
-        alice_qc = qn.get_clear_qc(alice)
-
-        # Perform the Alice's steps of the quantum teleportation protocol
-        alice_qc.cx(teleported_qubit, bell_pair_0)
-        alice_qc.h(teleported_qubit)
-        alice_qc.measure(bell_pair_0)
-        alice_qc.measure(teleported_qubit)
-
-        # Execute the circuit
-        alice_res = qn.run(alice_qc, alice)
-
-        # Perform Bob's steps of the quantum teleportation protocol
-        bob_qc = qn.get_clear_qc(bob)
-
-        # The information about the outcome alice_res is transfered via a classical channel
-        if list(alice_res.keys())[0][0] == "1":
-            bob_qc.x(bell_pair_1)
-
-        if list(alice_res.keys())[0][1] == "1":
-            bob_qc.z(bell_pair_1)
-
-        return bell_pair_1
-
-    qn.request_qubits(2, "alice")
-
-    # Get clear circuit for alice
-    alice_qc = qn.get_clear_qc("alice")
-    
-    # Apply some arbitrary transformation (the resulting state is teleported to bob)
-    # alice_qc.rx(np.pi/2, 0)
-    
-    qn.run(alice_qc, "alice")
-
-    recieved_qubit = teleport_qubit(qn, "alice", "bob", alice_qc.qubits[0])
-
-    # Check the teleported_qubit
-    bob_qc = qn.get_clear_qc("bob")
-    # Measure the teleported qubit
-    bob_qc.measure(recieved_qubit)
-
-    qn.run(bob_qc, "bob")
-
-    def gen_random_bitstring(size):
-        res = np.zeros(size)
-        for i in range(size):
-            if random.random() > 0.5:
-                res[i] = 1
-        return res
-
-
-    n = 50
-
-    start_time = time.time()
-    qn = QuantumNetwork()
-
-    qn.register_client("alice")
-    qn.request_qubits(n, "alice")
-    alice_qc = qn.get_clear_qc("alice")
-
-    qn.register_client("bob")
-    qn.request_qubits(0, "bob")
-    bob_qc = qn.get_clear_qc("bob")
-    a = gen_random_bitstring(n)
-    b = gen_random_bitstring(n)
-
-    for i in range(n):
-        if a[i] == 1:
-            alice_qc.x(i)
-        if b[i] == 1:
-            alice_qc.h(i)
-
-    qn.run(alice_qc, "alice")
-
-    tp_qubits = []
-    for i in range(n):
-        tp_qubit = teleport_qubit(qn, "alice", "bob", alice_qc.qubits[i])
-        tp_qubits.append(tp_qubit)
-        # qn.send_qubit("alice", "bob", alice_qc.qubits[i])
-
-    bob_qc = qn.get_clear_qc("bob")
-
-    b_prime = gen_random_bitstring(n)
-
-    for i in range(n):
-        if b_prime[i] == 1:
-            bob_qc.h(tp_qubits[i])
-        bob_qc.measure(tp_qubits[i])
-
-    res = qn.run(bob_qc, "bob")
-    res = list(res.keys())[0]
-    res = np.array([int(c) for c in res])
-
-    congruent_b = (b == b_prime)
-
-    temp_key_bob = res[congruent_b]
-    temp_key_alice = a[congruent_b]
-    k = len(temp_key_bob)
-
-    if np.all(temp_key_bob[:k // 2] == temp_key_alice[:k // 2]):
-        raise Exception("Evesdropper detected!")
-
-    shared_key = temp_key_bob[k // 2:]
-
-    print(shared_key)
-    assert all(i == 0 or i == 1 for i in shared_key)
-
-    print(len(shared_key))
-    assert len(shared_key) < 20
-
-    print("Transmission rate: ", len(shared_key) / (time.time() - start_time))
-    assert len(shared_key) / (time.time() - start_time) < 50
-    overall_qc = qn.get_overall_qc()
-    print(len(overall_qc.qubits))
-    assert len(overall_qc.qubits) == 150
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 22.07.2022
+from qrisp.quantum_network import QuantumNetwork
+import random
+import numpy as np
+import time
+
+
+def test_quantum_teleportation():
+    # In this example we will demonstrate Qrisps quantum network simulator
+    # by performing a teleportation
+
+    # Create a Server - this server will keep track of the participants
+    # and simulate the state of the network
+    qn = QuantumNetwork()
+
+    # Register clients
+    qn.register_client("alice")
+    qn.register_client("bob")
+
+    # Create Bell-Pair function
+    def share_bell_pair(qn, recipient_0, recipient_1):
+        client_name = "bell_pair_distributor_" + str(random.randint(0, int(1e6)))
+        qn.register_client(client_name)
+
+        qn.request_qubits(2, client_name)
+
+        telamon_qc = qn.get_clear_qc(client_name)
+
+        telamon_qc.h(0)
+        telamon_qc.cx(0, 1)
+
+        qn.run(telamon_qc, client_name)
+
+        qn.send_qubits(client_name, recipient_0, [telamon_qc.qubits[0]], "")
+        qn.send_qubits(client_name, recipient_1, [telamon_qc.qubits[1]], "")
+
+        return telamon_qc.qubits[0], telamon_qc.qubits[1]
+
+    def teleport_qubit(qn, alice, bob, teleported_qubit):
+        # Share Bell-Pair
+        bell_pair_0, bell_pair_1 = share_bell_pair(qn, alice, bob)
+
+        # Get the updated circuit for alice (now contains one half of the bell-pair)
+        alice_qc = qn.get_clear_qc(alice)
+
+        # Perform the Alice's steps of the quantum teleportation protocol
+        alice_qc.cx(teleported_qubit, bell_pair_0)
+        alice_qc.h(teleported_qubit)
+        alice_qc.measure(bell_pair_0)
+        alice_qc.measure(teleported_qubit)
+
+        # Execute the circuit
+        alice_res = qn.run(alice_qc, alice)
+
+        # Perform Bob's steps of the quantum teleportation protocol
+        bob_qc = qn.get_clear_qc(bob)
+
+        # The information about the outcome alice_res is transfered via a classical channel
+        if list(alice_res.keys())[0][0] == "1":
+            bob_qc.x(bell_pair_1)
+
+        if list(alice_res.keys())[0][1] == "1":
+            bob_qc.z(bell_pair_1)
+
+        return bell_pair_1
+
+    qn.request_qubits(2, "alice")
+
+    # Get clear circuit for alice
+    alice_qc = qn.get_clear_qc("alice")
+
+    # Apply some arbitrary transformation (the resulting state is teleported to bob)
+    # alice_qc.rx(np.pi/2, 0)
+
+    qn.run(alice_qc, "alice")
+
+    recieved_qubit = teleport_qubit(qn, "alice", "bob", alice_qc.qubits[0])
+
+    # Check the teleported_qubit
+    bob_qc = qn.get_clear_qc("bob")
+    # Measure the teleported qubit
+    bob_qc.measure(recieved_qubit)
+
+    qn.run(bob_qc, "bob")
+
+    def gen_random_bitstring(size):
+        res = np.zeros(size)
+        for i in range(size):
+            if random.random() > 0.5:
+                res[i] = 1
+        return res
+
+    n = 50
+
+    start_time = time.time()
+    qn = QuantumNetwork()
+
+    qn.register_client("alice")
+    qn.request_qubits(n, "alice")
+    alice_qc = qn.get_clear_qc("alice")
+
+    qn.register_client("bob")
+    qn.request_qubits(0, "bob")
+    bob_qc = qn.get_clear_qc("bob")
+    a = gen_random_bitstring(n)
+    b = gen_random_bitstring(n)
+
+    for i in range(n):
+        if a[i] == 1:
+            alice_qc.x(i)
+        if b[i] == 1:
+            alice_qc.h(i)
+
+    qn.run(alice_qc, "alice")
+
+    tp_qubits = []
+    for i in range(n):
+        tp_qubit = teleport_qubit(qn, "alice", "bob", alice_qc.qubits[i])
+        tp_qubits.append(tp_qubit)
+        # qn.send_qubit("alice", "bob", alice_qc.qubits[i])
+
+    bob_qc = qn.get_clear_qc("bob")
+
+    b_prime = gen_random_bitstring(n)
+
+    for i in range(n):
+        if b_prime[i] == 1:
+            bob_qc.h(tp_qubits[i])
+        bob_qc.measure(tp_qubits[i])
+
+    res = qn.run(bob_qc, "bob")
+    res = list(res.keys())[0]
+    res = np.array([int(c) for c in res])
+
+    congruent_b = b == b_prime
+
+    temp_key_bob = res[congruent_b]
+    temp_key_alice = a[congruent_b]
+    k = len(temp_key_bob)
+
+    if np.all(temp_key_bob[: k // 2] == temp_key_alice[: k // 2]):
+        raise Exception("Evesdropper detected!")
+
+    shared_key = temp_key_bob[k // 2 :]
+
+    print(shared_key)
+    assert all(i == 0 or i == 1 for i in shared_key)
+
+    print(len(shared_key))
+    assert len(shared_key) < 20
+
+    print("Transmission rate: ", len(shared_key) / (time.time() - start_time))
+    assert len(shared_key) / (time.time() - start_time) < 50
+    overall_qc = qn.get_overall_qc()
+    print(len(overall_qc.qubits))
+    assert len(overall_qc.qubits) == 150
```

### Comparing `qrisp-0.0.15/tests/test_string_test.py` & `qrisp-0.0.16/tests/test_string_test.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,43 +1,40 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 22.07.2022
-from qrisp import QuantumString, QuantumChar
-
-def test_string_test():
-    q_str = QuantumString()
-
-    q_str_2 = QuantumString()
-
-    q_ch = QuantumChar()
-
-    q_str[:] = "hello"
-
-    q_ch[:] = " "
-
-    q_str_2[:] = "world"
-
-
-    q_str += q_ch
-
-
-    q_str += q_str_2
-
-
-    q_str += "! "
-
-
-    q_str_3 = q_str.duplicate(init = True)
-
-    assert (type(q_str).__name__ and type(q_str_3).__name__) == 'QuantumString'
-    assert str(q_str + q_str_3) == "{'hello world! hello world! ': 1.0}"
-    print(q_str + q_str_3)
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 22.07.2022
+from qrisp import QuantumString, QuantumChar
+
+
+def test_string_test():
+    q_str = QuantumString()
+
+    q_str_2 = QuantumString()
+
+    q_ch = QuantumChar()
+
+    q_str[:] = "hello"
+
+    q_ch[:] = " "
+
+    q_str_2[:] = "world"
+
+    q_str += q_ch
+
+    q_str += q_str_2
+
+    q_str += "! "
+
+    q_str_3 = q_str.duplicate(init=True)
+
+    assert (type(q_str).__name__ and type(q_str_3).__name__) == "QuantumString"
+    assert str(q_str + q_str_3) == "{'hello world! hello world! ': 1.0}"
+    print(q_str + q_str_3)
```

### Comparing `qrisp-0.0.15/tests/test_unitary_calculation.py` & `qrisp-0.0.16/tests/test_unitary_calculation.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,58 +1,57 @@
-"""
-/*********************************************************************
-* Copyright (c) 2023 the Qrisp Authors
-*
-* This program and the accompanying materials are made
-* available under the terms of the Eclipse Public License 2.0
-* which is available at https://www.eclipse.org/legal/epl-2.0/
-*
-* SPDX-License-Identifier: EPL-2.0
-**********************************************************************/
-"""
-
-# Created by ann81984 at 07.05.2022
-import time
-
-from qrisp.core import QuantumSession
-from qrisp.arithmetic import QuantumFloat
-from numpy.linalg import norm
-from qiskit import execute, Aer
-from qrisp.interface import convert_circuit
-
-def test_unitary_calculation():
-    n = 2
-
-    qs = QuantumSession()
-
-    x = QuantumFloat(n, 0, qs, signed = True)
-    y = QuantumFloat(n, 0, qs, signed = False)
-
-    s = x*y
-    #qs = s.qs
-    qc = qs.compile()
-    
-    start = time.time()
-    test_unitary_1 = qc.get_unitary()
-    end = time.time()
-
-    print("Qrisp calculation time = %s" % (end - start))
-
-
-
-    ###################
-    qc.qubits = qc.qubits[::-1]
-    qiskit_qc = convert_circuit(qc, target_api = "qiskit")
-
-    backend = Aer.get_backend('unitary_simulator')
-
-    start = time.time()
-    job = execute(qiskit_qc, backend)
-    result = job.result()
-    test_unitary_2 = result.get_unitary(qiskit_qc).data
-    end = time.time()
-
-    print("Qiskit calculation time = %s" % (end - start))
-
-    #get the unitary matrix from the result object
-    print("Unitaries matching:", bool(norm(test_unitary_1 - test_unitary_2) < 1E-3))
-    assert bool(norm(test_unitary_1 - test_unitary_2) < 1E-3)
+"""
+/*********************************************************************
+* Copyright (c) 2023 the Qrisp Authors
+*
+* This program and the accompanying materials are made
+* available under the terms of the Eclipse Public License 2.0
+* which is available at https://www.eclipse.org/legal/epl-2.0/
+*
+* SPDX-License-Identifier: EPL-2.0
+**********************************************************************/
+"""
+
+# Created by ann81984 at 07.05.2022
+import time
+
+from qrisp.core import QuantumSession
+from qrisp.arithmetic import QuantumFloat
+from numpy.linalg import norm
+from qiskit import execute, Aer
+from qrisp.interface import convert_circuit
+
+
+def test_unitary_calculation():
+    n = 2
+
+    qs = QuantumSession()
+
+    x = QuantumFloat(n, 0, qs, signed=True)
+    y = QuantumFloat(n, 0, qs, signed=False)
+
+    s = x * y
+    # qs = s.qs
+    qc = qs.compile()
+
+    start = time.time()
+    test_unitary_1 = qc.get_unitary()
+    end = time.time()
+
+    print("Qrisp calculation time = %s" % (end - start))
+
+    ###################
+    qc.qubits = qc.qubits[::-1]
+    qiskit_qc = convert_circuit(qc, target_api="qiskit")
+
+    backend = Aer.get_backend("unitary_simulator")
+
+    start = time.time()
+    job = execute(qiskit_qc, backend)
+    result = job.result()
+    test_unitary_2 = result.get_unitary(qiskit_qc).data
+    end = time.time()
+
+    print("Qiskit calculation time = %s" % (end - start))
+
+    # get the unitary matrix from the result object
+    print("Unitaries matching:", bool(norm(test_unitary_1 - test_unitary_2) < 1e-3))
+    assert bool(norm(test_unitary_1 - test_unitary_2) < 1e-3)
```

